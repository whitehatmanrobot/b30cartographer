etric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;
    _drive = Drive;

    if (!_drive) {
        return FALSE;
    }

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}

VOID
ATTR_LIST_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetRange(WindowHandle, _size/3);
}

STATIC TCHAR buf[1024];

VOID
ATTR_LIST_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    PTCHAR  pc;
    TCHAR   sbFlags[32];
    ULONG   LengthOfList = _size;
    ULONG   CurrentOffset;
    ULONG   CurrentLine = 0;

    SetScrollRange(WindowHandle, SB_VERT, 0, _size/3, FALSE);
    SetScrollPos(WindowHandle, SB_VERT, QueryScrollPosition(), TRUE);

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || !_size) {
        return;
    }

    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)((PCHAR)_buffer);
    CurrentOffset = 0;

    while (CurrentOffset < LengthOfList) {

        if (0 != CurrentOffset) {
            CurrentLine++;
        }

        PTCHAR SymbolicTypeCode = GetNtfsAttributeTypeCodeName(
            CurrentEntry->AttributeTypeCode);

        swprintf(buf, TEXT("Attribute type code: \t%x (%s)"),
            CurrentEntry->AttributeTypeCode, SymbolicTypeCode);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Record length \t\t%x"), CurrentEntry->RecordLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Attribute name length \t%x"),
            CurrentEntry->AttributeNameLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Attribute name offset \t%x"),
            CurrentEntry->AttributeNameOffset);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Lowest vcn \t\t<%x,%x>"),
            CurrentEntry->LowestVcn.GetHighPart(),
            CurrentEntry->LowestVcn.GetLowPart());
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Segment reference: \t<%x,%x>"),
            CurrentEntry->SegmentReference.HighPart,
            CurrentEntry->SegmentReference.LowPart,
            CurrentEntry->SegmentReference.SequenceNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Sequence number: \t%x"),
            CurrentEntry->SegmentReference.SequenceNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Instance: \t\t%x"), CurrentEntry->Instance);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Attribute name:\t\t"));
        pc = buf + wcslen(buf);

        for (int i = 0; i < min(64, CurrentEntry->AttributeNameLength); ++i) {
            *pc++ = (CHAR)CurrentEntry->AttributeName[i];
        }
        *pc++ = '\0';

        if (CurrentEntry->AttributeNameLength > 64) {
            wcscat(buf, TEXT("..."));
        }
        WriteLine(DeviceContext, CurrentLine++, buf);

        if (CurrentEntry->RecordLength == 0) {
            break;
        }

        CurrentOffset += CurrentEntry->RecordLength;
        CurrentEntry = NextEntry(CurrentEntry);
    }
}

VOID
ATTR_LIST_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
ATTR_LIST_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\diskedit.cxx ===
#include "ulib.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "ntfssa.hxx"
#include "frs.hxx"
#include "attrib.hxx"
#include "mftfile.hxx"
#include "bitfrs.hxx"
#include "ntfsbit.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "rfatsa.hxx"
#include "secio.hxx"
#include "clusio.hxx"
#include "frsio.hxx"
#include "rootio.hxx"
#include "chainio.hxx"
#include "fileio.hxx"
#include "logrecio.hxx"
#include "secedit.hxx"
#include "frsedit.hxx"
#include "indxedit.hxx"
#include "secstr.hxx"
#include "bootedit.hxx"
#include "nbedit.hxx"
#include "ofsbedit.hxx"
#include "partedit.hxx"
#include "gptedit.hxx"
#include "restarea.hxx"
#include "logreced.hxx"
#include "rcache.hxx"
#include "hmem.hxx"
#include "attrio.hxx"
#include "recordpg.hxx"
#include "crack.hxx"
#include "atrlsted.hxx"
#include "diskedit.h"

extern "C" {
    #include <stdio.h>
}

DECLARE_CLASS( IO_COUPLE );

class IO_COUPLE : public OBJECT {

    public:

        DECLARE_CONSTRUCTOR( IO_COUPLE );

        VIRTUAL
        ~IO_COUPLE(
            ) { Destroy(); };

        PHMEM           Mem;
        PIO_OBJECT      IoObject;
        PEDIT_OBJECT    EditObject;
        PEDIT_OBJECT    OtherEditObject;
        PEDIT_OBJECT    SplitEditObject;

    private:

        NONVIRTUAL
        VOID
        Construct() {
            Mem = NULL;
            IoObject = NULL;
            EditObject = NULL;
            OtherEditObject = NULL;
            SplitEditObject = NULL;
        };

        NONVIRTUAL
        VOID
        Destroy(
            );

};

enum SPLIT_OPERATION {
    eSplitToggle,
    eSplitCreate,
    eSplitDestroy,
    eSplitQuery
};

extern BOOLEAN SplitView(HWND, SPLIT_OPERATION);


DEFINE_CONSTRUCTOR( IO_COUPLE, OBJECT );


VOID
IO_COUPLE::Destroy(
    )
{
    DELETE(Mem);
    DELETE(IoObject);
    DELETE(EditObject);
    DELETE(OtherEditObject);
    DELETE(SplitEditObject);
}

#define IoCoupleSetEdit(IoCouple,type,hWnd,hwndChild,ClientHeight,ClientWidth,Drive) \
{                                                                           \
    VERTICAL_TEXT_SCROLL *V = NEW type;                                     \
                                                                            \
    do {                                                                    \
                                                                            \
        if (NULL == V) {                                                    \
            ReportError(hwndChild, 0);                                      \
            continue;                                                       \
        }                                                                   \
        if (!V->Initialize(hwndChild, ClientHeight, ClientWidth, Drive)) {  \
            DELETE(V);                                                      \
            ReportError(hWnd, 0);                                           \
            continue;                                                       \
        }                                                                   \
                                                                            \
        IoCouple->EditObject->KillFocus(hwndChild);                         \
        DELETE(IoCouple->OtherEditObject);                                  \
        IoCouple->OtherEditObject = IoCouple->EditObject;                   \
        IoCouple->EditObject = V;                                           \
        IoCouple->IoObject->GetBuf(&size);                                  \
        IoCouple->EditObject->SetBuf(hwndChild,                             \
            IoCouple->IoObject->GetBuf(), size);                            \
        IoCouple->EditObject->SetFocus(hwndChild);                          \
        InvalidateRect(hwndChild, NULL, TRUE);                              \
                                                                            \
        if (NULL != hwndSplit) {                                            \
            if (NULL == (V = NEW type)) {                                   \
                ReportError(hwndSplit, 0);                                  \
                continue;                                                   \
            }                                                               \
            if (!V->Initialize(hwndSplit, ClientHeight,                     \
                    ClientWidth, Drive)) {                                  \
                DELETE(V);                                                  \
                ReportError(hWnd, 0);                                       \
                continue;                                                   \
            }                                                               \
                                                                            \
            IoCouple->SplitEditObject = V;                                  \
            IoCouple->IoObject->GetBuf(&size);                              \
            IoCouple->SplitEditObject->SetBuf(hwndSplit,                    \
                IoCouple->IoObject->GetBuf(), size);                        \
        }                                                                   \
    } while ( 0 );                                                          \
}



PLOG_IO_DP_DRIVE Drive = NULL;
LSN              Lsn;

STATIC HINSTANCE        hInst;
STATIC PIO_COUPLE       IoCouple = NULL;
STATIC PLIST            IoList = NULL;
STATIC PITERATOR        IoListIterator = NULL;
STATIC INT              ClientHeight = 0;
STATIC INT              ClientWidth = 0;
STATIC INT              BacktrackFileNumber;

BOOLEAN
DbgOutput(
    PCHAR   Stuff
    )
{
    OutputDebugStringA(Stuff);
    return TRUE;
}


VOID
ReportError(
    IN  HWND    hWnd,
    IN  ULONG   Error
    )
{
    FARPROC lpProc;
    TCHAR message[64];

    lpProc = MakeProcInstance((FARPROC) About, hInst);
    DialogBox(hInst, TEXT("ErrorBox"), hWnd, (DLGPROC) lpProc);
    FreeProcInstance(lpProc);

    if (0 != Error) {
        wsprintf(message, TEXT("Error code: 0x%x\n"), Error);
        MessageBox(hWnd, message, TEXT("Error Information"), MB_OK|MB_ICONINFORMATION);
    }
}


INT
WinMain(
    IN  HINSTANCE  hInstance,
    IN  HINSTANCE  hPrevInstance,
    IN  LPSTR   lpCmdLine,
    IN  INT     nCmdShow
    )
{
    MSG     msg;
    HACCEL  hAccel;
    HWND    hWnd;
    HICON   hIcon;

    if (!hPrevInstance && !InitApplication(hInstance)) {
        return FALSE;
    }

    if (!InitInstance(hInstance, nCmdShow, &hWnd, &hAccel)) {
        return FALSE;
    }

    while (GetMessage(&msg, NULL, NULL, NULL)) {
        if (!TranslateAccelerator(hWnd, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return (int)msg.wParam;
}


BOOLEAN
InitApplication(
    IN  HINSTANCE  hInstance
    )
{
    WNDCLASS  wc;

    //
    // Class for the normal viewing window
    //

    wc.style = NULL;
    wc.lpfnWndProc = ChildWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, TEXT("diskedit"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("ChildWinClass");

    if (0 == RegisterClass(&wc))
        return 0;

    //
    // Class for the split, byte-view window.
    //

    wc.style = NULL;
    wc.lpfnWndProc = SplitWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("SplitWinClass");

    if (0 == RegisterClass(&wc))
        return 0;

    //
    // Class for the parent window.
    //

    wc.style = NULL;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, TEXT("diskedit"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  TEXT("DiskEditMenu");
    wc.lpszClassName = TEXT("DiskEditWinClass");

    if (0 == RegisterClass(&wc))
        return 0;

    return 1;
}


BOOLEAN
InitInstance(
    IN  HINSTANCE  hInstance,
    IN  INT     nCmdShow,
    OUT HWND*   phWnd,
    OUT HACCEL* hAccel
    )
{
    HDC         hdc;
    TEXTMETRIC  textmetric;


    hInst = hInstance;

    hdc = GetDC(NULL);
    if (hdc == NULL)
        return FALSE;
    SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT));
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(NULL, hdc);

    *phWnd = CreateWindow(
        TEXT("DiskEditWinClass"),
        TEXT("DiskEdit"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        84*textmetric.tmMaxCharWidth,
        36*(textmetric.tmExternalLeading + textmetric.tmHeight),
        NULL,
        NULL,
        hInstance,
        NULL
        );
    if (NULL == *phWnd) {
        return FALSE;
    }

    *hAccel = (HACCEL) LoadAccelerators(hInst, TEXT("DiskEditAccel"));

    ShowWindow(*phWnd, nCmdShow);
    UpdateWindow(*phWnd);

    return TRUE;
}

BOOL
FrsNumberDialogProc(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
/*++

Routine Description:

    This is the dialog procedure for the dialog box which queries
    an FRS number to backtrack.

Arguments:

    hDlg    --  identifies the dialog box
    message --  supplies the message ID received by the dialog box
    wParam  --  message-type-dependent parameter
    lParam  --  message-type-dependent parameter

Returns:

    TRUE if this procedure handled the message, FALSE if it
    did not.

--*/
{
    UNREFERENCED_PARAMETER(lParam);

    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                TCHAR buf[1024];
                INT n;

                n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;
                swscanf(buf, TEXT("%x"), &BacktrackFileNumber);

                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}

STATIC HWND hwndChild = NULL;
STATIC HWND hwndSplit = NULL;

LRESULT
MainWndProc(
    IN  HWND    hWnd,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    FARPROC             lpProc;
    HDC                 hDC;
    PAINTSTRUCT         ps;

    PDOS_BOOT_EDIT      boot_edit;
    PNTFS_BOOT_EDIT     ntboot_edit;
    PPARTITION_TABLE_EDIT part_edit;
    PGUID_PARTITION_TABLE_EDIT guid_part_edit;
    PRESTART_AREA_EDIT  rest_area_edit;
    PRECORD_PAGE_EDIT   rec_page_edit;
    PLOG_RECORD_EDIT    log_rec_edit;
    ULONG               size;
    WORD                command;
    BOOLEAN             error;
    ULONG               error_status = 0;
    PIO_COUPLE          next_couple;
    PEDIT_OBJECT        tmp_edit;

    switch (message) {
    case WM_SETFOCUS:

        IoCouple->EditObject->SetFocus(hwndChild);
        break;

    case WM_CREATE:

       if (!DEFINE_CLASS_DESCRIPTOR( IO_COUPLE ) ||
            !(IoCouple = NEW IO_COUPLE) ||
            !(IoCouple->IoObject = NEW IO_OBJECT) ||
            !(IoCouple->EditObject = NEW EDIT_OBJECT) ||
            !(IoCouple->OtherEditObject = NEW EDIT_OBJECT) ||
            !(IoList = NEW LIST) ||
            !IoList->Initialize() ||
            !IoList->Put((POBJECT) IoCouple) ||
            !(IoListIterator = IoList->QueryIterator()) ||
            !IoListIterator->GetNext()) {

            PostQuitMessage(0);
        }

        hwndChild = CreateWindow(
            TEXT("ChildWinClass"),
            TEXT("PrimaryView"),
            WS_CHILD|WS_CLIPSIBLINGS|WS_VISIBLE,
            0, 0,
            ClientWidth, ClientHeight,
            hWnd,
            NULL,
            hInst,
            NULL
            );
        if (NULL == hwndChild) {
            int error = GetLastError();
            PostQuitMessage(0);
        }

        ShowWindow(hwndChild, SW_SHOW);
        UpdateWindow(hwndChild);

        SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth, ClientHeight,
            SWP_SHOWWINDOW);

        break;

    case WM_SIZE:
        ClientHeight = HIWORD(lParam);
        ClientWidth = LOWORD(lParam);

        if (NULL == hwndSplit) {
            IoCouple->EditObject->ClientSize(ClientHeight, ClientWidth);

            SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth, ClientHeight,
                SWP_SHOWWINDOW);
        } else {
            IoCouple->EditObject->ClientSize(ClientHeight, ClientWidth / 2);
            IoCouple->SplitEditObject->ClientSize(ClientHeight, ClientWidth / 2);

            SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth / 2,
                ClientHeight, SWP_SHOWWINDOW);

            SetWindowPos(hwndSplit, HWND_TOP, ClientWidth / 2, 0,
                ClientWidth / 2, ClientHeight, SWP_SHOWWINDOW);
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDM_ABOUT:
            lpProc = MakeProcInstance((FARPROC) About, hInst);
            DialogBox(hInst, TEXT("AboutBox"), hWnd, (DLGPROC) lpProc);
            FreeProcInstance(lpProc);
            break;

        case IDM_EXIT:
            DestroyWindow(hWnd);
            break;

        case IDM_OPEN:
            lpProc = MakeProcInstance((FARPROC) OpenVolume, hInst);
            if (!DialogBox(hInst, TEXT("OpenVolumeBox"), hWnd, (DLGPROC) lpProc)) {
                ReportError(hWnd, 0);
            }
            FreeProcInstance(lpProc);

            SplitView(hWnd, eSplitDestroy);

            IoCouple->EditObject->KillFocus(hwndChild);
            IoListIterator->Reset();
            IoList->DeleteAllMembers();

            if (!(IoCouple = NEW IO_COUPLE) ||
                !(IoCouple->IoObject = NEW IO_OBJECT) ||
                !(IoCouple->EditObject = NEW EDIT_OBJECT) ||
                !(IoCouple->OtherEditObject = NEW EDIT_OBJECT) ||
                !IoList->Initialize() ||
                !IoList->Put(IoCouple) ||
                !IoListIterator->GetNext()) {

                PostQuitMessage(0);
            }
            SetWindowText(hWnd, TEXT("DiskEdit"));
            InvalidateRect(hWnd, NULL, TRUE);
            InvalidateRect(hwndChild, NULL, TRUE);
            break;

        case IDM_READ_SECTORS:
        case IDM_READ_CLUSTERS:
        case IDM_READ_FRS:
        case IDM_READ_ROOT:
        case IDM_READ_CHAIN:
        case IDM_READ_FILE:
        case IDM_READ_ATTRIBUTE:
        case IDM_READ_LOG_RECORD:
            if (!(next_couple = NEW IO_COUPLE)) {
                break;
            }

            switch (LOWORD(wParam)) {

            case IDM_READ_SECTORS:
                next_couple->IoObject = NEW SECTOR_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_CLUSTERS:
                next_couple->IoObject = NEW CLUSTER_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_FRS:
                next_couple->IoObject = NEW FRS_IO;
                command = IDM_VIEW_FRS;
                break;

            case IDM_READ_ATTRIBUTE:
                next_couple->IoObject = NEW ATTR_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_LOG_RECORD:
                next_couple->IoObject = NEW LOG_RECORD_IO;
                command = IDM_VIEW_LOG_RECORD;
                break;

            case IDM_READ_ROOT:
                next_couple->IoObject = NEW ROOT_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_CHAIN:
                next_couple->IoObject = NEW CHAIN_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_FILE:
                next_couple->IoObject = NEW FILE_IO;
                command = IDM_VIEW_BYTES;
                break;

            default:
                next_couple->IoObject = NULL;
                break;
            }

            error = TRUE;

            if (next_couple->IoObject && (next_couple->Mem = NEW HMEM) &&
                next_couple->Mem->Initialize() &&
                next_couple->IoObject->Setup(next_couple->Mem,
                    Drive, hInst, hwndChild, &error) &&
                next_couple->IoObject->Read(&error_status) &&
                (next_couple->EditObject = NEW EDIT_OBJECT) &&
                (next_couple->OtherEditObject = NEW EDIT_OBJECT) &&
                IoList->Put(next_couple)) {

                if (NULL != hwndSplit) {
                    next_couple->SplitEditObject = NEW EDIT_OBJECT;
                    if (NULL == next_couple->SplitEditObject) {
                        DELETE(next_couple);
                        break;
                    }
                }

                IoCouple->EditObject->KillFocus(hwndChild);
                IoCouple = next_couple;
                IoCouple->EditObject->SetFocus(hwndChild);
                IoListIterator->Reset();
                IoListIterator->GetPrevious();
                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());

                SendMessage(hWnd, WM_COMMAND, command, 0);
                if (NULL != hwndSplit) {
                    SendMessage(hwndSplit, WM_COMMAND, command, 0);
                }

            } else {

                if (error) {
                     ReportError(hWnd, error_status);
                    }
                DELETE(next_couple);
            }
            break;

        case IDM_READ_PREVIOUS:
            if (NULL != IoListIterator->GetPrevious()) {
                IoCouple->EditObject->KillFocus(hwndChild);
                IoCouple = (PIO_COUPLE)IoListIterator->GetCurrent();
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hWnd, NULL, TRUE);

                if (NULL != IoCouple->SplitEditObject && NULL == hwndSplit) {
                    SplitView(hwndChild, eSplitCreate);
                    InvalidateRect(hwndSplit, NULL, TRUE);
                }
                if (NULL == IoCouple->SplitEditObject && NULL != hwndSplit) {
                    SplitView(hwndChild, eSplitDestroy);
                }
                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());

            } else {
                ReportError(hwndChild, 0);
                IoListIterator->GetNext();
            }
            break;

        case IDM_READ_NEXT:
            if (IoListIterator->GetNext()) {
                IoCouple->EditObject->KillFocus(hwndChild);
                IoCouple = (PIO_COUPLE) IoListIterator->GetCurrent();
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

                if (NULL != IoCouple->SplitEditObject && NULL == hwndSplit) {
                    SplitView(hwndChild, eSplitCreate);
                    InvalidateRect(hwndSplit, NULL, TRUE);
                }
                if (NULL == IoCouple->SplitEditObject && NULL != hwndSplit) {
                    SplitView(hwndChild, eSplitDestroy);
                }

                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());
            } else {
                ReportError(hwndChild, 0);
                IoListIterator->GetPrevious();
            }
            break;

        case IDM_READ_REMOVE:
            if (IoList->QueryMemberCount() > 1) {
                IoCouple->EditObject->KillFocus(hwndChild);
                IoCouple = (PIO_COUPLE) IoList->Remove(IoListIterator);
                DELETE(IoCouple);
                IoCouple = (PIO_COUPLE) IoListIterator->GetCurrent();
                if (!IoCouple) {
                    IoCouple = (PIO_COUPLE) IoListIterator->GetPrevious();
                }
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);
                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());
            }
            break;

        case IDM_RELOCATE_SECTORS:
        case IDM_RELOCATE_CLUSTERS:
        case IDM_RELOCATE_FRS:
        case IDM_RELOCATE_ROOT:
        case IDM_RELOCATE_CHAIN:
        case IDM_RELOCATE_FILE:

            IoCouple->IoObject->GetBuf(&size);

            DELETE(IoCouple->IoObject);

            switch (LOWORD(wParam)) {
            case IDM_RELOCATE_SECTORS:
                IoCouple->IoObject = NEW SECTOR_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_RELOCATE_CLUSTERS:
                IoCouple->IoObject = NEW CLUSTER_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_RELOCATE_FRS:
                IoCouple->IoObject = NEW FRS_IO;
                command = IDM_VIEW_FRS;
                break;

            case IDM_RELOCATE_ROOT:
                IoCouple->IoObject = NEW ROOT_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_RELOCATE_CHAIN:
                IoCouple->IoObject = NEW CHAIN_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_RELOCATE_FILE:
                IoCouple->IoObject = NEW FILE_IO;
                if (IoCouple->IoObject) {
                    if (!((PFILE_IO) IoCouple->IoObject)->Initialize(size)) {

                        DELETE(IoCouple->IoObject);
                    }
                }
                command = IDM_VIEW_BYTES;
                break;

            default:
                IoCouple->IoObject = NULL;
                break;
            }

            error = TRUE;

            if (IoCouple->IoObject && IoCouple->IoObject->Setup(IoCouple->Mem,
                Drive, hInst, hwndChild, &error)) {

                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());

            } else {
                if (error) {
                     ReportError(hWnd, 0);
                    }
            }
            break;

        case IDM_VIEW_BYTES:

            IoCoupleSetEdit( IoCouple,
                             SECTOR_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_FRS:

            IoCoupleSetEdit( IoCouple,
                             FRS_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_ATTR_LIST:

            IoCoupleSetEdit( IoCouple,
                             ATTR_LIST_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_NTFS_INDEX:

            IoCoupleSetEdit( IoCouple,
                             NAME_INDEX_BUFFER_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );


            break;

        case IDM_VIEW_NTFS_SECURITY_ID:

            IoCoupleSetEdit( IoCouple,
                             SECURITY_ID_INDEX_BUFFER_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_NTFS_SECURITY_HASH:

            IoCoupleSetEdit( IoCouple,
                             SECURITY_HASH_INDEX_BUFFER_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_NTFS_SECURITY_STREAM:

            IoCoupleSetEdit( IoCouple,
                             SECURITY_STREAM_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_FAT_BOOT:
            if (NULL == (boot_edit = NEW DOS_BOOT_EDIT)) {
                ReportError(hwndChild, 0);
                break;
            }

            IoCouple->EditObject->KillFocus(hwndChild);
            DELETE(IoCouple->OtherEditObject);
            IoCouple->OtherEditObject = IoCouple->EditObject;
            IoCouple->EditObject = boot_edit;
            IoCouple->IoObject->GetBuf(&size);
            IoCouple->EditObject->SetBuf(hwndChild,
                                         IoCouple->IoObject->GetBuf(), size);
            IoCouple->EditObject->SetFocus(hwndChild);
            InvalidateRect(hwndChild, NULL, TRUE);

            break;

        case IDM_VIEW_NTFS_BOOT:
            if (ntboot_edit = NEW NTFS_BOOT_EDIT) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = ntboot_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {
                DELETE(ntboot_edit);
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_PARTITION_TABLE:

            if ( (part_edit = NEW PARTITION_TABLE_EDIT) &&
                part_edit->Initialize(hwndChild, ClientHeight, ClientWidth, Drive)) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = part_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {

                DELETE( part_edit );
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_GPT:

            if ( (guid_part_edit = NEW GUID_PARTITION_TABLE_EDIT) &&
                guid_part_edit->Initialize(hwndChild, ClientHeight, ClientWidth, Drive)) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = guid_part_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {

                DELETE( guid_part_edit );
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_RESTART_AREA:

            if ((rest_area_edit = NEW RESTART_AREA_EDIT) &&
                rest_area_edit->Initialize(hwndChild, ClientHeight, ClientWidth, Drive )) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = rest_area_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {
                DELETE(rest_area_edit);
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_RECORD_PAGE:

            if ((rec_page_edit = NEW RECORD_PAGE_EDIT) &&
                rec_page_edit->Initialize(hwndChild, ClientHeight, ClientWidth, Drive)) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = rec_page_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {
                DELETE(rec_page_edit);
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_LOG_RECORD:

            if ((log_rec_edit = NEW LOG_RECORD_EDIT) &&
                log_rec_edit->Initialize(hwndChild, ClientHeight,
                    ClientWidth, Drive)) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = log_rec_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {
                DELETE(log_rec_edit);
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_LAST:
            IoCouple->EditObject->KillFocus(hwndChild);
            tmp_edit = IoCouple->EditObject;
            IoCouple->EditObject = IoCouple->OtherEditObject;
            IoCouple->OtherEditObject = tmp_edit;
            IoCouple->EditObject->SetFocus(hwndChild);
            InvalidateRect(hwndChild, NULL, TRUE);
            break;

        case IDM_VIEW_SPLIT:

            SplitView(hWnd, eSplitToggle);
            break;

        case IDM_WRITE_IT:
            if (!IoCouple->IoObject->Write()) {
                ReportError(hWnd, 0);
            }
            break;

        case IDM_CRACK_NTFS:
            lpProc = MakeProcInstance((FARPROC)InputPath, hInst);
            if (DialogBox(hInst, TEXT("InputPathBox"), hWnd, (DLGPROC)lpProc)) {
                CrackNtfsPath(hWnd);
            }
            FreeProcInstance(lpProc);
            break;

        case IDM_CRACK_FAT:
            lpProc = MakeProcInstance((FARPROC)InputPath, hInst);
            if (DialogBox(hInst, TEXT("InputPathBox"), hWnd, (DLGPROC)lpProc)) {
                CrackFatPath(hWnd);
            }
            FreeProcInstance(lpProc);
            break;

        case IDM_CRACK_LSN:
            lpProc = MakeProcInstance((FARPROC)InputLsn, hInst);
            if (DialogBox(hInst, TEXT("CrackLsnBox"), hWnd, (DLGPROC)lpProc)) {
                 CrackLsn(hWnd);
            }
            FreeProcInstance(lpProc);
            break;

        case IDM_CRACK_NEXT_LSN:
            lpProc = MakeProcInstance((FARPROC)InputLsn, hInst);
            if (DialogBox(hInst, TEXT("CrackNextLsnBox"), hWnd, (DLGPROC)lpProc)) {
                 CrackNextLsn(hWnd);
            }
            FreeProcInstance(lpProc);
            break;

        case IDM_BACKTRACK_FRS:

            lpProc = MakeProcInstance((FARPROC)FrsNumberDialogProc, hInst);
            if (DialogBox(hInst, TEXT("BacktrackFrsBox"), hWnd, (DLGPROC)lpProc)) {

                BacktrackFrsFromScratch(hWnd, BacktrackFileNumber);
            }
            FreeProcInstance(lpProc);
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);

        }
        break;

    case WM_PAINT:
        hDC = BeginPaint(hWnd, &ps);
        EndPaint(hWnd, &ps);
        break;

    case WM_DESTROY:
        IoCouple->EditObject->KillFocus(hwndChild);
        IoList->DeleteAllMembers();
        DELETE(IoListIterator);
        DELETE(IoList);
        DELETE(Drive);
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);

    }

    return 0;
}


BOOL
About(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}


BOOL
OpenVolume(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    PREAD_CACHE rcache;

    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, TRUE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {

            DSTRING dos_name, nt_name, tmp_name;
            DSTRING volfile_name, volfile_path, backslash;
            TCHAR   volume_buf[32];
            TCHAR   volfile_buf[32];
            INT     n;

            n = GetDlgItemText(hDlg, IDTEXT, volume_buf, sizeof(volume_buf)/sizeof(TCHAR));
            volume_buf[n] = 0;

            n = GetDlgItemText(hDlg, IDTEXT2, volfile_buf, sizeof(volfile_buf)/sizeof(TCHAR));
            volfile_buf[n] = 0;

            DELETE(Drive);

            if (!backslash.Initialize("\\") ||
                !dos_name.Initialize(volume_buf)) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (dos_name.QueryChCount() > 0 &&
                dos_name.QueryChAt(0) >= '0' &&
                dos_name.QueryChAt(0) <= '9') {

                if (!nt_name.Initialize("\\device\\harddisk") ||
                    !nt_name.Strcat(&dos_name) ||
                    !tmp_name.Initialize("\\partition0") ||
                    !nt_name.Strcat(&tmp_name)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
            } else {

                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dos_name,
                                                           &nt_name)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
            }

            if (!volfile_name.Initialize(volfile_buf)) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (0 != wcslen(volfile_buf)) {

                if (!volfile_path.Initialize(&nt_name) ||
                    !volfile_path.Strcat(&backslash) ||
                    !volfile_path.Strcat(&volfile_name)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
                if (NULL == (Drive = NEW LOG_IO_DP_DRIVE) ||
                    !Drive->Initialize(&nt_name, &volfile_path)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }

            } else {

                if (NULL == (Drive = NEW LOG_IO_DP_DRIVE) ||
                    !Drive->Initialize(&nt_name)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
            }

            if ((rcache = NEW READ_CACHE) &&
                rcache->Initialize(Drive, 1024)) {

                Drive->SetCache(rcache);

            } else {
                DELETE(rcache);
            }

            if (IsDlgButtonChecked(hDlg, IDCHECKBOX) &&
                !Drive->Lock()) {

                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}


BOOL
InputPath(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    INT n;

    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {
                n = GetDlgItemText(hDlg, IDTEXT, Path, MAX_PATH/sizeof(TCHAR));
                Path[n] = 0;
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}

BOOL
InputLsn(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    INT n;
    TCHAR buf[40];
    PTCHAR pch;

    switch (message) {
    case WM_INITDIALOG:
        wsprintf(buf, TEXT("%x:%x"), Lsn.HighPart, Lsn.LowPart);
        SetDlgItemText(hDlg, IDTEXT, buf);
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {
            n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;

            if (NULL == (pch = wcschr(buf, ':'))) {
                Lsn.HighPart = 0;
                swscanf(buf, TEXT("%x"), &Lsn.LowPart);
            } else {
                *pch = 0;
                swscanf(buf, TEXT("%x"), &Lsn.HighPart);
                swscanf(pch + 1, TEXT("%x"), &Lsn.LowPart);
                *pch = ':';
            }
            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

static ULONG SeqNumberBits;

ULONG
GetLogPageSize(
    PLOG_IO_DP_DRIVE Drive
    )
{
    static ULONG PageSize;
    static BOOLEAN been_here = FALSE;
    static UCHAR buf[0x600];
    NTFS_SA         NtfsSa;
    MESSAGE         Msg;
    NTFS_MFT_FILE   Mft;
    NTFS_FILE_RECORD_SEGMENT Frs;
    NTFS_ATTRIBUTE  Attrib;
    PLFS_RESTART_PAGE_HEADER pRestPageHdr;
    PLFS_RESTART_AREA pRestArea;
    ULONG           bytes_read;
    BOOLEAN         error;

    if (been_here) {
        return PageSize;
    }

    pRestPageHdr = (PLFS_RESTART_PAGE_HEADER)buf;

    if (!Drive ||
        !NtfsSa.Initialize(Drive, &Msg) ||
        !NtfsSa.Read() ||
        !Mft.Initialize(Drive, NtfsSa.QueryMftStartingLcn(),
            NtfsSa.QueryClusterFactor(), NtfsSa.QueryFrsSize(),
            NtfsSa.QueryVolumeSectors(), NULL, NULL) ||
        !Mft.Read() ||
        !Frs.Initialize((VCN)LOG_FILE_NUMBER, &Mft) ||
        !Frs.Read() ||
        !Frs.QueryAttribute(&Attrib, &error, $DATA) ||
        !Attrib.Read((PVOID)pRestPageHdr, 0, 0x600,
            &bytes_read) ||
        bytes_read != 0x600) {

        return 0;
    }

    PageSize = pRestPageHdr->LogPageSize;

    pRestArea = PLFS_RESTART_AREA(PUCHAR(pRestPageHdr) + pRestPageHdr->RestartOffset);

    SeqNumberBits = pRestArea->SeqNumberBits;

    been_here = 1;
    return PageSize;
}

ULONG
GetSeqNumberBits(
    PLOG_IO_DP_DRIVE Drive
    )
{
    (void)GetLogPageSize(Drive);

    return SeqNumberBits;
}

BOOLEAN
SplitView(
    HWND hWnd,
    SPLIT_OPERATION Op
    )
{
    static BOOLEAN CheckState = FALSE;
    int flags;
    PSECTOR_EDIT        sector_edit;
    CREATESTRUCT cs;
    ULONG size;
    HMENU hMenu = GetMenu(hWnd);

    if (Op == eSplitToggle) {
        CheckState = !CheckState;
    } else if (Op == eSplitCreate) {
        CheckState = TRUE;
    } else if (Op == eSplitDestroy) {
        CheckState = FALSE;
    } else if (Op == eSplitQuery) {
        DebugAssert(hWnd == NULL);
        return CheckState;
    } else {
        return FALSE;
    }


    if (!CheckState) {
        // Destroy the extra window, remove the checkbox from
        // the menu entry.

        if (NULL == hwndSplit) {
            return 0;
        }

        DestroyWindow(hwndSplit);
        hwndSplit = NULL;
        flags = MF_BYCOMMAND | MF_UNCHECKED;
        if (hMenu == NULL) {
            return FALSE;
        }
        CheckMenuItem(hMenu, IDM_VIEW_SPLIT, flags);

        SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth, ClientHeight,
            SWP_SHOWWINDOW);

        IoCouple->EditObject->SetFocus(hwndChild);
        SetFocus(hwndChild);

        return TRUE;
    }

    //
    // Split the window.
    //

    memset(&cs, 0, sizeof(cs));

    cs.y = ClientWidth / 2;
    cs.x = 0;
    cs.cy = ClientWidth / 2;
    cs.cx = ClientHeight;

    hwndSplit = CreateWindow(TEXT("SplitWinClass"), TEXT("hwndSplit"),
        WS_CHILD|WS_CLIPSIBLINGS|WS_VISIBLE,
        ClientWidth / 2, 0,
        ClientWidth / 2, ClientHeight,
        hWnd,
        NULL,
        hInst,
        &cs);

    if (NULL == hwndSplit) {
        int error = GetLastError();
        return FALSE;
    }

    SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth / 2, ClientHeight,
        SWP_SHOWWINDOW);

    flags = MF_BYCOMMAND | MF_CHECKED;
    CheckMenuItem(hMenu, IDM_VIEW_SPLIT, flags);

    ShowWindow(hwndSplit, SW_SHOW);
    UpdateWindow(hwndSplit);

    if (NULL != IoCouple->SplitEditObject) {
        // use the existing edit object
        return TRUE;
    }

    if ((sector_edit = NEW SECTOR_EDIT) &&
        sector_edit->Initialize(hwndSplit, ClientHeight, ClientWidth / 2, Drive)) {

        IoCouple->SplitEditObject = sector_edit;

        IoCouple->IoObject->GetBuf(&size);
        IoCouple->SplitEditObject->SetBuf(hwndSplit,
            IoCouple->IoObject->GetBuf(), size);

        IoCouple->EditObject->SetFocus(hwndChild);
        SetFocus(hwndChild);

    } else {
        DELETE(sector_edit);
        DestroyWindow(hwndSplit);
        ReportError(hWnd, 0);
    }

    return TRUE;
}

LRESULT
ChildWndProc(
    IN  HWND    hwnd,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    FARPROC             lpProc;
    HDC                 hdc;
    PAINTSTRUCT         ps;
    ULONG               size;
    WORD                command;
    BOOLEAN             error;
    ULONG               error_status;

    switch (message) {

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);

        IoCouple->EditObject->Paint(hdc, ps.rcPaint, hwnd);

        EndPaint(hwnd, &ps);
        return 0;


    case WM_CHAR:
        IoCouple->EditObject->Character(hwnd, (CHAR)wParam);
        break;

    case WM_VSCROLL:
        switch (LOWORD(wParam)) {
        case SB_LINEUP:
            IoCouple->EditObject->ScrollUp(hwnd);
            break;

        case SB_LINEDOWN:
            IoCouple->EditObject->ScrollDown(hwnd);
            break;

        case SB_PAGEUP:
            IoCouple->EditObject->PageUp(hwnd);
            break;

        case SB_PAGEDOWN:
            IoCouple->EditObject->PageDown(hwnd);
            break;

        case SB_THUMBPOSITION:
            IoCouple->EditObject->ThumbPosition(hwnd, HIWORD(wParam));
            break;

        default:
            break;

        }
        break;

    case WM_KEYDOWN:
        switch (LOWORD(wParam)) {
        case VK_UP:
            IoCouple->EditObject->KeyUp(hwnd);
            break;

        case VK_DOWN:
            IoCouple->EditObject->KeyDown(hwnd);
            break;

        case VK_LEFT:
            IoCouple->EditObject->KeyLeft(hwnd);
            break;

        case VK_RIGHT:
            IoCouple->EditObject->KeyRight(hwnd);
            break;

        case VK_PRIOR:
            IoCouple->EditObject->PageUp(hwnd);
            break;

        case VK_NEXT:
            IoCouple->EditObject->PageDown(hwnd);
            break;

        default:
            break;

        }
        break;

    case WM_SETFOCUS:
        IoCouple->EditObject->SetFocus(hwnd);
        break;

    case WM_KILLFOCUS:
        IoCouple->EditObject->KillFocus(hwnd);
        break;

    case WM_LBUTTONDOWN:
        IoCouple->EditObject->Click(hwnd, LOWORD(lParam), HIWORD(lParam));
        break;
    }

    return 0;
}


LRESULT
SplitWndProc(
    IN  HWND    hwnd,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    FARPROC             lpProc;
    HDC                 hdc;
    PAINTSTRUCT         ps;
    ULONG               size;
    WORD                command;
    BOOLEAN             error;
    ULONG               error_status;

    switch (message) {

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);

        if (NULL != IoCouple->SplitEditObject) {
            IoCouple->SplitEditObject->Paint(hdc, ps.rcPaint, hwnd);
        }

        EndPaint(hwnd, &ps);
        return 0;


    case WM_CHAR:
        IoCouple->SplitEditObject->Character(hwnd, (CHAR)wParam);
        break;

    case WM_VSCROLL:
        switch (LOWORD(wParam)) {
        case SB_LINEUP:
            IoCouple->SplitEditObject->ScrollUp(hwnd);
            break;

        case SB_LINEDOWN:
            IoCouple->SplitEditObject->ScrollDown(hwnd);
            break;

        case SB_PAGEUP:
            IoCouple->SplitEditObject->PageUp(hwnd);
            break;

        case SB_PAGEDOWN:
            IoCouple->SplitEditObject->PageDown(hwnd);
            break;

        case SB_THUMBPOSITION:
            IoCouple->SplitEditObject->ThumbPosition(hwnd, HIWORD(wParam));
            break;

        default:
            break;

        }
        break;

    case WM_KEYDOWN:
        switch (LOWORD(wParam)) {
        case VK_UP:
            IoCouple->SplitEditObject->KeyUp(hwnd);
            break;

        case VK_DOWN:
            IoCouple->SplitEditObject->KeyDown(hwnd);
            break;

        case VK_LEFT:
            IoCouple->SplitEditObject->KeyLeft(hwnd);
            break;

        case VK_RIGHT:
            IoCouple->SplitEditObject->KeyRight(hwnd);
            break;

        case VK_PRIOR:
            IoCouple->SplitEditObject->PageUp(hwnd);
            break;

        case VK_NEXT:
            IoCouple->SplitEditObject->PageDown(hwnd);
            break;

        default:
            break;

        }
        break;

    case WM_SETFOCUS:
        IoCouple->SplitEditObject->SetFocus(hwnd);
        break;

    case WM_KILLFOCUS:
        IoCouple->SplitEditObject->KillFocus(hwnd);
        break;

    case WM_LBUTTONDOWN:
        IoCouple->SplitEditObject->Click(hwnd, LOWORD(lParam), HIWORD(lParam));
        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\diskedit.h ===
#define IDM_ABOUT               100
#define IDM_OPEN                200
#define IDM_READ_SECTORS        300
#define IDM_READ_FRS            400
#define IDM_READ_ATTRIBUTE      450
#define IDM_VIEW_BYTES          500
#define IDM_VIEW_FRS            600
#define IDM_EXIT                700
#define IDM_WRITE_IT            800
#define IDM_READ_ROOT           900
#define IDM_READ_CHAIN          1000
#define IDM_READ_LOG_RECORD     1050
#define IDM_VIEW_FAT_BOOT       1100
#define IDM_VIEW_NTFS_BOOT      1200
#define IDM_READ_PREVIOUS       1300
#define IDM_READ_NEXT           1400
#define IDM_READ_REMOVE         1500
#define IDM_VIEW_LAST           1600
#define IDM_CRACK_NTFS          1700
#define IDM_CRACK_FAT           1800
#define IDM_CRACK_LSN           1850
#define IDM_CRACK_NEXT_LSN      1875
#define IDM_VIEW_NTFS_INDEX     1900
#define IDM_VIEW_NTFS_SECURITY_ID       1950
#define IDM_VIEW_NTFS_SECURITY_HASH     1951
#define IDM_VIEW_NTFS_SECURITY_STREAM   1952
#define IDM_BACKTRACK_FRS       2000
#define IDM_RELOCATE_SECTORS    2100
#define IDM_RELOCATE_FRS        2200
#define IDM_RELOCATE_ROOT       2300
#define IDM_RELOCATE_CHAIN      2400
#define IDM_READ_FILE           2600
#define IDM_RELOCATE_FILE       2700
#define IDM_READ_CLUSTERS       2800
#define IDM_RELOCATE_CLUSTERS   2900
#define IDM_VIEW_PARTITION_TABLE 3000
#define IDM_VIEW_GPT            3050
#define IDM_VIEW_RESTART_AREA   3100
#define IDM_VIEW_RECORD_PAGE    3200
#define IDM_VIEW_LOG_RECORD     3300
#define IDM_VIEW_SPLIT          3400
#define IDM_VIEW_ATTR_LIST      3500

#define IDTEXT      51
#define IDTEXT2     52
#define IDCHECKBOX  53
#define IDTEXT3     54
#define IDLISTBOX   55
#define IDVOLUME    56
#define IDRADIO1    57
#define IDRADIO2    58

#define IDSTATIC    -1


BOOLEAN InitApplication(HINSTANCE);
BOOLEAN InitInstance(HINSTANCE, INT, HWND*, HACCEL*);
LRESULT MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT SplitWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT ChildWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL About(HWND, UINT, UINT, LONG);
BOOL ReadSectors(HWND, UINT, UINT, LONG);
BOOL ReadClusters(HWND, UINT, UINT, LONG);
BOOL OpenVolume(HWND, UINT, UINT, LONG);
BOOL ReadFrs(HWND, UINT, UINT, LONG);
BOOL ReadChain(HWND, UINT, UINT, LONG);
BOOL ReadLogRecord(HWND, UINT, UINT, LONG);
BOOL InputPath(HWND, UINT, UINT, LONG);
BOOL InputLsn(HWND, UINT, UINT, LONG);
BOOL ReadTheFile(HWND, UINT, UINT, LONG);
BOOL ReadAttribute(HWND, UINT, UINT, LONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\clusio.cxx ===
#include "ulib.hxx"
#include "ntfssa.hxx"
#include "clusio.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

STATIC ULONG StartCluster = 0;
STATIC ULONG NumClusters = 1;


BOOLEAN
CLUSTER_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    FARPROC proc;
    HMEM    mem;
    MESSAGE msg;

    proc = MakeProcInstance((FARPROC) ReadClusters, Application);
    if (!DialogBox((HINSTANCE)Application, TEXT("ReadClustersBox"),
                   WindowHandle, (DLGPROC) proc)) {
        *Error = FALSE;
        return FALSE;
    }
    FreeProcInstance(proc);

    *Error = TRUE;

    _drive = Drive;

    if (!NumClusters || !_drive) {
        return FALSE;
    }

    PPACKED_BOOT_SECTOR     p;
    BIOS_PARAMETER_BLOCK    bpb;
    ULONG                   ClusterFactor;

    //
    // Read the boot sector.
    //

    if (!_secrun.Initialize(&mem, _drive, 0, 1) || !_secrun.Read()) {
        return FALSE;
    }
    p = (PPACKED_BOOT_SECTOR)_secrun.GetBuf();

    UnpackBios(&bpb, &(p->PackedBpb));

    ClusterFactor = bpb.SectorsPerCluster;

    if (!_secrun.Initialize(Mem, _drive,
                            StartCluster*ClusterFactor,
                            NumClusters*ClusterFactor)) {
        return FALSE;
    }

    swprintf(_header_text, TEXT("DiskEdit - Cluster 0x%X for 0x%X"), StartCluster, NumClusters);

    return TRUE;
}


BOOLEAN
CLUSTER_IO::Read(
    OUT PULONG pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }
    if (!_secrun.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
CLUSTER_IO::Write(
    )
{
    return _drive ? _secrun.Write() : FALSE;
}


PVOID
CLUSTER_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _drive ? (_drive->QuerySectorSize()*_secrun.QueryLength()) : 0;
    }

    return _secrun.GetBuf();
}


PTCHAR
CLUSTER_IO::GetHeaderText(
    )
{
    return _header_text;
}


BOOL
ReadClusters(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    TCHAR buf[1024];

    switch (message) {
        case WM_INITDIALOG:
            wsprintf(buf, TEXT("%x"), StartCluster);
            SetDlgItemText(hDlg, IDTEXT, buf);

            wsprintf(buf, TEXT("%x"), NumClusters);
            SetDlgItemText(hDlg, IDTEXT2, buf);

            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                INT n;

                n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;
                swscanf(buf, TEXT("%x"), &StartCluster);

                n = GetDlgItemText(hDlg, IDTEXT2, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;
                swscanf(buf, TEXT("%x"), &NumClusters);

                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\edit.cxx ===
#include "ulib.hxx"
#include "edit.hxx"

EDIT_OBJECT::~EDIT_OBJECT(
    )
{
}


VOID
EDIT_OBJECT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
}

VOID
EDIT_OBJECT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);
}


VOID
EDIT_OBJECT::ClientSize(
    IN  INT Height,
    IN  INT Width
    )
{
}


VOID
EDIT_OBJECT::ScrollUp(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::ScrollDown(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::PageUp(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::PageDown(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::ThumbPosition(
    IN  HWND    WindowHandle,
    IN  INT     NewThumbPosition
    )
{
}


VOID
EDIT_OBJECT::Click(
    IN  HWND    WindowHandle,
    IN  INT     Xcoordinate,
    IN  INT     Ycoordinate
    )
{
}


VOID
EDIT_OBJECT::KeyUp(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::KeyDown(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::KeyLeft(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::KeyRight(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::Character(
    IN  HWND    WindowHandle,
    IN  CHAR    Char
    )
{
}


VOID
EDIT_OBJECT::SetFocus(
    IN  HWND    WindowHandle
    )
{
    ::SetFocus(WindowHandle);
}


VOID
EDIT_OBJECT::KillFocus(
    IN  HWND    WindowHandle
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\frsio.cxx ===
#include "ulib.hxx"
#include "frsio.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "ntfssa.hxx"
#include "frs.hxx"
#include "attrib.hxx"
#include "mftfile.hxx"
#include "bitfrs.hxx"
#include "ntfsbit.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

extern PLOG_IO_DP_DRIVE Drive;

STATIC ULONG FileNumber = 0;

BOOLEAN
FRS_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    FARPROC proc;
    NTFS_SA ntfssa;
    MESSAGE msg;
    HMEM    hmem;

    proc = MakeProcInstance((FARPROC) ReadFrs, Application);
    if (!DialogBox((HINSTANCE)Application, TEXT("ReadFrsBox"),
                   WindowHandle, (DLGPROC) proc)) {
        *Error = FALSE;
        return FALSE;
    }
    FreeProcInstance(proc);

    *Error = TRUE;

    _drive = Drive;
    if (!_drive) {
        return FALSE;
    }

    if (!ntfssa.Initialize(_drive, &msg) ||
        !ntfssa.Read() ||
        !hmem.Initialize() ||
        !_frs.Initialize(&hmem, _drive,
                         ntfssa.QueryMftStartingLcn(),
                         ntfssa.QueryClusterFactor(),
                         ntfssa.QueryVolumeSectors(),
                         ntfssa.QueryFrsSize(),
                         NULL) ||
        !_frs.Read() ||
        !_frs.SafeQueryAttribute($DATA, &_mftdata, &_mftdata) ||
        !_frs.Initialize(Mem, &_mftdata, FileNumber,
                         ntfssa.QueryClusterFactor(),
                         ntfssa.QueryVolumeSectors(),
                         ntfssa.QueryFrsSize(),
                         NULL)) {

        return FALSE;
    }

    swprintf(_header_text, TEXT("DiskEdit - File Record 0x%X"), FileNumber);

    return TRUE;
}


BOOLEAN
FRS_IO::Read(
    OUT PULONG  pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }
    if (!_frs.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
FRS_IO::Write(
    )
{
    return _drive ? _frs.Write() : FALSE;
}


PVOID
FRS_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _frs.QuerySize();
    }

    return *((PVOID*) ((PCHAR) &_frs + 2*sizeof(PVOID)));
}


PTCHAR
FRS_IO::GetHeaderText(
    )
{
    return _header_text;
}


BOOL
ReadFrs(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    switch (message) {
    case WM_INITDIALOG:

            SetDlgItemText( hDlg, IDVOLUME, Drive->GetNtDriveName()->GetWSTR() );
            CheckDlgButton( hDlg, IDRADIO1, BST_CHECKED );
            return TRUE;

    case WM_COMMAND:


            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                TCHAR buf[1024];
                INT n;
                
                n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;

                if (IsDlgButtonChecked( hDlg, IDRADIO2)) {
                    swscanf(buf, TEXT("%x"), &FileNumber);
                } else {

                    DSTRING                     path;
                    NTFS_SA                     ntfssa;
                    MESSAGE                     msg;
                    NTFS_MFT_FILE               mft;
                    NTFS_BITMAP_FILE            bitmap_file;
                    NTFS_ATTRIBUTE              bitmap_attribute;
                    NTFS_BITMAP                 volume_bitmap;
                    NTFS_UPCASE_FILE            upcase_file;
                    NTFS_ATTRIBUTE              upcase_attribute;
                    NTFS_UPCASE_TABLE           upcase_table;
                    NTFS_FILE_RECORD_SEGMENT    file_record;
                    BOOLEAN                     error;
                    BOOLEAN                     system_file;

                    if (!path.Initialize(buf)) {
                        wsprintf(buf, TEXT("Out of memory"));
                        MessageBox(hDlg, buf, TEXT("DiskEdit"), MB_OK|MB_ICONEXCLAMATION);
                        return FALSE;
                    } else if (!Drive ||
                        !ntfssa.Initialize(Drive, &msg) ||
                        !ntfssa.Read() ||
                        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                                        ntfssa.QueryClusterFactor(),
                                        ntfssa.QueryFrsSize(),
                                        ntfssa.QueryVolumeSectors(), NULL, NULL) ||
                        !mft.Read() ||
                        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
                        !bitmap_file.Read() ||
                        !bitmap_file.QueryAttribute(&bitmap_attribute, &error, $DATA) ||
                        !volume_bitmap.Initialize(ntfssa.QueryVolumeSectors() /
                              (ULONG) ntfssa.QueryClusterFactor(), FALSE, NULL, 0) ||
                        !volume_bitmap.Read(&bitmap_attribute) ||
                        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
                        !upcase_file.Read() ||
                        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
                        !upcase_table.Initialize(&upcase_attribute) ||
                        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                                        ntfssa.QueryClusterFactor(),
                                        ntfssa.QueryFrsSize(),
                                        ntfssa.QueryVolumeSectors(),
                                        &volume_bitmap,
                                        &upcase_table) ||
                        !mft.Read()) {
                    
                        swprintf(buf, TEXT("Could not init NTFS data structures"));
                        MessageBox(hDlg, buf, TEXT("DiskEdit"), MB_OK|MB_ICONEXCLAMATION);
                        return FALSE;
                    
                    } else if (!ntfssa.QueryFrsFromPath(&path, mft.GetMasterFileTable(),
                               &volume_bitmap, &file_record, &system_file, &error)) {
                            
                        wsprintf(buf, TEXT("File not found."));
                        MessageBox(hDlg, buf, TEXT("DiskEdit"), MB_OK|MB_ICONINFORMATION);
                        return FALSE;
                        
                    } else {
                        FileNumber = file_record.QueryFileNumber().GetLowPart();
                    }
                }
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\frsedit.cxx ===
#include "ulib.hxx"
#include "frsedit.hxx"
#include "untfs.hxx"
#include "frsstruc.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"
#include "attrlist.hxx"
#include "crack.hxx"

extern "C" {
#include <stdio.h>
}


BOOLEAN
FRS_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;
    _drive = Drive;

    if (!_drive) {
        return FALSE;
    }

    if (!ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read()) {

        return FALSE;
    }

    _cluster_factor = ntfssa.QueryClusterFactor();
    _frs_size = ntfssa.QueryFrsSize();

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}


VOID
FRS_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}

STATIC  TCHAR  buf[1024];

VOID
FRS_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    INT                             nDrawX, nDrawY;
    INT                             CurrentLine;
    PCFILE_RECORD_SEGMENT_HEADER    pfrs;
    TCHAR                           sbFlags[32];

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || !_size) {
        return;
    }

    pfrs = (PCFILE_RECORD_SEGMENT_HEADER) _buffer;

    CurrentLine = 0;

    swprintf(buf, TEXT("FILE_RECORD_SEGMENT_HEADER {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    MULTI_SECTOR_HEADER MultiSectorHeader {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Signature: \t\t\t%c%c%c%c"),
            pfrs->MultiSectorHeader.Signature[0],
            pfrs->MultiSectorHeader.Signature[1],
            pfrs->MultiSectorHeader.Signature[2],
            pfrs->MultiSectorHeader.Signature[3]);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Update sequence array offset: \t%x"),
            pfrs->MultiSectorHeader.UpdateSequenceArrayOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Update sequence array size: \t%x"),
            pfrs->MultiSectorHeader.UpdateSequenceArraySize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    }"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Lsn: \t\t\t<%x,%x>"), pfrs->Lsn.HighPart,
        pfrs->Lsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Sequence number: \t\t%x"), pfrs->SequenceNumber);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Reference count: \t\t%x"),
            pfrs->ReferenceCount);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    First attribute offset: \t%x"),
         pfrs->FirstAttributeOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (pfrs->Flags & FILE_RECORD_SEGMENT_IN_USE) {
        wcscpy(sbFlags, TEXT("U"));
    } else {
        wcscpy(sbFlags, TEXT(" "));
    }
    if (pfrs->Flags & FILE_FILE_NAME_INDEX_PRESENT) {
        wcscat(sbFlags, TEXT("I"));
    }
    swprintf(buf, TEXT("    Flags: \t\t\t%x \t%s"), pfrs->Flags, sbFlags);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    First free byte: \t\t%x"), pfrs->FirstFreeByte);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Bytes available: \t\t%x"), pfrs->BytesAvailable);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    FILE_REFERENCE BaseFileRecordSegment {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        LowPart: \t %x"),
         pfrs->BaseFileRecordSegment.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Sequence number: %x"),
        pfrs->BaseFileRecordSegment.SequenceNumber);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    }"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Next attribute instance: %x"),
             pfrs->NextAttributeInstance);
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (pfrs->MultiSectorHeader.UpdateSequenceArrayOffset >=
        FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {
        swprintf(buf, TEXT("    Segment Number:          <%x,%x>"),
                 pfrs->SegmentNumberHighPart, pfrs->SegmentNumberLowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);
    }

    swprintf(buf, TEXT("}"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentLine++;

    // At this point enumerate all of the attribute records.

    NTFS_FRS_STRUCTURE          frs;
    PATTRIBUTE_RECORD_HEADER    prec;
    NTFS_ATTRIBUTE_RECORD       attrrec;
    DSTRING                     record_name;
    PWSTR                       pstr;
    CONT_MEM                    cmem;

    if (!cmem.Initialize(_buffer, _size) ||
        !frs.Initialize(&cmem, _drive, 0, _cluster_factor,
                        0, _frs_size, NULL)) {
        return;
    }

    prec = NULL;
    while (prec = (PATTRIBUTE_RECORD_HEADER) frs.GetNextAttributeRecord(prec)) {

        if (!attrrec.Initialize(NULL, prec) ||
            !attrrec.QueryName(&record_name) ||
            !(pstr = record_name.QueryWSTR())) {
            return;
        }

        swprintf(buf, TEXT("ATTRIBUTE_RECORD_HEADER at offset %x {"), (PCHAR) prec - (PCHAR) pfrs);
        WriteLine(DeviceContext, CurrentLine++, buf);

        PTCHAR SymbolicTypeCode = GetNtfsAttributeTypeCodeName(prec->TypeCode);

        swprintf(buf, TEXT("    Type code, name: \t%x (%s), %s"), prec->TypeCode,
            NULL == SymbolicTypeCode ? TEXT("unknown") : SymbolicTypeCode,
            pstr);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Record length: \t%x"), prec->RecordLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Form code: \t\t%x"), prec->FormCode);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Name length: \t%x"), prec->NameLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Name offset: \t%x"), prec->NameOffset);
        WriteLine(DeviceContext, CurrentLine++, buf);

        if (prec->Flags & ATTRIBUTE_FLAG_COMPRESSION_MASK) {
            wcscpy(sbFlags, TEXT("C"));
        } else {
            sbFlags[0] = '\0';
        }
        swprintf(buf, TEXT("    Flags: \t\t%x \t%s"), prec->Flags, sbFlags);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Instance: \t\t%x"), prec->Instance);
        WriteLine(DeviceContext, CurrentLine++, buf);
        CurrentLine++;

        if (!(prec->FormCode & NONRESIDENT_FORM)) {

            //
            // Resident Attribute
            //

            swprintf(buf, TEXT("    Resident form {"));
            WriteLine(DeviceContext, CurrentLine++, buf);

            swprintf(buf, TEXT("        Value length: \t%x"),
                    prec->Form.Resident.ValueLength);
            WriteLine(DeviceContext, CurrentLine++, buf);

            swprintf(buf, TEXT("        Value offset: \t%x"),
                    prec->Form.Resident.ValueOffset);
            WriteLine(DeviceContext, CurrentLine++, buf);

            if (prec->Form.Resident.ResidentFlags & RESIDENT_FORM_INDEXED) {
                wcscpy(sbFlags, TEXT("I"));
            } else {
                sbFlags[0] = '\0';
            }
            swprintf(buf, TEXT("        Resident flags: %x \t%s"),
                    prec->Form.Resident.ResidentFlags, sbFlags);
            WriteLine(DeviceContext, CurrentLine++, buf);

            swprintf(buf, TEXT("    }"));
            WriteLine(DeviceContext, CurrentLine++, buf);

            __try {

                if ($FILE_NAME == prec->TypeCode) {
                    DisplayFileName(prec, DeviceContext, CurrentLine);
                } else if ($ATTRIBUTE_LIST == prec->TypeCode) {
                    DisplayAttrList(prec, DeviceContext, CurrentLine);
                } else if ($STANDARD_INFORMATION == prec->TypeCode) {
                    DisplayStandardInformation( prec, DeviceContext, CurrentLine );
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                swprintf(buf, TEXT("[ADDRESS ERROR]"));
                WriteLine(DeviceContext, CurrentLine++, buf);
            }

            swprintf(buf, TEXT("}"));
            WriteLine(DeviceContext, CurrentLine++, buf);

            CurrentLine++;

            DELETE(pstr);
            continue;
        }

        //
        // Nonresident Attribute
        //

        swprintf(buf, TEXT("    Nonresident form {"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Lowest vcn: \t\t%x"),
                prec->Form.Nonresident.LowestVcn.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Highest vcn: \t\t%x"),
                prec->Form.Nonresident.HighestVcn.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Mapping pairs offset: \t%x"),
                prec->Form.Nonresident.MappingPairsOffset);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Compression unit: \t%x"),
                prec->Form.Nonresident.CompressionUnit);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Allocated length: \t%x"),
                prec->Form.Nonresident.AllocatedLength.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        File size: \t\t%x"),
                prec->Form.Nonresident.FileSize.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Valid data length: \t%x"),
                prec->Form.Nonresident.ValidDataLength.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        if ((prec->Flags & ATTRIBUTE_FLAG_COMPRESSION_MASK) != 0) {
            swprintf(buf, TEXT("        Total allocated: \t%x"),
                    prec->Form.Nonresident.TotalAllocated.LowPart);
            WriteLine(DeviceContext, CurrentLine++, buf);
        }

        NTFS_EXTENT_LIST    extents;
        BIG_INT             vcn, lcn, run_length;
        ULONG               i;

        if (!attrrec.QueryExtentList(&extents)) {
            return;
        }

        swprintf(buf, TEXT("        Extent list {"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        for (i = 0; i < extents.QueryNumberOfExtents(); i++) {

            nDrawY = CurrentLine * QueryCharHeight();

            if (nDrawY < QueryScrollPosition()*QueryCharHeight()) {
                nDrawY += QueryCharHeight();
                CurrentLine++;
                continue;
            }

            if (nDrawY > QueryScrollPosition()*QueryCharHeight() +
                         QueryClientHeight()) {

                break;
            }

            if (!extents.QueryExtent(i, &vcn, &lcn, &run_length)) {
                break;
            }

            swprintf(buf, TEXT("            (vcn, lcn, run length): (%x, %x, %x)"),
                    vcn.GetLowPart(), lcn.GetLowPart(), run_length.GetLowPart());
            WriteLine(DeviceContext, CurrentLine++, buf);
        }

        swprintf(buf, TEXT("        }"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    }"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("}"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        CurrentLine++;

        DELETE(pstr);
    }

    SetRange(WindowHandle, CurrentLine - 1);
}


VOID
FRS_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
FRS_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}

VOID
FRS_EDIT::DisplayStandardInformation(
    IN      PATTRIBUTE_RECORD_HEADER pRec,
    IN      HDC DeviceContext,
    IN OUT  INT &CurrentLine
    )
{
    PSTANDARD_INFORMATION2 Info2;
    PSTANDARD_INFORMATION  Info;
    PTCHAR   pc;
    TCHAR    sbFlags[32];

    Info  = (PSTANDARD_INFORMATION ) ((PCHAR)pRec + pRec->Form.Resident.ValueOffset);
    Info2 = (PSTANDARD_INFORMATION2) ((PCHAR)pRec + pRec->Form.Resident.ValueOffset);

    swprintf( buf, TEXT( "    CreationTime:         %16I64x" ), Info->CreationTime );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    LastModificationTime: %16I64x" ), Info->LastModificationTime );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    LastChangeTime:       %16I64x" ), Info->LastChangeTime );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    LastAccessTime:       %16I64x" ), Info->LastAccessTime );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    FileAttributes:   %08lx" ), Info->FileAttributes );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    MaximumVersions:  %08lx" ), Info->MaximumVersions );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    VersionNumber:    %08lx" ), Info->VersionNumber );
    WriteLine( DeviceContext, CurrentLine++, buf );


    if (pRec->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION2 )) {
        swprintf( buf, TEXT( "    ClassId:    %08lx" ), Info2->ClassId );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT( "    OwnerId:    %08lx" ), Info2->OwnerId );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT( "    SecurityId: %08lx" ), Info2->SecurityId );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT( "    QuotaCharged: %16I64x" ), Info2->QuotaCharged );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT( "    Usn:          %16I64x" ), Info2->Usn );
        WriteLine( DeviceContext, CurrentLine++, buf );
    }
}

VOID
FRS_EDIT::DisplayFileName(
    IN      PATTRIBUTE_RECORD_HEADER pRec,
    IN      HDC DeviceContext,
    IN OUT  INT &CurrentLine
    )
{
    PFILE_NAME pfn;
    PTCHAR   pc;
    TCHAR    sbFlags[32];

    pfn = (PFILE_NAME)((PCHAR)pRec + pRec->Form.Resident.ValueOffset);

    swprintf(buf, TEXT("    File name: \t"));
    pc = buf + wcslen(buf);

    for (int i = 0; i < min(64, pfn->FileNameLength); ++i) {
        *pc++ = (CHAR)pfn->FileName[i];
    }
    *pc++ = '\0';

    if (pfn->FileNameLength > 64) {
        wcscat(buf, TEXT("..."));
    }

    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    FILE_REFERENCE ParentDirectory {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        LowPart: \t %x"),
         pfn->ParentDirectory.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Sequence number: %x"),
        pfn->ParentDirectory.SequenceNumber);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    }"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (pfn->Flags & FILE_NAME_NTFS) {
        wcscpy(sbFlags, TEXT("N"));
    } else {
        wcscpy(sbFlags, TEXT(" "));
    }
    if (pfn->Flags & FILE_NAME_DOS) {
        wcscat(sbFlags, TEXT("D"));
    }
    swprintf(buf, TEXT("    Flags: \t%x \t%s"), pfn->Flags, sbFlags);
    WriteLine(DeviceContext, CurrentLine++, buf);
}

VOID
FRS_EDIT::DisplayAttrList(
    IN      PATTRIBUTE_RECORD_HEADER pRec,
    IN      HDC DeviceContext,
    IN OUT  INT &CurrentLine
    )
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    PTCHAR  pc;
    CHAR    sbFlags[32];
    ULONG   LengthOfList = pRec->Form.Resident.ValueLength;
    ULONG   CurrentOffset;

    swprintf(buf, TEXT("    Attribute List Data {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)((PCHAR)pRec +
        pRec->Form.Resident.ValueOffset);
    CurrentOffset = 0;

    while (CurrentOffset < LengthOfList) {

        if (0 != CurrentOffset) {
            CurrentLine++;
        }

        PTCHAR SymbolicTypeCode = GetNtfsAttributeTypeCodeName(
            CurrentEntry->AttributeTypeCode);

        swprintf(buf, TEXT("\tAttribute type code: \t%x (%s)"),
            CurrentEntry->AttributeTypeCode, SymbolicTypeCode);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tRecord length \t\t%x"), CurrentEntry->RecordLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tAttribute name length \t%x"),
            CurrentEntry->AttributeNameLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tAttribute name offset \t%x"),
            CurrentEntry->AttributeNameOffset);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tLowest vcn \t\t<%x,%x>"),
            CurrentEntry->LowestVcn.GetHighPart(),
            CurrentEntry->LowestVcn.GetLowPart());
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tSegment reference: \t<%x,%x>"),
            CurrentEntry->SegmentReference.HighPart,
            CurrentEntry->SegmentReference.LowPart,
            CurrentEntry->SegmentReference.SequenceNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tSequence number: \t%x"),
            CurrentEntry->SegmentReference.SequenceNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tInstance: \t\t%x"), CurrentEntry->Instance);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tAttribute name:\t\t"));
        pc = buf + wcslen(buf);

        for (int i = 0; i < min(64, CurrentEntry->AttributeNameLength); ++i) {
            *pc++ = (CHAR)CurrentEntry->AttributeName[i];
        }
        *pc++ = '\0';

        if (CurrentEntry->AttributeNameLength > 64) {
            wcscat(buf, TEXT("..."));
        }
        WriteLine(DeviceContext, CurrentLine++, buf);

        CurrentOffset += CurrentEntry->RecordLength;
        CurrentEntry = NextEntry(CurrentEntry);
    }

    swprintf(buf, TEXT("    }"));
    WriteLine(DeviceContext, CurrentLine++, buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\io.cxx ===
#include "ulib.hxx"
#include "io.hxx"


STATIC TCHAR HeaderText[] = { 'D', 'i', 's', 'k', 'E', 'd', 'i', 't', 0 };


IO_OBJECT::~IO_OBJECT(
    )
{
}


BOOLEAN
IO_OBJECT::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    *Error = FALSE;
    return TRUE;
}


BOOLEAN
IO_OBJECT::Read(
    OUT PULONG  pError
    )
{
    return TRUE;
}


BOOLEAN
IO_OBJECT::Write(
    )
{
    return TRUE;
}


PVOID
IO_OBJECT::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = 0;
    }
    return NULL;
}


PTCHAR
IO_OBJECT::GetHeaderText(
    )
{
    return HeaderText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\fileio.cxx ===
#include "ulib.hxx"
#include "fileio.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

STATIC TCHAR FilePath[MAX_PATH];

BOOLEAN
FILE_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    FARPROC proc;

    proc = MakeProcInstance((FARPROC) ReadTheFile, Application);
    if (!DialogBox((HINSTANCE)Application, TEXT("ReadFileBox"),
                   WindowHandle, (DLGPROC) proc)) {
        *Error = FALSE;
        return FALSE;
    }
    FreeProcInstance(proc);

    *Error = TRUE;

    _file_handle = CreateFile(FilePath, GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);

    if (_file_handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (!_buffer_size) {
        _buffer_size = GetFileSize(_file_handle, NULL);
    }

    if (_buffer_size == (ULONG) -1) {
        return FALSE;
    }

    _buffer = Mem->Acquire(_buffer_size, Drive->QueryAlignmentMask());
    if (!_buffer) {
        return FALSE;
    }

    swprintf(_header_text, TEXT("%s"), FilePath);

    return TRUE;
}


BOOLEAN
FILE_IO::Read(
    OUT PULONG  pError
    )
{
    DWORD   bytes_read;

    *pError = 0;

    if (_file_handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (SetFilePointer(_file_handle, 0, NULL, FILE_BEGIN) == (DWORD) -1) {
        return FALSE;
    }

    if (!ReadFile(_file_handle, _buffer, _buffer_size, &bytes_read, NULL) ||
        bytes_read != _buffer_size) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
FILE_IO::Write(
    )
{
    DWORD   bytes_written;

    if (_file_handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (SetFilePointer(_file_handle, 0, NULL, FILE_BEGIN) == (DWORD) -1) {
        return FALSE;
    }

    if (!WriteFile(_file_handle, _buffer, _buffer_size, &bytes_written, NULL) ||
        bytes_written != _buffer_size) {

        return FALSE;
    }

    if (!SetEndOfFile(_file_handle)) {
        return FALSE;
    }

    return TRUE;
}


PVOID
FILE_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _buffer_size;
    }

    return _buffer;
}


PTCHAR
FILE_IO::GetHeaderText(
    )
{
    return _header_text;
}


BOOL
ReadTheFile(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                INT n;

                n = GetDlgItemText(hDlg, IDTEXT, FilePath, sizeof(FilePath)/sizeof(TCHAR));
                FilePath[n] = 0;

                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\indxedit.cxx ===
#include "ulib.hxx"
#include "untfs.hxx"
#include "indxedit.hxx"
#include "frsstruc.hxx"
#include "ntfssa.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"

extern "C" {
#include <stdio.h>
}

///////////////////////////////////////////////////////////////////////////////
//  Common support for USA fixups                                            //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
PostReadMultiSectorFixup(
    IN OUT  PVOID   MultiSectorBuffer,
    IN      ULONG   BufferSize
    )
/*++

Routine Description:

    This routine first verifies that the first element of the
    update sequence array is written at the end of every
    SEQUENCE_NUMBER_STRIDE bytes.  If not, then this routine
    returns FALSE.

    Otherwise this routine swaps the following elements in the
    update sequence array into the appropriate positions in the
    multi sector buffer.

    This routine will also check to make sure that the update
    sequence array is valid and that the BufferSize is appropriate
    for this size of update sequence array.  Otherwise, this
    routine will not update the array sequence and return TRUE.

Arguments:

    MultiSectorBuffer   - Supplies the buffer to be updated.
    BufferSize          - Supplies the number of bytes in this
                            buffer.

Return Value:

    FALSE   - The last write to this buffer failed.
    TRUE    - There is no evidence that this buffer is bad.

--*/
{
    PUNTFS_MULTI_SECTOR_HEADER    pheader;
    USHORT                  i, size, offset;
    PUPDATE_SEQUENCE_NUMBER parray, pnumber;

    pheader = (PUNTFS_MULTI_SECTOR_HEADER) MultiSectorBuffer;
    size = pheader->UpdateSequenceArraySize;
    offset = pheader->UpdateSequenceArrayOffset;

    if (BufferSize%SEQUENCE_NUMBER_STRIDE ||
        offset%sizeof(UPDATE_SEQUENCE_NUMBER) ||
        offset + size*sizeof(UPDATE_SEQUENCE_NUMBER) > BufferSize ||
        BufferSize/SEQUENCE_NUMBER_STRIDE + 1 != size) {

        return TRUE;
    }

    parray = (PUPDATE_SEQUENCE_NUMBER) ((PCHAR) pheader + offset);

    for (i = 1; i < size; i++) {

        pnumber = (PUPDATE_SEQUENCE_NUMBER)
                  ((PCHAR) pheader + (i*SEQUENCE_NUMBER_STRIDE -
                   sizeof(UPDATE_SEQUENCE_NUMBER)));

        if (*pnumber != parray[0]) {
            return FALSE;
        }

        *pnumber = parray[i];
    }

    return TRUE;
}


VOID
PreWriteMultiSectorFixup(
    IN OUT  PVOID   MultiSectorBuffer,
    IN      ULONG   BufferSize
    )
/*++

Routine Description:

    This routine first checks to see if the update sequence
    array is valid.  If it is then this routine increments the
    first element of the update sequence array.  It then
    writes the value of the first element into the buffer at
    the end of every SEQUENCE_NUMBER_STRIDE bytes while
    saving the old values of those locations in the following
    elements of the update sequence arrary.

Arguments:

    MultiSectorBuffer   - Supplies the buffer to be updated.
    BufferSize          - Supplies the number of bytes in this
                            buffer.

Return Value:

    None.

--*/
{
    PUNTFS_MULTI_SECTOR_HEADER    pheader;
    USHORT                  i, size, offset;
    PUPDATE_SEQUENCE_NUMBER parray, pnumber;

    pheader = (PUNTFS_MULTI_SECTOR_HEADER) MultiSectorBuffer;
    size = pheader->UpdateSequenceArraySize;
    offset = pheader->UpdateSequenceArrayOffset;

    if (BufferSize%SEQUENCE_NUMBER_STRIDE ||
        offset%sizeof(UPDATE_SEQUENCE_NUMBER) ||
        offset + size*sizeof(UPDATE_SEQUENCE_NUMBER) > BufferSize ||
        BufferSize/SEQUENCE_NUMBER_STRIDE + 1 != size) {

        return;
    }

    parray = (PUPDATE_SEQUENCE_NUMBER) ((PCHAR) pheader + offset);

    parray[0]++;

    for (i = 1; i < size; i++) {

        pnumber = (PUPDATE_SEQUENCE_NUMBER)
                  ((PCHAR) pheader + (i*SEQUENCE_NUMBER_STRIDE -
                   sizeof(UPDATE_SEQUENCE_NUMBER)));

        parray[i] = *pnumber;
        *pnumber = parray[0];
    }
}

///////////////////////////////////////////////////////////////////////////////
//  Common support for viewing  indexes                                      //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
INDEX_BUFFER_BASE::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}


VOID
INDEX_BUFFER_BASE::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}

VOID
INDEX_BUFFER_BASE::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
INDEX_BUFFER_BASE::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}

VOID
INDEX_BUFFER_BASE::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    TCHAR buf[1024];

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || !_size) {
        return;
    }

    if (0 != memcmp(_buffer, "INDX", 4) && 0 != memcmp(_buffer, "BAAD", 4)) {
        PaintIndexRoot(DeviceContext, InvalidRect, WindowHandle);
        return;
    }

    INT BytesRemaining = _size;
    PVOID CurrentBuffer = _buffer;
    INT   CurrentLine = 0;
    ULONG BufferNumber = 0;;

    while( BytesRemaining ) {

        // Resolve the update sequence array.  Note that we must
        // resolve it back before we exit this function, or else
        // write will get hosed.
        //
        PINDEX_ALLOCATION_BUFFER  IndexBuffer =
            (PINDEX_ALLOCATION_BUFFER)CurrentBuffer;

        INT BytesPerIndexBuffer =
            FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, IndexHeader ) +
                IndexBuffer->IndexHeader.BytesAvailable;

        ULONG CurrentOffset =
            BufferNumber * BytesPerIndexBuffer +
                FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, IndexHeader );

        PostReadMultiSectorFixup( CurrentBuffer, BytesPerIndexBuffer );

        swprintf(buf, TEXT("Signature: %c%c%c%c"),
                IndexBuffer->MultiSectorHeader.Signature[0],
                IndexBuffer->MultiSectorHeader.Signature[1],
                IndexBuffer->MultiSectorHeader.Signature[2],
                IndexBuffer->MultiSectorHeader.Signature[3]);
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf(buf, TEXT("Update sequence array offset: %x"),
                IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset);
        WriteLine( DeviceContext, CurrentLine++, buf );


        swprintf(buf, TEXT("Update sequence array size: %x"),
                IndexBuffer->MultiSectorHeader.UpdateSequenceArraySize);
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf(buf, TEXT("This VCN: %x"), IndexBuffer->ThisVcn.GetLowPart() );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("") );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf(buf, TEXT("INDEX HEADER at offset %x"), CurrentOffset );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  FirstIndexEntry: \t%x"),
            IndexBuffer->IndexHeader.FirstIndexEntry );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  FirstFreeByte:   \t%x"),
            IndexBuffer->IndexHeader.FirstFreeByte );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  BytesAvailable:  \t%x"),
            IndexBuffer->IndexHeader.BytesAvailable );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Flags: \t\t%x"), IndexBuffer->IndexHeader.Flags );
        if( IndexBuffer->IndexHeader.Flags & INDEX_NODE ) {

            wcscat( buf, TEXT("\t INDEX_NODE "));
        }
        WriteLine( DeviceContext, CurrentLine++, buf );

        //
        // Don't print the Update Sequence Array--it's not interesting.
        //

        //
        // Now iterate through the index entries:
        //
        CurrentOffset += IndexBuffer->IndexHeader.FirstIndexEntry;

        WalkAndPaintIndexRecords( DeviceContext, CurrentOffset, CurrentLine );

        PreWriteMultiSectorFixup( CurrentBuffer, BytesPerIndexBuffer );

        if( BytesRemaining <= BytesPerIndexBuffer ) {

            BytesRemaining = 0;

        } else {

            BytesRemaining -= BytesPerIndexBuffer;
            CurrentBuffer = (PBYTE)CurrentBuffer + BytesPerIndexBuffer;
            BufferNumber++;

            WriteLine( DeviceContext, CurrentLine++, TEXT("") );
            WriteLine( DeviceContext, CurrentLine++, TEXT("****************************************") );
            WriteLine( DeviceContext, CurrentLine++, TEXT("") );
            WriteLine( DeviceContext, CurrentLine++, TEXT("****************************************") );
            WriteLine( DeviceContext, CurrentLine++, TEXT("") );
        }
    }

    SetRange(WindowHandle, CurrentLine + 50);
}


VOID
INDEX_BUFFER_BASE::PaintIndexRoot(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    TCHAR buf[1024];

    INT BytesRemaining = _size;
    PVOID CurrentBuffer = _buffer;
    INT CurrentLine = 0;
    ULONG BufferNumber = 0;
    PINDEX_ROOT IndexRoot = (PINDEX_ROOT)CurrentBuffer;

    ULONG BytesPerIndexRoot =
        FIELD_OFFSET(INDEX_ROOT, IndexHeader ) +
            IndexRoot->IndexHeader.BytesAvailable;

    ULONG CurrentOffset = FIELD_OFFSET(INDEX_ROOT, IndexHeader);

    swprintf(buf, TEXT("Attribute type code: %x"),
        IndexRoot->IndexedAttributeType);
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf(buf, TEXT("Collation rule: %x"), IndexRoot->CollationRule);
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf(buf, TEXT("Bytes Per Index Buffer: %x"),
            IndexRoot->BytesPerIndexBuffer);
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf(buf, TEXT("Clusters Per Index Buffer: %x"),
            IndexRoot->ClustersPerIndexBuffer);
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf(buf, TEXT("INDEX HEADER at offset %x"), CurrentOffset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("  FirstIndexEntry: \t%x"),
        IndexRoot->IndexHeader.FirstIndexEntry );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("  FirstFreeByte:   \t%x"),
        IndexRoot->IndexHeader.FirstFreeByte );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("  BytesAvailable:  \t%x"),
        IndexRoot->IndexHeader.BytesAvailable );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("  Flags: \t\t%x"), IndexRoot->IndexHeader.Flags );
    if( IndexRoot->IndexHeader.Flags & INDEX_NODE ) {

        wcscat( buf, TEXT("\t INDEX_NODE "));
    }
    WriteLine( DeviceContext, CurrentLine++, buf );

    //
    // Now iterate through the index entries:
    //
    CurrentOffset += IndexRoot->IndexHeader.FirstIndexEntry;

    WalkAndPaintIndexRecords( DeviceContext, CurrentOffset, CurrentLine );
}


VOID
INDEX_BUFFER_BASE::WalkAndPaintIndexRecords(
    IN HDC      DeviceContext,
    IN ULONG    Offset,
    IN OUT int &CurrentLine
    )
{
    TCHAR buf[1024];

    //
    //  Iterate through the index entries:
    //
    while( Offset < _size ) {

        PINDEX_ENTRY CurrentEntry = (PINDEX_ENTRY)((PBYTE)_buffer + Offset);

        //
        // check for corruption that will mess up the loop--if
        // the length of the current entry is zero or would overflow
        // the buffer, exit.
        //
        if( CurrentEntry->Length == 0  ||
            Offset + CurrentEntry->Length > _size ) {

            // Don't need to comment on the corruption--the user
            // can recognize it by noting that the last entry
            // is not an END entry.
            //
            break;
        }

        swprintf( buf, TEXT("") );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("INDEX ENTRY at offset %x"), Offset );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Length: \t %x"), CurrentEntry->Length );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Value Length:  %x"), CurrentEntry->AttributeLength );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Flags: \t %x"), CurrentEntry->Flags );
        if( CurrentEntry->Flags & INDEX_ENTRY_NODE ) {

            wcscat( buf, TEXT(" INDEX_ENTRY_NODE") );
        }
        if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

            wcscat( buf, TEXT(" INDEX_ENTRY_END") );
        }
        WriteLine( DeviceContext, CurrentLine++, buf );

        if( CurrentEntry->Flags & INDEX_ENTRY_NODE ) {

            swprintf( buf, TEXT("  Downpointer: %x"), (GetDownpointer(CurrentEntry)).GetLowPart() );
            WriteLine( DeviceContext, CurrentLine++, buf );
        }

        //
        // If the current entry is the END entry, we're done.
        //
        if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

            break;
        }

        if( sizeof( INDEX_ENTRY ) + CurrentEntry->AttributeLength >
            CurrentEntry->Length ) {

            swprintf( buf, TEXT("  ***Attribute value overflows entry.") );
            WriteLine( DeviceContext, CurrentLine++, buf );

        } else {
            PaintIndexRecord( DeviceContext, CurrentEntry, CurrentLine );
        }

        Offset += CurrentEntry->Length;
    }
}


///////////////////////////////////////////////////////////////////////////////
//  Support for viewing namespace indexes                                    //
///////////////////////////////////////////////////////////////////////////////


VOID
NAME_INDEX_BUFFER_EDIT::PaintIndexRecord (
    IN HDC          DeviceContext,
    IN PINDEX_ENTRY CurrentEntry,
    IN OUT int &  CurrentLine
    )
{
    TCHAR buf[1024];
    PFILE_NAME FileName;
    ULONG i, j;

    swprintf( buf, TEXT("  File Reference (FRS, Seq No): %x, %x"),
                     CurrentEntry->FileReference.LowPart,
                     CurrentEntry->FileReference.SequenceNumber );
    WriteLine( DeviceContext, CurrentLine++, buf );

    // This had better be a file name attribute, since
    // that's how I'll display it.
    //
    swprintf( buf, TEXT("  FILE NAME at offset %x"),
              (PCHAR) CurrentEntry - (PCHAR) _buffer + sizeof( INDEX_ENTRY ) );
    FileName = (PFILE_NAME)( (PBYTE)CurrentEntry + sizeof(INDEX_ENTRY) );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("    Parent Directory (FRS, Seq No): %x, %x"),
             FileName->ParentDirectory.LowPart,
             FileName->ParentDirectory.SequenceNumber );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("    Name Length: %x"), FileName->FileNameLength );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("    Flags: \t %x"), FileName->Flags );
    if( FileName->Flags & FILE_NAME_DOS ) {

        wcscat( buf, TEXT(" D") );
    }
    if( FileName->Flags & FILE_NAME_NTFS ) {

        wcscat( buf, TEXT(" N") );
    }
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("    File name:   ") );
    j = wcslen( buf );

    for( i = 0; i < FileName->FileNameLength; i++ ) {

        buf[i+j] = (TCHAR)(FileName->FileName[i]);
    }
    buf[FileName->FileNameLength+j] = 0;
    WriteLine( DeviceContext, CurrentLine++, buf );
}

///////////////////////////////////////////////////////////////////////////////
//  Support for viewing Security Id indexes                                  //
///////////////////////////////////////////////////////////////////////////////

VOID
SECURITY_ID_INDEX_BUFFER_EDIT::PaintIndexRecord(
    IN HDC          DeviceContext,
    IN PINDEX_ENTRY CurrentEntry,
    IN OUT int &  CurrentLine
    )
{
    TCHAR buf[1024];

    //
    //  This had better be a security id index record.  The format of
    //  the record is:
    //
    //      INDEX_ENTRY
    //          DataOffset
    //          DataLength
    //      SECURITY_ID
    //      SECURITY_DESCRIPTOR_HEADER
    //

    swprintf( buf, TEXT( "  DataOffset %x" ), CurrentEntry->DataOffset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  DataLength %x" ), CurrentEntry->DataLength );
    WriteLine( DeviceContext, CurrentLine++, buf );

    PULONG SecurityId = (PULONG) ((PBYTE)CurrentEntry + sizeof( INDEX_ENTRY ));
    PSECURITY_DESCRIPTOR_HEADER Header =
        (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE)CurrentEntry + CurrentEntry->DataOffset);

    swprintf( buf, TEXT( "  Key Security Id %08x" ), *SecurityId );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.Hash %08x" ), Header->HashKey.Hash );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.SecurityId %08x" ), Header->HashKey.SecurityId );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  Header.Offset %I64x" ), Header->Offset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  Header.Length %x" ), Header->Length );
    WriteLine( DeviceContext, CurrentLine++, buf );
}

///////////////////////////////////////////////////////////////////////////////
//  Support for viewing Security Hash indexes                                //
///////////////////////////////////////////////////////////////////////////////

VOID
SECURITY_HASH_INDEX_BUFFER_EDIT::PaintIndexRecord(
    IN HDC          DeviceContext,
    IN PINDEX_ENTRY CurrentEntry,
    IN OUT int &  CurrentLine
    )
{
    TCHAR buf[1024];

    //
    //  This had better be a security id index record.  The format of
    //  the record is:
    //
    //      INDEX_ENTRY
    //          DataOffset
    //          DataLength
    //      SECURITY_HASHKEY
    //      SECURITY_DESCRIPTOR_HEADER
    //

    swprintf( buf, TEXT( "  DataOffset %x" ), CurrentEntry->DataOffset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  DataLength %x" ), CurrentEntry->DataLength );
    WriteLine( DeviceContext, CurrentLine++, buf );

    PSECURITY_HASH_KEY HashKey = (PSECURITY_HASH_KEY) ((PBYTE)CurrentEntry + sizeof( INDEX_ENTRY ));
    PSECURITY_DESCRIPTOR_HEADER Header =
        (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE)CurrentEntry + CurrentEntry->DataOffset);

    swprintf( buf, TEXT( "  HashKey.Hash %08x" ), HashKey->Hash );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.SecurityId %08x" ), HashKey->SecurityId );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.Hash %08x" ), Header->HashKey.Hash );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.SecurityId %08x" ), Header->HashKey.SecurityId );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  Header.Offset %I64x" ), Header->Offset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  Header.Length %x" ), Header->Length );
    WriteLine( DeviceContext, CurrentLine++, buf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\lfs.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Lfs.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the Log File Service.

Author:
    Brian Andrew    [BrianAn]   20-June-1991


Revision History:

--*/

#ifndef _LFS_
#define _LFS_

//
// The Multi-Sector Header and Update Sequence Array provide detection of
// incomplete multi-sector transfers for devices which either have a
// physical sector size equal to the Sequence Number Stride or greater, or
// which do not transfer sectors out of order.  If a device exists which has
// a sector size smaller than the Sequence Number Stride *and* it sometimes
// transfers sectors out of order, then the Update Sequence Array will not
// provide absolute detection of incomplete transfers.  The Sequence Number
// Stride is set to a small enough number to provide absolute protection for
// all known hard disks.  It is not set any smaller, in order to avoid
// excessive run time and space overhead.
//
// The Multi-Sector Header contains space for a four-byte signature for the
// convenience of its user.  It then provides the offset to and length of the
// the Update Sequence Array.  The Update Sequence Array consists of an array
// of n saved USHORTs, where n is the size of the structure being protected
// divided by the sequence number stride.  (The size of structure being
// protected must be a nonzero power of 2 times the Sequence Number Stride,
// and less than or equal to the physical page size of the machine.)  The
// first word of the Update Sequence Array contains the Update Sequence Number,
// which is a cyclical counter (however 0 is not used) of the number of times
// the containing structure has been written to disk.  Following the Update
// Sequence Number are the n saved USHORTs which were overwritten by the
// Update Sequence Number the last time the containing structure was
// written to disk.
//
// In detail, just prior to each time the protected structure is written to
// disk, the last word in each Sequence Number Stride is saved to its
// respective position in the Sequence Number Array, and then it is overwritten
// with the next Update Sequence Number.  Just after this write, or whenever
// reading the structure, the saved word from the Sequence Number Array is
// restored to its actual position in the structure.  Before restoring the
// saved words on reads, all of the sequence numbers at the end of each
// stride are compared with the actual sequence number at the start of the
// array.  If any of these compares come up not equal, then a failed
// multi-sector transfer has been detected.
//
// The size of the array is determined by the size of the containing structure.
// As a C detail, the array is declared here with a size of 1, since its
// actual size can only be determined at runtime.
//
// The Update Sequence Array should be included at the end of the header of
// the structure it is protecting, since it is variable size.  Its user must
// insure that the correct size is reserved for it, namely:
//
//      (sizeof-structure / SEQUENCE_NUMBER_STRIDE + 1) * sizeof(USHORT)
//

#define SEQUENCE_NUMBER_STRIDE           (512)

typedef USHORT UPDATE_SEQUENCE_NUMBER, *PUPDATE_SEQUENCE_NUMBER;

//
// This array must be present at the offset described above.
//

typedef UPDATE_SEQUENCE_NUMBER UPDATE_SEQUENCE_ARRAY[1];

typedef UPDATE_SEQUENCE_ARRAY *PUPDATE_SEQUENCE_ARRAY;

//
//  The following structure is used to identify a log record by a log
//  sequence number.
//

typedef LARGE_INTEGER LSN, *PLSN;

//
//  The following Lsn will never occur in a file, it is used to indicate
//  a non-lsn.
//

extern LSN LfsZeroLsn;

//
//  The following type defines the different log record types.
//

typedef enum _LFS_RECORD_TYPE {

    LfsClientRecord = 1,
    LfsClientRestart

} LFS_RECORD_TYPE, *PLFS_RECORD_TYPE;

//
//  The following search modes are supported.
//

typedef enum _LFS_CONTEXT_MODE {

    LfsContextUndoNext = 1,
    LfsContextPrevious,
    LfsContextForward

} LFS_CONTEXT_MODE, *PLFS_CONTEXT_MODE;

typedef ULONG TRANSACTION_ID, *PTRANSACTION_ID;

typedef enum _TRANSACTION_STATE {

    TransactionUninitialized = 0,
    TransactionActive,
    TransactionPrepared,
    TransactionCommitted

} TRANSACTION_STATE, *PTRANSACTION_STATE;

typedef enum _LFS_INFO {

    LfsUseUsa = 1,
    LfsPackLog

} LFS_INFO, *PLFS_INFO;

typedef PVOID LFS_LOG_HANDLE, *PLFS_LOG_HANDLE;

typedef PVOID LFS_LOG_CONTEXT, *PLFS_LOG_CONTEXT;

//
//  Write Entry for LfsWrite and LfsForceWrite.  The interface to these
//  routines takes a pointer to a Write Entry along with a count of how
//  many Write Entries to expect to describe pieces of the caller's buffer
//  which are supposed to be copied in sequence to the log file.
//

typedef struct _LFS_WRITE_ENTRY {

    PVOID Buffer;
    ULONG ByteLength;

} LFS_WRITE_ENTRY, *PLFS_WRITE_ENTRY;


//
// Global Maintenance routines
//

BOOLEAN
LfsInitializeLogFileService (
    );

//
//  Log File Registration routines
//

typedef struct _LOG_FILE_INFORMATION {

    //
    //  This is the total useable space in the log file after space for
    //  headers and Lfs Restart Areas.
    //

    LONGLONG TotalAvailable;

    //
    //  This is the useable space in the log file from the current position
    //  in the log file to the lowest BaseLsn.  This total as returned is not
    //  yet reduced for undo commitments, returned separately below.
    //

    LONGLONG CurrentAvailable;

    //
    //  This is the total undo commitment for all clients of the log file.
    //  LfsWrite requests are refused when the sum of the write size of the
    //  request plus the UndoRequirement for the request plus the TotalUndoCommitment
    //  are greater than the CurrentAvailable.
    //

    LONGLONG TotalUndoCommitment;

    //
    //  This is the total undo commitment for this client.
    //

    LONGLONG ClientUndoCommitment;

    //
    //  Current system Lsn's.  Includes the Oldest, LastFlushed and current
    //  Lsn.
    //

    LSN OldestLsn;
    LSN LastFlushedLsn;
    LSN LastLsn;

} LOG_FILE_INFORMATION, *PLOG_FILE_INFORMATION;

#define LOG_FILE_DATA_BITS(D)      ((sizeof(LSN) * 8) - GetSeqNumberBits(D))
#define LOG_PAGE_MASK(D)        (GetLogPageSize(D) - 1)
#define LOG_PAGE_INVERSE_MASK(D)   (~LOG_PAGE_MASK(D))
#define LfsLogPageOffset(D, i)   ((i) & LOG_PAGE_MASK(D))
#define LfsLsnToPageOffset(D, lsn) (LfsLogPageOffset(D, (lsn).LowPart << three))
extern const int three;

#define LfsLsnToFileOffset(D, LSN)                 \
    /*xxShr*/(((ULONGLONG)/*xxShl*/((LSN).QuadPart << GetSeqNumberBits(D))) >> (GetSeqNumberBits(D) - three))
 
#define LfsTruncateLsnToLogPage(D, lsn, FO) {           \
    *(FO) = LfsLsnToFileOffset((D), (lsn));             \
    *((PULONG)(FO)) &= LOG_PAGE_INVERSE_MASK(D);        \
    }

#define LfsLsnToSeqNumber(D, LSN)                     \
    /*xxShr*/((ULONGLONG)/*xxShl*/((LSN).QuadPart) >> LOG_FILE_DATA_BITS(D))

#define LfsFileOffsetToLsn(D, FO, SN)          \
    ((((ULONGLONG)(FO)) >> three) + ((SN) << LOG_FILE_DATA_BITS(D)))
    

extern ULONG GetLogPageSize(PLOG_IO_DP_DRIVE);
extern ULONG GetSeqNumberBits(PLOG_IO_DP_DRIVE);

#endif  // LFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\gptedit.cxx ===
#include "ulib.hxx"
#include "gptedit.hxx"


extern "C" {
#include <stdio.h>
}

BOOLEAN
GUID_PARTITION_TABLE_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);

    return TRUE;
}


VOID
GUID_PARTITION_TABLE_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}


VOID
GUID_PARTITION_TABLE_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    GPT_HEADER                  header;
    PGPT_HEADER                 pgpth;
    GPT_ENTRY                   entry;
    PGPT_ENTRY                  pgpte;
    TEXTMETRIC                  textmetric;
    INT                         ch, CurrentLine;
    TCHAR                       buf[1024];
    ULONG                       i, *pul, blockSize, firstEntryOffset;
    PUCHAR                      pch; 

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || _size < 512) {
        return;
    }

    blockSize = 512;
    
    //
    // BUGBUG keithka 4/10/00 -- consider catching folks using either
    // sector 0 or an MBR by mistake?
    //
    pgpth = (PGPT_HEADER)((PBYTE)_buffer);

    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    CurrentLine = 0;

    pch = (PUCHAR) &pgpth->Signature;
    swprintf( buf, TEXT("Signature:         %c%c%c%c%c%c%c%c"), 
              pch[0], pch[1], pch[2], pch[3], pch[4], pch[5], pch[6], pch[7] );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("Revision:          0x%x"), pgpth->Revision );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("HeaderSize:        0x%x"), pgpth->HeaderSize );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("HeaderCRC32:       0x%x"), pgpth->HeaderCRC32 );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("MyLBA:             0x%x"), pgpth->MyLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("AlternateLBA:      0x%x"), pgpth->AlternateLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("FirstUsableLBA:    0x%x"), pgpth->FirstUsableLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("LastUsableLBA:     0x%x"), pgpth->LastUsableLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );    

//    swprintf( buf, TEXT("DiskGUID: 0x%x"), pgpth->DiskGUID );
//    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("TableLBA:          0x%x"), pgpth->TableLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("Entries Allocated: 0x%x"), pgpth->EntriesAllocated );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("SizeOfGPT_ENTRY:   0x%x"), pgpth->SizeOfGPT_ENTRY );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("TableCRC32:        0x%x"), pgpth->TableCRC32 );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    // Compute the sector checksum.  BUGBUG keithka 4/10/00 -- consider???
    //

    swprintf( buf, TEXT("") );
    WriteLine( DeviceContext, CurrentLine++, buf );

    if (pgpth->MyLBA >= pgpth->TableLBA) {

        swprintf( buf, TEXT("MyLBA >= TableLBA, corrupt GPT?") );
        WriteLine( DeviceContext, CurrentLine++, buf );

    } else {

        firstEntryOffset = (ULONG) (blockSize * (pgpth->TableLBA - pgpth->MyLBA));
        
        pgpte = (PGPT_ENTRY) ((PBYTE)pgpth + firstEntryOffset);
        
        for( i = 0; i < pgpth->EntriesAllocated; i++ ) {

            if( (firstEntryOffset + (i + 1) * sizeof(GPT_ENTRY)) > _size ) {

                // About to read beyond our buffer.
                //
                break;
            }

            swprintf( buf, TEXT("Entry %d"), i );
            WriteLine( DeviceContext, CurrentLine++, buf );

//            swprintf( buf, TEXT("  PartitionType: 0x%x"), pgpte->PartitionType );
//            WriteLine( DeviceContext, CurrentLine++, buf );

//            swprintf( buf, TEXT("  PartitionID:   0x%x"), pgpte->PartitionID );
//            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("  Starting LBA:  0x%x"), pgpte->StartingLBA );
            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("  Ending LBA:    0x%x"), pgpte->EndingLBA );
            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("  Attributes:    0x%x"), pgpte->Attributes );
            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("  PartitionName: %s"), pgpte->PartitionName );
            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("") );
            WriteLine( DeviceContext, CurrentLine++, buf );

            pgpte++;
        }

        if (0 == i) {

            swprintf( buf, TEXT("No valid GPT entries in the range read") );
            WriteLine( DeviceContext, CurrentLine++, buf );
        }
    }

    SetRange(WindowHandle, CurrentLine - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\logreced.cxx ===
#include "ulib.hxx"
#include "logreced.hxx"
#include "untfs.hxx"
#include "frsstruc.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"
#include "lfs.h"
#include "lfsdisk.h"
//#include "ntfsstru.h"
#include "ntfslog.h"

extern "C" {
#include <stdio.h>
}


BOOLEAN
LOG_RECORD_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;
    _drive = Drive;

    if (!_drive) {
        return FALSE;
    }

    if (!ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read()) {

        return FALSE;
    }

    _cluster_factor = ntfssa.QueryClusterFactor();
    _frs_size = ntfssa.QueryFrsSize();

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}


VOID
LOG_RECORD_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetRange(WindowHandle, _size/4);
}


VOID
LOG_RECORD_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    TCHAR                           buf[1024];
    INT                             nDrawX, nDrawY;
    PLFS_RECORD_HEADER              plog;
    PNTFS_LOG_RECORD_HEADER         pntfs_record;
    TEXTMETRIC                      tm;
    INT                             ch, CurrentLine;

    SetScrollRange(WindowHandle, SB_VERT, 0, _size/4, FALSE);
    SetScrollPos(WindowHandle, SB_VERT, QueryScrollPosition(), TRUE);

    if (!_buffer || !_size) {
        return;
    }

    GetTextMetrics(DeviceContext, &tm);
    ch = tm.tmExternalLeading + tm.tmHeight;
    CurrentLine = 0;

    plog = (PLFS_RECORD_HEADER)_buffer;
    pntfs_record = PNTFS_LOG_RECORD_HEADER(PUCHAR(_buffer) +
         LFS_RECORD_HEADER_SIZE);

    swprintf(buf, TEXT("ThisLsn: %x:%x"),
         plog->ThisLsn.HighPart,
         plog->ThisLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientPreviousLsn: %x:%x"),
         plog->ClientPreviousLsn.HighPart,
         plog->ClientPreviousLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientUndoNextLsn: %x:%x"),
         plog->ClientUndoNextLsn.HighPart,
         plog->ClientUndoNextLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientDataLength: %x"), plog->ClientDataLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientId.SeqNumber: %x"), plog->ClientId.SeqNumber);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientId.ClientIndex: %x"), plog->ClientId.ClientIndex);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RecordType: %x"), plog->RecordType);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("TransactionId: %x"), plog->TransactionId);
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (LOG_RECORD_MULTI_PAGE == plog->Flags) {
        swprintf(buf, TEXT("Flags: LOG_RECORD_MULTI_PAGE"));
    } else {
        swprintf(buf, TEXT("Flags: %x"), plog->Flags);
    }
    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentLine++;

    swprintf(buf, TEXT("RedoOperation: %x"), pntfs_record->RedoOperation);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("UndoOperation: %x"), pntfs_record->UndoOperation);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RedoOffset: %x"), pntfs_record->RedoOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RedoLength: %x"), pntfs_record->RedoLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("UndoOffset: %x"), pntfs_record->UndoOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("UndoLength: %x"), pntfs_record->UndoLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("TargetAttribute: %x"), pntfs_record->TargetAttribute);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LcnsToFollow: %x"), pntfs_record->LcnsToFollow);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RecordOffset: %x"), pntfs_record->RecordOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("AttributeOffset: %x"), pntfs_record->AttributeOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("TargetVcn: %x"), (ULONG)pntfs_record->TargetVcn);
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (0 != pntfs_record->LcnsToFollow) {

        WriteLine(DeviceContext, CurrentLine++, TEXT("Lcns:"));
    
        for (USHORT i = 0; i < pntfs_record->LcnsToFollow; ++i) {
    
            swprintf(buf, TEXT("    %x"), (ULONG)pntfs_record->LcnsForPage[i]);
            WriteLine(DeviceContext, CurrentLine++, buf);
        }
    }
}

VOID
LOG_RECORD_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
LOG_RECORD_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\lfsdisk.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsDisk.h

Abstract:

    This module defines the on-disk structures present in the log file.

Author:

    Brian Andrew    [BrianAn]   13-June-1991

Revision History:

IMPORTANT NOTE:

    The Log File Service will by used on systems that require that on-disk
    structures guarantee the natural alignment of all arithmetic quantities
    up to and including quad-word (64-bit) numbers.  Therefore, all Lfs
    on-disk structures are quad-word aligned, etc.

--*/

#ifndef _LFSDISK_
#define _LFSDISK_

#define MINIMUM_LFS_PAGES               0x00000030
#define MINIMUM_LFS_CLIENTS             1

//
//  The following macros are used to set and query with respect to the
//  update sequence arrays.
//

#define UpdateSequenceStructureSize( MSH )              \
    ((((PMULTI_SECTOR_HEADER) (MSH))->UpdateSequenceArraySize - 1) * SEQUENCE_NUMBER_STRIDE)

#define UpdateSequenceArraySize( STRUCT_SIZE )          \
    ((STRUCT_SIZE) / SEQUENCE_NUMBER_STRIDE + 1)

#define FIRST_STRIDE                                    \
    (SEQUENCE_NUMBER_STRIDE - sizeof( UPDATE_SEQUENCE_NUMBER ))


//
//  Log client ID.  This is used to uniquely identify a client for a
//  particular log file.
//

typedef struct _LFS_CLIENT_ID {

    USHORT SeqNumber;
    USHORT ClientIndex;

} LFS_CLIENT_ID, *PLFS_CLIENT_ID;


//
//  Log Record Header.  This is the header that begins every Log Record in
//  the log file.
//

typedef struct _LFS_RECORD_HEADER {

    //
    //  Log File Sequence Number of this log record.
    //

    LSN ThisLsn;

    //
    //  The following fields are used to back link Lsn's.  The ClientPrevious
    //  and ClientUndoNextLsn fields are used by a client to link his log
    //  records.
    //

    LSN ClientPreviousLsn;
    LSN ClientUndoNextLsn;

    //
    //  The following field is the size of data area for this record.  The
    //  log record header will be padded if necessary to fill to a 64-bit
    //  boundary, so the client data will begin on a 64-bit boundary to
    //  insure that all of his data is 64-bit aligned.  The below value
    //  has not been padded to 64 bits however.
    //

    ULONG ClientDataLength;

    //
    //  Client ID.  This identifies the owner of this log record.  The owner
    //  is uniquely identified by his offset in the client array and the
    //  sequence number associated with that client record.
    //

    LFS_CLIENT_ID ClientId;

    //
    //  This the Log Record type.  This could be a commit protocol record,
    //  a client restart area or a client update record.
    //

    LFS_RECORD_TYPE RecordType;

    //
    //  Transaction ID.  This is used externally by a client (Transaction
    //  Manager) to group log file entries.
    //

    TRANSACTION_ID TransactionId;

    //
    //  Log record flags.
    //

    USHORT Flags;

    //
    //  Alignment field.
    //

    USHORT AlignWord;

} LFS_RECORD_HEADER, *PLFS_RECORD_HEADER;

#define LOG_RECORD_MULTI_PAGE           (0x0001)

#define LFS_RECORD_HEADER_SIZE          QuadAlign( sizeof( LFS_RECORD_HEADER ))


//
//  Following are the version specific fields in the record page header.
//

typedef struct _LFS_UNPACKED_RECORD_PAGE {

    //
    //  This gives us the offset of the free space in the page.
    //

    USHORT NextRecordOffset;

    USHORT WordAlign;

    //
    //  Reserved.  The following array is reserved for possible future use.
    //

    USHORT Reserved;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_UNPACKED_RECORD_PAGE, *PLFS_UNPACKED_RECORD_PAGE;

typedef struct _LFS_PACKED_RECORD_PAGE {

    //
    //  This gives us the offset of the free space in the page.
    //

    USHORT NextRecordOffset;

    USHORT WordAlign;

    ULONG DWordAlign;

    //
    //  The following is the Lsn for the last log record which ends on the page.
    //

    LSN LastEndLsn;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_PACKED_RECORD_PAGE, *PLFS_PACKED_RECORD_PAGE;


//
//  Log Record Page Header.  This structure is present at the beginning of each
//  log file page in the client record section.
//

typedef struct _LFS_RECORD_PAGE_HEADER {

    //
    //  Cache multisector protection header.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;

    union {

        //
        //  Highest Lsn in this log file page.  This field is only for
        //  regular log pages.
        //

        LSN LastLsn;

        //
        //  Log file offset.  This is for the tail copies and indicates the
        //  location in the file where the original lays.  In this case the
        //  LastLsn field above can be obtained from the last ending Lsn
        //  field in the PACKED_RECORD_PAGE structure.
        //

        LONGLONG FileOffset;

    } Copy;

    //
    //  Page Header Flags.  These are the same flags that are stored in the
    //  Lbcb->Flags field.
    //
    //      LOG_PAGE_LOG_RECORD_END     -   Page contains the end of a log record
    //

    ULONG Flags;

    //
    //  I/O Page Position.  The following fields are used to determine
    //  where this log page resides within a Lfs I/O transfer.
    //

    USHORT PageCount;
    USHORT PagePosition;

    //
    //  The following is the difference between version 1.1 and earlier.
    //

    union {

        LFS_UNPACKED_RECORD_PAGE Unpacked;
        LFS_PACKED_RECORD_PAGE Packed;

    } Header;

} LFS_RECORD_PAGE_HEADER, *PLFS_RECORD_PAGE_HEADER;

#define LOG_PAGE_LOG_RECORD_END             (0x00000001)

#define LFS_UNPACKED_RECORD_PAGE_HEADER_SIZE        (                               \
    FIELD_OFFSET( LFS_RECORD_PAGE_HEADER, Header.Unpacked.UpdateSequenceArray )     \
)

#define LFS_PACKED_RECORD_PAGE_HEADER_SIZE          (                               \
    FIELD_OFFSET( LFS_RECORD_PAGE_HEADER, Header.Packed.UpdateSequenceArray )       \
)

//
//  Id strings for the page headers.
//

#define LFS_SIGNATURE_RESTART_PAGE          "RSTR"
#define LFS_SIGNATURE_RESTART_PAGE_ULONG    0x52545352
#define LFS_SIGNATURE_RECORD_PAGE           "RCRD"
#define LFS_SIGNATURE_RECORD_PAGE_ULONG     0x44524352
#define LFS_SIGNATURE_BAD_USA               "BAAD"
#define LFS_SIGNATURE_BAD_USA_ULONG         0x44414142
#define LFS_SIGNATURE_MODIFIED              "CHKD"
#define LFS_SIGNATURE_MODIFIED_ULONG        0x444b4843
#define LFS_SIGNATURE_UNINITIALIZED         "\377\377\377\377"
#define LFS_SIGNATURE_UNINITIALIZED_ULONG   0xffffffff


//
//  Log Client Record.  A log client record exists for each client user of
//  the log file.  One of these is in each Lfs restart area.
//

#define LFS_NO_CLIENT                           0xffff
#define LFS_CLIENT_NAME_MAX                     64

#define RESTART_SINGLE_PAGE_IO              (0x0001)

#define LFS_RESTART_AREA_SIZE       (FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray ))

#endif // _LFSDISK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\logrecio.cxx ===
#include "ulib.hxx"
#include "logrecio.hxx"
#include "attrib.hxx"
#include "mftfile.hxx"
#include "diskedit.h"

extern "C" {
#include "lfs.h"
#include "lfsdisk.h"
#include <stdio.h>
}

const int three = 3;

STATIC LSN Lsn;

BOOLEAN
LOG_RECORD_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    FARPROC proc;
    NTFS_SA ntfssa;
    MESSAGE msg;
    NTFS_MFT_FILE mft;
    ULONG       PageOffset;
    LONGLONG    FileOffset;
    BOOLEAN error;

    _drive = Drive;

    proc = MakeProcInstance((FARPROC)ReadLogRecord, Application);
    if (!DialogBox((HINSTANCE)Application, TEXT("ReadLogRecordBox"),
                   WindowHandle, (DLGPROC) proc)) {
        *Error = FALSE;
        return FALSE;
    }
    FreeProcInstance(proc);

    *Error = TRUE;

    if (!_drive ||
        !ntfssa.Initialize(_drive, &msg) ||
        !ntfssa.Read() ||
        !mft.Initialize(_drive, ntfssa.QueryMftStartingLcn(),
            ntfssa.QueryClusterFactor(), ntfssa.QueryFrsSize(),
            ntfssa.QueryVolumeSectors(), NULL, NULL) ||
        !mft.Read() ||
        !_frs.Initialize((VCN)LOG_FILE_NUMBER, &mft) ||
        !_frs.Read()) {

        return FALSE;
    }

    if (!_frs.QueryAttribute(&_attrib, &error, $DATA, NULL)) {
        return FALSE;
    }

    LfsTruncateLsnToLogPage(Drive, Lsn, &FileOffset);
    PageOffset = LfsLsnToPageOffset(Drive, Lsn);

    swprintf(_header_text, TEXT("DiskEdit - Log record: page @ %x, offset %x"),
            (ULONG)FileOffset, PageOffset);

    return TRUE;
}


BOOLEAN
LOG_RECORD_IO::Read(
    OUT PULONG  pError
    )
{
    LFS_RECORD_HEADER RecordHeader;
    ULONG       PageOffset;
    LONGLONG    FileOffset;
    ULONG       bytes_read;
    ULONG       RemainingLength, CurrentPos, ThisPagePortion;

    *pError = 0;

    (void)GetLogPageSize(_drive);

    LfsTruncateLsnToLogPage(_drive, Lsn, &FileOffset);
    PageOffset = LfsLsnToPageOffset(_drive, Lsn);

    //
    // Read in the record header to see how big the total record
    // is.
    //

    if (!_attrib.Read((PVOID)&RecordHeader, ULONG(PageOffset | FileOffset),
        LFS_RECORD_HEADER_SIZE, &bytes_read) ||
        bytes_read != LFS_RECORD_HEADER_SIZE) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }

    _length = LFS_RECORD_HEADER_SIZE + RecordHeader.ClientDataLength;
    if (NULL == (_buffer = MALLOC(_length))) {
        *pError = (ULONG)STATUS_INSUFFICIENT_RESOURCES;
        return FALSE;
    }

    RemainingLength = _length;
    CurrentPos = 0;

    while (RemainingLength > 0) {
        ThisPagePortion = MIN(GetLogPageSize(_drive) - PageOffset,
             RemainingLength);

        if (!_attrib.Read((PUCHAR)_buffer + CurrentPos,
            ULONG(FileOffset | PageOffset),
            ThisPagePortion, &bytes_read) ||
            bytes_read != ThisPagePortion) {
            *pError = _drive->QueryLastNtStatus();
            return FALSE;
        }

        CurrentPos += ThisPagePortion;
        RemainingLength -= ThisPagePortion;
        FileOffset += GetLogPageSize(_drive);
        PageOffset = LFS_PACKED_RECORD_PAGE_HEADER_SIZE;
    }

    return TRUE;
}


BOOLEAN
LOG_RECORD_IO::Write(
    )
{
    return FALSE;
}


PVOID
LOG_RECORD_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _length;
    }

    return _buffer;
}


PTCHAR
LOG_RECORD_IO::GetHeaderText(
    )
{
    return _header_text;
}


BOOL
ReadLogRecord(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    TCHAR buf[1024];
    PTCHAR pch;
    INT n;

    switch (message) {
    case WM_INITDIALOG:
            swprintf(buf, TEXT("%x:%x"), Lsn.HighPart, Lsn.LowPart);
            SetDlgItemText(hDlg, IDTEXT, buf);
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {
            n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;

            if (NULL == (pch = wcschr(buf, ':'))) {
                Lsn.HighPart = 0;
                swscanf(buf, TEXT("%x"), &Lsn.LowPart);
            } else {
                *pch = 0;
                swscanf(buf, TEXT("%x"), &Lsn.HighPart);
                swscanf(pch + 1, TEXT("%x"), &Lsn.LowPart);
                *pch = ':';
            }
            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\nbedit.cxx ===
#include "ulib.hxx"
#include "nbedit.hxx"
#include "untfs.hxx"

extern "C" {
#include <stdio.h>
}


VOID
NTFS_BOOT_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
NTFS_BOOT_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PPACKED_BOOT_SECTOR     p;
    BIOS_PARAMETER_BLOCK    bpb;
    TEXTMETRIC              textmetric;
    INT                     ch, current;
    TCHAR                   buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);

    if (!_buffer || _size < 128) {
        return;
    }

    p = (PPACKED_BOOT_SECTOR) _buffer;
    UnpackBios(&bpb, &(p->PackedBpb));

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));
    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    current = 0;

    swprintf(buf, TEXT("OEM String:           %c%c%c%c%c%c%c%c"),
                 p->Oem[0],
                 p->Oem[1],
                 p->Oem[2],
                 p->Oem[3],
                 p->Oem[4],
                 p->Oem[5],
                 p->Oem[6],
                 p->Oem[7]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Bytes per sector:     %x"), bpb.BytesPerSector);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per cluster:  %x"), bpb.SectorsPerCluster);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Reserved Sectors:     %x"),  bpb.ReservedSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of fats:       %x"), bpb.Fats);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Root entries:         %x"), bpb.RootEntries);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Small sector count:   %x"), bpb.Sectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Media byte:           %x"), bpb.Media);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per fat:      %x"), bpb.SectorsPerFat);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per track:    %x"), bpb.SectorsPerTrack);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of heads:      %x"), bpb.Heads);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of hidden sectors: %x"), bpb.HiddenSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Large number of sectors:  %x"), bpb.LargeSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Physical drive:       %x"), p->PhysicalDrive);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("NTFS number of sectors:   %x"), p->NumberSectors.LowPart);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("MFT starting cluster: %x"), p->MftStartLcn.GetLowPart());
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("MFT mirror starting cluster: %x"),
                 p->Mft2StartLcn.GetLowPart());
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Clusters per file record:    %x"),
                 p->ClustersPerFileRecordSegment);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Clusters per index block:    %x"),
                 p->DefaultClustersPerIndexAllocationBuffer);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("SerialNumber:         %08x%08x"), p->SerialNumber.HighPart,
                                           p->SerialNumber.LowPart);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Checksum:             %x"), p->Checksum);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\ntfslog.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsLog.h

Abstract:

    This module defines the Ntfs-specific log file structures.

Author:

    Tom Miller      [TomM]          21-Jul-1991

Revision History:

--*/

#ifndef _NTFSLOG_
#define _NTFSLOG_

#pragma pack(4)

//
//  The following type defines the Ntfs log operations.
//
//  The comment specifies the record type which follows the record.
//  These record types are defined either here or in ntfs.h.
//

typedef enum _NTFS_LOG_OPERATION {

    Noop =                         0x00, //
    CompensationLogRecord =        0x01, //
    InitializeFileRecordSegment =  0x02, //  FILE_RECORD_SEGMENT_HEADER
    DeallocateFileRecordSegment =  0x03, //
    WriteEndOfFileRecordSegment =  0x04, //  ATTRIBUTE_RECORD_HEADER
    CreateAttribute =              0x05, //  ATTRIBUTE_RECORD_HEADER
    DeleteAttribute =              0x06, //
    UpdateResidentValue =          0x07, //  (value)
    UpdateNonresidentValue =       0x08, //  (value)
    UpdateMappingPairs =           0x09, //  (value = mapping pairs bytes)
    DeleteDirtyClusters =          0x0A, //  array of LCN_RANGE
    SetNewAttributeSizes =         0x0B, //  NEW_ATTRIBUTE_SIZES
    AddIndexEntryRoot =            0x0C, //  INDEX_ENTRY
    DeleteIndexEntryRoot =         0x0D, //  INDEX_ENTRY
    AddIndexEntryAllocation =      0x0E, //  INDEX_ENTRY
    DeleteIndexEntryAllocation =   0x0F, //  INDEX_ENTRY
    WriteEndOfIndexBuffer =        0x10, //  INDEX_ENTRY
    SetIndexEntryVcnRoot =         0x11, //  VCN
    SetIndexEntryVcnAllocation =   0x12, //  VCN
    UpdateFileNameRoot =           0x13, //  DUPLICATED_INFORMATION
    UpdateFileNameAllocation =     0x14, //  DUPLICATED_INFORMATION
    SetBitsInNonresidentBitMap =   0x15, //  BITMAP_RANGE
    ClearBitsInNonresidentBitMap = 0x16, //  BITMAP_RANGE
    HotFix =                       0x17, //
    EndTopLevelAction =            0x18, //
    PrepareTransaction =           0x19, //
    CommitTransaction =            0x1A, //
    ForgetTransaction =            0x1B, //
    OpenNonresidentAttribute =     0x1C, //  OPEN_ATTRIBUTE_ENTRY+ATTRIBUTE_NAME_ENTRY
    OpenAttributeTableDump =       0x1D, //  OPEN_ATTRIBUTE_ENTRY array
    AttributeNamesDump =           0x1E, //  (all attribute names)
    DirtyPageTableDump =           0x1F, //  DIRTY_PAGE_ENTRY array
    TransactionTableDump =         0x20  //  TRANSACTION_ENTRY array

} NTFS_LOG_OPERATION, *PNTFS_LOG_OPERATION;

char *NtfsLogOperationStrings[] = {
    "Noop"
    "CompensationLogRecord" ,
    "InitializeFileRecordSegment",
    "DeallocateFileRecordSegment",
    "WriteEndOfFileRecordSegment",
    "CreateAttribute",
    "DeleteAttribute",
    "UpdateResidentValue",
    "UpdateNonresidentValue",
    "UpdateMappingPairs",
    "DeleteDirtyClusters",
    "SetNewAttributeSize",
    "AddIndexEntryRoot",
    "DeleteIndexEntryRoot",
    "AddIndexEntryAllocation",
    "DeleteIndexEntryAllocation",
    "WriteEndOfIndexBuffer",
    "SetIndexEntryVcnRoot",
    "SetIndexEntryVcnAllocation",
    "UpdateFileNameRoot",
    "UpdateFileNameAllocation",
    "SetBitsInNonresidentBitMap",
    "ClearBitsInNonresidentBitMap" ,
    "HotFix",
    "EndTopLevelAction",
    "PrepareTransaction",
    "CommitTransaction",
    "ForgetTransaction",
    "OpenNonresidentAttribute",
    "OpenAttributeTableDump",
    "AttributeNamesDump",
    "DirtyPageTableDump",
    "TransactionTableDump"
};


//
//  The Ntfs log record header precedes every log record written to
//  disk by Ntfs.
//

//
//  Log record header.
//

typedef struct _NTFS_LOG_RECORD_HEADER {

    //
    //  Log Operations (LOG_xxx codes)
    //

    USHORT RedoOperation;
    USHORT UndoOperation;

    //
    //  Offset to Redo record, and its length
    //

    USHORT RedoOffset;
    USHORT RedoLength;

    //
    //  Offset to Undo record, and its length.  Note, for some Redo/Undo
    //  combinations, the expected records may be the same, and thus
    //  these two values will be identical to the above values.
    //

    USHORT UndoOffset;
    USHORT UndoLength;

    //
    //  Open attribute table index to which this update applies.  Index 0 is
    //  always reserved for the MFT itself.  The value of this field
    //  essentially distinguishes two cases for this update, which will be
    //  referred to as MFT update and nonresident attribute update.
    //
    //  MFT updates are for initialization and deletion of file record
    //  segments and updates to resident attributes.
    //
    //  Nonresident attribute updates are used to update attributes which
    //  have been allocated externally to the MFT.
    //

    USHORT TargetAttribute;

    //
    //  Number of Lcns in use at end of header.
    //

    USHORT LcnsToFollow;

    //
    //  Byte offset and Vcn for which this update is to be applied.  If the
    //  TargetAttribute is the MFT, then the Vcn will always be the exact
    //  Vcn of the start of the file record segment being modified, even
    //  if the modification happens to be in a subsequent cluster of the
    //  same file record.  The byte offset in this case is the offset to
    //  the attribute being changed.  For the Mft, AttributeOffset may be used
    //  to represent the offset from the start of the attribute record
    //  at which an update is to be applied.
    //
    //  If the update is to some other (nonresident) attribute, then
    //  TargetVcn and RecordOffset may be used to calculate the reference
    //  point for the update.
    //
    //  As a bottom line, the exact use of these fields is up to the
    //  writer of this particular log operation, and the associated
    //  restart routines for this attribute.
    //

    USHORT RecordOffset;
    USHORT AttributeOffset;
    USHORT Reserved[2];
    LONGLONG TargetVcn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes log records according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LONGLONG LcnsForPage[1];

    //
    //  Immediately following the last run is a log-operation-specific record
    //  whose length may be calculated by subtracting the length of this header
    //  from the length of the entire record returned by LFS.  These records
    //  are defined below.
    //

} NTFS_LOG_RECORD_HEADER, *PNTFS_LOG_RECORD_HEADER;


//
//  RESTART AREA STRUCTURES
//
//  The following structures are present in the Restart Area.
//

//
//  Generic Restart Table
//
//  This is a generic table definition for the purpose of describing one
//  of the three table structures used at Restart: the Open Attribute Table,
//  the Dirty Pages Table, and the Transaction Table.  This simple structure
//  allows for common initialization and free list management.  Allocation
//  and Deallocation and lookup by index are extremely fast, while lookup
//  by value (only performed in the Dirty Pages Table during Restart) is
//  a little slower.  I.e., all accesses to these tables during normal
//  operation are extremely fast.
//
//  If fast access to a table entry by value becomes an issue, then the
//  table may be supplemented by an external Generic Table - it is probably
//  not a good idea to make the Generic Table be part of the structure
//  written to the Log File.
//
//  Entries in a Restart Table should start with:
//
//      ULONG AllocatedOrNextFree;
//
//  An allocated entry will have the pattern RESTART_ENTRY_ALLOCATED
//  in this field.
//

#define RESTART_ENTRY_ALLOCATED          (0xFFFFFFFF)

typedef struct _RESTART_TABLE {

    //
    //  Entry size, in bytes
    //

    USHORT EntrySize;

    //
    //  Total number of entries in table
    //

    USHORT NumberEntries;

    //
    //  Number entries that are allocated
    //

    USHORT NumberAllocated;

    //
    //  Reserved for alignment
    //

    USHORT Reserved[3];

    //
    //  Free goal - Offset after which entries should be freed to end of
    //  list, as opposed to front.  At each checkpoint, the table may be
    //  truncated if there are enough free entries at the end of the list.
    //  Expressed as an offset from the start of this structure.
    //

    ULONG FreeGoal;

    //
    //  First Free entry (head of list) and Last Free entry (used to deallocate
    //  beyond Free Goal).  Expressed as an offset from the start of this
    //  structure.
    //

    ULONG FirstFree;
    ULONG LastFree;

    //
    //  The table itself starts here.
    //

} RESTART_TABLE, *PRESTART_TABLE;

//
//  Macro to get a pointer to an entry in a Restart Table, from the Table
//  pointer and entry index.
//

#define GetRestartEntryFromIndex(TBL,INDX) (    \
    (PVOID)((PCHAR)(TBL)->Table + (INDX))       \
)

//
//  Macro to get an index for an entry in a Restart Table, from the Table
//  pointer and entry pointer.
//

#define GetIndexFromRestartEntry(TBL,ENTRY) (           \
    (ULONG)((PCHAR)(ENTRY) - (PCHAR)(TBL)->Table)       \
)

//
//  Macro to see if an entry in a Restart Table is allocated.
//

#define IsRestartTableEntryAllocated(PTR) (                 \
    (BOOLEAN)(*(PULONG)(PTR) == RESTART_ENTRY_ALLOCATED)    \
)

//
//  Macro to retrieve the size of a Restart Table in bytes.
//

#define SizeOfRestartTable(TBL) (                                   \
    (ULONG)(((TBL)->Table->NumberEntries *                          \
     (TBL)->Table->EntrySize) +                                     \
    sizeof(RESTART_TABLE))                                          \
)

//
//  Macro to see if Restart Table is empty.  It is empty if the
//  number allocated is zero.
//

#define IsRestartTableEmpty(TBL) (!(TBL)->Table->NumberAllocated)

//
//  Macro to see if an index is within the currently allocated size
//  for that table.
//

#define IsRestartIndexWithinTable(TBL,INDX) (               \
    (BOOLEAN)((INDX) < SizeOfRestartTable(TBL))             \
)

//
//  Macros to acquire and release a Restart Table.
//

#define NtfsAcquireExclusiveRestartTable(TBL,WAIT) {        \
    ExAcquireResourceExclusiveLite( &(TBL)->Resource,(WAIT));   \
}

#define NtfsAcquireSharedRestartTable(TBL,WAIT) {           \
    ExAcquireResourceSharedLite( &(TBL)->Resource,(WAIT));      \
}

#define NtfsReleaseRestartTable(TBL) {                      \
    ExReleaseResourceLite(&(TBL)->Resource);                    \
}

//
//  Define some tuning parameters to keep the restart tables a
//  reasonable size.
//

#define INITIAL_NUMBER_TRANSACTIONS      (5)
#define HIGHWATER_TRANSACTION_COUNT      (10)
#define INITIAL_NUMBER_ATTRIBUTES        (8)
#define HIGHWATER_ATTRIBUTE_COUNT        (16)

//
//  Attribute Name Entry.  This is a simple structure used to store
//  all of the attribute names for the Open Attribute Table during
//  checkpoint processing.  The Attribute Names record written to the log
//  is a series of Attribute Name Entries terminated by an entry with
//  Index == NameLength == 0.  The end of the table may be tested for by
//  looking for either of these fields to be 0, as 0 is otherwise invalid
//  for both.
//
//  Note that the size of this structure is equal to the overhead for storing
//  an attribute name in the table, including the UNICODE_NULL.
//

typedef struct _ATTRIBUTE_NAME_ENTRY {

    //
    //  Index for Attibute with this name in the Open Attribute Table.
    //

    USHORT Index;

    //
    //  Length of attribute name to follow in bytes, including a terminating
    //  UNICODE_NULL.
    //

    USHORT NameLength;

    //
    //  Start of attribute name
    //

    WCHAR Name[1];

} ATTRIBUTE_NAME_ENTRY, *PATTRIBUTE_NAME_ENTRY;

//
//  Open Attribute Table
//
//  One entry exists in the Open Attribute Table for each nonresident
//  attribute of each file that is open with modify access.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_ATTRIBUTE_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

typedef struct _OPEN_ATTRIBUTE_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  The following overlay either contains an optional pointer to an
    //  Attribute Name Entry from the Analysis Phase of Restart, or a
    //  pointer to an Scb once attributes have been open and in the normal
    //  running system.
    //
    //  Specifically, after the Analysis Phase of Restart:
    //
    //      AttributeName == NULL if there is no attribute name, or the
    //                       attribute name was captured in the Attribute
    //                       Names Dump in the last successful checkpoint.
    //      AttributeName != NULL if an OpenNonresidentAttribute log record
    //                       was encountered, and an Attribute Name Entry
    //                       was allocated at that time (and must be
    //                       deallocated when no longer needed).
    //
    //  Once the Nonresident Attributes have been opened during Restart,
    //  and in the running system, this is an Scb pointer.
    //

    union {
        PWSTR AttributeName;
        PVOID Scb;
    } Overlay;

    //
    //  File Reference of file containing attribute.
    //

    FILE_REFERENCE FileReference;

    //
    //  Lsn of OpenNonresidentAttribute log record, to distinguish reuses
    //  of this open file record.  Log records referring to this Open
    //  Attribute Entry Index, but with Lsns  older than this field, can
    //  only occur when the attribute was subsequently deleted - these
    //  log records can be ignored.
    //

    LSN LsnOfOpenRecord;

    //
    //  Flag to say if dirty pages seen for this attribute during dirty
    //  page scan.
    //

    BOOLEAN DirtyPagesSeen;

    //
    //  Reserved for alignment
    //

    UCHAR Reserved[3];

    //
    //  The following two fields identify the actual attribute
    //  with respect to its file.   We identify the attribute by
    //  its type code and name.  When the Restart Area is written,
    //  all of the names for all of the open attributes are temporarily
    //  copied to the end of the Restart Area.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    UNICODE_STRING AttributeName;

    //
    //  This field is only relevant to indices, i.e., if AttributeTypeCode
    //  above is $INDEX_ALLOCATION.
    //

    ULONG BytesPerIndexBuffer;

} OPEN_ATTRIBUTE_ENTRY, *POPEN_ATTRIBUTE_ENTRY;

#define SIZEOF_OPEN_ATTRIBUTE_ENTRY (                               \
    FIELD_OFFSET( OPEN_ATTRIBUTE_ENTRY, BytesPerIndexBuffer ) + 4   \
)

//
//  Dirty Pages Table
//
//  One entry exists in the Dirty Pages Table for each page which is
//  dirty at the time the Restart Area is written.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_DIRTY_PAGES_TABLE_SIZE or the size of the table in the log file.
//  It is *not* maintained in the running system.
//

typedef struct _DIRTY_PAGE_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Target attribute index.  This is the index into the Open Attribute
    //  Table to which this dirty page entry applies.
    //

    ULONG TargetAttribute;

    //
    //  Length of transfer, in case this is the end of file, and we cannot
    //  write an entire page.
    //

    ULONG LengthOfTransfer;

    //
    //  Number of Lcns in the array at end of this structure.  See comment
    //  with this array.
    //

    ULONG LcnsToFollow;

    //
    //  Reserved for alignment
    //

    ULONG Reserved;

    //
    //  Vcn of dirty page.
    //

    VCN Vcn;

    //
    //  OldestLsn for log record for which the update has not yet been
    //  written through to disk.
    //

    LSN OldestLsn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes pages according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LCN LcnsForPage[1];

} DIRTY_PAGE_ENTRY, *PDIRTY_PAGE_ENTRY;

//
//  Transaction Table
//
//  One transaction entry exists for each existing transaction at the time
//  the Restart Area is written.
//
//  Currently only local transactions are supported, and the transaction
//  ID is simply used to index into this table.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_TRANSACTION_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

typedef struct _TRANSACTION_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Transaction State
    //

    UCHAR TransactionState;

    //
    //  Reserved for proper alignment
    //

    UCHAR Reserved[3];

    //
    //  First Lsn for transaction.  This tells us how far back in the log
    //  we may have to read to abort the transaction.
    //

    LSN FirstLsn;

    //
    //  PreviousLsn written for the transaction and UndoNextLsn (next record
    //  which should be undone in the event of a rollback.
    //

    LSN PreviousLsn;
    LSN UndoNextLsn;

    //
    //  Number of of undo log records pending abort, and total undo size.
    //

    ULONG UndoRecords;
    LONG UndoBytes;

} TRANSACTION_ENTRY, *PTRANSACTION_ENTRY;

//
//  Restart record
//
//  The Restart record used by NTFS is small, and it only describes where
//  the above information has been written to the log.  The above records
//  may be considered logically part of NTFS's restart area.
//

typedef struct _RESTART_AREA {

    //
    //  Version numbers of NTFS Restart Implementation
    //

    ULONG MajorVersion;
    ULONG MinorVersion;

    //
    //  Lsn of Start of Checkpoint.  This is the Lsn at which the Analysis
    //  Phase of Restart must begin.
    //

    LSN StartOfCheckpoint;

    //
    //  Lsns at which the four tables above plus the attribute names reside.
    //

    LSN OpenAttributeTableLsn;
    LSN AttributeNamesLsn;
    LSN DirtyPageTableLsn;
    LSN TransactionTableLsn;

    //
    //  Lengths of the above structures in bytes.
    //

    ULONG OpenAttributeTableLength;
    ULONG AttributeNamesLength;
    ULONG DirtyPageTableLength;
    ULONG TransactionTableLength;

} RESTART_AREA, *PRESTART_AREA;


//
//  RECORD STRUCTURES USED BY LOG RECORDS
//

//
//  Set new attribute sizes
//

typedef struct _NEW_ATTRIBUTE_SIZES {

    LONGLONG AllocationSize;
    LONGLONG ValidDataLength;
    LONGLONG FileSize;

} NEW_ATTRIBUTE_SIZES, *PNEW_ATTRIBUTE_SIZES;

//
//  Describe a bitmap range
//

typedef struct _BITMAP_RANGE {

    ULONG BitMapOffset;
    ULONG NumberOfBits;

} BITMAP_RANGE, *PBITMAP_RANGE;

//
//  Describe a range of Lcns
//

typedef struct _LCN_RANGE {

    LCN StartLcn;
    LONGLONG Count;

} LCN_RANGE, *PLCN_RANGE;

#pragma pack()

#endif //  _NTFSLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\ntfsstru.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsStru.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Ntfs file system.

    The global data structures start with the NtfsData record.  It contains
    a pointer to a File System Device object, and a queue of Vcb's.  There
    is a Vcb for every currently mounted volume.  The Vcb's are allocated as
    the extension to a volume device object.

        +--------+
        |NtfsData|     +--------+
        |        | --> |FilSysDo|
        |        |     |        |
        |        | <+  +--------+
        +--------+  |
                    |
                    |  +--------+     +--------+
                    |  |VolDo   |     |VolDo   |
                    |  |        |     |        |
                    |  +--------+     +--------+
                    +> |Vcb     | <-> |Vcb     | <-> ...
                       |        |     |        |
                       +--------+     +--------+

    The File System Device Object contains the global work queue for
    NTFS while each volume device object contains an overflow work queue.

    Each Vcb contains a table of all Fcbs for the volume indexed by their
    file reference (Called the FcbTable).  And each Vcb contains a pointer
    a root Lcb for the volume.  An Lcb is used to connect an indexed Scb (i.e.,
    a directory) to an Fcb and give it a name.

    The following diagram shows the root structure.

        +--------+
        |Vcb     |
        |        |  +---+   +--------+
        |        | -|Lcb|-> |RootFcb |
        +--------+  |'\'|   |        |
                    +---+   |        |
                            +--------+

    Each Scb will only have one parent Fcb but multiple Fcb children (each
    connected via an Lcb).  An Fcb can have multiple Scb parents (via Lcbs)
    and multiple Scb Children.

    Now associated with each Fcb is potentially many Scbs.  An Scb
    is allocated for each opened stream file object (i.e., an attribute that
    the file system is manipulating as a stream file).  Each Scb contains
    a common fsrtl header and information necessary for doing I/O to the
    stream.

        +--------+
        |Fcb     |     +--------+     +--------+
        |        | <-> |Scb     | <-> |Scb     | <-> ...
        +--------+     |        |     |        |
                       +--------+     +--------+

    In the following diagram we have two index scb (Scb1 and Scb2).  The
    are two file opened under Scb1 both for the same File.  The file was opened
    once with the name LcbA and another time with the name LcbB.  Scb2 also has
    two opened file one is Fcb1 and named LcbC and the other is Fcb2 and named
    LcbD.  Fcb1 has two opened Scbs under it (Scb3 and Scb4), and Fcb2 has
    one opened Scb underneath it (Scb5).


           +--------+                +--------+
           |Scb     |                |Scb     |
           |    1   |                |    2   |
           |        |                |        |
           +--------+                +--------+

             |    |                    |    |

            Lcb  Lcb                  Lcb  Lcb
             A    B                    C    D

             |    |     +--------+     |    |     +--------+
             |    +---> |Fcb     | <---+    +---> |Fcb     |
             |          |    1   |                |    2   |
             +--------> |        |                |        |
                        +--------+                +--------+
                          ^    ^                    ^    ^
             +------------+    +------------+  +----+    +----+
             |                              |  |              |
             |  +--------+      +--------+  |  |  +--------+  |
             +> |Scb     | <--> |Scb     | <+  +> |Scb     | <+
                |    3   |      |    4   |        |    5   |
                |        |      |        |        |        |
                +--------+      +--------+        +--------+

    In addition off of each Lcb is a list of Ccb and Prefix entries.  The Ccb list
    is for each ccb that has opened that File (fcb) via the name.  The Prefix list
    contains the prefix table entries that we are caching.


    The NtfsData, all Vcbs, and the paging file Fcb, and all Scbs are allocated
    out of nonpaged pool.  The Fcbs are allocated out of paged pool.

    The resources protecting the NTFS memory structures are setup as follows:

    1. There is a global resource in the NtfsData record.  This resource
       protects the NtfsData record which includes any changes to its
       Vcb queue.

    2. There is a resource per Vcb.  This resource pretects the Vcb record
       which includes adding and removing Fcbs, and Scbs

    3. There is a single resource protecting an Fcb and its assigned
       Scbs.  This resource protects any changes to the Fcb, and Scb
       records.  The way this one works is that each Fcb, and Scb point
       to the resource.  The Scb also contain back pointers to their parent
       Fcb but we cannot use this pointer to get the resource because
       the Fcb might be in nonpaged pool.

        +--------+
        |Fcb     |     +--------+     +--------+
        |        | <-> |Scb     | <-> |Scb     | <-> ...
        +--------+     |        |     |        |
                       +--------+     +--------+
               |
               |           |            |
               |           v            |
               |                        |
               |       +--------+       |
               +-----> |Resource| <-----+
                       |        |
                       +--------+



    There are four types of opens possible for each file object handled by
    NTFS.  They are UserFileOpen, UserDirectoryOpen, UserVolumeOpen, and
    StreamFileOpen.  The first three types correspond to user opens on
    files, directories, and dasd respectively.  The last type is for any
    file object created by NTFS for its stream I/O (e.g., the volume
    bitmap).   The file system uses the FsContext and FsContext2 fields of
    the file object to store information about the type of open and the
    fcb/scb/ccb associated with the file object.  We can overload the low
    bits of the fields to be more than pointers because they must always
    point to longword aligned records.  The fields are used as follows:

        Type of open                FsContext                   FsContext2
        ------------                ---------                   ----------

        UserFileOpen        Pointer to Scb with             Pointer to Ccb
                            0 in the last two bits

        UserDirectoryOpen   Pointer to Scb with             Pointer to Ccb
                            1 in the last two bits

        UserVolumeOpen      Pointer to Scb with             Pointer to Ccb
                            2 in the last two bits

        StreamFileOpen      Pointer to Scb                  null

    The only part of the NTFS code that actually needs to know this
    information is in FilObSup.c.  But we talk about it here to help
    developers debug the system.


    To mount a new NTFS volume requires a bit of juggling.  The idea is
    to have as little setup in memory as necessary to recoginize the volume,
    call a restart routine that will recover the volume, and then precede with
    the mounting.  To aid in this the regular directory structures of the
    Fcb is bypassed.  In its place we have a linked list of Fcbs off
    of the Vcb.  This is done because during recovery we do not know where
    an Fcb belongs in the directory hierarchy.  So at restart time all
    new fcbs get put in this prerestart Fcb list.  Then after restart whenever
    we create a new Fcb we search this list for a match (on file reference).
    If we find one we remove the fcb from this list and move it to the proper
    place in the directory hierarchy tree (fcb tree).

Author:

    Brian Andrew    [BrianAn]       21-May-1991
    David Goebel    [DavidGoe]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:

--*/

#ifndef _NTFSSTRU_
#define _NTFSSTRU_

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module

//
//  Define who many freed structures we are willing to keep around
//

#define FREE_CCB_SIZE                    (8)
#define FREE_FCB_SIZE                    (8)
#define FREE_LCB_SIZE                    (8)
#define FREE_SCB_DATA_SIZE               (4)
#define FREE_SCB_SHARE_DATA_SIZE         (8)
#define FREE_SCB_INDEX_SIZE              (8)
#define FREE_SCB_NONPAGED_SIZE           (8)

#define FREE_DEALLOCATED_RECORDS_SIZE    (8)
#define FREE_ERESOURCE_SIZE              (8)
#define FREE_INDEX_CONTEXT_SIZE          (8)
#define FREE_KEVENT_SIZE                 (8)
#define FREE_NUKEM_SIZE                  (8)
#define FREE_SCB_SNAPSHOT_SIZE           (8)
#define FREE_IO_CONTEXT_SIZE             (8)
#define FREE_FILE_LOCK_SIZE              (8)

#define FREE_FCB_TABLE_SIZE              (8)

#define FREE_128_BYTE_SIZE               (16)
#define FREE_256_BYTE_SIZE               (16)
#define FREE_512_BYTE_SIZE               (16)

#define MAX_DELAYED_CLOSE_COUNT_SMALL    (20)
#define MAX_DELAYED_CLOSE_COUNT_MEDIUM   (100)
#define MAX_DELAYED_CLOSE_COUNT_LARGE    (500)


//
//  The NTFS_DATA record is the top record in the NTFS file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _NTFS_DATA {

    //
    //  The type and size of this record (must be NTFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A queue of all the devices that are mounted by the file system.
    //  Corresponds to the field Vcb->VcbLinks;
    //

    LIST_ENTRY VcbQueue;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  A resource variable to control access to the global NTFS data record
    //

    ERESOURCE Resource;

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

    //
    //  The following list entry is used for performing closes that can't
    //  be done in the context of the original caller.
    //

    LIST_ENTRY AsyncCloseList;

    BOOLEAN AsyncCloseActive;
    BOOLEAN ReduceDelayedClose;

    //
    //  The following fields describe the deferred close file objects.
    //

    ULONG DelayedCloseCount;

    LIST_ENTRY DelayedCloseList;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    WORK_QUEUE_ITEM NtfsCloseItem;

    //
    //  The following fields are used to allocate IRP context structures
    //  using the zone allocator, and other fixed sized structures from a
    //  small cache.  The spinlock protects access to the zone/lists
    //

    KSPIN_LOCK StrucSupSpinLock;

    ZONE_HEADER IrpContextZone;

    struct _CCB                 *FreeCcbArray[FREE_CCB_SIZE];
    struct _FCB                 *FreeFcbArray[FREE_FCB_SIZE];
    struct _LCB                 *FreeLcbArray[FREE_LCB_SIZE];
    struct _SCB                 *FreeScbDataArray[FREE_SCB_DATA_SIZE];
    struct _SCB                 *FreeScbShareDataArray[FREE_SCB_SHARE_DATA_SIZE];
    struct _SCB                 *FreeScbIndexArray[FREE_SCB_INDEX_SIZE];
    struct _SCB_NONPAGED        *FreeScbNonpagedArray[FREE_SCB_NONPAGED_SIZE];

    struct _DEALLOCATED_RECORDS *FreeDeallocatedRecordsArray[FREE_DEALLOCATED_RECORDS_SIZE];
    struct _ERESOURCE           *FreeEresourceArray         [FREE_ERESOURCE_SIZE];
    struct _INDEX_CONTEXT       *FreeIndexContextArray      [FREE_INDEX_CONTEXT_SIZE];
    struct _KEVENT              *FreeKeventArray            [FREE_KEVENT_SIZE];
    struct _NUKEM               *FreeNukemArray             [FREE_NUKEM_SIZE];
    struct _SCB_SNAPSHOT        *FreeScbSnapshotArray       [FREE_SCB_SNAPSHOT_SIZE];
    struct _NTFS_IO_CONTEXT     *FreeIoContextArray         [FREE_IO_CONTEXT_SIZE];
    struct _FILE_LOCK           *FreeFileLockArray          [FREE_FILE_LOCK_SIZE];

    PVOID                       *FreeFcbTableArray[FREE_FCB_TABLE_SIZE];

    PVOID                       *Free128ByteArray[FREE_128_BYTE_SIZE];
    PVOID                       *Free256ByteArray[FREE_256_BYTE_SIZE];
    PVOID                       *Free512ByteArray[FREE_512_BYTE_SIZE];

    UCHAR FreeCcbSize;
    UCHAR FreeFcbSize;
    UCHAR FreeLcbSize;
    UCHAR FreeScbDataSize;
    UCHAR FreeScbShareDataSize;
    UCHAR FreeScbIndexSize;
    UCHAR FreeScbNonpagedSize;

    UCHAR FreeDeallocatedRecordsSize;
    UCHAR FreeEresourceSize;
    UCHAR FreeIndexContextSize;
    UCHAR FreeKeventSize;
    UCHAR FreeNukemSize;
    UCHAR FreeScbSnapshotSize;
    UCHAR FreeIoContextSize;
    UCHAR FreeFileLockSize;

    UCHAR FreeFcbTableSize;

    UCHAR Free128ByteSize;
    UCHAR Free256ByteSize;
    UCHAR Free512ByteSize;

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerVolumeCallbacks;

    //
    //  This is a list of all of the threads currently doing read ahead.
    //  We will not hot fix for these threads.
    //

    LIST_ENTRY ReadAheadThreads;

    //
    //  The following fields are used for the CheckpointVolumes() callback.
    //

    KDPC VolumeCheckpointDpc;
    KTIMER VolumeCheckpointTimer;

    KSPIN_LOCK VolumeCheckpointSpinLock;
    WORK_QUEUE_ITEM VolumeCheckpointItem;

    BOOLEAN Modified;
    BOOLEAN ExtraCheckpoint;
    BOOLEAN TimerSet;

} NTFS_DATA;
typedef NTFS_DATA *PNTFS_DATA;


//
//  The record allocation context structure is used by the routines that allocate
//  and deallocate records based on a bitmap (for example the mft bitmap or the
//  index bitmap).  The context structure needs to be defined here because
//  the mft bitmap context is declared as part of the vcb.
//

typedef struct _RECORD_ALLOCATION_CONTEXT {

    //
    //  The following field is a pointer to the scb for the data part of
    //  the file that this bitmap controls.  For example, it is a pointer to
    //  the data attribute for the MFT.
    //
    //  NOTE !!!!  The Data Scb must remain the first entry in this structure.
    //  If we need to uninitialize and reinitialize this structure in the
    //  running system we don't want to touch this field.
    //
    //  NOTE !!!!  The code that clears the record allocation context expects
    //  the BitmapScb field to follow the Data Scb field.
    //

    struct _SCB *DataScb;

    //
    //  The following field is used to indicate if the bitmap attribute is
    //  in a resident form or a nonresident form.  If the bitmap is in a
    //  resident form then the pointer is null, and whenever a bitmap
    //  routine is called it must also be passed an attribute enumeration
    //  context to be able to read the bitmap.  If the field is not null
    //  then it points to the scb for the non resident bitmap attribute
    //

    struct _SCB *BitmapScb;

    //
    //  The following two fields describe the current size of the bitmap
    //  (in bits) and the number of free bits currently in the bitmap.
    //  A value of MAXULONG in the CurrentBitmapSize indicates that we need
    //  to reinitialize the record context structure.
    //

    ULONG CurrentBitmapSize;
    ULONG NumberOfFreeBits;

    //
    //  The following three fields are used to indicate the allocation
    //  size for the bitmap (i.e., each bit in the bitmap represents how
    //  many bytes in the data attribute).  Also it indicates the granularity
    //  with which we will either extend or shrink the bitmap.
    //

    ULONG BytesPerRecord;

    ULONG ExtendGranularity;
    ULONG TruncateGranularity;

    //
    //  The following field contains the index of last bit that we know
    //  to be set.  This is used for truncation purposes.
    //

    LONG IndexOfLastSetBit;

} RECORD_ALLOCATION_CONTEXT;
typedef RECORD_ALLOCATION_CONTEXT *PRECORD_ALLOCATION_CONTEXT;


//
//  The Vcb (Volume control Block) record corresponds to every volume mounted
//  by the file system.  They are ordered in a queue off of NtfsData.VcbQueue.
//  This structure must be allocated from non-paged pool
//

#define DEFAULT_ATTRIBUTE_TABLE_SIZE     (32)
#define DEFAULT_TRANSACTION_TABLE_SIZE   (32)
#define DEFAULT_DIRTY_PAGES_TABLE_SIZE   (64)

//
//  The Restart Pointers structure is the actual structure supported by
//  routines and macros to get at a Restart Table.  This structure is
//  required since the restart table itself may move, so one must first
//  acquire the resource to synchronize, then follow the pointer to the table.
//

typedef struct _RESTART_POINTERS {

    //
    //  Pointer to the actual Restart Table.
    //

    struct _RESTART_TABLE *Table;

    //
    //  Resource to synchronize with table moves.  This resource must
    //  be held shared while dealing with pointers to table entries,
    //  and exclusive to move the table.
    //

    ERESOURCE Resource;

    //
    //  Remember if the resource was initialized.
    //

    BOOLEAN ResourceInitialized;

    //
    //  Spin Lock synchronizing allocates and deletes of entries in the
    //  table.  The resource must be held at least shared.
    //

    KSPIN_LOCK SpinLock;

} RESTART_POINTERS, *PRESTART_POINTERS;


//
//  Structure used to track the deallocated clusters.
//

typedef struct _DEALLOCATED_CLUSTERS {

    LSN Lsn;
    LONGLONG ClusterCount;
    LARGE_MCB Mcb;

} DEALLOCATED_CLUSTERS, *PDEALLOCATED_CLUSTERS;

//
//  The Vcb structure corresponds to every mounted NTFS volume in the system
//

typedef struct _VCB {

    //
    //  The type and size of this record (must be NTFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for the queue of all the Vcbs in the system.
    //  Corresponds to the filld NtfsData.VcbQueue
    //

    LIST_ENTRY VcbLinks;

    //
    //  Pointer to the Scb for the special system file.  If the field is null
    //  then we haven't yet built the scb for that system file.  Also the pointer
    //  to the stream file object is located in the scb.
    //
    //  NOTE: AcquireExclusiveFiles depends on this order.  Any change here
    //  should be checked with the code there.
    //

    struct _SCB *MftScb;
    struct _SCB *Mft2Scb;
    struct _SCB *LogFileScb;
    struct _SCB *VolumeDasdScb;
    struct _SCB *AttributeDefTableScb;
    struct _SCB *UpcaseTableScb;
    struct _SCB *RootIndexScb;
    struct _SCB *BitmapScb;
    struct _SCB *BootFileScb;
    struct _SCB *BadClusterFileScb;
    struct _SCB *QuotaTableScb;
    struct _SCB *MftBitmapScb;

    //
    //  The root Lcb for this volume.
    //

    struct _LCB *RootLcb;

    //
    //  A pointer the device object passed in by the I/O system on a mount
    //  This is the target device object that the file system talks to when it
    //  needs to do any I/O (e.g., the disk stripper device object).
    //
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  A pointer to the VPB for the volume passed in by the I/O system on
    //  a mount.
    //

    PVPB Vpb;

    //
    //  The internal state of the volume.  This is a collection of Vcb
    //  state flags.  The VcbState is synchronized with the Vcb resource.
    //  The MftDefragState is synchronized with the CheckpointEvent.
    //  The MftReserveFlags are sychronized with the MftScb.
    //

    ULONG VcbState;
    ULONG MftReserveFlags;
    ULONG MftDefragState;

    //
    //  A count of the number of file objects that have any file/directory
    //  opened on this volume. And a count of the number of special system
    //  files that we have open
    //

    CLONG CleanupCount;
    CLONG CloseCount;
    CLONG ReadOnlyCloseCount;
    CLONG SystemFileCloseCount;

    //
    //  A resource variable to control access to the volume specific data
    //  structures
    //

    ERESOURCE Resource;

    //
    //  The following events are used to synchronize the Fcb table and
    //  the shared security structures.
    //

    KEVENT FcbTableEvent;
    PVOID FcbTableThread;

    KEVENT FcbSecurityEvent;
    PVOID FcbSecurityThread;

    //
    //  Following events are used to control the volume checkpoint
    //  operations.
    //

    KEVENT CheckpointEvent;
    PVOID CheckpointThread;

    KEVENT CheckpointNotifyEvent;
    PVOID CheckpointNotifyThread;

    ULONG CheckpointFlags;

    //
    //  The following field is a pointer to the file object that has the
    //  volume locked. if the VcbState has the locked flag set.
    //

    PFILE_OBJECT FileObjectWithVcbLocked;

    //
    //  The following volume-specific parameters are extracted from the
    //  Boot Sector.
    //

    ULONG BytesPerSector;
    ULONG BytesPerCluster;
    ULONG BytesPerFileRecordSegment;
    LONGLONG NumberSectors;
    LCN MftStartLcn;
    LCN Mft2StartLcn;
    ULONG ClustersPerFileRecordSegment;
    ULONG DefaultClustersPerIndexAllocationBuffer;

    //
    //  This field contains a calculated value which determines when an
    //  individual attribute is large enough to be moved to free up file
    //  record space.  (The calculation of this variable must be considered
    //  in conjunction with the constant MAX_MOVEABLE_ATTRIBUTES below.)
    //

    ULONG BigEnoughToMove;

    //
    //  The following fields are used to verify that an NTFS volume hasn't
    //  changed.  The serial number is stored in the boot sector on disk,
    //  and the four times are from the standard information field of the
    //  volume file.
    //

    LONGLONG VolumeSerialNumber;

    LONGLONG VolumeCreationTime;
    LONGLONG VolumeLastModificationTime;
    LONGLONG VolumeLastChangeTime;
    LONGLONG VolumeLastAccessTime;

    //
    //  The following table of unicode values is the case mapping, with the
    //  size in number of Unicode characters.
    //

    PWCH UpcaseTable;
    ULONG UpcaseTableSize;

    //
    //  This is a pointer to the attribute definitions for the volume
    //  which are loaded into nonpaged pool.
    //

    PATTRIBUTE_DEFINITION_COLUMNS AttributeDefinitions;

    //
    //  Convenient constants for the conversion macros
    //

    ULONG ClusterMask;              // BytesPerCluster - 1
    ULONG InverseClusterMask;       // ~ClusterMask
    ULONG ClusterShift;             // 2**ClusterShift == BytesPerCluster
    ULONG MftShift;                 //
    ULONG MftToClusterShift;
    ULONG ClustersPerPage;
    ULONG MftReserved;
    ULONG MftCushion;

    //
    //  Lfs Log Handle for this volume
    //

    LFS_LOG_HANDLE LogHandle;

    //
    //  LSNs of the end of the last checkpoint and the last RestartArea.
    //  Normally the RestartArea Lsn is greater than the other one, however
    //  if the VcbState indicates that a checkpoint is in progress, then these
    //  Lsns are in flux.
    //

    LSN EndOfLastCheckpoint;
    LSN LastRestartArea;
    LSN LastBaseLsn;

    //
    //  Open attribute table.
    //

    RESTART_POINTERS OpenAttributeTable;

    //
    //  Transaction table.
    //

    RESTART_POINTERS TransactionTable;

    //
    //  A table of all the fcb that have been created for this volume.
    //

    RTL_GENERIC_TABLE FcbTable;

    //
    //  The following fields are used by the BitmpSup routines.  The first
    //  value contains the total number of clusters on the volume, this
    //  is computed from the boot sector information.  The second value
    //  is the current number of free clusters available for allocation on
    //  the volume.  Allocation is handled by using two MCBs: FreeSpace
    //  describes some small window of known clusters that are free.
    //  RecentlyAllocated describes those clusters that have been recently
    //  allocated.
    //
    //  In addition there are two simply LRU arrays used by BitmpSup to keep
    //  the size of the corresponding MCB within limits.  The array field
    //  points to an array of lcn entries which is maintained in a round-robin
    //  lru fashion.  The size field denotes the number of Lcn entries
    //  allocated to the array, and tail and head are indices into the array.
    //
    //  The last field is for storing local volume specific data needed by
    //  the bitmap routines
    //

    LONGLONG TotalClusters;
    LONGLONG FreeClusters;
    LONGLONG DeallocatedClusters;

    LARGE_MCB FreeSpaceMcb;
    PLCN FreeSpaceLruArray;
    ULONG FreeSpaceLruSize;
    ULONG FreeSpaceLruTail;
    ULONG FreeSpaceLruHead;

    LARGE_MCB RecentlyAllocatedMcb;
    PLCN RecentlyAllocatedLruArray;
    ULONG RecentlyAllocatedLruSize;
    ULONG RecentlyAllocatedLruTail;
    ULONG RecentlyAllocatedLruHead;

    LCN LastBitmapHint;     //  Last Lcn used for fresh allocation

    //
    //  The following are used to track the deallocated clusters waiting
    //  for a checkpoint.  The pointers are used so we can toggle the
    //  use of the structures.
    //

    DEALLOCATED_CLUSTERS DeallocatedClusters1;
    DEALLOCATED_CLUSTERS DeallocatedClusters2;

    PDEALLOCATED_CLUSTERS PriorDeallocatedClusters;
    PDEALLOCATED_CLUSTERS ActiveDeallocatedClusters;

    //
    //  The following field is also used by the bitmap allocation routines
    //  to keep track of recently deallocated clusters.  A cluster that has
    //  been recently deallocated will not be reallocated until the
    //  operation (transaction) is complete.  That way if the operation
    //  needs to abort itself the space it had deallocated can easily be
    //  unwound.  NtfsDeallocateClusters adds to this mcb and
    //  NtfsDeallocateClusterComplete removes entries from it.
    //

    LARGE_MCB RecentlyDeallocatedMcb;

    //
    //  The following field is used for mft bitmap allocation
    //

    RECORD_ALLOCATION_CONTEXT MftBitmapAllocationContext;

    //
    //  The following two fields are used by the bitmap routines to determine
    //  what is called the mft zone.  The Mft zone are those clusters on the
    //  disk were we will try and put the mft and only the mft unless the disk
    //  is getting too full.
    //

    LCN MftZoneStart;
    LCN MftZoneEnd;

    //
    //  The following string contains the device name for this partition.
    //

    UNICODE_STRING DeviceName;

    //
    //  The following is the head of a list of notify Irps.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  The following mutex is used to manage the list of Irps pending
    //  dir notify.
    //

    KMUTEX DirNotifyMutex;

    //
    //  The following fields are used for the Mft defrag operation.  In addition
    //  we use the number of free clusters stored earlier in this structure.
    //
    //  The upper and lower thresholds are used to determine if the number of free
    //  file records in the Mft will cause us to trigger or cease defragging.
    //
    //  The count of free records is based on the size of the Mft and the allocated
    //  records.  The hole count is the count of how many file records are not
    //  allocated.
    //
    //  The count of the bitmap bits per hole.  This is the number of file records
    //  per hole.  Must be converted to clusters to find a hole in the Mft Mcb.
    //

    ULONG MftDefragUpperThreshold;
    ULONG MftDefragLowerThreshold;

    ULONG MftFreeRecords;
    ULONG MftHoleRecords;
    ULONG MftHoleGranularity;
    ULONG MftClustersPerHole;
    ULONG MftHoleMask;
    ULONG MftHoleInverseMask;

} VCB;
typedef VCB *PVCB;

//
//  These are the VcbState flags.  Synchronized with the Vcb resource.
//

#define VCB_STATE_VOLUME_MOUNTED            (0x00000001)
#define VCB_STATE_LOCKED                    (0x00000002)
#define VCB_STATE_REMOVABLE_MEDIA           (0x00000004)
#define VCB_STATE_VOLUME_MOUNTED_DIRTY      (0x00000008)
#define VCB_STATE_RESTART_IN_PROGRESS       (0x00000010)
#define VCB_STATE_FLAG_SHUTDOWN             (0x00000020)
#define VCB_STATE_NO_SECONDARY_AVAILABLE    (0x00000040)
#define VCB_STATE_RELOAD_FREE_CLUSTERS      (0x00000080)
#define VCB_STATE_ALREADY_BALANCED          (0x00000100)
#define VCB_STATE_VOL_PURGE_IN_PROGRESS     (0x00000200)

//
//  These are the flags for the Mft and the reserveration state.
//  Although these are in the Vcb they are synchronized with
//  the resource in the MftScb.
//

#define VCB_MFT_RECORD_RESERVED             (0x00000001)
#define VCB_MFT_RECORD_15_USED              (0x00000002)

//
//  These are the MftDefragState flags.  Synchronized with the
//  CheckpointEvent.
//

#define VCB_MFT_DEFRAG_PERMITTED            (0x00000001)
#define VCB_MFT_DEFRAG_ENABLED              (0x00000002)
#define VCB_MFT_DEFRAG_TRIGGERED            (0x00000004)
#define VCB_MFT_DEFRAG_ACTIVE               (0x00000008)
#define VCB_MFT_DEFRAG_EXCESS_MAP           (0x00000010)

//
//  These are the Checkpoint flags.  Synchronized with the
//  CheckpointEvent.  These flags are in the MftDefragState
//  flags field.
//

#define VCB_CHECKPOINT_IN_PROGRESS          (0x00000020)
#define VCB_LAST_CHECKPOINT_CLEAN           (0x00000040)

//
//  This is the maximum number of attributes in a file record which could
//  be considered for moving.  This value should be changed only in conjunction
//  with the initialization of the BigEnoughToMove field above.
//

#define MAX_MOVEABLE_ATTRIBUTES          (3)


//
//  The Volume Device Object is an I/O system device object with a workqueue
//  and an VCB record appended to the end.  There are multiple of these
//  records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload of
//  work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;
typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;



//
//  This structure is used to contain a link name and connections into
//  the splay tree for the parent.
//

typedef struct _NAME_LINK {

    UNICODE_STRING LinkName;
    RTL_SPLAY_LINKS Links;

} NAME_LINK, *PNAME_LINK;

//
//  The Lcb record corresponds to every open path between an Scb and an Fcb.
//  It denotes the name which was used to go from the scb to the fcb and
//  it also contains a queue of ccbs that have opened the fcb via that name
//  and also a queue of Prefix Entries that will get us to this lcb
//

typedef struct _LCB {

    //
    //  Type and size of this record must be NTFS_NTC_LCB
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for all the Lcbs that emminate out of an Scb and a pointer
    //  back to the Scb.  Corresponds to Scb->LcbQueue.
    //

    LIST_ENTRY ScbLinks;
    struct _SCB *Scb;

    //
    //  The links for all the Lcbs that go into an Fcb and a pointer
    //  back to the Fcb.  Corresponds to Fcb->LcbQueue.
    //

    LIST_ENTRY FcbLinks;
    struct _FCB *Fcb;

    //
    //  This is the number of unclean handles on this link.
    //

    ULONG CleanupCount;

    //
    //  This is the number of references to this link.  The parent
    //  Scb must be owned to modify this count.
    //

    ULONG ReferenceCount;

    UCHAR FileNameFlags;

    //
    //  These are the flags for the changes to this link and the
    //  change count for the duplicated information on this link.
    //

    UCHAR InfoFlags;

    //
    //  The following are the case-sensitive and case-insensitive
    //  name links.
    //

    NAME_LINK IgnoreCaseLink;
    NAME_LINK ExactCaseLink;

    //
    //  A queue of Ccbs that have the Fcb (via this edge) opened.
    //  Corresponds to Ccb->LcbLinks
    //

    LIST_ENTRY CcbQueue;

    //
    //  Internal state of the Lcb
    //

    ULONG LcbState;

} LCB;
typedef LCB *PLCB;

#define LCB_STATE_DELETE_ON_CLOSE        (0x00000001)
#define LCB_STATE_LINK_IS_GONE           (0x00000002)
#define LCB_STATE_EXACT_CASE_IN_TREE     (0x00000004)
#define LCB_STATE_IGNORE_CASE_IN_TREE    (0x00000008)

#define LcbSplitPrimaryLink( LCB )  \
    ((LCB)->FileNameFlags == FILE_NAME_NTFS || (LCB)->FileNameFlags == FILE_NAME_DOS )

#define LcbSplitPrimaryComplement( LCB )    \
    (((LCB)->FileNameFlags == FILE_NAME_NTFS) ? FILE_NAME_DOS : FILE_NAME_NTFS)

#define LcbLinkIsDeleted( LCB )                                                 \
    ((FlagOn( (LCB)->LcbState, LCB_STATE_DELETE_ON_CLOSE ))                     \
     || ((FlagOn( (LCB)->FileNameFlags, FILE_NAME_DOS | FILE_NAME_NTFS ))       \
         && (FlagOn( (LCB)->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED ))))


//
//  The Fcb record corresponds to every open file and directory, and to
//  every directory on an opened path.
//
//  The structure is really divided into two parts.  FCB can be allocated
//  from paged pool while the SCB must be allocated from non-paged
//  pool.  There is an SCB for every file stream associated with the Fcb.
//
//  Note that the Fcb, multiple Scb records all use the same resource so
//  if we need to grab exclusive access to the Fcb we only need to grab one
//  resource and we've blocked all the scbs
//

typedef struct _FCB {

    //
    //  Type and size of this record must be NTFS_NTC_FCB
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The Queue of all the Lcb that we are part of.  The list is actually
    //  ordered in a small sense.  The get next scb routine that traverses the
    //  Fcb/Scb graph always will put the current lcb edge that it is traversing
    //  into the front of this queue.
    //

    LIST_ENTRY LcbQueue;

    //
    //  A pointer to the Vcb containing this Fcb
    //

    PVCB Vcb;

    //
    //  The internal state of the Fcb.  This is a collection Fcb state flags.
    //  Also the delete relavent counts for the file.
    //

    ULONG FcbState;
    ULONG FcbDenyDelete;
    ULONG FcbDeleteFile;

    //
    //  A count of the number of file objects that have been opened for
    //  this file, but not yet been cleaned up yet.
    //  This count gets decremented in NtfsCommonCleanup,
    //  while the CloseCount below gets decremented in NtfsCommonClose.
    //

    CLONG CleanupCount;

    //
    //  A count of the number of file objects that have opened
    //  this file.
    //

    CLONG CloseCount;

    //
    //  A count of other references to this Fcb.
    //

    CLONG ReferenceCount;

    //
    //  The following field contains the file reference for the Fcb
    //

    FILE_REFERENCE FileReference;

    //
    //  A queue of Scb associated with the fcb.
    //  Corresponds to Scb->FcbLinks
    //

    LIST_ENTRY ScbQueue;

    //
    //  These are the links for the list of exclusively-owned Scbs off of
    //  the IrpContext.  We need to keep track of the exclusive count
    //  in the Fcb before our acquire so we know how many times to release it.
    //

    LIST_ENTRY ExclusiveFcbLinks;

    //
    //  This is the links for all paging Io resources acquired for a transaction.
    //

    LIST_ENTRY ExclusivePagingIoLinks;

    USHORT BaseExclusiveCount;
    USHORT BaseExclusivePagingIoCount;

    //
    //  This counts the number of times the Ea's on this file have been
    //  modified.
    //

    USHORT EaModificationCount;

    //
    //  The following field is used to store a pointer to the resource
    //  protecting the Fcb
    //

    PERESOURCE Resource;

    //
    //  The following field contains a pointer to the resource synchronizing
    //  a changing FileSize with paging Io.
    //

    PERESOURCE PagingIoResource;

    //
    //  Copy of the duplicated information for this Fcb.
    //  Also a flags field to tell us what has changed in the structure.
    //

    LONGLONG CurrentLastAccess;

    DUPLICATED_INFORMATION Info;
    ULONG InfoFlags;
    ULONG LinkCount;

    //
    //  The following fields contains a pointer to the security descriptor for this
    //  file.  The field can start off null and later be loaded in by any of the
    //  security support routines.  On delete Fcb the field pool should be deallocated
    //  when the fcb goes away
    //

    struct _SHARED_SECURITY *SharedSecurity;
    ULONG CreateSecurityCount;

    //
    //  This is a pointer to a shared security descriptor for
    //  a non-index child of this directory.  Ignored for non-directory files.
    //

    struct _SHARED_SECURITY *ChildSharedSecurity;

} FCB;
typedef FCB *PFCB;

#define FCB_STATE_FILE_DELETED           (0x00000001)
#define FCB_STATE_NONPAGED               (0x00000002)
#define FCB_STATE_PAGING_FILE            (0x00000004)
#define FCB_STATE_FROM_PRERESTART        (0x00000008)
#define FCB_STATE_DUP_INITIALIZED        (0x00000010)
#define FCB_STATE_NO_ACL                 (0x00000020)
#define FCB_STATE_UPDATE_STD_INFO        (0x00000040)
#define FCB_STATE_PRIMARY_LINK_DELETED   (0x00000080)
#define FCB_STATE_EA_SCB_INVALID         (0x00000100)
#define FCB_STATE_IN_FCB_TABLE           (0x00000200)
#define FCB_STATE_MODIFIED_SECURITY      (0x00000400)

#define FCB_INFO_CHANGED_CREATE          (0x00000001)
#define FCB_INFO_CHANGED_LAST_MOD        (0x00000002)
#define FCB_INFO_CHANGED_LAST_CHANGE     (0x00000004)
#define FCB_INFO_CHANGED_LAST_ACCESS     (0x00000008)
#define FCB_INFO_CHANGED_ALLOC_SIZE      (0x00000010)
#define FCB_INFO_CHANGED_FILE_SIZE       (0x00000020)
#define FCB_INFO_CHANGED_FILE_ATTR       (0x00000040)
#define FCB_INFO_CHANGED_EA_SIZE         (0x00000080)

#define FCB_CREATE_SECURITY_COUNT        (5)
#define FCB_LARGE_ACL_SIZE               (512)


//
//  The following three structures are the separate union structures for
//  Scb structure.
//

typedef struct _SCB_DATA {

    //
    //  The following field is used by the oplock module
    //  to maintain current oplock information.
    //

    OPLOCK Oplock;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //

    PFILE_LOCK FileLock;

    //
    //  Share Access structure for this stream.  May not be present
    //  in this Scb.  Check the flag in the Scb.
    //

    SHARE_ACCESS ShareAccess;

} SCB_DATA, *PSCB_DATA;

typedef struct _SCB_INDEX {

    //
    //  This is a list of records within the index allocation stream which
    //  have been deallocated in the current transaction.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  A queue of all the lcbs that are opened under this Scb.
    //  Corresponds to Lcb->ScbLinks
    //

    LIST_ENTRY LcbQueue;

    //
    //  A change count incremented every time an index buffer is deleted.
    //

    ULONG ChangeCount;

    //
    //  Type of attribute being indexed.
    //

    ATTRIBUTE_TYPE_CODE AttributeBeingIndexed;

    //
    //  Collation rule, for how the indexed attribute is collated.
    //

    ULONG CollationRule;

    //
    //  Size of Index Allocation Buffer in bytes, or 0 if not yet
    //  initialized.
    //

    ULONG BytesPerIndexBuffer;

    //
    //  Size of Index Allocation Buffers in units of clusters, or 0
    //  if not yet initialized.
    //

    UCHAR ClustersPerIndexBuffer;

    //
    //  Flag to indicate whether the RecordAllocationContext has been
    //  initialized or not.  If it is not initialized, this means
    //  either that there is no external index allocation, or that
    //  it simply has not been initialized yet.
    //

    BOOLEAN AllocationInitialized;

    //
    //  Index Depth Hint
    //

    USHORT IndexDepthHint;

    //
    //  Record allocation context, for managing the allocation of the
    //  INDEX_ALLOCATION_ATTRIBUTE, if one exists.
    //

    RECORD_ALLOCATION_CONTEXT RecordAllocationContext;

    //
    //  The following are the splay links of Lcbs opened under this
    //  Scb.  Note that not all of the Lcb in the list above may
    //  be in the splay links below.
    //

    PRTL_SPLAY_LINKS ExactCaseNode;
    PRTL_SPLAY_LINKS IgnoreCaseNode;

    //
    //  Share access structure for this file.
    //

    SHARE_ACCESS ShareAccess;

} SCB_INDEX, *PSCB_INDEX;

typedef struct _SCB_MFT {

    //
    //  This is a list of records within the Mft Scb stream which
    //  have been deallocated in the current transaction.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  The following field contains index of a reserved free record.  To
    //  keep us out of the chicken & egg problem of the Mft being able to
    //  be self mapping we added the ability to reserve an mft record
    //  to describe additional mft data allocation within previous mft
    //  run.  A value of zero means that index has not been reserved.
    //

    ULONG ReservedIndex;

    //
    //  The following Mcb's are used to track clusters being added and removed
    //  from the Mcb for the Scb.  This Scb must always be fully loaded after
    //  an abort.  We can't depend on reloading on the next LookupAllocation
    //  call.  Instead we keep one Mcb with the clusters added and one Mcb
    //  with the clusters removed.  During the restore phase of abort we
    //  will adjust the Mft Mcb by reversing the operations done during the
    //  transactions.
    //

    LARGE_MCB AddedClusters;
    LARGE_MCB RemovedClusters;

    //
    //  The following are the changes made to the Mft file as file records are added,
    //  freed or allocated.  Also the change in the number of file records which are
    //  part of holes.
    //

    LONG FreeRecordChange;
    LONG HoleRecordChange;

} SCB_MFT, *PSCB_MFT;

//
//  The following is the non-paged part of the scb.
//

typedef struct _SCB_NONPAGED {

    //
    //  Type and size of this record must be NTFS_NTC_SCB_NONPAGED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  Index allocated for this file in the Open Attribute Table.
    //

    ULONG OpenAttributeTableIndex;

    //
    //  Copy of the Vcb pointer so we can find the Vcb in the dirty page callback
    //  routine.
    //

    PVCB Vcb;

} SCB_NONPAGED, *PSCB_NONPAGED;


//
//  The following structure is the stream control block.  There can
//  be multiple records per fcb.  One is created for each attribute being
//  handled as a stream file.
//

typedef struct _SCB {

    //
    //  The following field is used for fast I/O.  It contains the node type code
    //  and size, indicates if fast I/O is possible, contains allocation, file,
    //  and valid data size, a resource, and call back pointers for FastIoRead and
    //  FastMdlRead.
    //
    //  The node type codes for the Scb must be either NTFS_NTC_SCB_INDEX,
    //  NTFS_NTC_SCB_ROOT_INDEX, or NTFS_NTC_SCB_DATA.  Which one it is determines
    //  the state of the union below.
    //

    FSRTL_COMMON_FCB_HEADER Header;

    //
    //  The links for the queue of Scb off of a given Fcb.  And a pointer back
    //  to the Fcb.  Corresponds to Fcb->ScbQueue
    //

    LIST_ENTRY FcbLinks;
    PFCB Fcb;

    //
    //  A pointer to the Vcb containing this Scb
    //

    PVCB Vcb;

    //
    //  The internal state of the Scb.
    //

    ULONG ScbState;

    //
    //  The following two fields identify the actual attribute for this
    //  Scb with respect to its file.   We identify the attribute by
    //  its type code and name.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    UNICODE_STRING AttributeName;

    //
    //  Stream File Object for internal use.  This field is NULL if the file
    //  stream is not being accessed internally.
    //

    PFILE_OBJECT FileObject;

    //
    //  A count of the number of file objects that have been opened for
    //  this attribute, but not yet been cleaned up yet.
    //  This count gets decremented in NtfsCommonCleanup,
    //  while the CloseCount below gets decremented in NtfsCommonClose.
    //

    CLONG CleanupCount;

    //
    //  A count of the number of file objects that have opened
    //  this attribute.
    //

    CLONG CloseCount;

    //
    //  This pointer is used to detect writes that eminated from the
    //  cache manager's worker thread.  It prevents lazy writer threads,
    //  who already have the Fcb shared, from trying to acquire it
    //  exclusive, and thus causing a deadlock.
    //

    PVOID LazyWriteThread;

    //
    //  Pointer to structure containing snapshotted Scb values, or NULL
    //  if the values have not been snapshotted.
    //

    struct _SCB_SNAPSHOT * ScbSnapshot;

    //
    //  First unknown Vcn in the Mcb.  This field is maintained every time
    //  allocation is looked up by someone currently holding the Scb exclusive,
    //  in order to not "reload" space into the Mcb when deleting files with
    //  multiple file records.
    //

    VCN FirstUnknownVcn;

    //
    //  The following field contains the mcb for this Scb
    //

    LARGE_MCB Mcb;

    //
    //  Pointer to the non-paged section objects and open attribute
    //  table index.
    //

    PSCB_NONPAGED NonpagedScb;

    //
    //  Compression unit from attribute record.
    //

    ULONG CompressionUnit;

    //
    //  Highest Vcn written to disk, important for file compression.
    //

    VCN HighestVcnToDisk;

    //
    //  Number of clusters added due to Split Mcb calls.  The user has
    //  not asked for this allocation.
    //

    LONGLONG ExcessFromSplitMcb;

    //
    //  Scb Type union, for different types of Scbs
    //

    union {

        SCB_DATA Data;
        SCB_INDEX Index;
        SCB_MFT Mft;

    } ScbType;

} SCB;
typedef SCB *PSCB;

#define SIZEOF_SCB_DATA             (FIELD_OFFSET( SCB, ScbType ) + FIELD_OFFSET( SCB_DATA, ShareAccess ))
#define SIZEOF_SCB_SHARE_DATA       (FIELD_OFFSET( SCB, ScbType ) + sizeof( SCB_DATA ))
#define SIZEOF_SCB_INDEX            (FIELD_OFFSET( SCB, ScbType ) + sizeof( SCB_INDEX ))
#define SIZEOF_SCB_MFT              (FIELD_OFFSET( SCB, ScbType ) + sizeof( SCB_MFT ))

#define SCB_STATE_TRUNCATE_ON_CLOSE         (0x00000001)
#define SCB_STATE_DELETE_ON_CLOSE           (0x00000002)
#define SCB_STATE_CHECK_ATTRIBUTE_SIZE      (0x00000004)
#define SCB_STATE_ATTRIBUTE_RESIDENT        (0x00000008)
#define SCB_STATE_UNNAMED_DATA              (0x00000010)
#define SCB_STATE_HEADER_INITIALIZED        (0x00000020)
#define SCB_STATE_NONPAGED                  (0x00000040)
#define SCB_STATE_USA_PRESENT               (0x00000080)
#define SCB_STATE_INTERNAL_ATTR_STREAM      (0x00000100)
#define SCB_STATE_ATTRIBUTE_DELETED         (0x00000200)
#define SCB_STATE_FILE_SIZE_LOADED          (0x00000400)
#define SCB_STATE_MODIFIED_NO_WRITE         (0x00000800)
#define SCB_STATE_USE_PAGING_IO_RESOURCE    (0x00001000)
#define SCB_STATE_CC_HAS_PAGING_IO_RESOURCE (0x00002000)
#define SCB_STATE_CREATE_MODIFIED_SCB       (0x00004000)
#define SCB_STATE_UNINITIALIZE_ON_RESTORE   (0x00008000)
#define SCB_STATE_RESTORE_UNDERWAY          (0x00010000)
#define SCB_STATE_SHARE_ACCESS              (0x00020000)
#define SCB_STATE_NOTIFY_ADD_STREAM         (0x00040000)
#define SCB_STATE_NOTIFY_REMOVE_STREAM      (0x00080000)
#define SCB_STATE_NOTIFY_RESIZE_STREAM      (0x00100000)
#define SCB_STATE_NOTIFY_MODIFY_STREAM      (0x00200000)
#define SCB_STATE_TEMPORARY                 (0x00400000)
#define SCB_STATE_COMPRESSED                (0x00800000)
#define SCB_STATE_REALLOCATE_ON_WRITE       (0x01000000)
#define SCB_STATE_DELAY_CLOSE               (0x02000000)

#define MAX_SCB_ASYNC_ACQUIRE               (0xf000)


//
//  Structure to contain snapshotted Scb values for error recovery.
//

typedef struct _SCB_SNAPSHOT {

    //
    //  Links for list snapshot structures off of IrpContext
    //

    LIST_ENTRY SnapshotLinks;

    //
    //  Saved values of the corresponding Scb (or FsRtl Header) fields
    //  The low bit of allocation size is set to remember when the
    //  attribute was resident.  The next bit, bit 1, is set to remember
    //  when the attribute was compressed.
    //

    LONGLONG AllocationSize;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;

    VCN LowestModifiedVcn;

    //
    //  Compression Unit
    //

    ULONG CompressionUnit;

    //
    //  Pointer to the Scb which has been snapped.
    //

    PSCB Scb;

} SCB_SNAPSHOT;
typedef SCB_SNAPSHOT *PSCB_SNAPSHOT;


//
//  The Ccb record is allocated for every file object
//

typedef struct _CCB {

    //
    //  Type and size of this record (must be NTFS_NTC_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The query template is used to filter directory query requests.
    //  It originally is set to null and on the first call the NtQueryDirectory
    //  it is set the the input filename or "*" if no name is supplied.
    //  All subsquent queries then use this template.
    //

    ULONG QueryLength;
    PVOID QueryBuffer;

    //
    //  The last returned value.  A copy of an IndexEntry is saved.  We only
    //  grow this buffer, to avoid always deallocating and reallocating.
    //

    ULONG IndexEntryLength;
    PINDEX_ENTRY IndexEntry;

    //
    //  Pointer to the index context structure for enumerations
    //

    struct _INDEX_CONTEXT *IndexContext;

    //
    //  This is the offset of the next Ea to return to the user.
    //

    ULONG NextEaOffset;

    //
    //  This is the Ccb Ea modification count.  If this count is in
    //  sync with the Fcb value, then the above offset is valid.
    //

    USHORT EaModificationCount;

    //
    //  Ccb flags.
    //

    ULONG Flags;

    //
    //  The links for the queue of Ccb off of a given Lcb and a pointer
    //  back to the Lcb.  Corresponds to Lcb->CcbQueue
    //

    LIST_ENTRY LcbLinks;
    PLCB Lcb;

    //
    //  This is a unicode string for the full filename used to
    //  open this file.
    //

    UNICODE_STRING FullFileName;
    USHORT LastFileNameOffset;

} CCB;
typedef CCB *PCCB;

#define CCB_FLAG_IGNORE_CASE                (0x00000001)
#define CCB_FLAG_OPEN_AS_FILE               (0x00000002)
#define CCB_FLAG_WILDCARD_IN_EXPRESSION     (0x00000004)
#define CCB_FLAG_OPEN_BY_FILE_ID            (0x00000008)
#define CCB_FLAG_USER_SET_LAST_MOD_TIME     (0x00000010)
#define CCB_FLAG_USER_SET_LAST_CHANGE_TIME  (0x00000020)
#define CCB_FLAG_USER_SET_LAST_ACCESS_TIME  (0x00000040)
#define CCB_FLAG_TRAVERSE_CHECK             (0x00000080)

#define CCB_FLAG_RETURN_DOT                 (0x00000100)
#define CCB_FLAG_RETURN_DOTDOT              (0x00000200)
#define CCB_FLAG_DOT_RETURNED               (0x00000400)
#define CCB_FLAG_DOTDOT_RETURNED            (0x00000800)

#define CCB_FLAG_DELETE_FILE                (0x00001000)
#define CCB_FLAG_DENY_DELETE                (0x00002000)

#define CCB_FLAG_ALLOCATED_FILE_NAME        (0x00004000)
#define CCB_FLAG_CLEANUP                    (0x00008000)


//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the NtfsComplete
//  request routine.
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be NTFS_NTC_IRP_CONTEXT)
    //
    //  NOTE:  THIS STRUCTURE MUST REMAIN 64-bit ALIGNED IN SIZE, SINCE
    //         IT IS ZONE ALLOCATED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    //
    //  This is a list of exclusively-owned Scbs which may only be
    //  released after the transaction is committed.
    //

    LIST_ENTRY ExclusiveFcbList;

    //
    //  This is a list of exclusively-owned paging Io resources which may only be
    //  released after the transaction is committed.
    //

    LIST_ENTRY ExclusivePagingIoList;

    //
    //  This structure contains the first ScbSnapshot for a modifying
    //  request which acquires files exclusive and snaps Scb values.
    //  If the SnapshotLinks field contains NULLs, then no data has
    //  been snapshot for this request, and the list is empty.  If
    //  the links are not NULL, then this snapshot structure is in
    //  use.  If the SnapshotLinks are not NULL, and do not represent
    //  an empty list, then there are addtional dynamically allocated
    //  snapshot structures in this list.
    //

    SCB_SNAPSHOT ScbSnapshot;

    //
    //  This is the Last Restart Area Lsn captured from the Vcb at
    //  the time log file full was raised.  The caller will force
    //  a checkpoint if this has not changed by the time he gets
    //  the global resource exclusive.
    //

    LSN LastRestartArea;

    //
    //  A pointer to the originating Irp.  We will store the Scb for
    //  delayed or async closes here while the request is queued.
    //

    PIRP OriginatingIrp;

    //
    //  Originating Device (required for workque algorithms)
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  Major and minor function codes copied from the Irp
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  Irp Context flags
    //

    ULONG Flags;

    //
    //  The following field contains the NTSTATUS value used when we are
    //  unwinding due to an exception.  We will temporarily store the Ccb
    //  for a delayed or deferred close here while the request is queued.
    //

    NTSTATUS ExceptionStatus;

    //
    //  Transaction Id for this request, which must be qualified by Vcb.
    //  We will store the type of open for a delayed or async close here
    //  while the request is queued.
    //

    PVCB Vcb;
    TRANSACTION_ID TransactionId;

    //
    //  The following field is used to maintain a queue of records that have been
    //  deallocated while processing this irp context.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  The following union contains pointers to the IoContext for I/O based requests
    //  and a pointer to a security context for requests which need to capture the
    //  subject context in the calling thread.
    //

    union {

        //
        //  The following context block is used for non-cached Io.
        //

        struct _NTFS_IO_CONTEXT *NtfsIoContext;

        //
        //  The following is the captured subject context.
        //

        PSECURITY_SUBJECT_CONTEXT SubjectContext;

    } Union;

    //
    //  This is the IrpContext for the top level request.
    //

    struct _IRP_CONTEXT *TopLevelIrpContext;

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

#define IRP_CONTEXT_FLAG_FROM_POOL          (0x00000002)
#define IRP_CONTEXT_FLAG_WAIT               (0x00000004)
#define IRP_CONTEXT_FLAG_WRITE_THROUGH      (0x00000008)
#define IRP_CONTEXT_LARGE_ALLOCATION        (0x00000010)
#define IRP_CONTEXT_DEFERRED_WRITE          (0x00000020)
#define IRP_CONTEXT_FLAG_ALLOC_CONTEXT      (0x00000040)
#define IRP_CONTEXT_FLAG_ALLOC_SECURITY     (0x00000080)
#define IRP_CONTEXT_MFT_RECORD_15_USED      (0x00000100)
#define IRP_CONTEXT_MFT_RECORD_RESERVED     (0x00000200)
#define IRP_CONTEXT_FLAG_IN_FSP             (0x00000400)
#define IRP_CONTEXT_FLAG_RAISED_STATUS      (0x00000800)
#define IRP_CONTEXT_FLAG_IN_TEARDOWN        (0x00001000)
#define IRP_CONTEXT_FLAG_ACQUIRE_VCB_EX     (0x00002000)
#define IRP_CONTEXT_FLAG_READ_ONLY_FO       (0x00004000)


//
//  The top level context is used to determine whether this request has other
//  requests below it on the stack.
//

typedef struct _TOP_LEVEL_CONTEXT {

    BOOLEAN TopLevelRequest;

    ULONG Ntfs;

    VCN VboBeingHotFixed;

    PSCB ScbBeingHotFixed;

    PIRP SavedTopLevelIrp;

    PIRP_CONTEXT TopLevelIrpContext;

} TOP_LEVEL_CONTEXT;
typedef TOP_LEVEL_CONTEXT *PTOP_LEVEL_CONTEXT;


//
//  The found attribute part of the attribute enumeration context describes
//  an attribute record that had been located or created.  It may refer to
//  either a base or attribute list.
//

typedef struct _FOUND_ATTRIBUTE {

    //
    //  The following identify the attribute which was mapped.  These are
    //  necessary if forcing the range of bytes into memory by pinning.
    //  These include the Bcb on which the attribute was read (if this field
    //  is NULL, this is the initial attribute) and the offset of the
    //  record segment in the Mft.
    //

    PBCB Bcb;

    LONGLONG MftFileOffset;

    //
    //  Pointer to the Attribute Record
    //

    PATTRIBUTE_RECORD_HEADER Attribute;

    //
    //  Pointer to the containing record segment.
    //

    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    //
    //  Some state information.
    //

    BOOLEAN AttributeDeleted;
    BOOLEAN AttributeAllocationDeleted;

} FOUND_ATTRIBUTE;
typedef FOUND_ATTRIBUTE *PFOUND_ATTRIBUTE;

//
//  The structure guides enumeration through the attribute list.
//

typedef struct _ATTRIBUTE_LIST_CONTEXT {

    //
    //  This field is used to remember the location of the Attribute
    //  List attribute within the base file record, if existent.
    //

    PATTRIBUTE_RECORD_HEADER AttributeList;

    //
    //  A Bcb for the attribute list.
    //

    PBCB Bcb;

    //
    //  This points to the first entry in the attribute list.  This is
    //  needed when the attribute list is non-resident.
    //

    PATTRIBUTE_LIST_ENTRY FirstEntry;

    //
    //  This points to the first attribute list entry; it is advanced
    //  when we are searching for a particular exteral attribute.
    //

    PATTRIBUTE_LIST_ENTRY Entry;

    //
    //  This points just beyond the final attribute list entry.
    //

    PATTRIBUTE_LIST_ENTRY BeyondFinalEntry;

} ATTRIBUTE_LIST_CONTEXT;
typedef ATTRIBUTE_LIST_CONTEXT *PATTRIBUTE_LIST_CONTEXT;

//
//  The Attribute Enumeration Context structure returns information on an
//  attribute which has been found by one of the Attribute Lookup or Creation
//  routines.  It is also used as an IN OUT structure to perform further
//  lookups/modifications to attributes.  It does not have a node type code
//  and size since it is usually allocated on the caller's stack.
//

typedef struct _ATTRIBUTE_ENUMERATION_CONTEXT {

    //
    //  Contains the actual attribute we found.
    //

    FOUND_ATTRIBUTE FoundAttribute;

    //
    //  Allows enumeration through the attribute list.
    //

    ATTRIBUTE_LIST_CONTEXT AttributeList;

} ATTRIBUTE_ENUMERATION_CONTEXT;
typedef ATTRIBUTE_ENUMERATION_CONTEXT *PATTRIBUTE_ENUMERATION_CONTEXT;


//
//  Define struct which will be used to remember the path that was followed
//  to locate a given INDEX_ENTRY or insertion point for an INDEX_ENTRY.
//  This structure is always filled in by LookupIndexEntry.
//
//  The Index Lookup Stack is generally allocated as a local variable in
//  one of the routines in this module that may be called from another module.
//  A pointer to this stack is then passed in to some of the internal routines.
//
//  The first entry in the stack describes context in the INDEX attribute in the
//  file record, and all subsequent stack entries refer to Index buffers in
//  the INDEX_ALLOCATION attribute.
//
//  Outside of indexsup.c, this structure should only be passed as an "opaque"
//  context, and individual fields should not be referenced.
//

typedef struct _INDEX_LOOKUP_STACK {

    //
    //  Bcb pointer for the Index Buffer.  In the "bottom" (first entry) of
    //  the stack this field contains a NULL, and the Bcb must be found via
    //  the Attribute Enumeration Context.
    //

    PBCB Bcb;

    //
    //  Pointer to the start of the File Record or Index Buffer
    //

    PVOID StartOfBuffer;

    //
    //  Pointer to Index Header in the File Record or Index Buffer
    //

    PINDEX_HEADER IndexHeader;

    //
    //  Pointer to to the current INDEX_ENTRY on search path
    //

    PINDEX_ENTRY IndexEntry;

    //
    //  Vcn of IndexBuffer
    //

    VCN Vcn;

    //
    //  Saved Lsn for faster enumerations
    //

    LSN CapturedLsn;

} INDEX_LOOKUP_STACK;

typedef INDEX_LOOKUP_STACK *PINDEX_LOOKUP_STACK;

#define INDEX_LOOKUP_STACK_SIZE      (3)

//
//  Index Context structure.
//
//  This structure maintains a context which describes the lookup stack to a
//  given index entry.  It includes the Attribute Enumeration Context for the
//  Index Root, the Index lookup stack remembering the path to the index entry,
//  and the current stack pointer within the stack pointing to the stack entry
//  for the current index entry or where we are at in a bucket split or delete
//  operation.
//
//  Outside of indexsup.c, this structure should only be passed as an "opaque"
//  context, and individual fields should not be referenced.
//

typedef struct _INDEX_CONTEXT {

    //
    //  Index lookup stack.
    //

    INDEX_LOOKUP_STACK LookupStack[INDEX_LOOKUP_STACK_SIZE];

    //
    //  Base of dynamically allocated lookup stack - either points
    //  to the one above or a dynamically allocated larger one.
    //

    PINDEX_LOOKUP_STACK Base;

    //
    //  Stack pointer within the Index Lookup Stack
    //

    PINDEX_LOOKUP_STACK Current;

    //
    //  Stack pointer to top of Lookup Stack.  This field essentially
    //  remembers how deep the index Btree is.
    //

    PINDEX_LOOKUP_STACK Top;

    //
    //  Captured Scb (Index type) change count
    //

    ULONG ScbChangeCount;

    //
    //  This field remembers where the index root attribute was last
    //  seen, to support correct operation of FindMoveableIndexRoot.
    //

    PATTRIBUTE_RECORD_HEADER OldAttribute;

    //
    //  Number of entries allocated in the lookup stack.
    //

    USHORT NumberEntries;

    //
    //  Reserved...
    //

    USHORT Reserved;

    //
    //  Attribute Enumeration Context for the Index Root
    //

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

} INDEX_CONTEXT;

typedef INDEX_CONTEXT *PINDEX_CONTEXT;


//
//  Context structure for asynchronous I/O calls.  Most of these fields
//  are actually only required for the Read/Write Multiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _NTFS_IO_CONTEXT {

    //
    //  These two fields are used for multiple run Io
    //

    LONG IrpCount;
    PIRP MasterIrp;
    UCHAR IrpSpFlags;
    BOOLEAN AllocatedContext;

    union {

        //
        //  This element handles the asynchronous non-cached Io
        //

        struct {

            PERESOURCE Resource;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;

        } Async;

        //
        //  and this element handles the synchronous non-cached Io.
        //

        KEVENT SyncEvent;

    } Wait;


} NTFS_IO_CONTEXT;

typedef NTFS_IO_CONTEXT *PNTFS_IO_CONTEXT;

//
//  An array of these structures is passed to NtfsMultipleAsync describing
//  a set of runs to execute in parallel.
//

typedef struct _IO_RUN {

    VBO StartingVbo;
    LBO StartingLbo;
    ULONG BufferOffset;
    ULONG ByteCount;
    PIRP SavedIrp;

} IO_RUN;
typedef IO_RUN *PIO_RUN;


//
//  This structure is used by the name manipulation routines to described a
//  parsed file name componant.
//

typedef struct _NTFS_NAME_DESCRIPTOR {

    //
    //  The follow flag tells which fields were present in the name.
    //

    ULONG FieldsPresent;

    UNICODE_STRING FileName;
    UNICODE_STRING AttributeType;
    UNICODE_STRING AttributeName;
    ULONG VersionNumber;

} NTFS_NAME_DESCRIPTOR;
typedef NTFS_NAME_DESCRIPTOR *PNTFS_NAME_DESCRIPTOR;

//
//  Define the bits in FieldsPresent above.
//

#define FILE_NAME_PRESENT_FLAG          (1)
#define ATTRIBUTE_TYPE_PRESENT_FLAG     (2)
#define ATTRIBUTE_NAME_PRESENT_FLAG     (4)
#define VERSION_NUMBER_PRESENT_FLAG     (8)


//
//  The following is used to perform Ea related routines.
//

typedef struct _EA_LIST_HEADER {

    //
    //  The size of buffer needed to pack these Ea's
    //

    ULONG PackedEaSize;

    //
    //  This is the count of Ea's with their NEED_EA
    //  bit set.
    //

    USHORT NeedEaCount;

    //
    //  The size of the buffer needed to return all Ea's
    //  in their unpacked form.
    //

    ULONG UnpackedEaSize;

    //
    //  This is the size of the buffer used to store the ea's
    //

    ULONG BufferSize;

    //
    //  This is the pointer to the first entry in the list.
    //

    PFILE_FULL_EA_INFORMATION FullEa;

} EA_LIST_HEADER;
typedef EA_LIST_HEADER *PEA_LIST_HEADER;


//
//  The following structure is used to maintain a list of recently deallocated
//  records so that the file system will not reuse a recently deallocated record
//  until it is safe to do so.  Each instance of this structure is placed on
//  two queues.  One queue is per index SCB and the other queue is per Irp Context.
//
//  Whenever we delete a record we allocate a new structure if necessary and add
//  it to the scb queue and the irp context queue.  We indicate in the structure
//  the index of the record we just deallocated.
//
//  Whenever we need to allocate a new record we filter out any canidate we want
//  to allocate to avoid allocating one in the scb's recently deallocated queue.
//
//  Whenever we delete an irp context we scan through its recently deallocated
//  queue removing it from the scb queue.
//

#define DEALLOCATED_RECORD_ENTRIES          32

typedef struct _DEALLOCATED_RECORDS {

    //
    //  The following field links this structure into the Scb->RecentlyDeallocatedQueue
    //

    LIST_ENTRY ScbLinks;

    //
    //  The following field links this structure into the IrpContext->RecentlyDeallocatedQueue
    //

    LIST_ENTRY IrpContextLinks;

    //
    //  This is a pointer to the Scb that this record is part of
    //

    PSCB Scb;

    //
    //  The following two fields describe the total size of this structure and
    //  the number of entries actually being used.  NumberOfEntries is the size
    //  of the Index array and NextFreeEntryis the index of the next free slot.
    //  If NumberOfEntries is equal to NextFreeEntry then this structure is full
    //

    ULONG NumberOfEntries;
    ULONG NextFreeEntry;

    //
    //  This is an array of indices that have been dealloated.
    //

    ULONG Index[DEALLOCATED_RECORD_ENTRIES];

} DEALLOCATED_RECORDS;
typedef DEALLOCATED_RECORDS *PDEALLOCATED_RECORDS;

#define DEALLOCATED_RECORDS_HEADER_SIZE (FIELD_OFFSET( DEALLOCATED_RECORDS, Index ))

typedef struct _FCB_TABLE_ELEMENT {

    FILE_REFERENCE FileReference;
    PFCB Fcb;

} FCB_TABLE_ELEMENT;
typedef FCB_TABLE_ELEMENT *PFCB_TABLE_ELEMENT;


//
//  Security descriptor information.  This structure is used to allow
//  Fcb's to share security descriptors.
//

typedef struct _SHARED_SECURITY {

    PFCB ParentFcb;
    ULONG ReferenceCount;
    ULONG SecurityDescriptorLength;
    UCHAR SecurityDescriptor[1];

} SHARED_SECURITY, *PSHARED_SECURITY;


//
//  The following structure is used to store the state of an Scb to use during
//  unwind operations.  We keep a copy of all of the file sizes.
//

typedef struct _OLD_SCB_SNAPSHOT {

    LONGLONG AllocationSize;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;

    UCHAR CompressionUnit;
    BOOLEAN Resident;
    BOOLEAN Compressed;

} OLD_SCB_SNAPSHOT, *POLD_SCB_SNAPSHOT;

//
//  Structure used to track the number of threads doing read ahead, so that
//  we do not hot fix for them.
//

typedef struct _READ_AHEAD_THREAD {

    //
    //  Links of read ahead structures.
    //

    LIST_ENTRY Links;

    //
    //  Thread Id
    //

    PVOID Thread;
} READ_AHEAD_THREAD, *PREAD_AHEAD_THREAD;

//
//  Structure used to post to Defrag Mft routine.
//

typedef struct _DEFRAG_MFT {

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    PVCB Vcb;

    BOOLEAN DeallocateWorkItem;

} DEFRAG_MFT, *PDEFRAG_MFT;

#endif // _NTFSSTRU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\ofsbedit.cxx ===
#include "ulib.hxx"
#include "ofs.hxx"
#include "ofsbedit.hxx"

extern "C" {
#include <stdio.h>
}


VOID
OFS_BOOT_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
OFS_BOOT_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    DSKPACKEDBOOTSECT       *p;
    DSKBPB                  bpb;
    TEXTMETRIC              textmetric;
    INT                     ch, current;
    TCHAR                   buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);

    if (!_buffer || _size < 128) {
        return;
    }

    p = (DSKPACKEDBOOTSECT *) _buffer;
    UnpackOfsBios(&bpb, &(p->PackedBpb));

    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    current = 0;

    swprintf(buf, TEXT("OEM String: %c%c%c%c%c%c%c%c"),
                 p->Oem[0],
                 p->Oem[1],
                 p->Oem[2],
                 p->Oem[3],
                 p->Oem[4],
                 p->Oem[5],
                 p->Oem[6],
                 p->Oem[7]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Bytes per sector: %x"), bpb.BytesPerSector);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per cluster: %x"), bpb.SectorsPerCluster);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Reserved Sectors: %x"),  bpb.ReservedSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of fats: %x"), bpb.Fats);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Root entries: %x"), bpb.RootEntries);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Small sector count: %x"), bpb.Sectors16);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Media byte: %x"), bpb.Media);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per fat: %x"), bpb.SectorsPerFat);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per track: %x"), bpb.SectorsPerTrack);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of heads: %x"), bpb.Heads);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of hidden sectors: %x"), bpb.HiddenSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Large number of sectors: %x"), bpb.Sectors32);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Volume Id: <%x,%x>"), (ULONG)(p->VolumeId >> 32),
        (ULONG)(p->VolumeId));
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("OFS number of sectors: <%x,%x>"), (ULONG)(p->Sectors >> 32),
        (ULONG)(p->Sectors));
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("OfsVolCatExtent: %x for %x"), ExtentAddr(p->OfsVolCatExtent),
        ExtentSize(p->OfsVolCatExtent));
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("CheckSum: %x"), p->CheckSum);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Flags: %x"), p->Flags);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\partedit.cxx ===
#include "ulib.hxx"
#include "partedit.hxx"


extern "C" {
#include <stdio.h>
}

BOOLEAN
PARTITION_TABLE_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);

    return TRUE;
}


VOID
PARTITION_TABLE_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}


VOID
PARTITION_TABLE_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PARTITION_TABLE_ENTRY   Entry;
    PPARTITION_TABLE_ENTRY  p;
    TEXTMETRIC              textmetric;
    INT                     ch, CurrentLine;
    TCHAR                   buf[1024];
    ULONG                   i, Checksum, *pul;

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || _size < 512) {
        return;
    }

    p = (PPARTITION_TABLE_ENTRY)((PBYTE)_buffer+0x1be);

    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    CurrentLine = 0;

    swprintf( buf, TEXT("Disk Signature: 0x%x"), *((PULONG)_buffer + 0x6E) );
    WriteLine( DeviceContext, CurrentLine++, buf );

    // Compute the sector checksum.
    //
    Checksum = 0;

    for( i = 0, pul = (PULONG)_buffer; i < 0x80; i++, pul++ ) {

        Checksum += *pul;
    }

    swprintf( buf, TEXT("Sector Checksum: 0x%x"), Checksum );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("") );
    WriteLine( DeviceContext, CurrentLine++, buf );

    for( i = 0; i < 4; i++ ) {

        memcpy( &Entry, p, sizeof(PARTITION_TABLE_ENTRY) );

        swprintf( buf, TEXT("Entry %d"), i );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Boot Indicator: 0x%x"), Entry.BootIndicator );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Beginning Head: 0x%x"), Entry.BeginningHead );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Beginning Sector: 0x%x"), Entry.BeginningSector );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Beginning Cylinder: 0x%x"), Entry.BeginningCylinder );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  System ID: 0x%x"), Entry.SystemID );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Ending Head: 0x%x"), Entry.EndingHead );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Ending Sector: 0x%x"), Entry.EndingSector );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Ending Cylinder: 0x%x"), Entry.EndingCylinder );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Starting Sector: 0x%x"), Entry.StartingSector );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Sectors: 0x%x"), Entry.Sectors );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("") );
        WriteLine( DeviceContext, CurrentLine++, buf );

        p++;
    }

    SetRange(WindowHandle, CurrentLine - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\recordpg.cxx ===
#include "ulib.hxx"
#include "drive.hxx"
#include "untfs.hxx"
#include "recordpg.hxx"

extern "C" {
#include <stdio.h>
}

BOOLEAN
RECORD_PAGE_EDIT::Initialize(
    IN      HWND    WindowHandle,
    IN      INT     ClientHeight,
    IN      INT     ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  tm;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &tm);
    ReleaseDC(WindowHandle, hdc);

    if (!VERTICAL_TEXT_SCROLL::Initialize(
        WindowHandle,
        0,
        ClientHeight,
        ClientWidth,
        tm.tmExternalLeading + tm.tmHeight,
        tm.tmMaxCharWidth
        )) {
        return FALSE;
    }

    return TRUE;
}


VOID
RECORD_PAGE_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetRange(WindowHandle, _size/2);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
RECORD_PAGE_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PLFS_RECORD_PAGE_HEADER pRecordPageHeader;
    TEXTMETRIC tm;
    INT ch, CurrentLine;
    TCHAR buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, _size/2, FALSE);
    SetScrollPos(WindowHandle, SB_VERT, QueryScrollPosition(), TRUE);

    if (!_buffer || _size < 512) {
        return;
    }

    GetTextMetrics(DeviceContext, &tm);
    ch = tm.tmExternalLeading + tm.tmHeight;
    CurrentLine = 0;

    pRecordPageHeader = (PLFS_RECORD_PAGE_HEADER)_buffer;

    swprintf(buf, TEXT("MultiSectorHeader.Signature: %c%c%c%c"),
        pRecordPageHeader->MultiSectorHeader.Signature[0],
        pRecordPageHeader->MultiSectorHeader.Signature[1],
        pRecordPageHeader->MultiSectorHeader.Signature[2],
        pRecordPageHeader->MultiSectorHeader.Signature[3]);
    WriteLine(DeviceContext, CurrentLine++, buf);
    
    swprintf(buf, TEXT("MultiSectorHeader.UpdateSequenceArrayOffset: %ul"),
        pRecordPageHeader->MultiSectorHeader.UpdateSequenceArrayOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);
    
    swprintf(buf, TEXT("MultiSectorHeader.UpdateSequenceArraySize: %x"),
        pRecordPageHeader->MultiSectorHeader.UpdateSequenceArraySize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Copy.LastLsn: %x:%x"),
        pRecordPageHeader->Copy.LastLsn.HighPart,
        pRecordPageHeader->Copy.LastLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Copy.FileOffset: %x"), pRecordPageHeader->Copy.FileOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Flags: %x"), pRecordPageHeader->Flags);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("PageCount: %x"), pRecordPageHeader->PageCount);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("PagePosition: %x"), pRecordPageHeader->PagePosition);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Header.Packed.NextRecordOffset: %x"),
        pRecordPageHeader->Header.Packed.NextRecordOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Header.Packed.LastEndLsn: %x:%x"),
        pRecordPageHeader->Header.Packed.LastEndLsn.HighPart,
        pRecordPageHeader->Header.Packed.LastEndLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    // then Header.Packed.UpdateSequenceArray
}

VOID
RECORD_PAGE_EDIT::KeyUp(
    IN HWND WindowHandle
    )
{
    ScrollUp(WindowHandle);
}

VOID
RECORD_PAGE_EDIT::KeyDown(
    IN HWND WindowHandle
    )
{
    ScrollDown(WindowHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\secedit.cxx ===
#include "ulib.hxx"
#include "secedit.hxx"

extern "C" {
#include <ctype.h>
#include <stdio.h>
}


BOOLEAN
SECTOR_EDIT::Initialize(
    IN  HWND    WindowHandle,
    IN  INT     ClientHeight,
    IN  INT     ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT));
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;
    _edit_nibble = 0;

    if (!VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth)) {
        return FALSE;
    }

    return TRUE;
}


VOID
SECTOR_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;

    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
    InvalidateRect(WindowHandle, NULL, TRUE);
    SetRange(WindowHandle, _size/16);
}


VOID
SECTOR_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    INT     xcoor, ycoor;
    PUCHAR  p;
    TCHAR   buf[10];
    INT     i, j;

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    ycoor = InvalidRect.top/QueryCharHeight()*QueryCharHeight();
    p = (PUCHAR) _buffer;
    for (i = QueryScrollPosition() + InvalidRect.top/QueryCharHeight();
         (unsigned)i < _size/16 && ycoor < InvalidRect.bottom; i++) {

        xcoor = 0;
        swprintf(buf, TEXT("%04X"), i*16);
        TextOut(DeviceContext, xcoor, ycoor, buf, 4);
        xcoor += 6*QueryCharWidth();

        for (j = 0; j < 16; j++) {

            if (j == 8) {
                xcoor += QueryCharWidth();
            }

            swprintf(buf, TEXT("%02X"), p[i*16 + j]);
            TextOut(DeviceContext, xcoor, ycoor, buf, 2);
            xcoor += 3*QueryCharWidth();
        }
        xcoor += QueryCharWidth();

        for (j = 0; j < 16; j++) {
            swprintf(buf, TEXT("%c"), isprint(p[i*16+j]) ? p[i*16+j] : '.');
            TextOut(DeviceContext, xcoor, ycoor, buf, 1);
            xcoor += QueryCharWidth();
        }

        ycoor += QueryCharHeight();
    }

    if (_edit_nibble < ULONG(32*QueryScrollPosition()) ||
        _edit_nibble >=
        ULONG(32*(QueryScrollPosition() + QueryClientHeight()/QueryCharHeight())) ||
        _edit_nibble >= 2*_size) {

        _edit_nibble = min((ULONG)32*QueryScrollPosition(), (ULONG)2*_size - 1);
    }

    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    if (_edit_nibble < 32) {
        return;
    }

    if (_edit_nibble - 32 < ULONG(32*QueryScrollPosition())) {
        ScrollUp(WindowHandle);
    }

    _edit_nibble -= 32;
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    if (_edit_nibble + 32 >= 2*_size) {
        return;
    }

    if (_edit_nibble + 32 >= (ULONG)
        32*(QueryScrollPosition() + QueryClientHeight()/QueryCharHeight())) {

        ScrollDown(WindowHandle);
    }

    _edit_nibble += 32;
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KeyLeft(
    IN  HWND    WindowHandle
    )
{
    if (!_edit_nibble) {
        return;
    }

    if (_edit_nibble == (ULONG)32*QueryScrollPosition()) {
        ScrollUp(WindowHandle);
    }

    _edit_nibble--;
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KeyRight(
    IN  HWND    WindowHandle
    )
{
    if (_edit_nibble + 1 >= 2*_size) {
        return;
    }

    if (_edit_nibble + 1 == (ULONG)
        32*(QueryScrollPosition() + QueryClientHeight()/QueryCharHeight())) {

        ScrollDown(WindowHandle);
    }

    _edit_nibble++;
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::Click(
    IN  HWND    WindowHandle,
    IN  INT     Xcoordinate,
    IN  INT     Ycoordinate
    )
{
    Xcoordinate /= QueryCharWidth();
    Ycoordinate /= QueryCharHeight();

    if (Xcoordinate < 6 || Xcoordinate >= 54 || Xcoordinate % 3 == 2 ||
        Ycoordinate + QueryScrollPosition() >= QueryNumLines()) {
        return;
    }

    _edit_nibble = (Ycoordinate + QueryScrollPosition())*32 +
                   ((Xcoordinate - 6)/3)*2 +
                   ((Xcoordinate % 3 == 1) ? 1 : 0);

    SetCaretToNibble();
}


VOID
SECTOR_EDIT::Character(
    IN  HWND    WindowHandle,
    IN  CHAR    Char
    )
{
    PUCHAR  p;
    UCHAR   nibble;
    BOOLEAN nibble_entered;

    p = (PUCHAR) _buffer;
    if (Char >= '0' && Char <= '9') {
        nibble = Char - '0';
        nibble_entered = TRUE;
    } else if (Char >= 'a' && Char <= 'f') {
        nibble = Char - 'a' + 10;
        nibble_entered = TRUE;
    } else {
        nibble_entered = FALSE;
    }

    if (nibble_entered) {
        if (_edit_nibble%2 == 0) {
            nibble = (nibble << 4);
            p[_edit_nibble/2] &= 0x0F;
            p[_edit_nibble/2] |= nibble;
        } else {
            p[_edit_nibble/2] &= 0xF0;
            p[_edit_nibble/2] |= nibble;
        }
    }

    InvalidateNibbleRect(WindowHandle);
    _edit_nibble++;
    if (_edit_nibble >= _size*2) {
        _edit_nibble--;
    }
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::SetFocus(
    IN  HWND    WindowHandle
    )
{
    EDIT_OBJECT::SetFocus(WindowHandle);

    if (!_size || !_buffer) {
        return;
    }

    CreateCaret(WindowHandle, NULL, QueryCharWidth(), QueryCharHeight());
    ShowCaret(WindowHandle);
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KillFocus(
    IN  HWND    WindowHandle
    )
{
    if (!_size || !_buffer) {
        return;
    }

    HideCaret(WindowHandle);
    DestroyCaret();
}


VOID
SECTOR_EDIT::SetCaretToNibble(
    )
{
    ULONG   byte_num;
    BOOLEAN high_byte;
    ULONG   x, y;

    if (!_buffer || !_size) {
        return;
    }

    byte_num = _edit_nibble/2;
    high_byte = (_edit_nibble%2 == 0);

    x = (byte_num%16)*3*QueryCharWidth() + 6*QueryCharWidth() +
        (high_byte ? 0 : QueryCharWidth());

    if (byte_num % 16 > 7)
        x += QueryCharWidth();

    y = (byte_num/16 - QueryScrollPosition())*QueryCharHeight();

    SetCaretPos(x, y);
}


VOID
SECTOR_EDIT::InvalidateNibbleRect(
    IN  HWND    WindowHandle
    )
{
    RECT    rect;
    ULONG   byte_num;

    byte_num = _edit_nibble/2;

    rect.left = 0;
    rect.top = (byte_num/16 - QueryScrollPosition())*QueryCharHeight();
    rect.right = 84*QueryCharWidth();
    rect.bottom = rect.top + QueryCharHeight();

    InvalidateRect(WindowHandle, &rect, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\rootio.cxx ===
#include "ulib.hxx"
#include "rootio.hxx"
#include "diskedit.h"
#include "rfatsa.hxx"

extern "C" {
#include <stdio.h>
}


BOOLEAN
ROOT_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    REAL_FAT_SA             fatsa;
    MESSAGE                 msg;

    _drive = Drive;

    *Error = TRUE;

    if (!_drive ||
        !fatsa.Initialize(_drive, &msg) ||
        !fatsa.FAT_SA::Read() ||
        !_rootdir.Initialize(Mem, _drive,
                             fatsa.QueryReservedSectors() +
                             fatsa.QueryFats() * fatsa.QuerySectorsPerFat(),
                             fatsa.QueryRootEntries())) {

        return FALSE;
    }

    _buffer = _rootdir.GetDirEntry(0);
    _buffer_size = ((BytesPerDirent*fatsa.QueryRootEntries() - 1)/
                     _drive->QuerySectorSize() + 1)*_drive->QuerySectorSize();

    wsprintf(_header_text, TEXT("DiskEdit - Root Directory"));

    return TRUE;
}


BOOLEAN
ROOT_IO::Read(
    OUT PULONG  pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }
    if (!_rootdir.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
ROOT_IO::Write(
    )
{
    return _drive ? _rootdir.Write() : FALSE;
}


PVOID
ROOT_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _buffer_size;
    }

    return _buffer;
}


PTCHAR
ROOT_IO::GetHeaderText(
    )
{
    return _header_text;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\secstr.cxx ===
#include "ulib.hxx"
#include "untfs.hxx"
#include "secstr.hxx"
#include "frsstruc.hxx"
#include "ntfssa.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"

extern "C" {
#include <stdio.h>
}

///////////////////////////////////////////////////////////////////////////////
//  Security stream support                                                  //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
SECURITY_STREAM_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}


VOID
SECURITY_STREAM_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}

VOID
SECURITY_STREAM_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
SECURITY_STREAM_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}

VOID
SECURITY_STREAM_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    TCHAR buf[1024];

    if (!_buffer || !_size) {
        return;
    }

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));


    //
    //  While there are more windows to dump
    //

    PVOID CurrentWindow = _buffer;
    INT CurrentLine = 0;

    while ((PCHAR)CurrentWindow < (PCHAR)_buffer + _size) {

        //
        //  Dump window
        //

        PSECURITY_DESCRIPTOR_HEADER Header = (PSECURITY_DESCRIPTOR_HEADER) CurrentWindow;

        while ((PBYTE)Header < (PBYTE)CurrentWindow + 256 * 1024 &&
               Header->HashKey.SecurityId != SECURITY_ID_INVALID) {

            swprintf( buf, TEXT( "%08x: Hash %08x  SecurityId %08x  Offset %016I64x  Length %08x" ),
                      (PCHAR)Header - (PCHAR)_buffer,
                      Header->HashKey.Hash, Header->HashKey.SecurityId,
                      Header->Offset, Header->Length );
            WriteLine( DeviceContext, CurrentLine++, buf );

            Header = (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE)Header + ((Header->Length + 15) & ~15));
        }

        //
        //  Dump mirror
        //

        Header = (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE) CurrentWindow + 256 * 1024);

        while ((PBYTE)Header < (PBYTE)_buffer + _size &&
               (PBYTE)Header < (PBYTE)CurrentWindow + 512 * 1024 &&
               Header->HashKey.SecurityId != SECURITY_ID_INVALID) {

            swprintf( buf, TEXT( "%08x: Hash %08x  SecurityId %08x  Offset %016I64x  Length %08x" ),
                      (PCHAR)Header - (PCHAR)_buffer,
                      Header->HashKey.Hash, Header->HashKey.SecurityId,
                      Header->Offset, Header->Length );
            WriteLine( DeviceContext, CurrentLine++, buf );

            Header = (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE)Header + ((Header->Length + 15) & ~15));
        }

        //
        //  Advance to next block
        //

        CurrentWindow = (PVOID) ((PBYTE)CurrentWindow + 512 * 1024);
    }

    SetRange(WindowHandle, CurrentLine + 50);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\secio.cxx ===
#include "ulib.hxx"
#include "secio.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

STATIC ULONG StartSector = 0;
STATIC ULONG NumSectors = 0;


BOOLEAN
SECTOR_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    FARPROC proc;

    proc = MakeProcInstance((FARPROC) ReadSectors, Application);
    if (!DialogBox((HINSTANCE)Application, TEXT("ReadSectorsBox"),
                   WindowHandle, (DLGPROC) proc)) {
        *Error = FALSE;
        return FALSE;
    }
    FreeProcInstance(proc);

    *Error = TRUE;

    _drive = Drive;

    if (!NumSectors || !_drive) {
        return FALSE;
    }

    if (!_secrun.Initialize(Mem, _drive, StartSector, NumSectors)) {
        return FALSE;
    }

    swprintf(_header_text, TEXT("DiskEdit - Sector 0x%X for 0x%X"),
        StartSector, NumSectors);

    return TRUE;
}


BOOLEAN
SECTOR_IO::Read(
    OUT PULONG  pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }
    if (!_secrun.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
SECTOR_IO::Write(
    )
{
    return _drive ? _secrun.Write() : FALSE;
}


PVOID
SECTOR_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _drive ? (_drive->QuerySectorSize()*_secrun.QueryLength()) : 0;
    }

    return _secrun.GetBuf();
}


PTCHAR
SECTOR_IO::GetHeaderText(
    )
{
    return _header_text;
}


BOOL
ReadSectors(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {

            TCHAR buf[1024];
            INT n;

            n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            swscanf(buf, TEXT("%x"), &StartSector);

            n = GetDlgItemText(hDlg, IDTEXT2, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            swscanf(buf, TEXT("%x"), &NumSectors);

            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\restarea.cxx ===
#include "ulib.hxx"
#include "drive.hxx"
#include "untfs.hxx"
#include "restarea.hxx"

extern "C" {
#include <stdio.h>
}

BOOLEAN
RESTART_AREA_EDIT::Initialize(
    IN      HWND    WindowHandle,
    IN      INT     ClientHeight,
    IN      INT     ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  tm;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &tm);
    ReleaseDC(WindowHandle, hdc);

    if (!VERTICAL_TEXT_SCROLL::Initialize(
        WindowHandle,
        0,
        ClientHeight,
        ClientWidth,
        tm.tmExternalLeading + tm.tmHeight,
        tm.tmMaxCharWidth
        )) {
        return FALSE;
    }

    return TRUE;
}


VOID
RESTART_AREA_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetRange(WindowHandle, _size/2);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
RESTART_AREA_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PLFS_RESTART_PAGE_HEADER pRestPageHeader;
    PLFS_RESTART_AREA       pRestArea;
    PLFS_CLIENT_RECORD      pClientRecord;
    TEXTMETRIC              tm;
    INT                     ch, CurrentLine;
    TCHAR                   buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, _size/2, FALSE);
    SetScrollPos(WindowHandle, SB_VERT, QueryScrollPosition(), TRUE);

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || _size < 512) {
        return;
    }

    GetTextMetrics(DeviceContext, &tm);
    ch = tm.tmExternalLeading + tm.tmHeight;
    CurrentLine = 0;

    pRestPageHeader = (PLFS_RESTART_PAGE_HEADER)_buffer;

    swprintf(buf, TEXT("MultiSectorHeader.Signature: \t\t\t%c%c%c%c"),
        pRestPageHeader->MultiSectorHeader.Signature[0],
        pRestPageHeader->MultiSectorHeader.Signature[1],
        pRestPageHeader->MultiSectorHeader.Signature[2],
        pRestPageHeader->MultiSectorHeader.Signature[3]);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("MultiSectorHeader.UpdateSequenceArrayOffset: \t%u"),
        pRestPageHeader->MultiSectorHeader.UpdateSequenceArrayOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("MultiSectorHeader.UpdateSequenceArraySize: \t%x"),
        pRestPageHeader->MultiSectorHeader.UpdateSequenceArraySize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ChkDskLsn: \t%x:%x"),
        pRestPageHeader->ChkDskLsn.HighPart,
        pRestPageHeader->ChkDskLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("SystemPageSize: %x"), pRestPageHeader->SystemPageSize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LogPageSize: \t%x"), pRestPageHeader->LogPageSize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RestartOffset: \t%x"), pRestPageHeader->RestartOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("MinorVersion: \t%d"), pRestPageHeader->MinorVersion);
    WriteLine(DeviceContext, CurrentLine++, buf);
    swprintf(buf, TEXT("MajorVersion: \t%d"), pRestPageHeader->MajorVersion);
    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentLine++;

    pRestArea = PLFS_RESTART_AREA(PUCHAR(_buffer) + pRestPageHeader->RestartOffset);

    swprintf(buf, TEXT("CurrentLsn: \t\t%x:%x"), pRestArea->CurrentLsn.HighPart,
        pRestArea->CurrentLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LogClients: \t\t%x"), pRestArea->LogClients);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientFreeList: \t%x"), pRestArea->ClientFreeList);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientInUseList: \t%x"), pRestArea->ClientInUseList);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Flags: \t\t\t%x"), pRestArea->Flags);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("SeqNumberBits: \t\t%x"), pRestArea->SeqNumberBits);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RestartAreaLength: \t%x"), pRestArea->RestartAreaLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientArrayOffset: \t%x"), pRestArea->ClientArrayOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("FileSize: \t\t%x"), pRestArea->FileSize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LastLsnDataLength: \t%x"), pRestArea->LastLsnDataLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RecordHeaderLength: \t%x"), pRestArea->RecordHeaderLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LogPageDataOffset: \t%x"), pRestArea->LogPageDataOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    for (INT i = 0; i < pRestArea->LogClients; ++i) {

        CurrentLine++;

        swprintf(buf, TEXT("CLIENT \t%d"), i);
        WriteLine(DeviceContext, CurrentLine++, buf);

        pClientRecord = &pRestArea->LogClientArray[i];

        swprintf(buf, TEXT("    OldestLsn: \t\t%x:%x"),
            pClientRecord->OldestLsn.HighPart,
            pClientRecord->OldestLsn.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    ClientRestartLsn: \t%x:%x"),
            pClientRecord->ClientRestartLsn.HighPart,
            pClientRecord->ClientRestartLsn.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    PrevClient: \t%x"), pClientRecord->PrevClient);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    NextClient: \t%x"), pClientRecord->NextClient);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    SeqNumber: \t\t%x"), pClientRecord->SeqNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    ClientName: \t"));
        INT x = wcslen(buf);

        for (ULONG j = 0; j < pClientRecord->ClientNameLength; ++j) {
            buf[j + x] = (TCHAR)pClientRecord->ClientName[j];
        }
        WriteLine(DeviceContext, CurrentLine++, buf);
    }
}

VOID
RESTART_AREA_EDIT::KeyUp(
    IN HWND WindowHandle
    )
{
    ScrollUp(WindowHandle);
}

VOID
RESTART_AREA_EDIT::KeyDown(
    IN HWND WindowHandle
    )
{
    ScrollDown(WindowHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\sources.inc ===
!IF 0

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=diskedit
TARGETPATH=obj
TARGETTYPE=PROGRAM

INCLUDES= \
    $(SDK_INC_PATH)\port1632;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\untfs\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    ..;\
    $(DDK_INC_PATH)

C_DEFINES= -DWIN32 -DUNICODE -D_UNICODE

SOURCES=                   \
        ..\attrio.cxx      \
        ..\chainio.cxx     \
        ..\clusio.cxx      \
        ..\crack.cxx       \
        ..\diskedit.cxx    \
        ..\edit.cxx        \
        ..\fileio.cxx      \
        ..\frsedit.cxx     \
        ..\frsio.cxx       \
        ..\gptedit.cxx     \
        ..\indxedit.cxx    \
        ..\io.cxx          \
        ..\rootio.cxx      \
        ..\secedit.cxx     \
        ..\secio.cxx       \
        ..\vscroll.cxx     \
        ..\bootedit.cxx    \
        ..\nbedit.cxx      \
        ..\partedit.cxx    \
        ..\recordpg.cxx    \
        ..\restarea.cxx    \
        ..\logreced.cxx    \
        ..\logrecio.cxx    \
        ..\atrlsted.cxx    \
        ..\secstr.cxx      \
        ..\res.rc

USE_MSVCRT=1

UMENTRY=winmain
UMTYPE=windows
TARGETLIBS= \
    $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(PROJECT_ROOT)\fs\utils\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(PROJECT_ROOT)\fs\utils\untfs\src\$(ALT_PROJECT)\$(O)\untfs.lib \
    $(PROJECT_ROOT)\fs\utils\ufat\src\$(ALT_PROJECT)\$(O)\ufat.lib \
    $(SDK_LIB_PATH)\ntdll.lib

W32_SB=1
SOURCES_USED=..\sources.inc

PRECOMPILED_INCLUDE=..\ulib.hxx
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\vscroll.cxx ===
#include "ulib.hxx"
#include "vscroll.hxx"

BOOLEAN
VERTICAL_TEXT_SCROLL::Initialize(
    IN  HWND    WindowHandle,
    IN  INT     NumLines,
    IN  INT     ClientHeight,
    IN  INT     ClientWidth,
    IN  INT     CharHeight,
    IN  INT     CharWidth
    )
{
    _client_height = ClientHeight;
    _client_width = ClientWidth;
    _char_height = CharHeight;
    _char_width = CharWidth;
    _scroll_position = 0;
    return TRUE;
}


VOID
VERTICAL_TEXT_SCROLL::SetRange(
    IN  HWND    WindowHandle,
    IN  INT     NumLines
    )
{
    _num_lines = NumLines - _client_height/_char_height;
    SetScrollRange(WindowHandle, SB_VERT, 0, _num_lines, FALSE);
}


VOID
VERTICAL_TEXT_SCROLL::ClientSize(
    IN  INT Height,
    IN  INT Width
    )
{
    _client_height = Height;
    _client_width = Width;
}


VOID
VERTICAL_TEXT_SCROLL::ScrollUp(
    IN  HWND    WindowHandle
    )
{
    _scroll_position--;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::ScrollDown(
    IN  HWND    WindowHandle
    )
{
    _scroll_position++;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::PageUp(
    IN  HWND    WindowHandle
    )
{
    _scroll_position -= _client_height/_char_height;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::PageDown(
    IN  HWND    WindowHandle
    )
{
    _scroll_position += _client_height/_char_height;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::ThumbPosition(
    IN  HWND    WindowHandle,
    IN  INT     NewThumbPosition
    )
{
    _scroll_position = NewThumbPosition;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::UpdateScrollPosition(
    IN  HWND    WindowHandle
    )
{
    INT current_pos;

    current_pos = GetScrollPos(WindowHandle, SB_VERT);
    _scroll_position = max(0, min(_scroll_position, _num_lines));

    if (_scroll_position != current_pos) {
        SetScrollPos(WindowHandle, SB_VERT, _scroll_position, TRUE);
        ScrollWindow(WindowHandle, 0,
                     QueryCharHeight()*(current_pos - _scroll_position),
                     NULL, NULL);
        UpdateWindow(WindowHandle);
    }
}

STATIC TCHAR buf[1024];

VOID
VERTICAL_TEXT_SCROLL::WriteLine(
    IN      HDC     DeviceContext,
    IN      INT     LineNumber,
    IN      PTCHAR   String
    )
{
    if( LineNumber >= QueryScrollPosition() &&
        LineNumber <= QueryScrollPosition() + QueryClientHeight()/QueryCharHeight() + 1) {

        CONST INT tabstop = 8;
        INT pos, bufpos;
    
        //
        // Copy string into buf, expanding tabs into spaces as we go.  This
        // is because the window to which we are displaying does not do tabs.
        //
    
        for (pos = 0, bufpos = 0; String[pos] != '\0'; ++pos) {
            if ('\t' == String[pos]) {
                do {
                    buf[bufpos++] = ' ';
                } while (0 != bufpos % tabstop);
    
                continue;
            }
    
            buf[bufpos++] = String[pos];
        }
        buf[bufpos++] = '\0';
    
        TextOut( DeviceContext,
                 0,
                 (LineNumber - QueryScrollPosition())*QueryCharHeight(),
                 buf,
                 wcslen( buf ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\doskey\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=doskey
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\doskey.cxx ..\doskey.rc

INCLUDES=..\..\ulib\inc;\
    $(WINDOWS_INC_PATH)

C_DEFINES=/DUNICODE=1

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\kernl32p.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\driverquery\pch.h ===
// *********************************************************************************
// 
//  Copyright (c)  Microsoft Corporation
//  
//  Module Name:
//  
// 	  pch.h
//  
//  Abstract:
//  
// 	  This module contains all necessary header files required by DriverQuery.cpp module.
// 	
//  
//  Author:
//  
// 	  J.S.Vasu	 31-Oct-2000
//  
//  Revision History:
//   Created  on 31-0ct-2000 by J.S.Vasu
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H


#pragma once		// include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <Security.h>
#include <SecExt.h>


//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <dbghelp.h>
#include <psapi.h>


#ifndef _WIN64
	#include <Wow64t.h>
#endif 


//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
#include <crtdbg.h>


//
// private Common header files
//
#include "cmdline.h"

#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\driverquery\connectwmi.cpp ===
//**********************************************************************************
//  Copyright (c)  Microsoft Corporation
//  
//  Module Name:
//		CONNECTWMI.cpp
//  
//  Abstract:
// 		Contains functions to connect to wmi.
//  
//  Author:
//		J.S.Vasu
//  
//  Revision History:
//		J.S.Vasu  26-sep-2k : Created It.  
// *********************************************************************************

// Include files
#include "pch.h"
#include "resource.h"
#include "driverquery.h"

// error constants
#define E_SERVER_NOTFOUND			0x800706ba

// function prototypes
BOOL IsValidServerEx( LPCWSTR pwszServer,
					  BOOL    &bLocalSystem );

HRESULT GetSecurityArguments( IUnknown *pInterface, 
							  DWORD&   dwAuthorization,
							  DWORD&   dwAuthentication );

HRESULT SetInterfaceSecurity( IUnknown       *pInterface, 
							  LPCWSTR		 pwszServer,
							  LPCWSTR		 pwszUser, 
							  LPCWSTR		 pwszPassword,
							  COAUTHIDENTITY **ppAuthIdentity );

HRESULT WINAPI SetProxyBlanket( IUnknown  *pInterface,
							    DWORD	  dwAuthnSvc,
								DWORD	  dwAuthzSvc,
								LPWSTR	  pwszPrincipal,
								DWORD	  dwAuthLevel,
								DWORD	  dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
								DWORD	  dwCapabilities );

HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser,
									  LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain,
									  COAUTHIDENTITY **ppAuthIdent );

BOOL ConnectWmi( IWbemLocator   *pLocator, 
				 IWbemServices  ** ppServices, 
				 LPCWSTR		pwszServer,
				 LPCWSTR		pwszUser,
				 LPCWSTR		pwszPassword, 
				 COAUTHIDENTITY **ppAuthIdentity, 
				 BOOL			bCheckWithNullPwd = FALSE, 
				 LPCWSTR		pwszNamespace = CIMV2_NAME_SPACE,
				 HRESULT		*phr = NULL,
				 BOOL			*pbLocalSystem = NULL );

VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY  **ppAuthIdentity );

// ***************************************************************************
// Routine Description: 
//		Checks whether the server name is a valid server name or not.
//		  
// Arguments:
//		pwszServer [in]       - Server name to be validated.
//		bLocalSystem [in/out] - Set to TRUE if server specified is local system.
//
// Return Value: 
//		TRUE if server is valid else FALSE.
// 
// ***************************************************************************
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL &bLocalSystem )
{
	// local variables
	CHString strTemp;
	
	if( pwszServer == NULL )
	{
		return FALSE;
	}

	bLocalSystem = FALSE;

	// get a local copy
	strTemp = pwszServer;

	// remove the forward slashes (UNC) if exist in the begining of the server name
	if ( IsUNCFormat( strTemp ) == TRUE )
	{
		strTemp = strTemp.Mid( 2 );
		if ( strTemp.GetLength() == 0 )
			return FALSE;
	}

	// now check if any '\' character appears in the server name. If so error
	if ( strTemp.Find( L'\\' ) != -1 )
		return FALSE;

	// now check if server name is '.' only which represent local system in WMI
	// else determine whether this is a local system or not
	bLocalSystem = TRUE;
	if ( strTemp.CompareNoCase( L"." ) != 0 )
	{
		// validate the server
		if ( IsValidServer( strTemp ) == FALSE )
			return FALSE;

		// check whether this is a local system or not
		bLocalSystem = IsLocalSystem( strTemp );
	}

	// valid server name
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Connects to wmi.
//		  
// Arguments:
//		pLocator [in]           - Pointer to the IWbemLocator object.
//		ppServices [out]        - Pointer to IWbemServices object.
//		pwszServer [in]         - Holds the server name to connect to.
//		pwszUser [in/out]       - Holds the user name.
//		pwszPassword [in/out]   - Holds the password.
//		ppAuthIdentity [in/out] - Pointer to authentication structure.
//		bCheckWithNullPwd [in]  - Specifies whether to connect through null password.
//		pwszNamespace [in]		- Specifies the namespace to connect to.
//		phRes [in/out]          - Holds the error value.
//		pbLocalSystem [in/out]  - Holds the boolean value to represent whether the server
//								  name is local or not.
// Return Value:
//		TRUE if successfully connected, FALSE if not.
// ***************************************************************************
BOOL ConnectWmi( IWbemLocator *pLocator, IWbemServices **ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY **ppAuthIdentity, 
				 BOOL bCheckWithNullPwd, LPCWSTR pwszNamespace, HRESULT *phRes,
				 BOOL *pbLocalSystem )
{
	// local variables
	HRESULT hRes = 0;
	BOOL bResult = FALSE;
	BOOL bLocalSystem = FALSE;
	_bstr_t bstrServer;
	_bstr_t bstrNamespace;
	_bstr_t bstrUser;
	_bstr_t	bstrPassword;

	if ( pbLocalSystem != NULL )
	{
		*pbLocalSystem = FALSE;
	}

	if ( phRes != NULL )
	{
		*phRes = NO_ERROR;
	}

	try
	{
		// clear the error
		SetLastError( WBEM_S_NO_ERROR );

		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// check whether locator object exists or not if not return FALSE
		if ( pLocator == NULL )
		{
			if ( phRes != NULL )
			{
				*phRes = WBEM_E_INVALID_PARAMETER;
			}

			// return failure
			return FALSE;
		}

		// validate the server name
		// NOTE: The error being raised in custom define for '0x800706ba' value
		//       The message that will be displayed in "The RPC server is unavailable."
		if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
		{
			_com_issue_error( ERROR_BAD_NETPATH );
		}

		// validate the user name
		if ( IsValidUserEx( pwszUser ) == FALSE )
		{
			_com_issue_error( ERROR_NO_SUCH_USER );
		}

		// prepare namespace
		bstrNamespace = pwszNamespace;				// name space
		if ( pwszServer != NULL && bLocalSystem == FALSE )
		{
			// get the server name
			bstrServer = pwszServer;

			// prepare the namespace
			// NOTE: check for the UNC naming format of the server and do
			if ( IsUNCFormat( pwszServer ) == TRUE )
			{
				bstrNamespace = bstrServer + L"\\" + pwszNamespace;
			}
			else
			{
				bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
			}

			// user credentials
			if ( pwszUser != NULL && lstrlen( pwszUser ) != 0 )
			{
				// copy the user name
				bstrUser = pwszUser;

				// if password is empty string and if we need to check with
				// null password, then do not set the password and try
				bstrPassword = pwszPassword;
				if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
				{
					bstrPassword = (LPWSTR) NULL;
				}
			}
		}

		// release the existing services object ( to be in safer side )
		SAFE_RELEASE( *ppServices );

		// connect to the remote system's WMI
		// there is a twist here ... 
		// do not trap the ConnectServer function failure into exception
		// instead handle that action manually
		// by default try the ConnectServer function as the information which we have
		// in our hands at this point. If the ConnectServer is failed, 
		// check whether password variable has any contents are not ... if no contents
		// check with "" (empty) password ... this might pass in this situation ..
		// if this call is also failed ... nothing is there that we can do ... throw the exception
		hRes = pLocator->ConnectServer( bstrNamespace, 
			bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
		if ( FAILED( hRes ) )
		{
			//
			// special case ...
	
			// check whether password exists or not
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'

			if ( hRes == E_ACCESSDENIED )
			{
				// check if we tried to connect to the system using null password
				// if so, then try connecting to the remote system with empty string
				if ( bCheckWithNullPwd == TRUE &&
					 bstrUser.length() != 0 && bstrPassword.length() == 0 )
				{
					// now invoke with ...
					hRes = pLocator->ConnectServer( bstrNamespace, 
						bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
				}
			}
			else if ( hRes == WBEM_E_LOCAL_CREDENTIALS )
			{
				// credentials were passed to the local system. 
				// So ignore the credentials and try to reconnect
				bLocalSystem = TRUE;
				bstrUser = (LPWSTR) NULL;
				bstrPassword = (LPWSTR) NULL;
				bstrNamespace = pwszNamespace;				// name space
				hRes = pLocator->ConnectServer( bstrNamespace, 
					NULL, NULL, 0L, 0L, NULL, NULL, ppServices );
				// now check the result again .. if failed
			}
			// now check the result again .. if failed .. ummmm..
			if ( FAILED( hRes ) )
			{
				_com_issue_error( hRes );
			}

			else
			{
				bstrPassword = L"";
			}
		}

		// set the security at the interface level also
		SAFE_EXECUTE( SetInterfaceSecurity( *ppServices, 
			pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

		// connection to WMI is successful
		bResult = TRUE;

		// save the hr value if needed by the caller
		if ( phRes != NULL )
		{
			*phRes = WBEM_S_NO_ERROR;
		}
	}
	catch( _com_error& e )
	{
		// save the error
		WMISaveError( e );

		// save the hr value if needed by the caller
		if ( phRes != NULL )
		{
			*phRes = e.Error();
		}
	}

	if ( pbLocalSystem != NULL )
	{
		*pbLocalSystem = bLocalSystem;
	}

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		Connects to wmi.
//		  
// Arguments:
//		pLocator [in]           - Pointer to the IWbemLocator object.
//		ppServices [out]        - Pointer to IWbemServices object.
//		strServer [in]          - Holds the server name to connect to.
//		strUserName [in/out]    - Holds the user name.
//		strPassword [in/out]    - Holds the password.
//		ppAuthIdentity [in/out] - Pointer to authentication structure.
//		bNeedPassword [in]		- Specifies whether to prompt for password.
//		pwszNamespace [in]		- Specifies the namespace to connect to.
//		pbLocalSystem [in/out]  - Holds the boolean value to represent whether the server
//								  name is local or not.
// Return Value:
//		TRUE if successfully connected, FALSE if not.
// ***************************************************************************
BOOL ConnectWmiEx( IWbemLocator  *pLocator, 
				   IWbemServices **ppServices,
				   const CHString &strServer, CHString &strUserName, CHString &strPassword, 
				   COAUTHIDENTITY **ppAuthIdentity, BOOL bNeedPassword, LPCWSTR pwszNamespace,
				   BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hRes = 0;
	DWORD dwSize = 0;
	BOOL bResult = FALSE;
	LPWSTR pwszPassword = NULL;
	CHString strBuffer = NULL_STRING;
	__MAX_SIZE_STRING szBuffer = NULL_STRING;

	// clear the error .. if any
	SetLastError( WBEM_S_NO_ERROR );

	// sometime users want the utility to prompt for the password
	// check what user wants the utility to do
	if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password
		// so skip this part and let the flow directly jump the password acceptance part
	}
	else
	{
		// try to establish connection to the remote system with the credentials supplied
		if ( strUserName.GetLength() == 0 )
		{
			// user name is empty
			// so, it is obvious that password will also be empty
			// even if password is specified, we have to ignore that
			bResult = ConnectWmi( pLocator, ppServices, 
				strServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hRes, pbLocalSystem );
		}
		else
		{
			// credentials were supplied
			// but password might not be specified ... so check and act accordingly
			LPCWSTR pwszTemp = NULL;
			if ( bNeedPassword == FALSE )
				pwszTemp = strPassword;

			// ...
			bResult = ConnectWmi( pLocator, ppServices, strServer,
				strUserName, pwszTemp, ppAuthIdentity, FALSE, pwszNamespace, &hRes, pbLocalSystem );
		}

		// check the result ... if successful in establishing connection ... return
		if ( bResult == TRUE )
			return TRUE;

		// now check the kind of error occurred
		switch( hRes )
		{
			case E_ACCESSDENIED:
				break;
		
			case WBEM_E_LOCAL_CREDENTIALS:
				 // needs to do special processing
				 break;

 			case WBEM_E_ACCESS_DENIED:

			default:
				 GetWbemErrorText( hRes );
				 DISPLAY_MESSAGE( stderr, ERROR_TAG );
				 DISPLAY_MESSAGE( stderr, GetReason() );
				 return( FALSE );		// no use of accepting the password .. return failure
		}

		// if failed in establishing connection to the remote terminal
		// even if the password is specifed, then there is nothing to do ... simply return failure
		if ( bNeedPassword == FALSE )
		{
			GetWbemErrorText( hRes );
			DISPLAY_MESSAGE( stderr, ERROR_TAG );
			DISPLAY_MESSAGE( stderr, GetReason() );
			return FALSE;
		}
	}

	// check whether user name is specified or not
	// if not, get the local system's current user name under whose credentials, the process
	// is running
	if ( strUserName.GetLength() == 0 )
	{
		// sub-local variables
		LPWSTR pwszUserName = NULL;

		try
		{
			// get the required buffer
			pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			DISPLAY_MESSAGE( stderr, ERROR_TAG );
			ShowLastError( stderr );
			return FALSE;
		}

		// get the user name

	        _TCHAR  szUserName[MAX_RES_STRING];
		ULONG ulLong = MAX_RES_STRING;
		if ( GetUserNameEx ( NameSamCompatible, szUserName , &ulLong)== FALSE )
		{
			// error occured while trying to get the current user info
			SaveLastError();
			DISPLAY_MESSAGE( stderr, ERROR_TAG );
			ShowLastError( stderr );
			return FALSE;
		}
		
		lstrcpy(pwszUserName,szUserName);
		// format the user name
		if ( _tcschr( pwszUserName, _T( '\\' ) ) == NULL )
		{
			// server not present in user name ... prepare ... this is only for display purpose
			FORMAT_STRING2( szBuffer, _T( "%s\\%s" ), strServer, szUserName );
			lstrcpy( pwszUserName, szBuffer );
		}

		// release the extra buffer allocated
		strUserName.ReleaseBuffer();
	}

	try
	{
		// get the required buffer
		pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		DISPLAY_MESSAGE( stderr, ERROR_TAG );
		ShowLastError( stderr );
		return FALSE;
	}

	// accept the password from the user
	strBuffer.Format( INPUT_PASSWORD, strUserName );
	WriteConsoleW( GetStdHandle( STD_ERROR_HANDLE ), 
				   strBuffer, strBuffer.GetLength(), &dwSize, NULL );
	GetPassword( pwszPassword, MAX_PASSWORD_LENGTH );

	// release the buffer allocated for password
	strPassword.ReleaseBuffer();

	// now again try to establish the connection using the currently
	// supplied credentials
	bResult = ConnectWmi( pLocator, ppServices, strServer,
		strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, &hRes, pbLocalSystem );

	if( bResult == FALSE )
	{
		 GetWbemErrorText( hRes );
		 DISPLAY_MESSAGE( stderr, ERROR_TAG );
		 DISPLAY_MESSAGE( stderr, GetReason() );
		 return( FALSE );		// no use of accepting the password .. return failure
	}
	// return the success
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		Gets the security arguments for an interface.
//
// Arguments:
//		pInterface [in]           - Pointer to interface stucture.
//		dwAuthorization [in/out]  - Holds Authorization value.
//		dwAuthentication [in/out] - Holds the Authentication value.
//  
// Return Value:
//		Returns HRESULT value. 
// ***************************************************************************
HRESULT GetSecurityArguments( IUnknown *pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication )
{
	// local variables
	HRESULT hRes = 0;
	DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
	IClientSecurity *pClientSecurity = NULL;

	if(pInterface == NULL)
	{
		return  WBEM_E_INVALID_PARAMETER; ;
	}
	// try to get the client security services values if possible
	hRes = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
	if ( SUCCEEDED( hRes ) )
	{
		// got the client security interface
		// now try to get the security services values
		hRes = pClientSecurity->QueryBlanket( pInterface, 
			&dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
		if ( SUCCEEDED( hRes ) )
		{
			// we've got the values from the interface
			dwAuthentication = dwAuthnSvc;
			dwAuthorization = dwAuthzSvc;
		}

		// release the client security interface
		SAFEIRELEASE( pClientSecurity );
	}

	// return always success
	return S_OK;
}


// ***************************************************************************
// Routine Description:
//		Sets the interface security for the interface.	
//		  
// Arguments:
//		pInterface [in]  - pointer to the interface.
//		pAuthIdentity [in] - pointer to authentication structure.
//
// Return Value:
//		returns HRESULT value. 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown *pInterface, COAUTHIDENTITY *pAuthIdentity )
{
	// local variables
	HRESULT hRes;
	LPWSTR pwszDomain = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

	// set the security information to the interface
	hRes = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

	// return the result
	return hRes;
}

// ***************************************************************************
// Routine Description:
//		Sets proxy blanket for the interface.
//		  
// Arguments:
//		pInterface [in]     - pointer to the inteface.
//		dwAuthnsvc [in]     - Authentication service to use.
//		dwAuthzSvc [in]     - Authorization service to use.
//		pwszPricipal [in]   - Server principal name to use with the authentication service.
//		dwAuthLevel [in]    - Authentication level to use.
//		dwImpLevel [in]     - Impersonation level to use.
//		pAuthInfo	[in]    - Identity of the client.
//		dwCapabilities [in] - Capability flags.
//  
// Return Value:
//		Return HRESULT value.
// 
// ***************************************************************************
HRESULT WINAPI SetProxyBlanket( IUnknown *pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities )
{
	// local variables
	HRESULT hRes;
    IUnknown *pUnknown = NULL;
    IClientSecurity *pClientSecurity = NULL;

	if( pInterface == NULL )
	{
		return  WBEM_E_INVALID_PARAMETER;
	}

	// get the IUnknown interface ... to check whether this is a valid interface or not
    hRes = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hRes != S_OK )
	{
        return hRes;
	}

	// now get the client security interface
    hRes = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hRes != S_OK )
    {
        SAFEIRELEASE( pUnknown );
        return hRes;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
        pAuthInfo = NULL;

	// now set the security
    hRes = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
		dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

	// release the security interface
	SAFEIRELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hRes = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hRes == S_OK )
        {
			// set security authentication
            hRes = pClientSecurity->SetBlanket( 
				pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal, 
				dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

			// release
            SAFEIRELEASE( pClientSecurity );
        }
        else if ( hRes == E_NOINTERFACE )
            hRes = S_OK;		// ignore no interface errors
    }

	// release the IUnknown
	SAFEIRELEASE( pUnknown );

	// return the result
    return hRes;
}

// ***************************************************************************
// Routine Description:
//		Allocate memory for authentication variables.
//		  
// Arguments:
//		pwszUser [in/out]     - User name.
//		pwszPassword [in/out] - Password.
//		pwszDomain [in/out]   - Domain name.
//		ppAuthIdent [in/out]  - Poointer to authentication structure.
//  
// Return Value:
//		Returns HRESULT value.
// ***************************************************************************
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY **ppAuthIdent )
{
	// local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

	// validate the input parameter
    if ( ppAuthIdent == NULL )
        return WBEM_E_INVALID_PARAMETER;

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
        return WBEM_E_OUT_OF_MEMORY;

	// init with 0's
    ZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

	//
	// Allocate needed memory and copy in data.  Cleanup if anything goes wrong

	// user
    if ( pwszUser != NULL )
    {
		// allocate memory for user
		LONG lLength = wcslen( pwszUser ); 
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
		if ( pAuthIdent->User == NULL )
		{
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        wcscpy( pAuthIdent->User, pwszUser );
    }

	// domain
    if ( pwszDomain != NULL )
    {
		// allocate memory for domain
		LONG lLength = wcslen( pwszDomain ); 
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        wcscpy( pAuthIdent->Domain, pwszDomain );
    }

	// passsord
    if ( pwszPassword != NULL )
    {
		// allocate memory for passsord
		LONG lLength = wcslen( pwszPassword ); 
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        wcscpy( pAuthIdent->Password, pwszPassword );
    }

	// type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
	*ppAuthIdent = pAuthIdent;

	// return result
    return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Frees the memory of authentication stucture	variable.
//
// Arguments:
//		ppAuthIdentity [in] - Pointer to authentication structure.
//
// Return Value:
//		none. 
// ***************************************************************************
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
		// free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->User );

		// free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Password );

		// free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Domain );

        // final the structure
		CoTaskMemFree( *ppAuthIdentity );
    }

	// set to NULL
	*ppAuthIdentity = NULL;
}


// ***************************************************************************
// Routine Description: checks if a user name is valid.
//		  
// Arguments: UserName
//  
// Return Value: BOOL
// 
// ***************************************************************************
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
	// local variables
	CHString strUser;

	try
	{
		// get user into local memory
		strUser = pwszUser;

		// user name should not be just '\'
		if ( strUser.CompareNoCase( L"\\" ) == 0 )
			return FALSE;

		// user name should not contain invalid characters
		if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
			return FALSE;
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		return FALSE;
	}

	// user name is valid
	return TRUE;
}




// ***************************************************************************
// Routine Description:
//		Sets interface security.
//		  
// Arguments:
//		pInterface [in]         - Pointer to the interface to which security has to be set.
//		pwszServer [in]         - Holds the server name of the interface.
//		pwszUser [in]           - Holds the user name of the server.
//		pwszPassword [in]       - Hold the password of the user.
//		ppAuthIdentity [in/out] - Pointer to authentication structure.
//
// Return Value:
//		returns HRESULT value. 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity )
{
	// local variables
	HRESULT hr=0;
	CHString strUser;
	CHString strDomain;
	LPCWSTR pwszUserArg = NULL;
	LPCWSTR pwszDomainArg = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// check the authentity strcuture ... if authentity structure is already ready
	// simply invoke the 2nd version of SetInterfaceSecurity
	if ( *ppAuthIdentity != NULL )
	{
		return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
	}

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

    // If we are doing trivial case, just pass in a null authenication structure 
    // for which the current logged in user's credentials will be considered
	if ( pwszUser == NULL && pwszPassword == NULL )
	{
		// set the security
		hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, 
			NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		// return the result
		return hr;
	}

	// parse and find out if the user name contains the domain name
	// if contains, extract the domain value from it
	LONG lPos = -1;
	strDomain = L"";
	strUser = pwszUser;
	if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
	{
		// user name contains domain name ... domain\user format
		strDomain = strUser.Left( lPos );
		strUser = strUser.Mid( lPos + 1 );
	}
	
	// get the domain info if it exists only
	if ( strDomain.GetLength() != 0 )
	{
		pwszDomainArg = strDomain;
	}

	// get the user info if it exists only
	if ( strUser.GetLength() != 0 )
	{
		pwszUserArg = strUser;
	}

	// check if authentication info is available or not ...
	// initialize the security authenication information ... UNICODE VERSION STRUCTURE
	if ( ppAuthIdentity == NULL )
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	else if ( *ppAuthIdentity == NULL )
	{
		hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
		if ( hr != S_OK )
		{
			return hr;
		}
	}

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Gets WMI error description.
//
// Arguments:
//		hResError [in] - Contain error value.
//
// Return Value:
//		none.	
// ***************************************************************************
VOID WMISaveError( HRESULT hResError )
{
	// local variables
	HRESULT hRes;
	CHString strBuffer = NULL_STRING;
	IWbemStatusCodeText *pWbemStatus = NULL;

	// if the error is win32 based, choose FormatMessage to get the message
	switch( hResError )
	{
	case E_ACCESSDENIED:			// Message: "Access Denied"
	case ERROR_NO_SUCH_USER:		// Message: "The specified user does not exist."
		{
			// change the error message to "Logon failure: unknown user name or bad password." 
			if ( hResError == E_ACCESSDENIED )
			{
				hResError = ERROR_LOGON_FAILURE;
			}

			// ...
			SetLastError( hResError );
			SaveLastError();
			return;
		}
	}

	try
	{
		// get the pointer to buffer
		LPWSTR pwszBuffer = NULL;
		pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

		// get the wbem specific status code text
		hRes = CoCreateInstance( CLSID_WbemStatusCodeText, 
			NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, ( LPVOID* ) &pWbemStatus );

		// check whether we got the interface or not
		if ( SUCCEEDED( hRes ) )
		{
			// get the error message
			BSTR bstr = NULL;
			hRes = pWbemStatus->GetErrorCodeText( hResError, 0, 0, &bstr );
			if ( SUCCEEDED( hRes ) )
			{
				// get the error message in proper format
				GetCompatibleStringFromUnicode( bstr, pwszBuffer, MAX_STRING_LENGTH );

				//
				// supress all the new-line characters and add '.' at the end ( if not exists )
				LPWSTR pwszTemp = NULL;
				pwszTemp = wcstok( pwszBuffer, L"\r\n" );
				
				if( pwszTemp == NULL )
				{
					_com_issue_error( WBEM_E_INVALID_PARAMETER );	
				}

				if ( *( pwszTemp + lstrlenW( pwszTemp ) - 1 ) != L'.' )
				{
					lstrcatW( pwszTemp, L"." );
				}

				// free the BSTR
				SysFreeString( bstr );
				bstr = NULL;

				// now release status code interface
				SAFE_RELEASE( pWbemStatus );
			}
			else
			{
				// failed to get the error message ... get the com specific error message
				_com_issue_error( hResError );
			}
		}
		else
		{
			// failed to get the error message ... get the com specific error message
			_com_issue_error( hResError );
		}

		// release the buffer
		strBuffer.ReleaseBuffer();
	}
	catch( _com_error& e )
	{
		try
		{
			// get the error message
			strBuffer.ReleaseBuffer();
			if ( e.ErrorMessage() != NULL )
				strBuffer = e.ErrorMessage();
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}

	// set the reason
	strBuffer += L"\n";
	SetReason( strBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\driverquery\driverquery.cpp ===
// *********************************************************************************
// 
//  Copyright (c)  Microsoft Corporation
//  
//  Module Name:
//  
// 	  DriverQuery.cpp
//  
//  Abstract:
//  
// 	  This modules Queries the information of the various drivers present in the  
//	  system .	
// 	
// 	  Syntax:
// 	  ------
// 	  DriverQuery [-s server ] [-u [domain\]username [-p password]]
// 				  [-fo format ] [-n|noheader  ] [-v]
//  
//  Author:
//  
// 	  J.S.Vasu (vasu.julakanti@wipro.com) 
//  
//  Revision History:
//    
//	  Created  on 31-0ct-2000 by J.S.Vasu
//	  Modified on 9-Dec-2000 by Santhosh Brahmappa Added a new function IsWin64()    
// 	  
//  
// *********************************************************************************
//
#include "pch.h"
#include "Resource.h"
#include "DriverQuery.h"
#include "LOCALE.H"
#include "shlwapi.h"


#ifndef _WIN64
	BOOL IsWin64(void);
	#define countof(x) (sizeof(x) / sizeof((x)[0]))
#endif 

// function prototypes
LCID GetSupportedUserLocale( BOOL& bLocaleChanged );


// ***************************************************************************
// Routine Description:
//		This the entry point to this utility.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//  
// Return Value:
//		0		: If the utility successfully displayed the driver information.
//		1		: If the utility completely failed to display the driver information
//		
// ***************************************************************************
DWORD _cdecl _tmain(DWORD argc,LPCTSTR argv[])
{
	BOOL bResult = FALSE ;
	BOOL bNeedPassword = FALSE ;
	BOOL bUsage = FALSE ;
	BOOL bHeader= FALSE ;
	LPTSTR szUserName  = NULL ;
	LPTSTR szPassword = NULL ;
	LPTSTR szServer  = NULL ;
	
	LPTSTR szTmpUserName  = NULL ;
	LPTSTR szTmpPassword = NULL ;
	LPTSTR szTmpServer  = NULL ;
	
	__MAX_SIZE_STRING szFormat = NULL_STRING ;
	DWORD dwSystemType = 0; 
	HRESULT hQueryResult = S_OK ;
	DWORD dwExitCode = 0;  
	DWORD dwErrCode = 0;
	BOOL bLocalFlag = TRUE ;
	BOOL bLocalSystem = TRUE;
	BOOL bVerbose = FALSE ;
	BOOL bComInitFlag = FALSE ;
	IWbemLocator* pIWbemLocator = NULL ;
	IWbemServices* pIWbemServReg = NULL ;
	LPCTSTR szToken = NULL ;
	COAUTHIDENTITY  *pAuthIdentity = NULL;
	BOOL bFlag = FALSE ;	
	BOOL bSigned = FALSE ;
	_tsetlocale( LC_ALL, _T(""));
	
	
	szServer =  (LPTSTR) malloc ((MAX_STRING_LENGTH) * sizeof(TCHAR));
	szUserName = (LPTSTR) malloc ((MAX_STRING_LENGTH) * sizeof(TCHAR));
	szPassword = (LPTSTR) malloc ((MAX_STRING_LENGTH) * sizeof(TCHAR));

	szTmpUserName = szUserName ;
	szTmpPassword  = szPassword ;
	szTmpServer = szServer ;

	if ((szServer == NULL)||(szUserName == NULL)||(szPassword == NULL))
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		dwExitCode = 1;
		SAFEFREE(szTmpServer);
		SAFEFREE(szTmpUserName);
		SAFEFREE(szTmpPassword);

		ReleaseGlobals();
		return(dwExitCode);
	}


	memset(szServer,0,MAX_STRING_LENGTH*sizeof(TCHAR));
	memset(szUserName,0,MAX_STRING_LENGTH*sizeof(TCHAR));
	memset(szPassword,0,MAX_STRING_LENGTH*sizeof(TCHAR));



	bResult = ProcessOptions(argc,argv,&bUsage,&szServer,&szUserName,&szPassword,szFormat,
							&bHeader,&bNeedPassword,&bVerbose,&bSigned);


	
	if(bResult == FALSE)
	{
		
		ShowMessage(stderr,GetReason());
		dwExitCode = 1;
		SAFEFREE(szTmpServer);
		SAFEFREE(szTmpUserName);
		SAFEFREE(szTmpPassword);
		ReleaseGlobals();
		return(dwExitCode);

	}
	
	// check if the help option has been specified.
	if(bUsage==TRUE)
	{
		ShowUsage() ;
		ReleaseGlobals();
		SAFEFREE(szTmpServer);
		SAFEFREE(szTmpUserName);
		SAFEFREE(szTmpPassword);
		return(dwExitCode);
	} 
	
	if( ( IsLocalSystem( szServer ) == TRUE )&&(lstrlen(szUserName)!=0) )
	{
		DISPLAY_MESSAGE(stdout,GetResString(IDS_IGNORE_LOCAL_CRED));
	}

	bComInitFlag = InitialiseCom(&pIWbemLocator);
	if(bComInitFlag == FALSE )
	{
		dwExitCode = 1;		 
		CloseConnection(szServer);	
		ReleaseGlobals();
		SAFEFREE(szTmpServer);
		SAFEFREE(szTmpUserName);
		SAFEFREE(szTmpPassword);
		return(dwExitCode);

	} 



	CHString		strUserName = NULL_STRING;
	CHString		strPassword = NULL_STRING;
	CHString		strMachineName = NULL_STRING;

	try
	{
		strUserName = szUserName ;
		strPassword = szPassword ;
		strMachineName = szServer ;
	
	 
	bFlag = ConnectWmiEx( pIWbemLocator, &pIWbemServReg, strMachineName,
			strUserName, strPassword, &pAuthIdentity, bNeedPassword, DEFAULT_NAMESPACE, &bLocalSystem );

	//if unable to connect to wmi exit failure
	if( bFlag == FALSE )
	{
		SAFEIRELEASE( pIWbemLocator);
		SAFEIRELEASE( pIWbemServReg );
		CoUninitialize();
		ReleaseGlobals();
		SAFEFREE(szTmpServer);
		SAFEFREE(szTmpUserName);
		SAFEFREE(szTmpPassword);
		return( EXIT_FAILURE );
	}
		
	szUserName = strUserName.GetBuffer(strUserName.GetLength());
	szPassword = strPassword.GetBuffer(strPassword.GetLength()) ;
	szServer = strMachineName.GetBuffer(strPassword.GetLength());

	}
	catch(CHeap_Exception)
	{
		DISPLAY_MESSAGE( stderr, ERROR_TAG );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		SAFEIRELEASE( pIWbemLocator);
		SAFEIRELEASE( pIWbemServReg );
		CoUninitialize();
		ReleaseGlobals();
		SAFEFREE(szTmpServer);
		SAFEFREE(szTmpUserName);
		SAFEFREE(szTmpPassword);
		return( EXIT_FAILURE );
	}

	// establish connection to remote system by using win32api function
	if ( bLocalSystem == FALSE )
	{
		LPCWSTR pwszUser = NULL;
		LPCWSTR pwszPassword = NULL;

		// identify the password to connect to the remote system
		if ( pAuthIdentity != NULL )
		{
			pwszPassword = pAuthIdentity->Password;
			if ( strUserName.GetLength() != 0 )
				pwszUser = strUserName;
		}

		DWORD dwConnect = 0 ;
		dwConnect = ConnectServer( strMachineName, pwszUser, pwszPassword );
		if(dwConnect !=NO_ERROR )
		{
			dwErrCode = GetLastError();
			if(dwErrCode == ERROR_SESSION_CREDENTIAL_CONFLICT)
			{
				DISPLAY_MESSAGE(stdout,GetResString(IDS_WARNING_TAG));
				ShowLastError(stdout);			
			}
			else if( dwConnect == ERROR_EXTENDED_ERROR )
			{
				DISPLAY_MESSAGE( stderr, ERROR_TAG );
				DISPLAY_MESSAGE( stderr, GetReason() );
				SAFEIRELEASE( pIWbemLocator );
				SAFEIRELEASE( pIWbemServReg );
				CoUninitialize();
				ReleaseGlobals();
				SAFEFREE(szTmpServer);
				SAFEFREE(szTmpUserName);
				SAFEFREE(szTmpPassword);
				return( EXIT_FAILURE );
			}
			else
			{
				SetLastError( dwConnect );
				DISPLAY_MESSAGE( stderr, ERROR_TAG );
				ShowLastError( stderr );
				SAFEIRELEASE( pIWbemLocator );
				SAFEIRELEASE( pIWbemServReg );
				CoUninitialize();
				ReleaseGlobals();
				SAFEFREE(szTmpServer);
				SAFEFREE(szTmpUserName);
				SAFEFREE(szTmpPassword);
				return( EXIT_FAILURE );
			}
		}
		else
		{
			
			bLocalFlag = FALSE ;
			
		}

	}
	else
	{
		lstrcpy( szServer, _T( "" ) );
	}

	hQueryResult = QueryDriverInfo(szServer, szUserName,szPassword,szFormat,bHeader,bVerbose,pIWbemLocator,pAuthIdentity,pIWbemServReg,bSigned);
	if(hQueryResult == FAILURE)
	{
		// close connection to the specified system and exit with failure.
		if (bLocalFlag == FALSE )
		{
			CloseConnection(szServer);	
		}
		dwExitCode = 1;
		ReleaseGlobals();
		SAFEFREE(szTmpServer);
		SAFEFREE(szTmpUserName);
		SAFEFREE(szTmpPassword);
	return(dwExitCode);

	}

	// close connection to the specified system and exit 
	
	if (bLocalFlag == FALSE )
	{
		CloseConnection(szServer);	
	}

	
	SAFEFREE(szTmpServer);
	SAFEFREE(szTmpUserName);
	SAFEFREE(szTmpPassword);
	ReleaseGlobals();
	return (dwExitCode);	
}

// ***************************************************************************
// Routine Description:
//		This function fetches usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		None
// ***************************************************************************
void ShowUsage()
{
	DWORD dwIndex  = ID_USAGE_BEGIN;
	
	for(;dwIndex<=ID_USAGE_ENDING; dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString( dwIndex ));
	}
}


// ***************************************************************************
// Routine Description:
//		This function queries the driverinfo of the specified system by connecting to WMI 
//		  
// Arguments:
//		[ in ] szServer			: server name on which DriverInformation has to be queried.
// 		[ in ] szUserName		: User name for whom  DriverInformation has to be queried.
//		[ in ] szPassword		: Password for the user 
//		[ in ] szFormat			: Format in which the results are to be displayed.
//		[ in ] bHeader			: Boolean indicating if the header is required.
//
// Return Value:
//		SUCCESS	: if the function is successful in querying
//		FAILURE	: if the function is unsuccessful in querying.
// ***************************************************************************
DWORD QueryDriverInfo(LPTSTR szServer,LPTSTR szUserName,LPTSTR szPassword,LPTSTR szFormat,BOOL bHeader,BOOL bVerbose,IWbemLocator* pIWbemLocator,COAUTHIDENTITY* pAuthIdentity,IWbemServices* pIWbemServReg,BOOL bSigned )
{
		
	HRESULT hRes = S_OK ;
	HRESULT hConnect = S_OK;

	
	
	_bstr_t bstrUserName ;
	_bstr_t bstrPassword ;
	_bstr_t bstrNamespace ;
	_bstr_t bstrServer ;
	
	try
	{
		bstrNamespace = CIMV2_NAMESPACE ;
		bstrServer = szServer ;
	}
	catch(...)
	{
		DISPLAY_MESSAGE( stderr,ERROR_RETREIVE_INFO);
		CoUninitialize();
		return FAILURE;
	}

	DWORD dwProcessResult = 0;
	DWORD dwSystemType = 0 ;
	LPTSTR lpMsgBuf = NULL;

	
	//Create a pointer to IWbemServices,IWbemLocator interfaces
	
	IWbemServices *pIWbemServices = NULL;
	IEnumWbemClassObject *pSystemSet = NULL;

	HRESULT hISecurity = S_FALSE;

	if ( IsLocalSystem( szServer ) == FALSE )
	{

		try
		{
			//appending UNC paths to form the complete path. 
			bstrNamespace = TOKEN_BACKSLASH2 + _bstr_t( szServer ) + TOKEN_BACKSLASH + CIMV2_NAMESPACE;
		
		
			// if user name is specified then only take user name and password
			if ( lstrlen( szUserName ) != 0 )
			{
				bstrUserName = szUserName;
				if (lstrlen(szPassword)==0)
				{
					bstrPassword = L"";
				
				}
				else
				{
					bstrPassword = szPassword ;
				}

			}
		}
		catch(...)
		{
			DISPLAY_MESSAGE( stderr,ERROR_RETREIVE_INFO);
			CoUninitialize();
			return FAILURE;

		}

	} 
	
	/* TCHAR szHost[256] = _T("");

	_tcscpy(szHost,szServer);
		
	if( IsValidIPAddress( szHost ) == TRUE )
	{
		//if( GetHostByIPAddr( szHost, szServer, FALSE ) == FALSE )
			GetHostByIPAddr( szHost, szServer, FALSE );
		//return FAILURE;

	} */


	dwSystemType = GetSystemType(pAuthIdentity,pIWbemServReg);
	if (dwSystemType == ERROR_WMI_VALUES)
	{
		DISPLAY_MESSAGE( stderr,ERROR_RETREIVE_INFO);
		CoUninitialize();
		return FAILURE;

	} 
		
	// Connect to the Root\Cimv2 namespace of the specified system with the current user.
	// If no system is specified then connect to the local system.
	// To pass the appropriate Username to connectserver
	// depending upon whether the user has entered domain\user or only username at the command prompt.

	// connect to the server with the credentials supplied.
		
		hConnect = pIWbemLocator->ConnectServer(bstrNamespace, 
												bstrUserName, 
												bstrPassword,
												0L,
												0L,
												NULL, 
												NULL, 
												&pIWbemServices ); 

		if((lstrlen(szUserName)!=0) && FAILED(hConnect) &&  (hConnect == E_ACCESSDENIED)) 
		{
			hConnect = pIWbemLocator->ConnectServer(bstrNamespace, 
													bstrUserName, 
													NULL,
													0L,
													0L,
													NULL, 
													NULL, 
													&pIWbemServices ); 
			
		}
		if(hConnect == WBEM_S_NO_ERROR)
		{
			// Set the proxy so that impersonation of the client occurs.

			hISecurity = SetInterfaceSecurity(pIWbemServices,pAuthIdentity);
				
			if(FAILED(hISecurity))
			{
				GetWbemErrorText(hISecurity);
				DISPLAY_MESSAGE(stderr,ERROR_TAG);
				DISPLAY_MESSAGE(stderr,GetReason());
				SAFEIRELEASE(pIWbemServices);
				CoUninitialize();
				return FAILURE ;
			}

			// Use the IWbemServices pointer to make requests of WMI. 
			// Create enumeration of Win32_ComputerSystem class
			if(bSigned == FALSE)
			{
				hRes = pIWbemServices->CreateInstanceEnum(_bstr_t(CLASS_SYSTEMDRIVER),	
													  WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
													  NULL,
													  &pSystemSet);  
			}
			else
			{
				hRes = pIWbemServices->ExecQuery(_bstr_t(LANGUAGE_WQL),_bstr_t(WQL_QUERY),WBEM_FLAG_RETURN_IMMEDIATELY| WBEM_FLAG_FORWARD_ONLY,NULL,&pSystemSet);
			}
			
			//if ( hRes == S_OK) 
			if ( SUCCEEDED(hRes )) 
			{

				hISecurity = SetInterfaceSecurity(pSystemSet,pAuthIdentity);
	
				if(FAILED(hISecurity))
				{
					GetWbemErrorText(hISecurity);
					DISPLAY_MESSAGE(stderr,ERROR_TAG);
					DISPLAY_MESSAGE(stderr,GetReason());
					SAFEIRELEASE(pSystemSet);
					CoUninitialize();
					return FAILURE ;
				}
			
				if(bSigned == FALSE)
				{
					dwProcessResult = ProcessCompSysEnum(szServer,pSystemSet,szFormat,bHeader,dwSystemType,bVerbose);
				}
				else
				{
					dwProcessResult = ProcessSignedDriverInfo(szServer,pSystemSet,szFormat,bHeader,dwSystemType,bVerbose);
				}

				switch(dwProcessResult)
				{
                    case FAILURE:
                        SAFEIRELEASE(pSystemSet);
	    				SAFEIRELEASE(pIWbemServices);	
		    			SAFEIRELEASE(pIWbemLocator);  
			        	CoUninitialize();
        			    return FAILURE ;


					case EXIT_FAILURE_MALLOC :	
						SetLastError(ERROR_NOT_ENOUGH_MEMORY);
						DISPLAY_MESSAGE( stderr, ERROR_TAG);
						ShowLastError(stderr);
						SAFEIRELEASE(pSystemSet);
						SAFEIRELEASE(pIWbemServices);	
						SAFEIRELEASE(pIWbemLocator);  
						CoUninitialize();
						return FAILURE ;
												
					case EXIT_FAILURE_FORMAT:	
											
						DISPLAY_MESSAGE(stderr, ERROR_ENUMERATE_INSTANCE);
						SAFEIRELEASE(pSystemSet);
						SAFEIRELEASE(pIWbemServices);
						SAFEIRELEASE(pIWbemLocator);  
						CoUninitialize();
						return FAILURE ;
												

					case EXIT_SUCCESSFUL:			
						SAFEIRELEASE(pSystemSet);
						SAFEIRELEASE(pIWbemServices);	
						SAFEIRELEASE(pIWbemLocator);  
						CoUninitialize();
						return SUCCESS ;
						break ;

					case EXIT_FAILURE_RESULTS:
						DISPLAY_MESSAGE(stdout,GetResString(IDS_NO_DRIVERS_FOUND));
						SAFEIRELEASE(pSystemSet);
						SAFEIRELEASE(pIWbemServices);	
						SAFEIRELEASE(pIWbemLocator);  
						CoUninitialize();
						return SUCCESS ;
						break ;
				}

			}
			else
			{
				DISPLAY_MESSAGE( stderr, ERROR_ENUMERATE_INSTANCE);
				SAFEIRELEASE(pIWbemServices);	
				SAFEIRELEASE(pIWbemLocator);  
				CoUninitialize();
				return FAILURE;
				
			} 
		}
		else
		{
			//display the error if connect server fails
			//unauthorized user
				if(hRes == WBEM_E_ACCESS_DENIED)
				{
					DISPLAY_MESSAGE( stderr, ERROR_AUTHENTICATION_FAILURE);
				}
				//local system credentials
				else if(hRes == WBEM_E_LOCAL_CREDENTIALS)
				{
					DISPLAY_MESSAGE( stderr, ERROR_LOCAL_CREDENTIALS);
				}
				//some error
				else
				{
					DISPLAY_MESSAGE( stderr, ERROR_WMI_FAILURE );
				}
				
				SAFEIRELEASE(pIWbemLocator);	
				CoUninitialize(); 
				return (FAILURE);
			
		
		}
		// Release pIWbemLocator object
		SAFEIRELEASE(pIWbemLocator);  

	// Close COM library, unload DLLs and free all resources held by 
	// current thread
    CoUninitialize();

    return (hRes);
}


// ***************************************************************************
// Routine Description:
//		Processes enumeration of Win32_ComputerSystem instances 
//		  
// Arguments:
//      [ in ]  szHost					: HostName to connect to
//		[ in ]	pSystemSet				: pointer to the structure containing system properties.
//		[ in ]  szFormat				: specifies the format  
//      [ in ]  bHeader					: specifies if the header is required or not.
//
// Return Value:
//		 0   no error
//		 1   error occured while allocating memory.			
//
//  ***************************************************************************
DWORD ProcessCompSysEnum(CHString szHost, IEnumWbemClassObject *pSystemSet,LPTSTR szFormat,BOOL bHeader,DWORD dwSystemType,BOOL bVerbose)
{
	HRESULT hRes = S_OK;
	ULONG ulReturned = 1;
	

	// declare variant type variables

	VARIANT vtPathName;

	//declaration  of normal variables
	CHString szPathName ;
	DWORD dwLength = 0;
	LPCTSTR szPath = NULL;
	LPTSTR szHostName = NULL ; 
	CHString szAcceptPauseVal ;
	CHString szAcceptStopVal ;
	LPTSTR szSysManfact = NULL;
	TARRAY arrResults  = NULL ;			
	TCHAR szPrintPath[MAX_STRING_LENGTH+1] =TOKEN_EMPTYSTRING ;
	DWORD dwRow = 0 ;
	BOOL bValue = FALSE ;
	DWORD dwValue = 0 ;

	TCHAR szDelimiter[MAX_RES_STRING+1] = NULL_STRING  ;
			
	DWORD dwPosn1 = 0;
	DWORD dwStrlen = 0;
			

	DWORD dwFormatType = SR_FORMAT_TABLE ;
	
	MODULE_DATA Current ;
	
	BOOL bResult = FALSE ;
	NUMBERFMT  *pNumberFmt = NULL;
	TCOLUMNS ResultHeader[ MAX_COLUMNS ];
	IWbemClassObject *pSystem = NULL;
	LPTSTR szCodeSize = NULL;
	LPTSTR szInitSize = NULL;
	LPTSTR szBssSize = NULL ;
	LPTSTR szAcceptStop = NULL ;
	int iLen = 0;
	LPTSTR szAcceptPause = NULL;
	LPTSTR szPagedSize = NULL ;
	TCHAR szDriverTypeVal[MAX_RES_STRING+1] = NULL_STRING;

	DWORD dwLocale = 0 ;
	WCHAR wszStrVal[MAX_RES_STRING+1] = NULL_STRING;

	CHString szValue ;
	CHString szSysName ;
	CHString szStartMode ;
	CHString szDispName ;
	CHString szDescription ;
	CHString szStatus ;
	CHString szState ;
	CHString szDriverType ;
	BOOL bBlankLine = FALSE;
	BOOL bFirstTime = TRUE;

	//get the paged pool acc to the Locale 
	BOOL bFValue = FALSE ;

	// Fill up the NUMBERFMT structure acc to the locale specific information
	LPTSTR szGroupSep = NULL;
	LPTSTR szDecimalSep = NULL ;
	LPTSTR szGroupThousSep = NULL ;


    pNumberFmt = (NUMBERFMT *) malloc(sizeof(NUMBERFMT));
	if(pNumberFmt == NULL)
	{
		return EXIT_FAILURE_MALLOC ;

	}


	// Initialise the structure to Zero.
	ZeroMemory(&Current,sizeof(Current));	

	// assign the appropriate format type to the dwFormattype flag

	if( StringCompare(szFormat,TABLE_FORMAT, TRUE,sizeof(TABLE_FORMAT)) == 0 )
	{
		dwFormatType = SR_FORMAT_TABLE;
	}
	else if( StringCompare(szFormat,LIST_FORMAT, TRUE,sizeof(LIST_FORMAT)) == 0 )
	{
		dwFormatType = SR_FORMAT_LIST;
	}
	else if( StringCompare(szFormat,CSV_FORMAT, TRUE,sizeof(CSV_FORMAT)) == 0 )
	{
		dwFormatType = SR_FORMAT_CSV;
	}

	// formulate the Column headers and show results appropriately
	FormHeader(dwFormatType,bHeader,ResultHeader,bVerbose);
		
	// loop till there are results. 
	bFirstTime = TRUE;
	while ( ulReturned == 1 )
	{
		// Create new Dynamic Array to hold the result
		arrResults = CreateDynamicArray();
	
		if(arrResults == NULL)
		{
			SAFEFREE(pNumberFmt);
			return EXIT_FAILURE_MALLOC ;
		}

		// Enumerate through the resultset.
		hRes = pSystemSet->Next(WBEM_INFINITE,
								1,				// return just one system
								&pSystem,		// pointer to system
								&ulReturned );	// number obtained: one or zero

		if ( SUCCEEDED( hRes ) && (ulReturned == 1) )
		{
	
			// initialise the variant variables to empty
		
			VariantInit(&vtPathName); 

						
			szValue = NO_DATA_AVAILABLE;
			szSysName = NO_DATA_AVAILABLE ;
			szStartMode = NO_DATA_AVAILABLE ;
			szDispName = NO_DATA_AVAILABLE ;
			szDescription = NO_DATA_AVAILABLE ;
			szStatus = NO_DATA_AVAILABLE ;
			szState = NO_DATA_AVAILABLE ;
			szDriverType = NO_DATA_AVAILABLE ;
				
			try
			{
				hRes = PropertyGet(pSystem,PROPERTY_NAME,szValue);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_SYSTEMNAME,szSysName);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_STARTMODE,szStartMode);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_DISPLAYNAME,szDispName);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_DESCRIPTION,szDescription);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_STATUS,szStatus);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_STATE,szState);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_ACCEPTPAUSE,szAcceptPauseVal);	
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_ACCEPTSTOP,szAcceptStopVal);	
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_SERVICETYPE,szDriverType);	
				ONFAILTHROWERROR(hRes);
			}
			catch(_com_error)
			{

				DISPLAY_MESSAGE(stderr,ERROR_GET_VALUE);
				SAFEIRELEASE(pSystem);
				DestroyDynamicArray(&arrResults);
				SAFEFREE(pNumberFmt);
				return FAILURE;
			}
			
			

			// retreive the PathName property
			szPath = NULL;
			try
			{
				hRes = pSystem->Get( PROPERTY_PATHNAME, 0,&vtPathName,0,NULL );
				if (( hRes == WBEM_S_NO_ERROR) && (vtPathName.vt != VT_NULL) && (vtPathName.vt != VT_EMPTY))
				{
						szPathName = ( LPWSTR ) _bstr_t(vtPathName);
						szSysManfact = (LPTSTR) malloc ((MAX_RES_STRING) * sizeof(TCHAR));
						if (szSysManfact == NULL)
						{
							SAFEIRELEASE(pSystem);
							DestroyDynamicArray(&arrResults);
							SAFEFREE(pNumberFmt);
							return EXIT_FAILURE_MALLOC;
						}
						
						dwLength = wcslen(szPathName);
						GetCompatibleStringFromUnicode( szPathName, szSysManfact, dwLength+2 );
						szPath = szSysManfact ; 
						
						// Initialise the structure to Zero.
						ZeroMemory(&Current,sizeof(Current));	

						// convert the szHost variable (containing hostname) into LPCTSTR and pass it to the GETAPI function
						szHostName = (LPTSTR) malloc ((MAX_RES_STRING) * (sizeof(TCHAR)));
						if (szHostName == NULL)
						{
							SAFEIRELEASE(pSystem);
							DestroyDynamicArray(&arrResults);
							SAFEFREE(pNumberFmt);
							SAFEFREE(szSysManfact);
							return EXIT_FAILURE_MALLOC;
						}

						GetCompatibleStringFromUnicode( szHost, szHostName,dwLength+2 );
						
						_tcscpy(szPrintPath,szPath);
						BOOL bApiInfo = GetApiInfo(szHostName,szPath,&Current, dwSystemType);		
						if(bApiInfo == FAILURE)
						{
							DestroyDynamicArray(&arrResults);
							SAFEFREE(pNumberFmt);
							SAFEFREE(szHostName);
							SAFEFREE(szSysManfact);
							continue ;
						}
						
				
				}
				else
				{
						DestroyDynamicArray(&arrResults);
						SAFEFREE(pNumberFmt);
						SAFEFREE(szHostName);
						SAFEFREE(szSysManfact);
						continue ; 	// ignore exception
				}
			}
			catch(...)
			{
				// If the path is empty then ignore the present continue with next iteration 
				DestroyDynamicArray(&arrResults);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				continue ; 	// ignore exception

			}

	
			//create a new empty row with required no of  columns
			dwRow =	DynArrayAppendRow(arrResults,MAX_COLUMNS) ;
		
			// Insert  the results into the Dynamic Array
						
   			DynArraySetString2( arrResults,dwRow,COL0,szSysName,0 );  
			DynArraySetString2( arrResults,dwRow,COL1,szValue,0 );  
			DynArraySetString2( arrResults,dwRow,COL2,szDispName,0 ); 
			DynArraySetString2( arrResults,dwRow,COL3,szDescription,0 ); 

			// strip off the word Driver from the display.
					
			
			dwLength = wcslen(szDriverType) ;
			GetCompatibleStringFromUnicode( szDriverType, szDriverTypeVal,dwLength+2 );

			_tcscpy(szDelimiter,DRIVER_TAG);
			dwPosn1 = _tcslen(szDelimiter);
			dwStrlen = _tcslen(szDriverTypeVal);
			szDriverTypeVal[dwStrlen-dwPosn1] = _T('\0');

			
			DynArraySetString2( arrResults,dwRow,COL4,szDriverTypeVal,0 );
			DynArraySetString2( arrResults,dwRow,COL5,szStartMode,0 ); 
			DynArraySetString2( arrResults,dwRow,COL6,szState,0 );
			DynArraySetString2( arrResults,dwRow,COL7,szStatus,0 ); 
				
			iLen = wcslen(szAcceptStopVal);
			szAcceptStop = (LPTSTR) malloc ((MAX_RES_STRING) * (sizeof(TCHAR )));
			if (szAcceptStop == NULL)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_MALLOC;
				
			}

			GetCompatibleStringFromUnicode(szAcceptStopVal,szAcceptStop,iLen + 2 );
			szAcceptStop[iLen] = '\0';  
			if (lstrcmp(szAcceptStop,_T("0"))==0)
			{
				lstrcpy(szAcceptStop,FALSE_VALUE); 
							
			}
			else
			{
				lstrcpy(szAcceptStop,TRUE_VALUE);
			}
				
			DynArraySetString2( arrResults,dwRow,COL8,szAcceptStop,0 );
					

			iLen = wcslen(szAcceptPauseVal);
			szAcceptPause = (LPTSTR) malloc ((MAX_RES_STRING) * (sizeof(TCHAR )));
			if (szAcceptPause == NULL)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_MALLOC;
				
			}

			GetCompatibleStringFromUnicode(szAcceptPauseVal,szAcceptPause,iLen + 2 );
			szAcceptPause[iLen] = '\0';  
			if (lstrcmp(szAcceptPause,_T("0"))==0)
			{
				lstrcpy(szAcceptPause,FALSE_VALUE); 
			}
			else
			{
				lstrcpy(szAcceptPause,TRUE_VALUE);
			}
			
			
			DynArraySetString2( arrResults,dwRow,COL9,szAcceptPause,0 );

			bFValue = FormatAccToLocale(pNumberFmt, &szGroupSep,&szDecimalSep,&szGroupThousSep);
			if (bFValue == FALSE)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);  
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_FORMAT ;
			
			}

			
			szPagedSize = (LPTSTR) malloc ((MAX_RES_STRING) * (sizeof(TCHAR )));
			if (szPagedSize == NULL)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);   
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_MALLOC;
			}
			
			

			_ltow(Current.ulPagedSize, wszStrVal,10);
			dwLocale = GetNumberFormat(LOCALE_USER_DEFAULT,0,wszStrVal,pNumberFmt,
					           szPagedSize,(MAX_RES_STRING + 1));
			if(dwLocale == 0)
			{
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szPagedSize);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);   
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_FORMAT;
			}

			DynArraySetString2( arrResults,dwRow,COL10, szPagedSize,0 );

			// get the CodeSize info acc to the locale
		

			szCodeSize = (LPTSTR) malloc ((MAX_RES_STRING) * (sizeof(TCHAR )));
			if (szCodeSize == NULL)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szPagedSize);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);   
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_MALLOC;
			}
			
									
			_ltow(Current.ulCodeSize, wszStrVal,10);
			dwLocale = GetNumberFormat(LOCALE_USER_DEFAULT,0,wszStrVal,pNumberFmt,szCodeSize,(MAX_RES_STRING + 1));
			if(dwLocale == 0)
			{	
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szCodeSize);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);   
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_FORMAT ;
			}
			DynArraySetString2( arrResults,dwRow,COL11, szCodeSize,0 );

			// retreive the bss info acc to the locale

			szBssSize = (LPTSTR) malloc ((MAX_RES_STRING) * (sizeof(TCHAR )));
			if (szBssSize == NULL)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szCodeSize);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);   
				DestroyDynamicArray(&arrResults);	
				return EXIT_FAILURE_MALLOC ;
			}
		
			_ltow(Current.ulBssSize, wszStrVal,10);
			dwLocale = GetNumberFormat(LOCALE_USER_DEFAULT,0,wszStrVal,pNumberFmt,
					           szBssSize,(MAX_RES_STRING + 1));
			if(dwLocale == 0)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szCodeSize);
				SAFEFREE(szBssSize);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);   
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_FORMAT ;
			}			
			DynArraySetString2( arrResults,dwRow,COL12, szBssSize,0 );

		
			//link date
			DynArraySetString2(arrResults,dwRow,COL13,(LPTSTR)(Current.szTimeDateStamp),0);  
			
			//Path of the File
			if(szPath != NULL)
			{
				DynArraySetString2(arrResults,dwRow,COL14,(LPTSTR)szPrintPath,0);  //
			}
			else
			{
				szPath= NO_DATA_AVAILABLE; 
				DynArraySetString2(arrResults,dwRow,COL14,(LPTSTR)szPath,0);  //
			}


			// get the initsize info acc to the locale
			szInitSize = (LPTSTR) malloc ((MAX_RES_STRING) * (sizeof(TCHAR )));
			if (szInitSize == NULL)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szCodeSize);
				SAFEFREE(szBssSize);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);   
				DestroyDynamicArray(&arrResults);
				return EXIT_FAILURE_MALLOC ;
			}

			_ltow(Current.ulInitSize, wszStrVal,10);
			dwLocale = GetNumberFormat(LOCALE_USER_DEFAULT,0,wszStrVal,pNumberFmt,
				           szInitSize,(MAX_RES_STRING + 1));
			if(dwLocale == 0)
			{
				SAFEIRELEASE(pSystem);
				SAFEFREE(pNumberFmt);
				SAFEFREE(szHostName);
				SAFEFREE(szSysManfact);
				SAFEFREE(szAcceptStop);
				SAFEFREE(szAcceptPause);
				SAFEFREE(szCodeSize);
				SAFEFREE(szBssSize);;
				SAFEFREE(szInitSize);
				SAFEFREE(szGroupThousSep);
				SAFEFREE(szDecimalSep);
				SAFEFREE(szGroupSep);   
				DestroyDynamicArray(&arrResults);	
				return EXIT_FAILURE_FORMAT ;
			}

			DynArraySetString2( arrResults,dwRow,COL15, szInitSize,0 );

			if ( bBlankLine == TRUE && (dwFormatType & SR_FORMAT_MASK) == SR_FORMAT_LIST )
				ShowMessage( stdout, _T( "\n" ) );

			if ( bFirstTime == TRUE )
			{
				ShowMessage( stdout, _T( "\n" ) );
				bFirstTime = FALSE;
			}

			if(bHeader)
			{
				ShowResults(MAX_COLUMNS, ResultHeader, dwFormatType|SR_NOHEADER,arrResults ) ;		
			}
			else
			{
				ShowResults(MAX_COLUMNS, ResultHeader, dwFormatType,arrResults ) ;
			}

			//set the header flag to true 
			bHeader = TRUE ;
			bBlankLine = TRUE;
			//set the bResult to true indicating that driver information has been displyed.
			bResult = TRUE ;
			
			// free the allocated memory
			SAFEFREE(szSysManfact); 
			SAFEFREE(pNumberFmt);
			SAFEFREE(szHostName);
			SAFEFREE(szAcceptStop);
			SAFEFREE(szAcceptPause);
			SAFEFREE(szPagedSize);
			SAFEFREE(szBssSize);
			SAFEFREE(szInitSize);
			SAFEFREE(szCodeSize);
			SAFEFREE(szGroupThousSep);
			SAFEFREE(szDecimalSep);
			SAFEFREE(szGroupSep);   
			SAFEIRELEASE(pSystem);

		} // If System Succeeded

		// Destroy the Dynamic arrays
		DestroyDynamicArray(&arrResults);
		
	}// While SystemSet returning objects

	// return the error value or success value
	if (bResult == TRUE)
	{
		return SUCCESS ;
	}
	else
	{
		return EXIT_FAILURE_RESULTS ;
	}
}

// ***************************************************************************
// Routine Description:
//		This function queries the system properties using API's . 
//		  
// Arguments:
//      [ in ]  szHostName		: HostName to connect to
//		[ in ]  pszPath			: pointer to the string containing the Path of the  file.
//		[ out]	Mod				: pointer to the structure containing system properties.
//
// Return Value:
//		SUCCESS : If successful in getting the information using API's.
//      FAILURE : If unable to get the information using API's.
//  ***************************************************************************
BOOL GetApiInfo(LPTSTR szHostName,LPCTSTR pszPath,PMODULE_DATA Mod,DWORD dwSystemType)
{
    
	HANDLE hMappedFile = NULL;
    PIMAGE_DOS_HEADER DosHeader;
    LOADED_IMAGE LoadedImage;
    ULONG ulSectionAlignment = 0;
	PIMAGE_SECTION_HEADER Section;
    DWORD dwI = 0;
    ULONG ulSize = 0;
	TCHAR szTmpServer[ MAX_STRING_LENGTH + 1 ] = NULL_STRING;
	HANDLE hFile = NULL ;	
	PTCHAR pszToken = NULL;
	lstrcpy(szTmpServer,TOKEN_BACKSLASH2);
	TCHAR szFinalPath[MAX_STRING_LENGTH+1] =TOKEN_EMPTYSTRING ;
	PTCHAR pdest = NULL ;

#ifndef _WIN64
	BOOL bIsWin64;
#endif 

	//copy the path into a variable
	_tcscpy(szFinalPath,pszPath); 


	//get the token upto the delimiter ":"
	pszToken = _tcstok(szFinalPath, COLON_SYMBOL );

	
	//form the string for getting the absolute path in the required format if it is a remote system.
	if(_tcslen(szHostName) != 0)
	{
		pdest = _tcsstr(pszPath,COLON_SYMBOL);
		
		if(pdest== NULL)
		{
			return FAILURE ;
		}
			
		_tcsnset(pdest,TOKEN_DOLLAR,1);
		_tcscat(szTmpServer,szHostName);
		_tcscat(szTmpServer,TOKEN_BACKSLASH);
		_tcscat(szTmpServer,pszToken);
		_tcscat(szTmpServer,pdest);
		
	}
	else
	{
		_tcscpy(szTmpServer,pszPath) ;

	}


#ifndef _WIN64
	bIsWin64 = IsWin64();
	
	if(bIsWin64)
		Wow64DisableFilesystemRedirector((LPCTSTR)szTmpServer);
#endif 

	// create a file on the specified system and return a handle to it.
	hFile = CreateFile(szTmpServer,
					   GENERIC_READ,
					   FILE_SHARE_READ,
					   NULL,
					   OPEN_EXISTING,
					   0,
					   NULL);


	
	//if the filehandle is invalid then return a error 
	if(hFile == INVALID_HANDLE_VALUE)
	{
		return FAILURE ;
	}



#ifndef _WIN64
	if(bIsWin64)
		Wow64EnableFilesystemRedirector();
#endif 

	// create a mapping to the specified file
    hMappedFile = CreateFileMapping(hFile,
									NULL,
									PAGE_READONLY,
									0,
									0,
									NULL);
     if (hMappedFile == NULL) 
	{
		CloseHandle(hFile);	
		return FAILURE ;
    }

    LoadedImage.MappedAddress = (PUCHAR)MapViewOfFile(hMappedFile,
													  FILE_MAP_READ,
													  0,
													  0,
													  0);
    
	// close the opened file handles
	CloseHandle(hMappedFile);
	CloseHandle(hFile);

    if ( !LoadedImage.MappedAddress ) 
	{
		return FAILURE ;
    }

    
    // check the image and find nt image headers
    
    DosHeader = (PIMAGE_DOS_HEADER)LoadedImage.MappedAddress;

	//exit if the DOS header does not match
    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) 
	{
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return FAILURE ;
    }


    LoadedImage.FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

    if ( LoadedImage.FileHeader->Signature != IMAGE_NT_SIGNATURE ) 
	{
        UnmapViewOfFile(LoadedImage.MappedAddress);
        
		return FAILURE ;
    }

	//get the number of sections present
    LoadedImage.NumberOfSections = LoadedImage.FileHeader->FileHeader.NumberOfSections;

    if(dwSystemType == SYSTEM_64_BIT )
	{
		LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS64));
	}
	else
	{
		LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS32));
	}
    
	LoadedImage.LastRvaSection = LoadedImage.Sections;
    
    // Walk through the sections and tally the dater
    
	ulSectionAlignment = LoadedImage.FileHeader->OptionalHeader.SectionAlignment;
	
    for(Section = LoadedImage.Sections,dwI=0;dwI < LoadedImage.NumberOfSections; dwI++,Section++) 
	{
        ulSize = Section->Misc.VirtualSize;

		if (ulSize == 0) 
		{
            ulSize = Section->SizeOfRawData;
        }

        ulSize = (ulSize + ulSectionAlignment - 1) & ~(ulSectionAlignment - 1);

	
		if (!_strnicmp((char *)(Section->Name),EXTN_PAGE, 4 )) 
		{
            Mod->ulPagedSize += ulSize;
        }

		
		else if (!_stricmp((char *)(Section->Name),EXTN_INIT )) 
		{
            Mod->ulInitSize += ulSize;
        }
       
		else if(!_stricmp((char *)(Section->Name),EXTN_BSS)) 
		{
            Mod->ulBssSize = ulSize;
        }
		else if (!_stricmp((char *)(Section->Name),EXTN_EDATA))
		{
			Mod->ulExportDataSize = ulSize ;
		}
		else if (!_stricmp((char *)(Section->Name),EXTN_IDATA )) 
		{
            Mod->ulImportDataSize = ulSize;
        }
		else if (!_stricmp((char *)(Section->Name),EXTN_RSRC)) 
		{
            Mod->ulResourceDataSize = ulSize;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) 
		{
            Mod->ulCodeSize += ulSize;
        }
		else if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) 
		{
            Mod->ulDataSize += ulSize;
        } 
        else 
		{
            Mod->ulDataSize += ulSize;
        }
     }
	
	#ifndef _WIN64
	LONG lTimeVal ;

	#else
	LONG64 lTimeVal;
	#endif

	lTimeVal = LoadedImage.FileHeader->FileHeader.TimeDateStamp ;
	
	struct tm *tmVal = NULL;
	tmVal = localtime(&lTimeVal);
	
	// proceed furthur only if we successfully got the localtime
	if ( tmVal != NULL )
	{
		LCID lcid;
		SYSTEMTIME systime;
		__STRING_64 szBuffer;
		BOOL bLocaleChanged = FALSE;

		systime.wYear = (WORD) (DWORD_PTR)( tmVal->tm_year + 1900 );	// tm -> Year - 1900   SYSTEMTIME -> Year = Year
		systime.wMonth = (WORD) (DWORD_PTR) tmVal->tm_mon + 1;			// tm -> Jan = 0       SYSTEMTIME -> Jan = 1
		systime.wDayOfWeek = (WORD) (DWORD_PTR) tmVal->tm_wday;
		systime.wDay = (WORD) (DWORD_PTR) tmVal->tm_mday;
		systime.wHour = (WORD) (DWORD_PTR) tmVal->tm_hour;
		systime.wMinute = (WORD) (DWORD_PTR) tmVal->tm_min;
		systime.wSecond = (WORD) (DWORD_PTR) tmVal->tm_sec;
		systime.wMilliseconds = 0;

		// verify whether console supports the current locale 100% or not
		lcid = GetSupportedUserLocale( bLocaleChanged );

		// get the formatted date
		GetDateFormat( lcid, 0, &systime, 
			((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL), szBuffer, SIZE_OF_ARRAY( szBuffer ) );
	
		// copy the date info
		lstrcpy( Mod->szTimeDateStamp, szBuffer ); 

		// now format the date
		GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systime, 
			((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), szBuffer, SIZE_OF_ARRAY( szBuffer ) );

		// now copy time info 
		lstrcat( Mod->szTimeDateStamp, _T( " " ) );
		lstrcat( Mod->szTimeDateStamp, szBuffer );
	}

	UnmapViewOfFile(LoadedImage.MappedAddress);
    return SUCCESS;
} 


// ***************************************************************************
// Routine Description:
//		This function parses the options specified at the command prompt
//		  
// Arguments:
//		[ in  ] argc			: count of elements in argv
//		[ in  ] argv			: command-line parameterd specified by the user
//		[ out ] pbShowUsage		: set to TRUE if -? exists in 'argv'
//		[ out ] pszServer		: value(s) specified with -s ( server ) option in 'argv'
//		[ out ] pszUserName		: value of -u ( username ) option in 'argv'
//		[ out ] pszPassword		: value of -p ( password ) option in 'argv'
//		[ out ] pszFormat		: Display format 
//		[ out ] bHeader			: specifies whether to display a header or not.
//		[ in  ] bNeedPassword	: specifies if the password is required or not.
//		  
// Return Value:
//		TRUE	: if the parsing is successful
//		FALSE	: if errors occured in parsing
// ***************************************************************************
BOOL ProcessOptions(LONG argc,LPCTSTR argv[],PBOOL pbShowUsage,LPTSTR *pszServer,LPTSTR *pszUserName,LPTSTR *pszPassword,LPTSTR pszFormat,PBOOL pbHeader, PBOOL bNeedPassword,PBOOL pbVerbose,PBOOL pbSigned)
{

	PTCMDPARSER pcmdOption = NULL; //pointer to the structure
	TCMDPARSER cmdOptions[MAX_OPTIONS] ; 
	BOOL bval = TRUE ;
	LPCTSTR szToken = NULL ;

	// init the password
	if ( pszPassword != NULL && *pszPassword != NULL )
	{
		lstrcpy( *pszPassword, _T( "*" ) );
	}

	// help option 
	pcmdOption  = &cmdOptions[OI_HELP] ;
	pcmdOption->dwCount = 1 ;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_USAGE ;
	pcmdOption->pValue = pbShowUsage ;
	pcmdOption->pFunction = NULL ;
	pcmdOption->pFunctionData = NULL ;
	lstrcpy(pcmdOption->szValues,NULL_STRING);
	lstrcpy(pcmdOption->szOption,OPTION_HELP); // _T("?")
	
 	
	//server name option
	pcmdOption  = &cmdOptions[OI_SERVER] ;
	pcmdOption->dwCount = 1 ;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY ;
	pcmdOption->pValue = *pszServer ;
	pcmdOption->pFunction = NULL ;
	pcmdOption->pFunctionData = NULL ;
	lstrcpy(pcmdOption->szValues,NULL_STRING);
	lstrcpy(pcmdOption->szOption,OPTION_SERVER); // _T("s")

	//domain\user option
	pcmdOption  = &cmdOptions[OI_USERNAME] ;
	pcmdOption->dwCount = 1 ;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY ;
	pcmdOption->pValue = *pszUserName ;
	pcmdOption->pFunction = NULL ;
	pcmdOption->pFunctionData = NULL ;
	lstrcpy(pcmdOption->szValues,NULL_STRING);
	lstrcpy(pcmdOption->szOption,OPTION_USERNAME); // _T("u")

	//password option
	pcmdOption  = &cmdOptions[OI_PASSWORD] ;
	pcmdOption->dwCount = 1 ;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT|CP_VALUE_OPTIONAL;
	pcmdOption->pValue = *pszPassword ;
	pcmdOption->pFunction = NULL ;
	pcmdOption->pFunctionData = NULL ;
	lstrcpy(pcmdOption->szValues,NULL_STRING);
	lstrcpy(pcmdOption->szOption,OPTION_PASSWORD); // _T("p")

	//format option.
	pcmdOption  = &cmdOptions[OI_FORMAT] ;
	pcmdOption->dwCount = 1 ;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY|CP_MODE_VALUES  ;
	pcmdOption->pValue = pszFormat ;
	pcmdOption->pFunction = NULL ;
	pcmdOption->pFunctionData = NULL ;
	lstrcpy(pcmdOption->szValues,FORMAT_VALUES);
	lstrcpy(pcmdOption->szOption,OPTION_FORMAT); // _T("fo")

	
	//no header option
	pcmdOption  = &cmdOptions[OI_HEADER] ;
	pcmdOption->dwCount = 1 ;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags =  0;
	pcmdOption->pValue = pbHeader;
	pcmdOption->pFunction = NULL ;
	pcmdOption->pFunctionData = NULL ;
	lstrcpy(pcmdOption->szValues,NULL_STRING);
	lstrcpy(pcmdOption->szOption,OPTION_HEADER); // _T("nh")


	//verbose option..

	pcmdOption  = &cmdOptions[OI_VERBOSE] ;
	pcmdOption->dwCount = 1 ;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags =  0 ;
	pcmdOption->pValue = pbVerbose;
	pcmdOption->pFunction = NULL ;
	pcmdOption->pFunctionData = NULL ;
	lstrcpy(pcmdOption->szValues,NULL_STRING);
	lstrcpy(pcmdOption->szOption,OPTION_VERBOSE); // _T("v")
	

	pcmdOption  = &cmdOptions[OI_SIGNED] ;
	pcmdOption->dwCount = 1 ;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags =  0 ;
	pcmdOption->pValue = pbSigned;
	pcmdOption->pFunction = NULL ;
	pcmdOption->pFunctionData = NULL ;
	lstrcpy(pcmdOption->szValues,NULL_STRING);
	lstrcpy(pcmdOption->szOption,OPTION_SIGNED); // _T("di")
	

	bval = DoParseParam(argc,argv,MAX_OPTIONS,cmdOptions) ;
	
	if( bval== FALSE)
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		return FALSE ;
	
	}
	
	if((*pbShowUsage == TRUE)&&(argc > 2))
	{
			SetReason(ERROR_SYNTAX);
			return FALSE ;
	}

	
	// checking if -u is specified when -s options is not specified and display error msg .
	if ((cmdOptions[OI_SERVER].dwActuals == 0) && (cmdOptions[OI_USERNAME].dwActuals !=0 ))
	{

		SetReason(ERROR_USERNAME_BUT_NOMACHINE);
		return FALSE ;
	}

	// checking if -u is specified when -p options is not specified and display error msg .
	if ((cmdOptions[OI_USERNAME].dwActuals == 0) && (cmdOptions[OI_PASSWORD].dwActuals !=0 ))
	{

		SetReason(ERROR_PASSWORD_BUT_NOUSERNAME);
		return FALSE ;
	}

	// checking if -p is specified when -u options is not specified and display error msg .
	if ((cmdOptions[OI_SERVER].dwActuals != 0) && (lstrlen(*pszServer)==0 ))
	{
		SetReason(ERROR_INVALID_SERVER);
		return FALSE ;
	}

	// checking if -p is specified when -u options is not specified and display error msg .
	if ((cmdOptions[OI_USERNAME].dwActuals != 0) && (lstrlen(*pszUserName)==0 ))
	{
		SetReason(ERROR_INVALID_USER);
		return FALSE ;
	}

	if((cmdOptions[OI_FORMAT].dwActuals != 0)&&(lstrcmpi((LPCTSTR)cmdOptions[OI_FORMAT].pValue,LIST_FORMAT) == 0)&&(cmdOptions[OI_HEADER].dwActuals != 0))
	{
		SetReason(ERROR_NO_HEADERS);
		return FALSE ;
	
	}


	if((cmdOptions[OI_SIGNED].dwActuals != 0)&&(cmdOptions[OI_VERBOSE].dwActuals != 0))
	{
		SetReason(INVALID_SIGNED_SYNTAX);
		return FALSE ;
	
	}

	if(StrCmpN(*pszServer,TOKEN_BACKSLASH2,2)==0)
	{
		if(!StrCmpN(*pszServer,TOKEN_BACKSLASH3,3)==0)
		{
			szToken = _tcstok(*pszServer,TOKEN_BACKSLASH2);
			lstrcpy(*pszServer,szToken);
		}
	}

	if(IsLocalSystem( *pszServer ) == FALSE )
	{
		// set the bNeedPassword to True or False .
		if ( cmdOptions[ OI_PASSWORD ].dwActuals != 0 && 
			 pszPassword != NULL && *pszPassword != NULL && lstrcmp( *pszPassword, _T( "*" ) ) == 0 )
		{
			// user wants the utility to prompt for the password before trying to connect
			*bNeedPassword = TRUE;
		}
		else if ( cmdOptions[ OI_PASSWORD ].dwActuals == 0 && 
				( cmdOptions[ OI_SERVER ].dwActuals != 0 || cmdOptions[ OI_USERNAME ].dwActuals != 0 ) )
		{
			// -s, -u is specified without password ...
			// utility needs to try to connect first and if it fails then prompt for the password
			*bNeedPassword = TRUE;
			if ( pszPassword != NULL && *pszPassword != NULL )
			{
				lstrcpy( *pszPassword, _T( "" ) );
			}
		}

	}

	return TRUE ;	
}



// ***************************************************************************
// Routine Description:
//		This function is used to build the header and also display the 
//		 result in the required format as specified by  the user.	
//		  
// Arguments:
//		[ in ] arrResults     : argument(s) count specified at the command prompt
//		[ in ] dwFormatType   : format flags 
//		[ in ] bHeader        : Boolean for specifying if the header is required or not.
//  
// Return Value:
//		none
//		
// ***************************************************************************
VOID FormHeader(DWORD dwFormatType,BOOL bHeader,TCOLUMNS *ResultHeader,BOOL bVerbose)
{
	
	// host name
	ResultHeader[COL0].dwWidth = COL_HOSTNAME_WIDTH;
	ResultHeader[COL0].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
	ResultHeader[COL0].pFunction = NULL;
	ResultHeader[COL0].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL0].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL0].szColumn,COL_HOSTNAME );

	
	//File Name header
	ResultHeader[COL1].dwWidth = COL_FILENAME_WIDTH  ;
	ResultHeader[COL1].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL1].pFunction = NULL;
	ResultHeader[COL1].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL1].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL1].szColumn,COL_FILENAME );


	// Forming the DisplayName header Column
	ResultHeader[COL2].dwWidth = COL_DISPLAYNAME_WIDTH  ;
	ResultHeader[COL2].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL2].pFunction = NULL;
	ResultHeader[COL2].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL2].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL2].szColumn,COL_DISPLAYNAME );

	
	// Forming the Description header Column
	ResultHeader[COL3].dwWidth = COL_DESCRIPTION_WIDTH;
	if(!bVerbose)
	{
		ResultHeader[COL3].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
	}
	else
	{
		ResultHeader[COL3].dwFlags = SR_TYPE_STRING;
	}
	ResultHeader[COL3].pFunction = NULL;
	ResultHeader[COL3].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL3].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL3].szColumn,COL_DESCRIPTION );

	
	// Forming the Drivertype header Column

	ResultHeader[COL4].dwWidth = COL_DRIVERTYPE_WIDTH  ;
	ResultHeader[COL4].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL4].pFunction = NULL;
	ResultHeader[COL4].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL4].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL4].szColumn,COL_DRIVERTYPE );


	// Forming the StartMode header Column
	ResultHeader[COL5].dwWidth = COL_STARTMODE_WIDTH;
	if(!bVerbose)
	{
		ResultHeader[COL5].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
	}
	else
	{
		ResultHeader[COL5].dwFlags = SR_TYPE_STRING;
	}
	ResultHeader[COL5].pFunction = NULL;
	ResultHeader[COL5].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL5].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL5].szColumn,COL_STARTMODE );

	
	// Forming the State header Column
	ResultHeader[COL6].dwWidth = COL_STATE_WIDTH  ;
	if(!bVerbose)
	{
		ResultHeader[COL6].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
	}
	else
	{
		ResultHeader[COL6].dwFlags = SR_TYPE_STRING;
	}
	ResultHeader[COL6].pFunction = NULL;
	ResultHeader[COL6].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL6].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL6].szColumn,COL_STATE );

	// Forming the Status header Column
	ResultHeader[COL7].dwWidth = COL_STATUS_WIDTH;
	if(!bVerbose)
	{
		ResultHeader[COL7].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
	}
	else
	{
		ResultHeader[COL7].dwFlags = SR_TYPE_STRING;
	}
	ResultHeader[COL7].pFunction = NULL;
	ResultHeader[COL7].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL7].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL7].szColumn,COL_STATUS );

	// Forming the AcceptStop header Column
	ResultHeader[COL8].dwWidth = COL_ACCEPTSTOP_WIDTH  ;
	if(!bVerbose)
	{
		ResultHeader[COL8].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
	}
	else
	{
		ResultHeader[COL8].dwFlags = SR_TYPE_STRING;
	}
	ResultHeader[COL8].pFunction = NULL;
	ResultHeader[COL8].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL8].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL8].szColumn,COL_ACCEPTSTOP );

	// Forming the AcceptPause header Column
	ResultHeader[COL9].dwWidth = COL_ACCEPTPAUSE_WIDTH;
	if(!bVerbose)
	{
		ResultHeader[COL9].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
	}
	else
	{
		ResultHeader[COL9].dwFlags = SR_TYPE_STRING;
	}
	ResultHeader[COL9].pFunction = NULL;
	ResultHeader[COL9].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL9].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL9].szColumn,COL_ACCEPTPAUSE );


	// Forming the PagedPool header Column
	ResultHeader[COL10].dwWidth = COL_PAGEDPOOL_WIDTH  ;
	if(!bVerbose)
	{
		ResultHeader[COL10].dwFlags =  SR_TYPE_STRING|SR_HIDECOLUMN ; 
	}
	else
	{
		ResultHeader[COL10].dwFlags = SR_TYPE_STRING; 
	}
	ResultHeader[COL10].pFunction = NULL;
	ResultHeader[COL10].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL10].szFormat, NULL_STRING );
	lstrcpy(ResultHeader[COL10].szColumn,COL_PAGEDPOOL) ;

	
	
	// Forming the Executable Code header Column
	ResultHeader[COL11].dwWidth = COL_EXECCODE_WIDTH  ;
	if(!bVerbose)
	{
		ResultHeader[COL11].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN ;
	}
	else
	{
		ResultHeader[COL11].dwFlags = SR_TYPE_STRING;
	}
	ResultHeader[COL11].pFunction = NULL;
	ResultHeader[COL11].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL11].szFormat, NULL_STRING );
	lstrcpy(ResultHeader[COL11].szColumn ,COL_EXECCODE) ;
	

	// Forming the BlockStorage Segment header Column	
	ResultHeader[COL12].dwWidth = COL_BSS_WIDTH  ;
	if(!bVerbose)
	{
		ResultHeader[COL12].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN; 
	}
	else
	{
		ResultHeader[COL12].dwFlags =  SR_TYPE_STRING ; 
	}
	ResultHeader[COL12].pFunction = NULL;
	ResultHeader[COL12].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL12].szFormat, NULL_STRING );
	lstrcpy(ResultHeader[COL12].szColumn ,COL_BSS );

	// Forming the LinkDate header Column
	ResultHeader[COL13].dwWidth = COL_LINKDATE_WIDTH;
	ResultHeader[COL13].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL13].pFunction = NULL;
	ResultHeader[COL13].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL13].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL13].szColumn,COL_LINKDATE );

	// Forming the Location header Column
	ResultHeader[COL14].dwWidth = COL_LOCATION_WIDTH  ;
	if(!bVerbose)
	{
		ResultHeader[COL14].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
	}
	else
	{
		ResultHeader[COL14].dwFlags = SR_TYPE_STRING;
	}
	ResultHeader[COL14].pFunction = NULL;
	ResultHeader[COL14].pFunctionData = NULL;
	_tcscpy( ResultHeader[COL14].szFormat, NULL_STRING );
	_tcscpy(ResultHeader[COL14].szColumn,COL_LOCATION);

	// Forming the Init Code header Column
	ResultHeader[COL15].dwWidth = COL_INITSIZE_WIDTH  ;
	if(!bVerbose)
	{
		ResultHeader[COL15].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN; 
	}
	else
	{
		ResultHeader[COL15].dwFlags = SR_TYPE_STRING; 
	}
	ResultHeader[COL15].pFunction = NULL;
	ResultHeader[COL15].pFunctionData = NULL;
	_tcscpy( ResultHeader[COL15].szFormat, NULL_STRING );
	_tcscpy(ResultHeader[COL15].szColumn,COL_INITSIZE);
}


#ifndef _WIN64

/*-------------------------------------------------------------------------*
 // IsWin64
 //
 //	 Arguments						: 
 //		 none
 // Returns true if we're running on Win64, false otherwise.
 *--------------------------------------------------------------------------*/

BOOL IsWin64(void)
{
#ifdef UNICODE
	
	// get a pointer to kernel32!GetSystemWow64Directory

	HMODULE hmod = GetModuleHandle (_T("kernel32.dll"));

	if (hmod == NULL)
		return (FALSE);

	UINT (WINAPI* pfnGetSystemWow64Directory)(LPTSTR, UINT);
	(FARPROC&)pfnGetSystemWow64Directory = GetProcAddress (hmod, "GetSystemWow64DirectoryW");

	if (pfnGetSystemWow64Directory == NULL)
		return (FALSE);

	/*
	 * if GetSystemWow64Directory fails and sets the last error to
	 * ERROR_CALL_NOT_IMPLEMENTED, we're on a 32-bit OS
	 */
	TCHAR szWow64Dir[MAX_PATH];

	if (((pfnGetSystemWow64Directory)(szWow64Dir, countof(szWow64Dir)) == 0) &&
		(GetLastError() == ERROR_CALL_NOT_IMPLEMENTED))
	{
		return (FALSE);
	}

	// we're on Win64
	 
	return (TRUE);
#else
	// non-Unicode platforms cannot be Win64
	 
	return (FALSE);
#endif	// UNICODE
}

#endif // _WIN64

 

/*-------------------------------------------------------------------

Routine Description:

Formats the Number to the locale with thousands position
 
Arguments:
	NUMBERFMT  *pNumberFmt[in]	- NUMBERFMT Structure to  be filled with .

Return Value:
	VOID
--------------------------------------------------------------------*/
BOOL FormatAccToLocale(	NUMBERFMT  *pNumberFmt,LPTSTR* pszGroupSep,LPTSTR* pszDecimalSep,LPTSTR* pszGroupThousSep)
{

	TCHAR   szFormatedString[MAX_RES_STRING + 1] = NULL_STRING;

	HRESULT hResult = 0;
	DWORD   dwLocale = 0;
 
 
	if( GetInfo( LOCALE_SGROUPING, pszGroupSep ) == FALSE)
	{
		pNumberFmt = NULL;
		return FALSE ;
	}
	if( GetInfo( LOCALE_SDECIMAL, pszDecimalSep ) == FALSE)
	{
		pNumberFmt = NULL;
		return FALSE ;
	}
	if( GetInfo( LOCALE_STHOUSAND, pszGroupThousSep ) == FALSE)
	{
		pNumberFmt = NULL;
		return FALSE ;
	}
	if(pNumberFmt != NULL)
	{
		pNumberFmt->LeadingZero = 0;
		pNumberFmt->NegativeOrder = 0;
		pNumberFmt->NumDigits = 0;
		if(lstrcmp(*pszGroupSep, GROUP_FORMAT_32) == 0)
		{
			pNumberFmt->Grouping = GROUP_32_VALUE;
		}
		else
		{
			pNumberFmt->Grouping = UINT( _ttoi( *pszGroupSep ) );
		}
		pNumberFmt->lpDecimalSep = *pszDecimalSep;
		pNumberFmt->lpThousandSep = *pszGroupThousSep;
	}
		
	
	return TRUE ;
}

/*-------------------------------------------------------------------
// 
//Routine Description:
// 
//Gets the Locale information
// 
//Arguments:
// 
//    LCTYPE lctype [in] -- Locale Information to get
//	  LPTSTR* pszData [out] -- Locale value corresponding to the given
//          information
// 
//	Return Value:
//		BOOL
//--------------------------------------------------------------------*/
BOOL GetInfo( LCTYPE lctype, LPTSTR* pszData )
{
	LONG lSize = 0;
 
 // get the locale specific info
 lSize = GetLocaleInfo( LOCALE_USER_DEFAULT, lctype, NULL, 0 );
 if ( lSize != 0 )
 {
  
	*pszData = (LPTSTR)malloc((lSize + 1)*sizeof(TCHAR));
  if ( *pszData != NULL )
  {
   // get the locale specific time seperator
  	GetLocaleInfo( LOCALE_USER_DEFAULT, lctype, *pszData, lSize );
	return TRUE;
  }
 }
 return FALSE;
}//end of GetInfo



/*-------------------------------------------------------------------
// 
//Routine Description:
// 
//Gets the type os the specified System ( 32 bit or 64 bit)
// 
//Arguments:
// 
//    IWbemLocator *pLocator[in] -- Pointer to the locator interface.
//	  _bstr_t bstrServer[in]     -- Server Name
//	  _bstr_t bstrUserName[in]   -- User Name
//	  _bstr_t bstrPassword [in]  -- Password 	
//          information
// 
//	Return Value:
//		DWORD : SYSTEM_32_BIT    -- If the system is 32 bit system.
//			    SYSTEM_64_BIT	 -- If the system is 32 bit system.
//				ERROR_WMI_VALUES -- If error occured while retreiving values from WMI. 
//--------------------------------------------------------------------*/

DWORD GetSystemType(COAUTHIDENTITY* pAuthIdentity,IWbemServices* pIWbemServReg)
{

    IWbemClassObject * pInClass = NULL;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutInst = NULL;
    IWbemClassObject * pInInst = NULL;
	VARIANT varConnectName;
	VARIANT varSvalue ;
	VARIANT varHkey;
	VARIANT varVaue ;
	VARIANT varRetVal ;

	HRESULT hRes = S_OK;
	LPTSTR szSysName = NULL ;
	CHString	  szSystemName ;
	DWORD dwSysType = 0 ;		

	 
	VariantInit(&varConnectName) ;
	VariantInit(&varSvalue) ;
	VariantInit(&varHkey) ;
	VariantInit(&varVaue) ;
	VariantInit(&varRetVal) ;

	
	try
	{
		hRes = pIWbemServReg->GetObject(bstr_t(STD_REG_CLASS), 0, NULL, &pClass, NULL);
		ONFAILTHROWERROR(hRes);
		if(hRes != WBEM_S_NO_ERROR)
		{
			hRes = FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
			return (ERROR_WMI_VALUES);
		} 
	
		// Get the input argument and set the property
		hRes = pClass->GetMethod(_bstr_t(PROPERTY_GETSTRINGVAL), 0, &pInClass, NULL); 
		ONFAILTHROWERROR(hRes);
		if(hRes != WBEM_S_NO_ERROR)
		{
			FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
			return (ERROR_WMI_VALUES);
		}

		hRes = pInClass->SpawnInstance(0, &pInInst);
		ONFAILTHROWERROR(hRes);
		if(hRes != WBEM_S_NO_ERROR)
		{
			FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
			return (ERROR_WMI_VALUES);
		}


		//the registry path to get the connection name

		varConnectName.vt = VT_BSTR;
		varConnectName.bstrVal= SysAllocString(REG_PATH);
		hRes = pInInst->Put(REG_SUB_KEY_VALUE, 0, &varConnectName, 0);
		ONFAILTHROWERROR(hRes);		

		//set the svalue name
		varSvalue.vt = VT_BSTR;
		varSvalue.bstrVal= SysAllocString(REG_SVALUE);
		hRes = pInInst->Put(REG_VALUE_NAME, 0, &varSvalue, 0);
		ONFAILTHROWERROR(hRes);
		
		varHkey.vt = VT_I4 ;
		varHkey.lVal = HEF_KEY_VALUE;
		hRes = pInInst->Put(HKEY_VALUE, 0, &varHkey, 0);
		ONFAILTHROWERROR(hRes);
		// Call the method
		hRes = pIWbemServReg->ExecMethod(_bstr_t(STD_REG_CLASS), _bstr_t(REG_METHOD), 0, NULL, pInInst, &pOutInst, NULL);
		ONFAILTHROWERROR(hRes);

		if(pOutInst == NULL)
		{
			FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
			return (ERROR_WMI_VALUES);
		}

		hRes = pOutInst->Get(PROPERTY_RETURNVAL,0,&varRetVal,NULL,NULL);
		ONFAILTHROWERROR(hRes);

		if(varRetVal.lVal != 0)
		{
			FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
			return (ERROR_WMI_VALUES);
		}

		hRes = pOutInst->Get(REG_RETURN_VALUE,0,&varVaue,NULL,NULL);
		ONFAILTHROWERROR(hRes);
		if(hRes != WBEM_S_NO_ERROR)
		{
			FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
			return (ERROR_WMI_VALUES);
		}
	}
	catch(_com_error)
	{

		DISPLAY_MESSAGE(stderr,ERROR_GET_VALUE);
		FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
		return (ERROR_WMI_VALUES);
	}

	szSystemName =  V_BSTR(&varVaue);

	szSysName = (LPTSTR)malloc((MAX_RES_STRING)*sizeof(TCHAR));

	if(szSysName == NULL)
	{
		FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
		return (ERROR_WMI_VALUES);
	}

	GetCompatibleStringFromUnicode( szSystemName, szSysName, wcslen( szSystemName )+2 );

	dwSysType = _tcsstr(szSysName,X86_MACHINE) ? SYSTEM_32_BIT:SYSTEM_64_BIT  ;

	FreeMemory(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,varConnectName,varSvalue,varHkey,varRetVal,varVaue,szSysName );
	return (dwSysType);

}



/*-------------------------------------------------------------------
// 
//Routine Description:
// 
//Gets the type os the specified System ( 32 bit or 64 bit)
// 
//Arguments:
// 
//    IWbemLocator** pLocator[in] -- Pointer to the locator interface.
//
//
//
//          information
// 
//	Return Value:
//		BOOL : TRUE  on Successfully initialising COM.   
//			   FALSE on Failure to initialise COM.
//			
//			
//			
//--------------------------------------------------------------------*/
BOOL InitialiseCom(IWbemLocator** ppIWbemLocator)
{

	HRESULT hRes = S_OK ;

	try
	{
		// To initialize the COM library.
		hRes = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED );
		ONFAILTHROWERROR(hRes);
	

		// Initialize COM security for DCOM services, Adjust security to 
		// allow client impersonation
	
		hRes =  CoInitializeSecurity( NULL, -1, NULL, NULL,
								RPC_C_AUTHN_LEVEL_NONE, 
								RPC_C_IMP_LEVEL_IMPERSONATE, 
								NULL, 
								EOAC_NONE, 0 );

		ONFAILTHROWERROR(hRes);
		
	
 		// get a pointer to the Interface IWbemLocator
		hRes = CoCreateInstance(CLSID_WbemLocator, NULL, 
        CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) ppIWbemLocator); 
		ONFAILTHROWERROR(hRes);
		
	}
	catch(_com_error& e )
	{
		GetWbemErrorText( e.Error() );
		DISPLAY_MESSAGE( stderr, ERROR_TAG  );
		DISPLAY_MESSAGE( stderr, GetReason() );
		return( FALSE );
	}
	
	// if successfully initialised COM then return true
	return TRUE ;
}



/*-------------------------------------------------------------------
// 
//Routine Description:
// 
// To perform the Get .
// 
//Arguments:
// 
//    IWbemClassObject** pWmiObject[in] -- Pointer to the locator interface.
//    LPCTSTR			pszInputVal[in] -- Input string containing the desired value. 
//    CHString          szOutPutVal[out]-- String containing the retreived value. 
//
//          information
// 
//	Return Value:
//		BOOL : TRUE  on Successfully initialising COM.   
//			   FALSE on Failure to initialise COM.
//			
//			
//			
//--------------------------------------------------------------------*/

HRESULT PropertyGet(IWbemClassObject* pWmiObject,LPCTSTR pszInputVal,CHString &szOutPutVal)
{

	HRESULT hRes = S_FALSE ;
	VARIANT vtValue ;
	VariantInit(&vtValue);
	hRes = pWmiObject->Get(pszInputVal,0,&vtValue,NULL,NULL);

	if (hRes != WBEM_S_NO_ERROR)
	{
		hRes = VariantClear(&vtValue);
		return (hRes);
	}
	if ((hRes == WBEM_S_NO_ERROR)&&(vtValue.vt != VT_NULL) && (vtValue.vt != VT_EMPTY))
	{
		szOutPutVal = (LPCWSTR)_bstr_t(vtValue);
	}

	hRes = VariantClear(&vtValue);
	if(hRes != S_OK)
	{
		return hRes ; 
	}
	return TRUE ;
	
	
}

// ***************************************************************************
// Routine Description:
//		This function frees the memory allocated in the function.
//		  
// Arguments:
//		IWbemClassObject *pInClass - Interface ptr pointing to the IWbemClassObject interface
//		IWbemClassObject * pClass  - Interface ptr pointing to the IWbemClassObject interface
//		IWbemClassObject * pOutInst - Interface ptr pointing to the IWbemClassObject interface
//		IWbemClassObject * pInInst - Interface ptr pointing to the IWbemClassObject interface
//		IWbemServices *pIWbemServReg - Interface ptr pointing to the IWbemServices interface
//		VARIANT varConnectName		- variant
//      VARIANT varSvalue			- variant
//		VARIANT varHkey				- variant
//		VARIANT varRetVal			- variant 
//		VARIANT varVaue				- variant 
//		LPTSTR szSysName			- LPTSTR varaible containing the system name. 
// Return Value:
//		None
// ***************************************************************************
HRESULT FreeMemory(IWbemClassObject *pInClass,IWbemClassObject * pClass,IWbemClassObject * pOutInst ,
    IWbemClassObject * pInInst,IWbemServices *pIWbemServReg,VARIANT varConnectName,VARIANT varSvalue,VARIANT varHkey,VARIANT varRetVal,VARIANT varVaue,LPTSTR szSysName )
{

	HRESULT hRes = S_OK ; 
	SAFEIRELEASE(pInInst); 
	SAFEIRELEASE(pInClass);
	SAFEIRELEASE(pClass);  
	SAFEIRELEASE(pIWbemServReg); 
	SAFEFREE(szSysName);	
	hRes = VariantClear(&varConnectName);
	if(hRes != S_OK)
	{
		return hRes ; 
	}
	hRes = VariantClear(&varSvalue);
	if(hRes != S_OK)
	{
		return hRes ; 
	}
	hRes = VariantClear(&varHkey);
	if(hRes != S_OK)
	{
		return hRes ; 
	}
	hRes = VariantClear(&varVaue);
	if(hRes != S_OK)
	{
		return hRes ; 
	}
	hRes = VariantClear(&varRetVal);
	if(hRes != S_OK)
	{
		return hRes ; 
	}
	
	return S_OK ;
}

// ***************************************************************************
// Routine Description:
//		Processes enumeration of Win32_PnpSignedDriver instances 
//		  
// Arguments:
//      [ in ]  szHost					: HostName to connect to
//		[ in ]	pSystemSet				: pointer to the structure containing system properties.
//		[ in ]  szFormat				: specifies the format  
//      [ in ]  bHeader					: specifies if the header is required or not.
//
// Return Value:
//		 0   no error
//		 1   error occured while allocating memory.			
//
//  ***************************************************************************
DWORD ProcessSignedDriverInfo(CHString szHost, IEnumWbemClassObject *pSystemSet,LPTSTR szFormat,BOOL bHeader,DWORD dwSystemType,BOOL bVerbose)
{
	HRESULT hRes = S_OK;
	ULONG ulReturned = 1;
		
	//declaration  of normal variables
	IWbemClassObject *pSystem = NULL;
		
	CHString szPnpDeviceName ;
	CHString szPnpInfName ;
	CHString szPnpMfg ;
	CHString szSigned ;

	BOOL bIsSigned = FALSE;
	
	TCOLUMNS ResultHeader[ MAX_COLUMNS ];	
	TARRAY arrResults = NULL; 
	DWORD dwRow = 0;
	DWORD dwFormatType = SR_FORMAT_TABLE ;

	BOOL bVersion = FALSE ;

	// Create new Dynamic Array to hold the result
	arrResults = CreateDynamicArray();

	if(arrResults == NULL)
	{
		return EXIT_FAILURE_MALLOC ;
	}

	if( StringCompare(szFormat,TABLE_FORMAT, TRUE,sizeof(TABLE_FORMAT)) == 0 )
	{
		dwFormatType = SR_FORMAT_TABLE;
	}
	else if( StringCompare(szFormat,LIST_FORMAT, TRUE,sizeof(LIST_FORMAT)) == 0 )
	{
		dwFormatType = SR_FORMAT_LIST;
	}
	else if( StringCompare(szFormat,CSV_FORMAT, TRUE,sizeof(CSV_FORMAT)) == 0 )
	{
		dwFormatType = SR_FORMAT_CSV;
	}

	FormSignedHeader(dwFormatType,bHeader,ResultHeader);

	// loop till there are results. 
	while ( ulReturned == 1 )
	{
	
		szPnpDeviceName = NO_DATA_AVAILABLE;
		szPnpInfName = NO_DATA_AVAILABLE;
		szSigned = NO_DATA_AVAILABLE ;
		szPnpMfg = NO_DATA_AVAILABLE ;

    	    // Enumerate through the resultset.
		    hRes = pSystemSet->Next(WBEM_INFINITE,
								1,				// return just one system
								&pSystem,		// pointer to system
								&ulReturned );	// number obtained: one or zero
             
    	if ( SUCCEEDED( hRes ) && (ulReturned == 1) )
		{
	
			// initialise the variant variables to empty
			//create a new empty row with required no of  columns
			dwRow =	DynArrayAppendRow(arrResults,MAX_COLUMNS) ;
		
			try
			{
				hRes = PropertyGet(pSystem,PROPERTY_PNP_DEVICENAME,szPnpDeviceName);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_PNP_INFNAME,szPnpInfName);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet_Bool(pSystem,PROPERTY_PNP_ISSIGNED,&bIsSigned);
				ONFAILTHROWERROR(hRes);
				hRes = PropertyGet(pSystem,PROPERTY_PNP_MFG,szPnpMfg);
				ONFAILTHROWERROR(hRes);
				
			}
			catch(_com_error)
			{
				DISPLAY_MESSAGE(stderr,ERROR_GET_VALUE);
				SAFEIRELEASE(pSystem);
				return FAILURE;
			}
			
			
			// free the allocated memory
			SAFEIRELEASE(pSystem);
			if(bIsSigned)
				szSigned = TRUE_VALUE;
			else
				szSigned = FALSE_VALUE;

			DynArraySetString2( arrResults,dwRow,COL0,szPnpDeviceName,0 );  
			DynArraySetString2( arrResults,dwRow,COL1,szPnpInfName,0 );  
			DynArraySetString2( arrResults,dwRow,COL2,szSigned,0 ); 
			DynArraySetString2( arrResults,dwRow,COL3,szPnpMfg,0 ); 
			
			//this flag is to check if there are any results 
			//else display an error message.

			bVersion = TRUE ;

		} // If System Succeeded
	
				
	}// While SystemSet returning objects

	if (bVersion == FALSE)
	{
        //
        // To display custom message in case the remote system is Win2k
        // System.
        if( hRes == -2147217392)
        {
       		DISPLAY_MESSAGE(stderr,GetResString(IDS_VERSION_MISMATCH_ERROR));
    		DestroyDynamicArray(&arrResults);
            
            // free the allocated memory
		    SAFEIRELEASE(pSystem);
		    return FAILURE ;
            
        }

        //display a error message
        GetWbemErrorText(hRes);
        DISPLAY_MESSAGE(stderr,ERROR_TAG);
        DISPLAY_MESSAGE(stderr,GetReason());
        SAFEIRELEASE(pSystem);
        return FAILURE;
	}

	ShowMessage( stdout, _T( "\n" ) );
	if(bHeader)
	{
		ShowResults(MAX_SIGNED_COLUMNS, ResultHeader, dwFormatType|SR_NOHEADER,arrResults ) ;		
	}
	else
	{
		ShowResults(MAX_SIGNED_COLUMNS, ResultHeader, dwFormatType,arrResults ) ;
	}

	DestroyDynamicArray(&arrResults);
	// free the allocated memory
	SAFEIRELEASE(pSystem);
	return SUCCESS ;
	
}


/*-------------------------------------------------------------------
// 
//Routine Description:
// 
// To perform the Get .
// 
//Arguments:
// 
//    IWbemClassObject** pWmiObject[in] -- Pointer to the locator interface.
//    LPCTSTR			pszInputVal[in] -- Input string containing the desired value. 
//    PBOOL           pIsSigned[out]-- String containing the retreived value. 
//
//          information
// 
//	Return Value:
//		HRESULT : hRes  on Successfully retreiving the value.   
//			      S_FALSE on Failure in retreiving the value.
//			
//			
//			
//--------------------------------------------------------------------*/
HRESULT PropertyGet_Bool(IWbemClassObject* pWmiObject, LPCTSTR pszInputVal, PBOOL pIsSigned)
{

	HRESULT hRes = S_FALSE ;
	VARIANT vtValue ;
	VariantInit(&vtValue);
	hRes = pWmiObject->Get(pszInputVal,0,&vtValue,NULL,NULL);

	if (hRes != WBEM_S_NO_ERROR)
	{
		hRes = VariantClear(&vtValue);
		return (hRes);
	}
	if ((hRes == WBEM_S_NO_ERROR)&&(vtValue.vt != VT_NULL) && (vtValue.vt != VT_EMPTY))
	{
		if(vtValue.vt == VT_BOOL)
			if(vtValue.boolVal == -1)
				*pIsSigned = 1;
			else
				*pIsSigned = 0;

		hRes = VariantClear(&vtValue);
		if(hRes != S_OK)
		{
			return hRes ;
		}
		
		return TRUE ;
	}

	hRes = VariantClear(&vtValue);
	return S_FALSE ;
		
}




// ***************************************************************************
// Routine Description:
//		This function is used to build the header and also display the 
//		 result in the required format as specified by  the user.	
//		  
// Arguments:
//		[ in ] arrResults     : argument(s) count specified at the command prompt
//		[ in ] dwFormatType   : format flags 
//		[ in ] bHeader        : Boolean for specifying if the header is required or not.
//  
// Return Value:
//		none
//		
// ***************************************************************************
VOID FormSignedHeader(DWORD dwFormatType,BOOL bHeader,TCOLUMNS *ResultHeader)
{
	
	// Device name
	ResultHeader[COL0].dwWidth = COL_DEVICE_WIDTH ;
	ResultHeader[COL0].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL0].pFunction = NULL;
	ResultHeader[COL0].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL0].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL0].szColumn,COL_DEVICENAME );

	
	//Inf header
	ResultHeader[COL1].dwWidth = COL_INF_WIDTH  ;
	ResultHeader[COL1].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL1].pFunction = NULL;
	ResultHeader[COL1].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL1].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL1].szColumn,COL_INF_NAME );


	// Forming the IsSigned header Column
	ResultHeader[COL2].dwWidth = COL_ISSIGNED_WIDTH  ;
	ResultHeader[COL2].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL2].pFunction = NULL;
	ResultHeader[COL2].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL2].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL2].szColumn,COL_ISSIGNED );

	
	// Forming the Manufacturer header Column
	ResultHeader[COL3].dwWidth = COL_MANUFACTURER_WIDTH  ;
	ResultHeader[COL3].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL3].pFunction = NULL;
	ResultHeader[COL3].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL3].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL3].szColumn,COL_MANUFACTURER);
}

// ***************************************************************************
// Routine Description: This function checks if the current locale is supported or not.
//		  
// Arguments: [input] bLocaleChanged
//  
// Return Value: LCID of the current locale.
// 
// ***************************************************************************
LCID GetSupportedUserLocale( BOOL& bLocaleChanged )
{
	// local variables
    LCID lcid;

	// get the current locale
	lcid = GetUserDefaultLCID();

	// check whether the current locale is supported by our tool or not
	// if not change the locale to the english which is our default locale
	bLocaleChanged = FALSE;
    if ( PRIMARYLANGID( lcid ) == LANG_ARABIC || PRIMARYLANGID( lcid ) == LANG_HEBREW ||
         PRIMARYLANGID( lcid ) == LANG_THAI   || PRIMARYLANGID( lcid ) == LANG_HINDI  ||
         PRIMARYLANGID( lcid ) == LANG_TAMIL  || PRIMARYLANGID( lcid ) == LANG_FARSI )
    {
		bLocaleChanged = TRUE;
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_DEFAULT ), SORT_DEFAULT ); // 0x409;
    }

	// return the locale
    return lcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\driverquery\driverquery.h ===
// *********************************************************************************
// 
//  Copyright (c)  Microsoft Corporation
//  
//  Module Name:
//  
// 	  DriverQuery.h
//  
//  Abstract:
//  
// 	  This module contains all necessary header files required by DriverQuery.cpp module.
// 	
//  
//  Author:
//  
// 	  J.S.Vasu	 31-Oct-2000
//  
//  Revision History:
//    Created  on 31-0ct-2000 by J.S.Vasu
//	  
// *********************************************************************************



#ifndef _DRIVERQUERY
#define _DRIVERQUERY


#include <wbemidl.h> 
#include <comdef.h> 
#include <CHSTRING.h>
#include <time.h>
#include <tchar.h>
#include <lm.h>
#include <Oleauto.h> 


#define ID_HELP_START 1 


#define ID_USAGE_START		IDS_USAGE_COPYRIGHT1
#define ID_USAGE_END		IDS_USAGE_EXAMPLE32

#define ID_USAGE_BEGIN		IDS_USAGEBEGIN1
#define ID_USAGE_ENDING		IDS_USAGEEND1


#define OI_HELP				0
#define OI_SERVER			1
#define OI_USERNAME			2
#define OI_PASSWORD			3
#define OI_FORMAT			4
#define OI_HEADER			5
#define OI_VERBOSE			6
#define OI_SIGNED			7


#define MAX_OPTIONS			8

// supported options ( do not localize )
#define OPTION_HELP			_T( "?" )					
#define OPTION_SERVER		_T( "s"	)					
#define OPTION_USERNAME		_T( "u"	)					
#define OPTION_PASSWORD		_T( "p"	)					
#define OPTION_FORMAT		_T( "fo")			
#define OPTION_HEADER		_T( "nh")			
#define OPTION_VERBOSE		_T( "v" )			
#define OPTION_SIGNED		_T( "si")



//localized error messages.
#define ERROR_USERNAME_BUT_NOMACHINE	GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME	GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_COM_INTIALIZE				GetResString(IDS_ERROR_COM_INTIALIZE)
#define ERROR_SECURITY_INTIALIZE		GetResString(IDS_ERROR_COM_SECURITY_INITIALIZE)
#define ERROR_ENUMERATE_INSTANCE		GetResString(IDS_ERROR_COM_ENUMERATE_INSTANCE)
#define ERROR_CONNECT					GetResString(IDS_ERROR_CONNECT)
#define ERROR_SYNTAX					GetResString(IDS_INVALID_SYNTAX)
#define ERROR_RETREIVE_INFO				GetResString(IDS_ERROR_RETREIVE_INFO)
#define ERROR_INVALID_CREDENTIALS		GetResString(IDS_INVALID_CREDENTIALS)
#define ERROR_INVALID_FORMAT			GetResString(IDS_ERROR_INVALID_FORMAT)
#define ERROR_TAG						GetResString(IDS_ERROR_TAG)
#define ERROR_GET_VALUE					GetResString(IDS_ERROR_GET)
#define WARNING_TAG						GetResString(IDS_WARNING_TAG)

#define LIST_FORMAT						GetResString(IDS_FORMAT_LIST)	
#define TABLE_FORMAT					GetResString(IDS_FORMAT_TABLE)	
#define CSV_FORMAT						GetResString(IDS_FORMAT_CSV)	
#define FORMAT_VALUES					GetResString(IDS_FORMAT_VALUES)
#define DRIVER_TAG						GetResString(IDS_DRIVER_TAG)

#define	ERROR_AUTHENTICATION_FAILURE    GetResString(IDS_ERROR_AUTHENTICATION_FAILURE)
#define ERROR_LOCAL_CREDENTIALS			GetResString(IDS_ERROR_LOCAL_CRED)
#define ERROR_WMI_FAILURE	            GetResString(IDS_ERROR_WMI_FAILURE)  

#define IGNORE_LOCALCREDENTIALS			GetResString(IDS_IGNORE_LOCAL_CRED)
#define INPUT_PASSWORD					GetResString( IDS_INPUT_PASSWORD )


#define COL_HOSTNAME                    GetResString(IDS_COL_HOSTNAME) 
#define COL_FILENAME					GetResString(IDS_COL_FILENAME)
#define COL_SIGNED						GetResString(IDS_SIGNED)
#define COL_DISPLAYNAME					GetResString(IDS_COL_DISPLAYNAME)
#define COL_DESCRIPTION					GetResString(IDS_COL_DESCRIPTION)
#define COL_DRIVERTYPE					GetResString(IDS_COL_DRIVERTYPE)
#define COL_STARTMODE					GetResString(IDS_COL_STARTMODE)
#define COL_STATE						GetResString(IDS_COL_STATE)
#define COL_STATUS						GetResString(IDS_COL_STATUS)
#define COL_ACCEPTSTOP					GetResString(IDS_COL_ACCEPTSTOP)
#define COL_ACCEPTPAUSE					GetResString(IDS_COL_ACCEPTPAUSE)
#define COL_MEMORYUSAGE					GetResString(IDS_COL_MEMORYUSAGE)
#define COL_PAGEDPOOL					GetResString(IDS_COL_PAGEDPOOL)
#define COL_NONPAGEDPOOL				GetResString(IDS_COL_NONPAGEDPOOL)
#define COL_EXECCODE					GetResString(IDS_COL_EXECCODE)
#define COL_NBSS						GetResString(IDS_COL_NBSS)
#define COL_BSS							GetResString(IDS_COL_BSS)
#define COL_LINKDATE					GetResString(IDS_COL_LINKDATE)
#define COL_LOCATION					GetResString(IDS_COL_LOCATION) 
#define COL_LINKDATE					GetResString(IDS_COL_LINKDATE)
#define COL_LOCATION					GetResString(IDS_COL_LOCATION) 
#define COL_INITSIZE					GetResString(IDS_COL_INITSIZE)
#define COL_PAGESIZE					GetResString(IDS_COL_PAGESIZE)
#define ERROR_ALLOC_FAILURE				GetResString(IDS_ALLOC_FAILURE)
#define ERROR_NO_HEADERS				GetResString(IDS_NO_HEADERS)
#define ERROR_INVALID_SERVER 				GetResString(IDS_INVALID_SERVER)
#define ERROR_INVALID_USER 				GetResString(IDS_INVALID_USER)
#define INVALID_SIGNED_SYNTAX			GetResString(IDS_INVALID_SIGNED_SYNTAX)

#define COL_HOSTNAME_WIDTH              AsLong(GetResString(IDS_COL_HOSTNAME_SIZE),10)
#define COL_FILENAME_WIDTH  			AsLong(GetResString(IDS_COL_FILENAME_SIZE),10)
#define COL_SIGNED_WIDTH				AsLong(GetResString(IDS_SIGNED_SIZE),10)
#define COL_DISPLAYNAME_WIDTH			AsLong(GetResString(IDS_COL_DISPLAYNAME_SIZE),10)
#define COL_DESCRIPTION_WIDTH			AsLong(GetResString(IDS_COL_DESCRIPTION_SIZE),10)
#define COL_DRIVERTYPE_WIDTH			AsLong(GetResString(IDS_COL_DRIVERTYPE_SIZE),10)
#define COL_STARTMODE_WIDTH				AsLong(GetResString(IDS_COL_STARTMODE_SIZE),10)
#define COL_STATE_WIDTH					AsLong(GetResString(IDS_COL_STATE_SIZE),10)
#define COL_STATUS_WIDTH				AsLong(GetResString(IDS_COL_STATUS_SIZE),10)
#define COL_ACCEPTSTOP_WIDTH			AsLong(GetResString(IDS_COL_ACCEPTSTOP_SIZE),10)
#define COL_ACCEPTPAUSE_WIDTH			AsLong(GetResString(IDS_COL_ACCEPTPAUSE_SIZE),10)
#define COL_MEMORYUSAGE_WIDTH			AsLong(GetResString(IDS_COL_MEMORYUSAGE_SIZE),10)
#define COL_PAGEDPOOL_WIDTH				AsLong(GetResString(IDS_COL_PAGEDPOOL_SIZE),10)
#define COL_NONPAGEDPOOL_WIDTH			AsLong(GetResString(IDS_COL_NONPAGEDPOOL_SIZE),10)
#define COL_EXECCODE_WIDTH 				AsLong(GetResString(IDS_COL_EXECCODE_SIZE),10)
#define COL_NBSS_WIDTH					AsLong(GetResString(IDS_COL_NBSS_SIZE),10)
#define COL_BSS_WIDTH					AsLong(GetResString(IDS_COL_BSS_SIZE),10)
#define COL_LINKDATE_WIDTH				AsLong(GetResString(IDS_COL_LINKDATE_SIZE),10)
#define COL_LOCATION_WIDTH				AsLong(GetResString(IDS_COL_LOCATION_SIZE),10)

#define COL_INITSIZE_WIDTH				AsLong(GetResString(IDS_COL_INITSIZE_SIZE),10)
#define COL_PAGESIZE_WIDTH				AsLong(GetResString(IDS_COL_PAGESIZE_SIZE),10)


#define COL_DEVICE_WIDTH				AsLong(GetResString(IDS_COL_DEVICE_WIDTH),10)
#define	COL_INF_WIDTH					AsLong(GetResString(IDS_COL_INF_WIDTH),10)
#define COL_ISSIGNED_WIDTH				AsLong(GetResString(IDS_COL_ISSIGNED_WIDTH),10)
#define COL_MANUFACTURER_WIDTH			AsLong(GetResString(IDS_COL_MANUFACTURER_WIDTH),10)

#define MAX_COLUMNS  16
#define MAX_SIGNED_COLUMNS 4

#define COL0						0
#define COL1						1
#define COL2						2
#define COL3						3
#define COL4						4
#define COL5						5
#define COL6						6
#define COL7						7
#define COL8						8
#define COL9						9
#define COL10						10
#define COL11						11
#define COL12						12
#define COL13						13
#define COL14						14
#define COL15						15
#define COL16						16
#define COL17						17
#define COL18						18



#define SUCCESS 0 
#define FAILURE 1

#define EXTN_BSS  ".bss"
#define EXTN_PAGE "PAGE"
#define EXTN_EDATA ".edata"
#define EXTN_IDATA ".idata"
#define EXTN_RSRC  ".rsrc"
#define EXTN_INIT "INIT"

 
#define TOKEN_DOLLAR      _T('$')
#define COLON_SYMBOL      _T(":")
#define TOKEN_BACKSLASH   _T("\\")
#define TOKEN_BACKSLASH2  _T("\\\\")
#define TOKEN_BACKSLASH3  _T("\\\\\\")
#define CIMV2_NAMESPACE	  _T("ROOT\\CIMV2")

#define DEFAULT_NAMESPACE _T("ROOT\\DEFAULT")
#define CIMV2_NAME_SPACE _T("ROOT\\CIMV2")


#define NO_DATA_AVAILABLE _T("N/A")
#define FALSE_VALUE		  _T("FALSE")
#define TRUE_VALUE		  _T("TRUE")
#define IDENTIFIER_VALUE  _T("Identifier")
#define X86_MACHINE		  _T("x86")
#define TOKEN_EMPTYSTRING _T("")
#define LANGUAGE_WQL	   _T("WQL")

#define WQL_QUERY	   _T("select * from Win32_PnpSignedDriver where DeviceName != NULL")

#define TOKEN_CONSTANT    11
#define GROUP_FORMAT_32   L"3;2;0" 
#define GROUP_32_VALUE    32
#define EXIT_SUCCESSFUL	  3
#define EXIT_FAILURE_MALLOC	  5
#define EXIT_FAILURE_FORMAT	  2
#define EXIT_FAILURE_RESULTS  4

#define PROPERTY_NAME   L"Name"
#define PROPERTY_SYSTEMNAME L"SystemName"
#define PROPERTY_STARTMODE  L"StartMode"
#define PROPERTY_DISPLAYNAME  L"DisplayName"
#define PROPERTY_DESCRIPTION  L"Description"
#define PROPERTY_STATUS L"Status"
#define PROPERTY_STATE L"State"
#define PROPERTY_ACCEPTPAUSE  L"AcceptPause"
#define PROPERTY_ACCEPTSTOP L"AcceptStop"
#define PROPERTY_SERVICETYPE L"ServiceType"
#define PROPERTY_PATHNAME L"PathName"
#define PROPERTY_SYSTEM_TYPE L"SystemType"

#define PROPERTY_GETSTRINGVAL L"GetStringValue"
#define PROPERTY_RETURNVAL L"ReturnValue"


#define STD_REG_CLASS					L"StdRegProv"
#define REG_METHOD						L"GetStringValue"
#define HKEY_VALUE						L"hDefKey"
#define REG_SUB_KEY_VALUE				L"sSubKeyName"
#define REG_VALUE_NAME					L"sValueName"
#define REG_RETURN_VALUE				L"sValue"
#define REG_PATH						L"HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0"
#define REG_SVALUE					   L"Identifier"
#define HEF_KEY_VALUE					2147483650

#define ERROR_WMI_VALUES 1
#define SYSTEM_64_BIT 2
#define SYSTEM_32_BIT 3
#define ERROR_RETREIVE_REGISTRY 4
#define ERROR_WMI_CONNECT 5
#define ERROR_GET 6
#define CLASS_SYSTEMDRIVER L"Win32_SystemDriver"
#define CLASS_COMPUTERSYSTEM L"Win32_ComputerSystem"
#define CLASS_PNPSIGNEDDRIVER L"Win32_PnpSignedDriver"

#define PROPERTY_PNP_DEVICENAME L"DeviceName"
#define PROPERTY_PNP_INFNAME L"InfName"
#define PROPERTY_PNP_ISSIGNED L"IsSigned"

//#define PROPERTY_PNP_MFG L"Mfg"
#define PROPERTY_PNP_MFG L"Manufacturer"


// Registry key information
#define HKEY_MACHINE_INFO   2147483650  // registry value for HKEY_LOCAL_MACHINE
#define SUBKEY _T("HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0") 


// User Defined Macros
#define SAFEDELETE(pObj) \
	if (pObj) \
	{	\
		delete[] pObj; \
		pObj = NULL; \
	}


// SAFEIRELEASE
#define SAFEIRELEASE(pIObj)	\
	if (pIObj)	\
	{	\
		pIObj->Release();	\
		pIObj = NULL;	\
	}


//SAFEBSTRFREE
#define SAFEBSTRFREE(bstrVal) \
	if (bstrVal) \
	{	\
		SysFreeString(bstrVal); \
		bstrVal = NULL; \
	}


#define SAFEFREE(szPtr)\
	if (szPtr!= NULL)\
	{ \
	   free(szPtr); \
	   szPtr = NULL; \
    }

#define ONFAILTHROWERROR(hResult) \
	if (FAILED(hResult)) \
	{	\
		_com_issue_error(hResult); \
	}

#define SAFE_RELEASE( interfacepointer )	\
	if ( (interfacepointer) != NULL )	\
	{	\
		(interfacepointer)->Release();	\
		(interfacepointer) = NULL;	\
	}	\

#define SAFE_EXECUTE( statement )				\
	hRes = statement;		\
	if ( FAILED( hRes ) )	\
	{	\
		_com_issue_error( hRes );	\
	}	\

#define EMPTY_LINE _T("\n")	

// structure to store the data fetched using the API's
typedef struct _MODULE_DATA 
{
	ULONG ulCodeSize;
	ULONG ulDataSize;
	ULONG ulBssSize;
	ULONG ulPagedSize;

	ULONG ulInitSize;
	ULONG ulImportDataSize ;
	ULONG ulExportDataSize ;
	ULONG ulResourceDataSize;

	__MAX_SIZE_STRING szTimeDateStamp ;

} MODULE_DATA, *PMODULE_DATA;


  

// function prototypes

DWORD QueryDriverInfo(LPTSTR szServer,LPTSTR szUserName,LPTSTR szPassword,LPTSTR szFormat,BOOL bHeader,BOOL bVerbose,IWbemLocator* pIWbemLocator,COAUTHIDENTITY* pAuthIdentity,IWbemServices* pIWbemServReg ,BOOL bSigned );
DWORD ProcessCompSysEnum(CHString szHostName,IEnumWbemClassObject *pSystemSet,LPTSTR szFormat,BOOL bHeader,DWORD dwSystemType,BOOL bVerbose);

BOOL ProcessOptions(LONG argc,LPCTSTR argv[],PBOOL pbShowUsage,LPTSTR *pszServer,LPTSTR *pszUserName,LPTSTR *pszPassword,LPTSTR pszFormat,PBOOL pbHeader, PBOOL bNeedPassword,PBOOL pbVerbose,PBOOL pbSigned);

VOID ShowUsage() ;
BOOL GetApiInfo(LPTSTR szHostName,LPCTSTR szPath,PMODULE_DATA Mod,DWORD dwSystemType);
VOID PrintModuleLine(PMODULE_DATA Current);
VOID FormHeader(DWORD dwFormatType,BOOL bHeader,TCOLUMNS *ResultHeader,BOOL bVerbose);
SCODE ParseAuthorityUserArgs1(BSTR & AuthArg, BSTR & UserArg,BSTR & Authority,BSTR & User);
BOOL bIsNT();


BOOL FormatAccToLocale(	NUMBERFMT  *pNumberFmt,LPTSTR* pszGroupSep,LPTSTR* pszDecimalSep,LPTSTR* pszGroupThousSep);
BOOL GetInfo( LCTYPE lctype, LPTSTR* pszData );

BOOL InitialiseCom(IWbemLocator** ppIWbemLocator);
DWORD GetSystemType(COAUTHIDENTITY* pAuthIdentity,IWbemServices* pIWbemServReg);

HRESULT PropertyGet(IWbemClassObject* pWmiObject,LPCTSTR pszInputVal,CHString &szOutPutVal);



SCODE ParseAuthorityUserArgs( BSTR& bstrAuthArg,
							  BSTR& bstrUserArg,
							  BSTR& bstrUser ) ;

HRESULT SetSecurity( IUnknown *pIUnknown,
					 LPCTSTR lpDomain,
					 LPCTSTR lpUser, 
					 LPCTSTR lpPassword,
					 BOOL  bLocCred );

HRESULT FreeMemory(IWbemClassObject *pInClass,IWbemClassObject * pClass,IWbemClassObject * pOutInst ,
    IWbemClassObject * pInInst,IWbemServices *pIWbemServReg,VARIANT varConnectName,VARIANT varSvalue,VARIANT varHkey,VARIANT varRetVal,VARIANT varVaue,LPTSTR szSysName );

BOOL IsValidUserEx( LPCWSTR pwszUser );

#define GetWbemErrorText( hr )			WMISaveError( hr )

HRESULT SetInterfaceSecurity( IUnknown *pInterface, COAUTHIDENTITY *pAuthIdentity );

BOOL ConnectWmiEx( IWbemLocator   *pLocator, 
				   IWbemServices  **ppServices,
				   const CHString &strServer,
				   CHString       &strUserName,
				   CHString       &strPassword, 
				   COAUTHIDENTITY **ppAuthIdentity, 
				   BOOL			  bNeedPassword = FALSE,
		 		   LPCWSTR		  pszNamespace = CIMV2_NAME_SPACE,
				   BOOL			 *pbLocalSystem = NULL );


DWORD ProcessSignedDriverInfo(CHString szHost, IEnumWbemClassObject *pSystemSet,LPTSTR szFormat,BOOL bHeader,DWORD dwSystemType,BOOL bVerbose);
HRESULT PropertyGet_Bool(IWbemClassObject* pWmiObject, LPCTSTR pszInputVal, PBOOL pIsSigned);
VOID FormSignedHeader(DWORD dwFormatType,BOOL bHeader,TCOLUMNS *ResultHeader);

VOID WMISaveError( HRESULT hResError );

LCID GetSupportedUserLocale( BOOL& bLocaleChanged ) ;

#define COL_DEVICENAME				GetResString(IDS_COL_DEVICENAME)
#define COL_INF_NAME				GetResString(IDS_COL_INF_NAME)
#define COL_ISSIGNED				GetResString(IDS_COL_ISSIGNED)
#define COL_MANUFACTURER			GetResString(IDS_COL_MANUFACTURER)

// inline functions
inline VOID WMISaveError( _com_error  &e )
{
	WMISaveError( e.Error() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\driverquery\resource.h ===
#define IDS_ERROR_USERNAME_BUT_NOMACHINE		101
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME		102
#define IDS_ERROR_COM_INTIALIZE					103
#define IDS_ERROR_COM_SECURITY_INITIALIZE		104
#define IDS_ERROR_COM_ENUMERATE_INSTANCE		105
#define IDS_ERROR_CONNECT						106
#define IDS_INVALID_SYNTAX						107
#define IDS_ERROR_RETREIVE_INFO					108
#define IDS_WMI_CREDENTIALS						109
#define IDS_INVALID_CREDENTIALS					110
#define IDS_ERROR_INVALID_FORMAT				111
#define IDS_ALLOC_FAILURE						112
#define IDS_ERROR_AUTHENTICATION_FAILURE		113
#define IDS_ERROR_LOCAL_CRED					114
#define IDS_ERROR_WMI_FAILURE					115
#define IDS_INVALID_SIGNED_SYNTAX				116
#define IDS_ERROR_GET							117
#define IDS_NO_HEADERS							118
#define IDS_INVALID_SERVER						119
#define IDS_INVALID_USER						120

#define IDS_IGNORE_LOCAL_CRED					151

#define IDS_DRIVER_TAG							201
#define IDS_ERROR_TAG							202
#define IDS_WARNING_TAG							203
#define IDS_INPUT_PASSWORD						204

#define IDS_NO_DRIVERS_FOUND					251

#define IDS_FORMAT_LIST							301
#define IDS_FORMAT_TABLE						302
#define IDS_FORMAT_CSV							303
#define IDS_FORMAT_VALUES						304

#define IDS_COL_HOSTNAME						351
#define IDS_COL_FILENAME						352
#define IDS_COL_SIGNED							353
#define IDS_COL_DISPLAYNAME						354
#define IDS_COL_DESCRIPTION						355
#define IDS_COL_DRIVERTYPE						356
#define IDS_COL_STARTMODE						357
#define IDS_COL_STATE							358
#define IDS_COL_STATUS							359
#define IDS_COL_ACCEPTSTOP						360
#define IDS_COL_ACCEPTPAUSE						361			
#define IDS_COL_MEMORYUSAGE						362			
#define IDS_COL_PAGEDPOOL						363			
#define IDS_COL_NONPAGEDPOOL					364			
#define IDS_COL_EXECCODE						365			
#define IDS_COL_NBSS							366			
#define IDS_COL_BSS								367			
#define IDS_COL_LINKDATE						368			
#define IDS_COL_INITSIZE						369			
#define IDS_COL_PAGESIZE						370			
#define IDS_COL_LOCATION						371
#define IDS_COL_DEVICENAME						372
#define IDS_COL_INF_NAME						373
#define IDS_COL_ISSIGNED						374
#define IDS_COL_MANUFACTURER					375

#define IDS_COL_HOSTNAME_SIZE					401	
#define IDS_COL_FILENAME_SIZE					402	
#define IDS_SIGNED_SIZE							403	
#define IDS_COL_DISPLAYNAME_SIZE				404	
#define IDS_COL_DESCRIPTION_SIZE				405	
#define IDS_COL_DRIVERTYPE_SIZE					406	
#define IDS_COL_STARTMODE_SIZE					407	
#define IDS_COL_STATE_SIZE						408	
#define IDS_COL_STATUS_SIZE						409	
#define IDS_COL_ACCEPTSTOP_SIZE					410	
#define IDS_COL_ACCEPTPAUSE_SIZE				411	
#define IDS_COL_MEMORYUSAGE_SIZE				412	
#define IDS_COL_PAGEDPOOL_SIZE					413	
#define IDS_COL_NONPAGEDPOOL_SIZE				414	
#define IDS_COL_EXECCODE_SIZE					415	
#define IDS_COL_NBSS_SIZE						416	
#define IDS_COL_BSS_SIZE						417	
#define IDS_COL_LINKDATE_SIZE					418	
#define IDS_COL_LOCATION_SIZE					419	
#define IDS_COL_INITSIZE_SIZE					420	
#define IDS_COL_PAGESIZE_SIZE					421	
#define IDS_COL_DEVICE_WIDTH					422	
#define IDS_COL_INF_WIDTH						423	
#define IDS_COL_ISSIGNED_WIDTH					424	
#define IDS_COL_MANUFACTURER_WIDTH				425	

#define IDS_USAGEBEGIN1							501
#define IDS_STRING81							502
#define IDS_STRING82							503
#define IDS_STRING83							504
#define IDS_STRING84							505
#define IDS_STRING85							506
#define IDS_STRING86							507
#define IDS_STRING87							508
#define IDS_STRING88							509
#define IDS_STRING89							510
#define IDS_STRING90							511
#define IDS_STRING91							512
#define IDS_STRING92							513
#define IDS_STRING93							514
#define IDS_STRING94							515
#define IDS_STRING95							516
#define IDS_STRING96							517
#define IDS_STRING97							518
#define IDS_STRING98							519
#define IDS_STRING99							520
#define IDS_STRING100							521
#define IDS_STRING101							522
#define IDS_STRING102							523
#define IDS_STRING103							524
#define IDS_STRING104							525
#define IDS_STRING105							526
#define IDS_USAGEEND1							527

#define IDS_VERSION_MISMATCH_ERROR				530
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\doskey\doskey.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

        doskey.cxx

Abstract:

        Edits command lines, recalls Windows 2000 commands, and creates macros.

Author:

        Norbert P. Kusters (norbertk) 02-April-1992

Revision History:

--*/

#include "ulib.hxx"
#include "error.hxx"

#include "arg.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"
#include "filestrm.hxx"
#include "system.hxx"
#include "file.hxx"

#include "ulibcl.hxx"

extern "C" {
#include "conapi.h"
#include <ctype.h>
#ifdef FE_SB // isspace patch
// isspace() causes access violation when x is Unicode char
// that is not included in ASCII charset.
#define isspace(x)     ( (x) == ' ' ) ? TRUE : FALSE
#endif
};

VOID
StripQuotesFromString(
    IN  PWSTRING String
    )
/*++

Routine Description:

    This routine removes leading and trailing quote marks (if
    present) from a quoted string.  If the string is not a quoted
    string, it is left unchanged.

--*/
{
    if( String->QueryChCount() >= 2    &&
        String->QueryChAt( 0 ) == '\"' &&
        String->QueryChAt( String->QueryChCount() - 1 ) == '\"' ) {

        String->DeleteChAt( String->QueryChCount() - 1 );
        String->DeleteChAt( 0 );
    }
}


BOOLEAN
DisplayPackedString(
    IN      PCWSTR      PackedStrings,
    IN      ULONG       PackedStringsLength,
    IN      BOOLEAN     IndentStrings,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine outputs the given strings.  One line per string.

Arguments:

    PackedStrings       - Supplies the null-separated strings to output.
    PackedStringsLength - Supplies the number of characters in the strings.
    NumIndentSpaces     - Supplies whether or not to indent the strings.
    Message             - Supplies the outlet for the strings.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING display_string;
    DSTRING raw_string;
    ULONG   i;
    PCWSTR  p;

    p = PackedStrings;

    for (i = 0; i < PackedStringsLength; i++) {

        if (i > 0 && p[i - 1]) {
            continue;
        }

        if (IndentStrings) {

            if (!display_string.Initialize("    ")) {
                return FALSE;
            }
        } else {

            if (!display_string.Initialize("")) {
                return FALSE;
            }
        }


        if (!raw_string.Initialize(&p[i]) ||
            !display_string.Strcat(&raw_string)) {

            return FALSE;
        }

        Message->Set(MSG_ONE_STRING_NEWLINE);
        Message->Display("%W", &display_string);
    }

    return TRUE;
}


BOOLEAN
QuerySourceAndTarget(
    IN  PCWSTRING   MacroLine,
    OUT PWSTR*      Source,
    OUT PWSTR*      Target
    )
/*++

Routine Description:

    This routine computes the sources and target string from the given macro line
    by isolating the '=' and then making sure that the source is a single token.

Arguments:

    MacroLine   - Supplies the macro.
    Source      - Returns the source part of the macro.
    Target      - Returns the target part of the macro.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG    src_start, src_end, dst_start;
    ULONG   i, n;
    WCHAR   w;

    *Source = NULL;
    *Target = NULL;

    i = 0;
    n = MacroLine->QueryChCount();

    for (; i < n; i++) {
        w = MacroLine->QueryChAt(i);
        if (!isspace(w)) {
            break;
        }
    }

    src_start = i;

    for (; i < n; i++) {
        w = MacroLine->QueryChAt(i);
        if (isspace(w) || w == '=') {
            break;
        }
    }

    src_end = i;

    if (src_start == src_end) {
        return FALSE;
    }

    for (; i < n; i++) {
        w = MacroLine->QueryChAt(i);
        if (!isspace(w)) {
            break;
        }
    }

    if (w != '=') {
        return FALSE;
    }

    i++;

    for (; i < n; i++) {
        w = MacroLine->QueryChAt(i);
        if (!isspace(w)) {
            break;
        }
    }

    dst_start = i;

    *Source = MacroLine->QueryWSTR(src_start, src_end - src_start);
    *Target = MacroLine->QueryWSTR(dst_start);

    if (!*Source || !*Target) {
        DELETE(*Source);
        DELETE(*Target);
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
DisplayMacros(
    IN      PWSTR       TargetExe,
    IN      BOOLEAN     IndentString,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine displays the macros for the given exe.

Arguments:

    TargetExe       - Supplies the exe for which to display the macros.
    IndentStrings   - Supplies whether or not to indent the macro strings.
    Message         - Supplies an outlet for the macro strings.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   buffer_length = 0;
    PWSTR   buffer;

    buffer_length = GetConsoleAliasesLength(TargetExe);
    if (!(buffer = (PWCHAR) MALLOC(buffer_length + 1))) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (buffer_length) {
        buffer_length = GetConsoleAliases(buffer, buffer_length, TargetExe);
    }

    if (!DisplayPackedString(buffer, buffer_length/sizeof(WCHAR),
                             IndentString, Message)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    FREE(buffer);

    return TRUE;
}


BOOLEAN
DisplayAllMacros(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine displays all of the macros for all of the exes which have macros
    defined for them.

Arguments:

    Message - Supplies an outlet for the macros.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR   exes_buffer;
    ULONG   exes_length;
    ULONG   i;
    DSTRING exe_name;
    DSTRING display_name;

    exes_length = GetConsoleAliasExesLength();
    if (!(exes_buffer = (PWSTR) MALLOC(exes_length + 1))) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (exes_length) {
        exes_length = GetConsoleAliasExes(exes_buffer, exes_length);
    }

    exes_length /= sizeof(WCHAR);

    for (i = 0; i < exes_length; i++) {

        if (i > 0 && exes_buffer[i - 1]) {
            continue;
        }

        if (!exe_name.Initialize(&exes_buffer[i]) ||
            !display_name.Initialize("[") ||
            !display_name.Strcat(&exe_name) ||
            !exe_name.Initialize("]") ||
            !display_name.Strcat(&exe_name)) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        Message->Set(MSG_ONE_STRING_NEWLINE);
        Message->Display("%W", &display_name);

        if (!DisplayMacros(&exes_buffer[i], TRUE, Message)) {
            return FALSE;
        }

        Message->Set(MSG_BLANK_LINE);
        Message->Display();
    }

    return TRUE;
}


BOOLEAN
ReadInMacrosFromFile(
    IN      PPATH       FilePath,
    IN      PWSTR       TargetExe,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine reads in the macros in the given file.  The file must have the same
    format as the output from DOSKEY /macros or DOSKEY /macros:all.

Arguments:

    FilePath    - Supplies the file with the macros.
    TargetExe   - Supplies the exe for which the unclaimed macros are.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PFSN_FILE       file;
    PFILE_STREAM    file_stream;
    DSTRING         line;
    PWSTR           target_exe;
    DSTRING         target_string;
    PWSTR           source, target;

    if (!(file = SYSTEM::QueryFile(FilePath)) ||
        !(file_stream = file->QueryStream(READ_ACCESS))) {

        DELETE(file);

        Message->Set(MSG_ATTRIB_FILE_NOT_FOUND);
        Message->Display("%W", FilePath->GetPathString());
        return FALSE;
    }


    // Set up the target exe.

    if (!line.Initialize("") ||
        !target_string.Initialize(TargetExe) ||
        !(target_exe = target_string.QueryWSTR())) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    while (!file_stream->IsAtEnd() && file_stream->ReadLine(&line)) {

        // First see if the current line will define a new exe name.

        if (!line.QueryChCount()) {
            continue;
        }

        if (line.QueryChAt(0) == '[' &&
            line.Strchr(']') != INVALID_CHNUM &&
            line.Strchr(']') > 1) {

            DELETE(target_exe);
            if (!target_string.Initialize(&line, 1, line.Strchr(']') - 1) ||
                !(target_exe = target_string.QueryWSTR())) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            continue;
        }


        if (!QuerySourceAndTarget(&line, &source, &target) ||
            !AddConsoleAlias(source, *target ? target : NULL, target_exe)) {

            Message->Set(MSG_DOSKEY_INVALID_MACRO_DEFINITION);
            Message->Display();

            continue;
        }
    }

    DELETE(file_stream);
    DELETE(file);

    return TRUE;
}

int __cdecl
main(
        )
/*++

Routine Description:

    This routine provides equivalent functionality to DOS 5's DOSKEY utility.

Arguments:

    None.

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    STREAM_MESSAGE          msg;
    ARGUMENT_LEXEMIZER      arglex;
    ARRAY                   lex_array;
    ARRAY                   arg_array;
    STRING_ARGUMENT         progname;
    FLAG_ARGUMENT           help;
    FLAG_ARGUMENT           reinstall;
    LONG_ARGUMENT           bufsize;
    LONG_ARGUMENT           listsize;
    STRING_ARGUMENT         m_plus;
    FLAG_ARGUMENT           m;
    STRING_ARGUMENT         macros_plus;
    FLAG_ARGUMENT           macros;
    FLAG_ARGUMENT           history;
    FLAG_ARGUMENT           h;
    FLAG_ARGUMENT           insert;
    FLAG_ARGUMENT           overstrike;
    STRING_ARGUMENT         exename;
    PATH_ARGUMENT           filename;
    REST_OF_LINE_ARGUMENT   macro;
    PWSTRING                pwstring;
    PWSTR                   target_exe;
    PWSTR                   source, target;
    PWSTR                   buffer;
    ULONG                   buffer_length;
    DSTRING                 all_string;


    //
    // DOSKEY /INSERT | /OVERSTRIKE changes the keyboard mode
    // and we do not want the keyboard mode to be restored on exit
    //
    Get_Standard_Input_Stream()->DoNotRestoreConsoleMode();

    // Initialize the error stack and the stream message object.

    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {

                return 1;
    }


    // Initialize the parsing machinery.

    if (!lex_array.Initialize() ||
        !arg_array.Initialize() ||
        !arglex.Initialize(&lex_array)) {

        return 1;
    }

    arglex.SetCaseSensitive(FALSE);
    arglex.PutStartQuotes( "\"" );
    arglex.PutEndQuotes( "\"" );
    arglex.PutSeparators( " \t" );


    // Tokenize the command line.

    if (!arglex.PrepareToParse()) {

        return 1;
    }


    // Initialize the argument patterns to be accepted.

    if (!progname.Initialize("*") ||
        !help.Initialize("/?") ||
        !reinstall.Initialize("/reinstall") ||
        !bufsize.Initialize("/bufsize=*") ||
        !listsize.Initialize("/listsize=*") ||
        !macros_plus.Initialize("/macros:*") ||
        !m_plus.Initialize("/m:*") ||
        !macros.Initialize("/macros") ||
        !m.Initialize("/m") ||
        !history.Initialize("/history") ||
        !h.Initialize("/h") ||
        !insert.Initialize("/insert") ||
        !overstrike.Initialize("/overstrike") ||
        !exename.Initialize("/exename=*") ||
        !filename.Initialize("/macrofile=*") ||
        !macro.Initialize()) {

        return 1;
    }


    // Feed the arguments into the argument array.

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&help) ||
        !arg_array.Put(&reinstall) ||
        !arg_array.Put(&bufsize) ||
        !arg_array.Put(&listsize) ||
        !arg_array.Put(&macros_plus) ||
        !arg_array.Put(&m_plus) ||
        !arg_array.Put(&macros) ||
        !arg_array.Put(&m) ||
        !arg_array.Put(&history) ||
        !arg_array.Put(&h) ||
        !arg_array.Put(&insert) ||
        !arg_array.Put(&overstrike) ||
        !arg_array.Put(&exename) ||
        !arg_array.Put(&filename) ||
        !arg_array.Put(&macro)) {

        return 1;
    }


    // Parse the command line.

    if (!arglex.DoParsing(&arg_array)) {

        msg.Set(MSG_INVALID_PARAMETER);
        msg.Display("%W", pwstring = arglex.QueryInvalidArgument());
        DELETE(pwstring);
        return 1;
    }


    // Interpret the command line.

    if (bufsize.IsValueSet()) {

        msg.Set(MSG_DOSKEY_CANT_DO_BUFSIZE);
        msg.Display();
    }


    if (help.QueryFlag()) {

        msg.Set(MSG_DOSKEY_HELP);
        msg.Display();
        return 0;
    }


    if ((m.QueryFlag() || macros.QueryFlag()) &&
        (macros_plus.IsValueSet() || m_plus.IsValueSet()) ||
        (macros_plus.IsValueSet() && m_plus.IsValueSet())) {

        msg.Set(MSG_INCOMPATIBLE_PARAMETERS);
        msg.Display();
        return 1;
    }


    // Compute the target exe name.

    if (exename.IsValueSet()) {

        StripQuotesFromString( (PWSTRING)exename.GetString() );
        if (!(target_exe = exename.GetString()->QueryWSTR())) {
            return 1;
        }

    } else {

        target_exe = (PWSTR) L"cmd.exe";
    }


    // Interpret reinstall switch.

    if (reinstall.QueryFlag()) {

        ExpungeConsoleCommandHistory(target_exe);
    }


    // Interpret list size switch.

    if (listsize.IsValueSet()) {
        if (!SetConsoleNumberOfCommands(listsize.QueryLong(), target_exe)) {
            msg.Set(MSG_DOSKEY_CANT_SIZE_LIST);
            msg.Display();
            return 1;
        }
    }


    // Interpret insert and overstrike switches.

    if (insert.QueryFlag()) {
        SetConsoleCommandHistoryMode(0);
    }

    if (overstrike.QueryFlag()) {
        SetConsoleCommandHistoryMode(CONSOLE_OVERSTRIKE);
    }


    // Interpret the macro if any.

    if (macro.IsValueSet()) {

        if (!QuerySourceAndTarget(macro.GetRestOfLine(), &source, &target) ||
            !AddConsoleAlias(source, *target ? target : NULL, target_exe)) {

            msg.Set(MSG_DOSKEY_INVALID_MACRO_DEFINITION);
            msg.Display();
        }

        DELETE(source);
        DELETE(target);
    }


    // pull the stuff out from the file if provided.

    if (filename.IsValueSet()) {

        StripQuotesFromString((PWSTRING)filename.GetPath()->GetPathString());
        if (!ReadInMacrosFromFile(filename.GetPath(), target_exe, &msg)) {
            return 1;
        }
    }


    // Print out history buffer.

    if (history.QueryFlag() || h.QueryFlag()) {

        buffer_length = GetConsoleCommandHistoryLength(target_exe);
        if (!(buffer = (PWSTR) MALLOC(buffer_length))) {
            msg.Set(MSG_CHK_NO_MEMORY);
            msg.Display();
            return 1;
        }

        if (buffer_length) {
            buffer_length = GetConsoleCommandHistory(buffer,
                                                     buffer_length,
                                                     target_exe);
        }

        if (!DisplayPackedString(buffer, buffer_length/sizeof(WCHAR),
                                 FALSE, &msg)) {

            msg.Set(MSG_CHK_NO_MEMORY);
            msg.Display();
            return 1;
        }

        FREE(buffer);
    }


    // Echo macros for target_exe.

    if (macros.QueryFlag() || m.QueryFlag()) {
        if (!DisplayMacros(target_exe, FALSE, &msg)) {
            return 1;
        }
    }


    // Echo macros for specific exe.

    if (macros_plus.IsValueSet()) {

        StripQuotesFromString(macros_plus.GetString());
        if (!all_string.Initialize("all")) {
            return 1;
        }

        if (!macros_plus.GetString()->Stricmp(&all_string)) {

            if (!DisplayAllMacros(&msg)) {
                return 1;
            }

        } else {

            target_exe = macros_plus.GetString()->QueryWSTR();

            if (!DisplayMacros(target_exe, FALSE, &msg)) {
                return 1;
            }

            DELETE(target_exe);
        }
    }


    // Echo macros for specific exe.

    if (m_plus.IsValueSet()) {

        StripQuotesFromString(m_plus.GetString());
        if (!all_string.Initialize("all")) {
            return 1;
        }

        if (!m_plus.GetString()->Stricmp(&all_string)) {

            if (!DisplayAllMacros(&msg)) {
                return 1;
            }

        } else {

            target_exe = m_plus.GetString()->QueryWSTR();

            if (!DisplayMacros(target_exe, FALSE, &msg)) {
                return 1;
            }

            DELETE(target_exe);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fc\fc.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    FC

Abstract:

    FC is a DOS-5 compatible file comparison utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Notes:

    This FC is a port of the DOS5 FC code. It has been slightly modified
    to use some of the ULIB functionality (e.g. argument parsing), however
    it does not make full use of the ULIB functionality (e.g. it uses
    stdio.h functions for file handling).



Revision History:

--*/


/****************************************************************************
    File Compare

    Fcom compares two files in either a line-by-line mode or in a strict
    BYTE-by-BYTE mode.

    The BYTE-by-BYTE mode is simple; merely read both files and print the
    offsets where they differ and the contents.

    The line compare mode attempts to isolate differences in ranges of lines.
    Two buffers of lines are read and compared.  No hashing of lines needs
    to be done; hashing only speedily tells you when things are different,
    not the same.  Most files run through this are expected to be largely
    the same.  Thus, hashing buys nothing.


***********************************************************************
The algorithm that immediately follows does not work.  There is an error
somewhere in the range of lines 11 on. An alternative explanation follows.
                                                            KGS
************************************************************************

    [0]     Fill buffers
    [1]     If both buffers are empty then
    [1.1]       Done
    [2]     Adjust buffers so 1st differing lines are at top.
    [3]     If buffers are empty then
    [3.1]       Goto [0]

    This is the difficult part.  We assume that there is a sequence of inserts,
    deletes and replacements that will bring the buffers back into alignment.

    [4]     xd = yd = FALSE
    [5]     xc = yc = 1
    [6]     xp = yp = 1
    [7]     If buffer1[xc] and buffer2[yp] begin a "sync" range then
    [7.1]       Output lines 1 through xc-1 in buffer 1
    [7.2]       Output lines 1 through yp-1 in buffer 2
    [7.3]       Adjust buffer 1 so line xc is at beginning
    [7.4]       Adjust buffer 2 so line yp is at beginning
    [7.5]       Goto [0]
    [8]     If buffer1[xp] and buffer2[yc] begin a "sync" range then
    [8.1]       Output lines 1 through xp-1 in buffer 1
    [8.2]       Output lines 1 through yc-1 in buffer 2
    [8.3]       Adjust buffer 1 so line xp is at beginning
    [8.4]       Adjust buffer 2 so line yc is at beginning
    [8.5]       Goto [0]
    [9]     xp = xp + 1
    [10]    if xp > xc then
    [10.1]      xp = 1
    [10.2]      xc = xc + 1
    [10.3]      if xc > number of lines in buffer 1 then
    [10.4]          xc = number of lines
    [10.5]          xd = TRUE
    [11]    if yp > yc then
    [11.1]      yp = 1
    [11.2]      yc = yc + 1
    [11.3]      if yc > number of lines in buffer 2 then
    [11.4]          yc = number of lines
    [11.5]          yd = TRUE
    [12]    if not xd or not yd then
    [12.1]      goto [6]

    At this point there is no possible match between the buffers.  For
    simplicity, we punt.

    [13]    Display error message.

EXPLANATION 2

    This is a variation of the Largest Common Subsequence problem.  A
    detailed explanation of this can be found on p 189 of Data Structures
    and Algorithms by Aho Hopcroft and Ulman.

    FC maintains two buffers within which it tries to find the Largest Common
    Subsequence (The largest common subsequence is simply the pattern in
    buffer1 that yields the most matches with the pattern in buffer2, or the
    pattern in buffer2 that yields the most matches with the pattern in buffer1)

    FC makes a simplifying assumption that the contents of one buffer can be
    converted to the contents of the other buffer by deleting the lines that are
    different between the two buffers.

    Two indices into each buffer are maintained:

            xc, yc == point to the last line that has been scanned up to now

            xp, yp == point to the first line that has not been exhaustively
                      compared to lines 0 - #c in the other buffer.

    FC now makes a second simplifying assumption:
        It is unnecessary to do any calculations on lines that are equal.

    Hence FC scans File1 and File two line by line until a difference is
    encountered.

    When a difference is encountered the two buffers are filled such that
    the line containing the first difference heads the buffer. The following
    exhaustive search algorithm is applied to find the first "sync" occurance.
    (The below is simplified to use == for comparison.  In practice more than
    one line needs to match for a "sync" to be established).

            FOR xc,yc = 1; xc,yx <= sizeof( BUFFERS ); xc++, yc++

                FOR xp,yp = 1; xp,yp <= xc,yc; xp++, yp++

                    IF ( BUFFER1[xp] == BUFFER2[yc] )

                        Then the range of lines BUFFER1[ 1 ... xp ] and
                        BUFFER2[ 1 ... yc ] need to be deleted for the
                        two files to be equal.  Therefore DISPLAY these
                        ranges, and begin scanning both files starting at
                        the matching lines.
                    FI

                    IF ( BUFFER1[yp] == BUFFER2[xc] )

                        Then the range of lines BUFFER2[ 1 ... yp ] and
                        BUFFER1[ 1 ... xc ] need to be deleted for the
                        two files to be equal.  Therefore DISPLAY these
                        ranges, and begin scanning both files starting at
                        the matching lines.
                    FI
                FOREND
            FOREND

    If a match is not found within the buffers, the message "RESYNC FAILED"
    is issued and further comparison is aborted since there is no valid way
    to find further matching lines.

END EXPLANATION 2

    Certain flags may be set to modify the behavior of the comparison:

    -a      abbreviated output.  Rather than displaying all of the modified
            ranges, just display the beginning, ... and the ending difference
    -b      compare the files in binary (or BYTE-by-BYTE) mode.  This mode is
            default on .EXE, .OBJ, .LIB, .COM, .BIN, and .SYS files
    -c      ignore case on compare (cmp = strcmpi instead of strcmp)
    -l      compare files in line-by-line mode
    -lb n   set the size of the internal line buffer to n lines from default
            of 100
    -u      Files to be compared are UNICODE text files
    -w      ignore blank lines and white space (ignore len 0, use strcmps)
    -t      do not untabify (use fgets instead of fgetl)
    -n      output the line number also
    -NNNN   set the number of lines to resynchronize to n which defaults
            to 2.  Failure to have this value set correctly can result in
            odd output:
              file1:        file2:
                    abcdefg       abcdefg
                    aaaaaaa       aaaaaab
                    aaaaaaa       aaaaaaa
                    aaaaaaa       aaaaaaa
                    abcdefg       abcdefg

            with default sync of 2 yields:          with sync => 3 yields:

                    *****f1                             *****f1
                    abcdefg                             abcdefg
                    aaaaaaa                             aaaaaaa
                    *****f2                             aaaaaaa
                    abcdefg                             *****f2
                    aaaaaab                             abcdefg
                    aaaaaaa                             aaaaaab
                                                        aaaaaaa
                    *****f1
                    aaaaaaa
                    aaaaaaa
                    abcdefg
                    *****f2
                    aaaaaaa
                    abcdefg

WARNING:
        This program makes use of GOTO's and hence is not as straightforward
        as it could be!  CAVEAT PROGRAMMER.
****************************************************************************/


#include "ulib.hxx"
#include "fc.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "bytestrm.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "mbstr.hxx"
#include "system.hxx"
#include "wstring.hxx"

#include <malloc.h>
#include <process.h>
#include <stdlib.h>
#include <math.h>
#include <locale.h>

/**************************************************************************/
/* main                                                                   */
/**************************************************************************/

INT __cdecl
main (
    )
{
    DEFINE_CLASS_DESCRIPTOR( FC );

    {
        FC Fc;

        if ( Fc.Initialize() ) {

            return Fc.Fcmain();
        }
    }

    return FAILURE;
}




CHAR *ExtBin[] = { "EXE", "OBJ", "LIB",
                 "COM", "BIN", "SYS", NULL };




DEFINE_CONSTRUCTOR( FC,  PROGRAM );


FC::~FC () {
}



BOOLEAN FC::Initialize() {


    if ( PROGRAM::Initialize() ) {

        ValidateVersion();

        ctSync  = -1;                 // number of lines required to sync
        cLine   = -1;                 // number of lines in internal buffs

        fAbbrev = FALSE;              // abbreviated output
        fBinary = FALSE;              // binary comparison
        fLine   = FALSE;              // line comparison
        fNumb   = FALSE;              // display line numbers
        fCase   = TRUE;               // case is significant
        fIgnore = FALSE;              // ignore spaces and blank lines
        fSkipOffline = TRUE;          // skip offline files

        fOfflineSkipped = FALSE;      // no files are skipped

#ifdef  DEBUG
        fDebug = FALSE;
#endif

        fExpandTabs = TRUE;
        // funcRead = (int (*)(char *,int,FILE *))fgetl;

        extBin = (CHAR **)ExtBin;

        return  ParseArguments();
    }

    return FALSE;
}





BOOLEAN
FC::ParseArguments(
    )
{

    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;
    ARRAY               ArrayOfArg;

    PATH_ARGUMENT       ProgramName;
    FLAG_ARGUMENT       FlagAbbreviate;
    FLAG_ARGUMENT       FlagAsciiCompare;
    FLAG_ARGUMENT       FlagBinaryCompare;
    FLAG_ARGUMENT       FlagCaseInsensitive;
    FLAG_ARGUMENT       FlagCompression;
    FLAG_ARGUMENT       FlagExpansion;
    FLAG_ARGUMENT       FlagLineNumber;
    FLAG_ARGUMENT       FlagRequestHelp;
    FLAG_ARGUMENT       FlagUnicode;
    FLAG_ARGUMENT       FlagIncludeOffline;
    FLAG_ARGUMENT       FlagIncludeOffline2;
    LONG_ARGUMENT       LongBufferSize;
#ifdef DEBUG
    FLAG_ARGUMENT       FlagDebug;
#endif
    STRING_ARGUMENT     LongMatch;
    PATH_ARGUMENT       InFile1;
    PATH_ARGUMENT       InFile2;

    LONG                Long;
    INT                 i;


    if( !LexArray.Initialize() ) {
        DebugAbort( "LexArray.Initialize() Failed!\n" );
        return( FALSE );
    }
    if( !ArgLex.Initialize(&LexArray) ) {
        DebugAbort( "ArgLex.Initialize() Failed!\n" );
        return( FALSE );
    }

    // Allow only the '/' as a valid switch
    ArgLex.PutSwitches("/");
    ArgLex.SetCaseSensitive( FALSE );

    ArgLex.PutStartQuotes("\"");
    ArgLex.PutEndQuotes("\"");
    ArgLex.PutSeparators(" \t");

    if( !ArgLex.PrepareToParse() ) {
        DebugAbort( "ArgLex.PrepareToParse() Failed!\n" );
        return( FALSE );
    }

    if( !ProgramName.Initialize("*")                ||
        !FlagAbbreviate.Initialize("/A")            ||
        !FlagAsciiCompare.Initialize("/L")          ||
        !FlagBinaryCompare.Initialize("/B")         ||
        !FlagCaseInsensitive.Initialize("/C")       ||
        !FlagCompression.Initialize("/W")           ||
        !FlagExpansion.Initialize("/T")             ||
        !FlagLineNumber.Initialize("/N")            ||
        !FlagRequestHelp.Initialize("/?")           ||
        !FlagUnicode.Initialize("/U")               ||
        !FlagIncludeOffline.Initialize("/OFFLINE")  ||
        !FlagIncludeOffline2.Initialize("/OFF")     ||
#ifdef DEBUG
        !FlagDebug.Initialize("/D")                 ||
#endif
        !LongBufferSize.Initialize("/LB#")          ||
        !LongMatch.Initialize("/*")                 ||
        !InFile1.Initialize("*")                    ||
        !InFile2.Initialize("*") ) {

        DebugAbort( "Unable to Initialize some or all of the Arguments!\n" );
        return( FALSE );
    }


    if( !ArrayOfArg.Initialize() ) {
        DebugAbort( "ArrayOfArg.Initialize() Failed\n" );
        return( FALSE );
    }

    if( !ArrayOfArg.Put(&ProgramName)           ||
        !ArrayOfArg.Put(&FlagAbbreviate)        ||
        !ArrayOfArg.Put(&FlagAsciiCompare)      ||
        !ArrayOfArg.Put(&FlagBinaryCompare)     ||
        !ArrayOfArg.Put(&FlagCaseInsensitive)   ||
        !ArrayOfArg.Put(&FlagCompression)       ||
        !ArrayOfArg.Put(&FlagExpansion)         ||
        !ArrayOfArg.Put(&FlagLineNumber)        ||
        !ArrayOfArg.Put(&FlagRequestHelp)       ||
        !ArrayOfArg.Put(&FlagUnicode)           ||
        !ArrayOfArg.Put(&FlagIncludeOffline)    ||
        !ArrayOfArg.Put(&FlagIncludeOffline2)   ||
#ifdef DEBUG
        !ArrayOfArg.Put(&FlagDebug)             ||
#endif
        !ArrayOfArg.Put(&LongBufferSize)        ||
        !ArrayOfArg.Put(&LongMatch)             ||
        !ArrayOfArg.Put(&InFile1)               ||
        !ArrayOfArg.Put(&InFile2) ) {

        DebugAbort( "ArrayOfArg.Put() Failed!\n" );
        return( FALSE );
    }


    if( !( ArgLex.DoParsing( &ArrayOfArg ) ) ) {
        // For each incorrect command line parameter, FC displays the
        // following message:
        //
        //      FC: Invalid Switch
        //
        // It does *not* die if a parameter is unrecognized...(Dos does...)
        //
        DisplayMessage( MSG_FC_INVALID_SWITCH, ERROR_MESSAGE, "" );
        // return( FALSE );
    }



    //
    // It should now be safe to test the arguments for their values...
    //
    if( FlagRequestHelp.QueryFlag() ) {
        DisplayMessage( MSG_FC_HELP_MESSAGE, NORMAL_MESSAGE, "" );
        return( FALSE );
    }

    if( FlagBinaryCompare.QueryFlag() &&
        ( FlagAsciiCompare.QueryFlag() || FlagLineNumber.QueryFlag() ) ) {

        DisplayMessage( MSG_FC_INCOMPATIBLE_SWITCHES, ERROR_MESSAGE, "" );
        return( FALSE );
    }

    if( !InFile1.IsValueSet() ||
        !InFile2.IsValueSet() ) {
        DisplayMessage( MSG_FC_INSUFFICIENT_FILES, ERROR_MESSAGE, "" );
        return( FALSE );
    }


    //
    //   Convert filenames to upper case
    //
    _File1.Initialize( InFile1.GetPath() );
    _File2.Initialize( InFile2.GetPath() );

    ((PWSTRING)_File1.GetPathString())->Strupr();
    ((PWSTRING)_File2.GetPathString())->Strupr();


    fUnicode        = FlagUnicode.QueryFlag();
    fAbbrev         = FlagAbbreviate.QueryFlag();
    fCase           = !FlagCaseInsensitive.QueryFlag();
    fIgnore         = FlagCompression.QueryFlag();
    fNumb           = FlagLineNumber.QueryFlag();
    fBinary         = FlagBinaryCompare.QueryFlag();
    fSkipOffline    = ( !FlagIncludeOffline.QueryFlag() ) &&
                      ( !FlagIncludeOffline2.QueryFlag() );

    if ( FlagExpansion.QueryFlag() ) {
        fExpandTabs = FALSE;
        //funcRead = (int (*)(char *,int,FILE *))fgets;
    }

#ifdef DEBUG
    fDebug      = FlagDebug.QueryFlag();
#endif


    if ( LongBufferSize.IsValueSet() ) {
        cLine = (INT)LongBufferSize.QueryLong();
        fLine  = TRUE;
    } else {
        cLine = 100;
    }

    if ( LongMatch.IsValueSet() ) {
        if ( LongMatch.GetString()->QueryNumber( &Long ) ) {
            ctSync = (INT)Long;
            fLine  = TRUE;
        } else {

            DisplayMessage( MSG_FC_INVALID_SWITCH, ERROR_MESSAGE, "" );
            ctSync = 2;
        }
    } else {
        ctSync = 2;
    }

    if (!fBinary && !fLine) {

        DSTRING             ExtBin;
        PWSTRING            Ext = _File1.QueryExt();

        if ( Ext ) {
            for (i=0; extBin[i]; i++) {
                ExtBin.Initialize( extBin[i] );
                if ( !ExtBin.Stricmp( Ext ) ) {
                    fBinary = TRUE;
                    break;
                }
            }

            DELETE( Ext );
        }

        if (!fBinary) {
            fLine = TRUE;
        }
    }

    if (!fUnicode) {
        if (fIgnore) {
            if (fCase) {
                fCmp = MBSTR::Strcmps;
            } else {
                fCmp = MBSTR::Strcmpis;
            }
        } else {

            if (fCase) {
                fCmp = MBSTR::Strcmp;
            } else {
                fCmp = MBSTR::Stricmp;
            }
        }
    } else {
        if (fIgnore) {
            if (fCase) {
                fCmp_U = WSTRING::Strcmps;
            } else {
                fCmp_U = WSTRING::Strcmpis;
            }
        } else {

            if (fCase) {
                fCmp_U = WSTRING::Strcmp;
            } else {
                fCmp_U = WSTRING::Stricmp;
            }
        }
    }

    return( TRUE );

}





INT
FC::Fcmain
    (
    )
{
  return ParseFileNames();
}




/**************************************************************************/
/* BinaryCompare                                                          */
/**************************************************************************/

int
FC::BinaryCompare (
    PCWSTRING f1,
    PCWSTRING f2
    )
{

    PATH            FileName;
    PFSN_FILE       File1   = NULL;
    PFSN_FILE       File2   = NULL;
    PFILE_STREAM    Stream1 = NULL;
    PFILE_STREAM    Stream2 = NULL;;
    BYTE_STREAM     Bs1;
    BYTE_STREAM     Bs2;
    BYTE            c1, c2;
    ULONG64         pos;
    BOOLEAN         fSame;
    char            buffer[128];
    BOOLEAN         fFileSkipped;


    if ( !FileName.Initialize( f1 )                     ||
         !(File1 = SYSTEM::QueryFile( &FileName, fSkipOffline, &fFileSkipped ))      ||
         !(Stream1 = File1->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL )) ||
         !Bs1.Initialize( Stream1 )
       ) {

        DELETE( Stream2 );
        DELETE( File2 );
        DELETE( Stream1 );
        DELETE( File1 );
        if (fFileSkipped) {
            // Skipping offline files is not an error, just track this happened
            fOfflineSkipped = TRUE;
            return FILES_OFFLINE;

        } else {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", f1 );
            return FILES_NOT_FOUND;
        }
    }

    if ( !FileName.Initialize( f2 )                     ||
         !(File2 = SYSTEM::QueryFile( &FileName, fSkipOffline, &fFileSkipped ))      ||
         !(Stream2 = File2->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL )) ||
         !Bs2.Initialize( Stream2 )
       ) {

        DELETE( Stream2 );
        DELETE( File2 );
        DELETE( Stream1 );
        DELETE( File1 );
        if (fFileSkipped) {
            // Skipping offline files is not an error, just track this happened
            fOfflineSkipped = TRUE;
            return FILES_OFFLINE;

        } else {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", f2 );
            return FILES_NOT_FOUND;
        }
    }

    fSame = TRUE;
    pos   = 0;

    while ( TRUE ) {

      if ( Bs1.ReadByte( &c1 ) ) {

        if ( Bs2.ReadByte( &c2 ) ) {

          if (c1 != c2) {

            if (pos > MAXULONG) {
                sprintf( buffer, "%016I64X: %02X %02X", pos, c1, c2 );
            } else {
                sprintf( buffer, "%08I64X: %02X %02X", pos, c1, c2 );
            }
            DisplayMessage( MSG_FC_DATA, NORMAL_MESSAGE, "%s", buffer );
            fSame = FALSE;

          }

        } else {

          DisplayMessage( MSG_FC_FILES_DIFFERENT_LENGTH, NORMAL_MESSAGE, "%W%W", f1, f2 );
          fSame = FALSE;
          break;

        }

      } else {

        if ( Bs2.ReadByte( &c2 ) ) {

          DisplayMessage( MSG_FC_FILES_DIFFERENT_LENGTH, NORMAL_MESSAGE, "%W%W", f2, f1 );
          fSame = FALSE;
          break;

        } else {

          if (fSame) {
              DisplayMessage( MSG_FC_NO_DIFFERENCES, NORMAL_MESSAGE );
          }

          break;

        }
      }

      pos++;
    }

    DELETE( Stream2 );
    DELETE( File2 );
    DELETE( Stream1 );
    DELETE( File1 );

    return fSame ? SUCCESS : FILES_ARE_DIFFERENT;
}


/**************************************************************************/
/* Compare a range of lines.                                              */
/**************************************************************************/

BOOLEAN FC::compare (int l1, register int s1, int l2, register int s2, int ct)
{
#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("compare (%d, %d, %d, %d, %d)\n", l1, s1, l2, s2, ct));
#endif

  if (ct <= 0 || s1+ct > l1 || s2+ct > l2)
    return (FALSE);

  while (ct--)
  {

#ifdef  DEBUG
    if (fDebug)
      DebugPrintTrace(("'%s' == '%s'? ", buffer1[s1].text, buffer2[s2].text));
#endif
  if(!fUnicode) {
        if ((*fCmp)(buffer1[s1++].text, buffer2[s2++].text)) {

#ifdef  DEBUG
          if (fDebug)
            DebugPrintTrace(("No\n"));
#endif
          return (FALSE);
        }
  } else {
        if ((*fCmp_U)(buffer1[s1++].wtext, buffer2[s2++].wtext)) {

#ifdef  DEBUG
          if (fDebug)
            DebugPrintTrace(("No\n"));
#endif
          return (FALSE);
        }
  }
  }

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("Yes\n"));
#endif

  return (TRUE);
}


/**************************************************************************/
/* LineCompare                                                            */
/**************************************************************************/


INT
FC::LineCompare(
    PCWSTRING f1,
    PCWSTRING f2
    )
{

    PATH            FileName;
    PFSN_FILE       File1   = NULL;
    PFSN_FILE       File2   = NULL;
    PFILE_STREAM    Stream1 = NULL;
    PFILE_STREAM    Stream2 = NULL;
    int             result;
    BOOLEAN         fFileSkipped;


    buffer1 = buffer2 = NULL;

    if ( !FileName.Initialize( f1 )    ||
         !(File1 = SYSTEM::QueryFile( &FileName, fSkipOffline, &fFileSkipped ))      ||
         !(Stream1 = File1->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL ))
       ) {

        FREE(buffer1);
        FREE(buffer2);
        DELETE(Stream2);
        DELETE(File2);
        DELETE(Stream1);
        DELETE(File1);
        if (fFileSkipped) {
            // Skipping offline files is not an error, just track this happened
            fOfflineSkipped = TRUE;
            return FILES_OFFLINE;

        } else {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", f1 );
            return FILES_NOT_FOUND;
        }
    }

    if ( !FileName.Initialize( f2 )    ||
         !(File2 = SYSTEM::QueryFile( &FileName, fSkipOffline, &fFileSkipped ))      ||
         !(Stream2 = File2->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL ))
       ) {

        FREE(buffer1);
        FREE(buffer2);
        DELETE(Stream2);
        DELETE(File2);
        DELETE(Stream1);
        DELETE(File1);
        if (fFileSkipped) {
            // Skipping offline files is not an error, just track this happened
            fOfflineSkipped = TRUE;
            return FILES_OFFLINE;

        } else {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", f2 );
            return FILES_NOT_FOUND;
        }
    }


    if ( (buffer1 = (struct lineType *)MALLOC(cLine * (sizeof *buffer1))) == NULL ||
         (buffer2 = (struct lineType *)MALLOC(cLine * (sizeof *buffer1))) == NULL) {

        DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
        FREE(buffer1);
        FREE(buffer2);
        DELETE(Stream2);
        DELETE(File2);
        DELETE(Stream1);
        DELETE(File1);
        return FAILURE;
    }

    result = RealLineCompare( f1, f2, Stream1, Stream2 );

    FREE(buffer1);
    FREE(buffer2);
    DELETE(Stream2);
    DELETE(File2);
    DELETE(Stream1);
    DELETE(File1);

    return result;
}

int
FC::RealLineCompare (
    PCWSTRING f1,
    PCWSTRING f2,
    PSTREAM Stream1,
    PSTREAM Stream2
    )
{

    int             l1, l2, i, xp, yp, xc, yc;
    BOOLEAN         xd, yd, fSame;
    int             line1, line2;


    fSame = TRUE;
    l1    = l2    = 0;
    line1 = line2 = 0;

l0:

#ifdef  DEBUG
    if (fDebug) {
        DebugPrintTrace(("At scan beginning\n"));
    }
#endif

    l1 += xfill (buffer1+l1, Stream1, cLine-l1, &line1);
    l2 += xfill (buffer2+l2, Stream2, cLine-l2, &line2);

    if (l1 == 0 && l2 == 0) {

        if (fSame) {
            DisplayMessage( MSG_FC_NO_DIFFERENCES, NORMAL_MESSAGE );
        }
        return fSame ? SUCCESS : FILES_ARE_DIFFERENT;
    }

    xc = min (l1, l2);

    for (i=0; i < xc; i++) {

        if (!compare (l1, i, l2, i, 1)) {
            break;
        }
    }

    if (i != xc) {
        i = ( i-1 > 0 )? ( i-1 ) : 0;
    }

    l1 = adjust (buffer1, l1, i);
    l2 = adjust (buffer2, l2, i);

    if (l1 == 0 && l2 == 0) {
        goto l0;
    }

    l1 += xfill (buffer1+l1, Stream1, cLine-l1, &line1);
    l2 += xfill (buffer2+l2, Stream2, cLine-l2, &line2);

#ifdef  DEBUG
    if (fDebug) {
        DebugPrintTrace(("buffers are adjusted, %d, %d remain\n", l1, l2));
    }
#endif

    xd = yd = FALSE;
    xc = yc = 1;
    xp = yp = 1;

l6:

#ifdef  DEBUG
    if (fDebug) {
        DebugPrintTrace(("Trying resync %d,%d  %d,%d\n", xc, xp, yc, yp));
    }
#endif

    i = min (l1-xc,l2-yp);
    i = min (i, ctSync);

    if (compare (l1, xc, l2, yp, i)) {

        fSame = FALSE;
        DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f1 );
        dump (buffer1, 0, xc);
        DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f2 );
        dump (buffer2, 0, yp);
        DisplayMessage( MSG_FC_DUMP_END, NORMAL_MESSAGE );

        l1 = adjust (buffer1, l1, xc);
        l2 = adjust (buffer2, l2, yp);

        goto l0;
    }

    i = min (l1-xp, l2-yc);
    i = min (i, ctSync);

    if (compare (l1, xp, l2, yc, i)) {

        fSame = FALSE;
        DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f1 );
        dump (buffer1, 0, xp);
        DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f2 );
        dump (buffer2, 0, yc);
        DisplayMessage( MSG_FC_DUMP_END, NORMAL_MESSAGE );

        l1 = adjust (buffer1, l1, xp);
        l2 = adjust (buffer2, l2, yc);

        goto l0;
    }

    if (++xp > xc) {

        xp = 1;
        if (++xc >= l1) {

            xc = l1;
            xd = TRUE;
        }
    }

    if (++yp > yc) {

        yp = 1;
        if (++yc >= l2) {

            yc = l2;
            yd = TRUE;
        }
    }

    if (!xd || !yd) {
        goto l6;
    }

    fSame = FALSE;

    if (l1 >= cLine || l2 >= cLine) {
        DisplayMessage( MSG_FC_RESYNC_FAILED, NORMAL_MESSAGE );
    }

    DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f1 );
    dump (buffer1, 0, l1-1);
    DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f2 );
    dump (buffer2, 0, l2-1);
    DisplayMessage( MSG_FC_DUMP_END, NORMAL_MESSAGE );

    return fSame ? SUCCESS : FILES_ARE_DIFFERENT;
}


/**************************************************************************/
/* Return number of lines read in.                                        */
/**************************************************************************/

FC::xfill (struct lineType *pl, PSTREAM Stream, int ct, int *plnum)
{
  int i;
  DWORD StrSize;

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("xfill (%04x, %04x)\n", pl, fh));
#endif

  i = 0;

  if (!fUnicode) {
    while ( ct-- && !Stream->IsAtEnd() && Stream->ReadMbLine( pl->text, MAXLINESIZE, &StrSize, fExpandTabs, 8 ) ) {

      if (fIgnore && !MBSTR::Strcmps(pl->text, "")) {

        pl->text[0] = 0;
        ++*plnum;
      }

      if (strlen (pl->text) != 0 || !fIgnore)
      {
        pl->line = ++*plnum;
        pl++;
        i++;
      }
    }
  } else {
    while( ct-- && !Stream->IsAtEnd() &&  Stream->ReadWLine( pl->wtext,MAXLINESIZE, &StrSize, fExpandTabs, 8 ) ) {
    //while( ct-- && !Stream->IsAtEnd() &&  Stream->ReadLine( &_String , TRUE )) {

      //_String.QueryWSTR(0,TO_END,pl->wtext,MAXLINESIZE,TRUE);

      if (fIgnore && !WSTRING::Strcmps((PWSTR)pl->wtext, (PWSTR)L"")) {

        pl->wtext[0] = 0;
        ++*plnum;
      }

      if (wcslen (pl->wtext) != 0 || !fIgnore)
      {
        pl->line = ++*plnum;
        pl++;
        i++;
      }
    }
  }

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("xfill returns %d\n", i));
#endif

  return (i);

#if 0

  while (ct-- && (*funcRead) (pl->text, MAXLINESIZE, fh) != NULL)
  {
    if (funcRead == ( int (*) (char *,int, FILE *))fgets)
      pl->text[strlen(pl->text)-1] = 0;
    if (fIgnore && !MBSTR::Strcmps(pl->text, ""))
    {
      pl->text[0] = 0;
      ++*plnum;
    }
    if (strlen (pl->text) != 0 || !fIgnore)
    {
      pl->line = ++*plnum;
      pl++;
      i++;
    }
  }

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("xfill returns %d\n", i));
#endif

  return (i);

#   endif

}


/**************************************************************************/
/* Adjust returns number of lines in buffer.                              */
/**************************************************************************/

FC::adjust (struct lineType *pl, int ml, int lt)
{
#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("adjust (%04x, %d, %d) = ", pl, ml, lt));
  if (fDebug)
    DebugPrintTrace(("%d\n", ml-lt));
#endif

  if (ml <= lt)
    return (0);

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("move (%04x, %04x, %04x)\n", &pl[lt], &pl[0], sizeof (*pl)*(ml-lt)));
#endif

  // Move((char  *)&pl[lt], (char  *)&pl[0], sizeof (*pl)*(ml-lt));
  memmove( (char  *)&pl[0], (char  *)&pl[lt],  sizeof (*pl)*(ml-lt) );
  return ml-lt;
}


/**************************************************************************/
/* dump                                                                   */
/*      dump outputs a range of lines.                                    */
/*                                                                        */
/*  INPUTS                                                                */
/*          pl      pointer to current lineType structure                 */
/*          start   starting line number                                  */
/*          end     ending line number                                    */
/*                                                                        */
/*  CALLS                                                                 */
/*          pline, printf                                                 */
/**************************************************************************/

void FC::dump (struct lineType *pl, int start, int end)
{
  if (fAbbrev && end-start > 2)
  {
    pline (pl+start);
    DisplayMessage( MSG_FC_ABBREVIATE_SYMBOL, NORMAL_MESSAGE );
    pline (pl+end);
  }
  else
  {
    while (start <= end)
      pline (pl+start++);
  }
}


/**************************************************************************/
/* PrintLINE                                                              */
/*      pline prints a single line of output.  If the /n flag             */
/*  has been specified, the line number of the printed text is added.     */
/*                                                                        */
/*  Inputs                                                                */
/*          pl      pointer to current lineType structure                 */
/*          fNumb   TRUE if /n specified                                  */
/**************************************************************************/

void FC::pline (struct lineType *pl)
{
  if (!fUnicode) {
    if (fNumb)
      DisplayMessage( MSG_FC_NUMBERED_DATA, NORMAL_MESSAGE, "%5d%s",
                      pl->line, pl->text );
    else
      DisplayMessage( MSG_FC_DATA, NORMAL_MESSAGE, "%s", pl->text );
  } else {
    FSTRING f;
    if (fNumb)
      DisplayMessage( MSG_FC_NUMBERED_DATA, NORMAL_MESSAGE, "%5d%W",
                      pl->line, f.Initialize(pl->wtext) );
    else
      DisplayMessage( MSG_FC_DATA, NORMAL_MESSAGE, "%W",
                      f.Initialize(pl->wtext) );
  }
}


/*********************************************************************/
/* Routine:   ParseFileNames                                         */
/*                                                                   */
/* Function:  Parses the two given filenames and then compares the   */
/*            appropriate filenames.  This routine handles wildcard  */
/*            characters in both filenames.                          */
/*********************************************************************/

INT
FC::ParseFileNames()
{
    PATH                File1;
    PATH                File2;
    FSN_FILTER          Filter;
    PWSTRING            Name;
    PARRAY              NodeArray;
    PITERATOR           Iterator;
    PFSN_DIRECTORY      Dir;
    PFSNODE             File;
    PPATH               ExpandedPath;
    PATH                TmpPath;
    int                 result = SUCCESS;
    char                *locale;

    if (!File1.Initialize( &_File1 ) ||
        !File2.Initialize( &_File2 ) ||
        !Filter.Initialize()) {
        DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
        return FAILURE;
    }

    if (!(Name = File1.QueryName())) {
        DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", File1.GetPathString() );
        return FILES_NOT_FOUND;
    }

    if (!Filter.SetFileName( Name ) ||
        !Filter.SetAttributes( (FSN_ATTRIBUTE)0,                // ALL
                                FSN_ATTRIBUTE_FILES,            // ANY
                                FSN_ATTRIBUTE_DIRECTORY )) {    // NONE
        DELETE( Name );
        DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
        return FAILURE;
    }

    DELETE( Name );

    if (!TmpPath.Initialize( &File1, TRUE ) ||
        !TmpPath.TruncateBase()) {
        DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
        return FAILURE;
    }

    if ( !(Dir = SYSTEM::QueryDirectory( &TmpPath ))        ||
         !(NodeArray = Dir->QueryFsnodeArray( &Filter ))    ||
         !(Iterator = NodeArray->QueryIterator())           ||
         !(File = (PFSNODE)Iterator->GetNext())
       ) {
        DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", File1.GetPathString() );
        return FILES_NOT_FOUND;
    }

    Iterator->Reset();

    while ( File = (PFSNODE)Iterator->GetNext() ) {

        PWSTRING Name1;
        PWSTRING Name2;

        if (!(Name1 = File->QueryName())) {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", File->GetPath()->GetPathString() );
            return FILES_NOT_FOUND;
        }

        if ( _File2.HasWildCard() ) {

            if ( !(ExpandedPath = _File2.QueryWCExpansion( (PPATH)File->GetPath() ))) {

                if (!(Name2 = _File2.QueryName())) {
                    DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", _File2.GetPathString() );
                    return FILES_NOT_FOUND;
                }

                DisplayMessage( MSG_FC_CANT_EXPAND_TO_MATCH, ERROR_MESSAGE, "%W%W", Name1, Name2 );
                DELETE( Name2 );
                DELETE( Name1 );
                DELETE( Iterator );
                DELETE( NodeArray );
                DELETE( Dir );
                return FAILURE;
            }

        } else {

            if ( !(ExpandedPath = NEW PATH) ||
                 !ExpandedPath->Initialize( &_File2 ) ) {

                DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
                DELETE( Name1 );
                DELETE( Iterator );
                DELETE( NodeArray );
                DELETE( Dir );
                return FAILURE;

            }
        }

        if (!(Name2 = ExpandedPath->QueryName())) {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", ExpandedPath->GetPathString() );
            return FILES_NOT_FOUND;
        }

        if (!File1.SetName( Name1 ) ||
            !File2.SetName( Name2 )) {
            DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
            return FAILURE;
        }

        switch (comp( File1.GetPathString(), File2.GetPathString() )) {
            case FAILURE:
                return FAILURE;

            case SUCCESS:
                break;

            case FILES_ARE_DIFFERENT:
                result |= FILES_ARE_DIFFERENT;
                break;

            case FILES_NOT_FOUND:
                result |= FILES_NOT_FOUND;
                break;

            case FILES_OFFLINE:
                result |= FILES_OFFLINE;
                break;

            default:
                DebugAssert(FALSE);
        }

        DELETE( Name2 );
        DELETE( Name1 );
        DELETE( ExpandedPath );

    }

    // Print a warning in case that offline files were skipped
    if (fOfflineSkipped) {
        DisplayMessage(MSG_FC_OFFLINE_FILES_SKIPPED, ERROR_MESSAGE);
    }

    DELETE( Iterator );
    NodeArray->DeleteAllMembers();
    DELETE( NodeArray );
    DELETE( Dir );

    return result;
}




/*********************************************************************/
/* Routine:   comp                                                   */
/*                                                                   */
/* Function:  Compares the two files.                                */
/*********************************************************************/

INT
FC::comp(PCWSTRING file1, PCWSTRING file2)
{
  DisplayMessage( MSG_FC_COMPARING_FILES, NORMAL_MESSAGE, "%W%W", file1, file2 );
  if (fBinary) {
      return BinaryCompare (file1, file2);
  } else {
      return LineCompare (file1, file2);
  }

}


#if 0
/* returns line from file (no CRLFs); returns NULL if EOF */
FC::fgetl ( char *buf, int len, FILE *fh)
{
    register int c;
    register char *p;

    /* remember NUL at end */
    len--;
    p = buf;
    while (len) {
        c = getc (fh);
        if (c == EOF || c == '\n')
            break;
#if MSDOS
        if (c != '\r')
#endif
            if (c != '\t') {
                *p++ = (char)c;
                len--;
                }
            else {
                c = min (8 - ((int)(p-buf) & 0x0007), len);
        memset(p, ' ', c);
                p += c;
                len -= c;
                }
        }
    *p = 0;
    return ! ( (c == EOF) && (p == buf) );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\arrowin.c ===
/** FILE: arrowin.c ******** Module Header ********************************
 *
 *      Control panel arrow window class routines. This file contains the
 *      window procedure and utility functions for managing the "cpArrow"
 *  window class/spinner control for use by Control Panel applet dialogs.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-    Steve Cathcart   [stevecat]
 *              Took base code from Win 3.1 source
 *
 *  Copyright (C) 1990-1991 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                                                              Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

// Windows SDK
/* cut out unnec stuff from windows.h */
#define NOCLIPBOARD
#define NOMETAFILE
#define NOREGION
#define NOSYSCOMMANDS
#define NOATOM
#define NOGDICAPMASKS

#include <windows.h>

//==========================================================================
//                                                      Local Definitions
//==========================================================================
#define SHIFT_TO_DOUBLE 1
#define DOUBLECLICK     0
#define PRESSINVERT     1
#define POINTSPERARROW  3
#define ARROWXAXIS      15
#define ARROWYAXIS      15


//==========================================================================
//                                                      External Declarations
//==========================================================================
extern HANDLE hModule;


//==========================================================================
//                                                      Local Data Declarations
//==========================================================================
#if 0
POINT Arrow[11] = {     16, 1, 2, 14, 12, 14, 12, 20, 2, 20, 16, 33,
            29, 20, 20, 20, 20, 14, 29, 14/*, 16,1*/};
#endif

#if 0
POINT ArrowUp[7] = {5, 2, 8, 5, 6, 5, 6, 7, 4, 7, 4, 5, 2, 5};

POINT ArrowDown[7] = {  4, 10, 6, 10, 6, 12, 8, 12, 5, 15, 2, 12, 4, 12};

#endif

POINT ArrowUp[POINTSPERARROW] = {7, 1, 3, 5, 11, 5};

POINT ArrowDown[POINTSPERARROW] = {7, 13, 3, 9, 11, 9};

BOOL    bRight;
RECT    rUp, rDown;
LPRECT  lpUpDown;
FARPROC lpArrowProc;
HANDLE  hParent;

//==========================================================================
//                                                      Local Function Prototypes
//==========================================================================


//==========================================================================
//                                                              Functions
//==========================================================================

WORD UpOrDown()
{
        LONG  l;
        WORD  retval;
        POINT pt;

        l = GetMessagePos();

        pt.y = (int) HIWORD(l);
        pt.x = (int) LOWORD(l);

        if (PtInRect((LPRECT) &rUp, pt))
                retval = SB_LINEUP;
        else if (PtInRect((LPRECT) &rDown, pt))
                retval = SB_LINEDOWN;
        else
                retval = (WORD)-1;      /* -1, because SB_LINEUP == 0 */
        return(retval);
}


WORD ArrowTimerProc(hWnd, wMsg, nID, dwTime)
HANDLE hWnd;
WORD   wMsg;
short  nID;
DWORD  dwTime;
{
        WORD wScroll;

        if ((wScroll = UpOrDown()) != -1)
        {
                if (bRight == WM_RBUTTONDOWN)
                        wScroll += SB_PAGEUP - SB_LINEUP;
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                GetWindowLong(hWnd, GWL_ID)), (LONG) hWnd);
        }
/* Don't need to call KillTimer(), because SetTimer will reset the right one */
        SetTimer(hWnd, nID, 50, (TIMERPROC)lpArrowProc);
        return(0);
#if 0
        wMsg = wMsg;
        dwTime = dwTime;
#endif
}


#if PRESSINVERT
void InvertArrow(HANDLE hArrow, WORD wScroll)
{
        HDC hDC;

        lpUpDown = (wScroll == SB_LINEUP) ? &rUp : &rDown;
        hDC = GetDC(hArrow);
        ScreenToClient(hArrow, (LPPOINT) &(lpUpDown->left));
        ScreenToClient(hArrow, (LPPOINT) &(lpUpDown->right));
        InvertRect(hDC, lpUpDown);
        ClientToScreen(hArrow, (LPPOINT) &(lpUpDown->left));
        ClientToScreen(hArrow, (LPPOINT) &(lpUpDown->right));
        ReleaseDC(hArrow, hDC);
        ValidateRect(hArrow, lpUpDown);
        return;
}


#endif

LONG ArrowControlProc(HWND hArrow, UINT message, UINT wParam, LONG lParam)
{
        PAINTSTRUCT ps;
        RECT    rArrow;
        HBRUSH  hbr;
        short   fUpDownOut;
        WORD    wScroll;
        POINT   tPoint;
        SIZE    tSize;

        switch (message)
        {
/*
      case WM_CREATE:
        break;

      case WM_DESTROY:
        break;
*/

        case WM_MOUSEMOVE:
                if (!bRight)  /* If not captured, don't worry about it */
                        break;

                if (lpUpDown == &rUp)
                        fUpDownOut = SB_LINEUP;
                else if (lpUpDown == &rDown)
                        fUpDownOut = SB_LINEDOWN;
                else
                        fUpDownOut = -1;

                switch (wScroll = UpOrDown())
                {
                case SB_LINEUP:
                        if (fUpDownOut == SB_LINEDOWN)
                                InvertArrow(hArrow, SB_LINEDOWN);
                        if (fUpDownOut != SB_LINEUP)
                                InvertArrow(hArrow, wScroll);
                        break;

                case SB_LINEDOWN:
                        if (fUpDownOut == SB_LINEUP)
                                InvertArrow(hArrow, SB_LINEUP);
                        if (fUpDownOut != SB_LINEDOWN)
                                InvertArrow(hArrow, wScroll);
                        break;

                default:
                        if (lpUpDown)
                        {
                                InvertArrow(hArrow, fUpDownOut);
                                lpUpDown = 0;
                        }
                }
                break;

        case WM_RBUTTONDOWN:
        case WM_LBUTTONDOWN:
                if (bRight)
                        break;
                bRight = message;
                SetCapture(hArrow);
                hParent = GetParent(hArrow);
                GetWindowRect(hArrow, (LPRECT) &rUp);
                CopyRect((LPRECT) &rDown, (LPRECT) &rUp);
                rUp.bottom = (rUp.top + rUp.bottom) / 2;
                rDown.top = rUp.bottom + 1;
                wScroll = UpOrDown();
#if PRESSINVERT
                InvertArrow(hArrow, wScroll);
#endif
#if SHIFT_TO_DOUBLE
                if (wParam & MK_SHIFT)
                {
                        if (message != WM_RBUTTONDOWN)
                                goto ShiftLClick;
                        else
                                goto ShiftRClick;
                }
#endif
                if (message == WM_RBUTTONDOWN)
                        wScroll += SB_PAGEUP - SB_LINEUP;
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                lpArrowProc = MakeProcInstance((FARPROC) ArrowTimerProc, hModule);
                SetTimer(hArrow, GetWindowLong(hArrow, GWL_ID), 200, (TIMERPROC)lpArrowProc);
                break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
                if ((UINT) (bRight - WM_LBUTTONDOWN + WM_LBUTTONUP) == message)
                {
                        bRight = 0;
                        ReleaseCapture();
#if PRESSINVERT
                        if (lpUpDown)
                                InvertArrow(hArrow, (WORD)((lpUpDown == &rUp) ? SB_LINEUP : SB_LINEDOWN));
#endif
                        if (lpArrowProc)
                        {
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                                SendMessage(hParent, WM_VSCROLL, MAKELONG(SB_ENDSCROLL,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                                KillTimer(hArrow, GetWindowLong(hArrow, GWL_ID));
                                FreeProcInstance(lpArrowProc);
                                ReleaseCapture();
                                lpArrowProc = 0;
                        }
                }
                break;

        case WM_LBUTTONDBLCLK:
ShiftLClick:
                wScroll = UpOrDown() + (WORD) (SB_TOP - SB_LINEUP);
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                break;

        case WM_RBUTTONDBLCLK:
ShiftRClick:
                wScroll = UpOrDown() + (WORD) (SB_THUMBPOSITION - SB_LINEUP);
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
/*
        hDC = GetDC(hArrow);
        InvertRect(hDC, (LPRECT) &rArrow);
        ReleaseDC(hArrow, hDC);
        ValidateRect(hArrow, (LPRECT) &rArrow);
*/
                break;

        case WM_PAINT:
                BeginPaint(hArrow, &ps);
                GetClientRect(hArrow, (LPRECT) &rArrow);
                if (hbr = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)))
                {
                        FillRect(ps.hdc, (LPRECT) &rArrow, hbr);
                        DeleteObject(hbr);
                }
                hbr = SelectObject(ps.hdc, GetStockObject(BLACK_BRUSH));
                SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWFRAME));
                SetMapMode(ps.hdc, MM_ANISOTROPIC);

                SetViewportOrgEx(ps.hdc, rArrow.left, rArrow.top, &tPoint);
                SetViewportExtEx(ps.hdc, rArrow.right - rArrow.left,
                    rArrow.bottom - rArrow.top, &tSize);
                SetWindowOrgEx(ps.hdc, 0, 0, &tPoint);
                SetWindowExtEx(ps.hdc, ARROWXAXIS, ARROWYAXIS, &tSize);
                MoveToEx(ps.hdc, 0, (ARROWYAXIS / 2), &tPoint);
                LineTo(ps.hdc, ARROWXAXIS, (ARROWYAXIS / 2));
/*
        Polygon(ps.hdc, (LPPOINT) Arrow, 10);
*/
                Polygon(ps.hdc, (LPPOINT) ArrowUp, POINTSPERARROW);
                Polygon(ps.hdc, (LPPOINT) ArrowDown, POINTSPERARROW);
                SelectObject(ps.hdc, hbr);
                EndPaint(hArrow, &ps);
                break;

        default:
                return(DefWindowProc(hArrow, message, wParam, lParam));
                break;
        }
        return(0L);
}


BOOL RegisterArrowClass (HANDLE hModule)
{
        WNDCLASS wcArrow;

        wcArrow.lpszClassName = "cpArrow";
        wcArrow.hInstance     = hModule;
        wcArrow.lpfnWndProc   = ArrowControlProc;
        wcArrow.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wcArrow.hIcon         = NULL;
        wcArrow.lpszMenuName  = NULL;
        wcArrow.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
        wcArrow.style         = CS_HREDRAW | CS_VREDRAW;
#if DOUBLECLICK
        wcArrow.style         |= CS_DBLCLKS;
#endif
        wcArrow.cbClsExtra    = 0;
        wcArrow.cbWndExtra    = 0;

        return(RegisterClass((LPWNDCLASS) &wcArrow));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\commit.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    commit.c

Abstract:

    This module contains the set of routines that support the commitment
    of changes to disk without  rebooting.

Author:

    Bob Rinne (bobri)  11/15/93

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "shellapi.h"
#include <winbase.h>
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include "scsi.h"
#include <ntddcdrm.h>
#include <ntddscsi.h>

// Lock list chain head for deleted partitions.

PDRIVE_LOCKLIST DriveLockListHead = NULL;

// Commit flag for case where a partition is deleted that has not drive letter

extern BOOLEAN CommitDueToDelete;
extern BOOLEAN CommitDueToMirror;
extern BOOLEAN CommitDueToExtended;
extern ULONG   UpdateMbrOnDisk;

extern HWND    InitDlg;

// List head for new drive letter assignment on commit.

typedef struct _ASSIGN_LIST {
    struct _ASSIGN_LIST *Next;
    ULONG                DiskNumber;
    BOOLEAN              MoveLetter;
    UCHAR                OriginalLetter;
    UCHAR                DriveLetter;
} ASSIGN_LIST, *PASSIGN_LIST;

PASSIGN_LIST    AssignDriveLetterListHead = NULL;

VOID
CommitToAssignLetterList(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN BOOL               MoveLetter
    )

/*++

Routine Description:

    Remember this region for assigning a drive letter to it upon
    commit.

Arguments:

    RegionDescriptor - the region to watch
    MoveLetter       - indicate that the region letter is already
                       assigned to a different partition, therefore
                       it must be "moved".

Return Value:

    None

--*/

{
    PASSIGN_LIST            newListEntry;
    PPERSISTENT_REGION_DATA regionData;

    newListEntry = (PASSIGN_LIST) Malloc(sizeof(ASSIGN_LIST));

    if (newListEntry) {

        // Save this region

        regionData = PERSISTENT_DATA(RegionDescriptor);
        newListEntry->OriginalLetter =
            newListEntry->DriveLetter = regionData->DriveLetter;
        newListEntry->DiskNumber = RegionDescriptor->Disk;
        newListEntry->MoveLetter = MoveLetter;

        // place it at the front of the chain.

        newListEntry->Next = AssignDriveLetterListHead;
        AssignDriveLetterListHead = newListEntry;
    }
}

VOID
CommitAssignLetterList(
    VOID
    )

/*++

Routine Description:

    Walk the assign drive letter list and make all drive letter assignments
    expected.  The regions data structures are moved around, so no pointer
    can be maintained to look at them.  To determine the partition number
    for a new partition in this list, the Disks[] structure must be searched
    to find a match on the partition for the drive letter.  Then the partition
    number will be known.

Arguments:

    None

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR      regionDescriptor;
    PPERSISTENT_REGION_DATA regionData;
    PDISKSTATE   diskp;
    PASSIGN_LIST assignList,
                 prevEntry;
    TCHAR        newName[4];
    WCHAR        targetPath[100];
    LONG         partitionNumber;
    ULONG        index;

    assignList = AssignDriveLetterListHead;
    while (assignList) {

        if ((assignList->DriveLetter != NO_DRIVE_LETTER_YET) && (assignList->DriveLetter != NO_DRIVE_LETTER_EVER)) {

            diskp = Disks[assignList->DiskNumber];
            partitionNumber = 0;
            for (index = 0; index < diskp->RegionCount; index++) {

                regionDescriptor = &diskp->RegionArray[index];

                if (DmSignificantRegion(regionDescriptor)) {

                    // If the region has a drive letter, use the drive letter
                    // to get the info via the Windows API.  Otherwise we'll
                    // have to use the NT API.

                    regionData = PERSISTENT_DATA(regionDescriptor);

                    if (regionData) {
                        if (regionData->DriveLetter == assignList->DriveLetter) {
                            partitionNumber = regionDescriptor->Reserved->Partition->PartitionNumber;
                            regionDescriptor->PartitionNumber = partitionNumber;
                            break;
                        }
                    }
                }
            }

            if (partitionNumber) {
                HANDLE handle;
                ULONG  status;

                // set up the new NT path.

                wsprintf((LPTSTR) targetPath,
                         "%s\\Partition%d",
                         GetDiskName(assignList->DiskNumber),
                         partitionNumber);

                // Set up the DOS name.

                newName[1] = (TCHAR)':';
                newName[2] = 0;

                if (assignList->MoveLetter) {

                    // The letter must be removed before it
                    // can be assigned.

                    newName[0] = (TCHAR)assignList->OriginalLetter;
                    NetworkRemoveShare((LPCTSTR) newName);
                    DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) newName, (LPCTSTR) NULL);
                    newName[0] = (TCHAR)assignList->DriveLetter;

                } else {
                    newName[0] = (TCHAR)assignList->DriveLetter;
                }

                // Assign the name - don't worry about errors for now.

                DefineDosDevice(DDD_RAW_TARGET_PATH, (LPCTSTR) newName, (LPCTSTR) targetPath);
                NetworkShare((LPCTSTR) newName);

                // Some of the file systems do not actually dismount
                // when requested.  Instead, they set a verification
                // bit in the device object.  Due to dynamic partitioning
                // this bit may get cleared by the process of the
                // repartitioning and the file system will then
                // assume it is still mounted on a new access.
                // To get around this problem, new drive letters
                // are always locked and dismounted on creation.

                status = LowOpenDriveLetter(assignList->DriveLetter,
                                            &handle);

                if (NT_SUCCESS(status)) {

                    // Lock the drive to insure that no other access is occurring
                    // to the volume.

                    status = LowLockDrive(handle);

                    if (NT_SUCCESS(status)) {
                        LowUnlockDrive(handle);
                    }
                    LowCloseDisk(handle);
                }

            } else {
                ErrorDialog(MSG_INTERNAL_LETTER_ASSIGN_ERROR);
            }
        }

        prevEntry = assignList;
        assignList = assignList->Next;
        Free(prevEntry);
    }
    AssignDriveLetterListHead = NULL;
}

LONG
CommitInternalLockDriveLetter(
    IN PDRIVE_LOCKLIST LockListEntry
    )

/*++

Routine Description:

    Support routine to perform the locking of a drive letter based on
    the locklist entry given.

Arguments:

    LockListEntry - The information about what to lock.

Return Values:

    zero - success
    non-zero failure

--*/

{
    ULONG           status;

    // Lock the disk and save the handle.

    status = LowOpenDriveLetter(LockListEntry->DriveLetter,
                                &LockListEntry->LockHandle);

    if (!NT_SUCCESS(status)) {
        return 1;
    }


    // Lock the drive to insure that no other access is occurring
    // to the volume.

    status = LowLockDrive(LockListEntry->LockHandle);

    if (!NT_SUCCESS(status)) {
        LowCloseDisk(LockListEntry->LockHandle);
        return 1;
    }

    LockListEntry->CurrentlyLocked = TRUE;
    return 0;
}

LONG
CommitToLockList(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN BOOL               RemoveDriveLetter,
    IN BOOL               LockNow,
    IN BOOL               FailOk
    )

/*++

Routine Description:

    This routine adds the given drive into the lock list for processing
    when a commit occurs.  If the LockNow flag is set it indicates that
    the drive letter is to be immediately locked if it is to go in the
    lock letter list.  If this locking fails an error is returned.

Arguments:

    RegionDescriptor  - the region for the drive to lock.
    RemoveDriveLetter - remove the letter when performing the unlock.
    LockNow           - If the letter is inserted in the list - lock it now.
    FailOk            - It is ok to fail the lock - used for disabled FT sets.

Return Values:

    non-zero - failure to add to list.

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDRIVE_LOCKLIST         lockListEntry;
    UCHAR                   driveLetter;
    ULONG                   diskNumber;

    if (!regionData) {

        // without region data there is no need to be on the lock list.

        return 0;
    }

    // See if this drive letter is already in the lock list.

    driveLetter = regionData->DriveLetter;

    if ((driveLetter == NO_DRIVE_LETTER_YET) || (driveLetter == NO_DRIVE_LETTER_EVER)) {

        // There is no drive letter to lock.

        CommitDueToDelete = RemoveDriveLetter;
        return 0;
    }

    if (!regionData->VolumeExists) {
        PASSIGN_LIST assignList,
                     prevEntry;

        // This item has never been created so no need to put it in the
        // lock list.  But it does need to be removed from the assign
        // letter list.

        prevEntry = NULL;
        assignList = AssignDriveLetterListHead;
        while (assignList) {

            // If a match is found remove it from the list.

            if (assignList->DriveLetter == driveLetter) {
                if (prevEntry) {
                    prevEntry->Next = assignList->Next;
                } else {
                    AssignDriveLetterListHead = assignList->Next;
                }

                Free(assignList);
                assignList = NULL;
            } else {

                prevEntry = assignList;
                assignList = assignList->Next;
            }
        }
        return 0;
    }

    diskNumber = RegionDescriptor->Disk;
    lockListEntry = DriveLockListHead;
    while (lockListEntry) {
        if (lockListEntry->DriveLetter == driveLetter) {

            // Already in the list -- update when to lock and unlock

            if (diskNumber < lockListEntry->LockOnDiskNumber) {
                lockListEntry->LockOnDiskNumber = diskNumber;
            }

            if (diskNumber > lockListEntry->UnlockOnDiskNumber) {
                lockListEntry->UnlockOnDiskNumber = diskNumber;
            }

            // Already in the lock list and information for locking set up.
            // Check to see if this should be a LockNow request.

            if (LockNow) {
               if (!lockListEntry->CurrentlyLocked) {

                    // Need to perform the lock.

                    if (CommitInternalLockDriveLetter(lockListEntry)) {

                        // Leave the element in the list

                        return 1;
                    }
                }
            }
            return 0;

        }
        lockListEntry = lockListEntry->Next;
    }

    lockListEntry = (PDRIVE_LOCKLIST) Malloc(sizeof(DRIVE_LOCKLIST));

    if (!lockListEntry) {
        return 1;
    }

    // set up the lock list entry.

    lockListEntry->LockHandle = NULL;
    lockListEntry->PartitionNumber = RegionDescriptor->PartitionNumber;
    lockListEntry->DriveLetter = driveLetter;
    lockListEntry->RemoveOnUnlock = RemoveDriveLetter;
    lockListEntry->CurrentlyLocked = FALSE;
    lockListEntry->FailOk = FailOk;
    lockListEntry->DiskNumber = lockListEntry->UnlockOnDiskNumber =
                                lockListEntry->LockOnDiskNumber = diskNumber;

    if (LockNow) {
        if (CommitInternalLockDriveLetter(lockListEntry)) {

            // Do not add this to the list.

            Free(lockListEntry);
            return 1;
        }
    }

    // place it at the front of the chain.

    lockListEntry->Next = DriveLockListHead;
    DriveLockListHead = lockListEntry;
    return 0;
}

LONG
CommitLockVolumes(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine will go through any drive letters inserted in the lock list
    for the given disk number and attempt to lock the volumes.  Currently,
    this routine locks all of the drives letters in the lock list when
    called the first time (i.e. when Disk == 0).

Arguments:

    Disk - the index into the disk table.

Return Values:

    non-zero - failure to lock the items in the list.

--*/

{
    PDRIVE_LOCKLIST lockListEntry;

    if (Disk) {
        return 0;
    }


    for (lockListEntry = DriveLockListHead; lockListEntry; lockListEntry = lockListEntry->Next) {

        // Lock the disk.  Return on any failure if that is the
        // requested action for the entry.  It is the responsibility
        // of the caller to release any successful locks.

        if (!lockListEntry->CurrentlyLocked) {
            if (CommitInternalLockDriveLetter(lockListEntry)) {
                if (!lockListEntry->FailOk) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

LONG
CommitUnlockVolumes(
    IN ULONG   Disk,
    IN BOOLEAN FreeList
    )

/*++

Routine Description:

    Go through and unlock any locked volumes in the locked list for the
    given disk.  Currently this routine waits until the last disk has
    been processed, then unlocks all disks.

Arguments:

    Disk - the index into the disk table.
    FreeList - Clean up the list as unlocks are performed or don't

Return Values:

    non-zero - failure to lock the items in the list.

--*/

{
    PDRIVE_LOCKLIST lockListEntry,
                    previousLockListEntry;
    TCHAR           name[4];

    if (Disk != GetDiskCount()) {
        return 0;
    }

    lockListEntry = DriveLockListHead;
    if (FreeList) {
        DriveLockListHead = NULL;
    }
    while (lockListEntry) {

        // Unlock the disk.

        if (lockListEntry->CurrentlyLocked) {

            if (FreeList && lockListEntry->RemoveOnUnlock) {

                // set up the new dos name and NT path.

                name[0] = (TCHAR)lockListEntry->DriveLetter;
                name[1] = (TCHAR)':';
                name[2] = 0;

                NetworkRemoveShare((LPCTSTR) name);
                if (!DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) name, (LPCTSTR) NULL)) {

                    // could not remove name!!?

                }
            }
            LowUnlockDrive(lockListEntry->LockHandle);
            LowCloseDisk(lockListEntry->LockHandle);
        }

        // Move to the next entry.  If requested free this entry.

        previousLockListEntry = lockListEntry;
        lockListEntry = lockListEntry->Next;
        if (FreeList) {
            Free(previousLockListEntry);
        }
    }
    return 0;
}

LETTER_ASSIGNMENT_RESULT
CommitDriveLetter(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN CHAR OldDrive,
    IN CHAR NewDrive
    )

/*++

Routine Description:

    This routine will update the drive letter information in the registry and
    (if the update works) it will attempt to move the current drive letter
    to the new one via DefineDosDevice()

Arguments:

    RegionDescriptor - the region that should get the letter.
    NewDrive         - the new drive letter for the volume.

Return Value:

    0 - the assignment failed.
    1 - if the assigning of the letter occurred interactively.
    2 - must reboot to do the letter.

--*/

{
    PPERSISTENT_REGION_DATA regionData;
    PDRIVE_LOCKLIST         lockListEntry;
    PASSIGN_LIST            assignList;
    HANDLE                  handle;
    TCHAR                   newName[4];
    WCHAR                   targetPath[100];
    int                     doIt;
    STATUS_CODE             status = ERROR_SEVERITY_ERROR;
    LETTER_ASSIGNMENT_RESULT result = Failure;

    regionData = PERSISTENT_DATA(RegionDescriptor);

    // check the assign letter list for a match.
    // If the letter is there, then just update the list
    // otherwise continue on with the action.

    assignList = AssignDriveLetterListHead;
    while (assignList) {

        if (assignList->DriveLetter == (UCHAR)OldDrive) {
            assignList->DriveLetter = (UCHAR)NewDrive;
            return Complete;
        }
        assignList = assignList->Next;
    }

    // Search to see if the drive is currently locked.

    for (lockListEntry = DriveLockListHead;
         lockListEntry;
         lockListEntry = lockListEntry->Next) {

        if ((lockListEntry->DiskNumber == RegionDescriptor->Disk) &&
            (lockListEntry->PartitionNumber == RegionDescriptor->PartitionNumber)) {

            if (lockListEntry->CurrentlyLocked) {
                status = 0;
            }

            // found the match no need to continue searching.

            break;
        }
    }

    if (!NT_SUCCESS(status)) {

        // See if the drive can be locked.

        status = LowOpenPartition(GetDiskName(RegionDescriptor->Disk),
                                  RegionDescriptor->PartitionNumber,
                                  &handle);

        if (!NT_SUCCESS(status)) {
            return Failure;
        }

        // Lock the drive to insure that no other access is occurring
        // to the volume.

        status = LowLockDrive(handle);

        if (!NT_SUCCESS(status)) {

            if (IsPagefileOnDrive(OldDrive)) {

                ErrorDialog(MSG_CANNOT_LOCK_PAGEFILE);
            } else {

                ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
            }
            doIt = ConfirmationDialog(MSG_SCHEDULE_REBOOT, MB_ICONQUESTION | MB_YESNO);

            LowCloseDisk(handle);
            if (doIt == IDYES) {
                RegistryChanged = TRUE;
                RestartRequired = TRUE;
                return MustReboot;
            }
            return Failure;
        }
    } else {

        // This drive was found in the lock list and is already
        // in the locked state.  It is safe to continue with
        // the drive letter assignment.

    }

    doIt = ConfirmationDialog(MSG_DRIVE_RENAME_WARNING, MB_ICONQUESTION | MB_YESNOCANCEL);

    if (doIt != IDYES) {

        LowUnlockDrive(handle);
        LowCloseDisk(handle);
        return Failure;
    }

    // Update the registry first.  This way if something goes wrong
    // the new letter will arrive on reboot.

    if (!DiskRegistryAssignDriveLetter(Disks[RegionDescriptor->Disk]->Signature,
                                      FdGetExactOffset(RegionDescriptor),
                                      FdGetExactSize(RegionDescriptor, FALSE),
                                      (UCHAR)((NewDrive == NO_DRIVE_LETTER_EVER) ? (UCHAR)' ' : (UCHAR)NewDrive))) {

        // Registry update failed.

        return Failure;
    }

    // It is safe to change the drive letter.  First, remove the
    // existing letter.

    newName[0] = (TCHAR)OldDrive;
    newName[1] = (TCHAR)':';
    newName[2] = 0;

    NetworkRemoveShare((LPCTSTR) newName);
    if (!DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) newName, (LPCTSTR) NULL)) {

        LowUnlockDrive(handle);
        LowCloseDisk(handle);
        RegistryChanged = TRUE;
        return Failure;
    }

    if (NewDrive != NO_DRIVE_LETTER_EVER) {

        // set up the new dos name and NT path.

        newName[0] = (TCHAR)NewDrive;
        newName[1] = (TCHAR)':';
        newName[2] = 0;

        wsprintf((LPTSTR) targetPath,
                 "%s\\Partition%d",
                 GetDiskName(RegionDescriptor->Disk),
                 RegionDescriptor->PartitionNumber);

        if (DefineDosDevice(DDD_RAW_TARGET_PATH, (LPCTSTR) newName, (LPCTSTR) targetPath)) {
            result = Complete;
        } else {
            RegistryChanged = TRUE;
        }
        NetworkShare((LPCTSTR) newName);
    } else {
        result = Complete;
    }

    // Force the file system to dismount

    LowUnlockDrive(handle);
    LowCloseDisk(handle);
    return result;
}

VOID
CommitUpdateRegionStructures(
    VOID
    )

/*++

Routine Description:

    This routine is called ONLY after a successful commit of a new partitioning
    scheme for the system.  Its is responsible for walking through the
    region arrays for each of the disks and updating the regions to indicate
    their transition from being "desired" to being actually committed
    to disk

Arguments:

    None

Return Values:

    None

--*/

{
    PDISKSTATE              diskState;
    PREGION_DESCRIPTOR      regionDescriptor;
    PPERSISTENT_REGION_DATA regionData;
    ULONG                   regionNumber,
                            diskNumber;

    // search through all disks in the system.

    for (diskNumber = 0, diskState = Disks[0]; diskNumber < DiskCount; diskState = Disks[++diskNumber]) {

        // Look at every region array entry and update the values
        // to indicate that this region now exists.

        for (regionNumber = 0; regionNumber < diskState->RegionCount; regionNumber++) {

            regionDescriptor = &diskState->RegionArray[regionNumber];
            if (regionDescriptor->Reserved) {
                if (regionDescriptor->Reserved->Partition) {
                    regionDescriptor->Reserved->Partition->CommitMirrorBreakNeeded = FALSE;
                }
            }
            regionData = PERSISTENT_DATA(regionDescriptor);
            if ((regionData) && (!regionData->VolumeExists)) {

                // By definition and assumption of this routine,
                // this region has just been committed to disk.

                regionData->VolumeExists = TRUE;

                if (regionData->TypeName) {
                    Free(regionData->TypeName);
                }
                regionData->TypeName = Malloc((lstrlenW(wszUnformatted)+1)*sizeof(WCHAR));
                lstrcpyW(regionData->TypeName, wszUnformatted);
            }
        }
    }
}

VOID
CommitAllChanges(
    IN PVOID Param
    )

/*++

Routine Description:

    This routine will go through all of the region descriptors and commit
    any changes that have occurred to disk.  Then it "re-initializes"
    Disk Administrator and start the display/work process over again.

Arguments:

    Param - undefined for now

Return Value:

    None

--*/

{
    DWORD                   action,
                            errorCode;
    ULONG                   diskCount,
                            temp;
    BOOL                    profileWritten,
                            changesMade,
                            mustReboot,
                            configureFt;

    SetCursor(hcurWait);
    diskCount = GetDiskCount();

    // Determine whether any disks have been changed, and whether
    // the system must be rebooted.  The system must be rebooted
    // if the registry has changed, if any non-removable disk has
    // changed, or if any removable disk that was not originally
    // unpartitioned has changed.

    changesMade = configureFt = FALSE;
    mustReboot = RestartRequired;

    for (temp=0; temp<diskCount; temp++) {
        if (HavePartitionsBeenChanged(temp)) {

            changesMade = TRUE;
            break;
        }
    }

    profileWritten = FALSE;

    // Determine if the commit can be done without a reboot.
    // If FT is in the system then it must be notified to
    // reconfigure if a reboot is not performed.  If it is
    // not in the system, but the new disk information requires
    // it, then a reboot must be forced.

    if (FtInstalled()) {
        configureFt = TRUE;
    }
    if (NewConfigurationRequiresFt()) {
        if (!configureFt) {

            // The FT driver is not loaded currently.

            mustReboot = TRUE;
        } else {

            // If the system is going to be rebooted, don't
            // have FT reconfigure prior to shutdown.

            if (mustReboot) {
                configureFt = FALSE;
            }
        }
    }

    if (RegistryChanged | changesMade | RestartRequired) {

        if (RestartRequired) {
            action = IDYES;
        } else {
            action = ConfirmationDialog(MSG_CONFIRM_EXIT, MB_ICONQUESTION | MB_YESNOCANCEL);
        }

        if (action == IDYES) {
            errorCode = CommitLockVolumes(0);
            if (errorCode) {

                // could not lock all volumes

                SetCursor(hcurNormal);
                ErrorDialog(MSG_CANNOT_LOCK_FOR_COMMIT);
                CommitUnlockVolumes(diskCount, FALSE);
                return;
            }

            if (mustReboot) {

                SetCursor(hcurNormal);
                if (RestartRequired) {
                    action = IDYES;
                } else {
                    action = ConfirmationDialog(MSG_REQUIRE_REBOOT, MB_ICONQUESTION | MB_YESNO);
                }

                if (action != IDYES) {

                    CommitUnlockVolumes(diskCount, FALSE);
                    return;
                }
            }

            SetCursor(hcurWait);
            errorCode = CommitChanges();
            CommitUnlockVolumes(diskCount, TRUE);
            SetCursor(hcurNormal);

            if (errorCode != NO_ERROR) {
                ErrorDialog(MSG_BAD_CONFIG_SET);
                PostQuitMessage(0);
            } else {
                ULONG OldBootPartitionNumber,
                      NewBootPartitionNumber;
                CHAR  OldNumberString[8],
                      NewNumberString[8];
                DWORD MsgCode;

                // Update the configuration registry

                errorCode = SaveFt();

                // Check if FTDISK drive should reconfigure.

                if (configureFt) {

                    // Issue device control to ftdisk driver to reconfigure.

                    FtConfigure();
                }

                // Register autochk to fix up file systems
                // in newly extended volume sets, if necessary

                if (RegisterFileSystemExtend()) {
                    mustReboot = TRUE;
                }

                // Determine if the FT driver must be enabled.

                if (DiskRegistryRequiresFt() == TRUE) {
                    if (!FtInstalled()) {
                        mustReboot = TRUE;
                    }
                    DiskRegistryEnableFt();
                } else {
                    DiskRegistryDisableFt();
                }

                if (errorCode == NO_ERROR) {
                    InfoDialog(MSG_OK_COMMIT);
                } else {
                    ErrorDialog(MSG_BAD_CONFIG_SET);
                }

                // Has the partition number of the boot
                // partition changed?

                if (BootPartitionNumberChanged( &OldBootPartitionNumber,&NewBootPartitionNumber)) {
#if i386
                    MsgCode = MSG_BOOT_PARTITION_CHANGED_X86;
#else
                    MsgCode = MSG_BOOT_PARTITION_CHANGED_ARC;
#endif
                    sprintf(OldNumberString, "%d", OldBootPartitionNumber);
                    sprintf(NewNumberString, "%d", NewBootPartitionNumber);
                    InfoDialog(MsgCode, OldNumberString, NewNumberString);
                }

                ClearCommittedDiskInformation();

                if (UpdateMbrOnDisk) {

                    UpdateMasterBootCode(UpdateMbrOnDisk);
                    UpdateMbrOnDisk = 0;
                }

                // Reboot if necessary.

                if (mustReboot) {

                    SetCursor(hcurWait);
                    Sleep(5000);
                    SetCursor(hcurNormal);
                    FdShutdownTheSystem();
                    profileWritten = TRUE;
                }
                CommitAssignLetterList();
                CommitUpdateRegionStructures();
                RegistryChanged = FALSE;
                CommitDueToDelete = CommitDueToMirror = FALSE;
                TotalRedrawAndRepaint();
                AdjustMenuAndStatus();
            }
        } else if (action == IDCANCEL) {
            return;      // don't exit
        } else {
            FDASSERT(action == IDNO);
        }
    }
}

VOID
FtConfigure(
    VOID
    )

/*++

Routine Description:

    This routine calls the FTDISK driver to ask it to reconfigure as changes
    have been made in the registry.

Arguments:

    None

Return Value:

    None

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    STRING            ntFtName;
    IO_STATUS_BLOCK   statusBlock;
    UNICODE_STRING    unicodeDeviceName;
    NTSTATUS          status;
    HANDLE            handle;

    // Open ft control object.

    RtlInitString(&ntFtName,
                  "\\Device\\FtControl");
    RtlAnsiStringToUnicodeString(&unicodeDeviceName,
                                 &ntFtName,
                                 TRUE);
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeDeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = DmOpenFile(&handle,
                        SYNCHRONIZE | FILE_ANY_ACCESS,
                        &objectAttributes,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT );
    RtlFreeUnicodeString(&unicodeDeviceName);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Issue device control to reconfigure FT.

    NtDeviceIoControlFile(handle,
                          NULL,
                          NULL,
                          NULL,
                          &statusBlock,
                          FT_CONFIGURE,
                          NULL,
                          0L,
                          NULL,
                          0L);

    DmClose(handle);
    return;
}

BOOL
CommitAllowed(
    VOID
    )

/*++

Routine Description:

    Determine if it is ok to perform a commit.

Arguments:

    None

Return Value:

    TRUE if it is ok to commit and there is something to commit
    FALSE otherwise

--*/

{
    if (DriveLockListHead ||
        AssignDriveLetterListHead ||
        CommitDueToDelete ||
        CommitDueToMirror ||
        CommitDueToExtended) {
        return TRUE;
    }
    return FALSE;
}

VOID
RescanDevices(
    VOID
    )

/*++

Routine Description:

    This routine performs all actions necessary to dynamically rescan
    device buses (i.e. SCSI) and get the appropriate driver support loaded.

Arguments:

    None

Return Value:

    None

--*/

{
    PSCSI_ADAPTER_BUS_INFO adapterInfo;
    PSCSI_BUS_DATA         busData;
    PSCSI_INQUIRY_DATA     inquiryData;
    TCHAR                  physicalName[32];
    TCHAR                  driveName[32];
    BYTE                   driveBuffer[32];
    BYTE                   physicalBuffer[32];
    HANDLE                 volumeHandle;
    STRING                 string;
    UNICODE_STRING         unicodeString;
    UNICODE_STRING         physicalString;
    OBJECT_ATTRIBUTES      objectAttributes;
    NTSTATUS               ntStatus;
    IO_STATUS_BLOCK        statusBlock;
    BOOLEAN                diskFound,
                           cdromFound;
    ULONG                  bytesTransferred,
                           i,
                           j,
                           deviceNumber,
                           currentPort,
                           numberOfPorts,
                           percentComplete,
                           portNumber;

    diskFound = FALSE;
    cdromFound = FALSE;

    // Determine how many buses there are

    portNumber = numberOfPorts = percentComplete = 0;
    while (TRUE) {

        memset(driveBuffer, 0, sizeof(driveBuffer));
        sprintf(driveBuffer, "\\\\.\\Scsi%d:", portNumber);

        // Open the SCSI port with the DOS name.

        volumeHandle = CreateFile(driveBuffer,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  0);

        if (volumeHandle == INVALID_HANDLE_VALUE) {
            break;
        }

        CloseHandle(volumeHandle);
        numberOfPorts++;
        portNumber++;
    }

    currentPort = 1;
    portNumber = 0;

    // Perform the scsi bus rescan.

    while (TRUE) {

        memset(driveBuffer, 0, sizeof(driveBuffer));
        sprintf(driveBuffer, "\\\\.\\Scsi%d:", portNumber);

        // Open the SCSI port with the DOS name.

        volumeHandle = CreateFile(driveBuffer,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  0);

        if (volumeHandle == INVALID_HANDLE_VALUE) {
            break;
        }

        // Issue rescan device control.

        if (!DeviceIoControl(volumeHandle,
                             IOCTL_SCSI_RESCAN_BUS,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesTransferred,
                             NULL)) {

            CloseHandle(volumeHandle);
            break;
        }

        percentComplete = (currentPort * 100) / numberOfPorts;

        if (percentComplete < 100) {
            PostMessage(InitDlg,
                        WM_USER,
                        percentComplete,
                        0);
        }

        currentPort++;

        // Get a big chuck of memory to store the SCSI bus data.

        adapterInfo = malloc(0x4000);

        if (adapterInfo == NULL) {
            CloseHandle(volumeHandle);
            goto finish;
        }

        // Issue device control to get configuration information.

        if (!DeviceIoControl(volumeHandle,
                             IOCTL_SCSI_GET_INQUIRY_DATA,
                             NULL,
                             0,
                             adapterInfo,
                             0x4000,
                             &bytesTransferred,
                             NULL)) {

            CloseHandle(volumeHandle);
            goto finish;
        }


        for (i = 0; i < adapterInfo->NumberOfBuses; i++) {

            busData = &adapterInfo->BusData[i];
            inquiryData =
                (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + busData->InquiryDataOffset);

            for (j = 0; j < busData->NumberOfLogicalUnits; j++) {

                // Check if device is claimed.

                if (!inquiryData->DeviceClaimed) {

                        // Determine the perpherial type.

                        switch (inquiryData->InquiryData[0] & 0x1f) {
                        case DIRECT_ACCESS_DEVICE:
                            diskFound = TRUE;
                            break;

                        case READ_ONLY_DIRECT_ACCESS_DEVICE:
                            cdromFound = TRUE;
                            break;

                        case OPTICAL_DEVICE:
                            diskFound = TRUE;
                            break;
                        }
                }

                // Get next device data.

                inquiryData =
                    (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + inquiryData->NextInquiryDataOffset);
            }
        }

        free(adapterInfo);
        CloseHandle(volumeHandle);

        portNumber++;
    }

    if (diskFound) {

        // Send IOCTL_DISK_FIND_NEW_DEVICES commands to each existing disk.

        deviceNumber = 0;
        while (TRUE) {

            memset(driveBuffer, 0, sizeof(driveBuffer));
            sprintf(driveBuffer, "\\Device\\Harddisk%d\\Partition0", deviceNumber);

            RtlInitString(&string, driveBuffer);
            ntStatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                    &string,
                                                    TRUE);
            if (!NT_SUCCESS(ntStatus)) {
                break;
            }
            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       0,
                                       NULL,
                                       NULL);
            ntStatus = DmOpenFile(&volumeHandle,
                                  FILE_READ_DATA  | FILE_WRITE_DATA | SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  | FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                RtlFreeUnicodeString(&unicodeString);
                break;
            }

            // Issue find device device control.

            if (!DeviceIoControl(volumeHandle,
                                 IOCTL_DISK_FIND_NEW_DEVICES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesTransferred,
                                 NULL)) {

            }
            DmClose(volumeHandle);

            // see if the physicaldrive# symbolic link is present

            sprintf(physicalBuffer, "\\DosDevices\\PhysicalDrive%d", deviceNumber);
            deviceNumber++;

            RtlInitString(&string, physicalBuffer);
            ntStatus = RtlAnsiStringToUnicodeString(&physicalString,
                                                    &string,
                                                    TRUE);
            if (!NT_SUCCESS(ntStatus)) {
                continue;
            }
            InitializeObjectAttributes(&objectAttributes,
                                       &physicalString,
                                       0,
                                       NULL,
                                       NULL);
            ntStatus = DmOpenFile(&volumeHandle,
                                  FILE_READ_DATA  | FILE_WRITE_DATA | SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  | FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                ULONG index;
                ULONG dest;

                // Name is not there - create it.  This copying
                // is done in case this code should ever become
                // unicode and the types for the two strings would
                // actually be different.
                //
                // Copy only the portion of the physical name
                // that is in the \dosdevices\ directory

                for (dest = 0, index = 12; TRUE; index++, dest++) {

                    physicalName[dest] = (TCHAR)physicalBuffer[index];
                    if (!physicalName[dest]) {
                        break;
                    }
                }

                // Copy all of the NT namespace name.

                for (index = 0; TRUE; index++) {

                    driveName[index] = (TCHAR) driveBuffer[index];
                    if (!driveName[index]) {
                        break;
                    }
                }

                DefineDosDevice(DDD_RAW_TARGET_PATH,
                                (LPCTSTR) physicalName,
                                (LPCTSTR) driveName);

            } else {
                DmClose(volumeHandle);
            }

            // free allocated memory for unicode string.

            RtlFreeUnicodeString(&unicodeString);
            RtlFreeUnicodeString(&physicalString);
        }
    }

    if (cdromFound) {

        // Send IOCTL_CDROM_FIND_NEW_DEVICES commands to each existing cdrom.

        deviceNumber = 0;
        while (TRUE) {

            memset(driveBuffer, 0, sizeof(driveBuffer));
            sprintf(driveBuffer, "\\Device\\Cdrom%d", deviceNumber);
            RtlInitString(&string, driveBuffer);

            ntStatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                    &string,
                                                    TRUE);

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       0,
                                       NULL,
                                       NULL);

            ntStatus = DmOpenFile(&volumeHandle,
                                  FILE_READ_DATA  | FILE_WRITE_DATA | SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  | FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            // Issue find device device control.

            if (!DeviceIoControl(volumeHandle,
                                 IOCTL_CDROM_FIND_NEW_DEVICES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesTransferred,
                                 NULL)) {
            }

            CloseHandle(volumeHandle);
            deviceNumber++;
        }
    }
finish:
    PostMessage(InitDlg,
                WM_USER,
                100,
                0);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fc\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=fc
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\fc.cxx ..\fc.rc

INCLUDES=..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

CXXFLAGS=+d
TARGETLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\dblspace.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dblspace.c

Abstract:

    This module contains the set of routines that deal with double space
    dialogs and support.

Author:

    Bob Rinne (bobri)  11/15/93

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "fmifs.h"
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <string.h>

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED

PREGION_DESCRIPTOR RegionForDblSpaceVolume;

ULONG DblSpaceThresholdSizes[] = { 10, 40, 100, (ULONG) -1 };

#define NUMBER_PARSEFORMAT_ITEMS 4
char *DblSpaceIniFileName = "%c:\\dblspace.ini";
char *DblSpaceWildCardFileName = "%c:\\dblspace.*";
char *DblSpaceParseFormat = "%s %s %d %d";

// All double space structures are chained into the base chain
// this allows for ease in initialization to determine which are
// mounted.  This chain is only used for initialization.

PDBLSPACE_DESCRIPTOR DblChainBase = NULL;
PDBLSPACE_DESCRIPTOR DblChainLast = NULL;

extern BOOLEAN DoubleSpaceSupported;

#define DblSpaceMountDrive(REGDESC, DBLSPACE) \
                                     DblSpaceChangeState(REGDESC, DBLSPACE, TRUE)
#define DblSpaceDismountDrive(REGDESC, DBLSPACE) \
                                     DblSpaceChangeState(REGDESC, DBLSPACE, FALSE)

VOID
DblSpaceUpdateIniFile(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    This routine is left around in case this code must update DOS
    based .ini files.  Currently it does nothing.

Arguments:

    The region with the double space volumes.

Return Value

    None

--*/

{
}

ULONG
DblSpaceChangeState(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpacePtr,
    IN BOOL                 Mount
    )

/*++

Routine Description:

    Based on the value of Mount, either mount the volume or
    dismount the Double Space volume

Arguments:

    RegionDescriptor - The region containing the double space volume
    DriveLetter      - The drive letter of the double space volume involved.
    Mount            - TRUE == perform a mount function
                       FALSE == dismount the volume

Return Value:

    None

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    WCHAR dblSpaceUniqueName[32];
    ULONG index;
    ULONG result = 0;

    SetCursor(hcurWait);

    if (Mount) {

        // Call fmifs mount routine.

        result = FmIfsMountDblspace(DblSpacePtr->FileName,
                                    regionData->DriveLetter,
                                    DblSpacePtr->NewDriveLetter);

    } else {

        // Call fmifs dismount routine.

        result = FmIfsDismountDblspace(DblSpacePtr->DriveLetter);
    }

    if (!result) {
        DblSpacePtr->Mounted = Mount;
        if (Mount) {
            DblSpacePtr->DriveLetter = DblSpacePtr->NewDriveLetter;
            MarkDriveLetterUsed(DblSpacePtr->DriveLetter);
        } else {
            TCHAR name[4];

            // remove the drive letter.

            name[0] = (TCHAR)DblSpacePtr->DriveLetter;
            name[1] = (TCHAR)':';
            name[2] = 0;

            DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) name, (LPCTSTR) NULL);

            // Now update the internal structures.

            MarkDriveLetterFree(DblSpacePtr->DriveLetter);
            DblSpacePtr->DriveLetter = ' ';
        }

        if (!IsDiskRemovable[RegionDescriptor->Disk]) {

            dblSpaceUniqueName[0] = (WCHAR) regionData->DriveLetter;
            dblSpaceUniqueName[1] = (WCHAR) ':';
            dblSpaceUniqueName[2] = (WCHAR) '\\';

            index = 0;
            while (dblSpaceUniqueName[index + 3] = DblSpacePtr->FileName[index]) {
                index++;
            }

            result = DiskRegistryAssignDblSpaceLetter(dblSpaceUniqueName,
                                                      (WCHAR) DblSpacePtr->DriveLetter);
        }
    }
    SetCursor(hcurNormal);
    return result;
}

PDBLSPACE_DESCRIPTOR
DblSpaceCreateInternalStructure(
    IN CHAR  DriveLetter,
    IN ULONG Size,
    IN PCHAR Name,
    IN BOOLEAN ChainIt
    )

/*++

Routine Description:

    This routine constructs the internal data structure that represents a
    double space volume.

Arguments:

    DriveLetter - drive letter for new internal structure
    Size        - size of the actual volume
    Name        - name of the containing double space file (i.e. dblspace.xxx)

Return Value:

    Pointer to the new structure if created.
    NULL if it couldn't be created.

--*/

{
    PDBLSPACE_DESCRIPTOR dblSpace;

    dblSpace = malloc(sizeof(DBLSPACE_DESCRIPTOR));
    if (dblSpace) {
        if (DriveLetter != ' ') {
            MarkDriveLetterUsed(DriveLetter);
        }
        dblSpace->DriveLetter = DriveLetter;
        dblSpace->DriveLetterEOS = 0;
        dblSpace->NewDriveLetter = 0;
        dblSpace->NewDriveLetterEOS = 0;
        dblSpace->ChangeDriveLetter = FALSE;
        dblSpace->Next = dblSpace->DblChainNext = NULL;
        dblSpace->Mounted = FALSE;
        dblSpace->ChangeMountState = FALSE;
        dblSpace->AllocatedSize = Size;
        dblSpace->FileName = malloc(strlen(Name) + 4);
        if (dblSpace->FileName) {

            // Copy the name.

            strcpy(dblSpace->FileName, Name);
            if (ChainIt) {
                if (DblChainBase) {
                    DblChainLast->DblChainNext = dblSpace;
                } else {
                    DblChainBase = dblSpace;
                }
                DblChainLast = dblSpace;
            }
        } else {

            // no memory - free what is allocated and give up.

            free(dblSpace);
            dblSpace = NULL;
        }
    }
    return dblSpace;
}

#define MAX_IFS_NAME_LENGTH 200
VOID
DblSpaceDetermineMounted(
    VOID
    )

/*++

Routine Description:

    This routine walks through all of the system drive letters to see
    if any are mounted double space volumes.  If a mounted double space
    volume is located it updates the state of that volume in the internal
    data structures for the double space volumes.

Arguments:

    None

Return Value:

    None

--*/

{
    PDBLSPACE_DESCRIPTOR dblSpace;
    ULONG                index;
    WCHAR                driveLetter[4],
                         ntDriveName[MAX_IFS_NAME_LENGTH],
                         cvfName[MAX_IFS_NAME_LENGTH],
                         hostDriveName[MAX_IFS_NAME_LENGTH],
                         compareName[MAX_IFS_NAME_LENGTH];
    UINT                 errorMode;
    BOOLEAN              removable,
                         floppy,
                         compressed,
                         error;

    driveLetter[1] = (WCHAR) ':';
    driveLetter[2] = 0;

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    for (driveLetter[0] = (WCHAR) 'C'; driveLetter[0] < (WCHAR) 'Z'; driveLetter[0]++) {

        if (DriveLetterIsAvailable((CHAR)driveLetter[0])) {

            // No sense calling this stuff for something that doesn't exist

            continue;
        }

        compressed = FALSE;
        if (FmIfsQueryInformation(&driveLetter[0],
                                  &removable,
                                  &floppy,
                                  &compressed,
                                  &error,
                                  &ntDriveName[0],
                                  MAX_IFS_NAME_LENGTH,
                                  &cvfName[0],
                                  MAX_IFS_NAME_LENGTH,
                                  &hostDriveName[0],
                                  MAX_IFS_NAME_LENGTH)) {
            // call worked, see if it is a double space volume

            if (compressed) {

                // now need to find this volume in the chain and
                // update it mounted state.

                for (dblSpace = DblChainBase;
                     dblSpace;
                     dblSpace = dblSpace->DblChainNext) {

                    for (index = 0;
                        compareName[index] = (WCHAR) dblSpace->FileName[index];
                        index++)  {
                        // Everything in for loop
                    }

                    if (!wcscmp(compareName, cvfName)) {

                        // found a match.

                        dblSpace->Mounted = TRUE;
                        dblSpace->DriveLetter = (UCHAR) driveLetter[0];
                    }
                }
            }
        }
    }
    SetErrorMode(errorMode);
}

VOID
DblSpaceInitialize(
    VOID
    )

/*++

Routine Description:

    This routine goes through the disk table and searches for FAT format
    partitions.  When one is found, it checks for the presense of DoubleSpace
    volumes and initializes the DoubleSpace support structures inside
    Disk Administrator.

Arguments:

    None

Return Value:

    None

--*/

{
    PDISKSTATE              diskState;
    PREGION_DESCRIPTOR      regionDesc;
    PPERSISTENT_REGION_DATA regionData;
    PDBLSPACE_DESCRIPTOR    dblSpace,
                            prevDblSpace;
    FILE                   *dblSpaceIniFile,
                           *dblSpaceFile;
    CHAR                    driveLetter[10];
    CHAR                    fileName[50];
    ULONG                   size,
                            mounted;
    int                     items;
    unsigned                diskIndex,
                            regionIndex;

    for (diskIndex = 0; diskIndex < DiskCount; diskIndex++) {

        diskState = Disks[diskIndex];
        regionDesc = diskState->RegionArray;
        for (regionIndex = 0; regionIndex < diskState->RegionCount; regionIndex++) {

            regionData = PERSISTENT_DATA(&regionDesc[regionIndex]);

            // region may be free or something that isn't recognized by NT

            if (!regionData) {
                continue;
            }

            // region may not be formatted yet.

            if (!regionData->TypeName) {
                continue;
            }

            // Double space volumes are only allowed on FAT non-FT partitions.

            if (regionData->FtObject) {
                continue;
            }

            if (wcscmp(regionData->TypeName, L"FAT") == 0) {
                WIN32_FIND_DATA findInformation;
                HANDLE          findHandle;

                // it is possible to have a double space volume here.
                // Search the root directory of the driver for files with
                // the name "dblspace.xxx".  These are potentially dblspace
                // volumes.

                prevDblSpace = NULL;
                sprintf(fileName, DblSpaceWildCardFileName, regionData->DriveLetter);
                findHandle = FindFirstFile(fileName, &findInformation);
                while (findHandle != INVALID_HANDLE_VALUE) {
                    char *cp;
                    int  i;
                    int  save;

                    // There is at least one dblspace volume.  Insure that
                    // the name is of the proper form.

                    save = TRUE;
                    cp = &findInformation.cFileName[0];

                    while (*cp) {
                        if (*cp == '.') {
                            break;
                        }
                        cp++;
                    }

                    if (*cp != '.') {

                        // not a proper dblspace volume name.

                        save = FALSE;
                    } else {

                        cp++;

                        for (i = 0; i < 3; i++, cp++) {
                            if ((*cp < '0') || (*cp > '9')) {
                                break;
                            }
                        }

                        if (i != 3) {

                            // not a proper dblspace volume name.

                            save = FALSE;
                        }
                    }

                    if (save) {

                        // save the information and search for more.

                        dblSpace =
                            DblSpaceCreateInternalStructure(' ',
                                                            ((findInformation.nFileSizeHigh << 16) |
                                                             (findInformation.nFileSizeLow)
                                                             / (1024 * 1024)),
                                                            &findInformation.cFileName[0],
                                                            TRUE);
                        if (dblSpace) {

                            // Assume volume is not mounted.

                            dblSpace->Mounted = FALSE;
                            dblSpace->ChangeMountState = FALSE;

                            // Chain in this description.

                            if (prevDblSpace) {
                                prevDblSpace->Next = dblSpace;
                            } else {
                                regionData->DblSpace = dblSpace;
                            }

                            // Keep the pointer to this one for the chain.

                            prevDblSpace = dblSpace;
                        } else {

                            // no memory

                            break;
                        }
                    }

                    if (!FindNextFile(findHandle, &findInformation)) {

                        // Technically this should double check and call
                        // GetLastError to see that it is ERROR_NO_MORE_FILES
                        // but this code doesn't do that.

                        FindClose(findHandle);

                        // Get out of the search loop.

                        findHandle = INVALID_HANDLE_VALUE;
                    }
                }
            }
        }
    }

    // Now that all volumes have been located determine which volumes
    // are mounted by chasing down the drive letters.

    LoadIfsDll();
    DblSpaceDetermineMounted();
}

PDBLSPACE_DESCRIPTOR
DblSpaceGetNextVolume(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )

/*++

Routine Description:

    This routine will check the RegionDescriptor to walk the DoubleSpace volume chain
    located from the persistent data.

Arguments:

    RegionDescriptor - pointer to the region on the disk that is to be searched for
                       a DoubleSpace volume.

    DblSpace - pointer to the last DoubleSpace volume located on the region.

Return Value:

    pointer to the next DoubleSpace volume if found
    NULL if no volume found.

--*/

{
    PPERSISTENT_REGION_DATA regionData;

    // If a previous DoubleSpace location was past, simply walk the chain to the next.

    if (DblSpace) {
        return DblSpace->Next;
    }

    // no previous DoubleSpace location, just get the first one and return it.
    // Could get a NULL RegionDescriptor.  If so, return NULL.

    if (RegionDescriptor) {
        regionData = PERSISTENT_DATA(RegionDescriptor);
        if (!regionData) {
            return NULL;
        }
    } else {
        return NULL;
    }
    return regionData->DblSpace;
}

VOID
DblSpaceLinkNewVolume(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )

/*++

Routine Description:

    Chain the new double space volume on the list of double space volumes
    for the region.

Arguments:

    RegionDescriptor - the region the double space volume has been added to.
    DblSpace         - the new volume internal data structure.

Return Value:

    None

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    prevDblSpace;

    // if this is the first one, chain it first

    if (!regionData->DblSpace) {
        regionData->DblSpace = DblSpace;
        return;
    }

    for (prevDblSpace = regionData->DblSpace;
        prevDblSpace->Next;
        prevDblSpace = prevDblSpace->Next) {

        // all the work is in the for
    }

    // found the last one.  Add the new one to the chain

    prevDblSpace->Next = DblSpace;
}

BOOL
DblSpaceVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Indicate to the caller if the input region contains a DoubleSpace volume.

Arguments:

    RegionDescriptor - a pointer to the region in question.

Return Value:

    TRUE if this region contains DoubleSpace volume(s).
    FALSE if not

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);

    if (regionData) {
        return(regionData->DblSpace ? TRUE : FALSE);
    }
    return FALSE;
}

BOOL
DblSpaceDismountedVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Indicate to the caller if the input region contains a DoubleSpace volume
    that is not mounted.

Arguments:

    RegionDescriptor - a pointer to the region in question.

Return Value:

    TRUE if this region contains DoubleSpace volume(s).
    FALSE if not

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace;

    if (regionData) {
        if (dblSpace = regionData->DblSpace) {
            while (dblSpace) {
                if (!dblSpace->Mounted) {
                    return TRUE;
                }
                dblSpace = dblSpace->Next;
            }
        }
    }
    return FALSE;
}

PDBLSPACE_DESCRIPTOR
DblSpaceFindVolume(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN PCHAR Name
    )

/*++

Routine Description:

    Given a region and a name, locate the double space data structure.

Arguments:

    RegionDescriptor - the region to search
    Name - the filename wanted.

Return Value:

    A pointer to a double space descriptor if found.
    NULL if not found.

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace = NULL;
    PCHAR string[50];

    if (regionData) {
        for (dblSpace = regionData->DblSpace; dblSpace; dblSpace = dblSpace->Next) {
            if (strcmp(Name, dblSpace->FileName) == 0) {

                // found the desired double space volume

                break;
            }
        }
    }
    return dblSpace;
}


BOOL
DblSpaceDetermineUniqueFileName(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN PUCHAR             FileName
    )

/*++

Routine Description:

    This routine will search the actual partition to determine what
    valid double space file name to use (i.e. dblspace.xxx where xxx
    is a unique number).

Arguments:

    RegionDescriptor - the region to search and determine what double space
                       file names are in use.
    FileName   - a pointer to a character buffer for the name.

Return Value:

    None

--*/

{
    DWORD uniqueNumber = 0;
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace;

    do {
        sprintf(FileName, "dblspace.%03d", uniqueNumber++);
        if (uniqueNumber > 999) {
            return FALSE;
        }
    } while (DblSpaceFindVolume(RegionDescriptor, FileName));
    return TRUE;
}

VOID
DblSpaceRemoveVolume(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN UCHAR              DriveLetter
    )

/*++

Routine Description:

    Find the drive letter provided and unlink it from the chain.
    Currently this also removes the volume for the scaffolding file.

Arguments:

    RegionDescriptor - region containing the double space volume.
    DriveLetter - the drive letter to remove.

Return Value:

    None

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace,
                            prevDblSpace = NULL;

    // Clean up the internal structures.

    if (regionData) {
        for (dblSpace = regionData->DblSpace; dblSpace; dblSpace = dblSpace->Next) {
            if (dblSpace->DriveLetter == DriveLetter) {

                // This is the one to delete

                if (prevDblSpace) {
                    prevDblSpace->Next = dblSpace->Next;
                } else {
                    regionData->DblSpace = dblSpace->Next;
                }
                free(dblSpace);
                break;
            }
            prevDblSpace = dblSpace;
        }
    }
}


INT
CreateDblSpaceDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LONG lParam
    )

/*++

Routine Description:

    This routine manages the dialog for the creation of a new double
    space volume.

Arguments:

    hDlg - the dialog box handle.
    wMsg - the message.
    wParam - the windows parameter.
    lParam - depends on message type.

Return Value:

    TRUE is returned back through windows if the create is successful
    FALSE otherwise

--*/
{
    PREGION_DESCRIPTOR      regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(regionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace;
    static FORMAT_PARAMS    formatParams;  // this is passed to other threads
                                           // it cannot be located on the stack
    static HWND             hwndCombo;
    static DWORD            sizeMB = 0,
                            maxSizeMB = 600,
                            minSizeMB = 10;
    TCHAR   outputString[50],
            driveLetterString[4], // big enough for "x:" string.
            sizeString[20],       // must be big enough for an 8.3 name
            letter;
    FILE   *dblspaceIniFile;
    DWORD   compressedSize,
            selection;
    BOOL    validNumber;
    CHAR    fileName[50];

    switch (wMsg) {
    case WM_INITDIALOG:

        // limit the size of string that may be entered for the label

        hwndCombo = GetDlgItem(hDlg, IDC_NAME);
        SendMessage(hwndCombo, EM_LIMITTEXT, 11, 0);

        // set up to watch all characters that go thru the size dialog
        // to allow only decimal numbers.

        hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_SIZE);
        OldSizeDlgProc = (WNDPROC) SetWindowLong(hwndCombo,
                                                 GWL_WNDPROC,
                                                 (LONG)&SizeDlgProc);

        // Add each available drive letter to the list of available
        // drive letters and set the default letter to the first available.

        hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
        driveLetterString[1] = TEXT(':');
        driveLetterString[2] = 0;
        for (letter='C'; letter <= 'Z'; letter++) {
            if (DriveLetterIsAvailable((CHAR)letter)) {
                *driveLetterString = letter;
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)driveLetterString);
            }
        }
        SendMessage(hwndCombo,CB_SETCURSEL,0,0);

        // Setup the min/max values and the size box.

        wsprintf(outputString, TEXT("%u"), 0);
        SetDlgItemText(hDlg, IDC_DBLSPACE_SIZE, outputString);
        wsprintf(outputString, TEXT("%u"), minSizeMB);
        SetDlgItemText(hDlg, IDC_MINMAX_MIN, outputString);
        wsprintf(outputString, TEXT("%u"), maxSizeMB);
        SetDlgItemText(hDlg, IDC_MINMAX_MAX, outputString);
        CenterDialog(hDlg);
        return TRUE;

    case WM_VSCROLL:
    {
        switch (LOWORD(wParam)) {
        case SB_LINEDOWN:
        case SB_LINEUP:

            // user is pressing one of the scroll buttons.

            sizeMB = GetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, &validNumber, FALSE);
            if (sizeMB < minSizeMB) {
                sizeMB = minSizeMB + 1;
            }

            if (sizeMB > maxSizeMB) {
                sizeMB = maxSizeMB - 1;
            }

            if (((sizeMB > minSizeMB) && (LOWORD(wParam) == SB_LINEDOWN))
             || ((sizeMB < maxSizeMB) && (LOWORD(wParam) == SB_LINEUP  ))) {
                if (sizeMB > maxSizeMB) {
                    sizeMB = maxSizeMB;
                } else if (LOWORD(wParam) == SB_LINEUP) {
                    sizeMB++;
                } else {
                    sizeMB--;
                }
                SetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, sizeMB, FALSE);
                SendDlgItemMessage(hDlg, IDC_DBLSPACE_SIZE, EM_SETSEL, 0, -1);
#if 0
                compressedSize = sizeMB * 2;
                wsprintf(outputString, TEXT("%u"), compressedSize);
                SetDlgItemText(hDlg, IDC_DBLSPACE_COMPRESSED, outputString);
#endif
            } else {
                Beep(500,100);
            }
        }
        break;
    }

    case WM_COMMAND:
        switch (wParam) {
        case FD_IDHELP:
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            // can only do this if the fmifs dll supports double space.

            if (!DoubleSpaceSupported) {

                // could not load the dll

                ErrorDialog(MSG_CANT_LOAD_FMIFS);
                EndDialog(hDlg, FALSE);
                break;
            }

            // Get the current size for this volume.

            sizeMB = GetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, &validNumber, FALSE);
            if (!validNumber || !sizeMB || (sizeMB > maxSizeMB) || (sizeMB < minSizeMB)) {
                ErrorDialog(MSG_INVALID_SIZE);
                EndDialog(hDlg, FALSE);
                break;
            }

            // Get the currently selected item in the listbox for drive letter

            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo, CB_GETLBTEXT, selection, (LONG)driveLetterString);

            formatParams.RegionDescriptor = regionDescriptor;
            formatParams.RegionData       = regionData;
            formatParams.FileSystem       = NULL;
            formatParams.DblspaceFileName = NULL;
            formatParams.QuickFormat      = formatParams.Cancel = FALSE;
            formatParams.DoubleSpace      = TRUE;
            formatParams.TotalSpace       = 0;
            formatParams.SpaceAvailable   = sizeMB;
            formatParams.NewLetter        = driveLetterString[0];

            // get the label

            formatParams.Label = (PUCHAR) malloc(100);
            GetDlgItemText(hDlg, IDC_NAME, (LPTSTR)formatParams.Label, 100);

            DialogBoxParam(hModule,
                           MAKEINTRESOURCE(IDD_DBLSPACE_CANCEL),
                           hwndFrame,
                           (DLGPROC) CancelDlgProc,
                           (ULONG) &formatParams);
            if (formatParams.Result) {

                // the format failed.

                ErrorDialog(formatParams.Result);
                EndDialog(hDlg, FALSE);
            } else {
                ULONG index;
                TCHAR message[300],
                      msgProto[300],
                      title[200];

                // save the name

                if (formatParams.DblspaceFileName) {
                    for (index = 0;
                         message[index] = (TCHAR) formatParams.DblspaceFileName[index];
                         index++) {
                    }
                } else {
                    sprintf(message, "DIDNTWORK");
                }
                free(formatParams.DblspaceFileName);

                dblSpace = DblSpaceCreateInternalStructure(*driveLetterString,
                                                           sizeMB,
                                                           message,
                                                           FALSE);
                if (dblSpace) {
                    DblSpaceLinkNewVolume(regionDescriptor, dblSpace);
                    MarkDriveLetterUsed(dblSpace->DriveLetter);
                    dblSpace->Mounted = TRUE;
                }

                LoadString(hModule,
                           IDS_DBLSPACECOMPLETE,
                           title,
                           sizeof(title)/sizeof(TCHAR));
                LoadString(hModule,
                           IDS_FORMATSTATS,
                           msgProto,
                           sizeof(msgProto)/sizeof(TCHAR));
                wsprintf(message,
                         msgProto,
                         formatParams.TotalSpace,
                         formatParams.SpaceAvailable);
                MessageBox(GetActiveWindow(),
                           message,
                           title,
                           MB_ICONINFORMATION | MB_OK);

                EndDialog(hDlg, TRUE);
            }

            break;

        default:

            if (HIWORD(wParam) == EN_CHANGE) {

                // The size value has changed.  Update the compressed
                // size value displayed to the user.

                sizeMB = GetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, &validNumber, FALSE);
                if (!validNumber) {
                    sizeMB = 0;
                }

            }
            break;
        }
        break;

    case WM_DESTROY:

        // restore original subclass to window.

        hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_SIZE);
        SetWindowLong(hwndCombo, GWL_WNDPROC, (LONG) OldSizeDlgProc);
        break;

    case WM_PAINT:

        // This may be dead code that really isn't needed.

        sizeMB = GetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, &validNumber, FALSE);
        if (!validNumber || !sizeMB || (sizeMB > maxSizeMB) || (sizeMB < minSizeMB)) {
            return FALSE;
        }

        SetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, sizeMB, FALSE);
        SendDlgItemMessage(hDlg, IDC_DBLSPACE_SIZE, EM_SETSEL, 0, -1);
        break;
    }
    return FALSE;
}

VOID
DblSpaceDelete(
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )

/*++

Routine Description:

    Start the dialog box for the deletion of a double space volume.

Arguments:

    Param - not currently used.

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR      regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(regionDescriptor);

    if (ConfirmationDialog(MSG_CONFIRM_DBLSPACE_DELETE, MB_ICONQUESTION | MB_YESNOCANCEL) == IDYES) {

        // Delete the drive from view

        DblSpaceRemoveVolume(regionDescriptor, DblSpace->DriveLetter);
        DblSpaceUpdateIniFile(regionDescriptor);
        DrawDiskBar(SingleSel);
        ForceLBRedraw();
    }
}

BOOLEAN
DblSpaceCreate(
    IN HWND  Dialog,
    IN PVOID Param
    )

/*++

Routine Description:

    Start the dialog box for the creation of a double space volume.

Arguments:

    Param - not currently used.

Return Value:

    None

--*/

{
    BOOLEAN result = 0;

    result = DialogBoxParam(hModule,
                            MAKEINTRESOURCE(IDD_DBLSPACE_CREATE),
                            Dialog,
                            (DLGPROC) CreateDblSpaceDlgProc,
                            (ULONG) NULL);
    if (result) {
        DrawDiskBar(SingleSel);
        ForceLBRedraw();
    }
    return result;
}

INT
DblSpaceMountDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN DWORD wParam,
    IN LONG lParam
    )

/*++

Routine Description:

    Handle the dialog for double space.

Arguments:

    Standard Windows dialog procedure.

Return Value:

    TRUE if something was deleted.
    FALSE otherwise.

--*/

{
    static PDBLSPACE_DESCRIPTOR dblSpace;
    HWND                        hwndCombo;
    DWORD                       selection;
    CHAR                        driveLetter;
    TCHAR                       driveLetterString[20];

    switch (wMsg) {
    case WM_INITDIALOG:

        dblSpace = (PDBLSPACE_DESCRIPTOR) lParam;

        // Update the drive letter selections.

        hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);

        // Add all other available letters.  Keep track of current
        // letters offset to set the cursor correctly

        driveLetterString[1] = TEXT(':');
        driveLetterString[2] = 0;
        for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
            if (DriveLetterIsAvailable((CHAR)driveLetter) ||
                (driveLetter == dblSpace->DriveLetter)) {

                *driveLetterString = driveLetter;
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)driveLetterString);
            }
        }

        // set the current selection to the appropriate index

        SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);
        return TRUE;

    case WM_COMMAND:
        switch (wParam) {

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_DOUBLESPACE_MOUNT);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            // User has selected the drive letter and wants the mount to occur.

            hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)driveLetterString);
            dblSpace->NewDriveLetter = (UCHAR) driveLetterString[0];
            EndDialog(hDlg, TRUE);
            break;
        }
    }

    return FALSE;
}

VOID
DblSpaceSetDialogState(
    IN HWND                 hDlg,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )

/*++

Routine Description:

    Given a double space volume this routine will update the buttons
    in the dialog box to reflect they meaning.

Arguments:

    hDlg - dialog handle
    DblSpace - The double space volume selection for determining dialog state.

Return Value

    None

--*/

{
    TCHAR outputString[200];

    if (DblSpace->Mounted) {

        LoadString(hModule,
                   IDS_DBLSPACE_MOUNTED,
                   outputString,
                   sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hDlg, IDC_MOUNT_STATE, outputString);
        LoadString(hModule,
                   IDS_DISMOUNT,
                   outputString,
                   sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hDlg, ID_MOUNT_OR_DISMOUNT, outputString);

        outputString[1] = TEXT(':');
        outputString[2] = 0;
        outputString[0] = DblSpace->DriveLetter;
        SetDlgItemText(hDlg, IDC_DBLSPACE_LETTER, outputString);
    } else {
        LoadString(hModule,
                   IDS_DBLSPACE_DISMOUNTED,
                   outputString,
                   sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hDlg, IDC_MOUNT_STATE, outputString);
        LoadString(hModule,
                   IDS_MOUNT,
                   outputString,
                   sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hDlg, ID_MOUNT_OR_DISMOUNT, outputString);

        outputString[1] = TEXT(' ');
        outputString[2] = 0;
        outputString[0] = TEXT(' ');
        SetDlgItemText(hDlg, IDC_DBLSPACE_LETTER, outputString);
    }
}

INT
DblSpaceDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN DWORD wParam,
    IN LONG lParam
    )

/*++

Routine Description:

    Handle the dialog for double space.

Arguments:

Return Value:

    TRUE if something was deleted.
    FALSE otherwise.

--*/

{
    static HWND hwndCombo,
                mountButtonHwnd,
                deleteButtonHwnd;
    static PREGION_DESCRIPTOR      regionDescriptor;
    static PPERSISTENT_REGION_DATA regionData;
    static PDBLSPACE_DESCRIPTOR    firstDblSpace;
    CHAR                           driveLetter;
    PDBLSPACE_DESCRIPTOR           dblSpace;
    TCHAR                          outputString[200];
    DWORD                          selection;
    BOOLEAN                        result;
    ULONG                          errorMessage;
    DRAWITEMSTRUCT                 drawItem;

    switch (wMsg) {
    case WM_INITDIALOG:

        regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
        regionData = PERSISTENT_DATA(regionDescriptor);

        hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_VOLUME);
        mountButtonHwnd = GetDlgItem(hDlg, ID_MOUNT_OR_DISMOUNT);
        deleteButtonHwnd = GetDlgItem(hDlg, IDDELETE);

        // place all double space file names in the selection
        // box and remember the first name.

        firstDblSpace = dblSpace = DblSpaceGetNextVolume(regionDescriptor, NULL);
        for (; dblSpace;
               dblSpace = DblSpaceGetNextVolume(regionDescriptor, dblSpace)) {
            wsprintf(outputString, TEXT("%s"), dblSpace->FileName);
            SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)outputString);
        }
        SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);

        // add the drive letter

        if (firstDblSpace) {

            // update the allocated size.

            wsprintf(outputString, TEXT("%u"), firstDblSpace->AllocatedSize);
            SetDlgItemText(hDlg, IDC_DBLSPACE_ALLOCATED, outputString);

            // update mount state

            DblSpaceSetDialogState(hDlg, firstDblSpace);
            EnableWindow(mountButtonHwnd, TRUE);
            EnableWindow(deleteButtonHwnd, TRUE);
        } else {

            // update the Mount/Dismount button to say mount and grey it

            LoadString(hModule,
                       IDS_MOUNT,
                       outputString,
                       sizeof(outputString)/sizeof(TCHAR));
            SetDlgItemText(hDlg, ID_MOUNT_OR_DISMOUNT, outputString);
            EnableWindow(mountButtonHwnd, FALSE);
            EnableWindow(deleteButtonHwnd, FALSE);
        }
        return TRUE;

    case WM_COMMAND:
        switch (wParam) {

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_DOUBLESPACE);
            break;

        case IDCANCEL:

            // Run the dblspace change and forget about any changes.

            for (dblSpace = firstDblSpace;
                 dblSpace;
                 dblSpace = DblSpaceGetNextVolume(regionDescriptor, dblSpace)) {
                 dblSpace->ChangeMountState = FALSE;
                 dblSpace->NewDriveLetter = 0;
            }
            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            EndDialog(hDlg, TRUE);
            break;

        case IDADD:

            DblSpaceCreate(hDlg, NULL);
            break;

        case IDDELETE:

            hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_VOLUME);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)outputString);

            // relate the name to a double space volume

            dblSpace = DblSpaceFindVolume(regionDescriptor, (PCHAR)outputString);
            if (!dblSpace) {
                break;
            }

            DblSpaceDelete(dblSpace);
            break;

        case ID_MOUNT_OR_DISMOUNT:

            // The state of something in the dialog changed.
            // Determine which double space volume is involved.

            hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_VOLUME);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)outputString);

            // relate the name to a double space volume

            dblSpace = DblSpaceFindVolume(regionDescriptor, (PCHAR)outputString);
            if (!dblSpace) {
                break;
            }

            if (dblSpace->Mounted) {

                // dismount the volume

                errorMessage = DblSpaceDismountDrive(regionDescriptor,
                                                     dblSpace);

                if (errorMessage) {
                    ErrorDialog(errorMessage);
                } else {

                    // Update the dialog

                    DblSpaceSetDialogState(hDlg, dblSpace);
                    DblSpaceUpdateIniFile(regionDescriptor);
                }

            } else {

                // mount the volume unless the user cancels out

                result = DialogBoxParam(hModule,
                                        MAKEINTRESOURCE(IDD_DBLSPACE_DRIVELET),
                                        hwndFrame,
                                        (DLGPROC) DblSpaceMountDlgProc,
                                        (ULONG) dblSpace);
                if (result) {

                    errorMessage = DblSpaceMountDrive(regionDescriptor, dblSpace);

                    if (errorMessage) {
                        ErrorDialog(errorMessage);
                    } else {

                        // Update the dialog

                        DblSpaceSetDialogState(hDlg, dblSpace);
                        DblSpaceUpdateIniFile(regionDescriptor);
                    }
                }
            }
            DrawDiskBar(SingleSel);
            ForceLBRedraw();
            break;

        default:

            // The state of something in the dialog changed.
            // Determine which double space volume is involved.

            hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_VOLUME);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)outputString);

            // relate the name to a double space volume

            dblSpace = DblSpaceFindVolume(regionDescriptor, (PCHAR)outputString);
            if (!dblSpace) {

                // update the Mount/Dismount button to say mount and grey it

                LoadString(hModule,
                           IDS_MOUNT,
                           outputString,
                           sizeof(outputString)/sizeof(TCHAR));
                SetDlgItemText(hDlg, ID_MOUNT_OR_DISMOUNT, outputString);
                EnableWindow(mountButtonHwnd, FALSE);
                EnableWindow(deleteButtonHwnd, FALSE);
                break;
            } else {
                EnableWindow(mountButtonHwnd, TRUE);
                EnableWindow(deleteButtonHwnd, TRUE);
            }
            if (HIWORD(wParam) == LBN_SELCHANGE) {

                // update the allocated/compressed size items

                wsprintf(outputString, TEXT("%u"), dblSpace->AllocatedSize);
                SetDlgItemText(hDlg, IDC_DBLSPACE_ALLOCATED, outputString);
#if 0
                wsprintf(outputString, TEXT("%u"), dblSpace->AllocatedSize * 2);
                SetDlgItemText(hDlg, IDC_DBLSPACE_COMPRESSED, outputString);
                wsprintf(outputString, TEXT("%u.%u"), 2, 0);
                SetDlgItemText(hDlg, IDC_DBLSPACE_RATIO, outputString);
#endif

                // update mount state

                DblSpaceSetDialogState(hDlg, dblSpace);
            }

            break;
        }
        break;
    }
    return FALSE;
}

VOID
DblSpace(
    IN HWND  Dialog,
    IN PVOID Param
    )

/*++

Routine Description:

    Start the dialog box for double space.

Arguments:

    Param - not currently used.

Return Value:

    None

--*/

{
    BOOLEAN result;

    if (IsFullDoubleSpace) {
        result = DialogBoxParam(hModule,
                                MAKEINTRESOURCE(IDD_DBLSPACE_FULL),
                                Dialog,
                                (DLGPROC) DblSpaceDlgProc,
                                (ULONG) NULL);

    } else {
        result = DialogBoxParam(hModule,
                                MAKEINTRESOURCE(IDD_DBLSPACE),
                                Dialog,
                                (DLGPROC) DblSpaceDlgProc,
                                (ULONG) NULL);
    }
    if (result) {
        DrawDiskBar(SingleSel);
        ForceLBRedraw();
    }
}
#else

// STUBS for easy removal of DoubleSpace support.

BOOL
DblSpaceVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )
{
    return FALSE;
}

BOOL
DblSpaceDismountedVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )
{
    return FALSE;
}

BOOLEAN
DblSpaceCreate(
    IN HWND  Dialog,
    IN PVOID Param
    )
{
    return FALSE;
}

VOID
DblSpaceDelete(
    IN PVOID Param
    )
{
}

VOID
DblSpaceMount(
    IN PVOID Param
    )
{
}

VOID
DblSpaceDismount(
    IN PVOID Param
    )
{
}

VOID
DblSpaceInitialize(
    VOID
    )
{
}

VOID
DblSpace(
    IN HWND  Dialog,
    IN PVOID Param
    )
{
}

PDBLSPACE_DESCRIPTOR
DblSpaceGetNextVolume(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )
{
    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\cdrom.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    cdrom.c

Abstract:

    This module contains the set of routines that display and control the
    drive letters for CdRom devices.

Author:

    Bob Rinne (bobri)  12/9/93

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "shellapi.h"
#include <string.h>
#include <stdio.h>
#include <wchar.h>
#include <malloc.h>

PCDROM_DESCRIPTOR CdRomChainBase = NULL;
PCDROM_DESCRIPTOR CdRomChainLast = NULL;
PCDROM_DESCRIPTOR CdRomChanged = NULL;

static BOOLEAN CdRomFirstCall = TRUE;
static TCHAR   SourcePathLetter = (TCHAR) '\0';
static TCHAR   SourcePathKeyName[80];
static TCHAR   SourcePathValueName[30];

VOID
CdRomAddDevice(
    IN PWSTR NtName,
    IN WCHAR DriveLetter
    )

/*++

Routine Description:

    Build a cdrom description structure for this and fill it in.

Arguments:

    NtName - The unicode name for the device.
    DriveLetter - The DosDevice name.

Return Value:

    None

--*/

{
    PCDROM_DESCRIPTOR cdrom;
    PWCHAR            cp;
    LONG              error;
    HKEY              keyHandle;
    DWORD             valueType;
    ULONG             size;
    TCHAR            *string;

    if (CdRomFirstCall) {
        CdRomFirstCall = FALSE;

        // Get the registry path and value name.

        LoadString(hModule,
                   IDS_SOURCE_PATH,
                   SourcePathKeyName,
                   sizeof(SourcePathKeyName)/sizeof(TCHAR));
        LoadString(hModule,
                   IDS_SOURCE_PATH_NAME,
                   SourcePathValueName,
                   sizeof(SourcePathValueName)/sizeof(TCHAR));

        error = RegOpenKey(HKEY_LOCAL_MACHINE,
                             SourcePathKeyName,
                             &keyHandle);
        if (error == NO_ERROR) {
            error = RegQueryValueEx(keyHandle,
                                    SourcePathValueName,
                                    NULL,
                                    &valueType,
                                    (PUCHAR)NULL,
                                    &size);

            if (error == NO_ERROR) {
                string = (PUCHAR) LocalAlloc(LMEM_FIXED, size);
                if (string) {
                    error = RegQueryValueEx(keyHandle,
                                            SourcePathValueName,
                                            NULL,
                                            &valueType,
                                            string,
                                            &size);
                    if (error == NO_ERROR) {
                        SourcePathLetter = *string;
                    }
                }
                LocalFree(string);
            }
            RegCloseKey(keyHandle);
        }
    }

    cdrom = (PCDROM_DESCRIPTOR) malloc(sizeof(CDROM_DESCRIPTOR));
    if (cdrom) {
        cdrom->DeviceName = (PWSTR) malloc((wcslen(NtName)+1)*sizeof(WCHAR));
        if (cdrom->DeviceName) {
            wcscpy(cdrom->DeviceName, NtName);
            cp = cdrom->DeviceName;
            while (*cp) {
                if (iswdigit(*cp)) {
                    break;
                }
                cp++;
            }

            if (*cp) {
                cdrom->DeviceNumber = wcstoul(cp, (WCHAR) 0, 10);
            }
            cdrom->DriveLetter = DriveLetter;
            cdrom->Next = NULL;
            cdrom->NewDriveLetter = (WCHAR) 0;
            if (CdRomChainBase) {
                CdRomChainLast->Next = cdrom;
            } else {
                AllowCdRom = TRUE;
                CdRomChainBase = cdrom;
            }
            CdRomChainLast = cdrom;
        } else {
            free(cdrom);
        }
    }
}


INT
CdRomDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN DWORD wParam,
    IN LONG lParam
    )

/*++

Routine Description:

    Handle the dialog for CD-ROMS

Arguments:

    Standard Windows dialog procedure

Return Value:

    TRUE if something was deleted.
    FALSE otherwise.

--*/

{
    HWND   hwndCombo;
    DWORD  selection;
    DWORD  index;
    CHAR   driveLetter;
    TCHAR  string[40];
    PCDROM_DESCRIPTOR cdrom;
    static PCDROM_DESCRIPTOR currentCdrom;
    static CHAR              currentSelectionLetter;

    switch (wMsg) {
    case WM_INITDIALOG:

        // Store all device strings into the selection area.

        hwndCombo = GetDlgItem(hDlg, IDC_CDROM_NAMES);
        cdrom = currentCdrom = CdRomChainBase;
        currentSelectionLetter = (CHAR) cdrom->DriveLetter;
        while (cdrom) {
            sprintf(string, "CdRom%d", cdrom->DeviceNumber);
            SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)string);
            cdrom = cdrom->Next;
        }
        SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);

        // Update the drive letter selections.

        selection = index = 0;
        hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
        string[1] = TEXT(':');
        string[2] = 0;
        for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
            if ((DriveLetterIsAvailable((CHAR)driveLetter)) ||
                (driveLetter == currentSelectionLetter)) {
                *string = driveLetter;
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)string);
                if (driveLetter == currentSelectionLetter) {
                    selection = index;
                }
                index++;
            }
        }

        // set the current selection to the appropriate index

        SendMessage(hwndCombo, CB_SETCURSEL, selection, 0);
        return TRUE;

    case WM_COMMAND:
        switch (wParam) {

        case FD_IDHELP:
            DialogHelp(HC_DM_DLG_CDROM);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            // User has selected the drive letter and wants the mount to occur.

            hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)string);
            currentCdrom->NewDriveLetter = (WCHAR) string[0];
            CdRomChanged = currentCdrom;
            EndDialog(hDlg, TRUE);
            break;

        default:

            if (HIWORD(wParam) == LBN_SELCHANGE) {
                TCHAR *cp;

                if (LOWORD(wParam) != IDC_CDROM_NAMES) {
                    break;
                }

                // The state of something in the dialog changed.

                hwndCombo = GetDlgItem(hDlg, IDC_CDROM_NAMES);
                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                SendMessage(hwndCombo,
                            CB_GETLBTEXT,
                            selection,
                            (LONG)string);

                // The format of the string returned is "cdrom#".  Parse the
                // value of # in order to find the selection.

                cp = string;
                while (*cp) {
                    cp++;
                }
                cp--;
                while ((*cp >= (TCHAR) '0') && (*cp <= (TCHAR) '9')) {
                    cp--;
                }
                cp++;

                selection = 0;
                while (*cp) {
                    selection = (selection * 10) + (*cp - (TCHAR) '0');
                    cp++;
                }

                // Find the matching device name.

                for (cdrom = CdRomChainBase; cdrom; cdrom = cdrom->Next) {

                    if (selection == cdrom->DeviceNumber) {

                        // found the match

                        currentSelectionLetter = (CHAR) cdrom->DriveLetter;
                        currentCdrom = cdrom;
                        break;
                    }
                }

                // The only thing that is important is to track the cdrom
                // device name selected and update the drive letter list.

                selection = index = 0;
                hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
                SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);
                string[1] = TEXT(':');
                string[2] = 0;
                for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
                    if ((DriveLetterIsAvailable((CHAR)driveLetter)) ||
                        (driveLetter == currentSelectionLetter)) {
                        *string = driveLetter;
                        SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)string);
                        if (driveLetter == currentSelectionLetter) {
                            selection = index;
                        }
                        index++;
                    }
                }

                // set the current selection to the appropriate index

                SendMessage(hwndCombo, CB_SETCURSEL, selection, 0);
            }
            break;
        }
    }

    return FALSE;
}


VOID
CdRom(
    IN HWND  Dialog,
    IN PVOID Param
    )

/*++

Routine Description:

    Start the CdRom dialogs.

Arguments:

    None

Return Value:

    None

--*/

{
    BOOLEAN result = 0;
    DWORD   action,
            ec;
    TCHAR   name[40];
    TCHAR   letter[10];
    PWSTR   linkTarget;
    OBJECT_ATTRIBUTES oa;
    WCHAR             dosName[20];
    HANDLE            handle;
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;
    ANSI_STRING       ansiName;
    UNICODE_STRING    unicodeName;
    UINT              errorMode;

    result = DialogBoxParam(hModule,
                            MAKEINTRESOURCE(IDD_CDROM),
                            Dialog,
                            (DLGPROC) CdRomDlgProc,
                            (ULONG) NULL);
    if (result) {

        action = ConfirmationDialog(MSG_DRIVE_RENAME_WARNING, MB_ICONQUESTION | MB_YESNOCANCEL);

        if (!action) {
            return;
        }

        // Attempt to open and lock the cdrom.

        sprintf(name, "\\Device\\CdRom%d", CdRomChanged->DeviceNumber);

        RtlInitAnsiString(&ansiName, name);
        status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, TRUE);

        if (!NT_SUCCESS(status)) {
            ErrorDialog(MSG_CDROM_LETTER_ERROR);
            return;
        }

        memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
        oa.Length = sizeof(OBJECT_ATTRIBUTES);
        oa.ObjectName = &unicodeName;
        oa.Attributes = OBJ_CASE_INSENSITIVE;

        errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        status = NtOpenFile(&handle,
                            SYNCHRONIZE | FILE_READ_DATA,
                            &oa,
                            &statusBlock,
                            FILE_SHARE_READ,
                            FILE_SYNCHRONOUS_IO_ALERT);
        RtlFreeUnicodeString(&unicodeName);
        SetErrorMode(errorMode);

        if (!NT_SUCCESS(status)) {
            ErrorDialog(MSG_CANNOT_LOCK_CDROM);
            return;
        }

        // Lock the drive to insure that no other access is occurring
        // to the volume.  This is done via the "Low" routine for
        // convenience

        status = LowLockDrive(handle);

        if (!NT_SUCCESS(status)) {
            LowCloseDisk(handle);
            ErrorDialog(MSG_CANNOT_LOCK_CDROM);
            return;
        }

        // Before attempting to move the name, see if the letter
        // is currently in use - could be a new network connection
        // or a partition that is scheduled for deletion.

        wsprintfW(dosName, L"\\DosDevices\\%wc:", (WCHAR) CdRomChanged->NewDriveLetter);
        ec = GetDriveLetterLinkTarget(dosName, &linkTarget);
        if (ec == NO_ERROR) {

            // Something is using this letter.

            LowCloseDisk(handle);
            ErrorDialog(MSG_CANNOT_MOVE_CDROM);
            return;
        }

        // remove existing definition - if this fails don't continue.

        sprintf(letter, "%c:", (UCHAR) CdRomChanged->DriveLetter);
        if (!DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) letter, (LPCTSTR) NULL)) {
            LowCloseDisk(handle);
            ErrorDialog(MSG_CDROM_LETTER_ERROR);
            return;
        }
        status = DiskRegistryAssignCdRomLetter(CdRomChanged->DeviceName,
                                               CdRomChanged->NewDriveLetter);
        MarkDriveLetterFree((UCHAR)CdRomChanged->DriveLetter);

        // See if this was the device used to install NT

        if (SourcePathLetter) {
            if (SourcePathLetter == CdRomChanged->DriveLetter) {
                LONG   error;
                HKEY   keyHandle;
                DWORD  valueType;
                ULONG  size;
                TCHAR *string;


                // Update the source path

                error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     SourcePathKeyName,
                                     0,
                                     KEY_ALL_ACCESS,
                                     &keyHandle);
                if (error == NO_ERROR) {
                    error = RegQueryValueEx(keyHandle,
                                            SourcePathValueName,
                                            NULL,
                                            &valueType,
                                            (PUCHAR)NULL,
                                            &size);

                    if (error == NO_ERROR) {
                        string = (PUCHAR) LocalAlloc(LMEM_FIXED, size);
                        if (string) {
                            error = RegQueryValueEx(keyHandle,
                                                    SourcePathValueName,
                                                    NULL,
                                                    &valueType,
                                                    string,
                                                    &size);
                            if (error == NO_ERROR) {
                                *string = SourcePathLetter = (UCHAR) CdRomChanged->NewDriveLetter;
                                RegSetValueEx(keyHandle,
                                              SourcePathValueName,
                                              0,
                                              REG_SZ,
                                              string,
                                              size);
                            }
                        }
                        LocalFree(string);
                    }
                    RegCloseKey(keyHandle);
                }
            }
        }

        // set up new device letter - name is already set up

        sprintf(letter, "%c:", (UCHAR) CdRomChanged->NewDriveLetter);
        if (DefineDosDevice(DDD_RAW_TARGET_PATH, (LPCTSTR) letter, (LPCTSTR) name)) {
            CdRomChanged->DriveLetter = CdRomChanged->NewDriveLetter;
            MarkDriveLetterUsed((UCHAR)CdRomChanged->DriveLetter);
        } else {
            RegistryChanged = TRUE;
        }
        LowCloseDisk(handle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdconst.h ===
#define SYSID_FT    0x80



#define LEGEND_STRING_COUNT 5

#define STATUS_TEXT_SIZE 250

#define NUM_AVAILABLE_COLORS        16
#define NUM_AVAILABLE_HATCHES       5


// brushes for drawing rectangles

#define     BRUSH_USEDPRIMARY       0
#define     BRUSH_USEDLOGICAL       1
#define     BRUSH_STRIPESET         2
#define     BRUSH_MIRROR            3
#define     BRUSH_VOLUMESET         4
#define     BRUSH_ARRAY_SIZE        LEGEND_STRING_COUNT

// see AvailableHatches[] in fddata.c
#define     DEFAULT_HATCH_USEDPRIMARY   4
#define     DEFAULT_HATCH_USEDLOGICAL   4
#define     DEFAULT_HATCH_STRIPESET     4
#define     DEFAULT_HATCH_MIRROR        4
#define     DEFAULT_HATCH_VOLUMESET     4

// see AvailableColors[] in fddata.c
#define     DEFAULT_COLOR_USEDPRIMARY   9
#define     DEFAULT_COLOR_USEDLOGICAL   15
#define     DEFAULT_COLOR_STRIPESET     14
#define     DEFAULT_COLOR_MIRROR        5
#define     DEFAULT_COLOR_VOLUMESET     10


#define     MESSAGE_BUFFER_SIZE 4096

#define     ID_LISTBOX      0xcac


// thickness of the border indicating selection of a region

#define SELECTION_THICKNESS 2


//
// define constants for use with drive letter assignments.
// use arbitrary symbols that won't ever be drive letters themselves.

#define     NO_DRIVE_LETTER_YET         '#'
#define     NO_DRIVE_LETTER_EVER        '%'




// notification codes

#define RN_CLICKED                  213

// window messages

#define RM_SELECT                   WM_USER

// window extra

#define RECTCONTROL_WNDEXTRA        2
#define GWW_SELECTED                0


// custom windows message for F1 key

#define WM_F1DOWN           (WM_USER + 0x17a)



#define     MBOOT_CODE_SIZE     0x1b8
#define     MBOOT_SIG_OFFSET    0x1fe
#define     MBOOT_SIG1          0x55
#define     MBOOT_SIG2          0xaa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fddata.c ===
#include "fdisk.h"


HANDLE  hModule;

// IsDiskRemovable is an array of BOOLEANs each of which indicates
// whether the corresponding physical disk is removable.

PBOOLEAN IsDiskRemovable = NULL;

// RemovableDiskReservedDriveLetters is an array of CHARs which
// shows the reserved drive letter for each disk if that disk is
// removable.

PCHAR        RemovableDiskReservedDriveLetters;

// This will be an array of pointers to DISKSTATE structures, indexed
// by disk number.

PDISKSTATE *Disks;

// BootDiskNumber is the number of the disk on which the boot partition
// (ie. the disk with the WinNt files) resides.  BootPartitionNumber is
// the original partition number of this partition.

ULONG   BootDiskNumber;
ULONG   BootPartitionNumber;


// window handles

HANDLE  hwndFrame,
        hwndList;

// GDI objects

HBITMAP  hBitmapSmallDisk;
HBITMAP  hBitmapRemovableDisk;
HDC      hDC;
HFONT    hFontGraph,
         hFontGraphBold;
HBRUSH   Brushes[BRUSH_ARRAY_SIZE];
HBRUSH   hBrushFreeLogical,
         hBrushFreePrimary;
HPEN     hPenNull,
         hPenThinSolid;
HCURSOR  hcurWait,
         hcurNormal;


// initial stuff for the disk graphs, used when there is
// no info in win.ini.

int      BrushHatches[BRUSH_ARRAY_SIZE] = { DEFAULT_HATCH_USEDPRIMARY,
                                            DEFAULT_HATCH_USEDLOGICAL,
                                            DEFAULT_HATCH_STRIPESET,
                                            DEFAULT_HATCH_MIRROR,
                                            DEFAULT_HATCH_VOLUMESET
                                          };

int      BrushColors[BRUSH_ARRAY_SIZE] = { DEFAULT_COLOR_USEDPRIMARY,
                                           DEFAULT_COLOR_USEDLOGICAL,
                                           DEFAULT_COLOR_STRIPESET,
                                           DEFAULT_COLOR_MIRROR,
                                           DEFAULT_COLOR_VOLUMESET
                                         };

// colors and patterns available for the disk graphs

COLORREF AvailableColors[NUM_AVAILABLE_COLORS] = { RGB(0,0,0),       // black
                                                   RGB(128,128,128), // dark gray
                                                   RGB(192,192,192), // light gray
                                                   RGB(255,255,255), // white
                                                   RGB(128,128,0),   // dark yellow
                                                   RGB(128,0,128),   // violet
                                                   RGB(128,0,0),     // dark red
                                                   RGB(0,128,128),   // dark cyan
                                                   RGB(0,128,0),     // dark green
                                                   RGB(0,0,128),     // dark blue
                                                   RGB(255,255,0),   // yellow
                                                   RGB(255,0,255),   // light violet
                                                   RGB(255,0,0),     // red
                                                   RGB(0,255,255),   // cyan
                                                   RGB(0,255,0),     // green
                                                   RGB(0,0,255)      // blue
                                                 };

int      AvailableHatches[NUM_AVAILABLE_HATCHES] = { 2,3,4,5,6 };


// positions for various items in a disk graph

DWORD GraphWidth,
      GraphHeight;
DWORD BarTopYOffset,
      BarBottomYOffset,
      BarHeight;
DWORD dxDriveLetterStatusArea;
DWORD dxBarTextMargin,
      dyBarTextLine;
DWORD dxSmallDisk,
      dySmallDisk,
      xSmallDisk,
      ySmallDisk;
DWORD dxRemovableDisk,
      dyRemovableDisk,
      xRemovableDisk,
      yRemovableDisk;
DWORD BarLeftX,
      BarWidth;


// if a single disk region is selected, these vars describe the selection.

PDISKSTATE SingleSel;
DWORD      SingleSelIndex;

// name of help file

PTCHAR HelpFile;
TCHAR  WinHelpFile[] = TEXT("windisk.hlp");
TCHAR  LanmanHelpFile[] = TEXT("windiska.hlp");


// number of hard disks attached to the system

unsigned DiskCount = 0;

// class name for frame window

TCHAR   szFrame[] = TEXT("fdFrame");

// "Disk %u"

LPTSTR  DiskN;

PWSTR wszUnformatted,
      wszNewUnformatted,
      wszUnknown;

// If the following is TRUE, the registry needs to be updated and the user will
// be prompted to save changed just as if he had made changes to any partitions.

BOOL RegistryChanged = FALSE;

// Restart required to make changes work.

BOOL RestartRequired = FALSE;


// If the following is TRUE, the main window will pass WM_ENTERIDLE
// messages on to the child dialog box; this will trigger the
// configuration search.

BOOL ConfigurationSearchIdleTrigger = FALSE;

// This flag indicates whether this is a Server
// or just regular Windows NT Workstation.

BOOL IsLanmanNt = FALSE;

// This flag indicates whether double space volume creation
// and deletion is allowed.

BOOL IsFullDoubleSpace = FALSE;

// Cdrom is present in the system.

ULONG AllowCdRom = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdft.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdhelpid.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fdhelpid.h

Abstract:

    Context ids for context-sensitive help for the disk manager

Author:

    Ted Miller (tedm) 18-March-1992

Revision History:

--*/


//
// All ids in this file start with HC_DM, as in "Help Context for Disk Manager"
//

//
// Menu items.  In the form HC_DM_MENU_xxx, where xxx matches the name used
// in the resource file (fdisk.rc) for the menu item (of the form IDM_xxx).
//

//
// The partition menu
//

#define         HC_DM_MENU_PARTITIONCREATE          110
#define         HC_DM_MENU_PARTITIONCREATEEX        111
#define         HC_DM_MENU_PARTITIONDELETE          112
#define         HC_DM_MENU_FTCREATEVOLUMESET        113
#define         HC_DM_MENU_FTEXTENDVOLUMESET        114
#define         HC_DM_MENU_FTCREATESTRIPE           115
#if i386
#define         HC_DM_MENU_PARTITIONACTIVE          116
#endif
#define         HC_DM_MENU_PARTITIONLETTER          117 // really in tools menu
#define         HC_DM_MENU_PARTITIONEXIT            118
#define         HC_DM_MENU_SECURESYSTEM             119
#define         HC_DM_MENU_COMMIT                   120

//
// The configuration menu
//

#define         HC_DM_MENU_CONFIGMIGRATE            210
#define         HC_DM_MENU_CONFIGSAVE               211
#define         HC_DM_MENU_CONFIGRESTORE            212
#define         HC_DM_MENU_CONFIG                   213

//
// The fault tolerance menu
//

#define         HC_DM_MENU_FTESTABLISHMIRROR        310
#define         HC_DM_MENU_FTBREAKMIRROR            311
#define         HC_DM_MENU_FTCREATEPSTRIPE          312
#define         HC_DM_MENU_FTRECOVERSTRIPE          313

//
// The tools menu
//

#define         HC_DM_MENU_AUTOMOUNT                610
#define         HC_DM_MENU_DBLSPACE                 611
#define         HC_DM_MENU_CDROM                    612
#define         HC_DM_MENU_FORMAT                   613
#define         HC_DM_MENU_LABEL                    614

//
// The options menu
//

#define         HC_DM_MENU_OPTIONSSTATUS            410
#define         HC_DM_MENU_OPTIONSLEGEND            411
#define         HC_DM_MENU_OPTIONSCOLORS            412
#define         HC_DM_MENU_OPTIONSDISPLAY           413

//
// The help menu
//

#define         HC_DM_MENU_HELPCONTENTS             510
#define         HC_DM_MENU_HELPSEARCH               511
#define         HC_DM_MENU_HELPHELP                 512
#define         HC_DM_MENU_HELPABOUT                513


//
// The system menu
//

#define         HC_DM_SYSMENU_RESTORE               910
#define         HC_DM_SYSMENU_MOVE                  911
#define         HC_DM_SYSMENU_SIZE                  912
#define         HC_DM_SYSMENU_MINIMIZE              913
#define         HC_DM_SYSMENU_MAXIMIZE              914
#define         HC_DM_SYSMENU_CLOSE                 915
#define         HC_DM_SYSMENU_SWITCHTO              916

//
// Dialog boxes.  In the form HC_DM_DLG_xxx, where xxx is some reasonably
// descriptive name for the dialog.
//
//
// These dialog boxes do not have help buttons:
//
//      - About
//      - Searching for Previous Installation
//      - Confirmation dialogs

//
// Min/Max dialogs for creating various items
//

#define         HC_DM_DLG_CREATEPRIMARY             1010
#define         HC_DM_DLG_CREATEEXTENDED            1011
#define         HC_DM_DLG_CREATELOGICAL             1012
#define         HC_DM_DLG_CREATEVOLUMESET           1013
#define         HC_DM_DLG_EXTENDVOLUMESET           1014
#define         HC_DM_DLG_CREATESTRIPESET           1015
#define         HC_DM_DLG_CREATEPARITYSTRIPE        1016

//
// Dialog for assigning drive letters
//

#define         HC_DM_DLG_DRIVELETTER               1020

//
// Dialog for determining display sizing
//

#define         HC_DM_DLG_DISPLAYOPTION             1030

//
// Configuration migration dialog to select previous installation
//

#define         HC_DM_DLG_SELECTINSTALLATION        1040

//
// Colors and patterns dialog
//

#define         HC_DM_COLORSANDPATTERNS             1050

//
// DoubleSpace dialog
//

#define         HC_DM_DLG_DOUBLESPACE               1060
#define         HC_DM_DLG_DOUBLESPACE_MOUNT         1061

//
// Format dialog
//

#define         HC_DM_DLG_FORMAT                    1070

//
// Label dialog
//

#define         HC_DM_DLG_LABEL                     1080

//
// CdRom dialog
//

#define         HC_DM_DLG_CDROM                     1090
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdhelp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fdhelp.c

Abstract:

    Routines to support context-sensitive help in the disk manager.

Author:

    Ted Miller (tedm) 18-March-1992

Revision History:

--*/


#include "fdisk.h"


//
// Define macro to convert between a menu id and its corresponding
// context-sensitive help id, in a switch statement.
//

#define     MENUID_TO_HELPID(name)      case IDM_##name :                    \
                                            HelpContext = HC_DM_MENU_##name; \
                                            break;


//
// Current help context
//

DWORD   HelpContext = (DWORD)(-1);


//
// Handle to windows hook for F1 key
//
HHOOK hHook;



DWORD
HookProc(
    IN int  nCode,
    IN UINT wParam,
    IN LONG lParam
    )

/*++

Routine Description:

    Hook proc to detect F1 key presses.

Arguments:

Return Value:

--*/

{
    PMSG pmsg = (PMSG)lParam;

    if(nCode < 0) {
        return(CallNextHookEx(hHook,nCode,wParam,lParam));
    }

    if(((nCode == MSGF_DIALOGBOX) || (nCode == MSGF_MENU))
     && (pmsg->message == WM_KEYDOWN)
     && (LOWORD(pmsg->wParam) == VK_F1))
    {
        PostMessage(hwndFrame,WM_F1DOWN,nCode,0);
        return(TRUE);
    }

    return(FALSE);
}



VOID
Help(
    IN LONG Code
    )

/*++

Routine Description:

    Display context-sensitive help.

Arguments:

    Code - supplies type of message (MSGF_DIALOGBOX, MSGF_MENU, etc).

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(Code);

    if(HelpContext != -1) {
        WinHelp(hwndFrame,HelpFile,HELP_CONTEXT,HelpContext);
        DrawMenuBar(hwndFrame);
    }
}

VOID
DialogHelp(
    IN DWORD HelpId
    )
/*++

Routine Description:

    Display help on a specific item.

Arguments:

    HelpId  --  Supplies the help item to display.

Return Value:

    None.

--*/
{
    WinHelp(hwndFrame,HelpFile,HELP_CONTEXT,HelpId);
    DrawMenuBar(hwndFrame);
}

VOID
SetMenuItemHelpContext(
    IN LONG wParam,
    IN DWORD lParam
    )

/*++

Routine Description:

    Routine to set help context based on which menu item is currently
    selected.

Arguments:

    wParam,lParam - params to window proc in WM_MENUSELECT case

Return Value:

    None.

--*/

{
    if(HIWORD(lParam) == 0) {                   // menu closed

        HelpContext = (DWORD)(-1);

    } else if (HIWORD(wParam) & MF_POPUP) {     // popup selected

        HelpContext = (DWORD)(-1);

    } else {                                    // regular old menu item
        switch(LOWORD(wParam)) {

        MENUID_TO_HELPID(PARTITIONCREATE)
        MENUID_TO_HELPID(PARTITIONCREATEEX)
        MENUID_TO_HELPID(PARTITIONDELETE)
#if i386
        MENUID_TO_HELPID(PARTITIONACTIVE)
#else
        MENUID_TO_HELPID(SECURESYSTEM)
#endif
        MENUID_TO_HELPID(PARTITIONLETTER)
        MENUID_TO_HELPID(PARTITIONEXIT)

        MENUID_TO_HELPID(CONFIGMIGRATE)
        MENUID_TO_HELPID(CONFIGSAVE)
        MENUID_TO_HELPID(CONFIGRESTORE)

        MENUID_TO_HELPID(FTESTABLISHMIRROR)
        MENUID_TO_HELPID(FTBREAKMIRROR)
        MENUID_TO_HELPID(FTCREATESTRIPE)
        MENUID_TO_HELPID(FTCREATEPSTRIPE)
        MENUID_TO_HELPID(FTCREATEVOLUMESET)
        MENUID_TO_HELPID(FTEXTENDVOLUMESET)
        MENUID_TO_HELPID(FTRECOVERSTRIPE)

        MENUID_TO_HELPID(OPTIONSSTATUS)
        MENUID_TO_HELPID(OPTIONSLEGEND)
        MENUID_TO_HELPID(OPTIONSCOLORS)
        MENUID_TO_HELPID(OPTIONSDISPLAY)

        MENUID_TO_HELPID(HELPCONTENTS)
        MENUID_TO_HELPID(HELPSEARCH)
        MENUID_TO_HELPID(HELPHELP)
        MENUID_TO_HELPID(HELPABOUT)

        default:
            HelpContext = (DWORD)(-1);
        }
    }
}


VOID
InitHelp(
    VOID
    )
{
    hHook = SetWindowsHookEx(WH_MSGFILTER,(HOOKPROC)HookProc,NULL,GetCurrentThreadId());
}


VOID
TermHelp(
    VOID
    )
{
    UnhookWindowsHookEx(hHook);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fddlgs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fddlgs.c

Abstract:

    Dialog routines and dialog support subroutines.

Author:

    Ted Miller (tedm) 7-Jan-1992

--*/

#include "fdisk.h"

// used in color dialog to indicate what the user has chosen for
// the various graph element types

DWORD SelectedColor[LEGEND_STRING_COUNT];
DWORD SelectedHatch[LEGEND_STRING_COUNT];

// used in color dialog, contains element (ie, partition, logical volume,
// etc) we're selecting for (ie, which item is diaplyed in static text of
// combo box).

DWORD CurrentElement;

// handle of active color dialogs box.  Used by rectangle custom control.

HWND hDlgColor;

BOOL
InitColorDlg(
    IN HWND  hdlg
    );

VOID
CenterDialog(
    HWND hwnd
    )

/*++

Routine Description:

    Centers a dialog relative to the app's main window

Arguments:

    hwnd - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,
          y,
          w,
          h;
    POINT point;
    LONG  sx = GetSystemMetrics(SM_CXSCREEN),
          sy = GetSystemMetrics(SM_CYSCREEN);

    point.x = point.y = 0;
    ClientToScreen(hwndFrame,&point);
    GetWindowRect (hwnd     ,&rcWindow);
    GetClientRect (hwndFrame,&rcFrame );

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    if (x + w > sx) {
        x = sx - w;
    } else if (x < 0) {
        x = 0;
    }
    if (y + h > sy) {
        y = sy - h;
    } else if (y < 0) {
        y = 0;
    }

    MoveWindow(hwnd,x,y,w,h,FALSE);
}

BOOL
MinMaxDlgProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    Dialog procedure for the enter size dialog box.  This dialog
    allows the user to enter a size for a partition, or use
    spin controls (a tiny scroll bar) to select the size.
    Possible outcomes are cancel or OK.  In the latter case the
    EndDialog code is the size.  In the former it is 0.

Arguments:

    hwnd - window handle of dialog box

    msg - message #

    wParam - msg specific data

    lParam - msg specific data

Return Value:

    msg dependent

--*/

{
    TCHAR             outputString[MESSAGE_BUFFER_SIZE];
    PMINMAXDLG_PARAMS params;
    BOOL              validNumber;
    DWORD             sizeMB;
    static DWORD      minSizeMB,
                      maxSizeMB,
                      helpContextId;

    switch (msg) {

    case WM_INITDIALOG:

        CenterDialog(hwnd);
        params = (PMINMAXDLG_PARAMS)lParam;
        // set up caption

        LoadString(hModule, params->CaptionStringID, outputString, sizeof(outputString)/sizeof(TCHAR));
        SetWindowText(hwnd, outputString);

        // set up minimum/maximum text

        LoadString(hModule, params->MinimumStringID, outputString, sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hwnd, IDC_MINMAX_MINLABEL, outputString);
        LoadString(hModule, params->MaximumStringID, outputString, sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hwnd, IDC_MINMAX_MAXLABEL, outputString);
        LoadString(hModule, params->SizeStringID, outputString, sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hwnd, IDC_MINMAX_SIZLABEL, outputString);

        minSizeMB = params->MinSizeMB;
        maxSizeMB = params->MaxSizeMB;
        helpContextId = params->HelpContextId;

        wsprintf(outputString, TEXT("%u"), minSizeMB);
        SetDlgItemText(hwnd, IDC_MINMAX_MIN, outputString);
        wsprintf(outputString, TEXT("%u"), maxSizeMB);
        SetDlgItemText(hwnd, IDC_MINMAX_MAX, outputString);

        // also put the size in the edit control and select the text

        wsprintf(outputString, TEXT("%u"), maxSizeMB);
        SetDlgItemText(hwnd, IDC_MINMAX_SIZE, outputString);
        SendDlgItemMessage(hwnd, IDC_MINMAX_SIZE, EM_SETSEL, 0, -1);
        SetFocus(GetDlgItem(hwnd, IDC_MINMAX_SIZE));
        return FALSE;      // indicate focus set to a control

    case WM_VSCROLL:

        switch (LOWORD(wParam)) {
        case SB_LINEDOWN:
        case SB_LINEUP:
            sizeMB = GetDlgItemInt(hwnd, IDC_MINMAX_SIZE, &validNumber, FALSE);
            if (!validNumber) {
                Beep(500,100);
            } else {
                if (((sizeMB > minSizeMB) && (LOWORD(wParam) == SB_LINEDOWN))
                 || ((sizeMB < maxSizeMB) && (LOWORD(wParam) == SB_LINEUP  )))
                {
                    if (sizeMB > maxSizeMB) {
                        sizeMB = maxSizeMB;
                    } else if (LOWORD(wParam) == SB_LINEUP) {
                        sizeMB++;
                    } else {
                        sizeMB--;
                    }
                    wsprintf(outputString, TEXT("%u"), sizeMB);
                    SetDlgItemText(hwnd, IDC_MINMAX_SIZE, outputString);
                    SendDlgItemMessage(hwnd, IDC_MINMAX_SIZE, EM_SETSEL, 0, -1);
                } else {
                    Beep(500,100);
                }
            }
        }
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:

            sizeMB = GetDlgItemInt(hwnd, IDC_MINMAX_SIZE, &validNumber, FALSE);
            if (!validNumber || !sizeMB || (sizeMB > maxSizeMB) || (sizeMB < minSizeMB)) {
                ErrorDialog(MSG_INVALID_SIZE);
            } else {
                EndDialog(hwnd, sizeMB);
            }
            break;

        case IDCANCEL:

            EndDialog(hwnd, 0);
            break;

        case FD_IDHELP:

            DialogHelp(helpContextId);
            break;

        default:

            return FALSE;
        }
        break;

    default:

        return FALSE;
    }
    return TRUE;
}

BOOL
DriveLetterDlgProc(
    IN HWND  hdlg,
    IN DWORD msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    Dialog for allowing the user to select a drive letter for a
    partition, logical drive, volume set, or stripe set.

    The EndDialog codes are as follows:

        0 - user cancelled
        NO_DRIVE_LETTER_EVER - user opted not to assign a drive letter
        other - the drive letter chosen by the user

Arguments:

    hdlg - window handle of dialog box

    msg - message #

    wParam - msg specific data

    lParam - msg specific data

Return Value:

    msg dependent

--*/

{
    static HWND        hwndCombo;
    static DWORD       currentSelection;
    TCHAR              driveLetter;
    TCHAR              driveLetterString[3];
    DWORD              defRadioButton,
                       selection;
    PREGION_DESCRIPTOR regionDescriptor;
    PFT_OBJECT         ftObject;
    TCHAR              description[256];

    switch (msg) {

    case WM_INITDIALOG:

        // lParam points to the region descriptor

        regionDescriptor = (PREGION_DESCRIPTOR)lParam;
        FDASSERT(DmSignificantRegion(regionDescriptor));

        hwndCombo = GetDlgItem(hdlg,IDC_DRIVELET_COMBOBOX);
        CenterDialog(hdlg);

        // Add each available drive letter to the list of available
        // drive letters.

        driveLetterString[1] = TEXT(':');
        driveLetterString[2] = 0;
        for (driveLetter='C'; driveLetter <= 'Z'; driveLetter++) {
            if (DriveLetterIsAvailable((CHAR)driveLetter)) {
                *driveLetterString = driveLetter;
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)driveLetterString);
            }
        }

        // Format the description of the partition.

        if (ftObject = GET_FT_OBJECT(regionDescriptor)) {

            TCHAR descr[256];
            DWORD resid = 0;

            // Ft.  Description is something like "Stripe set with parity #0"

            switch (ftObject->Set->Type) {
            case Mirror:
                resid = IDS_DLGCAP_MIRROR;
                break;
            case Stripe:
                resid = IDS_STATUS_STRIPESET;
                break;
            case StripeWithParity:
                resid = IDS_DLGCAP_PARITY;
                break;
            case VolumeSet:
                resid = IDS_STATUS_VOLUMESET;
                break;
            default:
                FDASSERT(FALSE);
            }

            LoadString(hModule, resid, descr, sizeof(descr)/sizeof(TCHAR));
            wsprintf(description, descr, ftObject->Set->Ordinal);

        } else {

            // Non-ft.  Description is something like '500 MB Unformatted
            // logical drive on disk 3' or '400 MB HPFS partition on disk 4'

            LPTSTR args[4];
            TCHAR  sizeStr[20],
                   partTypeStr[100],
                   diskNoStr[10],
                   typeName[150];
            TCHAR  formatString[256];

            args[0] = sizeStr;
            args[1] = typeName;
            args[2] = partTypeStr;
            args[3] = diskNoStr;

            wsprintf(sizeStr, "%u", regionDescriptor->SizeMB);
            wsprintf(typeName, "%ws", PERSISTENT_DATA(regionDescriptor)->TypeName);
            LoadString(hModule, regionDescriptor->RegionType == REGION_LOGICAL ? IDS_LOGICALVOLUME : IDS_PARTITION, partTypeStr, sizeof(partTypeStr)/sizeof(TCHAR));
            wsprintf(diskNoStr, "%u", regionDescriptor->Disk);

            LoadString(hModule, IDS_DRIVELET_DESCR, formatString, sizeof(formatString)/sizeof(TCHAR));
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          formatString,
                          0,
                          0,
                          description,
                          sizeof(description),
                          (va_list *)args);
        }

        SetWindowText(GetDlgItem(hdlg, IDC_DRIVELET_DESCR), description);
        driveLetter = (TCHAR)PERSISTENT_DATA(regionDescriptor)->DriveLetter;

        if ((driveLetter != NO_DRIVE_LETTER_YET) && (driveLetter != NO_DRIVE_LETTER_EVER)) {

            DWORD itemIndex;

            // There is a default drive letter.  Place it on the list,
            // check the correct radio button, and set the correct default
            // in the combo box.

            driveLetterString[0] = (TCHAR)driveLetter;
            itemIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)driveLetterString);
            SendMessage(hwndCombo, CB_SETCURSEL, itemIndex, 0);
            defRadioButton = IDC_DRIVELET_RBASSIGN;
            SetFocus(hwndCombo);
            currentSelection = itemIndex;

        } else {

            // Default is no drive letter.  Disable the combo box.  Select
            // the correct radio button.

            EnableWindow(hwndCombo, FALSE);
            defRadioButton = IDC_DRIVELET_RBNOASSIGN;
            SendMessage(hwndCombo, CB_SETCURSEL, (DWORD)(-1), 0);
            SetFocus(GetDlgItem(hdlg, IDC_DRIVELET_RBNOASSIGN));
            currentSelection = 0;
        }

        CheckRadioButton(hdlg, IDC_DRIVELET_RBASSIGN, IDC_DRIVELET_RBNOASSIGN, defRadioButton);
        return FALSE;      // focus set to control

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:

            // If the 'no letter' button is checked, return NO_DRIVE_LETTER_EVER

            if (IsDlgButtonChecked(hdlg, IDC_DRIVELET_RBNOASSIGN)) {
                EndDialog(hdlg, NO_DRIVE_LETTER_EVER);
                break;
            }

            // Otherwise, get the currently selected item in the listbox.

            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo, CB_GETLBTEXT, selection, (LONG)driveLetterString);
            EndDialog(hdlg,(int)(unsigned)(*driveLetterString));
            break;

        case IDCANCEL:

            EndDialog(hdlg, 0);
            break;

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_DRIVELETTER);
            break;

        case IDC_DRIVELET_RBASSIGN:

            if (HIWORD(wParam) == BN_CLICKED) {
                EnableWindow(hwndCombo, TRUE);
                SendMessage(hwndCombo, CB_SETCURSEL, currentSelection, 0);
                SetFocus(hwndCombo);
            }
            break;

        case IDC_DRIVELET_RBNOASSIGN:

            if (HIWORD(wParam) == BN_CLICKED) {
                currentSelection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                SendMessage(hwndCombo, CB_SETCURSEL, (DWORD)-1, 0);
                EnableWindow(hwndCombo, FALSE);
            }
            break;

        default:

            return FALSE;
        }
        break;

    default:

        return FALSE;
    }
    return TRUE;
}

BOOL
DisplayOptionsDlgProc(
    IN HWND  hdlg,
    IN UINT  msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    Dialog procedure for display options.  Currently the only display option
    is to alter the graph type (proportional/equal) on each disk.

    For this dialog, lParam on creation must point to a buffer into which
    this dialog procedure will place the user's new choices for the graph
    display type for each disk.

Arguments:

    hdlg - window handle of dialog box

    msg - message #

    wParam - msg specific data

    lParam - msg specific data

Return Value:

    msg dependent

--*/

{
    static PBAR_TYPE newBarTypes;
    static HWND      hwndCombo;
    DWORD            selection;
    DWORD            i;

    switch (msg) {

    case WM_INITDIALOG:

        CenterDialog(hdlg);
        newBarTypes = (PBAR_TYPE)lParam;
        hwndCombo = GetDlgItem(hdlg, IDC_DISK_COMBOBOX);

        // Add each disk to the combo box.

        for (i=0; i<DiskCount; i++) {

            TCHAR str[10];

            wsprintf(str,TEXT("%u"),i);
            SendMessage(hwndCombo, CB_ADDSTRING, 0, (DWORD)str);
        }

        // select the zeroth item in the combobox
        SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);
        SendMessage(hdlg,
                    WM_COMMAND,
                    MAKELONG(IDC_DISK_COMBOBOX,CBN_SELCHANGE),
                    0);
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
            EndDialog(hdlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        case FD_IDHELP:
            DialogHelp(HC_DM_DLG_DISPLAYOPTION);
            break;

        case IDC_DISK_COMBOBOX:

            if (HIWORD(wParam) == CBN_SELCHANGE) {

                int rb = 0;

                // Selection in the combobox has changed; update the radio buttons

                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);

                switch (newBarTypes[selection]) {
                case BarProportional:
                    rb = IDC_RBPROPORTIONAL;
                    break;
                case BarEqual:
                    rb = IDC_RBEQUAL;
                    break;
                case BarAuto:
                    rb = IDC_RBAUTO;
                    break;
                default:
                    FDASSERT(0);
                }

                CheckRadioButton(hdlg, IDC_RBPROPORTIONAL, IDC_RBAUTO, rb);
            }
            break;

        case IDC_RESETALL:

            if (HIWORD(wParam) == BN_CLICKED) {
                for (i=0; i<DiskCount; i++) {
                    newBarTypes[i] = BarAuto;
                }
                CheckRadioButton(hdlg, IDC_RBPROPORTIONAL, IDC_RBAUTO, IDC_RBAUTO);
            }
            break;

        case IDC_RBPROPORTIONAL:

            if (HIWORD(wParam) == BN_CLICKED) {
                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                newBarTypes[selection] = BarProportional;
            }
            break;

        case IDC_RBEQUAL:

            if (HIWORD(wParam) == BN_CLICKED) {
                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                newBarTypes[selection] = BarEqual;
            }
            break;

        case IDC_RBAUTO:

            if (HIWORD(wParam) == BN_CLICKED) {
                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                newBarTypes[selection] = BarAuto;
            }
            break;

        default:
            return FALSE;
        }
        break;

    default:

        return FALSE;
    }
    return TRUE;
}

BOOL
ColorDlgProc(
    IN HWND  hdlg,
    IN DWORD msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    Dialog for the select colors/patterns dialog box.  Note that this dialog
    uses a rectangle custom control, defined below.

Arguments:

    hwnd - window handle of dialog box

    msg - message #

    wParam - msg specific data

    lParam - msg specific data

Return Value:

    msg dependent

--*/

{
    unsigned i;

    switch (msg) {

    case WM_INITDIALOG:

        #if BRUSH_ARRAY_SIZE != LEGEND_STRING_COUNT
        #error legend label array and brush array are out of sync
        #endif

        if (!InitColorDlg(hdlg)) {
            EndDialog(hdlg, -1);
        }
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:

            for (i=0; i<LEGEND_STRING_COUNT; i++) {
                SelectedColor[i] -= IDC_COLOR1;
                SelectedHatch[i] -= IDC_PATTERN1;
            }
            EndDialog(hdlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        case FD_IDHELP:
            DialogHelp(HC_DM_COLORSANDPATTERNS);
            break;

        case IDC_COLORDLGCOMBO:
            switch (HIWORD(wParam)) {
            case CBN_SELCHANGE:
                // deselect previous color
                SendMessage(GetDlgItem(hdlg, SelectedColor[CurrentElement]),
                            RM_SELECT,
                            FALSE,
                            0);
                // deselect previous pattern
                SendMessage(GetDlgItem(hdlg, SelectedHatch[CurrentElement]),
                            RM_SELECT,
                            FALSE,
                            0);
                CurrentElement = SendMessage((HWND)lParam, CB_GETCURSEL, 0, 0);
                SendMessage(hdlg, WM_COMMAND, MAKELONG(SelectedColor[CurrentElement], 0), 0);
                SendMessage(hdlg, WM_COMMAND, MAKELONG(SelectedHatch[CurrentElement], 0), 0);
                break;
            default:
                return FALSE;
            }
            break;

        case IDC_COLOR1:
        case IDC_COLOR2:
        case IDC_COLOR3:
        case IDC_COLOR4:
        case IDC_COLOR5:
        case IDC_COLOR6:
        case IDC_COLOR7:
        case IDC_COLOR8:
        case IDC_COLOR9:
        case IDC_COLOR10:
        case IDC_COLOR11:
        case IDC_COLOR12:
        case IDC_COLOR13:
        case IDC_COLOR14:
        case IDC_COLOR15:
        case IDC_COLOR16:
            // deselect previous color

            SendMessage(GetDlgItem(hdlg, SelectedColor[CurrentElement]),
                        RM_SELECT,
                        FALSE,
                        0);
            SendMessage(GetDlgItem(hdlg, LOWORD(wParam)),
                        RM_SELECT,
                        TRUE,
                        0);
            SelectedColor[CurrentElement] = LOWORD(wParam);

            // now force patterns to be redrawn in selected color

            for (i=IDC_PATTERN1; i<=IDC_PATTERN5; i++) {
                InvalidateRect(GetDlgItem(hdlg, i), NULL, FALSE);
            }
            break;

        case IDC_PATTERN1:
        case IDC_PATTERN2:
        case IDC_PATTERN3:
        case IDC_PATTERN4:
        case IDC_PATTERN5:
            // deselect previous pattern
            SendMessage(GetDlgItem(hdlg, SelectedHatch[CurrentElement]),
                        RM_SELECT,
                        FALSE,
                        0);
            SendMessage(GetDlgItem(hdlg, LOWORD(wParam)),
                        RM_SELECT,
                        TRUE,
                        0);
            SelectedHatch[CurrentElement] = LOWORD(wParam);
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL
InitColorDlg(
    IN HWND  hdlg
    )

/*++

Routine Description:

    Initialize the color selection dialog.

Arguments:

    hdlg - the dialog handle.

Return Value:

    TRUE - successfully set up the dialog.

--*/

{
    unsigned i;
    LONG     ec;
    HWND     hwndCombo = GetDlgItem(hdlg, IDC_COLORDLGCOMBO);

    hDlgColor = hdlg;

    CenterDialog(hdlg);

    for (i=0; i<LEGEND_STRING_COUNT; i++) {
        ec = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)LegendLabels[i]);
        if ((ec == CB_ERR) || (ec == CB_ERRSPACE)) {
            return FALSE;
        }
        SelectedColor[i] = IDC_COLOR1 + BrushColors[i];
        SelectedHatch[i] = IDC_PATTERN1 + BrushHatches[i];
    }
    SendMessage(hwndCombo, CB_SETCURSEL, CurrentElement=0, 0);
    SendMessage(hdlg, WM_COMMAND, MAKELONG(GetDlgCtrlID(hwndCombo), CBN_SELCHANGE), (LONG)hwndCombo);
    return TRUE;
}

LONG
RectWndProc(
    IN HWND  hwnd,
    IN DWORD msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    This is a pre-process routine for all access to the disk
    bar display region of the WinDisk interface.

Arguments:

    hwnd - the dialog handle
    msg  - the windows message for the dialog
    wParam/lParam - windows dialog parameters.

Return Value:

    Standard dialog requirements.

--*/

{
    LONG        res = 1;
    PAINTSTRUCT ps;
    RECT        rc;
    int         CtlID;
    HBRUSH      hbr,
                hbrT;
    DWORD       style;

    switch (msg) {

    case WM_CREATE:

        FDASSERT(GetWindowLong(hwnd, GWL_STYLE) & (RS_PATTERN | RS_COLOR));
        SetWindowWord(hwnd, GWW_SELECTED, FALSE);
        break;

    case WM_LBUTTONDOWN:

        SetFocus(hwnd);
        break;

    case WM_SETFOCUS:

        SendMessage(GetParent(hwnd), WM_COMMAND, MAKELONG(GetDlgCtrlID(hwnd), RN_CLICKED), (LONG)hwnd);
        break;

    case WM_PAINT:

        GetClientRect(hwnd, &rc);
        CtlID = GetDlgCtrlID(hwnd);
        BeginPaint(hwnd, &ps);

        hbr = CreateSolidBrush(GetWindowWord(hwnd, GWW_SELECTED)
                               ? (~GetSysColor(COLOR_WINDOW)) & 0xffffff
                               : GetSysColor(COLOR_WINDOW));
        hbrT = SelectObject(ps.hdc,hbr);
        SelectObject(ps.hdc, hPenNull);
        Rectangle(ps.hdc, rc.left, rc.top, rc.right, rc.bottom);

        if (hbrT) {
            SelectObject(ps.hdc, hbrT);
        }
        DeleteObject(hbr);

        InflateRect(&rc, -2, -2);
        rc.right--;
        rc.bottom--;

        if (GetWindowLong(hwnd, GWL_STYLE) & RS_COLOR) {
            hbr = CreateSolidBrush(AvailableColors[CtlID-IDC_COLOR1]);
        } else {
            hbr = CreateHatchBrush(AvailableHatches[CtlID-IDC_PATTERN1], AvailableColors[SelectedColor[SendMessage(GetDlgItem(hDlgColor, IDC_COLORDLGCOMBO), CB_GETCURSEL, 0, 0)]-IDC_COLOR1]);
        }

        hbrT = SelectObject(ps.hdc, hbr);
        SelectObject(ps.hdc, hPenThinSolid);
        Rectangle(ps.hdc, rc.left, rc.top, rc.right, rc.bottom);

        if (hbrT) {
            SelectObject(ps.hdc, hbrT);
        }

        DeleteObject(hbr);

        EndPaint(hwnd, &ps);
        break;

    case RM_SELECT:

        // wParam = TRUE/FALSE for selected/not selected

        if (GetWindowWord(hwnd, GWW_SELECTED) != (WORD)wParam) {

            SetWindowWord(hwnd, GWW_SELECTED, (WORD)wParam);
            InvalidateRect(hwnd, NULL, FALSE);

            // make keyboard interface work correctly

            style = (DWORD)GetWindowLong(hwnd, GWL_STYLE);
            style = wParam ? style | WS_TABSTOP : style & ~WS_TABSTOP;
            SetWindowLong(hwnd, GWL_STYLE, (LONG)style);
        }

        break;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return res;
}

VOID
InitRectControl(
    VOID
    )

/*++

Routine Description:

    Register the windows class for the selection control.

Arguments:

    None

Return Value:

    None

--*/

{
    WNDCLASS wc;

    wc.style         = 0;
    wc.lpfnWndProc   = (WNDPROC)RectWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = RECTCONTROL_WNDEXTRA;
    wc.hInstance     = hModule;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = TEXT(RECTCONTROL);

    RegisterClass(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fdinit.c

Abstract:

    Code for initializing the fdisk application.

Author:

    Ted Miller (tedm) 7-Jan-1992

--*/

#include "fdisk.h"

HWND    InitDlg;
BOOLEAN StartedAsIcon = FALSE;
BOOLEAN InitDlgComplete = FALSE;

BOOL
InitializeApp(
    VOID
    )

/*++

Routine Description:

    This routine initializes the fdisk app.  This includes registering
    the frame window class and creating the frame window.

Arguments:

    None.

Return Value:

    boolean value indicating success or failure.

--*/

{
    WNDCLASS   wc;
    TCHAR      szTitle[80];
    DWORD      ec;
    HDC        hdcScreen = GetDC(NULL);
    TEXTMETRIC tm;
    BITMAP     bitmap;
    HFONT      hfontT;
    unsigned   i;

    ReadProfile();

    // Load cursors

    hcurWait   = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
    hcurNormal = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));

    // fonts

#ifdef JAPAN
    hFontGraph =  CreateFont(GetHeightFromPoints(10), 0,
                             0, 0, 400, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET,
                             OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS,
                             TEXT("System")
                            );
#else
    hFontGraph =  CreateFont(GetHeightFromPoints(8), 0,
                             0, 0, 400, FALSE, FALSE, FALSE, ANSI_CHARSET,
                             OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS,
                             TEXT("Helv"));
#endif

    hFontLegend = hFontGraph;
    hFontStatus = hFontGraph;

#ifdef JAPAN
    hFontGraphBold = CreateFont(GetHeightFromPoints(10), 0,
                                0, 0, 700, FALSE, FALSE, FALSE,
                                                                SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
                                                                CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                                                VARIABLE_PITCH | FF_SWISS, TEXT("System")
                               );
#else
    hFontGraphBold = CreateFont(GetHeightFromPoints(8), 0,
                                0, 0, 700, FALSE, FALSE, FALSE, ANSI_CHARSET,
                                OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS,
                                TEXT("Helv"));
#endif

    hfontT = SelectObject(hdcScreen, hFontGraph);
    GetTextMetrics(hdcScreen, &tm);
    if (hfontT) {
        SelectObject(hdcScreen, hfontT);
    }

    hPenNull      = CreatePen(PS_NULL, 0, 0);
    hPenThinSolid = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));

    GraphWidth = (DWORD)GetSystemMetrics(SM_CXSCREEN);
    GraphHeight = 25 * tm.tmHeight / 4;     // 6.25 x font height

    // set up the legend off-screen bitmap

    wLegendItem = GetSystemMetrics(SM_CXHTHUMB);
    dyLegend = 2 * wLegendItem;     // 7*wLegendItem/2 for a double-height legend

    ReleaseDC(NULL, hdcScreen);

    dyBorder = GetSystemMetrics(SM_CYBORDER);
    dyStatus = tm.tmHeight + tm.tmExternalLeading + 7 * dyBorder;

    // set up brushes

    for (i=0; i<BRUSH_ARRAY_SIZE; i++) {
        Brushes[i] = CreateHatchBrush(AvailableHatches[BrushHatches[i]], AvailableColors[BrushColors[i]]);
    }

    hBrushFreeLogical = CreateHatchBrush(HS_FDIAGONAL, RGB(128, 128, 128));
    hBrushFreePrimary = CreateHatchBrush(HS_BDIAGONAL, RGB(128, 128, 128));

    // load legend strings

    for (i=IDS_LEGEND_FIRST; i<=IDS_LEGEND_LAST; i++) {
        if (!(LegendLabels[i-IDS_LEGEND_FIRST] = LoadAString(i))) {
            return FALSE;
        }
    }

    if (((wszUnformatted    = LoadWString(IDS_UNFORMATTED))     == NULL)
    ||  ((wszNewUnformatted = LoadWString(IDS_NEW_UNFORMATTED)) == NULL)
    ||  ((wszUnknown        = LoadWString(IDS_UNKNOWN    ))     == NULL)) {
        return FALSE;
    }

    // register the frame class

    wc.style         = CS_OWNDC | CS_VREDRAW;
    wc.lpfnWndProc   = MyFrameWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hModule;
    wc.hIcon         = LoadIcon(hModule, MAKEINTRESOURCE(IDFDISK));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName  = MAKEINTRESOURCE(IDFDISK);
    wc.lpszClassName = szFrame;

    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    if (!RegisterArrowClass(hModule)) {
        return FALSE;
    }

    LoadString(hModule, IDS_APPNAME, szTitle, sizeof(szTitle)/sizeof(TCHAR));

    // create the frame window.  Note that this also creates the listbox.

    hwndFrame = CreateWindow(szFrame,
                             szTitle,
                             WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                             ProfileWindowX,
                             ProfileWindowY,
                             ProfileWindowW,
                             ProfileWindowH,
                             NULL,
                             NULL,
                             hModule,
                             NULL);
    if (!hwndFrame) {
        return FALSE;
    }

    if (!hwndList) {
        DestroyWindow(hwndFrame);
        return FALSE;
    }

    hDC = GetDC(hwndFrame);
    BarTopYOffset = tm.tmHeight;
    BarHeight = 21 * tm.tmHeight / 4;
    BarBottomYOffset = BarTopYOffset + BarHeight;
    dxBarTextMargin = 5*tm.tmAveCharWidth/4;
    dyBarTextLine = tm.tmHeight;

    dxDriveLetterStatusArea = 5 * tm.tmAveCharWidth / 2;

    hBitmapSmallDisk = LoadBitmap(hModule, MAKEINTRESOURCE(IDB_SMALLDISK));
    GetObject(hBitmapSmallDisk, sizeof(BITMAP), &bitmap);
    dxSmallDisk = bitmap.bmWidth;
    dySmallDisk = bitmap.bmHeight;
    xSmallDisk = dxSmallDisk / 2;
    ySmallDisk = BarTopYOffset + (2*dyBarTextLine) - dySmallDisk - tm.tmDescent;

    hBitmapRemovableDisk = LoadBitmap(hModule, MAKEINTRESOURCE(IDB_REMOVABLE));
    GetObject(hBitmapRemovableDisk, sizeof(BITMAP), &bitmap);
    dxRemovableDisk = bitmap.bmWidth;
    dyRemovableDisk = bitmap.bmHeight;
    xRemovableDisk = dxRemovableDisk / 2;
    yRemovableDisk = BarTopYOffset + (2*dyBarTextLine) - dyRemovableDisk - tm.tmDescent;


    BarLeftX = 7 * dxSmallDisk;
    BarWidth = GraphWidth - BarLeftX - (5 * tm.tmAveCharWidth);

    DiskN = LoadAString(IDS_DISKN);

    if ((ec = InitializeListBox(hwndList)) != NO_ERROR) {
        DestroyWindow(hwndList);
        DestroyWindow(hwndFrame);
        return FALSE;
    }

    // initial list box selection cursor (don't allow to fall on
    // extended partition).
    LBCursorListBoxItem = 0;
    ResetLBCursorRegion();

    ShowWindow(hwndFrame,
               ProfileIsIconic ? SW_SHOWMINIMIZED
                               : ProfileIsMaximized ? SW_SHOWMAXIMIZED : SW_SHOWDEFAULT);
    UpdateWindow(hwndFrame);
    return TRUE;
}

VOID
CreateDiskState(
    OUT PDISKSTATE *DiskState,
    IN  DWORD       Disk,
    OUT PBOOL       SignatureCreated
    )

/*++

Routine Description:

    This routine is designed to be called once, at initialization time,
    per disk.  It creates and initializes a disk state -- which includes
    creating a memory DC and compatible bitmap for drawing the disk's
    graph, and getting some information that is static in nature about
    the disk (ie, its total size.)

Arguments:

    DiskState - structure whose fields are to be intialized

    Disk - number of disk

    SignatureCreated - received boolean indicating whether an FT signature was created for
        the disk.

Return Value:

    None.

--*/

{
    HDC        hDCMem;
    PDISKSTATE pDiskState = Malloc(sizeof(DISKSTATE));


    *DiskState = pDiskState;

    pDiskState->LeftRight = Malloc(0);
    pDiskState->Selected  = Malloc(0);

    pDiskState->Disk = Disk;

    // create a memory DC for drawing the bar off-screen,
    // and the correct bitmap

#if 0
    pDiskState->hDCMem = NULL;
    pDiskState->hbmMem = NULL;
    hDCMem = CreateCompatibleDC(hDC);
#else
    pDiskState->hDCMem   = hDCMem = CreateCompatibleDC(hDC);
    pDiskState->hbmMem   = CreateCompatibleBitmap(hDC, GraphWidth, GraphHeight);
#endif
    SelectObject(hDCMem,pDiskState->hbmMem);


    pDiskState->RegionArray = NULL;
    pDiskState->RegionCount = 0;
    pDiskState->BarType = BarAuto;
    pDiskState->OffLine = IsDiskOffLine(Disk);

    if (pDiskState->OffLine) {

        pDiskState->SigWasCreated = FALSE;
        pDiskState->Signature = 0;
        pDiskState->DiskSizeMB = 0;
        FDLOG((1, "CreateDiskState: Disk %u is off-line\n", Disk));
    } else {

        pDiskState->DiskSizeMB = DiskSizeMB(Disk);
        if (pDiskState->Signature = FdGetDiskSignature(Disk)) {

            if (SignatureIsUniqueToSystem(Disk, pDiskState->Signature)) {
                pDiskState->SigWasCreated = FALSE;
                FDLOG((2,
                      "CreateDiskState: Found signature %08lx on disk %u\n",
                      pDiskState->Signature,
                      Disk));
            } else {
                goto createSignature;
            }
        } else {

createSignature:
            pDiskState->Signature = FormDiskSignature();
            FdSetDiskSignature(Disk, pDiskState->Signature);
            pDiskState->SigWasCreated = TRUE;
            FDLOG((1,
                  "CreateDiskState: No signature on disk %u; created signature %08lx\n",
                  Disk,
                  pDiskState->Signature));
        }
    }

    *SignatureCreated = (BOOL)pDiskState->SigWasCreated;
}

BOOL
InitializationDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

    standard Windows dialog procedure

Return Values:

    standard Windows dialog procedure

--*/

{
    static DWORD          percentDrawn;
    static RECT           rectGG;              // GasGauge rectangle
    static BOOL           captionIsLoaded;
    static PFORMAT_PARAMS formatParams;
           TCHAR          title[100],
                          templateString[100];

    switch (uMsg) {
    case WM_INITDIALOG: {
        HWND   hwndGauge = GetDlgItem(hDlg, IDC_GASGAUGE);

        InitDlg = hDlg;
        percentDrawn = 0;
        StartedAsIcon = IsIconic(hDlg);

        // Get the coordinates of the gas gauge static control rectangle,
        // and convert them to dialog client area coordinates

        GetClientRect(hwndGauge, &rectGG);
        ClientToScreen(hwndGauge, (LPPOINT)&rectGG.left);
        ClientToScreen(hwndGauge, (LPPOINT)&rectGG.right);
        ScreenToClient(hDlg, (LPPOINT)&rectGG.left);
        ScreenToClient(hDlg, (LPPOINT)&rectGG.right);
        return TRUE;
    }

    case WM_PAINT: {
        INT         width  = rectGG.right - rectGG.left;
        INT         height = rectGG.bottom - rectGG.top;
        INT         nDivideRects;
        HDC         hDC;
        PAINTSTRUCT ps;
        TCHAR       buffer[10];
        SIZE        size;
        INT         xText,
                    yText,
                    byteCount;
        RECT        rectDone,
                    rectLeftToDo;

        hDC = BeginPaint(hDlg, &ps);
        byteCount = wsprintf(buffer, TEXT("%3d%%"), percentDrawn);
        GetTextExtentPoint(hDC, buffer, lstrlen(buffer), &size);
        xText = rectGG.left + (width  - size.cx) / 2;
        yText = rectGG.top  + (height - size.cy) / 2;

        // Paint in the "done so far" rectangle of the gas
        // gauge with blue background and white text

        nDivideRects = (width * percentDrawn) / 100;
        SetRect(&rectDone,
                rectGG.left,
                rectGG.top,
                rectGG.left + nDivideRects,
                rectGG.bottom);

        SetTextColor(hDC, RGB(255, 255, 255));
        SetBkColor(hDC, RGB(0, 0, 255));
        ExtTextOut(hDC,
                   xText,
                   yText,
                   ETO_CLIPPED | ETO_OPAQUE,
                   &rectDone,
                   buffer,
                   byteCount/sizeof(TCHAR),
                   NULL);

        // Paint in the "still left to do" rectangle of the gas
        // gauge with white background and blue text

        SetRect(&rectLeftToDo,
                rectGG.left + nDivideRects,
                rectGG.top,
                rectGG.right,
                rectGG.bottom);
        SetBkColor(hDC, RGB(255, 255, 255));
        SetTextColor(hDC, RGB(0, 0, 255));
        ExtTextOut(hDC,
                   xText,
                   yText,
                   ETO_CLIPPED | ETO_OPAQUE,
                   &rectLeftToDo,
                   buffer,
                   byteCount/sizeof(TCHAR),
                   NULL);
        EndPaint(hDlg, &ps);

        if (percentDrawn == 100) {
            InitDlgComplete = TRUE;
        }
        return TRUE;
    }

    case WM_USER:
         percentDrawn = (INT)wParam;
         InvalidateRect(hDlg, &rectGG, TRUE);
         UpdateWindow(hDlg);
         return TRUE;

    case (WM_USER + 1):
        EndDialog(hDlg, FALSE);
        return TRUE;

    default:

        return FALSE;
    }
}

VOID
InitializationMessageThread(
    PVOID ThreadParameter
    )

/*++

Routine Description:

    This is the entry for the initialization message thread.  It creates
    a dialog that simply tells the user to be patient.

Arguments:

    ThreadParameter - not used.

Return Value:

    None

--*/

{
    DialogBoxParam(hModule,
                   MAKEINTRESOURCE(IDD_INITIALIZING),
                   hwndFrame,
                   (DLGPROC) InitializationDlgProc,
                   (ULONG) NULL);
    InitDlg = (HWND) 0;
    ExitThread(0L);
}

VOID
DisplayInitializationMessage(
    VOID
    )

/*++

Routine Description:

    Create a 2nd thread to display an initialization message.

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE threadHandle;
    DWORD  threadId;

    threadHandle = CreateThread(NULL,
                                0,
                                (LPTHREAD_START_ROUTINE) InitializationMessageThread,
                                (LPVOID) NULL,
                                (DWORD) 0,
                                (LPDWORD) &threadId);
    if (!threadHandle) {
        CloseHandle(threadHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdengine.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    fdengine.c

Abstract:

    This module contains the disk partitioning engine.  The code
    in this module can be compiled for either the NT platform
    or the ARC platform (-DARC).

Author:

    Ted Miller        (tedm)    Nov-1991

Revision History:

    Bob Rinne         (bobri)   Feb-1994
    Moved as actual part of Disk Administrator enlistment instead of being
    copied from ArcInst.  This is due to dynamic partition changes.  Removed
    string table that made this an internationalized file.

--*/

#include "fdisk.h"

#include <stdio.h>
#include <stdlib.h>

// Attached disk devices.

ULONG              CountOfDisks;
PCHAR             *DiskNames;

// Information about attached disks.

DISKGEOM          *DiskGeometryArray;

PPARTITION        *PrimaryPartitions,
                  *LogicalVolumes;

// A 'signature' is a unique 4-byte value immediately preceeding the
// partition table in the MBR.

PULONG             Signatures;

// Array keeping track of whether each disk is off line.

PBOOLEAN           OffLine;

// Keeps track of whether changes have been requested
// to each disk's partition structure.

BOOLEAN           *ChangesRequested;
BOOLEAN           *ChangesCommitted;


// Value used to indicate that the partition entry has changed but in a non-
// destructive way (ie, made active/inactive).

#define CHANGED_DONT_ZAP ((BOOLEAN)(5))

// forward declarations


STATUS_CODE
OpenDisks(
    VOID
    );

VOID
CloseDisks(
    VOID
    );

STATUS_CODE
GetGeometry(
    VOID
    );

BOOLEAN
CheckIfDiskIsOffLine(
    IN ULONG Disk
    );

STATUS_CODE
InitializePartitionLists(
    VOID
    );

STATUS_CODE
GetRegions(
    IN  ULONG               Disk,
    IN  PPARTITION          p,
    IN  BOOLEAN             WantUsedRegions,
    IN  BOOLEAN             WantFreeRegions,
    IN  BOOLEAN             WantLogicalRegions,
    OUT PREGION_DESCRIPTOR *Region,
    OUT ULONG              *RegionCount,
    IN  REGION_TYPE         RegionType
    );

BOOLEAN
AddRegionEntry(
    IN OUT PREGION_DESCRIPTOR *Regions,
    IN OUT ULONG              *RegionCount,
    IN     ULONG               SizeMB,
    IN     REGION_TYPE         RegionType,
    IN     PPARTITION          Partition,
    IN     LARGE_INTEGER       AlignedRegionOffset,
    IN     LARGE_INTEGER       AlignedRegionSize
    );

VOID
AddPartitionToLinkedList(
    IN PARTITION **Head,
    IN PARTITION *p
    );

BOOLEAN
IsInLinkedList(
    IN PPARTITION p,
    IN PPARTITION List
    );

BOOLEAN
IsInLogicalList(
    IN ULONG      Disk,
    IN PPARTITION p
    );

BOOLEAN
IsInPartitionList(
    IN ULONG      Disk,
    IN PPARTITION p
    );

LARGE_INTEGER
AlignTowardsDiskStart(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset
    );

LARGE_INTEGER
AlignTowardsDiskEnd(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset
    );

VOID
FreeLinkedPartitionList(
    IN PARTITION **q
    );

VOID
MergeFreePartitions(
    IN PPARTITION p
    );

VOID
FreePartitionInfoLinkedLists(
    IN PARTITION **ListHeadArray
    );

LARGE_INTEGER
DiskLengthBytes(
    IN ULONG Disk
    );

PPARTITION
AllocatePartitionStructure(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length,
    IN UCHAR         SysID,
    IN BOOLEAN       Update,
    IN BOOLEAN       Active,
    IN BOOLEAN       Recognized
    );

STATUS_CODE
LowFreeFdiskPathList(
    IN OUT  PCHAR*  PathList,
    IN      ULONG   ListLength
    );

STATUS_CODE
LowQueryFdiskPathList(
    OUT PCHAR  **PathList,
    OUT PULONG   ListLength
    );


STATUS_CODE
FdiskInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the partitioning engine, including allocating
    arrays, determining attached disk devices, and reading their
    partition tables.

Arguments:

    None.

Return Value:

    OK_STATUS or error code.

--*/

{
    STATUS_CODE status;
    ULONG        i;


    if ((status = LowQueryFdiskPathList(&DiskNames, &CountOfDisks)) != OK_STATUS) {
        return status;
    }

    DiskGeometryArray = NULL;
    PrimaryPartitions = NULL;
    LogicalVolumes = NULL;

    if (((DiskGeometryArray      = AllocateMemory(CountOfDisks * sizeof(DISKGEOM  ))) == NULL)
     || ((ChangesRequested       = AllocateMemory(CountOfDisks * sizeof(BOOLEAN   ))) == NULL)
     || ((ChangesCommitted       = AllocateMemory(CountOfDisks * sizeof(BOOLEAN   ))) == NULL)
     || ((PrimaryPartitions      = AllocateMemory(CountOfDisks * sizeof(PPARTITION))) == NULL)
     || ((Signatures             = AllocateMemory(CountOfDisks * sizeof(ULONG     ))) == NULL)
     || ((OffLine                = AllocateMemory(CountOfDisks * sizeof(BOOLEAN   ))) == NULL)
     || ((LogicalVolumes         = AllocateMemory(CountOfDisks * sizeof(PPARTITION))) == NULL))
    {
        RETURN_OUT_OF_MEMORY;
    }

    for (i=0; i<CountOfDisks; i++) {
        PrimaryPartitions[i] = NULL;
        LogicalVolumes[i] = NULL;
        ChangesRequested[i] = FALSE;
        ChangesCommitted[i] = FALSE;
        OffLine[i] = CheckIfDiskIsOffLine(i);
    }

    if (((status = GetGeometry()             ) != OK_STATUS)
     || ((status = InitializePartitionLists()) != OK_STATUS)) {
        return status;
    }

    return OK_STATUS;
}


VOID
FdiskCleanUp(
    VOID
    )

/*++

Routine Description:

    This routine deallocates storage used by the partitioning engine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LowFreeFdiskPathList(DiskNames, CountOfDisks);

    if (DiskGeometryArray != NULL) {
        FreeMemory(DiskGeometryArray);
    }
    if (PrimaryPartitions != NULL) {
        FreePartitionInfoLinkedLists(PrimaryPartitions);
        FreeMemory(PrimaryPartitions);
    }
    if (LogicalVolumes != NULL) {
        FreePartitionInfoLinkedLists(LogicalVolumes);
        FreeMemory(LogicalVolumes);
    }
    if (ChangesRequested != NULL) {
        FreeMemory(ChangesRequested);
    }
    if (ChangesCommitted != NULL) {
        FreeMemory(ChangesCommitted);
    }
    if (OffLine != NULL) {
        FreeMemory(OffLine);
    }
    if (Signatures != NULL) {
        FreeMemory(Signatures);
    }
}


BOOLEAN
CheckIfDiskIsOffLine(
    IN ULONG Disk
    )

/*++

Routine Description:

    Determine whether a disk is off-line by attempting to open it.
    If this is diskman, also attempt to read from it.

Arguments:

    Disk - supplies number of the disk to check

Return Value:

    TRUE if disk is off-line, FALSE is disk is on-line.

--*/

{
    HANDLE_T handle;
    UINT     errorMode;
    BOOLEAN  isOffLine = TRUE;

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    if (LowOpenDisk(GetDiskName(Disk), &handle) == OK_STATUS) {

        ULONG dummy,
              bps;
        PVOID unalignedBuffer,
              buffer;

        // The open might succeed even if the disk is off line.  So to be
        // sure, read the first sector from the disk.

        if (NT_SUCCESS(LowGetDriveGeometry(GetDiskName(Disk), &dummy, &bps, &dummy, &dummy))) {

            unalignedBuffer = Malloc(2*bps);
            buffer = (PVOID)(((ULONG)unalignedBuffer+bps) & ~(bps-1));

            if (NT_SUCCESS(LowReadSectors(handle,bps,0,1,buffer))) {
                isOffLine = FALSE;
            }

            Free(unalignedBuffer);
        } else {

            // It is possible this is a removable drive.

            if (IsRemovable(Disk)) {
                isOffLine = FALSE;
            }
        }
        LowCloseDisk(handle);
    }
    SetErrorMode(errorMode);

    return isOffLine;
}


STATUS_CODE
GetGeometry(
    VOID
    )

/*++

Routine Description:

    This routine determines disk geometry for each disk device.
    Disk geometry includes heads, sectors per track, cylinder count,
    and bytes per sector.  It also includes bytes per track and
    bytes per cylinder, which are calculated from the other values
    for the convenience of the rest of this module.

    Geometry information is placed in the DiskGeometryArray global variable.

    Geometry information is undefined for an off-line disk.

Arguments:

    None.

Return Value:

    OK_STATUS or error code.

--*/

{
    ULONG       i;
    STATUS_CODE status;
    ULONG       TotalSectorCount,
                SectorSize,
                SectorsPerTrack,
                Heads;

    for (i=0; i<CountOfDisks; i++) {

        if (OffLine[i]) {
            continue;
        }

        if ((status = LowGetDriveGeometry(DiskNames[i],&TotalSectorCount,&SectorSize,&SectorsPerTrack,&Heads)) != OK_STATUS) {
            return(status);
        }

        DiskGeometryArray[i].BytesPerSector   = SectorSize;
        DiskGeometryArray[i].SectorsPerTrack  = SectorsPerTrack;
        DiskGeometryArray[i].Heads            = Heads;
        DiskGeometryArray[i].Cylinders.QuadPart = (TotalSectorCount / (SectorsPerTrack * Heads));
        DiskGeometryArray[i].BytesPerTrack    = SectorsPerTrack * SectorSize;
        DiskGeometryArray[i].BytesPerCylinder = SectorsPerTrack * SectorSize * Heads;
    }
    return(OK_STATUS);
}


#if i386
VOID
SetPartitionActiveFlag(
    IN PREGION_DESCRIPTOR Region,
    IN UCHAR              value
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PPARTITION p = ((PREGION_DATA)Region->Reserved)->Partition;

    if((UCHAR)p->Active != value) {

        //
        // Unfortuneately, the Update flag becomes the RewritePartition flag
        // at commit time.  This causes us to zap the boot sector.  To avoid
        // this, we use a spacial non-boolean value that can be checked for
        // at commit time and that will cause us NOT to zap the bootsector
        // even though RewritePartition will be TRUE.
        //

        p->Active = value;
        if(!p->Update) {
            p->Update = CHANGED_DONT_ZAP;
        }
        ChangesRequested[p->Disk] = TRUE;
    }
}
#endif


VOID
DetermineCreateSizeAndOffset(
    IN  PREGION_DESCRIPTOR Region,
    IN  LARGE_INTEGER      MinimumSize,
    IN  ULONG              CreationSizeMB,
    IN  REGION_TYPE        Type,
    OUT PLARGE_INTEGER     CreationStart,
    OUT PLARGE_INTEGER     CreationSize
    )

/*++

Routine Description:

    Determine the actual offset and size of the partition, given the
    size in megabytes.

Arguments:

    Region  - a region descriptor returned by GetDiskRegions().  Must
              be an unused region.

    MinimumSize - if non-0, this is the minimum size that the partition
        or logical drive can be.

    CreationSizeMB - If MinimumSize is 0, size of partition to create, in MB.

    Type    - REGION_PRIMARY, REGION_EXTENDED, or REGION_LOGICAL, for
              creating a primary partition, extended partition, or
              logical volume, respectively.

    CreationStart - receives the offset where the partition should be placed.

    CreationSize - receives the exact size for the partition.

Return Value:

    None.

--*/

{
    PREGION_DATA  createData = Region->Reserved;
    ULONG         bpc = DiskGeometryArray[Region->Disk].BytesPerCylinder;
    ULONG         bpt = DiskGeometryArray[Region->Disk].BytesPerTrack;
    LARGE_INTEGER cSize,
                  cStart,
                  mod;

    //
    // If we are creating a partition at offset 0, adjust the aligned region
    // offset and the aligned region size, because no partition can actually
    // start at offset 0.
    //

    if (!createData->AlignedRegionOffset.QuadPart) {

        LARGE_INTEGER delta;

        if (Type == REGION_EXTENDED) {
            delta.QuadPart = bpc;
        } else {
            delta.QuadPart = bpt;
        }

        createData->AlignedRegionOffset = delta;
        createData->AlignedRegionSize.QuadPart -= delta.QuadPart;
    }

    cStart = createData->AlignedRegionOffset;
    if (!MinimumSize.QuadPart) {
        cSize.QuadPart = UInt32x32To64(CreationSizeMB, ONE_MEG);
    } else {
        cSize = MinimumSize;
        if (Type == REGION_LOGICAL) {
            cSize.QuadPart += bpt;
        }
    }

    //
    // Decide whether to align the ending cylinder up or down.
    // If the offset of end of the partition is more than half way into the
    // final cylinder, align towrds the disk end.  Otherwise align toward
    // the disk start.
    //

    mod.QuadPart = (cStart.QuadPart + cSize.QuadPart) % bpc;
    if (mod.QuadPart) {

        if ((MinimumSize.QuadPart) || (mod.QuadPart > (bpc/2))) {
            cSize.QuadPart += ((LONGLONG)bpc - mod.QuadPart);
        } else {
            cSize.QuadPart -= mod.QuadPart;  // snap downwards to cyl boundary
        }
    }

    if (cSize.QuadPart > createData->AlignedRegionSize.QuadPart) {

        //
        // Space available in the free space isn't large enough to accomodate
        // the request;  just use the entire free space.
        //

        cSize  = createData->AlignedRegionSize;
    }

    *CreationStart = cStart;
    *CreationSize  = cSize;
}


STATUS_CODE
CreatePartitionEx(
    IN PREGION_DESCRIPTOR Region,
    IN LARGE_INTEGER      MinimumSize,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        Type,
    IN UCHAR              SysId
    )

/*++

Routine Description:

    This routine creates a partition from a free region on the disk.  The
    partition is always created at the beginning of the free space, and any
    left over space at the end is kept on the free space list.

Arguments:

    Region  - a region descriptor returned by GetDiskRegions().  Must
              be an unused region.

    CreationSizeMB - size of partition to create, in MB.

    Type    - REGION_PRIMARY, REGION_EXTENDED, or REGION_LOGICAL, for
              creating a primary partition, extended pasrtition, or
              logical volume, respectively.

    SysId - system ID byte to be assigned to the partition

Return Value:

    OK_STATUS or error code.

--*/

{
    PPARTITION    p1,
                  p2,
                  p3;
    PREGION_DATA  createData = Region->Reserved;
    LARGE_INTEGER creationStart,
                  creationSize,
                  leftOver,
                  offset,
                  length;
    PPARTITION   *partitionList;

    DetermineCreateSizeAndOffset(Region,
                                 MinimumSize,
                                 CreationSizeMB,
                                 Type,
                                 &creationStart,
                                 &creationSize);

    // now we've got the start and size of the partition to be created.
    // If there's left-over at the beginning of the free space (after
    // alignment), make a new PARTITION structure.

    p1 = NULL;
    offset = createData->Partition->Offset;
    length = createData->Partition->Length;
    leftOver.QuadPart = creationStart.QuadPart - offset.QuadPart;

    if (leftOver.QuadPart > 0) {

        p1 = AllocatePartitionStructure(Region->Disk,
                                        createData->Partition->Offset,
                                        leftOver,
                                        SYSID_UNUSED,
                                        FALSE,
                                        FALSE,
                                        FALSE);
        if (p1 == NULL) {
            RETURN_OUT_OF_MEMORY;
        }
    }

    // make a new partition structure for space being left free as
    // a result of this creation.

    p2 = NULL;
    leftOver.QuadPart = (offset.QuadPart + length.QuadPart) -
                        (creationStart.QuadPart + creationSize.QuadPart);

    if (leftOver.QuadPart) {
        LARGE_INTEGER temp;

        temp.QuadPart = creationStart.QuadPart + creationSize.QuadPart;
        p2 = AllocatePartitionStructure(Region->Disk,
                                        temp,
                                        leftOver,
                                        SYSID_UNUSED,
                                        FALSE,
                                        FALSE,
                                        FALSE);
        if (p2 == NULL) {
            RETURN_OUT_OF_MEMORY;
        }
    }

    // adjust the free partition's fields.

    createData->Partition->Offset = creationStart;
    createData->Partition->Length = creationSize;
    createData->Partition->SysID  = SysId;
    createData->Partition->Update = TRUE;
    createData->Partition->Recognized = TRUE;

    // if we just created an extended partition, show the whole thing
    // as one free logical region.

    if (Type == REGION_EXTENDED) {

        p3 = AllocatePartitionStructure(Region->Disk,
                                        creationStart,
                                        creationSize,
                                        SYSID_UNUSED,
                                        FALSE,
                                        FALSE,
                                        FALSE);
        if (p3 == NULL) {
            RETURN_OUT_OF_MEMORY;
        }
        AddPartitionToLinkedList(&LogicalVolumes[Region->Disk], p3);
    }

    partitionList = (Type == REGION_LOGICAL)
                  ? &LogicalVolumes[Region->Disk]
                  : &PrimaryPartitions[Region->Disk];

    if (p1) {
        AddPartitionToLinkedList(partitionList, p1);
    }
    if (p2) {
        AddPartitionToLinkedList(partitionList, p2);
    }

    MergeFreePartitions(*partitionList);
    ChangesRequested[Region->Disk] = TRUE;
    return(OK_STATUS);
}


STATUS_CODE
CreatePartition(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        Type
    )
/*++

Routine Description:

    Create a partition.

Arguments:

    Region - A region descriptor pointer.
    CreationSizeMB - the size for the new region.
    Type - the type of region being created.

Return Value:

    OK_STATUS or error code

--*/

{
    LARGE_INTEGER zero;

    zero.QuadPart = 0;
    return CreatePartitionEx(Region,
                             zero,
                             CreationSizeMB,
                             Type,
                             (UCHAR)((Type == REGION_EXTENDED) ? SYSID_EXTENDED
                                                               : SYSID_BIGFAT));
}


STATUS_CODE
DeletePartition(
    IN PREGION_DESCRIPTOR Region
    )

/*++

Routine Description:

    This routine deletes a partition, returning its space to the
    free space on the disk.  If deleting the extended partition,
    all logical volumes within it are also deleted.

Arguments:

    Region  - a region descriptor returned by GetDiskRegions().  Must
              be a used region.

Return Value:

    OK_STATUS or error code.

--*/

{
    PREGION_DATA  RegionData = Region->Reserved;
    PPARTITION   *PartitionList;

    if(IsExtended(Region->SysID)) {

        // Deleting extended partition.  Also delete all logical volumes.

        FreeLinkedPartitionList(&LogicalVolumes[Region->Disk]);
    }

    RegionData->Partition->SysID  = SYSID_UNUSED;
    RegionData->Partition->Update = TRUE;
    RegionData->Partition->Active = FALSE;
    RegionData->Partition->OriginalPartitionNumber = 0;

    PartitionList = (Region->RegionType == REGION_LOGICAL)
                  ? &LogicalVolumes[Region->Disk]
                  : &PrimaryPartitions[Region->Disk];

    MergeFreePartitions(*PartitionList);
    ChangesRequested[Region->Disk] = TRUE;
    return OK_STATUS;
}


STATUS_CODE
GetDiskRegions(
    IN  ULONG               Disk,
    IN  BOOLEAN             WantUsedRegions,
    IN  BOOLEAN             WantFreeRegions,
    IN  BOOLEAN             WantPrimaryRegions,
    IN  BOOLEAN             WantLogicalRegions,
    OUT PREGION_DESCRIPTOR *Region,
    OUT ULONG              *RegionCount
    )

/*++

Routine Description:

    This routine returns an array of region descriptors to the caller.
    A region desscriptor describes a space on the disk, either used
    or free.  The caller can control which type of regions are returned.

    The caller must free the returned array via FreeRegionArray().

Arguments:

    Disk            - index of disk whose regions are to be returned

    WantUsedRegions - whether to return used disk regions

    WantFreeRegions - whether to return free disk regions

    WantPrimaryRegions - whether to return regions not in the
                         extended partition

    WantLogicalRegions - whether to return regions within the
                         extended partition

    Region          - where to put a pointer to the array of regions

    RegionCount     - where to put the number of items in the returned
                      Region array

Return Value:

    OK_STATUS or error code.

--*/

{
    *Region = AllocateMemory(0);
    *RegionCount = 0;

    if (WantPrimaryRegions) {
        return GetRegions(Disk,
                          PrimaryPartitions[Disk],
                          WantUsedRegions,
                          WantFreeRegions,
                          WantLogicalRegions,
                          Region,
                          RegionCount,
                          REGION_PRIMARY);
    } else if (WantLogicalRegions) {
        return GetRegions(Disk,
                          LogicalVolumes[Disk],
                          WantUsedRegions,
                          WantFreeRegions,
                          FALSE,
                          Region,
                          RegionCount,
                          REGION_LOGICAL);
    }
    return OK_STATUS;
}


// workers for GetDiskRegions

STATUS_CODE
GetRegions(
    IN  ULONG               Disk,
    IN  PPARTITION          p,
    IN  BOOLEAN             WantUsedRegions,
    IN  BOOLEAN             WantFreeRegions,
    IN  BOOLEAN             WantLogicalRegions,
    OUT PREGION_DESCRIPTOR *Region,
    OUT ULONG              *RegionCount,
    IN  REGION_TYPE         RegionType
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    STATUS_CODE   status;
    LARGE_INTEGER alignedOffset,
                  alignedSize,
                  temp;
    ULONG         sizeMB;

    while (p) {

        if (p->SysID == SYSID_UNUSED) {

            if (WantFreeRegions) {

                alignedOffset = AlignTowardsDiskEnd(p->Disk,p->Offset);
                temp.QuadPart = p->Offset.QuadPart + p->Length.QuadPart;
                temp = AlignTowardsDiskStart(p->Disk, temp);
                alignedSize.QuadPart = temp.QuadPart - alignedOffset.QuadPart;
                sizeMB        = SIZEMB(alignedSize);

                // Show the space free if it is greater than 1 meg, AND
                // it is not a space starting at the beginning of the disk
                // and of length <= 1 cylinder.
                // This prevents the user from seeing the first cylinder
                // of the disk as free (could otherwise happen with an
                // extended partition starting on cylinder 1 and cylinders
                // of 1 megabyte or larger).

                if ((alignedSize.QuadPart > 0) && sizeMB &&
                    ((p->Offset.QuadPart) ||
                      (p->Length.QuadPart > (DiskGeometryArray[p->Disk].BytesPerCylinder)))) {
                    if (!AddRegionEntry(Region,
                                        RegionCount,
                                        sizeMB,
                                        RegionType,
                                        p,
                                        alignedOffset,
                                        alignedSize)) {
                        RETURN_OUT_OF_MEMORY;
                    }
                }
            }
        } else {

            if (WantUsedRegions) {

                alignedOffset = p->Offset;
                alignedSize   = p->Length;
                sizeMB        = SIZEMB(alignedSize);

                if (!AddRegionEntry(Region,
                                    RegionCount,
                                    sizeMB,
                                    RegionType,
                                    p,
                                    alignedOffset,
                                    alignedSize)) {
                    RETURN_OUT_OF_MEMORY;
                }
            }

            if (IsExtended(p->SysID) && WantLogicalRegions) {
                status = GetRegions(Disk,
                                    LogicalVolumes[Disk],
                                    WantUsedRegions,
                                    WantFreeRegions,
                                    FALSE,
                                    Region,
                                    RegionCount,
                                    REGION_LOGICAL);
                if (status != OK_STATUS) {
                    return status;
                }
            }
        }
        p = p->Next;
    }
    return OK_STATUS;
}


BOOLEAN
AddRegionEntry(
    OUT PREGION_DESCRIPTOR *Regions,
    OUT ULONG              *RegionCount,
    IN  ULONG               SizeMB,
    IN  REGION_TYPE         RegionType,
    IN  PPARTITION          Partition,
    IN  LARGE_INTEGER       AlignedRegionOffset,
    IN  LARGE_INTEGER       AlignedRegionSize
    )

/*++

Routine Description:

    Allocate space for the region descriptor and copy the provided data.

Arguments:

    Regions - return the pointer to the new region
    RegionCount - number of regions on the disk so far
    SizeMB - size of the region
    RegionType - type of the region
    Partition - partition structure with other related information
    AlignedRegionOffset - region starting location
    AlignedRegionSize - region size.

Return Value:

    TRUE - The region was added successfully
    FALSE - it wasn't

--*/

{
    PREGION_DESCRIPTOR regionDescriptor;
    PREGION_DATA       regionData;

    regionDescriptor = ReallocateMemory(*Regions,(((*RegionCount) + 1) * sizeof(REGION_DESCRIPTOR)) + 20);
    if (regionDescriptor == NULL) {
        return FALSE;
    } else {
        *Regions = regionDescriptor;
        (*RegionCount)++;
    }

    regionDescriptor = &(*Regions)[(*RegionCount)-1];

    if (!(regionDescriptor->Reserved = AllocateMemory(sizeof(REGION_DATA)))) {
        return FALSE;
    }

    regionDescriptor->Disk                    = Partition->Disk;
    regionDescriptor->SysID                   = Partition->SysID;
    regionDescriptor->SizeMB                  = SizeMB;
    regionDescriptor->Active                  = Partition->Active;
    regionDescriptor->Recognized              = Partition->Recognized;
    regionDescriptor->PartitionNumber         = Partition->PartitionNumber;
    regionDescriptor->OriginalPartitionNumber = Partition->OriginalPartitionNumber;
    regionDescriptor->RegionType              = RegionType;
    regionDescriptor->PersistentData          = Partition->PersistentData;

    regionData = regionDescriptor->Reserved;

    regionData->Partition             = Partition;
    regionData->AlignedRegionOffset   = AlignedRegionOffset;
    regionData->AlignedRegionSize     = AlignedRegionSize;

    return TRUE;
}


VOID
FreeRegionArray(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              RegionCount
    )

/*++

Routine Description:

    This routine frees a region array returned by GetDiskRegions().

Arguments:

    Region          - pointer to the array of regions to be freed

    RegionCount     - number of items in the Region array

Return Value:

    None.

--*/

{
    ULONG i;

    for (i = 0; i < RegionCount; i++) {

        if (Region[i].Reserved) {
            FreeMemory(Region[i].Reserved);
        }
    }
    FreeMemory(Region);
}


VOID
AddPartitionToLinkedList(
    IN OUT PARTITION **Head,
    IN     PARTITION *p
    )

/*++

Routine Description:

    This routine adds a PARTITION structure to a doubly-linked
    list, sorted by the Offset field in ascending order.

Arguments:

    Head    - pointer to pointer to first element in list
    p       - pointer to item to be added to list

Return Value:

    None.

--*/

{
    PARTITION *cur,
              *prev;

    if ((cur = *Head) == NULL) {
        *Head = p;
        return;
    }

    if (p->Offset.QuadPart < cur->Offset.QuadPart) {
        p->Next = cur;
        cur->Prev = p;
        *Head = p;
        return;
    }

    prev = *Head;
    cur = cur->Next;

    while (cur) {
        if (p->Offset.QuadPart < cur->Offset.QuadPart) {

            p->Next = cur;
            p->Prev = prev;
            prev->Next = p;
            cur->Prev = p;
            return;
        }
        prev = cur;
        cur = cur->Next;
    }

    prev->Next = p;
    p->Prev = prev;
    return;
}


BOOLEAN
IsInLinkedList(
    IN PPARTITION p,
    IN PPARTITION List
    )

/*++

Routine Description:

    This routine determines whether a PARTITION element is in
    a given linked list of PARTITION elements.

Arguments:

    p       - pointer to element to be checked for
    List    - first element in list to be scanned

Return Value:

    true if p found in List, false otherwise

--*/

{
    while (List) {
        if (p == List) {
            return TRUE;
        }
        List = List->Next;
    }
    return FALSE;
}


BOOLEAN
IsInLogicalList(
    IN ULONG      Disk,
    IN PPARTITION p
    )

/*++

Routine Description:

    This routine determines whether a PARTITION element is in
    the logical volume list for a given disk.

Arguments:

    Disk    - index of disk to be checked
    p       - pointer to element to be checked for

Return Value:

    true if p found in Disk's logical volume list, false otherwise

--*/

{
    return IsInLinkedList(p, LogicalVolumes[Disk]);
}


BOOLEAN
IsInPartitionList(
    IN ULONG      Disk,
    IN PPARTITION p
    )

/*++

Routine Description:

    This routine determines whether a PARTITION element is in
    the primary partition list for a given disk.

Arguments:

    Disk    - index of disk to be checked
    p       - pointer to element to be checked for

Return Value:

    true if p found in Disk's primary partition list, false otherwise

--*/

{
    return IsInLinkedList(p, PrimaryPartitions[Disk]);
}


VOID
MergeFreePartitions(
    IN PPARTITION p
    )

/*++

Routine Description:

    This routine merges adjacent free space elements in the
    given linked list of PARTITION elements.  It is designed
    to be called after adding or deleting a partition.

Arguments:

    p - pointer to first item in list whose free elements are to
        be merged.

Return Value:

    None.

--*/

{
    PPARTITION next;

    while (p && p->Next) {

        if ((p->SysID == SYSID_UNUSED) && (p->Next->SysID == SYSID_UNUSED)) {

            next = p->Next;
            p->Length.QuadPart = (next->Offset.QuadPart + next->Length.QuadPart) - p->Offset.QuadPart;

            if (p->Next = next->Next) {
                next->Next->Prev = p;
            }

            FreeMemory(next);

        } else {
            p = p->Next;
        }
    }
}


PPARTITION
FindPartitionElement(
    IN ULONG Disk,
    IN ULONG Partition
    )

/*++

Routine Description:

    This routine locates a PARTITION element for a disk/partition
    number pair.  The partition number is the number that the
    system assigns to the partition.

Arguments:

    Disk - index of relevent disk

    Partition - partition number of partition to find

Return Value:

    pointer to PARTITION element, or NULL if not found.

--*/

{
    PPARTITION p;

    p = PrimaryPartitions[Disk];
    while (p) {
        if ((p->SysID != SYSID_UNUSED) && !IsExtended(p->SysID) && (p->PartitionNumber == Partition)) {
            return p;
        }
        p = p->Next;
    }
    p = LogicalVolumes[Disk];
    while (p) {
        if ((p->SysID != SYSID_UNUSED) && (p->PartitionNumber == Partition)) {
            return p;
        }
        p = p->Next;
    }
    return NULL;
}


VOID
SetSysID(
    IN ULONG Disk,
    IN ULONG Partition,
    IN UCHAR SysID
    )

/*++

Routine Description:

    This routine sets the system id of the given partition
    on the given disk.

Arguments:

    Disk - index of relevent disk

    Partition - partition number of relevent partition

    SysID - new system ID for Partition on Disk

Return Value:

    None.

--*/

{
    PPARTITION p = FindPartitionElement(Disk,Partition);

    if (p) {
        p->SysID = SysID;
        if (!p->Update) {
            p->Update = CHANGED_DONT_ZAP;
        }
        ChangesRequested[p->Disk] = TRUE;
    }
}


VOID
SetSysID2(
    IN PREGION_DESCRIPTOR Region,
    IN UCHAR              SysID
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PPARTITION p = ((PREGION_DATA)(Region->Reserved))->Partition;

    p->SysID = SysID;
    if (!p->Update) {
        p->Update = CHANGED_DONT_ZAP;
    }
    ChangesRequested[p->Disk] = TRUE;
}


VOID
FreeLinkedPartitionList(
    IN OUT PPARTITION *q
    )

/*++

Routine Description:

    This routine frees a linked list of PARTITION elements. The head
    pointer is set to NULL.

Arguments:

    p - pointer to pointer to first element of list to free.

Return Value:

    None.

--*/

{
    PARTITION *n;
    PARTITION *p = *q;

    while(p) {
        n = p->Next;
        FreeMemory(p);
        p = n;
    }
    *q = NULL;
}


VOID
FreePartitionInfoLinkedLists(
    IN PPARTITION *ListHeadArray
    )

/*++

Routine Description:

    This routine frees the linked lists of PARTITION elements
    for each disk.

Arguments:

    ListHeadArray - pointer to array of pointers to first elements of
                    PARTITION element lists.

Return Value:

    None.

--*/

{
    ULONG i;

    for (i = 0; i < CountOfDisks; i++) {

        FreeLinkedPartitionList(&ListHeadArray[i]);
    }
}


PPARTITION
AllocatePartitionStructure(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length,
    IN UCHAR         SysID,
    IN BOOLEAN       Update,
    IN BOOLEAN       Active,
    IN BOOLEAN       Recognized
    )

/*++

Routine Description:

    This routine allocates space for, and initializes a PARTITION
    structure.

Arguments:

    Disk    - index of disk, one of whose regions the new PARTITION
              strucure describes.
    Offset  - byte offset of region on the disk
    Length  - length in bytes of the region
    SysID   - system id of region, of SYSID_UNUSED of this PARTITION
              is actually a free space.
    Update  - whether this PARTITION is dirty, ie, has changed and needs
              to be written to disk.
    Active  - flag for the BootIndicator field in a partition table entry,
              indicates to the x86 master boot program which partition
              is active.
    Recognized - whether the partition is a type recognized by NT

Return Value:

    NULL if allocation failed, or new initialized PARTITION strucure.

--*/

{
    PPARTITION p = AllocateMemory(sizeof(PARTITION));

    if (p) {
        p->Next                    = NULL;
        p->Prev                    = NULL;
        p->Offset                  = Offset;
        p->Length                  = Length;
        p->Disk                    = Disk;
        p->Update                  = Update;
        p->Active                  = Active;
        p->Recognized              = Recognized;
        p->SysID                   = SysID;
        p->OriginalPartitionNumber = 0;
        p->PartitionNumber         = 0;
        p->PersistentData          = 0;
        p->CommitMirrorBreakNeeded = FALSE;
    }
    return(p);
}


STATUS_CODE
InitializeFreeSpace(
    IN ULONG             Disk,
    IN PPARTITION       *PartitionList,      // list the free space goes in
    IN LARGE_INTEGER     StartOffset,
    IN LARGE_INTEGER     Length
    )

/*++

Routine Description:

    This routine determines all the free spaces within a given area
    on a disk, allocates PARTITION structures to describe them,
    and adds these structures to the relevent partition list
    (primary partitions or logical volumes).

    No rounding or alignment is performed here.  Spaces of even one
    byte will be counted and inserted in the partition list.

Arguments:

    Disk    - index of disk whose free spaces are being sought.

    PartitionList - pointer to first element on PARTITION list that
                    the free spaces will go in.

    StartOffset - start offset of area on disk to consider (ie, 0 for
                  primary spaces or the first byte of the extended
                  partition for logical spaces).

    Length - length of area on disk to consider (ie, size of disk
             for primary spaces or size of extended partition for
             logical spaces).

Return Value:

    OK_STATUS or error code.

--*/

{
    PPARTITION    p = *PartitionList,
                  q;
    LARGE_INTEGER start,
                  size;

    start = StartOffset;
    while (p) {

        size.QuadPart = p->Offset.QuadPart - start.QuadPart;
        if (size.QuadPart > 0) {
            if (!(q = AllocatePartitionStructure(Disk,
                                                 start,
                                                 size,
                                                 SYSID_UNUSED,
                                                 FALSE,
                                                 FALSE,
                                                 FALSE))) {
                RETURN_OUT_OF_MEMORY;
            }

            AddPartitionToLinkedList(PartitionList, q);
        }

        start.QuadPart = p->Offset.QuadPart + p->Length.QuadPart;
        p = p->Next;
    }

    size.QuadPart = (StartOffset.QuadPart + Length.QuadPart) - start.QuadPart;
    if (size.QuadPart > 0) {

        if (!(q = AllocatePartitionStructure(Disk,
                                             start,
                                             size,
                                             SYSID_UNUSED,
                                             FALSE,
                                             FALSE,
                                             FALSE))) {
            RETURN_OUT_OF_MEMORY;
        }

        AddPartitionToLinkedList(PartitionList, q);
    }

    return OK_STATUS;
}


STATUS_CODE
InitializeLogicalVolumeList(
    IN ULONG                      Disk,
    IN PDRIVE_LAYOUT_INFORMATION  DriveLayout
    )

/*++

Routine Description:

    This routine creates the logical volume linked list of
    PARTITION structures for the given disk.

Arguments:

    Disk    - index of disk

    DriveLayout - pointer to structure describing the raw partition
                  layout of the disk.

Return Value:

    OK_STATUS or error code.

--*/

{
    PPARTITION             p,
                           q;
    ULONG                  i,
                           j;
    PPARTITION_INFORMATION d;
    LARGE_INTEGER          HiddenBytes;
    ULONG                  BytesPerSector = DiskGeometryArray[Disk].BytesPerSector;

    FreeLinkedPartitionList(&LogicalVolumes[Disk]);

    p = PrimaryPartitions[Disk];
    while (p) {
        if (IsExtended(p->SysID)) {
            break;
        }
        p = p->Next;
    }

    if (p) {
        for (i=ENTRIES_PER_BOOTSECTOR; i<DriveLayout->PartitionCount; i+=ENTRIES_PER_BOOTSECTOR) {

            for (j=i; j<i+ENTRIES_PER_BOOTSECTOR; j++) {

                d = &DriveLayout->PartitionEntry[j];

                if ((d->PartitionType != SYSID_UNUSED) && (d->PartitionType != SYSID_EXTENDED)) {
                    LARGE_INTEGER t1,
                                  t2;

                    HiddenBytes.QuadPart = (LONGLONG)d->HiddenSectors * (LONGLONG)BytesPerSector;

                    t1.QuadPart = d->StartingOffset.QuadPart - HiddenBytes.QuadPart;
                    t2.QuadPart = d->PartitionLength.QuadPart + HiddenBytes.QuadPart;
                    if (!(q = AllocatePartitionStructure(Disk,
                                                        t1,
                                                        t2,
                                                        d->PartitionType,
                                                        FALSE,
                                                        d->BootIndicator,
                                                        d->RecognizedPartition))) {
                        RETURN_OUT_OF_MEMORY;
                    }

                    q->PartitionNumber =
                        q->OriginalPartitionNumber = d->PartitionNumber;
                    AddPartitionToLinkedList(&LogicalVolumes[Disk],q);

                    break;
                }
            }
        }
        return InitializeFreeSpace(Disk,
                                   &LogicalVolumes[Disk],
                                   p->Offset,
                                   p->Length);
    }
    return OK_STATUS;
}


STATUS_CODE
InitializePrimaryPartitionList(
    IN  ULONG                     Disk,
    IN  PDRIVE_LAYOUT_INFORMATION DriveLayout
    )

/*++

Routine Description:

    This routine creates the primary partition linked list of
    PARTITION structures for the given disk.

Arguments:

    Disk    - index of disk

    DriveLayout - pointer to structure describing the raw partition
                  layout of the disk.

Return Value:

    OK_STATUS or error code.

--*/

{
    LARGE_INTEGER          zero;
    ULONG                  i;
    PPARTITION             p;
    PPARTITION_INFORMATION d;

    zero.QuadPart = 0;
    FreeLinkedPartitionList(&PrimaryPartitions[Disk]);

    if (DriveLayout->PartitionCount >= ENTRIES_PER_BOOTSECTOR) {

        for (i=0; i<ENTRIES_PER_BOOTSECTOR; i++) {

            d = &DriveLayout->PartitionEntry[i];

            if (d->PartitionType != SYSID_UNUSED) {

                if (!(p = AllocatePartitionStructure(Disk,
                                                     d->StartingOffset,
                                                     d->PartitionLength,
                                                     d->PartitionType,
                                                     FALSE,
                                                     d->BootIndicator,
                                                     d->RecognizedPartition))) {
                    RETURN_OUT_OF_MEMORY;
                }

                p->PartitionNumber =
                    p->OriginalPartitionNumber = IsExtended(p->SysID)
                                                 ? 0
                                                 : d->PartitionNumber;

                AddPartitionToLinkedList(&PrimaryPartitions[Disk],p);
            }
        }
    }
    return InitializeFreeSpace(Disk,
                               &PrimaryPartitions[Disk],
                               zero,
                               DiskLengthBytes(Disk));
}


VOID
ReconcilePartitionNumbers(
    ULONG Disk,
    PDRIVE_LAYOUT_INFORMATION DriveLayout
    )

/*++

Routine Description:

    With dynamic partitioning, the partitions on the disk will no longer
    follow sequencial numbering schemes.  It will be possible for a disk
    to have a partition #1 that is the last partition on the disk and a
    partition #3 that is the first.  This routine runs through the NT
    namespace for harddisks to resolve this inconsistency.

    This routine has the problem that it will not locate partitions that
    are part of an FT set because the partition information for these
    partitions will be modified to reflect the size of the set, not the
    size of the partition.

Arguments:

    Disk - the disk number
    DriveLayout - the partitioning information

Return Value:

    None

--*/

{
#define BUFFERSIZE 1024
    NTSTATUS                      status;
    IO_STATUS_BLOCK               statusBlock;
    HANDLE                        directoryHandle,
                                  partitionHandle;
    CLONG                         continueProcessing;
    ULONG                         context = 0,
                                  returnedLength,
                                  index;
    POBJECT_DIRECTORY_INFORMATION dirInfo;
    PARTITION_INFORMATION         partitionInfo;
    PPARTITION_INFORMATION        partitionInfoPtr;
    OBJECT_ATTRIBUTES             attributes;
    UNICODE_STRING                unicodeString;
    ANSI_STRING                   ansiName;
    PUCHAR                        deviceName;
    PUCHAR                        buffer;

    deviceName = Malloc(100);
    if (!deviceName) {
        return;
    }

    buffer = Malloc(BUFFERSIZE);
    if (!buffer) {
        Free(deviceName);
        return;
    }

    sprintf(deviceName, "\\Device\\Harddisk%d", Disk);
    RtlInitAnsiString(&ansiName, deviceName);
    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiName, TRUE);

    if (!NT_SUCCESS(status)) {
        Free(deviceName);
        Free(buffer);
        return;
    }
    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    status = NtOpenDirectoryObject(&directoryHandle,
                                   DIRECTORY_QUERY,
                                   &attributes);
    if (!NT_SUCCESS(status)) {

        Free(deviceName);
        Free(buffer);
        return;
    }

    //  Query the entire directory in one sweep

    continueProcessing = 1;
    while (continueProcessing) {
        RtlZeroMemory(buffer, BUFFERSIZE);
        status = NtQueryDirectoryObject(directoryHandle,
                                        buffer,
                                        BUFFERSIZE,
                                        FALSE,
                                        FALSE,
                                        &context,
                                        &returnedLength);

        //  Check the status of the operation.

        if (!NT_SUCCESS(status)) {
            if (status != STATUS_NO_MORE_FILES) {
                break;
            }
            continueProcessing = 0;
        }

        //  For every record in the buffer check for partition name


        for (dirInfo = (POBJECT_DIRECTORY_INFORMATION) buffer;
             TRUE;
             dirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) dirInfo) +
                          sizeof(OBJECT_DIRECTORY_INFORMATION))) {

            //  Check if there is another record.  If there isn't, then get out
            //  of the loop now

            if (dirInfo->Name.Length == 0) {
                break;
            }

            // compare the name to see if it is a Partition

            if (!_wcsnicmp(dirInfo->Name.Buffer, L"Partition", 9)) {
                UCHAR digits[3];
                ULONG partitionNumber;

                // Located a partition.  This restricts the # of partitions
                // to 99.

                digits[0] = (UCHAR) dirInfo->Name.Buffer[9];
                digits[1] = (UCHAR) dirInfo->Name.Buffer[10];
                digits[2] = 0;
                partitionNumber = atoi(digits);

                if (partitionNumber <= 0) {

                    // less than zero is really an error...
                    // partition zero is always the same.

                    continue;
                }

                // Have a numbered partition -- match it to the drive layout

                status = LowOpenPartition(deviceName, partitionNumber, &partitionHandle);
                if (!NT_SUCCESS(status)) {

                    // If it cannot be opened perhaps it isn't really a partition

                    continue;
                }

                status = NtDeviceIoControlFile(partitionHandle,
                                               0,
                                               NULL,
                                               NULL,
                                               &statusBlock,
                                               IOCTL_DISK_GET_PARTITION_INFO,
                                               NULL,
                                               0,
                                               &partitionInfo,
                                               sizeof(PARTITION_INFORMATION));

               if (!NT_SUCCESS(status)) {
                   LowCloseDisk(partitionHandle);
                   continue;
               }

               // match partition information with drive layout.

               for (index = 0; index < DriveLayout->PartitionCount; index++) {

                   partitionInfoPtr = &DriveLayout->PartitionEntry[index];
                   if ((partitionInfoPtr->StartingOffset.QuadPart == partitionInfo.StartingOffset.QuadPart) &&
                       (partitionInfoPtr->PartitionLength.QuadPart == partitionInfo.PartitionLength.QuadPart)) {

                       // This is a match.

                       partitionInfoPtr->PartitionNumber = partitionNumber;
                       break;
                   }
               }
               LowCloseDisk(partitionHandle);
            }

        }
    }

    //  Now close the directory object

    Free(deviceName);
    Free(buffer);
    (VOID) NtClose(directoryHandle);
    return;
}


VOID
CheckForOldDrivers(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine determines if an old release 3.1 drive is in the
    system.  If so, it calculates the partition number for each region
    on a disk.  For a used region, the partition number is the number
    that the system will assign to the partition.  All partitions
    (except the extended partition) are numbered first starting at 1,
    and then all logical volumes in the extended partition.
    For a free region, the partition number is the number that the
    system WOULD assign to the partition if the space were to be
    converted to a partition and all other regions on the disk were
    left as is.

    The partition numbers are stored in the PARTITION elements.

Arguments:

    Disk - index of disk whose partitions are to be renumbered.

Return Value:

    None.

--*/

{
    PPARTITION p = PrimaryPartitions[Disk];
    ULONG      n = 1;

    while (p) {
        if (p->SysID != SYSID_UNUSED) {
            if ((!IsExtended(p->SysID)) && (IsRecognizedPartition(p->SysID))) {

                // If there is already a partition number, nothing need be
                // done here.

                if (p->PartitionNumber) {
                    return;
                } else {
                    RestartRequired = TRUE;
                }
                p->PartitionNumber = n;
                if (p->SysID != SYSID_UNUSED) {
                    n++;
                }
            }
        }
        p = p->Next;
    }
    p = LogicalVolumes[Disk];
    while (p) {
        if (p->SysID != SYSID_UNUSED) {
            if (p->PartitionNumber) {
                return;
            } else {
                RestartRequired = TRUE;
            }
            p->PartitionNumber = n;
            n++;
        }
        p = p->Next;
    }
}


STATUS_CODE
InitializePartitionLists(
    VOID
    )

/*++

Routine Description:

    This routine scans the PARTITION_INFO array returned for each disk
    by the OS.  A linked list of PARTITION structures is layered on top
    of each array;  the net result is a sorted list that covers an entire
    disk, because free spaces are also factored in as 'dummy' partitions.

Arguments:

    None.

Return Value:

    OK_STATUS or error code.

--*/

{
    STATUS_CODE               status;
    ULONG                     disk;
    PDRIVE_LAYOUT_INFORMATION driveLayout;

    for (disk = 0; disk < CountOfDisks; disk++) {

        if (OffLine[disk]) {
            continue;
        }

        if ((status = LowGetDiskLayout(DiskNames[disk], &driveLayout)) != OK_STATUS) {
            return status;
        }

        // ReconcilePartitionNumbers(disk, driveLayout);

        if ((status = InitializePrimaryPartitionList(disk, driveLayout)) == OK_STATUS) {
            status = InitializeLogicalVolumeList(disk, driveLayout);
        }
        if (status != OK_STATUS) {
            FreeMemory(driveLayout);
            return status;
        }

        Signatures[disk] = driveLayout->Signature;
        FreeMemory(driveLayout);
        CheckForOldDrivers(disk);
    }
    return OK_STATUS;
}


LARGE_INTEGER
DiskLengthBytes(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine determines the disk length in bytes.  This value
    is calculated from the disk geometry information.

Arguments:

    Disk - index of disk whose size is desired

Return Value:

    Size of Disk.

--*/

{
    LARGE_INTEGER result;

    result.QuadPart = DiskGeometryArray[Disk].Cylinders.QuadPart *
                      DiskGeometryArray[Disk].BytesPerCylinder;
    return result;
}


ULONG
SIZEMB(
    IN LARGE_INTEGER ByteCount
    )

/*++

Routine Description:

    Calculate the size in megabytes of a given byte count. The value is
    properly rounded (ie, not merely truncated).

    This function replaces a macro of the same name that was truncating
    instead of rounding.

Arguments:

    ByteCount - supplies number of bytes

Return Value:

    Size in MB equivalent to ByteCount.

--*/

{
    ULONG Remainder;
    ULONG SizeMB;

    SizeMB = RtlExtendedLargeIntegerDivide(ByteCount,
                                           ONE_MEG,
                                           &Remainder).LowPart;

    if (Remainder >= ONE_MEG/2) {
        SizeMB++;
    }

    return SizeMB;
}


ULONG
DiskSizeMB(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine determines the disk length in megabytes.  The returned
    value is rounded down after division by 1024*1024.

Arguments:

    Disk - index of disk whose size is desired

Return Value:

    Size of Disk.

--*/

{
    return SIZEMB(DiskLengthBytes(Disk));
}


LARGE_INTEGER
AlignTowardsDiskStart(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset
    )

/*++

Routine Description:

    This routine snaps a byte offset to a cylinder boundary, towards
    the start of the disk.

Arguments:

    Disk - index of disk whose offset is to be snapped
    Offset - byte offset to be aligned (snapped to cylinder boundary)

Return Value:

    Aligned offset.

--*/

{
    LARGE_INTEGER mod;
    LARGE_INTEGER result;

    mod.QuadPart = Offset.QuadPart % DiskGeometryArray[Disk].BytesPerCylinder;
    result.QuadPart = Offset.QuadPart - mod.QuadPart;
    return result;
}


LARGE_INTEGER
AlignTowardsDiskEnd(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset
    )

/*++

Routine Description:

    This routine snaps a byte offset to a cylinder boundary, towards
    the end of the disk.

Arguments:

    Disk - index of disk whose offset is to be snapped
    Offset - byte offset to be aligned (snapped to cylinder boundary)

Return Value:

    Aligned offset.

--*/

{
    LARGE_INTEGER mod,
                  temp;

    mod.QuadPart = Offset.QuadPart % DiskGeometryArray[Disk].BytesPerCylinder;
    if (mod.QuadPart) {

        temp.QuadPart = Offset.QuadPart + DiskGeometryArray[Disk].BytesPerCylinder;
        Offset = AlignTowardsDiskStart(Disk, temp);
    }
    return Offset;
}


BOOLEAN
IsExtended(
    IN UCHAR SysID
    )

/*++

Routine Description:

    This routine determines whether a given system id is for an
    extended type (ie, link) entry.

Arguments:

    SysID - system id to be tested.

Return Value:

    true/false based on whether SysID is for an extended type.

--*/

{
    return (BOOLEAN)(SysID == SYSID_EXTENDED);
}


STATUS_CODE
IsAnyCreationAllowed(
    IN  ULONG    Disk,
    IN  BOOLEAN  AllowMultiplePrimaries,
    OUT PBOOLEAN AnyAllowed,
    OUT PBOOLEAN PrimaryAllowed,
    OUT PBOOLEAN ExtendedAllowed,
    OUT PBOOLEAN LogicalAllowed
    )

/*++

Routine Description:

    This routine determines whether any partition may be created on a
    given disk, based on three sub-queries -- whether creation is allowed
    of a primary partition, an extended partition, or a logical volume.

Arguments:

    Disk            - index of disk to check
    AllowMultiplePrimaries - whether to allow multiple primary partitions
    AnyAllowed - returns whether any creation is allowed
    PrimaryAllowed - returns whether creation of a primary partition
                     is allowed
    ExtendedAllowed - returns whether creation of an extended partition
                      is allowed
    Logical Allowed - returns whether creation of a logical volume is allowed.

Return Value:

    OK_STATUS or error code

--*/

{
    STATUS_CODE status;

    if ((status = IsCreationOfPrimaryAllowed(Disk,AllowMultiplePrimaries,PrimaryAllowed)) != OK_STATUS) {
        return status;
    }
    if ((status = IsCreationOfExtendedAllowed(Disk,ExtendedAllowed)) != OK_STATUS) {
        return status;
    }
    if ((status = IsCreationOfLogicalAllowed(Disk,LogicalAllowed)) != OK_STATUS) {
        return status;
    }
    *AnyAllowed = (BOOLEAN)(*PrimaryAllowed || *ExtendedAllowed || *LogicalAllowed);
    return OK_STATUS;
}


STATUS_CODE
IsCreationOfPrimaryAllowed(
    IN  ULONG    Disk,
    IN  BOOLEAN  AllowMultiplePrimaries,
    OUT BOOLEAN *Allowed
    )

/*++

Routine Description:

    This routine determines whether creation of a primary partition is
    allowed.  This is true when there is a free entry in the MBR and
    there is free primary space on the disk.  If multiple primaries
    are not allowed, then there must also not exist any primary partitions
    in order for a primary creation to be allowed.

Arguments:

    Disk            - index of disk to check
    AllowMultiplePrimaries - whether existnace of primary partition
                             disallows creation of a primary partition
    Allowed - returns whether creation of a primary partition
              is allowed

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount;
    ULONG              UsedCount,
                       RecogCount,
                       i;
    STATUS_CODE        status;
    BOOLEAN            FreeSpace = FALSE;

    status = GetPrimaryDiskRegions(Disk, &Regions, &RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    for (UsedCount = RecogCount = i = 0; i<RegionCount; i++) {
        if (Regions[i].SysID == SYSID_UNUSED) {
            FreeSpace = TRUE;
        } else {
            UsedCount++;
            if (!IsExtended(Regions[i].SysID) && Regions[i].Recognized) {
                RecogCount++;
            }
        }
    }

    if ((UsedCount < ENTRIES_PER_BOOTSECTOR)
     && FreeSpace
     && (!RecogCount || AllowMultiplePrimaries)) {
        *Allowed = TRUE;
    } else {
        *Allowed = FALSE;
    }

    FreeRegionArray(Regions, RegionCount);
    return OK_STATUS;
}


STATUS_CODE
IsCreationOfExtendedAllowed(
    IN  ULONG    Disk,
    OUT BOOLEAN *Allowed
    )

/*++

Routine Description:

    This routine determines whether creation of an extended partition is
    allowed.  This is true when there is a free entry in the MBR,
    there is free primary space on the disk, and there is no existing
    extended partition.

Arguments:

    Disk            - index of disk to check

    Allowed - returns whether creation of an extended partition
              is allowed

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount;
    ULONG              UsedCount,
                       FreeCount,
                       i;
    STATUS_CODE        status;

    status = GetPrimaryDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    for (UsedCount = FreeCount = i = 0; i<RegionCount; i++) {
        if (Regions[i].SysID == SYSID_UNUSED) {

            // BUGBUG should adjust the size here and see if it's non0 first
            // (ie, take into account that the extended partition can't
            // start on cyl 0).

            FreeCount++;
        } else {
            UsedCount++;
            if (IsExtended(Regions[i].SysID)) {
                FreeRegionArray(Regions,RegionCount);
                *Allowed = FALSE;
                return OK_STATUS;
            }
        }
    }
    *Allowed = (BOOLEAN)((UsedCount < ENTRIES_PER_BOOTSECTOR) && FreeCount);
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


STATUS_CODE
IsCreationOfLogicalAllowed(
    IN  ULONG    Disk,
    OUT BOOLEAN *Allowed
    )

/*++

Routine Description:

    This routine determines whether creation of a logical volume is
    allowed.  This is true when there is an extended partition and
    free space within it.

Arguments:

    Disk            - index of disk to check

    Allowed - returns whether creation of a logical volume is allowed

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount;
    ULONG              i;
    STATUS_CODE        status;
    BOOLEAN            ExtendedExists;

    *Allowed = FALSE;

    status = DoesExtendedExist(Disk,&ExtendedExists);
    if (status != OK_STATUS) {
        return status;
    }
    if (!ExtendedExists) {
        return OK_STATUS;
    }

    status = GetLogicalDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    for (i = 0; i<RegionCount; i++) {
        if (Regions[i].SysID == SYSID_UNUSED) {
            *Allowed = TRUE;
            break;
        }
    }
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


STATUS_CODE
DoesAnyPartitionExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN AnyExists,
    OUT PBOOLEAN PrimaryExists,
    OUT PBOOLEAN ExtendedExists,
    OUT PBOOLEAN LogicalExists
    )

/*++

Routine Description:

    This routine determines whether any partition exists on a given disk.
    This is based on three sub queries: whether there are any primary or
    extended partitions, or logical volumes on the disk.

Arguments:

    Disk            - index of disk to check
    AnyExists - returns whether any partitions exist on Disk
    PrimaryExists - returns whether any primary partitions exist on Disk
    ExtendedExists - returns whether there is an extended partition on Disk
    LogicalExists - returns whether any logical volumes exist on Disk

Return Value:

    OK_STATUS or error code

--*/

{
    STATUS_CODE status;

    if ((status = DoesAnyPrimaryExist(Disk,PrimaryExists )) != OK_STATUS) {
        return status;
    }
    if ((status = DoesExtendedExist  (Disk,ExtendedExists)) != OK_STATUS) {
        return status;
    }
    if ((status = DoesAnyLogicalExist(Disk,LogicalExists )) != OK_STATUS) {
        return status;
    }
    *AnyExists = (BOOLEAN)(*PrimaryExists || *ExtendedExists || *LogicalExists);
    return OK_STATUS;
}


STATUS_CODE
DoesAnyPrimaryExist(
    IN  ULONG    Disk,
    OUT BOOLEAN *Exists
    )

/*++

Routine Description:

    This routine determines whether any non-extended primary partition exists
    on a given disk.

Arguments:

    Disk   - index of disk to check
    Exists - returns whether any primary partitions exist on Disk

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount,
                       i;
    STATUS_CODE        status;

    status = GetUsedPrimaryDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    *Exists = FALSE;

    for (i=0; i<RegionCount; i++) {
        if (!IsExtended(Regions[i].SysID)) {
            *Exists = TRUE;
            break;
        }
    }
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


STATUS_CODE
DoesExtendedExist(
    IN  ULONG    Disk,
    OUT BOOLEAN *Exists
    )

/*++

Routine Description:

    This routine determines whether an extended partition exists
    on a given disk.

Arguments:

    Disk   - index of disk to check
    Exists - returns whether an extended partition exists on Disk

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount,
                       i;
    STATUS_CODE        status;

    status = GetUsedPrimaryDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    *Exists = FALSE;

    for (i=0; i<RegionCount; i++) {
        if (IsExtended(Regions[i].SysID)) {
            *Exists = TRUE;
            break;
        }
    }
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


STATUS_CODE
DoesAnyLogicalExist(
    IN  ULONG    Disk,
    OUT BOOLEAN *Exists
    )

/*++

Routine Description:

    This routine determines whether any logical volumes exist
    on a given disk.

Arguments:

    Disk   - index of disk to check
    Exists - returns whether any logical volumes exist on Disk

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount;
    STATUS_CODE        status;

    status = GetUsedLogicalDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    *Exists = (BOOLEAN)(RegionCount != 0);
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


ULONG
GetDiskCount(
    VOID
    )

/*++

Routine Description:

    This routine returns the number of attached partitionable disk
    devices.  The returned value is one greater than the maximum index
    allowed for Disk parameters to partitioning engine routines.

Arguments:

    None.

Return Value:

    Count of disks.

--*/

{
    return CountOfDisks;
}


PCHAR
GetDiskName(
    ULONG Disk
    )

/*++

Routine Description:

    This routine returns the system name for the disk device whose
    index is given.

Arguments:

    Disk - index of disk whose name is desired.

Return Value:

    System name for the disk device.  The caller must not attempt to
    free this buffer or modify it.

--*/

{
    return DiskNames[Disk];
}


// worker routines for WriteDriveLayout

VOID
UnusedEntryFill(
    IN PPARTITION_INFORMATION pinfo,
    IN ULONG                  EntryCount
    )

/*++

Routine Description:

    Initialize a partition information structure.

Arguments:

    pinfo - the partition information structure to fill in.
    EntryCount - the number of entries in the structure to fill.

Return Value:

    None

--*/

{
    ULONG         i;
    LARGE_INTEGER zero;

    zero.QuadPart = 0;
    for (i = 0; i < EntryCount; i++) {

        pinfo[i].StartingOffset   = zero;
        pinfo[i].PartitionLength  = zero;
        pinfo[i].HiddenSectors    = 0;
        pinfo[i].PartitionType    = SYSID_UNUSED;
        pinfo[i].BootIndicator    = FALSE;
        pinfo[i].RewritePartition = TRUE;
    }
}


LARGE_INTEGER
MakeBootRec(
    ULONG                  Disk,
    PPARTITION_INFORMATION pInfo,
    PPARTITION             pLogical,
    PPARTITION             pNextLogical
    )

/*++

Routine Description:

Arguments:

    Disk - the disk number
    pinfo - the partition information for the disk.
    pLogical
    pNextLogical

Return Value:

    The starting offset.

--*/

{
    ULONG         entry = 0;
    LARGE_INTEGER bytesPerTrack;
    LARGE_INTEGER sectorsPerTrack;
    LARGE_INTEGER startingOffset;

    bytesPerTrack.QuadPart = DiskGeometryArray[Disk].BytesPerTrack;
    sectorsPerTrack.QuadPart = DiskGeometryArray[Disk].SectorsPerTrack;
    startingOffset.QuadPart = 0;

    if (pLogical) {

        pInfo[entry].StartingOffset.QuadPart = pLogical->Offset.QuadPart + bytesPerTrack.QuadPart;
        pInfo[entry].PartitionLength.QuadPart = pLogical->Length.QuadPart - bytesPerTrack.QuadPart;
        pInfo[entry].HiddenSectors    = sectorsPerTrack.LowPart;
        pInfo[entry].RewritePartition = pLogical->Update;
        pInfo[entry].BootIndicator    = pLogical->Active;
        pInfo[entry].PartitionType    = pLogical->SysID;

        if(pInfo[entry].RewritePartition) {
            startingOffset = pInfo[entry].StartingOffset;
        }

        entry++;
    }

    if (pNextLogical) {

        pInfo[entry].StartingOffset   = pNextLogical->Offset;
        pInfo[entry].PartitionLength  = pNextLogical->Length;
        pInfo[entry].HiddenSectors    = 0;
        pInfo[entry].RewritePartition = TRUE;
        pInfo[entry].BootIndicator    = FALSE;
        pInfo[entry].PartitionType    = SYSID_EXTENDED;

        entry++;
    }

    UnusedEntryFill(pInfo + entry, ENTRIES_PER_BOOTSECTOR - entry);
    return startingOffset;
}


STATUS_CODE
ZapSector(
    ULONG         Disk,
    LARGE_INTEGER Offset
    )

/*++

Routine Description:

    This routine writes zeros into a sector at a given offset.  This is
    used to clear out a new partition's filesystem boot record, so that
    no previous filesystem appears in a new partition; or to clear out the
    first EBR in the extended partition if there are to be no logical vols.

Arguments:

    Disk - disk to write to

    Offset - byte offset to a newly created partition on Disk

Return Value:

    OK_STATUS or error code.

--*/

{
    ULONG       sectorSize = DiskGeometryArray[Disk].BytesPerSector;
    ULONG       i;
    PCHAR       sectorBuffer,
                alignedSectorBuffer;
    STATUS_CODE status;
    HANDLE_T    handle;
    LARGE_INTEGER temp;

    if ((sectorBuffer = AllocateMemory(2*sectorSize)) == NULL) {
        RETURN_OUT_OF_MEMORY;
    }

    alignedSectorBuffer = (PCHAR)(((ULONG)sectorBuffer+sectorSize) & ~(sectorSize-1));

    for (i=0; i<sectorSize; alignedSectorBuffer[i++] = 0);

    if ((status = LowOpenDisk(GetDiskName(Disk),&handle)) != OK_STATUS) {
        FreeMemory(sectorBuffer);
        return status;
    }

    temp.QuadPart = Offset.QuadPart / sectorSize;
    status = LowWriteSectors(handle,
                             sectorSize,
                             temp.LowPart,
                             1,
                             alignedSectorBuffer);
    LowCloseDisk(handle);

    // Now to make sure the file system really did a dismount,
    // force a mount/verify of the partition.  This avoids a
    // problem where HPFS doesn't dismount when asked, but instead
    // marks the volume for verify.

    if ((status = LowOpenDisk(GetDiskName(Disk), &handle)) == OK_STATUS) {
        LowCloseDisk(handle);
    }

    FreeMemory(sectorBuffer);
    return status;
}


STATUS_CODE
WriteDriveLayout(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine writes the current partition layout for a given disk
    out to disk.  The high-level PARTITION lists are transformed into
    a DRIVE_LAYOUT_INFORMATION structure before being passed down
    to the low-level partition table writing routine.

Arguments:

    Disk - index of disk whose on-disk partition structure is to be updated.

Return Value:

    OK_STATUS or error code.

--*/

{
#define MAX_DISKS 250
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION    pinfo;
    ULONG                     entryCount;
    ULONG                     sectorSize;
    STATUS_CODE               status;
    LARGE_INTEGER             startingOffset,
                              extendedStartingOffset;
    PPARTITION                nextPartition,
                              partition,
                              partitionHash[MAX_DISKS];

    extendedStartingOffset.QuadPart = 0;
    memset(partitionHash, 0, sizeof(partitionHash));

    // allocate a huge buffer now to avoid complicated dynamic
    // reallocation schemes later.

    if (!(driveLayout = AllocateMemory((MAX_DISKS + 1) * sizeof(PARTITION_INFORMATION)))) {
        RETURN_OUT_OF_MEMORY;
    }

    pinfo = &driveLayout->PartitionEntry[0];

    // first do the mbr.

    entryCount = 0;
    partition = PrimaryPartitions[Disk];
    sectorSize = DiskGeometryArray[Disk].BytesPerSector;

    while (partition) {

        if (partition->SysID != SYSID_UNUSED) {

            if (IsExtended(partition->SysID)) {
                extendedStartingOffset = partition->Offset;
            } else {
                partitionHash[entryCount] = partition;
            }

            pinfo[entryCount].StartingOffset   = partition->Offset;
            pinfo[entryCount].PartitionLength  = partition->Length;
            pinfo[entryCount].PartitionType    = partition->SysID;
            pinfo[entryCount].BootIndicator    = partition->Active;
            pinfo[entryCount].RewritePartition = partition->Update;
            pinfo[entryCount].HiddenSectors    = (ULONG) (partition->Offset.QuadPart / sectorSize);

            // if we're creating this partition, clear out the
            // filesystem boot sector.

            if (pinfo[entryCount].RewritePartition
             && (partition->Update != CHANGED_DONT_ZAP)
             && !IsExtended(pinfo[entryCount].PartitionType)) {
                status = ZapSector(Disk,pinfo[entryCount].StartingOffset);
                if (status != OK_STATUS) {
                    FreeMemory(driveLayout);
                    return status;
                }
            }

            entryCount++;
        }
        partition = partition->Next;
    }

    // fill the remainder of the MBR with unused entries.
    // NOTE that there will thus always be an MBR even if there
    // are no partitions defined.

    UnusedEntryFill(pinfo+entryCount, ENTRIES_PER_BOOTSECTOR - entryCount);
    entryCount = ENTRIES_PER_BOOTSECTOR;

    // now handle the logical volumes.
    // first check to see whether we need a dummy EBR at the beginning
    // of the extended partition.  This is the case when there is
    // free space at the beginning of the extended partition.
#if 0
    // Also handle the case where we are creating an empty extended
    // partition -- need to zap the first sector to eliminate any residue
    // that might start an EBR chain.
#else
    // BUGBUG 4/24/92 tedm:  Currently the io subsystem returns an error
    // status (status_bad_master_boot_record) if any mbr or ebr is bad.
    // Zeroing the first sector of the extended partition therefore causes
    // the whole disk to be seen as empty.  So create a blank, but valid,
    // EBR in the 'empty extended partition' case.  Code is in the 'else'
    // part of the #if 0, below.
#endif

    if ((partition = LogicalVolumes[Disk]) && (partition->SysID == SYSID_UNUSED)) {
        if (partition->Next) {

            partitionHash[entryCount] = partition;
            MakeBootRec(Disk, pinfo+entryCount, NULL, partition->Next);
            entryCount += ENTRIES_PER_BOOTSECTOR;
            partition = partition->Next;
        } else {

#if 0
            status = ZapSector(Disk, extendedStartingOffset);
            if (status != OK_STATUS) {
                FreeMemory(driveLayout);
                return status;
            }
#else
            MakeBootRec(Disk, pinfo+entryCount, NULL, NULL);
            entryCount += ENTRIES_PER_BOOTSECTOR;
#endif
        }
    }

    while (partition) {
        if (partition->SysID != SYSID_UNUSED) {

            // find the next logical volume.

            nextPartition = partition->Next;
            while (nextPartition) {
                if (nextPartition->SysID != SYSID_UNUSED) {
                    break;
                }
                nextPartition = nextPartition->Next;
            }

            partitionHash[entryCount] = partition;
            startingOffset = MakeBootRec(Disk, pinfo+entryCount, partition, nextPartition);

            // if we're creating a volume, clear out its filesystem
            // boot sector so it starts out fresh.

            if ((startingOffset.QuadPart) && (partition->Update != CHANGED_DONT_ZAP)) {
                status = ZapSector(Disk,startingOffset);
                if (status != OK_STATUS) {
                    FreeMemory(driveLayout);
                    return status;
                }
            }

            entryCount += ENTRIES_PER_BOOTSECTOR;
        }
        partition = partition->Next;
    }

    driveLayout->PartitionCount = entryCount;
    driveLayout->Signature = Signatures[Disk];
    status = LowSetDiskLayout(DiskNames[Disk], driveLayout);

    if (NT_SUCCESS(status)) {

        // Update the partition numbers in the region structures.

        // ReconcilePartitionNumbers(Disk, driveLayout);

        for (entryCount = 0; entryCount < MAX_DISKS; entryCount++) {
            if (partition = partitionHash[entryCount]) {
                if (partition->Update) {
                    pinfo = &driveLayout->PartitionEntry[entryCount];
                    partition->PartitionNumber = pinfo->PartitionNumber;
                }
            }
        }
    }

    FreeMemory(driveLayout);
    return status;
}


STATUS_CODE
CommitPartitionChanges(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine is the entry point for updating the on-disk partition
    structures of a disk.  The disk is only written to if the partition
    structure has been changed by adding or deleting partitions.

Arguments:

    Disk - index of disk whose on-disk partition structure is to be updated.

Return Value:

    OK_STATUS or error code.

--*/

{
    PPARTITION              p;
    STATUS_CODE             status;

    if (!HavePartitionsBeenChanged(Disk)) {
        return OK_STATUS;
    }

    if ((status = WriteDriveLayout(Disk)) != OK_STATUS) {
        return status;
    }

    // BUGBUG for ARC and NT MIPS, update NVRAM vars so partitions are right.
    //        Do that here, before partition numbers are reassigned.

    p = PrimaryPartitions[Disk];
    while (p) {
        p->Update = FALSE;
        p->OriginalPartitionNumber = p->PartitionNumber;
        p = p->Next;
    }
    p = LogicalVolumes[Disk];
    while (p) {
        p->Update = FALSE;
        p->OriginalPartitionNumber = p->PartitionNumber;
        p = p->Next;
    }

    ChangesRequested[Disk] = FALSE;
    ChangesCommitted[Disk] = TRUE;
    return OK_STATUS;
}


BOOLEAN
IsRegionCommitted(
    PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Given a region descriptor, return TRUE if it actually exists on disk,
    FALSE otherwise.

Arguments:

    RegionDescriptor - the region to check

Return Value:

    TRUE - if the region actually exists on disk
    FALSE otherwise.

--*/

{
    PPERSISTENT_REGION_DATA regionData;

    regionData = PERSISTENT_DATA(RegionDescriptor);
    if (!regionData) {
        return FALSE;
    }
    return regionData->VolumeExists;
}


BOOLEAN
HavePartitionsBeenChanged(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine returns TRUE if the given disk's partition structures
    have been modified by adding or deleting partitions, since the
    on-disk structures were last written by a call to CommitPartitionChanges
    (or first read).

Arguments:

    Disk - index of disk to check

Return Value:

    true if Disk's partition structure has changed.

--*/

{
    return ChangesRequested[Disk];
}


BOOLEAN
ChangeCommittedOnDisk(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine will inform the caller if a change was actually committed
    to the disk given.

Arguments:

    Disk - index of disk to check

Return Value:

    TRUE if disk was changed
    FALSE otherwise.

--*/

{
    return ChangesCommitted[Disk];
}


VOID
ClearCommittedDiskInformation(
    )

/*++

Routine Description:

    Clear all knowledge about any changes that have occurred to the
    disks.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG i;

    for (i=0; i<CountOfDisks; i++) {
        ChangesCommitted[i] = FALSE;
    }
}


VOID
FdMarkDiskDirty(
    IN ULONG Disk
    )

/*++

Routine Description:

    Remember that this disk has had some partitioning changes.

Arguments:

    Disk - the disk number

Return Value:

    None

--*/

{
    ChangesRequested[Disk] = TRUE;
}


VOID
FdSetPersistentData(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              Data
    )

/*++

Routine Description:

    Set the persistent data area for the specified region.

Arguments:

    Region - the region for which the persistent data is to be set
    Data   - the persistent data for the region.

Return Value:

    None

--*/

{
    ((PREGION_DATA)(Region->Reserved))->Partition->PersistentData =
                                                  (PPERSISTENT_REGION_DATA) Data;
}


ULONG
FdGetMinimumSizeMB(
    IN ULONG Disk
    )

/*++

Routine Description:

    Return the minimum size for a partition on a given disk.

    This is the rounded size of one cylinder or 1, whichever is greater.

Arguments:

    Region - region describing the partition to check.

Return Value:

    Actual offset

--*/

{
    LARGE_INTEGER temp;

    temp.QuadPart = DiskGeometryArray[Disk].BytesPerCylinder;
    return max(SIZEMB(temp), 1);
}


ULONG
FdGetMaximumSizeMB(
    IN PREGION_DESCRIPTOR Region,
    IN REGION_TYPE        CreationType
    )

/*++

Routine Description:

    Given a region of disk determine how much of it may be used to
    create the specified partition type.  This code take into consideration
    the many alignment restrictions imposed by early DOS software versions.

Arguments:

    Region - The affected region
    CreationType - What is being created
                   (extended partition/primary partition)

Return Value:

    The maximum size that a partition of the specified type can be
    to fit within the space available in the region.

--*/

{
    PREGION_DATA  createData = Region->Reserved;
    LARGE_INTEGER maxSize;

    maxSize = createData->AlignedRegionSize;
    if (!(createData->AlignedRegionOffset.QuadPart)) {
        ULONG delta;

        delta = (CreationType == REGION_EXTENDED)
              ? DiskGeometryArray[Region->Disk].BytesPerCylinder
              : DiskGeometryArray[Region->Disk].BytesPerTrack;

        maxSize.QuadPart -= delta;
    }

    return SIZEMB(maxSize);
}


LARGE_INTEGER
FdGetExactSize(
    IN PREGION_DESCRIPTOR Region,
    IN BOOLEAN            ForExtended
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PREGION_DATA  regionData = Region->Reserved;
    LARGE_INTEGER largeSize = regionData->AlignedRegionSize;
    LARGE_INTEGER bytesPerTrack;
    LARGE_INTEGER bytesPerCylinder;

    bytesPerTrack.QuadPart = DiskGeometryArray[Region->Disk].BytesPerTrack;
    bytesPerCylinder.QuadPart = DiskGeometryArray[Region->Disk].BytesPerCylinder;

    if (Region->RegionType == REGION_LOGICAL) {

        //
        // The region is within the extended partition.  It doesn't matter
        // whether it's free space or used -- in either case, we need to
        // account for the reserved EBR track.
        //

        largeSize.QuadPart -= bytesPerTrack.QuadPart;

    } else if (Region->SysID == SYSID_UNUSED) {

        //
        // The region is unused space not inside the extended partition.
        // We must know whether the caller will put a primary or extended
        // partition there -- a primary partition can use all the space, but
        // a logical volume in the extended partition won't include the first
        // track.  If the free space starts at offset 0 on the disk, a special
        // calculation must be used to move the start of the partition to
        // skip a track for a primary or a cylinder and a track for an
        // extended+logical.
        //

        if ((!regionData->AlignedRegionOffset.QuadPart) || ForExtended) {
            largeSize.QuadPart -= bytesPerTrack.QuadPart;
        }

        if ((!regionData->AlignedRegionOffset.QuadPart) && ForExtended) {
            largeSize.QuadPart -= bytesPerCylinder.QuadPart;
        }
    }

    return largeSize;
}


LARGE_INTEGER
FdGetExactOffset(
    IN PREGION_DESCRIPTOR Region
    )

/*++

Routine Description:

    Determine where a given partition _actually_ starts, which may be
    different than where is appears because of EBR reserved tracks, etc.

    NOTE: This routine is not meant to operate on unused regions or
    extended partitions.  In these cases, it just returns the apparant offset.

Arguments:

    Region - region describing the partition to check.

Return Value:

    Actual offset

--*/

{
    LARGE_INTEGER offset = ((PREGION_DATA)(Region->Reserved))->Partition->Offset;

    if ((Region->SysID != SYSID_UNUSED) && (Region->RegionType == REGION_LOGICAL)) {

        //
        // The region is a logical volume.
        // Account for the reserved EBR track.
        //

        offset.QuadPart += DiskGeometryArray[Region->Disk].BytesPerTrack;
    }

    return offset;
}


BOOLEAN
FdCrosses1024Cylinder(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        RegionType
    )

/*++

Routine Description:

    Determine whether a used region corsses the 1024th cylinder, or whether
    a partition created within a free space will cross the 1024th cylinder.

Arguments:

    Region - region describing the partition to check.
    CreationSizeMB - if the Region is for a free space, this is the size of
        the partition to be checked.
    RegionType - one of REGION_PRIMARY, REGION_EXTENDED, or REGION_LOGICAL

Return Value:

    TRUE if the end cylinder >= 1024.

--*/

{
    LARGE_INTEGER start,
                  size,
                  end,
                  zero;

    if (Region->SysID == SYSID_UNUSED) {

        // Determine the exact size and offset of the partition, according
        // to how CreatePartitionEx() will do it.

        zero.QuadPart = 0;
        DetermineCreateSizeAndOffset(Region,
                                     zero,
                                     CreationSizeMB,
                                     RegionType,
                                     &start,
                                     &size);
    } else {

        start = ((PREGION_DATA)(Region->Reserved))->Partition->Offset;
        size  = ((PREGION_DATA)(Region->Reserved))->Partition->Length;
    }

    end.QuadPart = (start.QuadPart + size.QuadPart) - 1;

    // End is the last byte in the partition.  Divide by the number of
    // bytes in a cylinder and see whether the result is > 1023.

    end.QuadPart = end.QuadPart / DiskGeometryArray[Region->Disk].BytesPerCylinder;
    return (end.QuadPart > 1023);
}


BOOLEAN
IsDiskOffLine(
    IN ULONG Disk
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    return OffLine[Disk];
}

ULONG
FdGetDiskSignature(
    IN ULONG Disk
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    return Signatures[Disk];
}

VOID
FdSetDiskSignature(
    IN ULONG Disk,
    IN ULONG Signature
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    Signatures[Disk] = Signature;
}

BOOLEAN
SignatureIsUniqueToSystem(
    IN ULONG Disk,
    IN ULONG Signature
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG index;

    for (index = 0; index < Disk; index++) {
        if (Signatures[index] == Signature) {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdft.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    fdft.c

Abstract:

    This module contains FT support routines for Disk Administrator

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    11-Nov-93 (bobri) minor changes - mostly cosmetic.

--*/

#include "fdisk.h"
#include <string.h>


// This variable heads a linked list of ft object sets.

PFT_OBJECT_SET FtObjects = NULL;

// Array of pointers to registry disk descriptors that we
// remember, ie, save for later use when a disk is not physically
// present on the machine.

PDISK_DESCRIPTION *RememberedDisks;
ULONG              RememberedDiskCount;



ULONG
FdpDetermineDiskDescriptionSize(
    PDISKSTATE DiskState
    );

ULONG
FdpConstructDiskDescription(
    IN  PDISKSTATE        DiskState,
    OUT PDISK_DESCRIPTION DiskDescription
    );

VOID
FdpRememberDisk(
    IN PDISK_DESCRIPTION DiskDescription
    );

VOID
FdpInitializeMirrors(
    VOID
    );

#define MAX_FT_SET_TYPES 4
ULONG OrdinalToAllocate[MAX_FT_SET_TYPES] = {0, 0, 0, 0};

VOID
MaintainOrdinalTables(
    IN FT_TYPE FtType,
    IN ULONG   Ordinal
    )

/*++

Routine Description:

    Maintain the minimum and maximum Ordinal value recorded.

Arguments:

    FtType - the type of the FT set.
    Ordinal - the in use FtGroup (or ordinal) number

Return Value:

    None

--*/

{
    if (Ordinal > OrdinalToAllocate[FtType]) {
        OrdinalToAllocate[FtType] = Ordinal;
    }
}

DWORD
FdftNextOrdinal(
    IN FT_TYPE FtType
    )

/*++

Routine Description:

    Allocate a number that will uniquely identify the FT set
    from other sets of the same type.  This number must be unique
    from any given or used by FT sets of the same type due to
    requirements of FT dynamic partitioning.

Arguments:

    FtType - The type of the FT set.

Return Value:

    The FtGroup number -- called an "ordinal" in the internal
    structures.

--*/

{
    DWORD          ord;
    PFT_OBJECT_SET pftset;
    BOOL           looping;

    // The Ordinal value is going to be used as an FtGroup number
    // FtGroups are USHORTs so don't wrap on the Ordinal.  Try
    // to keep the next ordinal in the largest opening range, that
    // is if the minimum found is > half way through a USHORT, start
    // the ordinals over at zero.

    if (OrdinalToAllocate[FtType] > 0x7FFE) {
        OrdinalToAllocate[FtType] = 0;
    }

    ord = OrdinalToAllocate[FtType];
    ord++;

    do {
        looping = FALSE;
        pftset = FtObjects;
        while (pftset) {
            if ((pftset->Type == FtType) && (pftset->Ordinal == ord)) {
                ord++;
                looping = TRUE;
                break;
            }
            pftset = pftset->Next;
        }
    } while (looping);

    OrdinalToAllocate[FtType] = (ord + 1);
    return ord;
}


VOID
FdftCreateFtObjectSet(
    IN FT_TYPE             FtType,
    IN PREGION_DESCRIPTOR *Regions,
    IN DWORD               RegionCount,
    IN FT_SET_STATUS       Status
    )

/*++

Routine Description:

    Create the FT set structures for the give collection of
    region pointers.

Arguments:

    FtType
    Regions
    RegionCount
    Status

Return Value:

    None

--*/

{
    DWORD           Ord;
    PFT_OBJECT_SET  FtSet;
    PFT_OBJECT      FtObject;


    FtSet = Malloc(sizeof(FT_OBJECT_SET));

    // Figure out an ordinal for the new object set.

    FtSet->Ordinal = FdftNextOrdinal(FtType);
    FtSet->Type = FtType;
    FtSet->Members = NULL;
    FtSet->Member0 = NULL;
    FtSet->Status = Status;

    // Link the new object set into the list.

    FtSet->Next = FtObjects;
    FtObjects = FtSet;

    // For each region in the set, associate the ft info with it.

    for (Ord=0; Ord<RegionCount; Ord++) {

        FtObject = Malloc(sizeof(FT_OBJECT));

        // If this is a creation of a stripe set with parity, then
        // we must mark the 0th item 'Initializing' instead of 'Healthy'.

        if ((Ord == 0)
         && (FtType == StripeWithParity)
         && (Status == FtSetNewNeedsInitialization)) {
            FtObject->State = Initializing;
        } else {
            FtObject->State = Healthy;
        }

        if (!Ord) {
            FtSet->Member0 = FtObject;
        }

        FtObject->Set = FtSet;
        FtObject->MemberIndex = Ord;
        FtObject->Next = FtSet->Members;
        FtSet->Members = FtObject;

        SET_FT_OBJECT(Regions[Ord],FtObject);
    }
}

BOOL
FdftUpdateFtObjectSet(
    IN PFT_OBJECT_SET FtSet,
    IN FT_SET_STATUS  SetState
    )

/*++

Routine Description:

    Given an FT set, go back to the registry information and
    update the state of the members with the state in the registry.

    NOTE:  The following condition may exist.  It is possible for
    the FtDisk driver to return that the set is in an initializing
    or regenerating state and not have this fact reflected in the
    registry.  This can happen when the system has crashed and
    on restart the FtDisk driver started the regeneration of the
    check data (parity).

Arguments:

    FtSet - the set to update.

Return Value:

    TRUE if the set state provided has a strong likelyhood of being correct
    FALSE if the NOTE condition above is occuring.

--*/

{
    BOOLEAN            allHealthy = TRUE;
    PFT_OBJECT         ftObject;
    PDISK_REGISTRY     diskRegistry;
    PDISK_PARTITION    partition;
    PDISK_DESCRIPTION  diskDescription;
    DWORD              ec;
    ULONG              diskIndex,
                       partitionIndex;

    ec = MyDiskRegistryGet(&diskRegistry);
    if (ec != NO_ERROR) {

        // No registry information.

        return TRUE;
    }

    diskDescription = diskRegistry->Disks;
    for (diskIndex=0; diskIndex<diskRegistry->NumberOfDisks; diskIndex++) {

        for (partitionIndex=0; partitionIndex<diskDescription->NumberOfPartitions; partitionIndex++) {

            partition = &diskDescription->Partitions[partitionIndex];
            if ((partition->FtType == FtSet->Type) && (partition->FtGroup == (USHORT) FtSet->Ordinal)) {

                // Have a match for a partition within this set.
                // Find the region descriptor for this partition and
                // update its state accordingly.

                for (ftObject = FtSet->Members; ftObject; ftObject = ftObject->Next) {

                    if (ftObject->MemberIndex == (ULONG) partition->FtMember) {
                        ftObject->State = partition->FtState;
                        break;
                    }

                    if (partition->FtState != Healthy) {
                        allHealthy = FALSE;
                    }
                }
            }
        }
        diskDescription = (PDISK_DESCRIPTION)&diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    Free(diskRegistry);
    if ((allHealthy) && (SetState != FtSetHealthy)) {

        // This is a condition where the system must be
        // updating the check data for redundant sets.

        return FALSE;
    }

    return TRUE;
}

VOID
FdftDeleteFtObjectSet(
    IN PFT_OBJECT_SET FtSet,
    IN BOOL           OffLineDisksOnly
    )

/*++

Routine Description:

    Delete an ft set, or rather its internal representation as a linked
    list of ft member structures.

Arguments:

    FtSet - supplies pointer to ft set structure for set to delete.

    OffLineDisksOnly - if TRUE, then do not delete the set but instead
        scan remembered disks for members of the set and remove such members.

Return Value:

    None.

--*/

{
    PFT_OBJECT        ftObject = FtSet->Members;
    PFT_OBJECT        next;
    PFT_OBJECT_SET    ftSetTemp;
    PDISK_DESCRIPTION diskDescription;
    PDISK_PARTITION   diskPartition;
    ULONG             partitionCount,
                      size,
                      i,
                      j;

    // Locate any members of the ft set on remembered disks and
    // remove the entries for such partitions.

    for (i=0; i<RememberedDiskCount; i++) {

        diskDescription = RememberedDisks[i];
        partitionCount = diskDescription->NumberOfPartitions;

        for (j=0; j<partitionCount; j++) {

            diskPartition = &diskDescription->Partitions[j];

            if ((diskPartition->FtType  == FtSet->Type)
             && (diskPartition->FtGroup == (USHORT)FtSet->Ordinal)) {

                // Found a member of the ft set being deleted on a
                // remembered disk.  Remove the partition from the
                // remembered disk.

                RtlMoveMemory( diskPartition,
                               diskPartition+1,
                               (partitionCount - j - 1) * sizeof(DISK_PARTITION)
                             );

                partitionCount--;
                j--;
            }
        }

        if (partitionCount != diskDescription->NumberOfPartitions) {

            diskDescription->NumberOfPartitions = (USHORT)partitionCount;

            size = sizeof(DISK_DESCRIPTION);
            if (partitionCount > 1) {
                size += (partitionCount - 1) * sizeof(DISK_PARTITION);
            }
            RememberedDisks[i] = Realloc(RememberedDisks[i], size);
        }
    }

    if (OffLineDisksOnly) {
        return;
    }

    // First, free all members of the set

    while (ftObject) {
        next = ftObject->Next;
        Free(ftObject);
        ftObject = next;
    }

    // now, remove the set from the linked list of sets.

    if (FtObjects == FtSet) {
        FtObjects = FtSet->Next;
    } else {
        ftSetTemp = FtObjects;
        while (1) {
            FDASSERT(ftSetTemp);
            if (ftSetTemp == NULL) {
                break;
            }
            if (ftSetTemp->Next == FtSet) {
                ftSetTemp->Next = FtSet->Next;
                break;
            }
            ftSetTemp = ftSetTemp->Next;
        }
    }
    Free(FtSet);
}

VOID
FdftExtendFtObjectSet(
    IN OUT  PFT_OBJECT_SET      FtSet,
    IN OUT  PREGION_DESCRIPTOR* Regions,
    IN      DWORD               RegionCount
    )
/*++

Routine Description:

    This function adds regions to an existing FT-set.

Arguments:

    FtSet       --  Supplies the set to extend.
    Regions     --  Supplies the regions to add to the set.  Note
                    that these regions are updated with the FT
                    information.
    RegionCount --  Supplies the number of regions to add.

Return Value:

    None.

--*/
{
    PFT_OBJECT FtObject;
    DWORD   i, StartingIndex;

    // Determine the starting member index for the new regions.
    // It is the greatest of the existing member indices plus one.

    StartingIndex = 0;

    for( FtObject = FtSet->Members; FtObject; FtObject = FtObject->Next ) {

        if( FtObject->MemberIndex > StartingIndex ) {

            StartingIndex = FtObject->MemberIndex;
        }
    }

    StartingIndex++;


    // Associate the ft-set's information with each of the
    // new regions.

    for( i = 0; i < RegionCount; i++ ) {

        FtObject = Malloc( sizeof(FT_OBJECT) );

        FtObject->Set = FtSet;
        FtObject->MemberIndex = StartingIndex + i;
        FtObject->Next = FtSet->Members;
        FtObject->State = Healthy;
        FtSet->Members = FtObject;

        SET_FT_OBJECT(Regions[i],FtObject);
    }

    FtSet->Status = FtSetExtended;
}


PULONG DiskHadRegistryEntry;

ULONG
ActualPartitionCount(
    IN PDISKSTATE DiskState
    )

/*++

Routine Description:

    Given a disk, this routine counts the number of partitions on it.
    The number of partitions is the number of regions that appear in
    the NT name space (ie, the maximum value of <x> in
    \device\harddiskn\partition<x>).

Arguments:

    DiskState - descriptor for the disk in question.

Return Value:

    Partition count (may be 0).

--*/

{
    ULONG i,PartitionCount=0;
    PREGION_DESCRIPTOR region;

    for(i=0; i<DiskState->RegionCount; i++) {
        region = &DiskState->RegionArray[i];
        if((region->SysID != SYSID_UNUSED) &&
           !IsExtended(region->SysID) &&
           IsRecognizedPartition(region->SysID)) {

            PartitionCount++;
        }
    }
    return(PartitionCount);
}


PDISKSTATE
LookUpDiskBySignature(
    IN ULONG Signature
    )

/*++

Routine Description:

    This routine will look through the disk descriptors created by the
    fdisk back end looking for a disk with a particular signature.

Arguments:

    Signature - signature of disk to locate

Return Value:

    Pointer to disk descriptor or NULL if no disk with the given signature
    was found.

--*/

{
    ULONG disk;
    PDISKSTATE ds;

    for(disk=0; disk<DiskCount; disk++) {
        ds = Disks[disk];
        if(ds->Signature == Signature) {
            return(ds);
        }
    }
    return(NULL);
}


PREGION_DESCRIPTOR
LookUpPartition(
    IN PDISKSTATE    DiskState,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length
    )

/*++

Routine Description:

    This routine will look through a region descriptor array for a
    partition with a particular length and starting offset.

Arguments:

    DiskState       - disk on which to locate the partition
    Offset          - offset of partition on the disk to find
    Length          - size of the partition to find

Return Value:

    Pointer to region descriptor or NULL if no such partition on that disk

--*/

{
    ULONG              regionIndex,
                       maxRegion = DiskState->RegionCount;
    PREGION_DESCRIPTOR regionDescriptor;
    LARGE_INTEGER      offset,
                       length;

    for (regionIndex=0; regionIndex<maxRegion; regionIndex++) {

        regionDescriptor = &DiskState->RegionArray[regionIndex];

        if ((regionDescriptor->SysID != SYSID_UNUSED) && !IsExtended(regionDescriptor->SysID)) {

            offset = FdGetExactOffset(regionDescriptor);
            length = FdGetExactSize(regionDescriptor, FALSE);

            if ((offset.LowPart  == Offset.LowPart )
             && (offset.HighPart == Offset.HighPart)
             && (length.LowPart  == Length.LowPart)
             && (length.HighPart == Length.HighPart)) {
                return regionDescriptor;
            }
        }
    }
    return NULL;
}


VOID
AddObjectToSet(
    IN PFT_OBJECT FtObjectToAdd,
    IN FT_TYPE    FtType,
    IN USHORT     FtGroup
    )

/*++

Routine Description:

    Find the FtSet for that this object belongs to and insert
    it into the chain of members.  If the set cannot be found
    in the existing collection of sets, create a new one.

Arguments:

    FtObjectToAdd - the object point to be added.
    FtType        - the type of the FT set.
    FtGroup       - group for this object.

Return Value:

    None

--*/

{
    PFT_OBJECT_SET ftSet = FtObjects;

    while (ftSet) {

        if ((ftSet->Type == FtType) && (ftSet->Ordinal == FtGroup)) {
            break;
        }
        ftSet = ftSet->Next;
    }

    if (!ftSet) {

        // There is no such existing ft set.  Create one.

        ftSet = Malloc(sizeof(FT_OBJECT_SET));

        ftSet->Status = FtSetHealthy;
        ftSet->Type = FtType;
        ftSet->Ordinal = FtGroup;
        ftSet->Members = NULL;
        ftSet->Next = FtObjects;
        ftSet->Member0 = NULL;
        ftSet->NumberOfMembers = 0;
        FtObjects = ftSet;
    }

    FDASSERT(ftSet);

    FtObjectToAdd->Next = ftSet->Members;
    ftSet->Members = FtObjectToAdd;
    ftSet->NumberOfMembers++;
    FtObjectToAdd->Set = ftSet;

    if (FtObjectToAdd->MemberIndex == 0) {
        ftSet->Member0 = FtObjectToAdd;
    }

    if (FtType == StripeWithParity || FtType == Mirror) {

        // Update the set's state based on the state of the new member:

        switch (FtObjectToAdd->State) {

        case Healthy:

            // Doesn't change state of set.

            break;

        case Regenerating:
            ftSet->Status = (ftSet->Status == FtSetHealthy ||
                             ftSet->Status == FtSetRegenerating)
                          ? FtSetRegenerating
                          : FtSetBroken;
            break;

        case Initializing:
            ftSet->Status = (ftSet->Status == FtSetHealthy ||
                             ftSet->Status == FtSetInitializing)
                          ? FtSetInitializing
                          : FtSetBroken;
            break;

        default:

            // If only one member is bad, the set is recoverable;
            // otherwise, it's broken.

            ftSet->Status = (ftSet->Status == FtSetHealthy)
                          ? FtSetRecoverable
                          : FtSetDisabled;
            break;
        }
    }
}


ULONG
InitializeFt(
    IN BOOL DiskSignaturesCreated
    )

/*++

Routine Description:

    Search the disk registry information to construct the FT
    relationships in the system.

Arguments:

    DiskSignaturesCreated - boolean to indicate that new disks
                            were located in the system.

Return Value:

    An error code if the disk registry could not be obtained.

--*/

{
    ULONG              disk,
                       partitionIndex,
                       partitionCount;
    PDISK_REGISTRY     diskRegistry;
    PDISK_PARTITION    partition;
    PDISK_DESCRIPTION  diskDescription;
    PDISKSTATE         diskState;
    PREGION_DESCRIPTOR regionDescriptor;
    DWORD              ec;
    BOOL               configDiskChanged = FALSE,
                       configMissingDisk = FALSE,
                       configExtraDisk   = FALSE;
    PFT_OBJECT         ftObject;
    BOOL               anyDisksOffLine;
    TCHAR              name[100];


    RememberedDisks = Malloc(0);
    RememberedDiskCount = 0;

    ec = MyDiskRegistryGet(&diskRegistry);
    if (ec != NO_ERROR) {

        FDLOG((0,"InitializeFt: Error %u from MyDiskRegistryGet\n",ec));

        return ec;
    }

    DiskHadRegistryEntry = Malloc(DiskCount * sizeof(ULONG));
    memset(DiskHadRegistryEntry,0,DiskCount * sizeof(ULONG));

    diskDescription = diskRegistry->Disks;

    for (disk = 0; disk < diskRegistry->NumberOfDisks; disk++) {

        // For the disk described in the registry, look up the
        // corresponding actual disk found by the fdisk init code.

        diskState = LookUpDiskBySignature(diskDescription->Signature);

        if (diskState) {

            FDLOG((2,
                  "InitializeFt: disk w/ signature %08lx is disk #%u\n",
                  diskDescription->Signature,
                  diskState->Disk));

            DiskHadRegistryEntry[diskState->Disk]++;

            partitionCount = ActualPartitionCount(diskState);

            if (partitionCount != diskDescription->NumberOfPartitions) {

                FDLOG((1,"InitializeFt: partition counts for disk %08lx don't match:\n", diskState->Signature));
                FDLOG((1,"    Count from actual disk: %u\n",partitionCount));
                FDLOG((1,"    Count from registry   : %u\n",diskDescription->NumberOfPartitions));

                configDiskChanged = TRUE;
            }
        } else {

            // there's an entry in the registry that does not have a
            // real disk to match.  Remember this disk; if it has any
            // FT partitions, we also want to display a message telling
            // the user that something's missing.

            FDLOG((1,"InitializeFt: Entry for disk w/ signature %08lx has no matching real disk\n", diskDescription->Signature));

            for (partitionIndex = 0; partitionIndex < diskDescription->NumberOfPartitions; partitionIndex++) {

                partition = &diskDescription->Partitions[partitionIndex];
                if (partition->FtType != NotAnFtMember) {

                    // This disk has an FT partition, so Windisk will
                    // want to tell the user that some disks are missing.

                    configMissingDisk = TRUE;
                    break;
                }
            }

            FdpRememberDisk(diskDescription);
        }

        for (partitionIndex = 0; partitionIndex < diskDescription->NumberOfPartitions; partitionIndex++) {

            partition = &diskDescription->Partitions[partitionIndex];
            regionDescriptor = NULL;

            if (diskState) {
                regionDescriptor = LookUpPartition(diskState,
                                                   partition->StartingOffset,
                                                   partition->Length);
            }

            // At this point one of three conditions exists.
            //
            // 1. There is no disk related to this registry information
            //    diskState == NULL && regionDescriptor == NULL
            // 2. There is a disk, but no partition related to this information
            //    diskState != NULL && regionDescriptor == NULL
            // 3. There is a disk and a partition related to this information
            //    diskState != NULL && regionDescriptor != NULL
            //
            // In any of these conditions, if the registry entry is part
            // of an FT set and FT object must be created.
            //
            // that corresponds to a partition's entry in the
            // disk registry database.

            if (partition->FtType != NotAnFtMember) {
                ftObject = Malloc(sizeof(FT_OBJECT));
                ftObject->Next = NULL;
                ftObject->Set = NULL;
                ftObject->MemberIndex = partition->FtMember;
                ftObject->State = partition->FtState;

                // if a partition was actually found there will be a
                // regionDescriptor that needs to be updated.

                if (regionDescriptor && regionDescriptor->PersistentData) {
                    FT_SET_STATUS setState;
                    ULONG         numberOfMembers;

                    SET_FT_OBJECT(regionDescriptor, ftObject);

                    // Before the drive letter is moved into the region
                    // data, be certain that the FT volume exists at this
                    // drive letter.

                    LowFtVolumeStatusByLetter(partition->DriveLetter,
                                              &setState,
                                              &numberOfMembers);

                    // If the numberOfMembers gets set to 1 then
                    // this letter is not the letter for the FT set,
                    // but rather a default letter assigned because the
                    // FT sets letter could not be assigned.

                    if (numberOfMembers > 1) {
                        PERSISTENT_DATA(regionDescriptor)->DriveLetter = partition->DriveLetter;
                    }
                } else {

                    // There is no region for this partition
                    // so update the set state.

                    ftObject->State = Orphaned;
                }

                // Now place the ft object in the correct set,
                // creating the set if necessary.

                AddObjectToSet(ftObject, partition->FtType, partition->FtGroup);
                MaintainOrdinalTables(partition->FtType, (ULONG) partition->FtGroup);
            }
        }

        diskDescription = (PDISK_DESCRIPTION)&diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }
    Free(diskRegistry);

    // Check to see if every disk found by the fdisk back end has a
    // corresponding registry entry.

    for (disk = 0; disk < DiskCount; disk++) {

        if (Disks[disk]->OffLine) {
            continue;
        }

        if ((!DiskHadRegistryEntry[disk]) && (!IsRemovable(disk))) {

            // a real disk does not have a matching registry entry.

            FDLOG((1,"InitializeFt: Disk %u does not have a registry entry (disk sig = %08lx)\n",disk,Disks[disk]->Signature));
            configExtraDisk = TRUE;
        }
    }

    // Determine whether any disks are off line

    anyDisksOffLine = FALSE;
    for (disk = 0; disk < DiskCount; disk++) {
        if (Disks[disk]->OffLine) {
            anyDisksOffLine = TRUE;
            break;
        }
    }

    if (configMissingDisk || anyDisksOffLine) {
        WarningDialog(MSG_CONFIG_MISSING_DISK);
    }
    if (configDiskChanged) {
        RegistryChanged = TRUE;
        WarningDialog(MSG_CONFIG_DISK_CHANGED);
    }
    if (configExtraDisk || DiskSignaturesCreated) {

        BOOL BadConfigSet = FALSE;

        WarningDialog(MSG_CONFIG_EXTRA_DISK);

        // Update ft signature on each disk for which a new signature
        // was created. and update registry for each disk with
        // DiskHadRegistryEntry[Disk] == 0.

        for (disk = 0; disk < DiskCount; disk++) {
            BOOL b1 = TRUE,
                 b2 = TRUE;

            if (Disks[disk]->OffLine) {
                continue;
            }

            wsprintf(name, DiskN, disk);
            if (Disks[disk]->SigWasCreated) {
                if (ConfirmationDialog(MSG_NO_SIGNATURE, MB_ICONEXCLAMATION | MB_YESNO, name) == IDYES) {
                    b1 = (MasterBootCode(disk, Disks[disk]->Signature, TRUE, TRUE) == NO_ERROR);
                } else {
                    Disks[disk]->OffLine = TRUE;
                    continue;
                }
            }

            if (!DiskHadRegistryEntry[disk]) {
                ULONG size;

                size = FdpDetermineDiskDescriptionSize(Disks[disk]);

                diskDescription = Malloc(size);
                FdpConstructDiskDescription(Disks[disk], diskDescription);

                FDLOG((2,"InitializeFt: Adding new disk %08lx to registry.\n", diskDescription->Signature));
                LOG_ONE_DISK_REGISTRY_DISK_ENTRY("InitializeFt", diskDescription);

                b2 = (EC(DiskRegistryAddNewDisk(diskDescription)) == NO_ERROR);
                Free(diskDescription);
            }

            if (!(b1 && b2)) {
                BadConfigSet = TRUE;
            }
        }

        if (BadConfigSet) {
            ErrorDialog(MSG_BAD_CONFIG_SET);
        }
    }

    return NO_ERROR;
}

BOOLEAN
NewConfigurationRequiresFt(
    VOID
    )

/*++

Routine Description:

    Search the diskstate and region arrays to determine if a single
    FtDisk element (i.e. stripe, stripe set with parity, mirror or
    volume set) is contained in the configuration.

Arguments:

    None

Return Value:

    TRUE if the new configuration requires the FtDisk driver.
    FALSE otherwise.

--*/

{
    ULONG              disk,
                       region;
    PDISKSTATE         diskState;
    PREGION_DESCRIPTOR regionDescriptor;

    // Look at all disks in the system.

    for (disk = 0; disk < DiskCount; disk++) {

        diskState = Disks[disk];
        if (diskState->OffLine || IsDiskRemovable[disk]) {
            continue;
        }

        // Check each region on the disk.

        for (region = 0; region < diskState->RegionCount; region++) {

            regionDescriptor = &diskState->RegionArray[region];
            if ((regionDescriptor->SysID != SYSID_UNUSED) && !IsExtended(regionDescriptor->SysID) && IsRecognizedPartition(regionDescriptor->SysID)) {

                // If a single region has an FT Object, then FT
                // is required and the search may be stopped.

                if (GET_FT_OBJECT(regionDescriptor)) {
                    return TRUE;
                }
            }
        }
    }

    // no FtObject was found.

    return FALSE;
}

ULONG
SaveFt(
    VOID
    )

/*++

Routine Description:

    This routine walks all of the internal structures and creates
    the interface structure for the DiskRegistry interface.

Arguments:

    None

Return Value:

    success/failure code.  NO_ERROR is success.

--*/

{
    ULONG             i;
    ULONG             disk,
                      partition;
    ULONG             size;
    PDISK_REGISTRY    diskRegistry;
    PDISK_DESCRIPTION diskDescription;
    PBYTE             start,
                      end;
    DWORD             ec;
    ULONG             offLineDiskCount;
    ULONG             removableDiskCount;

    // First count partitions and disks so we can allocate a structure
    // of the correct size.

    size = sizeof(DISK_REGISTRY) - sizeof(DISK_DESCRIPTION);
    offLineDiskCount = 0;
    removableDiskCount = 0;

    for (i=0; i<DiskCount; i++) {

        if (Disks[i]->OffLine) {
            offLineDiskCount++;
        } else if (IsDiskRemovable[i]) {
            removableDiskCount++;
        } else {
            size += FdpDetermineDiskDescriptionSize(Disks[i]);
        }
    }

    // Account for remembered disks.

    size += RememberedDiskCount * sizeof(DISK_DESCRIPTION);
    for (i=0; i<RememberedDiskCount; i++) {
        if (RememberedDisks[i]->NumberOfPartitions > 1) {
            size += (RememberedDisks[i]->NumberOfPartitions - 1) * sizeof(DISK_PARTITION);
        }
    }

    diskRegistry = Malloc(size);
    diskRegistry->NumberOfDisks = (USHORT)(   DiskCount
                                            + RememberedDiskCount
                                            - offLineDiskCount
                                            - removableDiskCount);
    diskRegistry->ReservedShort = 0;
    diskDescription = diskRegistry->Disks;
    for (disk=0; disk<DiskCount; disk++) {

        if (Disks[disk]->OffLine || IsDiskRemovable[disk]) {
            continue;
        }

        partition = FdpConstructDiskDescription(Disks[disk], diskDescription);

        diskDescription = (PDISK_DESCRIPTION)&diskDescription->Partitions[partition];
    }

    // Toss in remembered disks.

    for (i=0; i<RememberedDiskCount; i++) {

        // Compute the beginning and end of this remembered disk's
        // Disk Description:

        partition =  RememberedDisks[i]->NumberOfPartitions;
        start = (PBYTE)RememberedDisks[i];
        end   = (PBYTE)&(RememberedDisks[i]->Partitions[partition]);

        RtlMoveMemory(diskDescription, RememberedDisks[i], end - start);
        diskDescription = (PDISK_DESCRIPTION)&diskDescription->Partitions[partition];
    }

    LOG_DISK_REGISTRY("SaveFt", diskRegistry);

    ec = EC(DiskRegistrySet(diskRegistry));
    Free(diskRegistry);

    if (ec == NO_ERROR) {
        FdpInitializeMirrors();
    }

    return(ec);
}


ULONG
FdpDetermineDiskDescriptionSize(
    PDISKSTATE DiskState
    )

/*++

Routine Description:

    This routine takes a pointer to a disk and determines how much
    memory is needed to contain the description of the disk by
    counting the number of partitions on the disk and multiplying
    the appropriate counts by the appropriate size of the structures.

Arguments:

    DiskState - the disk in question.

Return Value:

    The memory size needed to contain all of the information on the disk.

--*/

{
    ULONG partitionCount;
    ULONG size;

    if (DiskState->OffLine) {
        return(0);
    }

    size = sizeof(DISK_DESCRIPTION);
    partitionCount = ActualPartitionCount(DiskState);
    size += (partitionCount ? partitionCount-1 : 0) * sizeof(DISK_PARTITION);

    return(size);
}


ULONG
FdpConstructDiskDescription(
    IN  PDISKSTATE        DiskState,
    OUT PDISK_DESCRIPTION DiskDescription
    )

/*++

Routine Description:

    Given a disk state pointer as input, construct the FtRegistry
    structure to describe the partitions on the disk.

Arguments:

    DiskState - the disk for which to construct the information
    DiskDescription - the memory location where the registry
                      structure is to be created.

Return Value:

    The number of partitions described in the DiskDescription.

--*/

{
    PDISKSTATE         ds = DiskState;
    ULONG              partition,
                       region;
    PREGION_DESCRIPTOR regionDescriptor;
    PDISK_PARTITION    diskPartition;
    CHAR               driveLetter;
    BOOLEAN            assignDriveLetter;
    PFT_OBJECT         ftObject;
    PFT_OBJECT_SET     ftSet;

    partition = 0;

    for (region=0; region<ds->RegionCount; region++) {

        regionDescriptor = &ds->RegionArray[region];

        if ((regionDescriptor->SysID != SYSID_UNUSED) && !IsExtended(regionDescriptor->SysID) && IsRecognizedPartition(regionDescriptor->SysID)) {

            diskPartition = &DiskDescription->Partitions[partition++];

            diskPartition->StartingOffset = FdGetExactOffset(regionDescriptor);
            diskPartition->Length = FdGetExactSize(regionDescriptor, FALSE);
            diskPartition->LogicalNumber = (USHORT)regionDescriptor->PartitionNumber;

            switch (driveLetter = PERSISTENT_DATA(regionDescriptor)->DriveLetter) {
            case NO_DRIVE_LETTER_YET:
                assignDriveLetter = TRUE;
                driveLetter = 0;
                break;
            case NO_DRIVE_LETTER_EVER:
                assignDriveLetter = FALSE;
                driveLetter = 0;
                break;
            default:
                assignDriveLetter = TRUE;
                break;
            }

            diskPartition->DriveLetter = driveLetter;
            diskPartition->FtLength.LowPart = 0;
            diskPartition->FtLength.HighPart = 0;
            diskPartition->ReservedTwoLongs[0] = 0;
            diskPartition->ReservedTwoLongs[1] = 0;
            diskPartition->Modified = TRUE;

            if (ftObject = GET_FT_OBJECT(regionDescriptor)) {
                PREGION_DESCRIPTOR tmpDescriptor;

                ftSet = ftObject->Set;

                tmpDescriptor = LocateRegionForFtObject(ftSet->Member0);

                // Only update status if member zero is present.
                // otherwise the status is know to be Orphaned or
                // needs regeneration.
#if 0

// need to do something here, but currently this does not work.

                if (tmpDescriptor) {
                ULONG          numberOfMembers;
                FT_SET_STATUS  setState;
                STATUS_CODE    status;

                    // If the partition number is zero, then this set
                    // has not been committed to the disk yet.  Only
                    // update status for existing sets.

                    if ((tmpDescriptor->PartitionNumber) &&
                        (ftSet->Status != FtSetNew) &&
                        (ftSet->Status != FtSetNewNeedsInitialization)) {
                        status = LowFtVolumeStatus(tmpDescriptor->Disk,
                                                   tmpDescriptor->PartitionNumber,
                                                   &setState,
                                                   &numberOfMembers);
                        if (status == OK_STATUS) {
                            if (ftSet->Status != setState) {

                                // Problem here - the FT driver has
                                // updated the status of the set after
                                // windisk last got the status.  Need
                                // to restart the process of building
                                // the FT information after updating
                                // the set to the new state.

                                FdftUpdateFtObjectSet(ftSet, setState);

                                // now recurse and start over

                                status =
                                FdpConstructDiskDescription(DiskState,
                                                            DiskDescription);
                                return status;
                            }
                        }
                    }
                }
#endif
                diskPartition->FtState = ftObject->State;
                diskPartition->FtType = ftSet->Type;
                diskPartition->FtGroup = (USHORT)ftSet->Ordinal;
                diskPartition->FtMember = (USHORT)ftObject->MemberIndex;
                if (assignDriveLetter && (ftObject == ftObject->Set->Member0)) {
                    diskPartition->AssignDriveLetter = TRUE;
                } else {
                    diskPartition->AssignDriveLetter = FALSE;
                }

            } else {

                diskPartition->FtState = Healthy;
                diskPartition->FtType = NotAnFtMember;
                diskPartition->FtGroup = (USHORT)(-1);
                diskPartition->FtMember = 0;
                diskPartition->AssignDriveLetter = assignDriveLetter;
            }
        }
    }

    DiskDescription->NumberOfPartitions = (USHORT)partition;
    DiskDescription->Signature = ds->Signature;
    DiskDescription->ReservedShort = 0;
    return(partition);
}


VOID
FdpRememberDisk(
    IN PDISK_DESCRIPTION DiskDescription
    )

/*++

Routine Description:

    Make a copy of a registry disk description structure for later use.

Arguments:

    DiskDescription - supplies pointer to the registry descriptor for
        the disk in question.

Return Value:

    None.

--*/

{
    PDISK_DESCRIPTION diskDescription;
    ULONG Size;

    // Only bother remembering disks with at least one partition.

    if (DiskDescription->NumberOfPartitions == 0) {

        return;
    }

    // Compute the size of the structure

    Size = sizeof(DISK_DESCRIPTION);
    if (DiskDescription->NumberOfPartitions > 1) {
        Size += (DiskDescription->NumberOfPartitions - 1) * sizeof(DISK_PARTITION);
    }

    diskDescription = Malloc(Size);
    RtlMoveMemory(diskDescription, DiskDescription, Size);

    RememberedDisks = Realloc(RememberedDisks,
                              (RememberedDiskCount + 1) * sizeof(PDISK_DESCRIPTION));
    RememberedDisks[RememberedDiskCount++] = diskDescription;

    FDLOG((2,
          "FdpRememberDisk: remembered disk %08lx, remembered count = %u\n",
          diskDescription->Signature,
          RememberedDiskCount));
}


VOID
FdpInitializeMirrors(
    VOID
    )

/*++

Routine Description:

    For each existing partition that was mirrored by the user during this Disk Manager
    session, call the FT driver to register initialization of the mirror (ie, cause
    the primary to be copied to the secondary).  Perform a similar initialization for
    each stripe set with parity created by the user.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFT_OBJECT_SET ftSet;
    PFT_OBJECT     ftMember;

    // Look through the list of FT sets for mirrored pairs and parity stripes

    for (ftSet = FtObjects; ftSet; ftSet = ftSet->Next) {

        // If the set needs initialization, or was recovered,
        // call the FT driver.

        switch (ftSet->Status) {

        case FtSetNewNeedsInitialization:

            DiskRegistryInitializeSet((USHORT)ftSet->Type,
                                      (USHORT)ftSet->Ordinal);
            ftSet->Status = FtSetInitializing;
            break;

        case FtSetRecovered:

            // Find the member that needs to be addressed.

            for (ftMember=ftSet->Members; ftMember; ftMember=ftMember->Next) {
                if (ftMember->State == Regenerating) {
                    break;
                }
            }

            DiskRegistryRegenerateSet((USHORT)ftSet->Type,
                                      (USHORT)ftSet->Ordinal,
                                      (USHORT)ftMember->MemberIndex);
            ftSet->Status = FtSetRegenerating;
            break;

        default:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdglob.h ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    fdglob.h

Abstract:

    Global data

Author:

    Ted Miller (tedm) 7-Jan-1992

Revisions:

    11-Nov-93 (bobri) double space and commit support.

--*/

// from fddata.c

extern HANDLE       hModule;
extern PBOOLEAN     IsDiskRemovable;
extern PCHAR        RemovableDiskReservedDriveLetters;
extern PDISKSTATE  *Disks;
extern ULONG        BootDiskNumber;
extern ULONG        BootPartitionNumber;
extern HANDLE       hwndFrame,
                    hwndList;

extern HBITMAP      hBitmapSmallDisk;
extern HBITMAP      hBitmapRemovableDisk;
extern HDC          hDC;
extern HFONT        hFontGraph,
                    hFontGraphBold;
extern HBRUSH       Brushes[BRUSH_ARRAY_SIZE];
extern HBRUSH       hBrushFreeLogical,
                    hBrushFreePrimary;
extern HPEN         hPenNull,
                    hPenThinSolid;
extern HCURSOR      hcurWait,
                    hcurNormal;

extern int          BrushHatches[BRUSH_ARRAY_SIZE];
extern int          BrushColors[BRUSH_ARRAY_SIZE];

extern COLORREF     AvailableColors[NUM_AVAILABLE_COLORS];
extern int          AvailableHatches[NUM_AVAILABLE_HATCHES];

extern DWORD        GraphWidth,
                    GraphHeight;
extern DWORD        BarTopYOffset,
                    BarBottomYOffset,
                    BarHeight;
extern DWORD        dxDriveLetterStatusArea;
extern DWORD        dxBarTextMargin,
                    dyBarTextLine;
extern DWORD        dxSmallDisk,
                    dySmallDisk,
                    xSmallDisk,
                    ySmallDisk;
extern DWORD        dxRemovableDisk,
                    dyRemovableDisk,
                    xRemovableDisk,
                    yRemovableDisk;
extern DWORD        BarLeftX,BarWidth;

extern PDISKSTATE   SingleSel;
extern DWORD        SingleSelIndex;

extern TCHAR        WinHelpFile[];
extern TCHAR        LanmanHelpFile[];
extern PTCHAR       HelpFile;

extern unsigned     DiskCount;

extern TCHAR        szFrame[];
extern LPTSTR       DiskN;
extern PWSTR        wszUnformatted,
                    wszNewUnformatted,
                    wszUnknown;

extern BOOL         RegistryChanged;
extern BOOL         RestartRequired;

extern BOOL         ConfigurationSearchIdleTrigger;
extern BOOL         IsLanmanNt;
extern BOOL         IsFullDoubleSpace;

// from fdstleg.c

extern HFONT        hFontStatus,
                    hFontLegend;
extern DWORD        dyLegend,
                    wLegendItem;
extern DWORD        dyStatus,
                    dyBorder;
extern TCHAR       *LegendLabels[LEGEND_STRING_COUNT];
extern BOOL         StatusBar,
                    Legend;
extern TCHAR        StatusTextStat[STATUS_TEXT_SIZE];
extern TCHAR        StatusTextSize[STATUS_TEXT_SIZE];
extern WCHAR        StatusTextDrlt[3];
extern WCHAR        StatusTextType[STATUS_TEXT_SIZE];
extern WCHAR        StatusTextVoll[STATUS_TEXT_SIZE];

// from fdlistbx.c

extern DWORD        LBCursorListBoxItem,
                    LBCursorRegion;

// from fdprof.c

extern int          ProfileWindowX,
                    ProfileWindowY,
                    ProfileWindowW,
                    ProfileWindowH;
extern BOOL         ProfileIsMaximized,
                    ProfileIsIconic;

// from fddlgs.c

extern DWORD        SelectedColor[LEGEND_STRING_COUNT];
extern DWORD        SelectedHatch[LEGEND_STRING_COUNT];

// from fdft.c

extern PFT_OBJECT_SET FtObjects;

// For CdRoms

extern ULONG          AllowCdRom;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdisk.h ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    fdisk.h

Abstract:

    Central include file for Disk Administrator

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    11-Nov-93 (bobri) added doublespace and commit support.
    2-Feb-94  (bobri) removed ArcInst dependency in build.

--*/

//#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntdskreg.h>
#include <ntddft.h>

//
// These defines are for virtualized types in partitp.h, low.h,
// fdengine.c, etc.
//
#define STATUS_CODE             NTSTATUS
#define OK_STATUS               STATUS_SUCCESS
#define RETURN_OUT_OF_MEMORY    return(STATUS_NO_MEMORY);
#define HANDLE_T                HANDLE
#define HANDLE_PT               PHANDLE
#define AllocateMemory          Malloc
#define ReallocateMemory        Realloc
#define FreeMemory              Free

#include <windows.h>

#include <stdarg.h>

#include "fdtypes.h"
#include "fdproto.h"
#include "fdconst.h"
#include "fdglob.h"
#include "fdres.h"
#include "fdiskmsg.h"
#include "fdhelpid.h"


#define PERSISTENT_DATA(region) ((PPERSISTENT_REGION_DATA)((region)->PersistentData))

#define GET_FT_OBJECT(region)   ((region)->PersistentData ? PERSISTENT_DATA(region)->FtObject : NULL)
#define SET_FT_OBJECT(region,o) (PERSISTENT_DATA(region)->FtObject = o)


#define EC(x) RtlNtStatusToDosError(x)

// assertion checking, logging

#if DBG

#define     FDASSERT(expr)  if(!(expr)) FdiskAssertFailedRoutine(#expr,__FILE__,__LINE__);
#define     FDLOG(X) FdLog X

VOID
FdLog(
    IN int   Level,
    IN PCHAR FormatString,
    ...
    );

VOID
LOG_DISK_REGISTRY(
    IN PCHAR          RoutineName,
    IN PDISK_REGISTRY DiskRegistry
    );

VOID
LOG_ONE_DISK_REGISTRY_DISK_ENTRY(
    IN PCHAR             RoutineName     OPTIONAL,
    IN PDISK_DESCRIPTION DiskDescription
    );

VOID
LOG_DRIVE_LAYOUT(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout
    );

VOID
InitLogging(
    VOID
    );

extern PVOID LogFile;

#else

#define     FDASSERT(expr)
#define     FDLOG(X)
#define     LOG_DISK_REGISTRY(x,y)
#define     LOG_ONE_DISK_REGISTRY_DISK_ENTRY(x,y)
#define     LOG_DRIVE_LAYOUT(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdmem.c ===
#include "fdisk.h"
#include <malloc.h>
#include <process.h>



PVOID
Malloc(
    IN ULONG Size
    )
{
    PVOID p;

    while((p = malloc(Size)) == NULL) {
        ConfirmOutOfMemory();
    }
    return(p);
}


PVOID
Realloc(
    IN PVOID Block,
    IN ULONG NewSize
    )
{
    PVOID p;

    if(NewSize) {
        while((p = realloc(Block,NewSize)) == NULL) {
            ConfirmOutOfMemory();
        }
    } else {

        //
        // realloc with a size of 0 is the same as free,
        // so special case that here.
        //

        free(Block);
        while((p = malloc(0)) == NULL) {
            ConfirmOutOfMemory();
        }
    }
    return(p);
}


VOID
Free(
    IN PVOID Block
    )
{
    free(Block);
}



VOID
ConfirmOutOfMemory(
    VOID
    )
{
    va_list arglist =
#ifdef _ALPHA_
    {0};      // Alpha defines va_list as a struct.  Init as such.
#else
    NULL;
#endif

    if(CommonDialog(MSG_OUT_OF_MEMORY,
                    NULL,
                    MB_ICONHAND | MB_RETRYCANCEL | MB_SYSTEMMODAL,
                    arglist) != IDRETRY) {
        exit(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdprof.c ===
#include "fdisk.h"
#include <stdio.h>


int  ProfileWindowX,
     ProfileWindowY,
     ProfileWindowW,
     ProfileWindowH;

BOOL ProfileIsMaximized,ProfileIsIconic;

#ifdef JAPAN
//Don't use IDS_APPNAME as registry key,
//because it is also used window's caption and it was localized.
CHAR SectionName[]             = "Disk Administrator";
#else
CHAR SectionName[80];
#endif

CHAR szWindowPosition[]        = "WindowPosition";
CHAR szWindowMaximized[]       = "WindowMaximized";
CHAR szWindowIconic[]          = "WindowIconic";
CHAR szWindowPosFormatString[] = "%d,%d,%d,%d";
CHAR szStatusBar[]             = "StatusBar";
CHAR szLegend[]                = "Legend";
CHAR szElementN[]              = "Element %u Color/Pattern";


VOID
WriteProfile(
    VOID
    )
{
    CHAR  SectionLocation[128], SectionMapping[128];
    HKEY  Key1, Key2;
    RECT  rc;
    CHAR  text[100],text2[100];
    int   i;
    DWORD Disposition;
    LONG  Err;


#ifdef JAPAN
//Don't use IDS_APPNAME as registry key,
//because it is also used window's caption and it was localized.
#else
    LoadStringA(hModule,IDS_APPNAME,SectionName,sizeof(SectionName));
#endif

    // Make sure that the appropriate registry keys exits:
    //
    // windisk.ini key:
    //
    Err = RegCreateKeyExA( HKEY_LOCAL_MACHINE,
                           "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\windisk.ini",
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &Key1,
                           &Disposition );

    if( Err != ERROR_SUCCESS ) {

        return;
    }

    if( Disposition == REG_CREATED_NEW_KEY ) {

        // We need to set up the registry keys for the INI mapping.
        // First, create the Disk Administrator value on the windisk.ini
        // key, which indicates the location of the key which maps
        // the Disk Administrator section.
        //
        strcpy( SectionLocation, "Software\\Microsoft\\" );
        strcat( SectionLocation, SectionName );

        strcpy( SectionMapping, "USR:" );
        strcat( SectionMapping, SectionLocation );

        Err = RegSetValueEx( Key1,
                             SectionName,
                             0,
                             REG_SZ,
                             SectionMapping,
                             strlen( SectionMapping ) + 1 );

        if( Err != ERROR_SUCCESS ) {

            RegCloseKey( Key1 );
            return;
        }

        // Now create the key to which the section mapping points:
        //
        Err = RegCreateKeyEx( HKEY_CURRENT_USER,
                              SectionLocation,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key2,
                              &Disposition );

        RegCloseKey( Key2 );
    }

    RegCloseKey( Key1 );


    // OK, the registry location is set up.  Write the initialization
    // information.
    //

    // write window position

    GetWindowRect(hwndFrame,&rc);
    wsprintf(text,
             szWindowPosFormatString,
             ProfileWindowX,
             ProfileWindowY,
             ProfileWindowW,
             ProfileWindowH
            );
    WritePrivateProfileStringA(SectionName,szWindowPosition,text,"windisk.ini");
    wsprintf(text,"%u",IsZoomed(hwndFrame));
    WritePrivateProfileStringA(SectionName,szWindowMaximized,text,"windisk.ini");
    wsprintf(text,"%u",IsIconic(hwndFrame));
    WritePrivateProfileStringA(SectionName,szWindowIconic,text,"windisk.ini");

    // status bar and legend stuff

    wsprintf(text,
             "%u",
             StatusBar
            );
    WritePrivateProfileStringA(SectionName,szStatusBar,text,"windisk.ini");

    wsprintf(text,
             "%u",
             Legend
            );
    WritePrivateProfileStringA(SectionName,szLegend,text,"windisk.ini");

    // disk graph colors/patterns

    for(i=0; i<LEGEND_STRING_COUNT; i++) {
        wsprintf(text2,szElementN,i);
        wsprintf(text,"%u/%u",BrushColors[i],BrushHatches[i]);
        WritePrivateProfileStringA(SectionName,text2,text,"windisk.ini");
    }
}


VOID
ReadProfile(
    VOID
    )
{
    CHAR text[100],text2[100];
    int  i;

#ifdef JAPAN
//Don't use IDS_APPNAME as registry key,
//because it is also used window's caption and it was localized.
#else
    LoadStringA(hModule,IDS_APPNAME,SectionName,sizeof(SectionName));
#endif

    // get the window position data

    ProfileIsMaximized = GetPrivateProfileIntA(SectionName,szWindowMaximized,0,"windisk.ini");
    ProfileIsIconic    = GetPrivateProfileIntA(SectionName,szWindowIconic   ,0,"windisk.ini");

    *text = 0;
    if(GetPrivateProfileStringA(SectionName,szWindowPosition,"",text,sizeof(text),"windisk.ini")
    && *text)
    {
        sscanf(text,
               szWindowPosFormatString,
               &ProfileWindowX,
               &ProfileWindowY,
               &ProfileWindowW,
               &ProfileWindowH
              );
    } else {
        ProfileWindowX = CW_USEDEFAULT;
        ProfileWindowY = 0;
        ProfileWindowW = CW_USEDEFAULT;
        ProfileWindowH = 0;
    }

    // status bar and legend stuff

    StatusBar = GetPrivateProfileIntA(SectionName,szStatusBar,1,"windisk.ini");
    Legend    = GetPrivateProfileIntA(SectionName,szLegend   ,1,"windisk.ini");

    // disk graph colors/patterns

    for(i=0; i<LEGEND_STRING_COUNT; i++) {
        wsprintf(text2,szElementN,i);
        *text = 0;
        if(GetPrivateProfileStringA(SectionName,text2,"",text,sizeof(text),"windisk.ini") && *text) {
            sscanf(text,"%u/%u",&BrushColors[i],&BrushHatches[i]);
            if( BrushHatches[i] >= NUM_AVAILABLE_HATCHES ) {
                    BrushHatches[i] = NUM_AVAILABLE_HATCHES - 1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdmisc.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    fdmisc.c

Abstract:

    Miscellaneous routines for NT fdisk.

Author:

    Ted Miller (tedm) 7-Jan-1992

Modifications:

    13-Dec-1993 (bobri) CdRom initialization support.

--*/


#include "fdisk.h"
#include <process.h>

extern HWND    InitDlg;
extern BOOLEAN StartedAsIcon;

BOOL
AllDisksOffLine(
    VOID
    )

/*++

Routine Description:

    Determine whether all hard disks are off line.

Arguments:

    None.

Return Value:

    TRUE if all disks off-line, false otherwise.

--*/

{
    ULONG i;

    FDASSERT(DiskCount);

    for (i=0; i<DiskCount; i++) {
        if (!IsDiskOffLine(i)) {
            return FALSE;
        }
    }
    return TRUE;
}


VOID
FdShutdownTheSystem(
    VOID
    )

/*++

Routine Description:

    This routine attempts to update the caller privilege, then shutdown the
    Windows NT system.  If it fails it prints a warning dialog.  If it
    succeeds then it doesn't return to the caller.

Arguments:

    None

Return Value:

    None

--*/

{
    NTSTATUS Status;
    BOOLEAN  PreviousPriv;

    InfoDialog(MSG_MUST_REBOOT);
    SetCursor(hcurWait);
    WriteProfile();

    // Enable shutdown privilege

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &PreviousPriv);

#if DBG
    if (Status) {
        DbgPrint("DISKMAN: Status %lx attempting to enable shutdown privilege\n",Status);
    }
#endif

    Sleep(3000);
    if (!ExitWindowsEx(EWX_REBOOT,(DWORD)(-1))) {
        WarningDialog(MSG_COULDNT_REBOOT);
    }
}


LPTSTR
LoadAString(
    IN DWORD StringID
    )

/*++

Routine Description:

    Loads a string from the resource file and allocates a buffer of exactly
    the right size to hold it.

Arguments:

    StringID - resource ID of string to load

Return Value:

    pointer to buffer.  If string is not found, the first
    (and only) char in the returned buffer will be 0.

--*/

{
    TCHAR  text[500];
    LPTSTR buffer;

    text[0] = 0;
    LoadString(hModule, StringID, text, sizeof(text)/sizeof(TCHAR));
    buffer = Malloc((lstrlen(text)+1)*sizeof(TCHAR));
    lstrcpy(buffer, text);
    return buffer;
}


PWSTR
LoadWString(
    IN DWORD StringID
    )

/*++

Routine Description:

    Loads a wide-char string from the resource file and allocates a
    buffer of exactly the right size to hold it.

Arguments:

    StringID - resource ID of string to load

Return Value:

    pointer to buffer.  If string is not found, the first
    (and only) char in the returned buffer will be 0.

--*/

{
    WCHAR text[500];
    PWSTR buffer;

    text[0] = 0;
    LoadStringW(hModule, StringID, text, sizeof(text)/sizeof(WCHAR));
    buffer = Malloc((lstrlenW(text)+1)*sizeof(WCHAR));
    lstrcpyW(buffer, text);
    return buffer;
}


int
GetHeightFromPoints(
    IN int Points
    )

/*++

Routine Description:

    This routine calculates the height of a font given a point value.
    The calculation is based on 72 points per inch and the display's
    pixels/inch device capability.

Arguments:

    Points - number of points

Return Value:

    pixel count (negative and therefore suitable for passing to
    CreateFont())

--*/

{
    HDC hdc    = GetDC(NULL);
    int height = MulDiv(-Points, GetDeviceCaps(hdc, LOGPIXELSY), 72);

    ReleaseDC(NULL, hdc);
    return height;
}


VOID
UnicodeHack(
    IN  PCHAR  Source,
    OUT LPTSTR Dest
    )

/*++

Routine Description:

    Given a non-Unicode ASCII string, this routine will either convert it
    to Unicode or copy it, depending on the current definition of TCHAR.
    The 'conversion' is a simple hack that casts to TCHAR.

Arguments:

    Source - source (ansi ascii) string
    Dest   - destination string or wide string

Return Value:

    None.

--*/

{
    int i;
    int j = lstrlen(Source);

    for (i=0; i<=j; i++) {
        Dest[i] = (TCHAR)(UCHAR)Source[i];
    }
}


VOID
_RetreiveAndFormatMessage(
    IN  DWORD   Msg,
    OUT LPTSTR  Buffer,
    IN  DWORD   BufferSize,
    IN  va_list arglist
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD x;
    TCHAR text[500];

    // get message from system or app msg file.

    x = FormatMessage( Msg >= MSG_FIRST_FDISK_MSG
                     ? FORMAT_MESSAGE_FROM_HMODULE
                     : FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL,
                       Msg,
                       0,
                       Buffer,
                       BufferSize,
                       &arglist);

    if (!x) {                // couldn't find message

        LoadString(hModule,
                   Msg >= MSG_FIRST_FDISK_MSG ? IDS_NOT_IN_APP_MSG_FILE : IDS_NOT_IN_SYS_MSG_FILE,
                   text,
                   sizeof(text)/sizeof(TCHAR));

        wsprintf(Buffer, text, Msg);
    }
}


DWORD
CommonDialog(
    IN DWORD   MsgCode,
    IN LPTSTR  Caption,
    IN DWORD   Flags,
    IN va_list arglist
    )

/*++

Routine Description:

    Simple dialog routine to get dialogs out of the resource
    for the program and run them as a message box.

Arguments:

    MsgCode - dialog message code
    Caption - message box caption
    Flags   - standard message box flags
    arglist - list to be given when pulling the message text

Return Value:

    The MessageBox() return value

--*/

{
    TCHAR   MsgBuf[MESSAGE_BUFFER_SIZE];

    if (!StartedAsIcon) {
//        Flags |= MB_SETFOREGROUND;
    }

    if (InitDlg) {

        PostMessage(InitDlg,
                    (WM_USER + 1),
                    0,
                    0);
        InitDlg = (HWND) 0;
    }
    _RetreiveAndFormatMessage(MsgCode, MsgBuf, sizeof(MsgBuf), arglist);
    return MessageBox(GetActiveWindow(), MsgBuf, Caption, Flags);
}


VOID
ErrorDialog(
    IN DWORD ErrorCode,
    ...
    )

/*++

-Routine Description:

    This routine retreives a message from the app or system message file
    and displays it in a message box.

Arguments:

    ErrorCode - number of message

    ...       - strings for insertion into message

Return Value:

    None.

--*/

{
    va_list arglist;

    va_start(arglist, ErrorCode);
    CommonDialog(ErrorCode, NULL, MB_ICONHAND | MB_OK | MB_SYSTEMMODAL, arglist);
    va_end(arglist);
}




VOID
WarningDialog(
    IN DWORD MsgCode,
    ...
    )

/*++

Routine Description:

    This routine retreives a message from the app or system message file
    and displays it in a message box.

Arguments:

    MsgCode - number of message

    ...     - strings for insertion into message

Return Value:

    None.

--*/

{
    TCHAR Caption[100];
    va_list arglist;

    va_start(arglist, MsgCode);
    LoadString(hModule, IDS_APPNAME, Caption, sizeof(Caption)/sizeof(TCHAR));
    CommonDialog(MsgCode, Caption, MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL, arglist);
    va_end(arglist);
}


DWORD
ConfirmationDialog(
    IN DWORD MsgCode,
    IN DWORD Flags,
    ...
    )

/*++

Routine Description:

    Support for a simple confirmation dialog

Arguments:

    MsgCode - resource code for message
    Flags   - dialog flags

Return Value:

    Result from the CommonDialog() performed.

--*/

{
    TCHAR Caption[100];
    DWORD x;
    va_list arglist;

    va_start(arglist, Flags);
    LoadString(hModule, IDS_CONFIRM, Caption, sizeof(Caption)/sizeof(TCHAR));
    x = CommonDialog(MsgCode, Caption, Flags | MB_TASKMODAL, arglist);
    va_end(arglist);
    return x;
}


VOID
InfoDialog(
    IN DWORD MsgCode,
    ...
    )

/*++

Routine Description:

    This routine retreives a message from the app or system message file
    and displays it in a message box.

Arguments:

    MsgCode - number of message

    ...     - strings for insertion into message

Return Value:

    None.

--*/

{
    TCHAR Caption[100];
    va_list arglist;

    va_start(arglist, MsgCode);
    LoadString(hModule, IDS_APPNAME, Caption, sizeof(Caption)/sizeof(TCHAR));
    CommonDialog(MsgCode, Caption, MB_ICONINFORMATION | MB_OK | MB_TASKMODAL, arglist);
    va_end(arglist);
}

PREGION_DESCRIPTOR
LocateRegionForFtObject(
    IN PFT_OBJECT FtObject
    )

/*++

Routine Description:

    Given an FtObject, find the associated region descriptor

Arguments:

    FtObject - the ft object to search for.

Return Value:

    NULL - no descriptor found
    !NULL - a pointer to the region descriptor for the FT object

++*/

{
    PDISKSTATE         diskState;
    PREGION_DESCRIPTOR regionDescriptor;
    DWORD              disk,
                       region;
    PPERSISTENT_REGION_DATA regionData;

    for (disk = 0; disk < DiskCount; disk++) {

        diskState = Disks[disk];

        for (region = 0; region < diskState->RegionCount; region++) {

            regionDescriptor = &diskState->RegionArray[region];
            regionData = PERSISTENT_DATA(regionDescriptor);

            if (regionData) {
                if (regionData->FtObject == FtObject) {
                    return regionDescriptor;
                }
            }
        }
    }
    return NULL;
}

VOID
InitVolumeLabelsAndTypeNames(
    VOID
    )

/*++

Routine Description:

    Determine the volume label and type name for each significant
    (non-extended, non-free, recognized) partition.

    Assumes that persistent data has already been set up, and drive letters
    determined.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD              disk,
                       region;
    PDISKSTATE         ds;
    PREGION_DESCRIPTOR rd;
    PPERSISTENT_REGION_DATA regionData;
    WCHAR              diskName[4];
    WCHAR              volumeLabel[100];
    WCHAR              typeName[100];
    UINT               errorMode;

    lstrcpyW(diskName, L"x:\\");

    for (disk=0; disk<DiskCount; disk++) {

        ds = Disks[disk];

        for (region=0; region<ds->RegionCount; region++) {

            rd = &ds->RegionArray[region];

            if (DmSignificantRegion(rd)) {

                // If the region has a drive letter, use the drive letter
                // to get the info via the Windows API.  Otherwise we'll
                // have to use the NT API.

                regionData = PERSISTENT_DATA(rd);

                if (!regionData) {
                    continue;
                }

                if ((regionData->DriveLetter == NO_DRIVE_LETTER_YET)
                ||  (regionData->DriveLetter == NO_DRIVE_LETTER_EVER)) {
                    PWSTR tempLabel,
                          tempName;

                    // No drive letter.  Use NT API.
                    // If this is an FT set use the zero member disk for the
                    // call so all members get the right type and label

                    if (regionData->FtObject) {
                        PFT_OBJECT searchFtObject;

                        // Want to get rd pointing to the zeroth member

                        searchFtObject = regionData->FtObject->Set->Member0;

                        // Now search regions for this match

                        rd = LocateRegionForFtObject(searchFtObject);

                        if (!rd) {
                            continue;
                        }
                    }

                    if (GetVolumeLabel(rd->Disk, rd->PartitionNumber, &tempLabel) == NO_ERROR) {
                        lstrcpyW(volumeLabel, tempLabel);
                        Free(tempLabel);
                    } else {
                        *volumeLabel = 0;
                    }

                    if (GetTypeName(rd->Disk, rd->PartitionNumber, &tempName) == NO_ERROR) {
                        lstrcpyW(typeName, tempName);
                        Free(tempName);
                    } else {
                        lstrcpyW(typeName, wszUnknown);
                    }

                } else {

                    // Use Windows API.

                    diskName[0] = (WCHAR)(UCHAR)regionData->DriveLetter;

                    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
                    if (!GetVolumeInformationW(diskName, volumeLabel, sizeof(volumeLabel)/2, NULL, NULL, NULL, typeName, sizeof(typeName)/2)) {
                        lstrcpyW(typeName, wszUnknown);
                        *volumeLabel = 0;
                    }
                    SetErrorMode(errorMode);
                }

                if (!lstrcmpiW(typeName, L"raw")) {
                    lstrcpyW(typeName, wszUnknown);
                }

                regionData->TypeName    = Malloc((lstrlenW(typeName)    + 1) * sizeof(WCHAR));
                regionData->VolumeLabel = Malloc((lstrlenW(volumeLabel) + 1) * sizeof(WCHAR));

                lstrcpyW(regionData->TypeName, typeName);
                lstrcpyW(regionData->VolumeLabel, volumeLabel);
            }
        }
    }
}


VOID
DetermineRegionInfo(
    IN PREGION_DESCRIPTOR Region,
    OUT PWSTR *TypeName,
    OUT PWSTR *VolumeLabel,
    OUT PWCH   DriveLetter
    )

/*++

Routine Description:

    For a given region, fetch the persistent data, appropriately modified
    depending on whether the region is used or free, recognized, etc.

Arguments:

    Region - supplies a pointer to the region whose data is to be fetched.

    TypeName - receives a pointer to the type name.  If the region is
        unrecognized, the type is determined based on the system id of
        the partition.

    VolumeLabel - receives a pointer to the volume label.  If the region is
        free space or unrecognized, the volume label is "".

    DriveLetter - receices the drive letter.  If the region is free space
        or unrecognized, the drive letter is ' ' (space).

Return Value:

    None.

--*/

{
    PWSTR typeName,
          volumeLabel;
    WCHAR driveLetter;
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(Region);

    if (DmSignificantRegion(Region)) {

        typeName = regionData->TypeName;
        volumeLabel = regionData->VolumeLabel;
        driveLetter = (WCHAR)(UCHAR)regionData->DriveLetter;
        if ((driveLetter == NO_DRIVE_LETTER_YET) || (driveLetter == NO_DRIVE_LETTER_EVER)) {
            driveLetter = L' ';
        }
    } else {
        typeName = GetWideSysIDName(Region->SysID);
        volumeLabel = L"";
        driveLetter = L' ';
    }

    *TypeName = typeName;
    *VolumeLabel = volumeLabel;
    *DriveLetter = driveLetter;
}


PREGION_DESCRIPTOR
RegionFromFtObject(
    IN PFT_OBJECT FtObject
    )

/*++

Routine Description:

    Given an ft object, determine which region it belongs to.  The algorithm
    is brute force -- look at each region on each disk until a match is found.

Arguments:

    FtObject - ft member whose region is to be located.

Return Value:

    pointer to region descriptor

--*/

{
    PREGION_DESCRIPTOR reg;
    DWORD region,
          disk;
    PDISKSTATE ds;

    for (disk=0; disk<DiskCount; disk++) {

        ds = Disks[disk];

        for (region=0; region<ds->RegionCount; region++) {

            reg = &ds->RegionArray[region];

            if (DmSignificantRegion(reg) && (GET_FT_OBJECT(reg) == FtObject)) {

                return reg;
            }
        }
    }
    return NULL;
}


//
// For each drive letter, these arrays hold the disk and partition number
// the the drive letter is linked to.
//

#define M1  ((unsigned)(-1))

unsigned
DriveLetterDiskNumbers[26]      = { M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,
                                    M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1
                                  },

DriveLetterPartitionNumbers[24] = { M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,
                                    M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1
                                  };

#undef M1

//
// Drive letter usage map.  Bit n set means that drive letter 'C'+n is in use.
//

ULONG DriveLetterUsageMap = 0;

#define     DRIVELETTERBIT(letter)  (1 << (unsigned)((UCHAR)letter-(UCHAR)'C'))

#define     SetDriveLetterUsed(letter)   DriveLetterUsageMap |= DRIVELETTERBIT(letter)
#define     SetDriveLetterFree(letter)   DriveLetterUsageMap &= (~DRIVELETTERBIT(letter))
#define     IsDriveLetterUsed(letter)    (DriveLetterUsageMap & DRIVELETTERBIT(letter))


CHAR
GetAvailableDriveLetter(
    VOID
    )

/*++

Routine Description:

    Scan the drive letter usage bitmap and return the next available
    drive letter.  May also mark the drivee letter used.

Arguments:

    None.

Return Value:

    The next available drive letter, or 0 if all are used.

--*/

{
    CHAR driveLetter;

    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
        if (!IsDriveLetterUsed(driveLetter)) {
            return driveLetter;
        }
    }
    return 0;
}


VOID
MarkDriveLetterUsed(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Given an ASCII drive letter, mark it in the usage map as being used.

Arguments:

    DriveLetter - the letter to mark

Return Value:

    None

--*/

{
    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    if ((DriveLetter != NO_DRIVE_LETTER_YET) && (DriveLetter != NO_DRIVE_LETTER_EVER)) {
        SetDriveLetterUsed(DriveLetter);
    }
}

VOID
MarkDriveLetterFree(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Given a drive letter, remove it from the usage map, thereby making it available
    for reuse.

Arguments:

    Drive Letter - the letter to free

Return Value:

    None

--*/

{
    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    if ((DriveLetter != NO_DRIVE_LETTER_YET) && (DriveLetter != NO_DRIVE_LETTER_EVER)) {
        SetDriveLetterFree(DriveLetter);
    }
}

BOOL
DriveLetterIsAvailable(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Determine if the drive letter given is available for use.

Arguments:

    DriveLetter - the letter to check in the usage map

Return Value:

    TRUE if it is free and can be used.
    FALSE if it is currently in use.

--*/

{
    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    FDASSERT((DriveLetter != NO_DRIVE_LETTER_YET) && (DriveLetter != NO_DRIVE_LETTER_EVER));
    return !IsDriveLetterUsed(DriveLetter);
}

BOOL
AllDriveLettersAreUsed(
    VOID
    )

/*++

Routine Description:

    Determine if all possible drive letters are in use.

Arguments:

    None

Return Value:

    TRUE if all letters are in use - FALSE otherwise

--*/

{
    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    return(DriveLetterUsageMap == 0x00ffffff);
}

ULONG
GetDiskNumberFromDriveLetter(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Given a drive letter return the disk number that contains the partition
    that is the drive letter.

Arguments:

    DriveLetter - the drive letter to check.

Return Value:

    -1 if the letter is invalid.
    The disk number for the drive letter if it is valid.

--*/

{
    DriveLetter = toupper( DriveLetter );

    if (DriveLetter >= 'C' && DriveLetter <= 'Z') {
        return DriveLetterDiskNumbers[ DriveLetter - 'C' ];
    } else {
        return (ULONG)(-1);
    }
}

ULONG
GetPartitionNumberFromDriveLetter(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Given a drive letter return the numeric value for the partition that
    the letter is associated with.

Arguments:

    DriveLetter - the letter in question.

Return Value:

    -1 if letter is invalid
    Partition number for partition that is the drive letter

--*/

{
    DriveLetter = toupper( DriveLetter );

    if (DriveLetter >= 'C' && DriveLetter <= 'Z') {
        return DriveLetterPartitionNumbers[ DriveLetter - 'C' ];
    } else {
        return (ULONG)(-1);
    }
}


CHAR
LocateDriveLetterFromDiskAndPartition(
    IN ULONG Disk,
    IN ULONG Partition
    )

/*++

Routine Description:

    Given a disk and partition number return the drive letter assigned to it.

Arguments:

    Disk - the disk index
    Partition - the partition index

Return Value:

    The drive letter for the specific partition or
    NO_DRIVE_LETTER_YET if it is not assigned a letter.

--*/

{
    unsigned i;

    for (i=0; i<24; i++) {

        if (Disk == DriveLetterDiskNumbers[i] &&
            Partition == DriveLetterPartitionNumbers[i]) {

            return((CHAR)(i+(unsigned)(UCHAR)'C'));
        }
    }
    return NO_DRIVE_LETTER_YET;
}

CHAR
LocateDriveLetter(
    IN PREGION_DESCRIPTOR Region
    )

/*++

Routine Description:

    Return the drive letter associated to a region.

Arguments:

    Region - the region wanted.

Return Value:

    The drive letter or NO_DRIVE_LETTER_YET

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(Region);

    if (regionData) {
        if (regionData->FtObject) {
            if (regionData->DriveLetter) {
                return regionData->DriveLetter;
            }
        }
    }

    return LocateDriveLetterFromDiskAndPartition(Region->Disk,
                                                 Region->OriginalPartitionNumber);
}


#define IsDigitW(digit)     (((digit) >= L'0') && ((digit) <= L'9'))

VOID
InitializeDriveLetterInfo(
    VOID
    )

/*++

Routine Description:

    Initialze all of the external support structures for drive letter maintainence.

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR DriveLetterW;
    CHAR  DriveLetter = '\0';
    PWSTR LinkTarget;
    WCHAR DosDevicesName[sizeof(L"\\DosDevices\\A:")];
    int   DiskNo,
          PartNo;
    PWSTR Pattern,
          String;
    DWORD x,
          ec;
    PFT_OBJECT         FtObject;
    PFT_OBJECT_SET     FtSet;
    PREGION_DESCRIPTOR Region;

    // Construct list of drives with pagefiles

    LoadExistingPageFileInfo();

    // Initialize network information.
    
    NetworkInitialize();

    // For each drive letter c-z, query the symbolic link.

    for (DriveLetterW=L'C'; DriveLetterW<=L'Z'; DriveLetterW++) {

        wsprintfW(DosDevicesName, L"%ws%wc:", L"\\DosDevices\\", DriveLetterW);

        if ((ec = GetDriveLetterLinkTarget(DosDevicesName, &LinkTarget)) == NO_ERROR) {

            // Check if it is a Cdrom

            if (_wcsnicmp(LinkTarget, L"\\Device\\CdRom", 13) == 0) {

                // Save the information on this CdRom away

                CdRomAddDevice(LinkTarget, DriveLetterW);
            }

            // The drive letter is used because it is linked to something,
            // even if we can't figure out what.  So mark it used here.

            SetDriveLetterUsed(DriveLetterW);
            CharUpperW(LinkTarget);
            Pattern = L"\\DEVICE\\HARDDISK";
            String = LinkTarget;

            // Attempt to match the '\device\harddisk' part

            for (x=0; x < (sizeof(L"\\DEVICE\\HARDDISK") / sizeof(WCHAR)) - 1; x++) {
                if (*Pattern++ != *String++) {
                    goto next_letter;
                }
            }

            // Now get the hard disk #

            if (!IsDigitW(*String)) {
                continue;
            }

            DiskNo = 0;
            while (IsDigitW(*String)) {
                DiskNo = (DiskNo * 10) + (*String - L'0');
                *String++;
            }

            // Attempt to match the '\partition' part

            Pattern = L"\\PARTITION";
            for (x=0; x < (sizeof(L"\\PARTITION") / sizeof(WCHAR)) - 1; x++) {
                if (*Pattern++ != *String++) {
                    goto next_letter;
                }
            }

            // Now get the partition #, which cannot be 0

            PartNo = 0;
            while (IsDigitW(*String)) {
                PartNo = (PartNo * 10) + (*String - L'0');
                *String++;
            }

            if (!PartNo) {
                continue;
            }

            // Make sure there is nothing left in the link target's name

            if (*String) {
                continue;
            }

            // We understand the link target. Store the disk and partition.

            DriveLetterDiskNumbers[DriveLetterW-L'C'] = DiskNo;
            DriveLetterPartitionNumbers[DriveLetterW-L'C'] = PartNo;
        } else {
            if (ec == ERROR_ACCESS_DENIED) {
                ErrorDialog(MSG_ACCESS_DENIED);

                // BUGBUG When system and workstation manager are the same
                // thing, then we'd never have gotten here.  We can't just
                // send a WM_DESTROY message to hwndFrame because we're not
                // in the message loop here -- we end up doing a bunch of
                // processing before the quit message is pulled our of the
                // queue.  So just exit.

                SendMessage(hwndFrame,WM_DESTROY,0,0);
                exit(1);
            }
        }
        next_letter:
        {}
    }

    // Now for each non-ft, significant region on each disk, figure out its
    // drive letter.

    for (x=0; x<DiskCount; x++) {

        PDISKSTATE ds = Disks[x];
        unsigned reg;

        for (reg=0; reg<ds->RegionCount; reg++) {

            PREGION_DESCRIPTOR region = &ds->RegionArray[reg];

            if (DmSignificantRegion(region)) {

                // Handle drive letters for FT sets specially.

                if (!GET_FT_OBJECT(region)) {
                    PERSISTENT_DATA(region)->DriveLetter = LocateDriveLetter(region);
                }
            }
        }

        // If this is a removable disk, record the reserved drive
        // letter for that disk.

        if (IsDiskRemovable[x]) {
            RemovableDiskReservedDriveLetters[x] = LocateDriveLetterFromDiskAndPartition(x, 1);
        } else {
            RemovableDiskReservedDriveLetters[x] = NO_DRIVE_LETTER_YET;
        }
    }

    // Now handle ft sets.  For each set, loop through the objects twice.
    // On the first pass, figure out which object actually is linked to the
    // drive letter.  On the second pass, assign the drive letter found to
    // each of the objects in the set.

    for (FtSet = FtObjects; FtSet; FtSet = FtSet->Next) {

        for (FtObject = FtSet->Members; FtObject; FtObject = FtObject->Next) {

            Region = RegionFromFtObject(FtObject);

            if (Region) {
                if ((DriveLetter = LocateDriveLetter(Region)) != NO_DRIVE_LETTER_YET) {
                    break;
                }
            }
        }

        for (FtObject = FtSet->Members; FtObject; FtObject = FtObject->Next) {

            Region = RegionFromFtObject(FtObject);

            if (Region) {
                PERSISTENT_DATA(Region)->DriveLetter = DriveLetter;
            }
        }
    }
}


#if DBG

VOID
FdiskAssertFailedRoutine(
    IN char *Expression,
    IN char *FileName,
    IN int   LineNumber
    )

/*++

Routine Description:

    Routine that is called when an assertion fails in the debug version.
    Throw up a list box giving appriopriate information and terminate
    the program.

Arguments:

    Source - source (ansi ascii) string
    Dest   - destination string or wide string

Return Value:

    None.

--*/

{
    char text[500];

    wsprintf(text,
             "Line #%u in File '%s'\n[%s]\n\nClick OK to exit.",
             LineNumber,
             FileName,
             Expression
            );

    MessageBoxA(NULL,text,"Assertion Failure",MB_TASKMODAL | MB_OK);
    exit(1);
}


#include <stdio.h>

PVOID LogFile;
int LoggingLevel = 1000;


VOID
InitLogging(
    VOID
    )

/*++

Routine Description:

    Open the log file for debug logging.

Arguments:

    None

Return Value:

    None

--*/

{
    LogFile = (PVOID)fopen("c:\\fdisk.log","wt");
    if(LogFile == NULL) {
        MessageBox(GetActiveWindow(),"Can't open log file; logging turned off","DEBUG",MB_SYSTEMMODAL|MB_OK);
        LoggingLevel = -1;
    }
}


VOID
FdLog(
    IN int   Level,
    IN PCHAR FormatString,
    ...
    )

/*++

Routine Description:

    Write a line into the log file for debugging.

Arguments:

    Debug level and "printf" like argument string.

Return Value:

    None

--*/

{
    va_list arglist;

    if(Level <= LoggingLevel) {

        va_start(arglist,FormatString);

        if(vfprintf((FILE *)LogFile,FormatString,arglist) < 0) {
            LoggingLevel = -1;
            MessageBox(GetActiveWindow(),"Error writing to log file; logging turned off","DEBUG",MB_SYSTEMMODAL|MB_OK);
            fclose((FILE *)LogFile);
        } else {
            fflush((FILE *)LogFile);
        }

        va_end(arglist);
    }
}


VOID
LOG_DISK_REGISTRY(
    IN PCHAR          RoutineName,
    IN PDISK_REGISTRY DiskRegistry
    )

/*++

Routine Description:

    Log what was in the disk registry into the debugging log file.

Arguments:

    RoutineName - calling routines name
    DiskRegistry - registry information for disks

Return Value:

    None

--*/

{
    ULONG i;
    PDISK_DESCRIPTION diskDesc;

    FDLOG((2,"%s: %u disks; registry info follows:\n",RoutineName,DiskRegistry->NumberOfDisks));

    diskDesc = DiskRegistry->Disks;

    for(i=0; i<DiskRegistry->NumberOfDisks; i++) {
        LOG_ONE_DISK_REGISTRY_DISK_ENTRY(NULL,diskDesc);
        diskDesc = (PDISK_DESCRIPTION)&diskDesc->Partitions[diskDesc->NumberOfPartitions];
    }
}


VOID
LOG_ONE_DISK_REGISTRY_DISK_ENTRY(
    IN PCHAR             RoutineName     OPTIONAL,
    IN PDISK_DESCRIPTION DiskDescription
    )

/*++

Routine Description:

    This routine walks through the partition information from
    the registry for a single disk and writes lines in the
    debugging log file.

Arguments:

    RoutineName - the name of the calling routine
    DiskDescription - the disk description portion of the registry

Return Value:

    None

--*/

{
    USHORT j;
    PDISK_PARTITION partDesc;
    PDISK_DESCRIPTION diskDesc = DiskDescription;

    if(ARGUMENT_PRESENT(RoutineName)) {
        FDLOG((2,"%s: disk registry entry follows:\n",RoutineName));
    }

    FDLOG((2,"    Disk signature : %08lx\n",diskDesc->Signature));
    FDLOG((2,"    Partition count: %u\n",diskDesc->NumberOfPartitions));
    if(diskDesc->NumberOfPartitions) {
        FDLOG((2,"    #   Dr  FtTyp  FtGrp  FtMem  Start              Length\n"));
    }

    for(j=0; j<diskDesc->NumberOfPartitions; j++) {

        CHAR dr1,dr2;

        partDesc = &diskDesc->Partitions[j];

        if(partDesc->AssignDriveLetter) {

            if(partDesc->DriveLetter) {
                dr1 = partDesc->DriveLetter;
                dr2 = ':';
            } else {
                dr1 = dr2 = ' ';
            }

        } else {
            dr1 = 'n';
            dr2 = 'o';
        }

        FDLOG((2,
               "    %02u  %c%c  %-5u  %-5u  %-5u  %08lx:%08lx  %08lx:%08lx\n",
               partDesc->LogicalNumber,
               dr1,dr2,
               partDesc->FtType,
               partDesc->FtGroup,
               partDesc->FtMember,
               partDesc->StartingOffset.HighPart,
               partDesc->StartingOffset.LowPart,
               partDesc->Length.HighPart,
               partDesc->Length.LowPart
             ));
    }
}


VOID
LOG_DRIVE_LAYOUT(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout
    )

/*++

Routine Description:

    Write the drive layout into the debugging log file.

Arguments:

    DriveLayout - the layout to write

Return Value:

    None

--*/

{
    ULONG i;

    FDLOG((2,"   Disk signature : %08lx\n",DriveLayout->Signature));
    FDLOG((2,"   Partition count: %u\n",DriveLayout->PartitionCount));

    for(i=0; i<DriveLayout->PartitionCount; i++) {

        if(!i) {
            FDLOG((2,"    ID  Active  Recog  Start              Size               Hidden\n"));
        }

        FDLOG((2,
               "    %02x  %s     %s    %08lx:%08lx  %08lx:%08lx  %08lx\n",
               DriveLayout->PartitionEntry[i].PartitionType,
               DriveLayout->PartitionEntry[i].BootIndicator ? "yes" : "no ",
               DriveLayout->PartitionEntry[i].RecognizedPartition ? "yes" : "no ",
               DriveLayout->PartitionEntry[i].StartingOffset.HighPart,
               DriveLayout->PartitionEntry[i].StartingOffset.LowPart,
               DriveLayout->PartitionEntry[i].PartitionLength.HighPart,
               DriveLayout->PartitionEntry[i].PartitionLength.LowPart,
               DriveLayout->PartitionEntry[i].HiddenSectors
             ));
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdtypes.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    fdtypes.h

Abstract:

    Support types definitions for Disk Administrator

Author:

    Ted Miller (tedm) 7-Jan-1992

Revisions:

    11-Nov-93 (bobri) double space and commit support.
    2-Feb-94  (bobri) moved ArcInst data items into this file.

--*/

// Partition data items

typedef enum { REGION_PRIMARY,
               REGION_EXTENDED,
               REGION_LOGICAL
             } REGION_TYPE;

enum {
        SYSID_UNUSED     = 0,
        SYSID_EXTENDED   = 5,
        SYSID_BIGFAT     = 6,
        SYSID_IFS        = 7
     };

//    These structures are used in doubly-linked per disk lists that
//    describe the layout of the disk.
//
//    Free spaces are indicated by entries with a SysID of 0 (note that
//    these entries don't actually appear anywhere on-disk!)
//
//    The partition number is the number the system will assign to
//    the partition in naming it.  For free spaces, this is the number
//    that the system WOULD assign to it if it was a partition.
//    The number is good only for one transaction (create or delete),
//    after which partitions must be renumbered.

struct _PERSISTENT_REGION_DATA;
typedef struct _PARTITION {
    struct _PARTITION  *Next;
    struct _PARTITION  *Prev;
    struct _PERSISTENT_REGION_DATA *PersistentData;
    LARGE_INTEGER          Offset;
    LARGE_INTEGER          Length;
    ULONG                  Disk;
    ULONG                  OriginalPartitionNumber;
    ULONG                  PartitionNumber;
    BOOLEAN                Update;
    BOOLEAN                Active;
    BOOLEAN                Recognized;
    UCHAR                  SysID;
    BOOLEAN                CommitMirrorBreakNeeded;
} PARTITION,*PPARTITION;

typedef struct _REGION_DATA {
    PPARTITION      Partition;
    LARGE_INTEGER   AlignedRegionOffset;
    LARGE_INTEGER   AlignedRegionSize;
} REGION_DATA,*PREGION_DATA;

// structure that describes an ft object (mirror, stripe component, etc).

struct _FT_OBJECT_SET;
typedef struct _FT_OBJECT {
    struct _FT_OBJECT     *Next;
    struct _FT_OBJECT_SET *Set;
    ULONG                  MemberIndex;
    FT_PARTITION_STATE     State;
} FT_OBJECT, *PFT_OBJECT;

// DoubleSpace support structure.  This is tagged off of the persistent data for
// each region.

typedef struct _DBLSPACE_DESCRIPTOR {
    struct _DBLSPACE_DESCRIPTOR *Next;
    struct _DBLSPACE_DESCRIPTOR *DblChainNext;
    ULONG   AllocatedSize;
    PCHAR   FileName;
    UCHAR   DriveLetter;
    CHAR    DriveLetterEOS;
    BOOLEAN Mounted;
    BOOLEAN ChangeMountState;
    UCHAR   NewDriveLetter;
    CHAR    NewDriveLetterEOS;
    BOOLEAN ChangeDriveLetter;
} DBLSPACE_DESCRIPTOR, *PDBLSPACE_DESCRIPTOR;

// Define the structure that is associated with each non-extended, recognized
// partition.  This structure is associated with the partition, and persists
// across region array free/get from the back end.  It is used for logical
// and ft information.

typedef struct _PERSISTENT_REGION_DATA {
    PFT_OBJECT           FtObject;
    PDBLSPACE_DESCRIPTOR DblSpace;
    PWSTR                VolumeLabel;
    PWSTR                TypeName;
    CHAR                 DriveLetter;
    BOOLEAN              VolumeExists;
} PERSISTENT_REGION_DATA, *PPERSISTENT_REGION_DATA;

typedef struct _REGION_DESCRIPTOR {
    PPERSISTENT_REGION_DATA PersistentData;
    PREGION_DATA    Reserved;
    ULONG           Disk;
    ULONG           PartitionNumber;
    ULONG           OriginalPartitionNumber;
    ULONG           SizeMB;
    REGION_TYPE     RegionType;
    BOOLEAN         Active;
    BOOLEAN         Recognized;
    UCHAR           SysID;
} REGION_DESCRIPTOR,*PREGION_DESCRIPTOR;

// params for the MinMax dialog -- used at WM_INITDIALOG time

typedef struct _MINMAXDLG_PARAMS {
    DWORD CaptionStringID;
    DWORD MinimumStringID;
    DWORD MaximumStringID;
    DWORD SizeStringID;
    DWORD MinSizeMB;
    DWORD MaxSizeMB;
    DWORD HelpContextId;
} MINMAXDLG_PARAMS,*PMINMAXDLG_PARAMS;

typedef struct _FORMAT_PARAMS {
    PREGION_DESCRIPTOR RegionDescriptor;
    PVOID   RegionData;
    BOOL    QuickFormat;
    BOOL    Cancel;
    BOOL    DoubleSpace;
    UCHAR   NewLetter;
    PUCHAR  Label;
    PUCHAR  FileSystem;
    PWSTR   DblspaceFileName;
    HWND    DialogHwnd;
    DWORD   Result;
    ULONG   TotalSpace;
    ULONG   SpaceAvailable;
    ULONG   ThreadIsDone;
} FORMAT_PARAMS, *PFORMAT_PARAMS;

typedef struct _LABEL_PARAMS {
    PREGION_DESCRIPTOR RegionDescriptor;
    LPTSTR             NewLabel;
} LABEL_PARAMS, *PLABEL_PARAMS;

typedef struct _LEFTRIGHT {
    LONG Left;
    LONG Right;
} LEFTRIGHT, *PLEFTRIGHT;


//
// Types of views that can be used for a disk bar.
// Proportional means that the amount of space taken up in the bar is
// directly proportional to the size of the partition or free space
// Equal means that all free spaces and partitions are sized equally on
// screen regardless of their actual size

typedef enum _BAR_TYPE {
    BarProportional,
    BarEqual,
    BarAuto
} BAR_TYPE, *PBAR_TYPE;

// One of these structures is associated with each item in the
// listbox.  The structure is the crux of the implementation.

typedef struct _DISKSTATE {
    DWORD               Disk;           // number of disk
    DWORD               DiskSizeMB;     // size in MB of disk
    PREGION_DESCRIPTOR  RegionArray;    // region array for disk
    DWORD               RegionCount;    // # items in region array
    PBOOLEAN            Selected;       // whether each region is selected
    PLEFTRIGHT          LeftRight;      // left/right coords of boxes in graph
    DWORD               BoxCount;       // # boxes in this disk's graph
    BOOLEAN             CreateAny;      // any creations allowed on disk
    BOOLEAN             CreatePrimary;  // allowed to create primary partition
    BOOLEAN             CreateExtended; // allowed to create extended partition
    BOOLEAN             CreateLogical;  // allowed to create logical volume
    BOOLEAN             ExistAny;       // any partitions/logicals exist
    BOOLEAN             ExistPrimary;   // primary partition(s) exist
    BOOLEAN             ExistExtended;  // extended partition exists
    BOOLEAN             ExistLogical;   // logical volume(s) exist
    HDC                 hDCMem;         // for off-screen drawing
    HBITMAP             hbmMem;         // for offscreen bitmap
    ULONG               Signature;      // unique disk registry index
    BAR_TYPE            BarType;        // how to display the disk's bar
    BOOLEAN             SigWasCreated;  // whether we had to make up a sig
    BOOLEAN             OffLine;        // FALSE if disk is accessible.
} DISKSTATE, *PDISKSTATE;

// Enum for the states in which an ft set can be.

typedef enum _FT_SET_STATUS {
    FtSetHealthy,
    FtSetBroken,
    FtSetRecoverable,
    FtSetRecovered,
    FtSetNew,
    FtSetNewNeedsInitialization,
    FtSetExtended,
    FtSetInitializing,
    FtSetRegenerating,
    FtSetInitializationFailed,
    FtSetDisabled
} FT_SET_STATUS, *PFT_SET_STATUS;

// structure that describes an ft object set (ie, mirrored pair, stripe set).

typedef struct _FT_OBJECT_SET {
    struct _FT_OBJECT_SET *Next;
    FT_TYPE                Type;
    ULONG                  Ordinal;
    PFT_OBJECT             Members;
    PFT_OBJECT             Member0;
    FT_SET_STATUS          Status;
    ULONG                  NumberOfMembers;
} FT_OBJECT_SET, *PFT_OBJECT_SET;

typedef struct _DBLSPACE_PARAMS {
    DWORD                   CaptionStringID;
    PVOID                   RegionDescriptor;
    PPERSISTENT_REGION_DATA RegionData;
    PDBLSPACE_DESCRIPTOR    DblSpace;
} DBLSPACE_PARAMS, *PDBLSPACE_PARAMS;

// CdRom support structures.

typedef struct _CDROM_DESCRIPTOR {
    struct _CDROM_DESCRIPTOR *Next;
    PWSTR   DeviceName;
    ULONG   DeviceNumber;
    WCHAR   DriveLetter;
    WCHAR   NewDriveLetter;
} CDROM_DESCRIPTOR, *PCDROM_DESCRIPTOR;

// Commit support structures

typedef struct _DRIVE_LOCKLIST {
    struct _DRIVE_LOCKLIST *Next;
    HANDLE                  LockHandle;
    ULONG                   DiskNumber;
    ULONG                   PartitionNumber;
    ULONG                   LockOnDiskNumber;
    ULONG                   UnlockOnDiskNumber;
    UCHAR                   DriveLetter;
    BOOLEAN                 RemoveOnUnlock;
    BOOLEAN                 FailOk;
    BOOLEAN                 CurrentlyLocked;
} DRIVE_LOCKLIST, *PDRIVE_LOCKLIST;

// Commit support enum for drive letter assignment

typedef enum _LETTER_ASSIGNMENT_RESULT {
    Failure = 0,
    Complete,
    MustReboot
} LETTER_ASSIGNMENT_RESULT;

// Items below used to be in fdenginp.h -- have been moved here to
// remove dependency on ArcInst project.

#define LOWPART(x)      ((x).LowPart)

#define ONE_MEG         (1024*1024)

ULONG
SIZEMB(
    IN LARGE_INTEGER ByteCount
    );

#define ENTRIES_PER_BOOTSECTOR          4

//  This structure is used to hold the information returned by the
//  get drive geometry call.

typedef struct _DISKGEOM {
    LARGE_INTEGER   Cylinders;
    ULONG           Heads;
    ULONG           SectorsPerTrack;
    ULONG           BytesPerSector;
    // These two are not part of drive geometry info, but calculated from it.
    ULONG           BytesPerCylinder;
    ULONG           BytesPerTrack;
} DISKGEOM,*PDISKGEOM;



#if DBG

#include <process.h>
char _ASRTFAILEDSTR_[256];
#define ASRT(x)   if(!(x)) { sprintf( _ASRTFAILEDSTR_,                                      \
                                      "file %s\nline %u",                                   \
                                      __FILE__,__LINE__                                     \
                                    );                                                      \
                             MessageBoxA(NULL,_ASRTFAILEDSTR_,"Assertion Failure",0);       \
                             exit(1);                                                       \
                           }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdres.h ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    fdres.h

Abstract:

    Central include file for Disk Administrator

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    11-Nov-93 (bobri) added doublespace and commit support.

--*/

// If double space is included this define should turn it on in the sources
//#define DOUBLE_SPACE_SUPPORT_INCLUDED 1

#define     IDFDISK                 1

#define     IDB_SMALLDISK           100
#define     IDB_REMOVABLE           101


// dialogs

#define     IDD_ABOUT               200
#define     IDD_MINMAX              201
#define     IDD_COLORS              202
#define     IDD_DRIVELET            203
#define     IDD_DISPLAYOPTIONS      204
#define     IDD_DBLSPACE_CREATE     205
#define     IDD_DBLSPACE_DELETE     206
#define     IDD_DBLSPACE_MOUNT      207
#define     IDD_DBLSPACE_DISMOUNT   208
#define     IDD_DBLSPACE            209
#define     IDD_PARTITIONFORMAT     210
#define     IDD_PARTITIONLABEL      211
#define     IDD_DBLSPACE_DRIVELET   212
#define     IDD_FORMATCANCEL        213
#define     IDD_DBLSPACE_CANCEL     214
#define     IDD_DBLSPACE_FULL       215
#define     IDD_CDROM               216
#define     IDD_INITIALIZING        217

// menu IDs

#define     IDM_PARTITIONCREATE     1000
#define     IDM_PARTITIONCREATEEX   1001
#define     IDM_PARTITIONDELETE     1002
#if i386
#define     IDM_PARTITIONACTIVE     1003
#endif
#define     IDM_PARTITIONLETTER     1004
#define     IDM_PARTITIONEXIT       1005
#define     IDM_SECURESYSTEM        1006
#define     IDM_PARTITIONFORMAT     1007
#define     IDM_PARTITIONLABEL      1008

#define     IDM_CONFIGMIGRATE       2000
#define     IDM_CONFIGSAVE          2001
#define     IDM_CONFIGRESTORE       2002

#define     IDM_FTESTABLISHMIRROR   3000
#define     IDM_FTBREAKMIRROR       3001
#define     IDM_FTCREATESTRIPE      3002
#define     IDM_FTCREATEVOLUMESET   3004
#define     IDM_FTRECOVERSTRIPE     3006
#define     IDM_FTCREATEPSTRIPE     3007
#define     IDM_FTEXTENDVOLUMESET   3009

#define     IDM_DBLSPACE            3100
#define     IDM_AUTOMOUNT           3101
#define     IDM_CDROM               3102

#define     IDM_OPTIONSSTATUS       4000
#define     IDM_OPTIONSLEGEND       4001
#define     IDM_OPTIONSCOLORS       4002
#define     IDM_OPTIONSDISPLAY      4003

#define     IDM_COMMIT              4100

#define     IDM_HELPCONTENTS        5000
#define     IDM_HELPSEARCH          5001
#define     IDM_HELPHELP            5002
#define     IDM_HELPABOUT           5003

#if DBG && DEVL
#define     IDM_DEBUGALLOWDELETES   10001
#endif

// accelerator keys

#define     IDM_HELP                6000

//controls

#define     IDC_MINMAX_MINLABEL     100
#define     IDC_MINMAX_MAXLABEL     101
#define     IDC_MINMAX_SIZLABEL     102
#define     IDC_MINMAX_MIN          103
#define     IDC_MINMAX_MAX          104
#define     IDC_MINMAX_SIZE         105
#define     IDC_MINMAX_SCROLL       106
#define     IDC_DBLSPACE_LETTER     107
#define     IDC_DBLSPACE_LETTER_INDICATOR 108
#define     IDC_DBLSPACE_ALLOCATED  100
#define     IDC_DBLSPACE_COMPRESSED 110
#define     IDC_DBLSPACE_SIZE       111
#define     IDC_DBLSPACE_VOLUME     112
#define     IDC_DBLSPACE_RATIO      113
#define     IDC_MOUNT_STATE         114

#define     IDC_TEXT                200
#define     IDC_NAME                201
#define     IDC_VERIFY              202
#define     IDC_FSTYPE              203
#define     IDC_PROGRESS            204
#define     IDC_GASGAUGE            205
#define     IDC_HIDE                206

#define     IDC_COLOR1              501
#define     IDC_COLOR2              502
#define     IDC_COLOR3              503
#define     IDC_COLOR4              504
#define     IDC_COLOR5              505
#define     IDC_COLOR6              506
#define     IDC_COLOR7              507
#define     IDC_COLOR8              508
#define     IDC_COLOR9              509
#define     IDC_COLOR10             510
#define     IDC_COLOR11             511
#define     IDC_COLOR12             512
#define     IDC_COLOR13             513
#define     IDC_COLOR14             514
#define     IDC_COLOR15             515
#define     IDC_COLOR16             516

#define     IDC_PATTERN1            601
#define     IDC_PATTERN2            602
#define     IDC_PATTERN3            603
#define     IDC_PATTERN4            604
#define     IDC_PATTERN5            605

#define     IDC_COLORDLGCOMBO       100

#define     IDC_DRIVELET_RBASSIGN   700
#define     IDC_DRIVELET_RBNOASSIGN 701
#define     IDC_DRIVELET_DESCR      702
#define     IDC_DRIVELET_COMBOBOX   703
#define     IDC_CDROM_NAMES         704

#define     IDC_DISK_COMBOBOX       100
#define     IDC_RESETALL            101
#define     IDC_RBPROPORTIONAL      200
#define     IDC_RBEQUAL             201
#define     IDC_RBAUTO              202


// buttons

#define     FD_IDHELP               22
#define     IDADD                   23
#define     IDDELETE                24
#define     ID_MOUNT_OR_DISMOUNT    25

// strings

#define     IDS_APPNAME             1
#define     IDS_MULTIPLEITEMS       2
#define     IDS_FREESPACE           3
#define     IDS_PARTITION           4
#define     IDS_LOGICALVOLUME       5
#define     IDS_DISKN               6
#define     IDS_CONFIRM             7
#define     IDS_NOT_IN_APP_MSG_FILE 8
#define     IDS_NOT_IN_SYS_MSG_FILE 9
#define     IDS_UNFORMATTED         10
#define     IDS_UNKNOWN             11
#define     IDS_STRIPESET           12
#define     IDS_VOLUMESET           13
#define     IDS_EXTENDEDPARTITION   14
#define     IDS_FREEEXT             15
#define     IDS_DRIVELET_DESCR      16
#define     IDS_HEALTHY             17
#define     IDS_BROKEN              18
#define     IDS_RECOVERABLE         19
#define     IDS_REGENERATED         20
#define     IDS_NEW                 21
#define     IDS_OFFLINE             22
#define     IDS_INSERT_DISK         23
#define     IDS_MEGABYTES_ABBREV    24
#define     IDS_INITIALIZING        25
#define     IDS_REGENERATING        26
#define     IDS_NO_CONFIG_INFO      27
#define     IDS_NEW_UNFORMATTED     28
#define     IDS_DISABLED            29
#define     IDS_INIT_FAILED         70

#define     IDS_CRTPART_CAPTION_P   30
#define     IDS_CRTPART_CAPTION_E   31
#define     IDS_CRTPART_CAPTION_L   32
#define     IDS_CRTPART_MIN_P       33
#define     IDS_CRTPART_MAX_P       34
#define     IDS_CRTPART_MIN_L       35
#define     IDS_CRTPART_MAX_L       36
#define     IDS_CRTPART_SIZE_P      37
#define     IDS_CRTPART_SIZE_L      38

#define     IDS_CRTSTRP_CAPTION     39
#define     IDS_CRTSTRP_MIN         40
#define     IDS_CRTSTRP_MAX         41
#define     IDS_CRTSTRP_SIZE        42

#define     IDS_CRTVSET_CAPTION     43
#define     IDS_EXPVSET_CAPTION     44
#define     IDS_CRTVSET_MIN         45
#define     IDS_CRTVSET_MAX         46
#define     IDS_CRTVSET_SIZE        47

#define     IDS_STATUS_STRIPESET    48
#define     IDS_STATUS_PARITY       49
#define     IDS_STATUS_VOLUMESET    50
#define     IDS_STATUS_MIRROR       51

#define     IDS_CRTPSTRP_CAPTION    52

#define     IDS_DLGCAP_PARITY       53
#define     IDS_DLGCAP_MIRROR       54

// these must be contigous, and kept in sync with BRUSH_xxx constants

#define     IDS_LEGEND_PRIMARY      100
#define     IDS_LEGEND_LOGICAL      101
#define     IDS_LEGEND_STRIPESET    102
#define     IDS_LEGEND_MIRROR       103
#define     IDS_LEGEND_VOLUMESET    104
#define     IDS_LEGEND_LAST         IDS_LEGEND_VOLUMESET
#define     IDS_LEGEND_FIRST        IDS_LEGEND_PRIMARY


// These are the strings for system-names other than those which are
// meaningful to NT.

#define     IDS_PARTITION_FREE      120
#define     IDS_PARTITION_XENIX1    121
#define     IDS_PARTITION_XENIX2    122
#define     IDS_PARTITION_OS2_BOOT  123
#define     IDS_PARTITION_EISA      124
#define     IDS_PARTITION_UNIX      125
#define     IDS_PARTITION_POWERPC   126


// Double space support strings

#define     IDS_DBLSPACE_DELETE     150
#define     IDS_WITH_DBLSPACE       151
#define     IDS_DBLSPACE_MOUNTED    152
#define     IDS_DBLSPACE_DISMOUNTED 153
#define     IDS_MOUNT               154
#define     IDS_DISMOUNT            155
#define     IDS_CREATING_DBLSPACE   156
#define     IDS_DBLSPACECOMPLETE    157

// format strings.

#define     IDS_QUICK_FORMAT        170
#define     IDS_PERCENTCOMPLETE     171
#define     IDS_FORMATSTATS         172
#define     IDS_FORMATCOMPLETE      173
#define     IDS_FORMAT_TITLE        174
#define     IDS_LABEL_TITLE         175

// Registry paths.

#define     IDS_SOURCE_PATH         180
#define     IDS_SOURCE_PATH_NAME    181

#if i386
#define     IDS_ACTIVEPARTITION     200
#endif


// name of rectangle custom control class

#define RECTCONTROL "RectControl"

// rectangle control styles

#define RS_PATTERN                  0x00000001
#define RS_COLOR                    0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdproto.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    fdproto.h

Abstract:

    Function prototypes.

Author:

    Ted Miller (tedm) 7-Jan-1992

Revision:

    Bob Rinne  (bobri) 2-Feb-1994
    Moved definitions from ArcInst here to get rid of dependency with
    that source project.

--*/

// stuff in fdengine.c

BOOLEAN
SignatureIsUniqueToSystem(
    IN ULONG Disk,
    IN ULONG Signature
    );

VOID
FdSetDiskSignature(
    IN ULONG Disk,
    IN ULONG Signature
    );

ULONG
FdGetDiskSignature(
    IN ULONG Disk
    );

BOOLEAN
IsDiskOffLine(
    IN ULONG Disk
    );

BOOLEAN
IsRegionCommitted(
    PREGION_DESCRIPTOR RegionDescriptor
    );

BOOLEAN
ChangeCommittedOnDisk(
    IN ULONG Disk
    );

VOID
ClearCommittedDiskInformation(
    );

// stuff in fdisk.c

LONG
MyFrameWndProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN UINT  wParam,
    IN LONG  lParam
    );

VOID
DeterminePartitioningState(
    IN OUT PDISKSTATE DiskState
    );

VOID
DrawDiskBar(
    IN PDISKSTATE DiskState
    );

VOID
AdjustMenuAndStatus(
    VOID
    );

// stuff in fdinit.c

BOOL
InitializeApp(
    VOID
    );

VOID
CreateDiskState(
    OUT PDISKSTATE *DiskState,
    IN  DWORD       Disk,
    OUT PBOOL       SignatureCreated
    );

#if DBG && DEVL

VOID
StartThread2(
    VOID
    );

#endif

VOID
DisplayInitializationMessage(
    VOID
    );

// stuff in fdlistbx.c

VOID
Selection(
    IN BOOL       MultipleSel,
    IN PDISKSTATE DiskState,
    IN DWORD      region
    );

VOID
MouseSelection(
    IN     BOOL   MultipleSel,
    IN OUT PPOINT point
    );

VOID
SubclassListBox(
    IN HWND hwnd
    );

DWORD
InitializeListBox(
    IN HWND hwndListBox
    );

VOID
ResetLBCursorRegion(
    VOID
    );

VOID
WMDrawItem(
    IN PDRAWITEMSTRUCT pDrawItem
    );

VOID
ForceLBRedraw(
    VOID
    );


// stuff in fdmisc.c

BOOL
AllDisksOffLine(
    VOID
    );

VOID
FdShutdownTheSystem(
    VOID
    );

LPTSTR
LoadAString(
    IN DWORD StringID
    );

PWSTR
LoadWString(
    IN DWORD StringID
    );

int
GetHeightFromPoints(
    IN int Points
    );

VOID
UnicodeHack(
    IN  PCHAR  Source,
    OUT LPTSTR Dest
    );

VOID
TotalRedrawAndRepaint(
    VOID
    );

DWORD
CommonDialog(
    IN DWORD   MsgCode,
    IN LPTSTR  Caption,
    IN DWORD   Flags,
    IN va_list arglist
    );

VOID
ErrorDialog(
    IN DWORD ErrorCode,
    ...
    );

VOID
WarningDialog(
    IN DWORD MsgCode,
    ...
    );

DWORD
ConfirmationDialog(
    IN DWORD MsgCode,
    IN DWORD Flags,
    ...
    );

VOID
InfoDialog(
    IN DWORD MsgCode,
    ...
    );

VOID
InitVolumeLabelsAndTypeNames(
    VOID
    );

VOID
DetermineRegionInfo(
    IN PREGION_DESCRIPTOR Region,
    OUT PWSTR *TypeName,
    OUT PWSTR *VolumeLabel,
    OUT PWCH   DriveLetter
    );

VOID
InitializeDriveLetterInfo(
    VOID
    );

CHAR
GetAvailableDriveLetter(
    VOID
    );

VOID
MarkDriveLetterUsed(
    IN CHAR DriveLetter
    );

VOID
MarkDriveLetterFree(
    IN CHAR DriveLetter
    );

BOOL
DriveLetterIsAvailable(
    IN CHAR DriveLetter
    );

BOOL
AllDriveLettersAreUsed(
    VOID
    );

ULONG
GetDiskNumberFromDriveLetter(
    IN CHAR DriveLetter
    );

ULONG
GetPartitionNumberFromDriveLetter(
    IN CHAR DriveLetter
    );

PREGION_DESCRIPTOR
LocateRegionForFtObject(
    IN PFT_OBJECT FtObject
    );

#if DBG

VOID
FdiskAssertFailedRoutine(
    IN char *Expression,
    IN char *FileName,
    IN int   LineNumber
    );

#endif


// stuff in fddlgs.c

VOID
CenterDialog(
    HWND hwnd
    );

VOID
SubclassListBox(
    IN HWND hwnd
    );

BOOL
MinMaxDlgProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN DWORD wParam,
    IN LONG  lParam
    );

BOOL
DriveLetterDlgProc(
    IN HWND  hdlg,
    IN DWORD msg,
    IN DWORD wParam,
    IN LONG  lParam
    );

BOOL
ColorDlgProc(
    IN HWND  hdlg,
    IN DWORD msg,
    IN DWORD wParam,
    IN LONG  lParam
    );

BOOL
DisplayOptionsDlgProc(
    IN HWND  hdlg,
    IN UINT  msg,
    IN DWORD wParam,
    IN LONG  lParam
    );

VOID
InitRectControl(
    VOID
    );


// Format and label support routines - dmfmifs.c

VOID
FormatPartition(
    PREGION_DESCRIPTOR RegionDescriptor
    );

VOID
LabelPartition(
    PREGION_DESCRIPTOR RegionDescriptor
    );

INT
FormatDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LONG lParam
    );

INT
LabelDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LONG lParam
    );

BOOL
CancelDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
UnloadIfsDll(
    VOID
    );

// stuff in fdmem.c

PVOID
Malloc(
    IN ULONG Size
    );

PVOID
Realloc(
    IN PVOID Block,
    IN ULONG NewSize
    );

VOID
Free(
    IN PVOID Block
    );

VOID
ConfirmOutOfMemory(
    VOID
    );


// stuff in fdstleg.c

VOID
UpdateStatusBarDisplay(
    VOID
    );

VOID
ClearStatusArea(
    VOID
    );

VOID
DrawLegend(
    IN HDC   hdc,
    IN PRECT rc
    );

VOID
DrawStatusAreaItem(
    IN PRECT  rc,
    IN HDC    hdc,
    IN LPTSTR Text,
    IN BOOL   Unicode
    );


// stuff in fdprof.c

VOID
WriteProfile(
    VOID
    );

VOID
ReadProfile(
    VOID
    );


// stuff in fdft.c

ULONG
InitializeFt(
    IN BOOL DiskSignaturesCreated
    );

ULONG
SaveFt(
    VOID
    );

VOID
FdftCreateFtObjectSet(
    IN FT_TYPE             FtType,
    IN PREGION_DESCRIPTOR *Regions,
    IN DWORD               RegionCount,
    IN FT_SET_STATUS       Status
    );

BOOL
FdftUpdateFtObjectSet(
    IN PFT_OBJECT_SET FtSet,
    IN FT_SET_STATUS  SetState
    );

VOID
FdftDeleteFtObjectSet(
    IN PFT_OBJECT_SET FtSet,
    IN BOOL           OffLineDisksOnly
    );

BOOLEAN
NewConfigurationRequiresFt(
    VOID
    );

VOID
FdftExtendFtObjectSet(
    IN OUT  PFT_OBJECT_SET      FtSet,
    IN OUT  PREGION_DESCRIPTOR* Regions,
    IN      DWORD               RegionCount
    );

DWORD
FdftNextOrdinal(
    IN FT_TYPE FtType
    );

// commit.c

VOID
FtConfigure(
    VOID
    );

VOID
CommitAssignLetterList(
    VOID
    );

VOID
CommitToAssignLetterList(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN BOOL               MoveLetter
    );

VOID
CommitAllChanges(
    IN PVOID Param
    );

VOID
CommitDeleteLockLetter(
    IN CHAR DriveLetter
    );

BOOL
CommitAllowed(
    VOID
    );


VOID
RescanDevices(
    VOID
    );

// Commit interface routines.

LETTER_ASSIGNMENT_RESULT
CommitDriveLetter(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN CHAR OldDrive,
    IN CHAR NewDrive
    );

LONG
CommitToLockList(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN BOOL               RemoveDriveLetter,
    IN BOOL               LockNow,
    IN BOOL               FailOk
    );

LONG
CommitLockVolumes(
    IN ULONG Disk
    );

LONG
CommitUnlockVolumes(
    IN ULONG   Disk,
    IN BOOLEAN FreeList
    );

VOID
CommitUpdateRegionStructures(
    VOID
    );

// windisk.c

INT
SizeDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LONG lParam
    );

extern WNDPROC OldSizeDlgProc;

DWORD
CommitChanges(
    VOID
    );

BOOLEAN
BootPartitionNumberChanged(
    PULONG OldNumber,
    PULONG NewNumber
    );

DWORD
DeletionIsAllowed(
    IN PREGION_DESCRIPTOR Region
    );

BOOL
RegisterFileSystemExtend(
    VOID
    );

// stuff in fd_nt.c

BOOLEAN
IsPagefileOnDrive(
    CHAR DriveLetter
    );

VOID
LoadExistingPageFileInfo(
    IN VOID
    );

BOOLEAN
GetVolumeSizeMB(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PULONG Size
    );

ULONG
GetVolumeTypeAndSize(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Label,
    OUT PWSTR *Type,
    OUT PULONG Size
    );

PWSTR
GetWideSysIDName(
    IN UCHAR SysID
    );

ULONG
MyDiskRegistryGet(
    OUT PDISK_REGISTRY *DiskRegistry
    );

ULONG
MasterBootCode(
    IN ULONG   Disk,
    IN ULONG   Signature,
    IN BOOLEAN SetBootCode,
    IN BOOLEAN SetSignature
    );

ULONG
UpdateMasterBootCode(
    IN ULONG   Disk
    );

ULONG
FormDiskSignature(
    VOID
    );

ULONG
GetVolumeLabel(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Label
    );

ULONG
GetTypeName(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Name
    );

BOOLEAN
IsRemovable(
    IN ULONG DiskNumber
    );

ULONG
GetDriveLetterLinkTarget(
    IN PWSTR SourceNameStr,
    OUT PWSTR *LinkTarget
    );

#if i386
VOID
MakePartitionActive(
    IN PREGION_DESCRIPTOR DiskRegionArray,
    IN ULONG              RegionCount,
    IN ULONG              RegionIndex
    );
#endif


// stuff in arrowin.c

BOOL
RegisterArrowClass(
    IN HANDLE hModule
    );


// stuff in fdhelp.c

VOID
InitHelp(
    VOID
    );

VOID
TermHelp(
    VOID
    );

VOID
Help(
    IN LONG Code
    );

VOID
DialogHelp(
    IN DWORD HelpId
    );

VOID
SetMenuItemHelpContext(
    IN LONG wParam,
    IN DWORD lParam
    );


// stuff in ftreg.c

BOOL
DoMigratePreviousFtConfig(
    VOID
    );

BOOL
DoRestoreFtConfig(
    VOID
    );

VOID
DoSaveFtConfig(
    VOID
    );


// Double Space support routines.

BOOL
DblSpaceVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    );

BOOL
DblSpaceDismountedVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    );

BOOLEAN
DblSpaceCreate(
    IN HWND  Dialog,
    IN PVOID Param
    );

VOID
DblSpaceDelete(
    IN PVOID Param
    );

VOID
DblSpaceMount(
    IN PVOID Param
    );

VOID
DblSpaceDismount(
    IN PVOID Param
    );

VOID
DblSpaceInitialize(
    VOID
    );

VOID
DblSpace(
    IN HWND  Dialog,
    IN PVOID Param
    );

PDBLSPACE_DESCRIPTOR
DblSpaceGetNextVolume(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    );

// FmIfs interface routines

BOOL
LoadIfsDll(
    VOID
    );

BOOL
FmIfsDismountDblspace(
    IN CHAR DriveLetter
    );

BOOL
FmIfsMountDblspace(
    IN PCHAR FileName,
    IN CHAR  HostDrive,
    IN CHAR  NewDrive
    );

BOOLEAN
FmIfsQueryInformation(
    IN  PWSTR       DosDriveName,
    OUT PBOOLEAN    IsRemovable,
    OUT PBOOLEAN    IsFloppy,
    OUT PBOOLEAN    IsCompressed,
    OUT PBOOLEAN    Error,
    OUT PWSTR       NtDriveName,
    IN  ULONG       MaxNtDriveNameLength,
    OUT PWSTR       CvfFileName,
    IN  ULONG       MaxCvfFileNameLength,
    OUT PWSTR       HostDriveName,
    IN  ULONG       MaxHostDriveNameLength
    );


// Cdrom interface routines.

VOID
CdRom(
    IN HWND  Dialog,
    IN PVOID Param
    );

VOID
CdRomAddDevice(
    IN PWSTR NtName,
    IN WCHAR DriveLetter
    );

//
// Macros
//

//
// BOOLEAN
// DmSignificantRegion(
//      IN PREGION_DESCRIPTOR Region
//      );
//

#define DmSignificantRegion(Region)     (((Region)->SysID != SYSID_UNUSED) \
                                     &&  (!IsExtended((Region)->SysID))    \
                                     &&  (IsRecognizedPartition((Region)->SysID)))

//
// VOID
// DmSetPersistentRegionData(
//      IN PPERSISTENT_REGION_DATA RegionData
//      );
//

#define DmSetPersistentRegionData(Region,RegionData)            \
            FdSetPersistentData((Region),(ULONG)RegionData);    \
            (Region)->PersistentData = RegionData


//
// VOID
// DmInitPersistentRegionData(
//      OUT PPERSISTENT_REGION_DATA RegionData,
//      IN  PFT_OBJECT ftObject,
//      IN  PWSTR volumeLabel,
//      IN  PWSTR typeName,
//      IN  CHAR driveLetter,
//      );
//

#define DmInitPersistentRegionData(RegionData,ftObject,volumeLabel,typeName,driveLetter) \
            RegionData->DblSpace    = NULL;             \
            RegionData->FtObject    = ftObject;         \
            RegionData->VolumeLabel = volumeLabel;      \
            RegionData->TypeName    = typeName;         \
            RegionData->VolumeExists = FALSE;           \
            RegionData->DriveLetter = driveLetter

// ntlow definitions

STATUS_CODE
LowOpenNtName(
    IN PCHAR     Name,
    IN HANDLE_PT Handle
    );

STATUS_CODE
LowOpenDisk(
    IN  PCHAR       DevicePath,
    OUT HANDLE_PT   DiskId
    );

STATUS_CODE
LowOpenPartition(
    IN  PCHAR       DevicePath,
    IN  ULONG       Partition,
    OUT HANDLE_PT   Handle
    );

STATUS_CODE
LowOpenDriveLetter(
    IN CHAR      DriveLetter,
    IN HANDLE_PT Handle
    );

STATUS_CODE
LowCloseDisk(
    IN  HANDLE_T    DiskId
    );

STATUS_CODE
LowGetDriveGeometry(
    IN  PCHAR   DevicePath,
    OUT PULONG  TotalSectorCount,
    OUT PULONG  SectorSize,
    OUT PULONG  SectorsPerTrack,
    OUT PULONG  Heads
    );

STATUS_CODE
LowGetPartitionGeometry(
    IN  PCHAR   PartitionPath,
    OUT PULONG  TotalSectorCount,
    OUT PULONG  SectorSize,
    OUT PULONG  SectorsPerTrack,
    OUT PULONG  Heads
    );

STATUS_CODE
LowReadSectors(
    IN  HANDLE_T    VolumeId,
    IN  ULONG       SectorSize,
    IN  ULONG       StartingSector,
    IN  ULONG       NumberOfSectors,
    OUT PVOID       Buffer
    );

STATUS_CODE
LowWriteSectors(
    IN  HANDLE_T    VolumeId,
    IN  ULONG       SectorSize,
    IN  ULONG       StartingSector,
    IN  ULONG       NumberOfSectors,
    IN  PVOID       Buffer
    );

STATUS_CODE
LowLockDrive(
    IN HANDLE_T DiskId
    );

STATUS_CODE
LowUnlockDrive(
    IN HANDLE_T DiskId
    );

STATUS_CODE
LowFtVolumeStatus(
    IN ULONG          Disk,
    IN ULONG          Partition,
    IN PFT_SET_STATUS FtStatus,
    IN PULONG         NumberOfMembers
    );

STATUS_CODE
LowFtVolumeStatusByLetter(
    IN CHAR           DriveLetter,
    IN PFT_SET_STATUS FtStatus,
    IN PULONG         NumberOfMembers
    );

STATUS_CODE
LowSetDiskLayout(
    IN PCHAR                     Path,
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout
    );

STATUS_CODE
LowGetDiskLayout(
    IN  PCHAR                      Path,
    OUT PDRIVE_LAYOUT_INFORMATION *DriveLayout
    );

// Partition engine definitions

ULONG
GetDiskCount(
    VOID
    );

PCHAR
GetDiskName(
    ULONG Disk
    );

ULONG
DiskSizeMB(
    IN ULONG Disk
    );

STATUS_CODE
GetDiskRegions(
    IN  ULONG               Disk,
    IN  BOOLEAN             WantUsedRegions,
    IN  BOOLEAN             WantFreeRegions,
    IN  BOOLEAN             WantPrimaryRegions,
    IN  BOOLEAN             WantLogicalRegions,
    OUT PREGION_DESCRIPTOR *Region,
    OUT ULONG              *RegionCount
    );

#define GetAllDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,TRUE,TRUE,TRUE,regions,count)

#define GetFreeDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,FALSE,TRUE,TRUE,TRUE,regions,count)

#define GetUsedDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,FALSE,TRUE,TRUE,regions,count)

#define GetPrimaryDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,TRUE,TRUE,FALSE,regions,count)

#define GetLogicalDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,TRUE,FALSE,TRUE,regions,count)

#define GetUsedPrimaryDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,FALSE,TRUE,FALSE,regions,count)

#define GetUsedLogicalDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,FALSE,FALSE,TRUE,regions,count)

#define GetFreePrimaryDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,FALSE,TRUE,TRUE,FALSE,regions,count)

#define GetFreeLogicalDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,FALSE,TRUE,FALSE,TRUE,regions,count)

VOID
FreeRegionArray(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              RegionCount
    );

STATUS_CODE
IsAnyCreationAllowed(
    IN  ULONG    Disk,
    IN  BOOLEAN  AllowMultiplePrimaries,
    OUT PBOOLEAN AnyAllowed,
    OUT PBOOLEAN PrimaryAllowed,
    OUT PBOOLEAN ExtendedAllowed,
    OUT PBOOLEAN LogicalAllowed
    );

STATUS_CODE
IsCreationOfPrimaryAllowed(
    IN  ULONG    Disk,
    IN  BOOLEAN  AllowMultiplePrimaries,
    OUT PBOOLEAN Allowed
    );

STATUS_CODE
IsCreationOfExtendedAllowed(
    IN  ULONG    Disk,
    OUT PBOOLEAN Allowed
    );

STATUS_CODE
IsCreationOfLogicalAllowed(
    IN  ULONG    Disk,
    OUT PBOOLEAN Allowed
    );

STATUS_CODE
DoesAnyPartitionExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN AnyExists,
    OUT PBOOLEAN PrimaryExists,
    OUT PBOOLEAN ExtendedExists,
    OUT PBOOLEAN LogicalExists
    );

STATUS_CODE
DoesAnyPrimaryExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN Exists
    );

STATUS_CODE
DoesExtendedExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN Exists
    );

STATUS_CODE
DoesAnyLogicalExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN Exists
    );

BOOLEAN
IsExtended(
    IN UCHAR SysID
    );

VOID
SetPartitionActiveFlag(
    IN PREGION_DESCRIPTOR Region,
    IN UCHAR              value
    );

STATUS_CODE
CreatePartition(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        Type
    );

STATUS_CODE
CreatePartitionEx(
    IN PREGION_DESCRIPTOR Region,
    IN LARGE_INTEGER      MinimumSize,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        Type,
    IN UCHAR              SysId
    );

STATUS_CODE
DeletePartition(
    IN PREGION_DESCRIPTOR Region
    );

ULONG
GetHiddenSectorCount(
    ULONG Disk,
    ULONG Partition
    );

VOID
SetSysID(
    IN ULONG Disk,
    IN ULONG Partition,
    IN UCHAR SysID
    );

VOID
SetSysID2(
    IN PREGION_DESCRIPTOR Region,
    IN UCHAR              SysID
    );

PCHAR
GetSysIDName(
    UCHAR SysID
    );

STATUS_CODE
CommitPartitionChanges(
    IN ULONG Disk
    );

BOOLEAN
HavePartitionsBeenChanged(
    IN ULONG Disk
    );

VOID
FdMarkDiskDirty(
    IN ULONG Disk
    );

VOID
FdSetPersistentData(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              Data
    );

ULONG
FdGetMinimumSizeMB(
    IN ULONG Disk
    );

ULONG
FdGetMaximumSizeMB(
    IN PREGION_DESCRIPTOR Region,
    IN REGION_TYPE        CreationType
    );

LARGE_INTEGER
FdGetExactSize(
    IN PREGION_DESCRIPTOR Region,
    IN BOOLEAN            ForExtended
    );

LARGE_INTEGER
FdGetExactOffset(
    IN PREGION_DESCRIPTOR Region
    );

BOOLEAN
FdCrosses1024Cylinder(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        RegionType
    );

ULONG
FdGetDiskSignature(
    IN ULONG Disk
    );

VOID
FdSetDiskSignature(
    IN ULONG Disk,
    IN ULONG Signature
    );

BOOLEAN
IsDiskOffLine(
    IN ULONG Disk
    );


STATUS_CODE
FdiskInitialize(
    VOID
    );

VOID
FdiskCleanUp(
    VOID
    );

VOID
ConfigureSystemPartitions(
    VOID
    );


VOID
ConfigureOSPartitions(
    VOID
    );

// Network support function definitions.  stuff from network.c

VOID
NetworkRemoveShare(
    IN LPCTSTR DriveLetter
    );

VOID
NetworkShare(
    IN LPCTSTR DriveLetter
    );

VOID
NetworkInitialize(
    );

// Debugging support for opens

#ifdef DBG

NTSTATUS
DmOpenFile(
    OUT PHANDLE           FileHandle,
    IN ACCESS_MASK        DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK  IoStatusBlock,
    IN ULONG              ShareAccess,
    IN ULONG              OpenOptions
    );

NTSTATUS
DmClose(
    IN HANDLE Handle
    );
#else
#define DmOpenFile NtOpenFile
#define DmClose    NtClose
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdlistbx.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fdlistbx.c

Abstract:

    Routines for handling the subclassed owner-draw listbox used by NT fdisk
    to display the state of attached disks.

Author:

    Ted Miller (tedm) 7-Jan-1992

--*/

#include "fdisk.h"

// constants used when listbox or its focus rectangle is
// scrolled/moved.

#define    DIR_NONE     0
#define    DIR_UP       1
#define    DIR_DN       2

// original window procedure for our subclassed listbox

WNDPROC OldListBoxProc;

// item which has focus

DWORD LBCursorListBoxItem,LBCursorRegion;

BOOL LBCursorOn = FALSE;

VOID
ToggleLBCursor(
    IN HDC hdc
    );

VOID
ToggleRegion(
    IN PDISKSTATE DiskState,
    IN DWORD      RegionIndex,
    IN HDC        hdc
    );

LONG
ListBoxSubProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    This routine is the window procedure used for our subclassed listbox.
    We subclass the listbox so that we can handle keyboard input processing.
    All other messages are passed through to the original listbox procedure.

    Significant keys are arrows, pageup/dn, tab, space, return, home, and end.
    Control may be used to modify space and return.
    Shift may be used to modify tab.

Arguments:

    hwnd    - window handle of listbox

    msg     - message #

    wParam  - user param # 1

    lParam  - user param # 2

Return Value:

    see below

--*/

{
    int        focusDir = DIR_NONE;
    USHORT     vKey;
    DWORD      maxRegion;
    PDISKSTATE diskState;
    LONG       topItem,
               bottomWholeItem,
               visibleItems;
    RECT       rc;

    switch (msg) {

    case WM_CHAR:

        break;

    case WM_KEYDOWN:

        switch (vKey = LOWORD(wParam)) {
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:

            ToggleLBCursor(NULL);
            switch (vKey) {
            case VK_LEFT:
                LBCursorRegion = LBCursorRegion ? LBCursorRegion-1 : 0;
                break;
            case VK_RIGHT:
                maxRegion = Disks[LBCursorListBoxItem]->RegionCount - 1;
                if (LBCursorRegion < maxRegion) {
                    LBCursorRegion++;
                }
                break;
            case VK_UP:
                if (LBCursorListBoxItem) {
                    LBCursorListBoxItem--;
                    LBCursorRegion = 0;
                    focusDir = DIR_UP;
                }
                break;
            case VK_DOWN:
                if (LBCursorListBoxItem < DiskCount-1) {
                    LBCursorListBoxItem++;
                    LBCursorRegion = 0;
                    focusDir = DIR_DN;
                }
                break;
            }

            // don't allow list box cursor to fall on extended partition

            diskState = Disks[LBCursorListBoxItem];
            maxRegion = diskState->RegionCount - 1;
            if (IsExtended(diskState->RegionArray[LBCursorRegion].SysID)) {
                if (LBCursorRegion && ((vKey == VK_LEFT) || (LBCursorRegion == maxRegion))) {
                    LBCursorRegion--;
                } else {
                    LBCursorRegion++;
                }
            }

            ToggleLBCursor(NULL);
            break;

        case VK_TAB:

            ToggleLBCursor(NULL);

            if (GetKeyState(VK_SHIFT) & ~1) {    // shift-tab
                LBCursorListBoxItem--;
                focusDir = DIR_UP;
            } else {
                LBCursorListBoxItem++;
                focusDir = DIR_DN;
            }
            if (LBCursorListBoxItem == (DWORD)(-1)) {
                LBCursorListBoxItem = DiskCount-1;
                focusDir = DIR_DN;
            } else if (LBCursorListBoxItem == DiskCount) {
                LBCursorListBoxItem = 0;
                focusDir = DIR_UP;
            }
            ResetLBCursorRegion();

            ToggleLBCursor(NULL);
            break;

        case VK_HOME:
        case VK_END:

            ToggleLBCursor(NULL);
            topItem = (vKey == VK_HOME) ? 0 : DiskCount-1;
            SendMessage(hwndList, LB_SETTOPINDEX, (DWORD)topItem, 0);
            LBCursorListBoxItem = topItem;
            ResetLBCursorRegion();
            ToggleLBCursor(NULL);
            break;

        case VK_PRIOR:
        case VK_NEXT:

            ToggleLBCursor(NULL);
            topItem = SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
            GetClientRect(hwndList,&rc);
            visibleItems = (rc.bottom - rc.top) / GraphHeight;
            if (!visibleItems) {
                visibleItems = 1;
            }
            topItem = (vKey == VK_PRIOR)
                    ? max(topItem - visibleItems, 0)
                    : min(topItem + visibleItems, (LONG)DiskCount-1);
            SendMessage(hwndList, LB_SETTOPINDEX, (DWORD)topItem, 0);
            LBCursorListBoxItem = SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
            ResetLBCursorRegion();
            ToggleLBCursor(NULL);
            break;


        case VK_RETURN:
        case VK_SPACE:

            // Select the region that currently has the list box selection cursor.

            if (!Disks[LBCursorListBoxItem]->OffLine) {

                Selection(GetKeyState(VK_CONTROL) & ~1,     // strip toggle bit
                          Disks[LBCursorListBoxItem],
                          LBCursorRegion);
            }
            break;
        }

        // now scroll the newly focused item into view if necessary

        switch (focusDir) {
        case DIR_UP:
            if (LBCursorListBoxItem < (DWORD)SendMessage(hwndList, LB_GETTOPINDEX, 0, 0)) {
                SendMessage(hwndList, LB_SETTOPINDEX, LBCursorListBoxItem, 0);
            }
            break;
        case DIR_DN:
            GetClientRect(hwndList, &rc);
            topItem = SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
            bottomWholeItem = topItem + ((rc.bottom - rc.top) / GraphHeight) - 1;
            if (bottomWholeItem < topItem) {
                bottomWholeItem = topItem;
            }
            if ((DWORD)bottomWholeItem > DiskCount-1) {
                bottomWholeItem = DiskCount-1;
            }
            if (LBCursorListBoxItem > (DWORD)bottomWholeItem) {
                SendMessage(hwndList,
                            LB_SETTOPINDEX,
                            topItem + LBCursorListBoxItem - bottomWholeItem,
                            0);
            }
            break;
        }
        break;

    default:
        return CallWindowProc(OldListBoxProc, hwnd, msg, wParam, lParam);
    }
    return 0;
}

VOID
SubclassListBox(
    IN HWND hwnd
    )
{
    OldListBoxProc = (WNDPROC)GetWindowLong(hwnd, GWL_WNDPROC);
    SetWindowLong(hwnd, GWL_WNDPROC, (LONG)ListBoxSubProc);

    // There is a scantily documented 'feature' of a listbox wherein it will
    // use its parent's DC.  This means that drawing is not always clipped to
    // the client area of the listbox.  Seeing as we're subclassing listboxes
    // anyway, take care of this here.

    SetClassLong(hwnd, GCL_STYLE, GetClassLong(hwnd, GCL_STYLE) & ~CS_PARENTDC);
}

VOID
DeselectSelectedRegions(
    VOID
    )

/*++

Routine Description:

    This routine visually unselects all selected regions.  The selection
    state is also updated in the master disk structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD      i,
               j;
    PDISKSTATE diskState;

    for (i=0; i<DiskCount; i++) {
        diskState = Disks[i];
        for (j=0; j<diskState->RegionCount; j++) {
            if (diskState->Selected[j]) {
                diskState->Selected[j] = FALSE;
                ToggleRegion(diskState, j, NULL);
            }
        }
    }
}

VOID
Selection(
    IN BOOL       MultipleSel,
    IN PDISKSTATE DiskState,
    IN DWORD      RegionIndex
    )

/*++

Routine Description:

    This routine handles a user selection of a disk region.  It is called
    directly for a keyboard selection or indirectly for a mouse selection.
    If not a multiple selection, all selected regions are deselected.
    The focus rectangle is moved to the selected region, which is then
    visually selected.

Arguments:

    MultipleSel - whether the user has made a multiple selection
                  (ie, control-clicked).

    DiskState - master disk structure for disk containing selected region

    RegionIndex - index of selected region on the disk

Return Value:

    None.

--*/

{
    PFT_OBJECT     ftObject,
                   ftObj;
    PFT_OBJECT_SET ftSet;
    ULONG          disk,
                   r;

    if (!MultipleSel) {

        // need to deselect all selected regions first.

        DeselectSelectedRegions();
    }

    // remove the list box selection cursor from its previous region

    ToggleLBCursor(NULL);

    // The selected region might be part of an ft object set.  If it is,
    // scan each region in each disk and select each item in the set.

    if (ftObject = GET_FT_OBJECT(&DiskState->RegionArray[RegionIndex])) {

        ftSet = ftObject->Set;
        for (disk=0; disk<DiskCount; disk++) {
            PDISKSTATE diskState = Disks[disk];

            for (r=0; r<diskState->RegionCount; r++) {
                PREGION_DESCRIPTOR regionDescriptor = &diskState->RegionArray[r];

                if (DmSignificantRegion(regionDescriptor)) {

                    if (ftObj = GET_FT_OBJECT(regionDescriptor)) {

                        if (ftObj->Set == ftSet) {

                            diskState->Selected[r] = (BOOLEAN)(!diskState->Selected[r]);
                            ToggleRegion(diskState, r, NULL);
                        }
                    }
                }
            }
        }
    } else {
        DiskState->Selected[RegionIndex] = (BOOLEAN)(!DiskState->Selected[RegionIndex]);
        ToggleRegion(DiskState, RegionIndex, NULL);
    }

    LBCursorListBoxItem = DiskState->Disk;
    LBCursorRegion      = RegionIndex;
    ToggleLBCursor(NULL);
    AdjustMenuAndStatus();
}

VOID
MouseSelection(
    IN     BOOL   MultipleSel,
    IN OUT PPOINT Point
    )

/*++

Routine Description:

    This routine is called when the user clicks in the list box.  It determines
    which disk region the user has clicked on before calling the common
    selection subroutine.

Arguments:

    MultipleSel - whether the user has made a multiple selection
                  (ie, control-clicked).

    point - screen coords of the click

Return Value:

    None.

--*/

{
    PDISKSTATE  diskState;
    DWORD       selectedItem;
    DWORD       x,
                y;
    DWORD       i;
    RECT        rc;
    BOOL        valid;

    if ((selectedItem = SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR) {
        return;
    }

    // user has clicked on a list box item.

    diskState = Disks[selectedItem];

    // Ignore clicks on off-line disks.

    if (diskState->OffLine) {
        return;
    }

    ScreenToClient(hwndList, Point);

    x = Point->x;
    y = Point->y;
    GetClientRect(hwndList,&rc);

    // first make sure that the click was within a bar and not in space
    // between two bars

    for (valid=FALSE, i=rc.top; i<=(DWORD)rc.bottom; i+=GraphHeight) {
        if ((y >= i+BarTopYOffset) && (y <= i+BarBottomYOffset)) {
            valid = TRUE;
            break;
        }
    }
    if (!valid) {
        return;
    }

    // determine which region he has clicked on

    for (i=0; i<diskState->RegionCount; i++) {
        if ((x >= (unsigned)diskState->LeftRight[i].Left) && (x <= (unsigned)diskState->LeftRight[i].Right)) {
            break;
        }
    }
    if (i == diskState->RegionCount) {
        return;     // region not found.  Ignore the click.
    }

    Selection(MultipleSel, diskState, i);
}

LONG
CalcBarTop(
    DWORD Bar
    )

/*++

Routine Description:

    This routine calculates the current top y coord of a given bar.
    The value is in listbox client coords.

Arguments:

    Bar - # of bar whose position is desired

Return Value:

    Y-coord, or -1 if bar is not visible.

--*/

{
    LONG  barDelta = (LONG)Bar - SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
    LONG  pos = -1;
    RECT  rc;

    if (barDelta >= 0) {                 // BUGBUG check bottom too
        GetClientRect(hwndList,&rc);
        pos = rc.top + (barDelta * GraphHeight);
    }
    return pos;
}

VOID
ResetLBCursorRegion(
    VOID
    )

/*++

Routine Description:

    This routine resets the list box focus cursor to the 0th (leftmost)
    region on the current disk.  If the 0th region is the extended
    partition, focus is set to the first logical volume or free space
    with the extended partition instead.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PDISKSTATE diskState = Disks[LBCursorListBoxItem];
    unsigned   i;

    LBCursorRegion = 0;
    if (IsExtended(diskState->RegionArray[LBCursorRegion].SysID)) {
        for (i=0; i<diskState->RegionCount; i++) {
            if (diskState->RegionArray[i].RegionType == REGION_LOGICAL) {
                LBCursorRegion = i;
                return;
            }
        }
        FDASSERT(0);
    }
}

VOID
ToggleLBCursor(
    IN HDC hdc
    )

/*++

Routine Description:

    This routine visually toggles the focus state of the disk region
    described by the LBCursorListBoxItem and LBCursorRegion globals.

Arguments:

    hdc - If non-NULL, device context to use for drawing.  If NULL,
          we'll first get a DC via GetDC().

Return Value:

    None.

--*/

{
    PDISKSTATE lBCursorDisk = Disks[LBCursorListBoxItem];
    LONG       barTop = CalcBarTop(LBCursorListBoxItem);
    RECT       rc;
    HDC        hdcActual;

    if (barTop != -1) {

        hdcActual = hdc ? hdc : GetDC(hwndList);

        LBCursorOn = !LBCursorOn;

        rc.left   = lBCursorDisk->LeftRight[LBCursorRegion].Left;
        rc.right  = lBCursorDisk->LeftRight[LBCursorRegion].Right + 1;
        rc.top    = barTop + BarTopYOffset;
        rc.bottom = barTop + BarBottomYOffset;

        FrameRect(hdcActual,
                  &rc,
                  GetStockObject(LBCursorOn ? WHITE_BRUSH : BLACK_BRUSH));

        if (LBCursorOn) {

            // BUGBUG really want a dotted line.
            DrawFocusRect(hdcActual, &rc);
        }

        if (!hdc) {
            ReleaseDC(hwndList, hdcActual);
        }
    }
}

VOID
ForceLBRedraw(
    VOID
    )

/*++

Routine Description:

    This routine forces redraw of the listbox by invalidating its
    entire client area.

Arguments:

    None.

Return Value:

    None.

--*/

{
    InvalidateRect(hwndList,NULL,FALSE);
    UpdateWindow(hwndList);
}

VOID
ToggleRegion(
    IN PDISKSTATE DiskState,
    IN DWORD      RegionIndex,
    IN HDC        hdc
    )

/*++

Routine Description:

    This routine visually toggles the selection state of a given disk region.

Arguments:

    DiskState - master structure for disk containing region to select

    RegionIndex - which region on the disk to toggle

    hdc - if non-NULL, device context to use for drawing.  If NULL, we'll
          first get a device context via GetDC().


Return Value:

    None.

--*/

{
    PLEFTRIGHT leftRight = &DiskState->LeftRight[RegionIndex];
    LONG       barTop    = CalcBarTop(DiskState->Disk);  // BUGBUG disk# as lb index#
    BOOL       selected  = (BOOL)DiskState->Selected[RegionIndex];
    HBRUSH     hbr       = GetStockObject(BLACK_BRUSH);
    HDC        hdcActual;
    RECT       rc;
    int        i;

    if (barTop != -1) {

        hdcActual = hdc ? hdc : GetDC(hwndList);

        rc.left   = leftRight->Left + 1;
        rc.right  = leftRight->Right;
        rc.top    = barTop + BarTopYOffset + 1;
        rc.bottom = barTop + BarBottomYOffset - 1;

        if (selected) {

            for (i=0; i<SELECTION_THICKNESS; i++) {
                FrameRect(hdcActual, &rc, hbr);
                InflateRect(&rc, -1, -1);
            }

        } else {

            // Blt the region from the off-screen bitmap onto the
            // screen.  But first exclude the center of the region
            // from the clip region so we only blt the necessary bits.
            // This sppeds up selections noticably.

            InflateRect(&rc, -SELECTION_THICKNESS, -SELECTION_THICKNESS);
            ExcludeClipRect(hdcActual, rc.left, rc.top, rc.right, rc.bottom);
            BitBlt(hdcActual,
                   leftRight->Left,
                   barTop + BarTopYOffset,
                   leftRight->Right - leftRight->Left,
                   barTop + BarBottomYOffset,
                   DiskState->hDCMem,
                   leftRight->Left,
                   BarTopYOffset,
                   SRCCOPY);
        }

        if (!hdc) {
            ReleaseDC(hwndList, hdcActual);
        }
    }
}

DWORD
InitializeListBox(
    IN HWND  hwndListBox
    )

/*++

Routine Description:

    This routine sets up the list box.  This includes creating disk state
    structures, drawing the graphs for each disk off screen, and adding the
    disks to the list box.

    It also includes determining the initial volume labels and type names
    for all significant partitions.

Arguments:

    hwndListBox - handle of the list box that will hold the disk graphs

Return Value:

    Windows error code (esp. out of memory)

--*/

{
    PPERSISTENT_REGION_DATA regionData;
    TCHAR                   windowsDir[MAX_PATH];
    unsigned                i;
    PDISKSTATE              diskState;
    DWORD                   ec;
    ULONG                   r;
    BOOL                    diskSignaturesCreated,
                            temp;

    // First, create the array that will hold the diskstates,
    // the IsDiskRemovable array and the RemovableDiskReservedDriveLetters
    // array.

    Disks = Malloc(DiskCount * sizeof(PDISKSTATE));
    IsDiskRemovable = (PBOOLEAN)Malloc(DiskCount * sizeof(BOOLEAN));
    RemovableDiskReservedDriveLetters = (PCHAR)Malloc(DiskCount * sizeof(CHAR));

    // Determine which disks are removable and which are unpartitioned.

    for (i=0; i<DiskCount; i++) {

        IsDiskRemovable[i] = IsRemovable( i );
    }

    // next, create all disk states

    FDASSERT(DiskCount);
    diskSignaturesCreated = FALSE;
    for (i=0; i<DiskCount; i++) {

        // first create the disk state structure

        CreateDiskState(&diskState, i, &temp);
        diskSignaturesCreated = diskSignaturesCreated || temp;

        Disks[i] = diskState;

        // next determine the state of the disk's partitioning scheme

        DeterminePartitioningState(diskState);

        // Next create a blank logical disk structure for each region.

        for (r=0; r<diskState->RegionCount; r++) {
            if (DmSignificantRegion(&diskState->RegionArray[r])) {
                regionData = Malloc(sizeof(PERSISTENT_REGION_DATA));
                DmInitPersistentRegionData(regionData, NULL, NULL, NULL, NO_DRIVE_LETTER_YET);
                regionData->VolumeExists = TRUE;
            } else {
                regionData = NULL;
            }
            DmSetPersistentRegionData(&diskState->RegionArray[r], regionData);
        }

        // add the item to the listbox

        while (((ec = SendMessage(hwndListBox, LB_ADDSTRING, 0, 0)) == LB_ERR) || (ec == LB_ERRSPACE)) {
            ConfirmOutOfMemory();
        }
    }

    // Read the configuration registry

    if ((ec = InitializeFt(diskSignaturesCreated)) != NO_ERROR) {
        ErrorDialog(ec);
        return ec;
    }

    // Determine drive letter mappings

    InitializeDriveLetterInfo();

    // Determine volume labels and type names.

    InitVolumeLabelsAndTypeNames();

    // Determine which disk is the boot disk.

    if (GetWindowsDirectory(windowsDir, sizeof(windowsDir)/sizeof(TCHAR)) < 2 ||
        windowsDir[1] != TEXT(':')) {

        BootDiskNumber = (ULONG)-1;
        BootPartitionNumber = (ULONG)-1;
    } else {
        BootDiskNumber = GetDiskNumberFromDriveLetter((CHAR)windowsDir[0]);
        BootPartitionNumber = GetPartitionNumberFromDriveLetter((CHAR)windowsDir[0]);
    }

    // Locate and create data structures for any DoubleSpace volumes

    DblSpaceInitialize();

    for (i=0; i<DiskCount; i++) {

        DrawDiskBar(Disks[i]);
    }

    return NO_ERROR;
}

VOID
WMDrawItem(
    IN PDRAWITEMSTRUCT pDrawItem
    )
{
    DWORD      temp;
    PDISKSTATE pDiskState;

    if ((pDrawItem->itemID != (DWORD)(-1))
    && (pDrawItem->itemAction == ODA_DRAWENTIRE)) {
        pDiskState = Disks[pDrawItem->itemID];

        // blt the disk's bar from the off-screen bitmap to the screen

        BitBlt(pDrawItem->hDC,
               pDrawItem->rcItem.left,
               pDrawItem->rcItem.top,
               pDrawItem->rcItem.right  - pDrawItem->rcItem.left + 1,
               pDrawItem->rcItem.bottom - pDrawItem->rcItem.top  + 1,
               pDiskState->hDCMem,
               0,
               0,
               SRCCOPY);

        // if we just overwrote the focus cursor, redraw it

        if (pDrawItem->itemID == LBCursorListBoxItem) {
            LBCursorOn = FALSE;
            ToggleLBCursor(pDrawItem->hDC);
        }

        // select any items selected in this bar

        for (temp=0; temp<pDiskState->RegionCount; temp++) {
            if (pDiskState->Selected[temp]) {
                ToggleRegion(pDiskState, temp, pDrawItem->hDC);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fdstleg.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fdstleg.c

Abstract:

    Routines to support the status bar and legend displays.

Author:

    Ted Miller (tedm) 7-Jan-1992

--*/


#include "fdisk.h"


HFONT hFontStatus,hFontLegend;

DWORD dyLegend,wLegendItem;
DWORD dyStatus,dyBorder;


// text for status area

TCHAR   StatusTextStat[STATUS_TEXT_SIZE];
TCHAR   StatusTextSize[STATUS_TEXT_SIZE];

WCHAR   StatusTextDrlt[3];

WCHAR   StatusTextType[STATUS_TEXT_SIZE];
WCHAR   StatusTextVoll[STATUS_TEXT_SIZE];

TCHAR  *LegendLabels[LEGEND_STRING_COUNT];


// whether status bar and legend are currently shown

BOOL    StatusBar = TRUE,
        Legend    = TRUE;



VOID
UpdateStatusBarDisplay(
    VOID
    )
{
    RECT rc;

    if(StatusBar) {
        GetClientRect(hwndFrame,&rc);
        rc.top = rc.bottom - dyStatus;
        InvalidateRect(hwndFrame,&rc,FALSE);
    }
}


VOID
ClearStatusArea(
    VOID
    )
{
    StatusTextStat[0] = StatusTextSize[0] = 0;
    StatusTextVoll[0] = StatusTextType[0] = 0;
    StatusTextDrlt[0] = 0;
    UpdateStatusBarDisplay();
}


VOID
DrawLegend(
    IN HDC   hdc,
    IN PRECT rc
    )

/*++

Routine Description:

    This routine draws the legend onto the given device context.  The legend
    lists the brush styles used to indicate various region types in the
    disk graphs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD  i,
           left,
           delta = GraphWidth / BRUSH_ARRAY_SIZE;
    HBRUSH hBrush;
    RECT   rc1,rc2;
    HFONT  hfontOld;
    SIZE   size;
    DWORD  dx;
    COLORREF OldTextColor,OldBkColor;

    rc1 = *rc;
    rc2 = *rc;

    // first draw the background.

    hBrush  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    rc1.right = rc1.left + GetSystemMetrics(SM_CXSCREEN);   // erase it all
    FillRect(hdc,&rc1,hBrush);
    DeleteObject(hBrush);

    // now draw the nice container

    rc2.left  += 8 * dyBorder;
    rc2.right -= 8 * dyBorder;
    DrawStatusAreaItem(&rc2,hdc,NULL,FALSE);

    // now draw the legend items

    SelectObject(hdc,hPenThinSolid);

    left = rc2.left + (wLegendItem / 2);
    SetBkColor(hdc,GetSysColor(COLOR_BTNFACE));
    hfontOld = SelectObject(hdc,hFontLegend);

    OldTextColor = SetTextColor(hdc,GetSysColor(COLOR_BTNTEXT));
    SetBkMode(hdc,OPAQUE);

    for(i=0; i<BRUSH_ARRAY_SIZE; i++) {

        hBrush = SelectObject(hdc,Brushes[i]);

        OldBkColor = SetBkColor(hdc,RGB(255,255,255));

        Rectangle(hdc,
                  left,
                  rc->top + (wLegendItem / 2),
                  left + wLegendItem,
                  rc->top + (3 * wLegendItem / 2)
                 );

        SetBkColor(hdc,OldBkColor);

        // BUGBUG unicode lstrlen?
        GetTextExtentPoint(hdc,LegendLabels[i],lstrlen(LegendLabels[i]),&size);
        dx = (DWORD)size.cx;
        TextOut(hdc,
                left + (3*wLegendItem/2),
                rc->top + (wLegendItem / 2) + ((wLegendItem-size.cy)/2),
                LegendLabels[i],
                lstrlen(LegendLabels[i])
               );
#if 0
        SelectObject(hdc,Brushes[++i]);

        OldBkColor = SetBkColor(hdc,RGB(255,255,255));

        Rectangle(hdc,
                  left,
                  rc->top + (2 * wLegendItem),
                  left + wLegendItem,
                  rc->top + (3 * wLegendItem)
                 );

        SetBkColor(hdc,OldBkColor);

        GetTextExtentPoint(hdc,LegendLabels[i],lstrlen(LegendLabels[i]),&size);
        TextOut(hdc,
                left + (3*wLegendItem/2),
                rc->top + (2 * wLegendItem) + ((wLegendItem-size.cy)/2),
                LegendLabels[i],
                lstrlen(LegendLabels[i])
               );

        if((DWORD)size.cx > dx) {
            dx = (DWORD)size.cx;
        }
#endif
        left += dx + (5*wLegendItem/2);

        if(hBrush) {
            SelectObject(hdc,hBrush);
        }
    }
    if(hfontOld) {
        SelectObject(hdc,hfontOld);
    }
    SetTextColor(hdc,OldTextColor);
}



VOID
DrawStatusAreaItem(
    IN PRECT  rc,
    IN HDC    hdc,
    IN LPTSTR Text,
    IN BOOL   Unicode
    )

/*++

Routine Description:

    This routine draws a status area item into a given dc.  This
    includes drawing the nice shaded button-like container, and
    then drawing text within it.

Arguments:

    rc      - rectangle describing the status area item

    hdc     - device context into which to draw

    Text    - optional parameter that if present represents text to
              be placed in the item.

    Unicode - if TRUE, Text points to a wide character string regardless
              of the type of LPTSTR

Return Value:

    None.

--*/

{
    HBRUSH hBrush;
    RECT   rcx;


    // the shadow

    if(hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW))) {

        // left edge

        rcx.left    = rc->left;
        rcx.right   = rc->left   + dyBorder;
        rcx.top     = rc->top    + (2*dyBorder);
        rcx.bottom  = rc->bottom - (2*dyBorder);
        FillRect(hdc,&rcx,hBrush);

        // top edge

        rcx.right    = rc->right;
        rcx.bottom   = rcx.top + dyBorder;
        FillRect(hdc,&rcx,hBrush);

        DeleteObject(hBrush);
    }

    // the highlight

    if(hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT))) {

        // right edge

        rcx.left    = rc->right - dyBorder;
        rcx.right   = rc->right;
        rcx.top     = rc->top    + (2*dyBorder);
        rcx.bottom  = rc->bottom - (2*dyBorder);
        FillRect(hdc,&rcx,hBrush);

        // top edge

        rcx.left    = rc->left;
        rcx.right   = rc->right;
        rcx.top     = rc->bottom - (3*dyBorder);
        rcx.bottom  = rcx.top + dyBorder;
        FillRect(hdc,&rcx,hBrush);

        DeleteObject(hBrush);
    }

    if(Text) {

        // draw the text

        SetTextColor(hdc,GetSysColor(COLOR_BTNTEXT));
        SetBkColor(hdc,GetSysColor(COLOR_BTNFACE));

        rcx.top    = rc->top    + (3*dyBorder);
        rcx.bottom = rc->bottom - (3*dyBorder);
        rcx.left   = rc->left   + dyBorder;
        rcx.right  = rc->right  - dyBorder;

        if(Unicode && (sizeof(TCHAR) != sizeof(WCHAR))) {

            ExtTextOutW(hdc,
                        rcx.left+(2*dyBorder),
                        rcx.top,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rcx,
                        (PWSTR)Text,
                        lstrlenW((PWSTR)Text),
                        NULL
                       );

        } else {
            ExtTextOut(hdc,
                       rcx.left+(2*dyBorder),
                       rcx.top,
                       ETO_OPAQUE | ETO_CLIPPED,
                       &rcx,
                       Text,
                       lstrlen(Text),
                       NULL
                      );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\makefile.inc ===
fdiskmsg.h fdiskmsg.rc msg00001.bin: fdiskmsg.mc
    mc -v fdiskmsg.mc

$(O)\fdisk.res: fdisk.dlg fdiskmsg.rc ftreg.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fmifs.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    fmifs.c

Abstract:

    This module contains the set of routines that work with the fmifs.dll

Author:

    Bob Rinne (bobri)  11/15/93

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "shellapi.h"
#include "fmifs.h"
#include <string.h>
#include <stdio.h>

//
// defines unique to this module
//

#define FS_CANCELUPDATE (WM_USER + 0)
#define FS_FINISHED     (WM_USER + 1)

BOOLEAN
FmIfsCallback(
    IN FMIFS_PACKET_TYPE    PacketType,
    IN DWORD                PacketLength,
    IN PVOID                PacketData
    );

//
// Externals needed for IFS Dll support (format and label)
//

HINSTANCE                           IfsDllHandle            = NULL;
PFMIFS_FORMAT_ROUTINE               FormatRoutine           = NULL;
PFMIFS_SETLABEL_ROUTINE             LabelRoutine            = NULL;

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
PFMIFS_DOUBLESPACE_CREATE_ROUTINE   DblSpaceCreateRoutine   = NULL;
PFMIFS_DOUBLESPACE_MOUNT_ROUTINE    DblSpaceMountRoutine    = NULL;
PFMIFS_DOUBLESPACE_DELETE_ROUTINE   DblSpaceDeleteRoutine   = NULL;
PFMIFS_DOUBLESPACE_DISMOUNT_ROUTINE DblSpaceDismountRoutine = NULL;
PFMIFS_DOUBLESPACE_QUERY_INFO_ROUTINE DblSpaceQueryInfoRoutine = NULL;

BOOLEAN DoubleSpaceSupported = TRUE;
#endif

// HACK HACK - clean this up if it works.

#define    SELECTED_REGION(i)  (SelectedDS[i]->RegionArray[SelectedRG[i]])
#define     MaxMembersInFtSet   32
extern DWORD      SelectionCount;
extern PDISKSTATE SelectedDS[MaxMembersInFtSet];
extern ULONG      SelectedRG[MaxMembersInFtSet];

VOID
setUnicode(
    char *astring,
    WCHAR *wstring
    )
/*++

Routine Description:

    Convert an ansii string to Unicode.  Internal routine to fmifs module.

Arguments:

    astring - ansii string to convert to Unicode
    wstring - resulting string location

Return Value:

    None

--*/
{

    int len = lstrlen(astring)+1;

    MultiByteToWideChar( CP_ACP, 0, astring, len, wstring, len );
}

BOOL
LoadIfsDll(
    VOID
    )

/*++

Routine Description:

    This routine will determine if the IFS Dll needs to be loaded.  If
    so, it will load it and locate the format and label routines in the
    dll.

Arguments:

    None

Return Value:

    TRUE if Dll is loaded and the routines needed have been found
    FALSE if something fails

--*/

{
    if (FormatRoutine) {

        // Library is already loaded and the routines needed
        // have been located.

        return TRUE;
    }

    IfsDllHandle = LoadLibrary(TEXT("fmifs.dll"));
    if (IfsDllHandle == (HANDLE)NULL) {

         // FMIFS not available.

         return FALSE;
    }

    // Library is loaded.  Locate the two routines needed by
    // Disk Administrator.

    FormatRoutine = (PVOID)GetProcAddress(IfsDllHandle, "Format");
    LabelRoutine  = (PVOID)GetProcAddress(IfsDllHandle, "SetLabel");
    if (!FormatRoutine || !LabelRoutine) {

        // something didn't get found so shut down all accesses
        // to the library by insuring FormatRoutine is NULL

        FreeLibrary(IfsDllHandle);
        FormatRoutine = NULL;
        return FALSE;
    }

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
    DblSpaceMountRoutine    = (PVOID)GetProcAddress(IfsDllHandle, "DoubleSpaceMount");
    DblSpaceDismountRoutine = (PVOID)GetProcAddress(IfsDllHandle, "DoubleSpaceDismount");
    DblSpaceCreateRoutine   = (PVOID)GetProcAddress(IfsDllHandle, "DoubleSpaceCreate");
    DblSpaceDeleteRoutine   = (PVOID)GetProcAddress(IfsDllHandle, "DoubleSpaceDelete");
    DblSpaceQueryInfoRoutine = (PVOID)GetProcAddress(IfsDllHandle, "FmifsQueryDriveInformation");

    if (!DblSpaceMountRoutine || !DblSpaceDismountRoutine || !DblSpaceQueryInfoRoutine)  {

        // didn't get all of the DoubleSpace support routines
        // Allow format and label, just don't do DoubleSpace

        DoubleSpaceSupported = FALSE;
    }

    if (DblSpaceCreateRoutine && DblSpaceDeleteRoutine) {

        // Everything is there for read/write double space support.
        // This will change certain dialogs to allow creation and
        // deletion of double space volumes.

        IsFullDoubleSpace = TRUE;
    }
#endif
    return TRUE;
}

VOID
UnloadIfsDll(
    VOID
    )

/*++

Routine Description:

    This routine will free the FmIfs DLL if it was loaded.

Arguments:

    None

Return Value:

    None

--*/

{
    if (FormatRoutine) {
        FreeLibrary(IfsDllHandle);
        FormatRoutine = NULL;
        IfsDllHandle  = NULL;
        LabelRoutine  = NULL;
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
        DblSpaceDismountRoutine = NULL;
        DblSpaceMountRoutine    = NULL;
        DblSpaceCreateRoutine   = NULL;
        DblSpaceDeleteRoutine   = NULL;
#endif
    }
}

PFORMAT_PARAMS ParamsForCallBack = NULL;

BOOLEAN
FmIfsCallback(
    IN FMIFS_PACKET_TYPE    PacketType,
    IN DWORD                PacketLength,
    IN PVOID                PacketData
    )

/*++

Routine Description:

    This routine gets callbacks from fmifs.dll regarding
    progress and status of the ongoing format or doublespace
    create.  It runs in the same thread as the format or create,
    which is a separate thread from the "cancel" button.  If
    the user hits "cancel", this routine notices on the next
    callback and cancels the format or double space create.

Arguments:

    [PacketType] -- an fmifs packet type
    [PacketLength] -- length of the packet data
    [PacketData] -- data associated with the packet

Return Value:

    TRUE if the fmifs activity should continue, FALSE if the
    activity should halt immediately.  Thus, we return FALSE if
    the user has hit "cancel" and we wish fmifs to clean up and
    return from the Format() entrypoint call.

--*/

{
    PFORMAT_PARAMS formatParams = ParamsForCallBack;
    HWND           hDlg = formatParams->DialogHwnd;

    // Quit if told to do so..

    if (formatParams->Cancel) {
        formatParams->Result = MSG_FORMAT_CANCELLED;
        return FALSE;
    }

    switch (PacketType) {
    case FmIfsPercentCompleted:

        PostMessage(hDlg,
                    FS_CANCELUPDATE,
                    ((PFMIFS_PERCENT_COMPLETE_INFORMATION)PacketData)->PercentCompleted,
                    0);
        break;

    case FmIfsFormatReport:

        formatParams->TotalSpace = ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesTotalDiskSpace;
        formatParams->SpaceAvailable = ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesAvailable;
        break;

    case FmIfsIncompatibleFileSystem:

        formatParams->Result = MSG_INCOMPATIBLE_FILE_SYSTEM;
        break;

    case FmIfsInsertDisk:

        break;

    case FmIfsFormattingDestination:

        break;

    case FmIfsIncompatibleMedia:

        formatParams->Result = MSG_INCOMPATIBLE_MEDIA;
        break;

    case FmIfsAccessDenied:

        formatParams->Result = MSG_FORMAT_ACCESS_DENIED;
        break;

    case FmIfsMediaWriteProtected:

        formatParams->Result = MSG_WRITE_PROTECTED;
        break;

    case FmIfsCantLock:

        formatParams->Result = MSG_FORMAT_CANT_LOCK;
        break;

    case FmIfsBadLabel:

        formatParams->Result = MSG_BAD_LABEL;
        break;

    case FmIfsCantQuickFormat:

        formatParams->Result = MSG_CANT_QUICK_FORMAT;
        break;

    case FmIfsIoError:

        formatParams->Result = MSG_IO_ERROR;
        break;

    case FmIfsFinished:

        PostMessage(hDlg,
                    FS_FINISHED,
                    0,
                    0);
        return FALSE;
        break;

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
    case FmIfsDblspaceCreateFailed:
        formatParams->Result = MSG_CANT_CREATE_DBLSPACE;
        break;

    case FmIfsDblspaceMountFailed:
        formatParams->Result = MSG_CANT_MOUNT_DBLSPACE;
        break;

    case FmIfsDblspaceDriveLetterFailed:
        formatParams->Result = MSG_DBLSPACE_LETTER_FAILED;
        break;

    case FmIfsDblspaceCreated:

        // Save the name of the double space file.

        if (formatParams->DblspaceFileName = (PWSTR) Malloc(PacketLength)) {
            memcpy(formatParams->DblspaceFileName, PacketData, PacketLength);
        }
        break;

    case FmIfsDblspaceMounted:
        break;
#endif
    default:
        break;
    }

    return (formatParams->Result) ? FALSE : TRUE;
}

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
ULONG MountDismountResult;
#define MOUNT_DISMOUNT_SUCCESS 0

BOOLEAN
FmIfsMountDismountCallback(
    IN FMIFS_PACKET_TYPE    PacketType,
    IN DWORD                PacketLength,
    IN PVOID                PacketData
    )

/*++

Routine Description:

    This routine gets callbacks from fmifs.dll regarding
    progress and status of the ongoing format or doublespace

Arguments:

    [PacketType] -- an fmifs packet type
    [PacketLength] -- length of the packet data
    [PacketData] -- data associated with the packet

Return Value:

    TRUE if the fmifs activity should continue, FALSE if the
    activity should halt immediately.  Thus, we return FALSE if
    the user has hit "cancel" and we wish fmifs to clean up and
    return from the Format() entrypoint call.

--*/

{
    switch (PacketType) {
    case FmIfsDblspaceMounted:
        MountDismountResult = MOUNT_DISMOUNT_SUCCESS;
        break;
    }
    return TRUE;
}
#endif

VOID
FormatVolume(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This routine converts the strings in the formatParams structure
    and calls the fmifs routines to perform the format.

    It assumes it is called by a separate thread and will exit the
    thread on completion of the format.

Arguments:

    ThreadParameter - a pointer to the FORMAT_PARAMS structure

Return Value:

    None

--*/

{
    PFORMAT_PARAMS formatParams = (PFORMAT_PARAMS) ThreadParameter;
    PPERSISTENT_REGION_DATA regionData;
    DWORD          index;
    WCHAR          unicodeLabel[100],
                   unicodeFsType[20],
                   driveLetter[4];

    // The fmifs interface doesn't allow for a context parameter
    // therefore the formatparams must be passed through an external.

    ParamsForCallBack = formatParams;

    // set up a unicode drive letter.

    regionData = (PPERSISTENT_REGION_DATA) formatParams->RegionData;
    driveLetter[1] = L':';
    driveLetter[2] = 0;
    driveLetter[0] = (WCHAR) regionData->DriveLetter;

    // convert label to unicode

    setUnicode(formatParams->Label,
               unicodeLabel);

    // convert filesystem type to unicode

    for (index = 0;
         unicodeFsType[index] = (WCHAR)(formatParams->FileSystem[index]);
         index++) {
        // operation done in for loop
    }

    (*FormatRoutine)(driveLetter,
                     FmMediaUnknown,
                     unicodeFsType,
                     unicodeLabel,
                     (BOOLEAN)formatParams->QuickFormat,
                     &FmIfsCallback);

    // Set the synchronization event to inform the windisk thread
    // that this is complete and all handles have been closed.

    formatParams->ThreadIsDone = 1;
    ExitThread(0L);
}

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
VOID
FmIfsCreateDblspace(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This routine converts the strings in the formatParams structure
    and calls the fmifs routines to perform the double space create.

    It assumes it is called by a separate thread and will exit the
    thread on completion of the create.

Arguments:

    ThreadParameter - a pointer to the FORMAT_PARAMS structure

Return Value:

    None

--*/

{
    PFORMAT_PARAMS formatParams = (PFORMAT_PARAMS) ThreadParameter;
    PPERSISTENT_REGION_DATA regionData;
    DWORD          index;
    UCHAR          letter;
    WCHAR          unicodeLabel[100],
                   newDriveLetter[4],
                   driveLetter[4];

    // The fmifs interface doesn't allow for a context parameter
    // therefore the formatparams must be passed through an external.

    ParamsForCallBack = formatParams;

    // set up a unicode drive letter.

    regionData = (PPERSISTENT_REGION_DATA) formatParams->RegionData;
    driveLetter[1] = L':';
    driveLetter[2] = 0;
    driveLetter[0] = (WCHAR) regionData->DriveLetter;

    // set up the new letter

    newDriveLetter[1] = L':';
    newDriveLetter[2] = 0;

    // Choose the first available.  This should come from the dialog
    // newDriveLetter[0] = (WCHAR) formatParams->NewLetter;

    for (letter='C'; letter <= 'Z'; letter++) {
        if (DriveLetterIsAvailable((CHAR)letter)) {
            newDriveLetter[0] = (WCHAR) letter;
            break;
        }
    }

    // convert label to unicode

    setUnicode(formatParams->Label,
               unicodeLabel);

    (*DblSpaceCreateRoutine)(driveLetter,
                             formatParams->SpaceAvailable * 1024 * 1024,
                             unicodeLabel,
                             newDriveLetter,
                             &FmIfsCallback);
    ExitThread(0L);
}

BOOL
FmIfsDismountDblspace(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Convert the name provided into unicode and call the
    FmIfs support routine.

Arguments:

    DriveLetter - the drive letter to dismount.

Return Value:

    TRUE - it worked.

--*/

{
    WCHAR unicodeLetter[4];
    ULONG index;

    unicodeLetter[0] = (WCHAR) DriveLetter;
    unicodeLetter[1] = (WCHAR) ':';
    unicodeLetter[2] = 0;

    // The only way to communicate with the fmifs callback
    // is through global externals.

    MountDismountResult = MSG_CANT_DISMOUNT_DBLSPACE;

    (*DblSpaceDismountRoutine)(unicodeLetter, &FmIfsMountDismountCallback);

    return MountDismountResult;
}

BOOL
FmIfsMountDblspace(
    IN PCHAR FileName,
    IN CHAR  HostDrive,
    IN CHAR  NewDrive
    )

/*++

Routine Description:

    Convert the arguments into unicode characters and
    call the FmIfs support routine to mount the double
    space volume.

Arguments:

    FileName  - ASCII file name (i.e. dblspace.xxx)
    HostDrive - Drive drive letter containing double space volume
    NewDrive  - Drive letter to be assigned to the volume

Return Value:

    TRUE it worked.

--*/

{
    WCHAR wideFileName[40];
    WCHAR wideHostDrive[4];
    WCHAR wideNewDrive[4];
    ULONG index;

    // convert the double space file name.

    for (index = 0; wideFileName[index] = (WCHAR) FileName[index]; index++) {
        // all work done in for expression
    }

    // convert the drive names.

    wideNewDrive[1] = wideHostDrive[1] = (WCHAR) ':';
    wideNewDrive[2] = wideHostDrive[2] = 0;

    wideNewDrive[0]  = (WCHAR) NewDrive;
    wideHostDrive[0] = (WCHAR) HostDrive;

    // The only way to communicate with the fmifs callback
    // is through global externals.

    MountDismountResult = MSG_CANT_MOUNT_DBLSPACE;

    (*DblSpaceMountRoutine)(wideHostDrive,
                            wideFileName,
                            wideNewDrive,
                            &FmIfsMountDismountCallback);
    return MountDismountResult;
}

BOOLEAN
FmIfsQueryInformation(
    IN  PWSTR       DosDriveName,
    OUT PBOOLEAN    IsRemovable,
    OUT PBOOLEAN    IsFloppy,
    OUT PBOOLEAN    IsCompressed,
    OUT PBOOLEAN    Error,
    OUT PWSTR       NtDriveName,
    IN  ULONG       MaxNtDriveNameLength,
    OUT PWSTR       CvfFileName,
    IN  ULONG       MaxCvfFileNameLength,
    OUT PWSTR       HostDriveName,
    IN  ULONG       MaxHostDriveNameLength
    )

/*++

Routine Description:

    Call through the pointer to the routine in the fmifs dll.

Arguments:

    Same as the Fmifs routine in the DLL.

Return Value:

--*/

{
    if (!DblSpaceQueryInfoRoutine) {
        return FALSE;
    }
    return (*DblSpaceQueryInfoRoutine)(DosDriveName,
                                       IsRemovable,
                                       IsFloppy,
                                       IsCompressed,
                                       Error,
                                       NtDriveName,
                                       MaxNtDriveNameLength,
                                       CvfFileName,
                                       MaxCvfFileNameLength,
                                       HostDriveName,
                                       MaxHostDriveNameLength);
}
#endif

BOOL
CancelDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for the modeless progress & cancel dialog
    Two main purposes here:
       1. if the user chooses CANCEL we set bCancel to TRUE
          which will end the PeekMessage background processing loop
       2. handle the private FS_CANCELUPDATE message and draw
          a "gas gauge" indication of how far the background job
          has progressed

Arguments:

    standard Windows dialog procedure

Return Values:

    standard Windows dialog procedure

--*/

{
    static DWORD          percentDrawn;
    static RECT           rectGG;              // GasGauge rectangle
    static BOOL           captionIsLoaded;
    static PFORMAT_PARAMS formatParams;
           TCHAR          title[100],
                          templateString[100];

    switch (uMsg) {
    case WM_INITDIALOG: {
        PPERSISTENT_REGION_DATA regionData;
        HANDLE threadHandle;
        DWORD  threadId;
        HWND   hwndGauge = GetDlgItem(hDlg, IDC_GASGAUGE);

        // set up the dialog handle in the parameter block so the
        // call back routine can communicate with this routine
        // and initialize static variables.

        formatParams = (PFORMAT_PARAMS) lParam;
        formatParams->DialogHwnd = hDlg;
        regionData = (PPERSISTENT_REGION_DATA) formatParams->RegionData;
        percentDrawn = 0;
        captionIsLoaded = FALSE;

        // Set the caption string.

        LoadString(hModule, IDS_FORMAT_TITLE, templateString, sizeof(templateString)/sizeof(TCHAR));
        wsprintf(title,
                 templateString,
                 regionData->DriveLetter);
        SetWindowText(hDlg, title);

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
        if (formatParams->DoubleSpace) {

             // start the double space create thread

             threadHandle = CreateThread(NULL,
                                         0,
                                         (LPTHREAD_START_ROUTINE) FmIfsCreateDblspace,
                                         (LPVOID) formatParams,
                                         (DWORD) 0,
                                         (LPDWORD) &threadId);
        } else {
#endif

             // start the format thread

             threadHandle = CreateThread(NULL,
                                         0,
                                         (LPTHREAD_START_ROUTINE) FormatVolume,
                                         (LPVOID) formatParams,
                                         (DWORD) 0,
                                         (LPDWORD) &threadId);
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
        }
#endif
        if (!threadHandle) {
            // can't do it now.

            formatParams->Result = MSG_COULDNT_CREATE_THREAD;
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        // no need to keep the handle around.

        CloseHandle(threadHandle);

        // Get the coordinates of the gas gauge static control rectangle,
        // and convert them to dialog client area coordinates

        GetClientRect(hwndGauge, &rectGG);
        ClientToScreen(hwndGauge, (LPPOINT)&rectGG.left);
        ClientToScreen(hwndGauge, (LPPOINT)&rectGG.right);
        ScreenToClient(hDlg, (LPPOINT)&rectGG.left);
        ScreenToClient(hDlg, (LPPOINT)&rectGG.right);
        return TRUE;
    }

    case WM_COMMAND:

        switch (wParam) {
        case IDCANCEL:

            formatParams->Result = MSG_FORMAT_CANCELLED;
            formatParams->Cancel = TRUE;
            EndDialog(hDlg, FALSE);
        }
        return TRUE;

    case WM_PAINT: {
        INT         width  = rectGG.right - rectGG.left;
        INT         height = rectGG.bottom - rectGG.top;
        INT         nDivideRects;
        HDC         hDC;
        PAINTSTRUCT ps;
        TCHAR       buffer[100];
        SIZE        size;
        INT         xText,
                    yText,
                    byteCount;
        RECT        rectDone,
                    rectLeftToDo;

        // The gas gauge is drawn by drawing a text string stating
        // what percentage of the job is done into the middle of
        // the gas gauge rectangle, and by separating that rectangle
        // into two parts: rectDone (the left part, filled in blue)
        // and rectLeftToDo(the right part, filled in white).
        // nDivideRects is the x coordinate that divides these two rects.
        //
        // The text in the blue rectangle is drawn white, and vice versa
        // This is easy to do with ExtTextOut()!

        hDC = BeginPaint(hDlg, &ps);

        // If formatting quick, set this display

        if (!captionIsLoaded) {
            UINT resourceId = IDS_PERCENTCOMPLETE;

            if (formatParams->QuickFormat) {
                resourceId = IDS_QUICK_FORMAT;
            }
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
            if (formatParams->DoubleSpace) {
                resourceId = IDS_CREATING_DBLSPACE;
            }
#endif
            LoadString(hModule,
                       resourceId,
                       buffer,
                       sizeof(buffer)/sizeof(TCHAR));
            if (!formatParams->QuickFormat) {
                SetDlgItemText(hDlg, IDC_TEXT, buffer);
            }
            captionIsLoaded = TRUE;
        }

        if (formatParams->QuickFormat) {
            nDivideRects = 0;
            byteCount = lstrlen(buffer);
        } else {
            byteCount = wsprintf(buffer, TEXT("%3d%%"), percentDrawn);
            nDivideRects = (width * percentDrawn) / 100;
        }

        GetTextExtentPoint(hDC, buffer, lstrlen(buffer), &size);
        xText = rectGG.left + (width  - size.cx) / 2;
        yText = rectGG.top  + (height - size.cy) / 2;


        // Paint in the "done so far" rectangle of the gas
        // gauge with blue background and white text

        SetRect(&rectDone,
                rectGG.left,
                rectGG.top,
                rectGG.left + nDivideRects,
                rectGG.bottom);

        SetTextColor(hDC, RGB(255, 255, 255));
        SetBkColor(hDC, RGB(0, 0, 255));

        ExtTextOut(hDC,
                   xText,
                   yText,
                   ETO_CLIPPED | ETO_OPAQUE,
                   &rectDone,
                   buffer,
                   byteCount/sizeof(TCHAR),
                   NULL);

        // Paint in the "still left to do" rectangle of the gas
        // gauge with white background and blue text

        SetRect(&rectLeftToDo,
                rectGG.left + nDivideRects,
                rectGG.top,
                rectGG.right,
                rectGG.bottom);
        SetTextColor(hDC, RGB(0, 0, 255));
        SetBkColor(hDC, RGB(255, 255, 255));

        ExtTextOut(hDC,
                   xText,
                   yText,
                   ETO_CLIPPED | ETO_OPAQUE,
                   &rectLeftToDo,
                   buffer,
                   byteCount/sizeof(TCHAR),
                   NULL);
        EndPaint(hDlg, &ps);
        return TRUE;
    }

    case FS_CANCELUPDATE:

         // wParam = % completed

         percentDrawn = (INT)wParam;
         InvalidateRect(hDlg, &rectGG, TRUE);
         UpdateWindow(hDlg);
         return TRUE;

    case FS_FINISHED:

        EndDialog(hDlg, TRUE);
        return TRUE;

    default:

        return FALSE;
    }
}

INT
LabelDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LONG lParam)

/*++

Routine Description:

    This routine manages the label dialog.
    Upon completion of the dialog it will end the dialog with a result of
    TRUE to indicate that all is set up for the label operation.  FALSE if
    the label operation has been cancelled by the user.

Arguments:

    Standard Windows dialog procedure.

Return Value:

    Standard Windows dialog procedure.

--*/

{
    static PLABEL_PARAMS      labelParams;
    static PREGION_DESCRIPTOR regionDescriptor;
    static PPERSISTENT_REGION_DATA regionData;
    char     text[100];
    TCHAR    uniText[100];
    int      labelSize;
    TCHAR    title[100],
             templateString[100];

    switch (wMsg) {
    case WM_INITDIALOG:

        labelParams = (PLABEL_PARAMS) lParam;
        regionDescriptor = labelParams->RegionDescriptor;
        regionData = PERSISTENT_DATA(regionDescriptor);

        // Set the caption string.
        //
        LoadString(hModule, IDS_LABEL_TITLE, templateString, sizeof(templateString)/sizeof(TCHAR));
        wsprintf(title,
                 templateString,
                 regionData->DriveLetter);
        SetWindowText(hDlg, title);

        // Convert the volume label into the proper type for windows.

        wsprintf(text, "%ws", regionData->VolumeLabel);
        UnicodeHack(text, uniText);
        SetDlgItemText(hDlg, IDC_NAME, uniText);
        return TRUE;

    case WM_COMMAND:
        switch (wParam) {

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_LABEL);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            labelSize = GetDlgItemText(hDlg, IDC_NAME, text, 100);
            UnicodeHack(text, labelParams->NewLabel);
            EndDialog(hDlg, TRUE);
            break;
        }
        break;
    }
    return FALSE;
}

#define NUM_FSTYPES 2
#define MAX_FSTYPENAME_SIZE 6

// HPFS is not supported -- therefore commented out.

TCHAR *FsTypes[NUM_FSTYPES + 1] = { "NTFS",
                                 /* "HPFS", */
                                    "FAT" };
WCHAR *UnicodeFsTypes[NUM_FSTYPES] = { L"NTFS",
                                    /* L"HPFS", */
                                       L"FAT" };

INT
FormatDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LONG lParam)

/*++

Routine Description:

    This routine manages the format dialog.  Upon completion it ends the
    dialog with a result value of TRUE to indicate that the format operation
    is to take place.  FALSE is the result if the user cancels out of the
    dialog.

Arguments:

    Standard Windows dialog procedure.

Return Value:

    Standard Windows dialog procedure.

--*/

{
    static HWND                    hwndCombo;
    static PFORMAT_PARAMS          formatParams;
    static PREGION_DESCRIPTOR      regionDescriptor;
    static PPERSISTENT_REGION_DATA regionData;
    char  text[40];
    TCHAR uniText[40];
    INT   i;
    DWORD selection;
    BOOL  quickFormat = FALSE;
    HWND  hwndButton;
    TCHAR title[100],
          templateString[100];

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
    case WM_INITDIALOG: {
        PWSTR typeName    = NULL,
              volumeLabel = NULL;
        WCHAR driveLetter = L' ';

        // since the format params are static reset the quick format boolean.

        formatParams = (PFORMAT_PARAMS) lParam;
        formatParams->QuickFormat = FALSE;

        // get format params, set static values and
        // get information about the volume

        hwndCombo = GetDlgItem(hDlg, IDC_FSTYPE);
        regionDescriptor = formatParams->RegionDescriptor;
        DetermineRegionInfo(regionDescriptor,
                            &typeName,
                            &volumeLabel,
                            &driveLetter);
        regionData = PERSISTENT_DATA(regionDescriptor);

        // Set the caption string.

        LoadString(hModule, IDS_FORMAT_TITLE, templateString, sizeof(templateString)/sizeof(TCHAR));
        wsprintf(title,
                 templateString,
                 regionData->DriveLetter);
        SetWindowText(hDlg, title);

        // Convert the volume label into the proper type for windows
        // and set default values.

        wsprintf(text, "%ws", regionData->VolumeLabel);
        UnicodeHack(text, uniText);
        SetDlgItemText(hDlg, IDC_NAME, uniText);
        CheckDlgButton(hDlg, IDC_VERIFY, quickFormat);
        SendDlgItemMessage(hDlg, IDOK, EM_SETSEL, 0, -1);

        // If this volume is a mirror or stripe with parity,
        // disable Quick Format.

        if (regionData->FtObject != NULL &&
            (regionData->FtObject->Set->Type == Mirror ||
             regionData->FtObject->Set->Type == StripeWithParity)) {

            hwndButton = GetDlgItem(hDlg, IDC_VERIFY);

            if (hwndButton != NULL) {

                EnableWindow(hwndButton, FALSE);
            }
        }

        selection = 0;
        if (IsDiskRemovable[regionDescriptor->Disk]) {

            // If removable, start from the bottom of the list so FAT is first.
            // Load the available File system types.

            for (i = NUM_FSTYPES - 1; i >= 0; i--) {

                // Fill the drop down list.

                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)FsTypes[i]);
            }

        } else {

            // Load the available File system types.

            for (i = 0; i < NUM_FSTYPES; i++) {

                // While filling in the drop down, determine which FS
                // this volume is already formated for and make it the
                // default (if not found, NTFS is the default).

                if (wcscmp(typeName, UnicodeFsTypes[i]) == 0) {
                    selection = i;
                }

                // set the FS type into the dialog.

                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)FsTypes[i]);
            }
        }

        SendMessage(hwndCombo, CB_SETCURSEL, selection, 0);
        return TRUE;
        break;
    }

    case WM_COMMAND:

        switch (wParam) {

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_FORMAT);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK: {
            int labelSize;

            // pull the parameters from the dialog
            // and return with success.

            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)formatParams->FileSystem);
            labelSize = GetDlgItemText(hDlg,
                                       IDC_NAME,
                                       (LPTSTR) formatParams->Label,
                                       100);
            if (IsDlgButtonChecked(hDlg, IDC_VERIFY)) {
                formatParams->QuickFormat = TRUE;
            }
            EndDialog(hDlg, TRUE);
            break;
        }

        default:

            return FALSE;
        }

    default:
        break;
    }
    return FALSE;
}

VOID
FormatPartition(
    PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Insure the IFS Dll is loaded and start the dialog for format
    of a volume.

Arguments:

    RegionDescriptor - The region to format.

Return Value:

    None

--*/

{
    static FORMAT_PARAMS formatParams;  // this is passed to other threads
                                        // it cannot be located on the stack
    PPERSISTENT_REGION_DATA regionData;
    int   doFormat;
    ULONG diskSize;
    PWSTR tempName,
          tempLabel,
          typeName;
    TCHAR label[100],
          fileSystem[10],
          message[300],
          msgProto[300],
          title[200];

    // Make sure format of this partition is allowed.  It is not allowed
    // if it is the boot partition (or sys partition on x86).

    if ((DeletionIsAllowed(RegionDescriptor)) != NO_ERROR) {
        ErrorDialog(MSG_CANT_FORMAT_WINNT);
        return;
    }

    // must have a drive letter

    regionData = PERSISTENT_DATA(RegionDescriptor);
    if (!regionData->DriveLetter) {
        ErrorDialog(MSG_CANT_FORMAT_NO_LETTER);
        return;
    }

    // can only do this is the dll is loaded.

    if (!LoadIfsDll()) {

        // could not load the dll

        ErrorDialog(MSG_CANT_LOAD_FMIFS);
        return;
    }

    // set up the parameters and get the information from the user.

    formatParams.RegionDescriptor = RegionDescriptor;
    formatParams.Result           = 0;
    formatParams.RegionData       = regionData;
    formatParams.Label            = (PUCHAR) label;
    formatParams.FileSystem       = (PUCHAR) fileSystem;
    formatParams.QuickFormat = formatParams.Cancel =
                               formatParams.DoubleSpace = FALSE;
    formatParams.TotalSpace       = formatParams.SpaceAvailable = 0;
    doFormat = DialogBoxParam(hModule,
                              MAKEINTRESOURCE(IDD_PARTITIONFORMAT),
                              hwndFrame,
                              (DLGPROC) FormatDlgProc,
                              (ULONG) &formatParams);
    if (doFormat) {

        // do an are you sure message.

        doFormat = ConfirmationDialog(MSG_CONFIRM_FORMAT,
                                      MB_ICONQUESTION | MB_YESNO);
        if (doFormat == IDYES) {

            if (IsDiskRemovable[RegionDescriptor->Disk]) {
                PWSTR   typeName,
                        volumeLabel;
                BOOLEAN volumeChanged = FALSE;

                if (!RegionDescriptor->PartitionNumber) {

                    // TODO: something has changed where the code gets to this
                    // point with an incorrect partition number - This happens
                    // when a partition is deleted and added to removable media.
                    // For removable media the partition number is always 1.

                    RegionDescriptor->PartitionNumber = 1;
                }
                if (GetVolumeTypeAndSize(RegionDescriptor->Disk,
                                         RegionDescriptor->PartitionNumber,
                                         &volumeLabel,
                                         &typeName,
                                         &diskSize) == OK_STATUS) {

                    // Verify that this is still the same device.

                    if (typeName) {
                        if (!lstrcmpiW(typeName, L"raw")) {
                            Free(typeName);
                            typeName = Malloc((wcslen(wszUnknown) * sizeof(WCHAR)) + sizeof(WCHAR));
                            lstrcpyW(typeName, wszUnknown);
                        }
                    } else {
                        typeName = Malloc((wcslen(wszUnknown) * sizeof(WCHAR)) + sizeof(WCHAR));
                        lstrcpyW(typeName, wszUnknown);
                    }
                    if (regionData) {
                        if (regionData->VolumeLabel) {
                            if (wcscmp(regionData->VolumeLabel, volumeLabel)) {
                                volumeChanged = TRUE;
                            }
                        }
                        if (regionData->TypeName) {

                            // It is possible the region has no type
                            // or is of type "Unformatted".
                            // This says it is ok to format.

                            if (*regionData->TypeName) {

                                if (wcscmp(regionData->TypeName, wszUnformatted)) {

                                    // It has a type and it isn't
                                    // unformatted - see if it is
                                    // the same as before.

                                    if (wcscmp(regionData->TypeName, typeName)) {
                                        volumeChanged = TRUE;
                                    }
                                }
                            }
                        }
                    }

                    if (Disks[RegionDescriptor->Disk]->DiskSizeMB != (diskSize/1024)) {
                        volumeChanged = TRUE;
                    }
                    if (volumeChanged) {

                        ErrorDialog(MSG_VOLUME_CHANGED);

                        // since the user was told the volume changed,
                        // update the display.

                        SetCursor(hcurWait);
                        if (GetVolumeTypeAndSize(RegionDescriptor->Disk,
                                                 RegionDescriptor->PartitionNumber,
                                                 &tempLabel,
                                                 &tempName,
                                                 &diskSize) == OK_STATUS) {
                            Free(typeName);
                            typeName = tempName;
                            Free(volumeLabel);
                            volumeLabel = tempLabel;
                        }
                        if (regionData->VolumeLabel) {
                            Free(regionData->VolumeLabel);
                        }
                        regionData->VolumeLabel = volumeLabel;
                        if (regionData->TypeName) {
                            Free(regionData->TypeName);
                        }
                        regionData->TypeName = typeName;
                        SetCursor(hcurNormal);
                        TotalRedrawAndRepaint();
                        return;
                    } else {
                        if (volumeLabel) {
                            Free(volumeLabel);
                        }
                        if (typeName) {
                            Free(typeName);
                        }
                    }
                }
            }

            // Insure the partition is not to big if the requested format
            // is FAT.

            if (!strcmpi(formatParams.FileSystem, "FAT")) {

                if (GetVolumeSizeMB(RegionDescriptor->Disk,
                                    RegionDescriptor->PartitionNumber,
                                    &diskSize)) {
                    if (diskSize > (4*1024)) {
                        ErrorDialog(MSG_TOO_BIG_FOR_FAT);
                        TotalRedrawAndRepaint();
                        return;
                    }
                } else {

                    // Just try the format anyway.

                }
            }

            // Initialize synchronization event to know when the
            // format thread is really complete.

            formatParams.ThreadIsDone = 0;

            // user still wants to format.

            DialogBoxParam(hModule,
                           MAKEINTRESOURCE(IDD_FORMATCANCEL),
                           hwndFrame,
                           (DLGPROC) CancelDlgProc,
                           (ULONG) &formatParams);
            if (formatParams.Result) {

                // the format failed.

                ErrorDialog(formatParams.Result);
            } else {

                LoadString(hModule,
                           IDS_FORMATCOMPLETE,
                           title,
                           sizeof(title)/sizeof(TCHAR));
                LoadString(hModule,
                           IDS_FORMATSTATS,
                           msgProto,
                           sizeof(msgProto)/sizeof(TCHAR));
                wsprintf(message,
                         msgProto,
                         formatParams.TotalSpace,
                         formatParams.SpaceAvailable);
                MessageBox(GetActiveWindow(),
                           message,
                           title,
                           MB_ICONINFORMATION | MB_OK);

            }

            // Synchronize with the format thread just in case
            // the user did a cancel and the format thread is
            // still buzy verifying 50MB or some such thing.
            // Rather than use an event this is a polling loop.

            SetCursor(hcurWait);
            while (!formatParams.ThreadIsDone) {
                Sleep(1000);
            }
            SetCursor(hcurNormal);

            // If the format was successful, update the volume
            // information in the data structures.

            if (!formatParams.Result) {

                // get the new label and FsType regardless of success of the
                // format (i.e. user cancel may have occurred, so this stuff
                // is not what it used to be even if the format failed.

                {
                    // force mount by filesystem.  This is done with the
                    // extra \ on the end of the path.  This must be done
                    // in order to get the FS type.  Otherwise the filesystem
                    // recognisor may allow the open without actually getting
                    // the file system involved.

                    char        ntDeviceName[100];
                    STATUS_CODE sc;
                    HANDLE_T    handle;

                    sprintf(ntDeviceName, "\\DosDevices\\%c:\\", regionData->DriveLetter);
                    sc = LowOpenNtName(ntDeviceName, &handle);
                    if (sc == OK_STATUS) {
                        LowCloseDisk(handle);
                    }
                }
                typeName = NULL;
                GetTypeName(RegionDescriptor->Disk, RegionDescriptor->PartitionNumber, &typeName);

                if (!typeName) {

                    // Failed to get the type after a cancel.  This means
                    // GetTypeName() could not open the volume for some reason.
                    // This has been seen on Alpha's and x86 with large
                    // hardware raid devices.  Exiting and starting
                    // over will get an FS type.  For now, don't change the
                    // data structures.

                    TotalRedrawAndRepaint();
                    return;
                }

                tempLabel = NULL;
                if (GetVolumeLabel(RegionDescriptor->Disk, RegionDescriptor->PartitionNumber, &tempLabel) == NO_ERROR) {

                    if (tempLabel) {
                        Free(regionData->VolumeLabel);
                        regionData->VolumeLabel = Malloc((lstrlenW(tempLabel) + 1) * sizeof(WCHAR));
                        lstrcpyW(regionData->VolumeLabel, tempLabel);
                    }
                } else {
                    *regionData->VolumeLabel = 0;
                }

                // update the type name.

                if (regionData->TypeName) {
                    Free(regionData->TypeName);
                    regionData->TypeName = typeName;
                }

                // update the file system type information for all
                // components of this region (i.e. fix up FT structures if
                // it is an FT item).  This is done via knowledge about multiple
                // selections as opposed to walking through the FtObject list.

                if (SelectionCount > 1) {
                    PPERSISTENT_REGION_DATA passedRegionData;
                    ULONG index;

                    // Need to update all involved.

                    passedRegionData = regionData;

                    for (index = 0; index < SelectionCount; index++) {
                        RegionDescriptor = &SELECTED_REGION(index);
                        regionData = PERSISTENT_DATA(RegionDescriptor);

                        if (regionData == passedRegionData) {
                            continue;
                        }

                        if (regionData->VolumeLabel) {
                            Free(regionData->VolumeLabel);
                            regionData->VolumeLabel = NULL;
                        }
                        if (tempLabel) {
                            regionData->VolumeLabel = Malloc((lstrlenW(tempLabel) + 1) * sizeof(WCHAR));
                            lstrcpyW(regionData->VolumeLabel, tempLabel);
                        }

                        if (regionData->TypeName) {
                            Free(regionData->TypeName);
                        }
                        regionData->TypeName = Malloc((lstrlenW(passedRegionData->TypeName) + 1) * sizeof(WCHAR));
                        lstrcpyW(regionData->TypeName, passedRegionData->TypeName);
                    }
                }

                if (tempLabel) {
                    Free(tempLabel);
                }
            }

            // force screen update.

            TotalRedrawAndRepaint();
        }
    }
}

VOID
LabelPartition(
    PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Insure the IFS Dll is loaded and start the dialog for label
    of a volume.

Arguments:

    RegionDescriptor - the region for the label.

Return Value:

    None

--*/

{
    int          doLabel;
    DWORD        ec;
    TCHAR        label[100];
    WCHAR        unicodeLabel[100];
    LABEL_PARAMS labelParams;
    WCHAR        driveLetter[4];
    PWSTR        tmpLabel;
    PPERSISTENT_REGION_DATA regionData;

    if (!LoadIfsDll()) {

        // could not load the Dll

        ErrorDialog(MSG_CANT_LOAD_FMIFS);
        return;
    }
    labelParams.RegionDescriptor = RegionDescriptor;
    labelParams.NewLabel = (LPTSTR)label;
    doLabel = DialogBoxParam(hModule,
                             MAKEINTRESOURCE(IDD_PARTITIONLABEL),
                             hwndFrame,
                             (DLGPROC) LabelDlgProc,
                             (ULONG) &labelParams);
    if (doLabel) {

        regionData = PERSISTENT_DATA(RegionDescriptor);

        if (IsDiskRemovable[RegionDescriptor->Disk]) {
            PWSTR   typeName,
                    volumeLabel;
            ULONG   diskSize;
            BOOLEAN volumeChanged = FALSE;

            if (GetVolumeTypeAndSize(RegionDescriptor->Disk,
                                     RegionDescriptor->PartitionNumber,
                                     &volumeLabel,
                                     &typeName,
                                     &diskSize) == OK_STATUS) {
                // Verify that this is still the same device.

                if (regionData) {
                    if (regionData->VolumeLabel) {
                        if (wcscmp(regionData->VolumeLabel, volumeLabel)) {
                            volumeChanged = TRUE;
                        }
                    }
                    if (regionData->TypeName) {
                        if (wcscmp(regionData->TypeName, typeName)) {
                            volumeChanged = TRUE;
                        }
                    }
                }

                if (Disks[RegionDescriptor->Disk]->DiskSizeMB != (diskSize/1024)) {
                    volumeChanged = TRUE;
                }

                if (volumeChanged) {
                    PWSTR   tempName,
                            tempLabel;

                    ErrorDialog(MSG_VOLUME_CHANGED);

                    // since the user was told the volume changed,
                    // update the display.

                    SetCursor(hcurWait);
                    if (GetVolumeTypeAndSize(RegionDescriptor->Disk,
                                             RegionDescriptor->PartitionNumber,
                                             &tempLabel,
                                             &tempName,
                                             &diskSize) == OK_STATUS) {
                        Free(typeName);
                        typeName = tempName;
                        Free(volumeLabel);
                        volumeLabel = tempLabel;
                    }
                    if (regionData->VolumeLabel) {
                        Free(regionData->VolumeLabel);
                    }
                    regionData->VolumeLabel = volumeLabel;
                    if (regionData->TypeName) {
                        Free(regionData->TypeName);
                    }
                    regionData->TypeName = typeName;
                    SetCursor(hcurNormal);
                    TotalRedrawAndRepaint();
                    return;
                } else {
                    Free(volumeLabel);
                    Free(typeName);
                }
            }
        }
        driveLetter[1] = L':';
        driveLetter[2] = 0;
        driveLetter[0] = (WCHAR)regionData->DriveLetter;

        // convert to unicode - use variable doLabel as an index.

        setUnicode(label,
                   unicodeLabel);

        // perform the label.

        SetCursor(hcurWait);
        (*LabelRoutine)(driveLetter, unicodeLabel);

        ec = GetLastError();

        if (ec != NO_ERROR) {
            SetCursor(hcurNormal);
            ErrorDialog(ec);
            SetCursor(hcurWait);
        }

        // get the new label to be certain it took and update
        // the internal structures.

        if (GetVolumeLabel(RegionDescriptor->Disk, RegionDescriptor->PartitionNumber, &tmpLabel) == NO_ERROR) {
            Free(regionData->VolumeLabel);
            regionData->VolumeLabel = Malloc((lstrlenW(tmpLabel) + 1) * sizeof(WCHAR));
            lstrcpyW(regionData->VolumeLabel, tmpLabel);
        } else {
            *regionData->VolumeLabel = 0;
        }

        // update the label for all
        // components of this region (i.e. fix up FT structures if
        // it is an FT item).  This is done via knowledge about multiple
        // selections as opposed to walking through the FtObject list.

        if (SelectionCount > 1) {
            PPERSISTENT_REGION_DATA passedRegionData;
            ULONG index;

            // Need to update all involved.

            passedRegionData = regionData;

            for (index = 0; index < SelectionCount; index++) {
                RegionDescriptor = &SELECTED_REGION(index);
                regionData = PERSISTENT_DATA(RegionDescriptor);

                if (regionData == passedRegionData) {
                    continue;
                }

                if (regionData->VolumeLabel) {
                    Free(regionData->VolumeLabel);
                    regionData->VolumeLabel = NULL;
                }
                if (tmpLabel) {
                    regionData->VolumeLabel = Malloc((lstrlenW(tmpLabel) + 1) * sizeof(WCHAR));
                    lstrcpyW(regionData->VolumeLabel, tmpLabel);
                } else {
                    *regionData->VolumeLabel = 0;
                }
            }
        }
        if (tmpLabel) {
            Free(tmpLabel);
        }
        SetCursor(hcurNormal);

        // force screen update.

        TotalRedrawAndRepaint();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\ftregres.h ===
#define IDC_LISTBOX                 101
#define IDD_SELDIR                  100
#define IDC_SIMPLE_TEXT_LINE        201
#define IDD_SIMPLETEXT              300
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\ntlow.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    ntlow.c

Abstract:

    This file contains the low-level I/O routines, implemented
    to run on NT.

Author:

    Ted Miller        (tedm)    8-Nov-1991

Revision History:

    Bob Rinne         (bobri)   2-Feb-1994
    Dynamic partitioning changes.

--*/


#include "fdisk.h"
#include <stdio.h>
#include <string.h>


STATUS_CODE
LowQueryFdiskPathList(
    OUT PCHAR  **PathList,
    OUT PULONG   ListLength
    )

/*++

Routine Description:

    This routine determines how many drives are present in the
    system and returns a list of Ascii strings for the names of
    each of the drives found.

    When a drive is located, a check is made to insure that the
    associated DosName for the physical drive is also present in
    the system.

Arguments:

    PathList   - pointer to a pointer for the list
    ListLength - the number of entries returned in the list

Return Value:

    Error status if there is a problem.

--*/

{
    HANDLE      dummyHandle;
    STATUS_CODE status;
    ULONG       count = 0;
    ULONG       i;
    char        buffer[100];
    PCHAR      *pathArray;

    while (1) {

        sprintf(buffer, "\\device\\harddisk%u", count);
        status = LowOpenDisk(buffer, &dummyHandle);

        // Only STATUS_OBJECT_PATH_NOT_FOUND can terminate the count.

        if (NT_SUCCESS(status)) {
            char dosNameBuffer[80];

            LowCloseDisk(dummyHandle);

            // Insure that the physicaldrive name is present

            sprintf(dosNameBuffer, "\\dosdevices\\PhysicalDrive%u", count);
            status = LowOpenNtName(dosNameBuffer, &dummyHandle);
            if (NT_SUCCESS(status)) {
                LowCloseDisk(dummyHandle);
            } else {

                // Not there, create it.

                sprintf(buffer, "\\device\\harddisk%u\\Partition0", count);
                DefineDosDevice(DDD_RAW_TARGET_PATH, (LPCTSTR) dosNameBuffer, (LPCTSTR) buffer);
            }
        } else if (status == STATUS_OBJECT_PATH_NOT_FOUND) {

            break;
        } else if (status == STATUS_ACCESS_DENIED) {

            return status;
        }
        count++;
    }

    pathArray = Malloc(count * sizeof(PCHAR));

    for (i=0; i<count; i++) {

        sprintf(buffer, "\\device\\harddisk%u", i);
        pathArray[i] = Malloc(lstrlenA(buffer)+1);
        strcpy(pathArray[i], buffer);
    }

    *PathList = pathArray;
    *ListLength = count;
    return OK_STATUS;
}


STATUS_CODE
LowFreeFdiskPathList(
    IN OUT  PCHAR*  PathList,
    IN      ULONG   ListLength
    )

/*++

Routine Description:

    Walk the provided list up to its length and free the memory
    allocated.  Upon completion, free the memory for the list
    itself.

Arguments:

    PathList   - pointer to base of path list
    ListLength - number of entries in the list

Return Value:

    Always OK_STATUS

--*/

{
    ULONG i;

    for (i=0; i<ListLength; i++) {
        FreeMemory(PathList[i]);
    }
    FreeMemory(PathList);
    return OK_STATUS;
}


STATUS_CODE
LowOpenNtName(
    IN PCHAR     Name,
    IN HANDLE_PT Handle
    )

/*++

Routine Description:

    This is an internal "Low" routine to handle open requests.

Arguments:

    Name - pointer to the NT name for the open.
    Handle - pointer for the handle returned.

Return Value:

    NT status

--*/

{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;
    ANSI_STRING       ansiName;
    UNICODE_STRING    unicodeName;

    RtlInitAnsiString(&ansiName, Name);
    status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, TRUE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.ObjectName = &unicodeName;
    oa.Attributes = OBJ_CASE_INSENSITIVE;

    status = DmOpenFile(Handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);


    if (!NT_SUCCESS(status)) {

        FDLOG((1,"LowOpen: 1st open failed with 0x%x\n", status));

        // try a 2nd time to get around an FS glitch or a test
        // bug where this doesn't work on an attempt to delete a
        // partition

        Sleep(500);
        status = DmOpenFile(Handle,
                            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                            &oa,
                            &statusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_SYNCHRONOUS_IO_ALERT);
        FDLOG((1,"LowOpen: 2nd open 0x%x\n", status));
    }
    RtlFreeUnicodeString(&unicodeName);
    return status;
}


STATUS_CODE
LowOpenDriveLetter(
    IN CHAR      DriveLetter,
    IN HANDLE_PT Handle
    )

/*++

Routine Description:

    Given a drive letter, open it and return a handle.

Arguments:

    DriveLetter - the letter to open
    Handle      - a pointer to a handle

Return Value:

    NT status

--*/

{
    char        ntDeviceName[100];

    sprintf(ntDeviceName,
            "\\DosDevices\\%c:",
            DriveLetter);
    return LowOpenNtName(ntDeviceName, Handle);
}


STATUS_CODE
LowOpenPartition(
    IN  PCHAR     DevicePath,
    IN  ULONG     Partition,
    OUT HANDLE_PT Handle
    )

/*++

Routine Description:

    Construct the NT device name for the Partition value given
    and perform the NT APIs to open the device.

Arguments:

    DevicePath - the string to the device without the partition
                 portion of the name.  This is constructed using
                 the Partition value passed
    Partition  - the partion desired
    Handle     - pointer to a handle pointer for the result

Return Value:

    NT status

--*/

{
    char        ntDeviceName[100];

    sprintf(ntDeviceName,
            "%s\\partition%u",
            DevicePath,
            Partition);
    return LowOpenNtName(ntDeviceName, Handle);
}


STATUS_CODE
LowOpenDisk(
    IN  PCHAR     DevicePath,
    OUT HANDLE_PT DiskId
    )

/*++

Routine Description:

    Perform the NT actions to open a device.

Arguments:

    DevicePath - Ascii device name
    DiskId     - pointer to a handle pointer for the returned
                 handle value

Return Value:

    NT status

--*/

{
    return(LowOpenPartition(DevicePath, 0, DiskId));
}


STATUS_CODE
LowCloseDisk(
    IN HANDLE_T DiskId
    )

/*++

Routine Description:

    Close a disk handle.

Arguments:

    DiskId - the actual NT handle

Return Value:

    NT status

--*/

{
    return(DmClose(DiskId));
}


STATUS_CODE
LowLockDrive(
    IN HANDLE_T DiskId
    )

/*++

Routine Description:

    Perform the NT API to cause a volume to be locked.
    This is a File System device control.

Arguments:

    DiskId - the actual NT handle to the drive

Return Value:

    NT status

--*/

{
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;

    status = NtFsControlFile(DiskId,
                             0,
                             NULL,
                             NULL,
                             &statusBlock,
                             FSCTL_LOCK_VOLUME,
                             NULL,
                             0,
                             NULL,
                             0);

    if (!NT_SUCCESS(status)) {
            FDLOG((1, "LowLock: failed with 0x%x\n", status));
    }
    return status;
}


STATUS_CODE
LowUnlockDrive(
    IN HANDLE_T DiskId
    )

/*++

Routine Description:

    Perform the NT API to cause a volume to be unlocked.
    This is a File System device control.

Arguments:

    DiskId - the actual NT handle to the drive

Return Value:

    NT status

--*/

{
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;

    status = NtFsControlFile(DiskId,
                             0,
                             NULL,
                             NULL,
                             &statusBlock,
                             FSCTL_DISMOUNT_VOLUME,
                             NULL,
                             0,
                             NULL,
                             0);
    status = NtFsControlFile(DiskId,
                             0,
                             NULL,
                             NULL,
                             &statusBlock,
                             FSCTL_UNLOCK_VOLUME,
                             NULL,
                             0,
                             NULL,
                             0);
    return status;
}


STATUS_CODE
LowGetDriveGeometry(
    IN  PCHAR  Path,
    OUT PULONG TotalSectorCount,
    OUT PULONG SectorSize,
    OUT PULONG SectorsPerTrack,
    OUT PULONG Heads
    )

/*++

Routine Description:

    Routine collects information concerning the geometry
    of a specific drive.

Arguments:

    Path        - Ascii path name to get to disk object
                  this is not a full path, but rather
                  a path without the Partition indicator
                  \device\harddiskX
    TotalSectorCount- pointer to ULONG for result
    SectorSize      - pointer to ULONG for result
    SectorsPerTrack - pointer to ULONG for result
    Heads           - pointer to ULONG for result

Return Value:

    NT status

--*/

{
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY   diskGeometry;
    STATUS_CODE     status;
    HANDLE          handle;

    if ((status = LowOpenDisk(Path, &handle)) != OK_STATUS) {
        return status;
    }

    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                   NULL,
                                   0,
                                   &diskGeometry,
                                   sizeof(DISK_GEOMETRY));
    if (!NT_SUCCESS(status)) {
        return (STATUS_CODE)status;
    }
    LowCloseDisk(handle);

    *SectorSize       = diskGeometry.BytesPerSector;
    *SectorsPerTrack  = diskGeometry.SectorsPerTrack;
    *Heads            = diskGeometry.TracksPerCylinder;
    *TotalSectorCount = (RtlExtendedIntegerMultiply(diskGeometry.Cylinders,
                                                    *SectorsPerTrack * *Heads)).LowPart;
    return(OK_STATUS);
}


STATUS_CODE
LowGetDiskLayout(
    IN  PCHAR                      Path,
    OUT PDRIVE_LAYOUT_INFORMATION *DriveLayout
    )

/*++

Routine Description:

    Perform the necessary NT API calls to get the drive
    layout from the disk and return it in a memory buffer
    allocated by this routine.

Arguments:

    Path        - Ascii path name to get to disk object
                  this is not a full path, but rather
                  a path without the Partition indicator
                  \device\harddiskX

    DriveLayout - pointer to pointer for the drive layout result

Return Value:

    NT status

--*/

{
    PDRIVE_LAYOUT_INFORMATION layout;
    IO_STATUS_BLOCK statusBlock;
    STATUS_CODE     status;
    ULONG           bufferSize;
    HANDLE          handle;

    bufferSize = sizeof(DRIVE_LAYOUT_INFORMATION)
               + (500 * sizeof(PARTITION_INFORMATION));

    if ((layout = AllocateMemory(bufferSize)) == NULL) {
        RETURN_OUT_OF_MEMORY;
    }

    if ((status = LowOpenDisk(Path, &handle)) != OK_STATUS) {
        FreeMemory(layout);
        return status;
    }

    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_DRIVE_LAYOUT,
                                   NULL,
                                   0,
                                   layout,
                                   bufferSize);
    LowCloseDisk(handle);

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_BAD_MASTER_BOOT_RECORD) {

            FDLOG((1,"LowGetDiskLayout: Disk device %s has bad MBR\n",Path));

            // Zero the drive layout information for the fdengine to process.

            RtlZeroMemory(layout, bufferSize);
        } else {
            FDLOG((0,"LowGetDiskLayout: Status %lx getting layout for disk device %s\n",status,Path));
            FreeMemory(layout);
            return status;
        }
    } else {

        FDLOG((2,"LowGetDiskLayout: layout received from ioctl for %s follows:\n",Path));
        LOG_DRIVE_LAYOUT(layout);
    }

    // Check to insure that the drive supports dynamic partitioning.

    *DriveLayout = layout;
    return OK_STATUS;
}


STATUS_CODE
LowSetDiskLayout(
    IN PCHAR                     Path,
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout
    )

/*++

Routine Description:

    Perform the NT API actions of opening Partition0 for
    the specified drive and setting the drive layout.

Arguments:

    Path        - Ascii path name to get to disk object
                  this is not a full path, but rather
                  a path without the Partition indicator
                  \device\harddiskX

    DriveLayout - new layout to set

Return Value:

    NT status

--*/

{
    IO_STATUS_BLOCK statusBlock;
    STATUS_CODE     status;
    HANDLE          handle;
    ULONG           bufferSize;

    if ((status = LowOpenDisk(Path, &handle)) != OK_STATUS) {

        return status;
    }  else {

        FDLOG((2, "LowSetDiskLayout: calling ioctl for %s, layout follows:\n", Path));
        LOG_DRIVE_LAYOUT(DriveLayout);
    }

    bufferSize = sizeof(DRIVE_LAYOUT_INFORMATION)
               + (  (DriveLayout->PartitionCount - 1)
                   * sizeof(PARTITION_INFORMATION));
    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_SET_DRIVE_LAYOUT,
                                   DriveLayout,
                                   bufferSize,
                                   DriveLayout,
                                   bufferSize);
    LowCloseDisk(handle);
    return status;
}


STATUS_CODE
LowWriteSectors(
    IN  HANDLE_T    VolumeId,
    IN  ULONG       SectorSize,
    IN  ULONG       StartingSector,
    IN  ULONG       NumberOfSectors,
    IN  PVOID       Buffer
    )

/*++

Routine Description:

    Routine to write to a volume handle.  This routine
    insulates the NT issues concerning the call from the
    caller.

Arguments:

    VolumeId        - actually the NT handle.
    SectorSize      - used to calculate starting byte offset for I/O
    StartingSector  - starting sector for write.
    NumberOfSectors - size of I/O in sectors
    Buffer          - the location for the data

Return Value:

    Standard NT status values

--*/

{
    IO_STATUS_BLOCK statusBlock;
    LARGE_INTEGER   byteOffset;

    byteOffset = RtlExtendedIntegerMultiply(RtlConvertUlongToLargeInteger(StartingSector), (LONG)SectorSize);

    statusBlock.Status = 0;
    statusBlock.Information = 0;
    return(NtWriteFile(VolumeId,
                       0,
                       NULL,
                       NULL,
                       &statusBlock,
                       Buffer,
                       NumberOfSectors * SectorSize,
                       &byteOffset,
                       NULL));
}


STATUS_CODE
LowReadSectors(
    IN  HANDLE_T    VolumeId,
    IN  ULONG       SectorSize,
    IN  ULONG       StartingSector,
    IN  ULONG       NumberOfSectors,
    IN  PVOID       Buffer
    )

/*++

Routine Description:

    Routine to read from a volume handle.  This routine
    insulates the NT issues concerning the call from the
    caller.

Arguments:

    VolumeId        - actually the NT handle.
    SectorSize      - used to calculate starting byte offset for I/O
    StartingSector  - starting sector for write.
    NumberOfSectors - size of I/O in sectors
    Buffer          - the location for the data

Return Value:

    Standard NT status values

--*/

{
    IO_STATUS_BLOCK statusBlock;
    LARGE_INTEGER   byteOffset;

    byteOffset = RtlExtendedIntegerMultiply(RtlConvertUlongToLargeInteger(StartingSector), (LONG)SectorSize);

    statusBlock.Status = 0;
    statusBlock.Information = 0;
    return(NtReadFile(VolumeId,
                      0,
                      NULL,
                      NULL,
                      &statusBlock,
                      Buffer,
                      NumberOfSectors * SectorSize,
                      &byteOffset,
                      NULL));
}


STATUS_CODE
LowFtVolumeStatus(
    IN ULONG          Disk,
    IN ULONG          Partition,
    IN PFT_SET_STATUS FtStatus,
    IN PULONG         NumberOfMembers
    )

/*++

Routine Description:

    Open the requested partition and query the FT state.

Arguments:

    DriveLetter - the letter for the current state
    FtState     - a pointer to a location to return state
    NumberOfMembers - a pointer to a ULONG for number of members
                      in the FT set.

Return Value:

    Standard NT status values

--*/

{
    HANDLE             handle;
    STATUS_CODE        status;
    IO_STATUS_BLOCK    statusBlock;
    FT_SET_INFORMATION setInfo;

    status = LowOpenPartition(GetDiskName(Disk),
                              Partition,
                              &handle);

    if (status == OK_STATUS) {

        status = NtDeviceIoControlFile(handle,
                                       0,
                                       NULL,
                                       NULL,
                                       &statusBlock,
                                       FT_QUERY_SET_STATE,
                                       NULL,
                                       0,
                                       &setInfo,
                                       sizeof(setInfo));
        LowCloseDisk(handle);

        if (status == OK_STATUS) {
            switch (setInfo.SetState) {
            case FtStateOk:
                *FtStatus = FtSetHealthy;
                break;

            case FtHasOrphan:
                switch (setInfo.Type) {
                case Mirror:
                    *FtStatus = FtSetBroken;
                    break;
                case StripeWithParity:
                    *FtStatus = FtSetRecoverable;
                    break;
                }
                break;

            case FtRegenerating:
                *FtStatus = FtSetRegenerating;
                break;

            case FtCheckParity:
                *FtStatus = FtSetInitializationFailed;
                break;

            case FtInitializing:
                *FtStatus = FtSetInitializing;
                break;

            case FtDisabled:

                // This will never happen.

                *FtStatus = FtSetDisabled;
                break;

            case FtNoCheckData:
            default:

                // BUGBUG: there is no mapping here.

                *FtStatus = FtSetHealthy;
                break;
            }
            *NumberOfMembers = setInfo.NumberOfMembers;
        }
    } else {

        // If the FT set could not be opened, then it must be
        // disabled if the return code is "No such device".

        if (status == 0xc000000e) {
            *FtStatus = FtSetDisabled;
            status = OK_STATUS;
        }
    }

    // Always update the state to the caller.

    return status;
}


STATUS_CODE
LowFtVolumeStatusByLetter(
    IN CHAR           DriveLetter,
    IN PFT_SET_STATUS FtStatus,
    IN PULONG         NumberOfMembers
    )

/*++

Routine Description:

    Open the requested drive letter and query the FT state.

Arguments:

    DriveLetter - the letter for the current state
    FtState     - a pointer to a location to return state
    NumberOfMembers - a pointer to a ULONG for number of members
                      in the FT set.

Return Value:

    Standard NT status values

--*/

{
    HANDLE             handle;
    STATUS_CODE        status;
    IO_STATUS_BLOCK    statusBlock;
    FT_SET_INFORMATION setInfo;

    *NumberOfMembers = 1;
    status = LowOpenDriveLetter(DriveLetter,
                                &handle);

    if (status == OK_STATUS) {

        status = NtDeviceIoControlFile(handle,
                                       0,
                                       NULL,
                                       NULL,
                                       &statusBlock,
                                       FT_QUERY_SET_STATE,
                                       NULL,
                                       0,
                                       &setInfo,
                                       sizeof(setInfo));
        LowCloseDisk(handle);

        if (status == OK_STATUS) {
            switch (setInfo.SetState) {
            case FtStateOk:
                *FtStatus = FtSetHealthy;
                break;

            case FtHasOrphan:
                switch (setInfo.Type) {
                case Mirror:
                    *FtStatus = FtSetBroken;
                    break;
                case StripeWithParity:
                    *FtStatus = FtSetRecoverable;
                    break;
                }
                break;

            case FtRegenerating:
                *FtStatus = FtSetRegenerating;
                break;

            case FtCheckParity:
                *FtStatus = FtSetInitializationFailed;
                break;

            case FtInitializing:
                *FtStatus = FtSetInitializing;
                break;

            case FtDisabled:

                // This will never happen.

                *FtStatus = FtSetDisabled;
                break;

            case FtNoCheckData:
            default:

                // BUGBUG: there is no mapping here.

                *FtStatus = FtSetHealthy;
                break;
            }
            *NumberOfMembers = setInfo.NumberOfMembers;
        }
    } else {

        // If the FT set could not be opened, then it must be
        // disabled if the return code is "No such device".

        if (status == 0xc000000e) {
            *FtStatus = FtSetDisabled;
            status = OK_STATUS;
        }
    }

    // Always update the state to the caller.

    return status;
}



#define NUMBER_OF_HANDLES_TRACKED 500
HANDLE OpenHandleArray[NUMBER_OF_HANDLES_TRACKED];
BOOLEAN DmFirstTime = TRUE;
ULONG   HandleHighWaterMark = 0;

NTSTATUS
DmOpenFile(
    OUT PHANDLE           FileHandle,
    IN ACCESS_MASK        DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK  IoStatusBlock,
    IN ULONG              ShareAccess,
    IN ULONG              OpenOptions
    )

/*++

Routine Description:

    A debugging aid to track open and closes of partitions.

Arguments:

    Same as for NtOpenFile()

Return Value:

    Same as for NtOpenFile()

--*/

{
    ULONG    index;
    NTSTATUS status;

    if (DmFirstTime) {
        DmFirstTime = FALSE;
        for (index = 0; index < NUMBER_OF_HANDLES_TRACKED; index++) {
            OpenHandleArray[index] = (HANDLE) 0;
        }
    }

    status = NtOpenFile(FileHandle,
                        DesiredAccess,
                        ObjectAttributes,
                        IoStatusBlock,
                        ShareAccess,
                        OpenOptions);
    if (NT_SUCCESS(status)) {
        for (index = 0; index < NUMBER_OF_HANDLES_TRACKED; index++) {
            if (OpenHandleArray[index] == (HANDLE) 0) {
                OpenHandleArray[index] = *FileHandle;

                if (index > HandleHighWaterMark) {
                    HandleHighWaterMark = index;
                }
                break;
            }
        }
    }
    return status;
}


NTSTATUS
DmClose(
    IN HANDLE Handle
    )

/*++

Routine Description:

    A debugging aid for tracking open and closes

Arguments:

    Same as for NtClose()

Return Value:

    Same as for NtClose()

--*/

{
    ULONG index;

    for (index = 0; index < NUMBER_OF_HANDLES_TRACKED; index++) {
        if (OpenHandleArray[index] == Handle) {
            OpenHandleArray[index] = (HANDLE) 0;
            break;
        }
    }

    return NtClose(Handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\network.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains the set of routines that support updating network
    drive shares when adding and deleting drive letters.

Author:

    Bob Rinne (bobri)  12/26/94

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "shellapi.h"
#include <winbase.h>
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include <lm.h>

// Data area to hold the permissions that are to be assigned to the
// administrative shares C$, D$, etc.  This is obtained during initialization
// and not changed, just used when a new administrator share needes to
// be made.

LPBYTE ShareInformationBuffer;

// Only perform network actions if this value is true.  This value
// is set if the initialization of this module completes successfully.

BOOLEAN NetworkEnabled;


VOID
NetworkInitialize(
    )

/*++

Routine Description:

    Intialize the permissions constants for any new administrator
    driver letter shares.

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR           shareName[4];
    NET_API_STATUS  status;
    PSHARE_INFO_502 info;
    LPTSTR          string;

    shareName[1] = (WCHAR) '$';
    shareName[2] = (WCHAR) 0;

    for (shareName[0] = (WCHAR) 'C'; shareName[0] <= (WCHAR) 'Z'; shareName[0]++) {

        // Since windisk is still built as a non-unicode application,
        // the parameter "shareName" must be unicode, but the prototype
        // specifies that it is a (char *).  Do the typecast to remove
        // warnings.

         status = NetShareGetInfo(NULL,
                                  (char *) shareName,
                                  502,
                                  &ShareInformationBuffer);
         if (status == NERR_Success) {

             // Update the remarks and password to be NULL.

             info = (PSHARE_INFO_502) ShareInformationBuffer;
             string = info->shi502_remark;
             if (string) {
                 *string = (TCHAR) 0;
             }
             string = info->shi502_passwd;
             if (string) {
                 *string = (TCHAR) 0;
             }

             // Network shares are to be updated.

             NetworkEnabled = TRUE;
             return;
         }
    }

    // Can't find any network shares - do not attempt updates
    // of administrator shares.

    NetworkEnabled = FALSE;
}

VOID
NetworkShare(
    IN LPCTSTR DriveLetter
    )

/*++

Routine Description:

    Given a drive letter, construct the default administrator share
    for the letter.  This is the C$, D$, etc share for the drive.

Arguments:

    DriveLetter - the drive letter to share.

Return Value:

    None

--*/

{
    NET_API_STATUS  status;
    PSHARE_INFO_502 info;
    LPTSTR          string;

    if (NetworkEnabled) {
        info = (PSHARE_INFO_502) ShareInformationBuffer;

        // Set up the new network name.

        string = info->shi502_netname;
        *string = *DriveLetter;

        // Set up the path.  All that need be added is the drive letter
        // the rest of the path (":\") is already in the structure.

        string = info->shi502_path;
        *string = *DriveLetter;

        status = NetShareAdd(NULL,
                             502,
                             ShareInformationBuffer,
                             NULL);
    }
}


VOID
NetworkRemoveShare(
    IN LPCTSTR DriveLetter
    )

/*++

Routine Description:

    Remove the administrator share for the given letter.

Arguments:

    DriveLetter - the drive letter to share.

Return Value:

    None

--*/

{
    NET_API_STATUS status;
    WCHAR shareName[4];

    if (NetworkEnabled) {
        shareName[0] = (WCHAR) *DriveLetter;
        shareName[1] = (WCHAR) '$';
        shareName[2] = (WCHAR) 0;

        // Since windisk is still built as a non-unicode application,
        // the parameter "shareName" must be unicode, but the prototype
        // specifies that it is a (char *).  Do the typecast to remove
        // warnings.

        status = NetShareDel(NULL,
                             (char *) shareName,
                             0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\ftreg.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    ftreg.c

Abstract:

    This module contains the routines for Disk Administrator that deal
    with registry manipulation

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    1-Feb-94 (bobri) Clean up and handle missing floppy disk on registry
                     save/restore.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "fdisk.h"
#include "ftregres.h"



// attempt to avoid conflict

#define TEMP_KEY_NAME       TEXT("xzss3___$$Temp$Hive$$___")

#define DISK_KEY_NAME       TEXT("DISK")
#define DISK_VALUE_NAME     TEXT("Information")


LONG
FdpLoadHiveIntoRegistry(
    IN LPTSTR HiveFilename
    )

/*++

Routine Description:

    This routine writes the contents of a given hive file into the registry,
    rooted at a temporary key in HKEY_LOCAL_MACHINE.

Arguments:

    HiveFilename - supplies filename of the hive to be loaded into
        the registry

Return Value:

    Windows error code.

--*/

{
    NTSTATUS Status;
    BOOLEAN  OldPrivState;
    LONG     Err;

    // Attempt to get restore privilege

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &OldPrivState);
    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError(Status);
    }

    // Load the hive into our registry

    Err = RegLoadKey(HKEY_LOCAL_MACHINE,TEMP_KEY_NAME,HiveFilename);

    // Restore old privilege if necessary

    if (!OldPrivState) {

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                           FALSE,
                           FALSE,
                           &OldPrivState);
    }

    return Err;
}


LONG
FdpUnloadHiveFromRegistry(
    VOID
    )

/*++

Routine Description:

    This routine removes a tree (previously loaded with
    FdpLoadHiveIntoRegistry) from the temporary key in HKEY_LOCAL_MACHINE.

Arguments:

    None.

Return Value:

    Windows error code.

--*/

{
    NTSTATUS Status;
    BOOLEAN  OldPrivState;
    LONG     Err;

    // Attempt to get restore privilege

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &OldPrivState);
    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError(Status);
    }

    // Unload the hive from our registry

    Err = RegUnLoadKey(HKEY_LOCAL_MACHINE,TEMP_KEY_NAME);

    // Restore old privilege if necessary

    if (!OldPrivState) {

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                           FALSE,
                           FALSE,
                           &OldPrivState);
    }

    return Err;
}


LONG
FdpGetDiskInfoFromKey(
    IN  LPTSTR  RootKeyName,
    OUT PVOID  *DiskInfo,
    OUT PULONG  DiskInfoSize
    )

/*++

Routine Description:

    This routine pulls the binary blob containing disk ft, drive letter,
    and layout information out of a given registry key.

    The info is found in HKEY_LOCAL_MACHINE,<RootKeyName>\DISK:Information.

Arguments:

    RootKeyName - name of the subkey of HKEY_LOCAL_MACHINE that is to
        contain the DISK key.

    DiskInfo - receives a pointer to a buffer containing the disk info.

    DiskInfoSize - receives size of the disk buffer.

Return Value:

    Windows error code.  If NO_ERROR, DiskInfo and DiskInfoSize are
    filled in, and it is the caller's responsibility to free the buffer
    when it is finished (via LocalFree()).

--*/

{
    LONG     Err;
    HKEY     hkeyDisk;
    ULONG    BufferSize;
    ULONG    ValueType;
    PVOID    Buffer;
    LPTSTR   DiskKeyName;

    // Form the name of the DISK key

    DiskKeyName = (LPTSTR)LocalAlloc( LMEM_FIXED,
                                        (   lstrlen(RootKeyName)
                                          + lstrlen(DISK_KEY_NAME)
                                          + 2           //  the \ and nul
                                        )
                                      * sizeof(TCHAR)
                                    );

    if (DiskKeyName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    lstrcpy(DiskKeyName,RootKeyName);
    lstrcat(DiskKeyName,TEXT("\\"));
    lstrcat(DiskKeyName,DISK_KEY_NAME);

    // Open the DISK key.

    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DiskKeyName,
                       REG_OPTION_RESERVED,
                       KEY_READ,
                       &hkeyDisk);

    if (Err != NO_ERROR) {
        goto CleanUp2;
    }

    // Determine how large we need the buffer to be

    Err = RegQueryValueEx(hkeyDisk,
                          DISK_VALUE_NAME,
                          NULL,
                          &ValueType,
                          NULL,
                          &BufferSize);

    if ((Err != NO_ERROR) && (Err != ERROR_MORE_DATA)) {
        goto CleanUp1;
    }

    // Allocate a buffer of appropriate size

    Buffer = (PVOID)LocalAlloc(LMEM_FIXED,BufferSize);
    if (Buffer == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp1;
    }

    // Query the data

    Err = RegQueryValueEx(hkeyDisk,
                          DISK_VALUE_NAME,
                          NULL,
                          &ValueType,
                          Buffer,
                          &BufferSize);

    if (Err != NO_ERROR) {
        LocalFree(Buffer);
        goto CleanUp1;
    }

    *DiskInfo = Buffer;
    *DiskInfoSize = BufferSize;

  CleanUp1:

    RegCloseKey(hkeyDisk);

  CleanUp2:

    LocalFree(DiskKeyName);

    return Err;
}


LONG
FdpGetDiskInfoFromHive(
    IN  PCHAR   HiveFilename,
    OUT PVOID  *DiskInfo,
    OUT PULONG  DiskInfoSize
    )

/*++

Routine Description:

    This routine pulls the binary blob containing disk ft, drive letter,
    and layout information out of a given registry hive, which must be
    a file in an alternate NT tree (ie, can't be an active hive).

    The info is found in \DISK:Information within the hive.

Arguments:

    HiveFilename - supplies filename of hive

    DiskInfo - receives a pointer to a buffer containing the disk info.

    DiskInfoSize - receives size of the disk buffer.

Return Value:

    Windows error code.  If NO_ERROR, DiskInfo and DiskInfoSize are
    filled in, and it is the caller's responsibility to free the buffer
    when it is finished (via LocalFree()).

--*/

{
    ULONG windowsError;

    windowsError = FdpLoadHiveIntoRegistry(HiveFilename);
    if (windowsError == NO_ERROR) {
        windowsError = FdpGetDiskInfoFromKey(TEMP_KEY_NAME,DiskInfo,DiskInfoSize);
        FdpUnloadHiveFromRegistry();
    }

    return windowsError;
}


LONG
FdTransferOldDiskInfoToRegistry(
    IN PCHAR HiveFilename
    )

/*++

Routine Description:

    This routine transfers disk configuration from a given hive file
    (which should be an inactive system hive) to the current registry.

Arguments:

    HiveFilename - supplies filename of source hive

Return Value:

    Windows error code.

--*/

{
    LONG  windowsError;
    PVOID diskInfo;
    ULONG diskInfoSize;
    HKEY  hkeyDisk;


    // Load up the hive and pull the disk info from it.

    windowsError = FdpGetDiskInfoFromHive(HiveFilename,&diskInfo,&diskInfoSize);
    if (windowsError != NO_ERROR) {
        return windowsError;
    }

    // Propogate the disk info into the current registry.
    //
    // Start by opening HKEY_LOCAL_MACHINE,System\DISK

    windowsError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                TEXT("System\\") DISK_KEY_NAME,
                                REG_OPTION_RESERVED,
                                KEY_WRITE,
                                &hkeyDisk);

    if (windowsError != NO_ERROR) {
        LocalFree(diskInfo);
        return windowsError;
    }

    // Set the Information value in the DISK key.

    windowsError = RegSetValueEx(hkeyDisk,
                                 DISK_VALUE_NAME,
                                 0,
                                 REG_BINARY,
                                 diskInfo,
                                 diskInfoSize);
    RegCloseKey(hkeyDisk);
    LocalFree(diskInfo);
    return windowsError;
}


typedef struct _STRING_LIST_NODE {
    struct _STRING_LIST_NODE *Next;
    LPTSTR                    String;
} STRING_LIST_NODE, *PSTRING_LIST_NODE;

PSTRING_LIST_NODE FoundDirectoryList;
ULONG             FoundDirectoryCount;

TCHAR Pattern[MAX_PATH+1];
WIN32_FIND_DATA FindData;
OFSTRUCT OfStruct;
HWND hwndStatus;
BOOLEAN ScanDrive[26];
BOOLEAN UserCancelled;


typedef
BOOL
(*PFOUND_HIVE_ROUTINE)(
    IN LPTSTR Directory
    );

VOID
ProcessPendingMessages(
    VOID
    )

/*++

Routine Description:

    Preprocess messages.

Arguments:

    None

Return Value:

    None

--*/

{
    MSG msg;

    while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }
}



PUCHAR ConfigRegistryPath = "\\system32\\config\\system";
BOOL
FdpSearchTreeForSystemHives(
    IN LPTSTR                CurrentDirectory,
    IN PFOUND_HIVE_ROUTINE   FoundHiveRoutine,
    IN HWND                  hdlg
    )

/*++

Routine Description:

    Search an entire directory tree for system and system.alt hive files.
    When found, call a callback function with the directory in which
    system32\config\system[.alt] was found, and the full path of the hive
    file.

    The root directory is not included in the search.

    The top-level call to this function should have a current directory
    like "C:." (ie, no slash for the root directory).

Arguments:

    CurrentDirectory - supplies current directory search path

Return Value:

    FALSE if error (callback function returned FALSE when we found an entry).

--*/

{
    HANDLE findHandle;
    TCHAR  newDirectory[MAX_PATH+1];
    BOOL   found = FALSE;

    // Iterate through the current directory, looking for subdirectories.

    lstrcpy(Pattern, CurrentDirectory);
    lstrcat(Pattern, "\\*");
    findHandle = FindFirstFile(Pattern, &FindData);

    if (findHandle != INVALID_HANDLE_VALUE) {

        do {

            ProcessPendingMessages();
            if (UserCancelled) {
                return FALSE;
            }

            // If the current match is not a directory then skip it.

            if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            || !lstrcmp(FindData.cFileName,TEXT("."))
            || !lstrcmp(FindData.cFileName,TEXT(".."))) {
                continue;
            }

            found = FALSE;

            // Form the name of the file we are looking for
            // [<currentdirectory>\<match>\system32\config\system]

            lstrcpy(Pattern, CurrentDirectory);
            lstrcat(Pattern, "\\");
            lstrcat(Pattern, FindData. cFileName);

            lstrcpy(newDirectory, Pattern);

            // Don't decend into the directory unless the path to the
            // hive.alt name is within MAX_PATH length.

            if ((ULONG)(lstrlen(newDirectory) / sizeof(TCHAR)) < (MAX_PATH - strlen(ConfigRegistryPath) - 4)) {

                SetDlgItemText(hdlg, IDC_SIMPLE_TEXT_LINE, newDirectory);

                lstrcat(Pattern, TEXT(ConfigRegistryPath));

                if (OpenFile(Pattern, &OfStruct, OF_EXIST) != (HFILE)(-1)) {
                    found = TRUE;
                }

                // Also check for a system.alt file there

                lstrcat(Pattern,TEXT(".alt"));

                if (OpenFile(Pattern, &OfStruct, OF_EXIST) != (HFILE)(-1)) {
                    found = TRUE;
                }

                if (found) {
                    if (!FoundHiveRoutine(newDirectory)) {
                        return FALSE;
                    }
                }

                // Descend into the directory we just found

                if (!FdpSearchTreeForSystemHives(newDirectory, FoundHiveRoutine, hdlg)) {
                    return FALSE;
                }
            }

        } while (FindNextFile(findHandle,&FindData));

        FindClose(findHandle);
    }

    return TRUE;
}


BOOL
FdpFoundHiveCallback(
    IN PCHAR Directory
    )

/*++

Routine Description:

    This routine is called when a directory containing a system hive
    has been located.  If all goes well (allocate memory and the like)
    this routine will save the directory name in a list for later use.
    NOTE: No checks are made on the directory name being greater in
    length than MAX_PATH.  It is the responsibility of the caller to
    insure that this is true.

Arguments:

    Directory - the pointer to the character string for the directory
                where a hive has been located.

Return Value:

    TRUE - did something with it.
    FALSE - did not save the directory.

--*/

{
    TCHAR             windowsDir[MAX_PATH+1];
    PSTRING_LIST_NODE dirItem;
    LPTSTR            p;

    // If this is the current windows directory, skip it.

    GetWindowsDirectory(windowsDir, sizeof(windowsDir)/sizeof(TCHAR));

    if (!lstrcmpi(Directory, windowsDir)) {
        return TRUE;
    }

    // Save the directory information away

    dirItem = (PSTRING_LIST_NODE)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(STRING_LIST_NODE));
    if (dirItem == NULL) {
        return FALSE;
    }

    p = (LPTSTR)LocalAlloc(LMEM_FIXED,(lstrlen(Directory)+1) * sizeof(TCHAR));
    if (p == NULL) {
        LocalFree(dirItem);
        return FALSE;
    }

    dirItem->String = p;
    lstrcpy(p, Directory);

    // Update the global chain of found directories.

    dirItem->Next = FoundDirectoryList;
    FoundDirectoryList = dirItem;
    FoundDirectoryCount++;
    return TRUE;
}


VOID
FdpFreeDirectoryList(
    VOID
    )

/*++

Routine Description:

    Go through the list of directories containing system hives and
    free the entries.

Arguments:

    None

Return Value:

    None

--*/

{
    PSTRING_LIST_NODE n,
                      p = FoundDirectoryList;

    while (p) {
        n = p->Next;
        if (p->String) {
            LocalFree(p->String);
        }
        LocalFree(p);
        p = n;
    }

    FoundDirectoryCount = 0;
    FoundDirectoryList = NULL;
}


BOOL
FdpScanningDirsDlgProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    Display the "scanning" dialog, then when the IDLE message arrives
    process all drive letters and search for system hives.

Arguments:

    Windows dialog proc

Return Value:

    Windows dialog proc

--*/

{
    TCHAR LetterColon[3];
    TCHAR Letter;

    switch (msg) {

    case WM_INITDIALOG:

        CenterDialog(hwnd);
        break;

    case WM_ENTERIDLE:

        // Sent to us by the main window after the dialog is displayed.
        // Perform the search here.

        ConfigurationSearchIdleTrigger = FALSE;

        UserCancelled = FALSE;

        lstrcpy(LetterColon,TEXT("?:"));
        for (Letter = TEXT('A'); Letter <= TEXT('Z'); Letter++) {

            if (!ScanDrive[Letter-TEXT('A')]) {
                continue;
            }

            LetterColon[0] = Letter;

            if (!FdpSearchTreeForSystemHives(LetterColon, FdpFoundHiveCallback, hwnd)) {
                EndDialog(hwnd,IDCANCEL);
                return TRUE;
            }

        }

        EndDialog(hwnd,IDOK);
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDCANCEL:

            UserCancelled = TRUE;
            break;

        default:

            return FALSE;
        }
        break;

    default:

        return FALSE;
    }
    return TRUE;
}


BOOL
FdpSelectDirDlgProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    Using the list of directories containing system hives, display the
    selections to the user and save the selected item if the user so
    chooses.

Arguments:

    Windows dialog proc.

Return Value:

    Windows dialog proc.

--*/

{
    PSTRING_LIST_NODE Str;
    LONG i;
    static HANDLE ListBoxHandle;

    switch (msg) {

    case WM_INITDIALOG:

        CenterDialog(hwnd);

        // Add each item in the directory list to the listbox

        ListBoxHandle = GetDlgItem(hwnd,IDC_LISTBOX);

        for (Str = FoundDirectoryList; Str; Str = Str->Next) {

            i = SendMessage(ListBoxHandle,LB_ADDSTRING  ,0,(LONG)Str->String);
                SendMessage(ListBoxHandle,LB_SETITEMDATA,i,(LONG)Str        );
        }

        // select the zeroth item

        SendMessage(ListBoxHandle,LB_SETCURSEL,0,0);

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:

            // Get the index of the current list box selection and the
            // pointer to the string node associated with it.

            i = SendMessage(ListBoxHandle,LB_GETCURSEL,0,0);
            EndDialog(hwnd,SendMessage(ListBoxHandle,LB_GETITEMDATA,i,0));
            break;

        case IDCANCEL:

            EndDialog(hwnd,(int)NULL);
            break;

        default:

            return FALSE;
        }
        break;

    default:

        return FALSE;
    }

    return TRUE;
}


BOOL
DoMigratePreviousFtConfig(
    VOID
    )

/*++

Routine Description:

    Allow the user to move the disk config info from a different Windows NT
    installation into the current registry.

    For each fixed disk volume, scan it for system hives and present the
    results to the user so he can select the installation to migrate.

    Then load the system hive from that instllation (system.alt if the system
    hive is corrupt, etc) and transfer the DISK:Information binary blob.

Arguments:

    None.

Return Value:

    FALSE if error or user cancelled, TRUE if info was migrated and reboot
    is required.

--*/

{
    LONG              windowsError;
    TCHAR             letter;
    TCHAR             letterColon[4];
    PSTRING_LIST_NODE stringNode;

    // Tell the user what this will do and prompt for confirmation

    if (ConfirmationDialog(MSG_CONFIRM_MIGRATE_CONFIG, MB_ICONEXCLAMATION | MB_YESNO) != IDYES) {
        return FALSE;
    }

    ProcessPendingMessages();

    // Figure out which drives are relevent

    SetCursor(hcurWait);

    RtlZeroMemory(ScanDrive,sizeof(ScanDrive));
    lstrcpy(letterColon,TEXT("?:\\"));
    for (letter=TEXT('A'); letter<=TEXT('Z'); letter++) {

        letterColon[0] = letter;

        if (GetDriveType(letterColon) == DRIVE_FIXED) {

            ScanDrive[letter-TEXT('A')] = TRUE;
        }
    }

    SetCursor(hcurNormal);

    // Create a window that will list the directories being scanned, to
    // keep the user entertained.

    ConfigurationSearchIdleTrigger = TRUE;

    windowsError = DialogBox(hModule,
                             MAKEINTRESOURCE(IDD_SIMPLETEXT),
                             hwndFrame,
                             (DLGPROC)FdpScanningDirsDlgProc);

    if (windowsError == IDCANCEL) {
        FdpFreeDirectoryList();
        return FALSE;
    }

    ProcessPendingMessages();

    if (!FoundDirectoryCount) {

        InfoDialog(MSG_NO_OTHER_NTS);
        return FALSE;
    }

    // Display a dialog box that allows the user to select one of the
    // directories we found.

    stringNode = (PSTRING_LIST_NODE)DialogBox(hModule,
                                              MAKEINTRESOURCE(IDD_SELDIR),
                                              hwndFrame,
                                              (DLGPROC)FdpSelectDirDlgProc);

    if (stringNode == NULL) {
        FdpFreeDirectoryList();
        return FALSE;
    }

    // User made a selection.  One last confirmation.

    if (ConfirmationDialog(MSG_ABSOLUTELY_SURE,MB_ICONEXCLAMATION | MB_YESNO) != IDYES) {
        FdpFreeDirectoryList();
        return FALSE;
    }

    ProcessPendingMessages();

    SetCursor(hcurWait);

    lstrcpy(Pattern,stringNode->String);
    lstrcat(Pattern,TEXT(ConfigRegistryPath));

    windowsError = FdTransferOldDiskInfoToRegistry(Pattern);
    if (windowsError != NO_ERROR) {
        lstrcat(Pattern,TEXT(".alt"));
        windowsError = FdTransferOldDiskInfoToRegistry(Pattern);
    }
    FdpFreeDirectoryList();
    SetCursor(hcurNormal);

    if (windowsError != NO_ERROR) {

        if (windowsError == ERROR_FILE_NOT_FOUND) {
            ErrorDialog(MSG_NO_DISK_INFO);
        } else if (windowsError == ERROR_SHARING_VIOLATION) {
            ErrorDialog(MSG_DISK_INFO_BUSY);
        } else {
            ErrorDialog(windowsError);
        }
        return FALSE;
    }
    return TRUE;
}



BOOL
DoRestoreFtConfig(
    VOID
    )

/*++

Routine Description:

    Restore previously saved disk configuration information into the
    active registry.

    The saved config info will come from a floppy that the user is
    prompted to insert.

Arguments:

    None.

Return Value:

    FALSE if error or user cancelled, TRUE if info was restored and reboot
    is required.

--*/

{
    LONG    Err;
    TCHAR   caption[256];
    UINT    errorMode;
    va_list arglist =
#ifdef _ALPHA_    // Alpha defines va_list as a struct.  Init as such
    {0};
#else
    NULL;
#endif


    // Get confirmation

    if (ConfirmationDialog(MSG_CONFIRM_RESTORE_CONFIG, MB_ICONEXCLAMATION | MB_YESNO) != IDYES) {
        return FALSE;
    }

    // Get the diskette into A:.

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    LoadString(hModule,IDS_INSERT_DISK,caption,sizeof(caption)/sizeof(TCHAR));
    if (CommonDialog(MSG_INSERT_REGSAVEDISK,caption,MB_OKCANCEL | MB_TASKMODAL, arglist) != IDOK) {
        return FALSE;
    }

    ProcessPendingMessages();
    SetCursor(hcurWait);

    // If there is no file called SYSTEM on a:\, it appears that the registry
    // creates one and then keeps it open.  To avoid this, check to see
    // whether there is one first.

    if (OpenFile(TEXT("A:\\SYSTEM"),&OfStruct,OF_EXIST) == (HFILE)(-1)) {
        Err = ERROR_FILE_NOT_FOUND;
    } else {
        Err = FdTransferOldDiskInfoToRegistry(TEXT("A:\\SYSTEM"));
    }

    SetErrorMode(errorMode);
    SetCursor(hcurNormal);

    if (Err != NO_ERROR) {
        ErrorDialog(Err);
        return FALSE;
    }

    return TRUE;
}



VOID
DoSaveFtConfig(
    VOID
    )

/*++

Routine Description:

    Allow the user to update the registry save diskette with the currently
    defined disk configuration.  The saved info excludes any changes made
    during this session of disk manager.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LONG    Err,
            ErrAlt;
    LPTSTR  SystemHiveName = TEXT("a:\\system");
    HKEY    hkey;
    TCHAR   caption[256];
    DWORD   disposition;
    UINT    errorMode;
    va_list arglist =
#ifdef _ALPHA_
    {0};        // Alpha defines va_list as a struct.  Init as such.
#else
    NULL;
#endif

    // Get a diskette into A:.

    LoadString(hModule,
               IDS_INSERT_DISK,
               caption,
               sizeof(caption)/sizeof(TCHAR));
    if (CommonDialog(MSG_INSERT_REGSAVEDISK2,caption,MB_OKCANCEL | MB_TASKMODAL, arglist) != IDOK) {
        return;
    }

    // Decide what to do based on the presence of a a:\system.  If that file
    // is present, just update the DISK entry in it.  If it is not present,
    // then blast out the entire system hive.

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    ProcessPendingMessages();
    SetCursor(hcurWait);

    if (OpenFile(SystemHiveName,&OfStruct,OF_EXIST) == (HFILE)(-1)) {

        BOOLEAN OldPrivState;
        NTSTATUS Status;

        // Blast the entire system hive out to the floppy.
        // Start by attempting to get backup privilege.

        Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &OldPrivState);

        Err = RtlNtStatusToDosError(Status);
        if (Err == NO_ERROR) {

            Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               TEXT("system"),
                               REG_OPTION_RESERVED,
                               KEY_READ,
                               &hkey);

            if (Err == NO_ERROR) {

                Err = RegSaveKey(hkey,SystemHiveName,NULL);
                RegCloseKey(hkey);
            }

            if (!OldPrivState) {
                RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,FALSE,FALSE,&OldPrivState);
            }
        }
    } else {

        PVOID DiskInfo;
        ULONG DiskInfoSize;

        // Load up the saved system hive

        Err = FdpLoadHiveIntoRegistry(SystemHiveName);
        if (Err == NO_ERROR) {

            // Get the current DISK information

            Err = FdpGetDiskInfoFromKey(TEXT("system"),&DiskInfo,&DiskInfoSize);
            if (Err == NO_ERROR) {

                // Place the current disk information into the saved hive

                Err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                     TEMP_KEY_NAME TEXT("\\") DISK_KEY_NAME,
                                     0,
                                     "Disk and fault tolerance information.",
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &disposition );

                if (Err == NO_ERROR) {

                    Err = RegSetValueEx(hkey,
                                        DISK_VALUE_NAME,
                                        REG_OPTION_RESERVED,
                                        REG_BINARY,
                                        DiskInfo,
                                        DiskInfoSize);

                    RegFlushKey(hkey);
                    RegCloseKey(hkey);
                }

                LocalFree(DiskInfo);
            }

            ErrAlt = FdpUnloadHiveFromRegistry();

            if (Err == NO_ERROR && ErrAlt != NO_ERROR) {

                Err = ErrAlt;
            }
        }
    }

    SetCursor(hcurNormal);
    SetErrorMode(errorMode);

    if (Err == NO_ERROR) {
        InfoDialog(MSG_CONFIG_SAVED_OK);
    } else {
        ErrorDialog(Err);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\fd_nt.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    fd_nt.c

Abstract:

    This module wraps fdisk engine functions.  This is done
    to avoid having files that include both the full windows
    and the full nt include file sets.

    Functions that manipulate engine structures (REGIONs, for example)
    are also placed here.

    This file is targeted at NT, not Windows.

Author:

    Ted Miller        (tedm)    5-Dec-1991

Revision History:

    Misc cleanup      (BobRi)   22-Jan-1994

--*/

#include "fdisk.h"
#include <string.h>
#include <stdio.h>

// These partition ID's are for systems recognized by WINDISK,
// even though they don't appear in ntdddisk.h.

#define PARTITION_OS2_BOOT              0xa
#define PARTITION_EISA                  0x12


WCHAR UnicodeSysIdName[100];
BYTE StringBuffer[100];

// Pagefile support structures.

typedef struct _PAGEFILE_LOCATION {
    struct _PAGEFILE_LOCATION *Next;
    CHAR                       DriveLetter;
} PAGEFILE_LOCATION, *PPAGEFILE_LOCATION;

PPAGEFILE_LOCATION PagefileHead = NULL;

// For some reason the file systems don't like being accessed shortly after
// a format or lock event.

#define SLEEP_TIME (1000*2) // 2 seconds


PWSTR
GetWideSysIDName(
    IN UCHAR SysID
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ANSI_STRING    ansiString;
    UNICODE_STRING unicodeString;
    DWORD          stringId;

    // Get the name, which is a byte-string.

    switch (SysID) {

    case PARTITION_ENTRY_UNUSED:
        stringId = IDS_PARTITION_FREE;
        break;

    case PARTITION_XENIX_1:
        stringId = IDS_PARTITION_XENIX1;
        break;

    case PARTITION_XENIX_2:
        stringId = IDS_PARTITION_XENIX2;
        break;

    case PARTITION_OS2_BOOT:
        stringId = IDS_PARTITION_OS2_BOOT;
        break;

    case PARTITION_EISA:
        stringId = IDS_PARTITION_EISA;
        break;

    case PARTITION_UNIX:
        stringId = IDS_PARTITION_UNIX;
        break;

    case PARTITION_PREP:
#ifdef _PPC_
        stringId = IDS_PARTITION_POWERPC;
#else

        // If not on a PPC platform, assume this is Eisa related

        stringId = IDS_PARTITION_EISA;
#endif
        break;

    default:
        stringId = IDS_UNKNOWN;
        break;
    }

    LoadString(hModule, stringId, StringBuffer, sizeof(StringBuffer));
    RtlInitAnsiString(&ansiString, StringBuffer);

    //
    // Convert to Unicode
    //

    unicodeString.Buffer = UnicodeSysIdName;
    unicodeString.MaximumLength = sizeof(UnicodeSysIdName);
    RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
    return UnicodeSysIdName;
}


ULONG
MyDiskRegistryGet(
    OUT PDISK_REGISTRY *DiskRegistry
    )

/*++

Routine Description:

    Allocate memory for the size of the disk registry, obtain
    the registry contents (if any) and return the pointer to the
    allocated memory.

Arguments:

    A pointer to a disk registry pointer.

Return Value:

    status indicating success or failure.

--*/

{
    ULONG          length;
    PDISK_REGISTRY diskRegistry;
    NTSTATUS       status;


    while (((status = DiskRegistryGet(NULL, &length)) == STATUS_NO_MEMORY)
      ||    (status == STATUS_INSUFFICIENT_RESOURCES))
    {
        ConfirmOutOfMemory();
    }

    if (!NT_SUCCESS(status)) {
        return EC(status);
    }

    diskRegistry = Malloc(length);

    while (((status = DiskRegistryGet(diskRegistry, &length)) == STATUS_NO_MEMORY)
      ||    (status == STATUS_INSUFFICIENT_RESOURCES))
    {
        ConfirmOutOfMemory();
    }

    if (NT_SUCCESS(status)) {

        LOG_DISK_REGISTRY("MyDiskRegistryGet", diskRegistry);
        *DiskRegistry = diskRegistry;
    }
    return EC(status);
}


ULONG
FormDiskSignature(
    VOID
    )

/*++

Routine Description:

    Return a ULONG disk signature.  This is derived from the current
    system time.

Arguments:

    None

Return Value:

    A 32-bit signature

--*/

{
    LARGE_INTEGER time;
    static ULONG  baseSignature = 0;

    if (!baseSignature) {

        NtQuerySystemTime(&time);
        time.QuadPart = time.QuadPart >> 16;
        baseSignature = time.LowPart;
    }
    return baseSignature++;
}


BOOLEAN
GetVolumeSizeMB(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PULONG Size
    )

/*++

Routine Description:

    Given a disk and a partition, query the "volume" to get its size.
    By performing the query on the 1st partition of a potential FT set,
    the total size of the set will be returned.  If the partition isn't
    an FT set, it will work too.

Arguments:

    Disk - the disk number
    Partition - the partition number
    Size - the size of the "volume"

Return Value:

    TRUE - a size was returned.
    FALSE - something failed in getting the size.

--*/

{
    BOOLEAN                     retValue = FALSE;
    IO_STATUS_BLOCK             statusBlock;
    HANDLE                      handle;
    STATUS_CODE                 sc;
    PARTITION_INFORMATION       partitionInfo;
    LARGE_INTEGER               partitionLength;

    *Size = 0;
    sc = LowOpenPartition(GetDiskName(Disk), Partition, &handle);
    if (sc == OK_STATUS) {

        sc = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_PARTITION_INFO,
                                   NULL,
                                   0,
                                   &partitionInfo,
                                   sizeof(PARTITION_INFORMATION));

        if (sc == OK_STATUS) {

            // Convert to MB

            partitionLength.QuadPart = partitionInfo.PartitionLength.QuadPart >> 20;
            *Size = partitionLength.LowPart;
            retValue = TRUE;
        }
        LowCloseDisk(handle);
    }
    return retValue;
}


ULONG
GetVolumeTypeAndSize(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Label,
    OUT PWSTR *Type,
    OUT PULONG Size
    )

/*++

Routine Description:

    Given a disk and partition number, determine its size, label and file
    system type.  This routine will allocate the space for label and file
    system type.  It is the responsibility of the caller to free this memory.

Arguments:

    Disk - the disk number
    Partition - the partition number
    Label - a pointer to a pointer for a WCHAR string to contain the label
    Type - a pointer to a pointer for a WCHAR string to contain the file system
           type.
    Size - a pointer to a ULONG for the size of the disk in KB.

Return Value:

    OK_STATUS - everything was performed.
    !OK_STATUS - the error code that was returned in the process of performing
                 this work.

--*/

{
    IO_STATUS_BLOCK             statusBlock;
    HANDLE                      handle;
    unsigned char               buffer[256];
    PWSTR                       label,
                                name;
    ULONG                       length;
    DISK_GEOMETRY               diskGeometry;
    STATUS_CODE                 sc;
    BOOLEAN                     firstTime = TRUE;
    PFILE_FS_VOLUME_INFORMATION labelInfo = (PFILE_FS_VOLUME_INFORMATION)buffer;
    PFILE_FS_ATTRIBUTE_INFORMATION info = (PFILE_FS_ATTRIBUTE_INFORMATION)buffer;

    while (1) {
        sc = LowOpenPartition(GetDiskName(Disk), Partition, &handle);
        if (sc == OK_STATUS) {

            sc = NtQueryVolumeInformationFile(handle,
                                              &statusBlock,
                                              buffer,
                                              sizeof(buffer),
                                              FileFsVolumeInformation);
            if (sc == OK_STATUS) {

                length = labelInfo->VolumeLabelLength;
                labelInfo->VolumeLabel[length/sizeof(WCHAR)] = 0;
                length = (length+1) * sizeof(WCHAR);

                label = Malloc(length);
                RtlMoveMemory(label, labelInfo->VolumeLabel, length);
            } else {

                label = Malloc(sizeof(WCHAR));
                *label = 0;
            }
            *Label = label;

            if (sc == OK_STATUS) {
                sc = NtQueryVolumeInformationFile(handle,
                                                  &statusBlock,
                                                  buffer,
                                                  sizeof(buffer),
                                                  FileFsAttributeInformation);
                if (sc == OK_STATUS) {

                    length = info->FileSystemNameLength;
                    info->FileSystemName[length/sizeof(WCHAR)] = 0;
                    length = (length+1)*sizeof(WCHAR);
                    name = Malloc(length);
                    RtlMoveMemory(name, info->FileSystemName, length);
                } else {

                    name = Malloc(sizeof(WCHAR));
                    *name = 0;
                }
                *Type = name;
            }

            if (sc == OK_STATUS) {
                sc = NtDeviceIoControlFile(handle,
                                           0,
                                           NULL,
                                           NULL,
                                           &statusBlock,
                                           IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                           NULL,
                                           0,
                                           (PVOID)&diskGeometry,
                                           sizeof(diskGeometry));
                if (NT_SUCCESS(sc)) {
                    LARGE_INTEGER sizeInBytes;
                    ULONG         cylinderBytes;

                    cylinderBytes = diskGeometry.TracksPerCylinder *
                                    diskGeometry.SectorsPerTrack *
                                    diskGeometry.BytesPerSector;

                    sizeInBytes.QuadPart = diskGeometry.Cylinders.QuadPart * cylinderBytes;

                    // Now convert everything to KB

                    sizeInBytes.QuadPart = sizeInBytes.QuadPart >> 10;
                    *Size = (ULONG) sizeInBytes.LowPart;
                }
            }
            DmClose(handle);
            sc = OK_STATUS;
            break;
        } else {
            if (firstTime) {
                firstTime = FALSE;
            } else {
                break;
            }
            Sleep(SLEEP_TIME);
        }
    }

    return EC(sc);
}

ULONG
GetVolumeLabel(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Label
    )

/*++

Routine Description:

    Given a disk number and a partition number return the volume label (if
    any).

Arguments:

    Disk - the disk number
    Partition - the partition number
    Label - a pointer to a pointer for a WCHAR string to contain the label

Return Value:

    OK_STATUS - everything was performed.
    !OK_STATUS - the error code that was returned in the process of performing
                 this work.
--*/

{
    IO_STATUS_BLOCK             statusBlock;
    HANDLE                      handle;
    unsigned char               buffer[256];
    PWSTR                       label;
    ULONG                       length;
    STATUS_CODE                 sc;
    BOOLEAN                     firstTime = TRUE;
    PFILE_FS_VOLUME_INFORMATION labelInfo = (PFILE_FS_VOLUME_INFORMATION)buffer;

    while (1) {
        sc = LowOpenPartition(GetDiskName(Disk), Partition, &handle);
        if (sc == OK_STATUS) {

            sc = NtQueryVolumeInformationFile(handle,
                                              &statusBlock,
                                              buffer,
                                              sizeof(buffer),
                                              FileFsVolumeInformation);
            DmClose(handle);
            if (sc == OK_STATUS) {

                length = labelInfo->VolumeLabelLength;
                labelInfo->VolumeLabel[length/sizeof(WCHAR)] = 0;
                length = (length+1) * sizeof(WCHAR);

                label = Malloc(length);
                RtlMoveMemory(label, labelInfo->VolumeLabel, length);
            } else {

                label = Malloc(sizeof(WCHAR));
                sc = OK_STATUS;
                *label = 0;
            }
            *Label = label;
            break;
        } else {
            if (firstTime) {
                firstTime = FALSE;
            } else {
                *Label = NULL;
                break;
            }
            Sleep(SLEEP_TIME);
        }
    }
    return EC(sc);
}


ULONG
GetTypeName(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Name
    )

/*++

Routine Description:

    Given a disk number and partition number return the file system type
    string.

Arguments:

    Disk - the disk number
    Partition - the partition number
    Name - a pointer to a pointer for a WCHAR string to contain the file system
           type.

Return Value:

    OK_STATUS - everything was performed.
    !OK_STATUS - the error code that was returned in the process of performing
                 this work.
--*/

{
    PWSTR                          name;
    STATUS_CODE                    sc;
    HANDLE                         handle;
    unsigned char                  buffer[256];
    IO_STATUS_BLOCK                statusBlock;
    ULONG                          length;
    BOOLEAN                        firstTime = TRUE;
    PFILE_FS_ATTRIBUTE_INFORMATION info = (PFILE_FS_ATTRIBUTE_INFORMATION)buffer;

    // For some reason, the file systems believe they are locked or need
    // to be verified after formats and the like.  Therefore this is attempted
    // twice before it actually gives up.

    while (1) {
        sc = LowOpenPartition(GetDiskName(Disk), Partition, &handle);

        if (sc == OK_STATUS) {
            sc = NtQueryVolumeInformationFile(handle,
                                              &statusBlock,
                                              buffer,
                                              sizeof(buffer),
                                              FileFsAttributeInformation);
            DmClose(handle);
            if (sc == OK_STATUS) {

                length = info->FileSystemNameLength;
                info->FileSystemName[length/sizeof(WCHAR)] = 0;
                length = (length+1)*sizeof(WCHAR);
                name = Malloc(length);
                RtlMoveMemory(name, info->FileSystemName, length);
            } else {

                name = Malloc(sizeof(WCHAR));
                *name = 0;
                sc = OK_STATUS;
            }
            *Name = name;
            break;
        } else {
            if (firstTime) {
                firstTime = FALSE;
            } else {
                break;
            }
            Sleep(SLEEP_TIME);
        }
    }

    return EC(sc);
}


BOOLEAN
IsRemovable(
    IN ULONG DiskNumber
    )

/*++

Routine Description:

    This function determines whether the specified physical
    disk is removable.

Arguments:

    DiskNumber  --  The Physical Disk Number of the disk in question.

Return Value:

    TRUE if the disk is removable.

--*/

{
    STATUS_CODE     sc;
    NTSTATUS        status;
    HANDLE          handle;
    DISK_GEOMETRY   diskGeometry;
    IO_STATUS_BLOCK statusBlock;
    PCHAR           name;

    name = GetDiskName(DiskNumber);
    sc = LowOpenDisk(name, &handle);

    if (sc == OK_STATUS) {
        status = NtDeviceIoControlFile(handle,
                                       0,
                                       NULL,
                                       NULL,
                                       &statusBlock,
                                       IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                       NULL,
                                       0,
                                       (PVOID)&diskGeometry,
                                       sizeof(diskGeometry));
        LowCloseDisk(handle);
        if (NT_SUCCESS(status)) {
            if (diskGeometry.MediaType == RemovableMedia) {
                char  ntDeviceName[100];

                // Do a dismount/force mount sequence to make sure
                // the media hasn't changed since last mount.
                // Dismount partition 1 by lock/unlock/close.

                sprintf(ntDeviceName, "%s\\Partition1", name);
                status= LowOpenNtName(ntDeviceName, &handle);
                if (NT_SUCCESS(status)) {

                    LowLockDrive(handle);
                    LowUnlockDrive(handle);
                    LowCloseDisk(handle);

                    // Now force the mount by opening the device with a '\'
                    // This is done on partition 1 of the device.

                    sprintf(ntDeviceName, "%s\\Partition1\\", name);
                    status= LowOpenNtName(ntDeviceName, &handle);
                    if (NT_SUCCESS(status)) {
                        LowCloseDisk(handle);
                    }
                }
                return TRUE;
            }
        }
    }
    return FALSE;
}


ULONG
GetDriveLetterLinkTarget(
    IN PWSTR SourceNameStr,
    OUT PWSTR *LinkTarget
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    static WCHAR      targetNameBuffer[50];
    UNICODE_STRING    sourceName,
                      targetName;
    NTSTATUS          status;
    OBJECT_ATTRIBUTES attributes;
    HANDLE            handle;


    RtlInitUnicodeString(&sourceName, SourceNameStr);
    InitializeObjectAttributes(&attributes, &sourceName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenSymbolicLinkObject(&handle, READ_CONTROL | SYMBOLIC_LINK_QUERY, &attributes);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(targetNameBuffer, 50 * sizeof(WCHAR));
        targetName.Buffer = targetNameBuffer;
        targetName.MaximumLength = sizeof(targetNameBuffer);
        status = NtQuerySymbolicLinkObject(handle, &targetName, NULL);
        NtClose(handle);
    }

    if (NT_SUCCESS(status)) {
        *LinkTarget = targetName.Buffer;
    } else {
        *LinkTarget = NULL;
    }

    return EC(status);
}


#include "bootmbr.h"

#if X86BOOTCODE_SIZE < MBOOT_CODE_SIZE
#error Something is wrong with the boot code (it's too small)!
#endif


ULONG
MasterBootCode(
    IN ULONG   Disk,
    IN ULONG   Signature,
    IN BOOLEAN SetBootCode,
    IN BOOLEAN SetSignature
    )

/*++

Routine Description:

    If the zero sector of the disk does not have a valid MBR
    signature (i.e. AA55), update it such that it has a valid
    MBR and fill in the disk signature and bootcode in the
    process.

Arguments:

    Disk - the disk ordinal to be affected
    SetSignature - if TRUE update the disk signature
    Signature    - the disk signature for the update

Return Value:

    status

--*/

{
    HANDLE      handle;
    STATUS_CODE status;
    PUCHAR      unalignedSectorBuffer,
                sectorBuffer;
    ULONG       bps,
                dummy,
                i;
    BOOLEAN     writeIt;
    PCHAR       diskName = GetDiskName(Disk);

#ifndef     max
#define     max(a,b) ((a > b) ? a : b)
#endif

    if (SetBootCode) {
        writeIt = FALSE;

        // allocate sector buffer

        status = LowGetDriveGeometry(diskName, &dummy, &bps, &dummy, &dummy);
        if (status != OK_STATUS) {
            return EC(status);
        }
        if (bps < 512) {
            bps = 512;
        }
        unalignedSectorBuffer = Malloc(2*bps);
        sectorBuffer = (PUCHAR)(((ULONG)unalignedSectorBuffer+bps) & ~(bps-1));

        // open entire disk (partition 0)

        if ((status = LowOpenDisk(diskName, &handle)) != OK_STATUS) {
            return EC(status);
        }

        // read (at least) first 512 bytes

        status = LowReadSectors(handle, bps, 0, 1, sectorBuffer);
        if (status == OK_STATUS) {

            if ((sectorBuffer[MBOOT_SIG_OFFSET+0] != MBOOT_SIG1)
            ||  (sectorBuffer[MBOOT_SIG_OFFSET+1] != MBOOT_SIG2)) {

                // xfer boot code into sectorBuffer

                for (i=0; i<MBOOT_CODE_SIZE; i++) {
                    sectorBuffer[i] = x86BootCode[i];
                }

                // wipe partition table

                for (i=MBOOT_CODE_SIZE; i<MBOOT_SIG_OFFSET; i++) {
                    sectorBuffer[i] = 0;
                }

                // set the signature

                sectorBuffer[MBOOT_SIG_OFFSET+0] = MBOOT_SIG1;
                sectorBuffer[MBOOT_SIG_OFFSET+1] = MBOOT_SIG2;

                writeIt = TRUE;
            }

            if (writeIt) {
                status = LowWriteSectors(handle, bps, 0, 1, sectorBuffer);
            }
        }

        LowCloseDisk(handle);
        Free(unalignedSectorBuffer);
    }

    if (SetSignature) {
        PDRIVE_LAYOUT_INFORMATION layout;

        // Use the IOCTL to set the signature.  This code really does
        // not know where the MBR exists.  (ezDrive extensions).

        status = LowGetDiskLayout(diskName, &layout);

        if (status == OK_STATUS) {
            layout->Signature = Signature;
            LowSetDiskLayout(diskName, layout);
        }
    }

    return EC(status);
}


ULONG
UpdateMasterBootCode(
    IN ULONG   Disk
    )

/*++

Routine Description:

    This routine updates the zero sector of the disk to insure that boot
    code is present.

Arguments:

    Disk - the disk number onto which to put the boot code.

Return Value:

    status

--*/

{
    HANDLE      handle;
    STATUS_CODE status;
    PUCHAR      unalignedSectorBuffer,
                sectorBuffer;
    ULONG       bps,
                dummy,
                i;
    PCHAR       diskName = GetDiskName(Disk);

#ifndef     max
#define     max(a,b) ((a > b) ? a : b)
#endif

    // allocate sector buffer

    status = LowGetDriveGeometry(diskName, &dummy, &bps, &dummy, &dummy);
    if (status != OK_STATUS) {
        return EC(status);
    }
    if (bps < 512) {
        bps = 512;
    }
    unalignedSectorBuffer = Malloc(2*bps);
    sectorBuffer = (PUCHAR)(((ULONG)unalignedSectorBuffer+bps) & ~(bps-1));

    // open entire disk (partition 0)

    if ((status = LowOpenDisk(diskName, &handle)) != OK_STATUS) {
        return EC(status);
    }

    // read (at least) first 512 bytes

    status = LowReadSectors(handle, bps, 0, 1, sectorBuffer);
    if (status == OK_STATUS) {


        // xfer boot code into sectorBuffer.  This avoids changing the
        // disk signature and the partition table information.

        for (i=0; i<MBOOT_CODE_SIZE; i++) {
            sectorBuffer[i] = x86BootCode[i];
        }

        status = LowWriteSectors(handle, bps, 0, 1, sectorBuffer);
    }

    LowCloseDisk(handle);

    // free the sector buffer

    Free(unalignedSectorBuffer);
    return EC(status);
}


#if i386

VOID
MakePartitionActive(
    IN PREGION_DESCRIPTOR DiskRegionArray,
    IN ULONG              RegionCount,
    IN ULONG              RegionIndex
    )

/*++

Routine Description:

    Update the information in the internal structures to indicate
    that the specified partition is active.

Arguments:

    DiskRegionArray
    RegionCount
    RegionIndex

Return Value:

    None

--*/

{
    unsigned i;

    for (i=0; i<RegionCount; i++) {
        if (DiskRegionArray[i].RegionType == REGION_PRIMARY) {
            DiskRegionArray[i].Active = FALSE;
            SetPartitionActiveFlag(&DiskRegionArray[i], FALSE);
        }
    }
    DiskRegionArray[RegionIndex].Active = (BOOLEAN)0x80;
    SetPartitionActiveFlag(&DiskRegionArray[RegionIndex], 0x80);
}

#endif

VOID
LoadExistingPageFileInfo(
    IN VOID
    )

/*++

Routine Description:

    This routine finds all pagefiles in the system and updates the internal
    structures.

Arguments:

    None

Return Values:

    None

--*/

{
    NTSTATUS                     status;
    SYSTEM_INFO                  sysInfo;
    UCHAR                        genericBuffer[0x10000];
    PSYSTEM_PAGEFILE_INFORMATION pageFileInfo;
    ANSI_STRING                  ansiPageFileName;
    PPAGEFILE_LOCATION           pageFileListEntry;
    PCHAR                        p;

    GetSystemInfo(&sysInfo);

    status = NtQuerySystemInformation(SystemPageFileInformation,
                                      genericBuffer,
                                      sizeof(genericBuffer),
                                      NULL);
    if (!NT_SUCCESS(status)) {

        // It's possible that this call will fail if the
        // the system is running without ANY paging files.

        return;
    }

    pageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION) genericBuffer;

    for (;;) {

        RtlUnicodeStringToAnsiString(&ansiPageFileName,
                                     &pageFileInfo->PageFileName,
                                     TRUE);

        // Since the format of the pagefile name generally
        // looks something like "\DosDevices\h:\pagefile.sys",
        // just use the first character before the colon
        // and assume that's the drive letter.

        p = strchr(_strlwr(ansiPageFileName.Buffer), ':');

        if ((p-- != NULL) && (*p >= 'a') && (*p <= 'z')) {

            pageFileListEntry = Malloc(sizeof(PAGEFILE_LOCATION));
            if (pageFileListEntry) {
                if (PagefileHead) {
                    pageFileListEntry->Next = PagefileHead;
                } else {
                    PagefileHead = pageFileListEntry;
                    pageFileListEntry->Next = NULL;
                }
                pageFileListEntry->DriveLetter = *p;
            }

        }

        RtlFreeAnsiString(&ansiPageFileName);

        if (pageFileInfo->NextEntryOffset == 0) {
            break;
        }

        pageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR) pageFileInfo
                      + pageFileInfo->NextEntryOffset);
    }
}

BOOLEAN
IsPagefileOnDrive(
    CHAR DriveLetter
    )

/*++

Routine Description:

    Walk the page file list and determine if the drive letter given has
    a paging file.  NOTE:  The assumption is that drive letters that
    contain paging files can never get changed during the execution of
    Disk Administrator.  Therefore this list is never updated, but
    can be used during the execution of Disk Administrator.

Arguments:

    DriveLetter - the drive in question.

Return Value:

    TRUE if this drive contains a page file.

--*/

{
    PPAGEFILE_LOCATION pageFileListEntry = PagefileHead;

    while (pageFileListEntry) {
        if (pageFileListEntry->DriveLetter == DriveLetter) {
            return TRUE;
        }
        pageFileListEntry = pageFileListEntry->Next;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\find\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=find
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES=..\find.cxx ..\find.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\findstr\makefile.inc ===
fsmsg.rc: msg00001.bin

fsmsg.h msg00001.bin: fsmsg.mc
    mc -v -h .\ fsmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\scsi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    scsi.h

Abstract:

    This is a subset of the header file for SCSI definitions that is
    located in the kernel tree.

Authors:

    Mike Glass (mglass)

Revision History:

--*/

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\find\find.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    find.cxx

Abstract:

    This utility allows the user to search for strings in a file
    It is functionaly compatible with DOS 5 find utility.

    SYNTAX (Command line)

      FIND [/?][/V][/C][/N][/I] "string" [[d:][path]filename[.ext]...]

      where:

        /? - Display this help
        /V - Display all lines NOT containing the string
        /C - Display only a count of lines containing string
        /N - Display number of line containing string
        /I - Ignore case

    UTILITY FUNCTION:

      Searches the specified file(s) looking for the string the user
      entered from the command line.  If file name(s) are specifeied,
      those names are displayed, and if the string is found, then the
      entire line containing that string will be displayed.  Optional
      parameters modify that behavior and are described above.  String
      arguments have to be enclosed in double quotes.  (Two double quotes
      if a double quote is to be included).  Only one string argument is
      presently allowed.  The maximum line size is determined by buffer
      size.  Bigger lines will bomb the program.  If no file name is given
      then it will asssume the input is coming from the standard Input.
      No errors are reported when reading from standard Input.


    EXIT:
     The program returns errorlevel:
       0 - OK, and some matches
       1 -
       2 - Some Error


Author:

    Bruce Wilson (w-wilson) 08-May-1991

Environment:

    ULIB, User Mode

Revision History:

    08-May-1991             w-wilson

        created
-----------------------------------------------------------
    8/5/96                  t-reagjo

        Unicode re-enabled. This was broken, presumably by some changes to ulib.

        Non-Unicode files searched will now be converted to Unicode using the CP of the
        console.

        Changed the string comparison to use the NLSAPI call CompareString.
-----------------------------------------------------------
--*/

#include "ulib.hxx"
#include "ulibcl.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "mbstr.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "substrng.hxx"
#include "filestrm.hxx"
#include "file.hxx"
#include "system.hxx"
#include "arrayit.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "find.hxx"
#include "dir.hxx"
#include <winnls.h>

extern "C" {
    #include <stdio.h>
    #include <string.h>
}

#define MAX_LINE_LEN            1024

static STR              TmpBuf[MAX_LINE_LEN];

DEFINE_CONSTRUCTOR( FIND, PROGRAM );

VOID
FIND::DisplayMessageAndExit(
    IN MSGID        MsgId,
    IN ULONG        ExitCode,
    IN MESSAGE_TYPE Type,
    IN PWSTRING     String
    )
/*++

Routine Description:

    Display an error message and exit.

Arguments:

    MsgId       - Supplies the Id of the message to display.
    String      - Supplies a string parameter for the message.
    ExitCode    - Supplies the exit code to use for exit.

Return Value:

    N/A


--*/
{
    if (MsgId != 0) {
        if (String)
            DisplayMessage(MsgId, Type, "%W", String);
        else
            DisplayMessage(MsgId, Type);
    }

    exit( ExitCode );
}


BOOLEAN
FIND::Initialize(
    )

/*++

Routine Description:

    Initializes an FIND class.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/

{
    ARGUMENT_LEXEMIZER      ArgLex;
    ARRAY                   LexArray;

    ARRAY                   ArgumentArray;

    STRING_ARGUMENT         ProgramNameArgument;
    FLAG_ARGUMENT           FlagCaseInsensitive;
    FLAG_ARGUMENT           FlagNegativeSearch;
    FLAG_ARGUMENT           FlagCountLines;
    FLAG_ARGUMENT           FlagDisplayNumbers;
    FLAG_ARGUMENT           FlagIncludeOfflineFiles;
    FLAG_ARGUMENT           FlagIncludeOfflineFiles2;
    FLAG_ARGUMENT           FlagDisplayHelp;
    FLAG_ARGUMENT           FlagInvalid;
    STRING_ARGUMENT         StringPattern;

    PROGRAM::Initialize();

    // An Error Level return of 1 indicates that no match was
    // found; a return of 0 indicates that a match was found.
    // Set it at 1 until a match is found.
    //
    _ErrorLevel = 1;

    if( !SYSTEM::IsCorrectVersion() ) {
        DisplayMessageAndExit(MSG_FIND_INCORRECT_VERSION, 2);
    }

    //
    // - init the array that will contain the command-line args
    //
    if ( !ArgumentArray.Initialize() ) {
        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }

    //
    // - init the individual arguments
    //
    if( !ProgramNameArgument.Initialize("*")
        || !FlagCaseInsensitive.Initialize( "/I" )
        || !FlagNegativeSearch.Initialize( "/V" )
        || !FlagCountLines.Initialize( "/C" )
        || !FlagDisplayNumbers.Initialize( "/N" )
        || !FlagIncludeOfflineFiles.Initialize( "/OFFLINE" )
        || !FlagIncludeOfflineFiles2.Initialize( "/OFF" )
        || !FlagDisplayHelp.Initialize( "/?" )
        || !FlagInvalid.Initialize( "/*" )          // comment */
        || !StringPattern.Initialize( "\"*\"" )
        || !_PathArguments.Initialize( "*", FALSE, TRUE ) ) {

        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }

    //
    // - put the arguments in the array
    //
    if( !ArgumentArray.Put( &ProgramNameArgument )
        || !ArgumentArray.Put( &FlagCaseInsensitive )
        || !ArgumentArray.Put( &FlagNegativeSearch )
        || !ArgumentArray.Put( &FlagCountLines )
        || !ArgumentArray.Put( &FlagDisplayNumbers )
        || !ArgumentArray.Put( &FlagIncludeOfflineFiles )
        || !ArgumentArray.Put( &FlagIncludeOfflineFiles2 )
        || !ArgumentArray.Put( &FlagDisplayHelp )
        || !ArgumentArray.Put( &FlagInvalid )
        || !ArgumentArray.Put( &StringPattern )
        || !ArgumentArray.Put( &_PathArguments ) ) {

        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }
    //
    // - init the lexemizer
    //
    if ( !LexArray.Initialize() ) {
        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }
    if ( !ArgLex.Initialize( &LexArray ) ) {
        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }

    //
    // - set up the defaults
    //
    ArgLex.PutSwitches( "/" );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );
    ArgLex.PutSeparators( " \"\t" );
    ArgLex.SetCaseSensitive( FALSE );
    if( !ArgLex.PrepareToParse() ) {

        //
        // invalid format
        //
        DisplayMessageAndExit(MSG_FIND_INVALID_FORMAT, 2);
    }


    //
    // - now parse the command line.  The args in the array will be set
    //   if they are found on the command line.
    //
    if( !ArgLex.DoParsing( &ArgumentArray ) ) {
        if( FlagInvalid.QueryFlag() ) {
            //
            // invalid switch
            //
            DisplayMessageAndExit(MSG_FIND_INVALID_SWITCH, 2);

        } else {
            //
            // invalid format
            //
           DisplayMessageAndExit(MSG_FIND_INVALID_FORMAT, 2);
        }
    } else if ( _PathArguments.WildCardExpansionFailed() ) {

        //
        //  No files matched
        //
        DisplayMessageAndExit(MSG_FIND_FILE_NOT_FOUND,
                              2,
                              ERROR_MESSAGE,
                              (PWSTRING)_PathArguments.GetLexemeThatFailed());
    }

    if( FlagInvalid.QueryFlag() ) {
        //
        // invalid switch
        //
        DisplayMessageAndExit(MSG_FIND_INVALID_SWITCH, 2);
    }

    //
    // - now do semantic checking/processing
    //    - if they ask for help, do it right away and return
    //    - set flags
    //
    if( FlagDisplayHelp.QueryFlag() ) {
        DisplayMessageAndExit(MSG_FIND_USAGE, 0, NORMAL_MESSAGE);
    }

    if( !StringPattern.IsValueSet() ) {
        DisplayMessageAndExit(MSG_FIND_INVALID_FORMAT, 2);
    } else {
        //
        // - keep a copy of the pattern string
        //

           DebugAssert(StringPattern.GetString());
        _PatternString.Initialize(StringPattern.GetString());

    }

    _CaseSensitive = (BOOLEAN)!FlagCaseInsensitive.QueryFlag();

    _LinesContainingPattern = (BOOLEAN)!FlagNegativeSearch.QueryFlag();

    _OutputLines = (BOOLEAN)!FlagCountLines.QueryFlag();

    _OutputLineNumbers = (BOOLEAN)FlagDisplayNumbers.QueryFlag();

    _SkipOfflineFiles =  ( (BOOLEAN)!FlagIncludeOfflineFiles.QueryFlag() ) &&
                         ( (BOOLEAN)!FlagIncludeOfflineFiles2.QueryFlag() );

    return( TRUE );
}


BOOLEAN
FIND::IsDos5CompatibleFileName(
    IN PCPATH       Path
    )
/*++

Routine Description:

    Parses the path string and returns FALSE if DOS5 would reject
    the path.

Arguments:

    Path    -       Supplies the path

Return Value:

    BOOLEAN -       Returns FALSE if DOS5 would reject the path,
                    TRUE otherwise

--*/

{

    PWSTRING        String;

    DebugPtrAssert( Path );

    String = (PWSTRING)Path->GetPathString();

    DebugPtrAssert( String );

    if ( String->QueryChCount() > 0 ) {

        if ( String->QueryChAt(0) == '\"' ) {
            return FALSE;
        }
    }

    return TRUE;

}



ULONG
FIND::SearchStream(
    PSTREAM                 StreamToSearch
    )

/*++

Routine Description:

    Does the search on an open file_stream.

Arguments:

    None.

Return Value:

    Number of lines found/not found.


--*/

{

    ULONG       LineCount;
    ULONG       FoundCount;
    DWORD       PatternLen;
    DWORD       LineLen;
    DWORD       LastPosInLine;
    BOOLEAN     Found;
    WCHAR       c;
    PWSTR       pLine;
    PWSTR       p;
    WCHAR       CurrentLine[MAX_LINE_LEN];
    WCHAR       PatternString[MAX_LINE_LEN];
    DSTRING     dstring;
    DSTRING     _String;
    DWORD       CompareFlags;


    LineCount   = FoundCount = 0;
    PatternLen  = _PatternString.QueryChCount() ;
    _PatternString.QueryWSTR(0,TO_END,PatternString,MAX_LINE_LEN,TRUE);

    if ( !_String.Initialize() ) {
        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }

    //
    //  - converting to Unicode from the current console code page
    //          (say -that- ten times fast...)
    //
    _String.SetConsoleConversions();

    //
    //    - for each line from stream
    //       - do strstr to see if pattern string is in line
    //       - if -ve search and not in line || +ve search and in line
    //          - output line and number or inc counter appropriately
    //
    while( !StreamToSearch->IsAtEnd() ) {

        if ( !StreamToSearch->ReadLine( &_String)) {
            DisplayMessageAndExit(MSG_FIND_UNABLE_TO_READ_FILE, 2);
        }
        if (_String.QueryChCount() == 0 &&
            StreamToSearch->IsAtEnd()) {
            break;
        }
        _String.QueryWSTR(0,TO_END,CurrentLine,MAX_LINE_LEN,TRUE);
        LineLen = min ( MAX_LINE_LEN - 1, _String.QueryChCount());
        LineCount++;

        //
        //      - look for pattern string in the current line
        //              - note: a 0-length pattern ("") never matches a line.
        //                A 0-length pattern can produce output with the /v
        //                switch.
        //      - start at the end (saves a var)
        //

        Found = FALSE;

        if ( PatternLen && LineLen >= PatternLen ) {

            CompareFlags = 0;
            if ( !_CaseSensitive ) {
                CompareFlags |= NORM_IGNORECASE;
            }

            LastPosInLine = LineLen - PatternLen + 1;
            pLine = CurrentLine + LastPosInLine;

            while ( pLine >= CurrentLine && !Found ) {

                if ( CompareString ( LOCALE_USER_DEFAULT, CompareFlags, PatternString, PatternLen, pLine, PatternLen ) == 2 ) {

                    Found = TRUE;
                }
                pLine--;

            }
        }

        //
        // - if either (search is +ve and found a match)
        //          or (search is -ve and no match found)
        //   then print line/line number based on options
        //
        if( (_LinesContainingPattern && Found)
            || (!_LinesContainingPattern && !Found) ) {

            FoundCount++;
            if( _OutputLines ) {
                dstring.Initialize(CurrentLine);
                if( _OutputLineNumbers ) {
                    DisplayMessage( MSG_FIND_LINE_AND_NUMBER, NORMAL_MESSAGE, "%d%W", LineCount, &dstring);
                } else {
                    DisplayMessage( MSG_FIND_LINEONLY, NORMAL_MESSAGE, "%W", &dstring);
                }
            }
        }
    }

    if (FoundCount) {

        // Set _ErrorLevel to zero to indicate that at least
        // one match has been found.
        //
        _ErrorLevel = 0;
    }
    return(FoundCount);
}



VOID
FIND::SearchFiles(
    )

/*++

Routine Description:

    Does the search on the files specified on the command line.

Arguments:

    None.

Return Value:

    None.


--*/

{
    PARRAY                  PathArray;
    PARRAY_ITERATOR         PIterator;
    PPATH                   CurrentPath;
    PFSN_FILE               CurrentFSNode   = NULL;
    PFSN_DIRECTORY          CurrentFSDir;
    PFILE_STREAM            CurrentFile     = NULL;
    DSTRING                 CurrentPathString;
    ULONG                   LinesFound;
    BOOLEAN                 PrintSkipWarning = FALSE;
    BOOLEAN                 OfflineSkipped;

    //
    // - if 0 paths on cmdline then open stdin
    // - if more than one path set OutputName flag
    //

    if( (_PathArguments.QueryPathCount() == 0) ) {

        // use stdin
        LinesFound = SearchStream( Get_Standard_Input_Stream() );

        if( !_OutputLines ) {
            DisplayMessage(MSG_FIND_COUNT, NORMAL_MESSAGE, "%d", LinesFound);
        }
        return;
    }

    PathArray = _PathArguments.GetPathArray();
    PIterator = (PARRAY_ITERATOR)PathArray->QueryIterator();

    //
    // - for each path specified on the command line
    //    - open a stream for the path
    //    - print filename if supposed to
    //    - call SearchStream
    //
    while( (CurrentPath = (PPATH)PIterator->GetNext()) != NULL ) {
        CurrentPathString.Initialize( CurrentPath->GetPathString() );
        CurrentPathString.Strupr();

        // if the system object can return a FSN_DIRECTORY for this
        // path then the user is trying to 'find' on a dir so print
        // access denied and skip this file

        if( CurrentFSDir = SYSTEM::QueryDirectory(CurrentPath) ) {

            if (CurrentPath->IsDrive()) {

                DisplayMessage(MSG_FIND_FILE_NOT_FOUND, ERROR_MESSAGE, "%W", &CurrentPathString);

            } else {

                DisplayMessage( MSG_ACCESS_DENIED, ERROR_MESSAGE, "%W", &CurrentPathString);

            }

            DELETE( CurrentFSDir );
            continue;
        }


        if( !(CurrentFSNode = SYSTEM::QueryFile(CurrentPath, _SkipOfflineFiles, &OfflineSkipped)) ||
            !(CurrentFile = CurrentFSNode->QueryStream(READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL)) ) {

            //
            //      If the file name is "", DOS5 prints an invalid parameter
            //      format message.  There is no clean way to filter this
            //      kind of stuff in the ULIB library, so we will have to
            //      parse the path ourselves.
            //
            if ( IsDos5CompatibleFileName( CurrentPath ) ) {
                //
                //  Track whether an offline file was skipped:
                //  We don't want to print an error message for each file,
                //  just a one warning at the end
                //
                if (OfflineSkipped) {
                    PrintSkipWarning = TRUE;
                } else {
                    DisplayMessage(MSG_FIND_FILE_NOT_FOUND, ERROR_MESSAGE, "%W", &CurrentPathString);
                }
            } else {
                DisplayMessage(MSG_FIND_INVALID_FORMAT, ERROR_MESSAGE );
                break;
            }
            DELETE( CurrentFile );
            DELETE( CurrentFSNode );
            CurrentFile     =   NULL;
            CurrentFSNode   =   NULL;
            continue;

        }

        if( _OutputLines ) {
            DisplayMessage( MSG_FIND_BANNER, NORMAL_MESSAGE, "%W", &CurrentPathString);
        }

        LinesFound = SearchStream( CurrentFile );

        if( !_OutputLines ) {
            DisplayMessage(MSG_FIND_COUNT_BANNER, NORMAL_MESSAGE, "%W%d", &CurrentPathString, LinesFound);
        }

        DELETE( CurrentFSNode );
        DELETE( CurrentFile );
        CurrentFSNode   = NULL;
        CurrentFile     = NULL;
    }

    //
    // Print warning message if offline files were skipped
    //
    if(PrintSkipWarning) {
        DisplayMessage(MSG_FIND_OFFLINE_FILES_SKIPPED, ERROR_MESSAGE);
    }

    return;
}



VOID
FIND::Terminate(
    )

/*++

Routine Description:

    Deletes objects created during initialization.

Arguments:

    None.

Return Value:

    None.


--*/

{
   exit(_ErrorLevel);
}


VOID __cdecl
main()
{
   DEFINE_CLASS_DESCRIPTOR( FIND );

   {
       FIND    Find;

        if( Find.Initialize() ) {
            Find.SearchFiles();
        }

        Find.Terminate();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\findstr\findstr.c ===
// FINDSTR (used to be QGREP), June 1992
//
// Modification History:
//
//     Aug 1990     PeteS       Created.
//         1990     DaveGi      Ported to Cruiser
//  31-Oct-1990     W-Barry     Removed the #ifdef M_I386 'cause this
//                              code will never see 16bit again.
//  June 1992       t-petes     Added recursive file search in subdirs.
//                              Used file mapping instead of multi-thread.
//                              Disabled internal switches.
//                              Internatioanlized display messages.
//                              Made switches case-insensitive.
//  05/08/93        v-junm      Added Japanese search support.
//  06/03/93        v-junm      Added Bilingual Message support>


/*  About FILEMAP support:
 *  The file mapping object is used to speed up string searches. The new
 *  file mapping method is coded as #ifdef-#else-#endif to show the
 *  changes needed to be made. The old code(non-filemapping) has a read
 *  buffer like this:
 *
 *      filbuf[] = {.....................................}
 *                      ^                           ^
 *                    BegPtr                      EndPtr
 *
 *  This means there are some spare space before BegPtr and after EndPtr
 *  for the search algorithm to work its way. The old code also
 *  occasionally modifies filbuf[](like filbuf[i] = '\n';).
 *
 *  The new code(filemapping) must avoid doing all of the above because
 *  there are no spare space before BegPtr or after EndPtr when mapping
 *  view of the file which is opened as read-only.
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>
#include <windows.h>
#include <ctype.h>
#include <assert.h>
#include <locale.h>
#include <stdarg.h>

#include "fsmsg.h"

#define FILBUFLEN   (SECTORLEN*2)

#define ISCOT       0x0002                          // Handle is console output
#define LG2SECLEN   10                              // Log base two of sector length
#define LNOLEN      12                              // Maximum line number length
#define MAXSTRLEN   128                             // Maximum search string length
#define OUTBUFLEN   (SECTORLEN*2)                   // Output buffer length
#define PATHLEN     (MAX_PATH+2)                    // Path buffer length
#define SECTORLEN   (1 << LG2SECLEN)                // Sector length
#define STKLEN      512                             // Stack length in bytes
#define TRTABLEN    256                             // Translation table length
#define s_text(x)   (((char *)(x)) - ((x)->s_must)) // Text field access macro
#define EOS         ('\r')                          // End of string
#define CURRENT_DIRECTORY_MAX_LENGTH    512
#define MAX_SLASH_C_OPTION          100

//  Bit flag definitions

#define SHOWNAME        0x01            // Print filename
#define NAMEONLY        0x02            // Print filename only
#define LINENOS         0x04            // Print line numbers
#define BEGLINE         0x08            // Match at beginning of line
#define ENDLINE         0x10            // Match at end of line
#define DEBUG           0x20            // Print debugging output
#define TIMER           0x40            // Time execution
#define SEEKOFF         0x80            // Print seek offsets
#define PRINTABLE_ONLY 0x100            // Skip files with non-printable characters
#define OFFLINE_FILES  0x200            // Do not skip offline files

#define DISPLAYBUFFER_SIZE     4096

//  Type definitions

typedef struct stringnode {
    struct stringnode   *s_alt;         // List of alternates
    struct stringnode   *s_suf;         // List of suffixes
    int                 s_must;         // Length of portion that must match
}
                        STRINGNODE;     // String node

typedef ULONG           CBIO;           // I/O byte count
typedef ULONG           PARM;           // Generic parameter

typedef CBIO            *PCBIO;         // Pointer to I/O byte count
typedef PARM            *PPARM;         // Pointer to generic parameter


// Global data

char    *BaseByteAddress = NULL;        // File mapping base address
BOOL    bStdIn = FALSE;                 // Std-input file flag
BOOL    bLargeFile = FALSE;                 // Dealing with non-memory mapped file

#ifdef FE_SB
BOOL    IsDBCSCodePage = TRUE;
#endif

char        filbuf[FILBUFLEN*2L + 12];
char        outbuf[OUTBUFLEN*2];
char        td1[TRTABLEN] = { 0 };
unsigned    cchmin = (unsigned)-1;      // Minimum string length
unsigned    chmax = 0;                  // Maximum character
unsigned    chmin = (unsigned)-1;       // Minimum character
char        transtab[TRTABLEN] = { 0 };
STRINGNODE  *stringlist[TRTABLEN/2];
int         casesen = 1;                // Assume case-sensitivity
long        cbfile;                     // Number of bytes in file
static int  clists = 1;                 // One is first available index
int         flags;                      // Flags
unsigned    lineno;                     // Current line number
char        *program;                   // Program name
int         status = 1;                 // Assume failure
int         strcnt = 0;                 // String count
char        target[MAXSTRLEN];          // Last string added
int         targetlen;                  // Length of last string added
unsigned    waste;                      // Wasted storage in heap
int         arrc;                       // I/O return code for DOSREAD
char        asyncio;                    // Asynchronous I/O flag
int         awrc = TRUE;                // I/O return code for DOSWRITE
char        *bufptr[] = { filbuf + 4, filbuf + FILBUFLEN + 8 };
CBIO        cbread;                     // Bytes read by DOSREAD
CBIO        cbwrite;                    // Bytes written by DOSWRITE
char        *obuf[] = { outbuf, outbuf + OUTBUFLEN };
int         ocnt[] = { OUTBUFLEN, OUTBUFLEN };
int         oi = 0;                     // Output buffer index
char        *optr[] = { outbuf, outbuf + OUTBUFLEN };
char        pmode;                      // Protected mode flag
WORD        wAttrib = 0;                // filename color
CONSOLE_SCREEN_BUFFER_INFO  csbi = {0}; // Our default screen info
CRITICAL_SECTION    critSection;
BOOLEAN             fExiting = FALSE;

BOOLEAN     fOfflineSkipped = FALSE;    // Whether offline files were skipped

//  External functions and forward references

void        printmessage(FILE  *fp, DWORD messagegID, ...);
            // Message display function for internationalization

int         filematch(char *pszfile, char **ppszpat, int cpat, int fsubdirs);

#ifdef FE_SB
// Function to check if a certain location in a string is the second byte
// of a DBCS character.
int  IsTailByte( unsigned const char *, const int );
int _mbsnicmp( const unsigned char *, const unsigned char *, int, BOOL * );
unsigned char *_mbslwr( unsigned char * );
char *_mbsrchr( const char *, int );
#endif

void        addexpr( char *, int );                  // See QMATCH.C
void        addstring( char *, int );                // See below
int         countlines( char *, char * );
char        *findexpr( unsigned char *, char *);     // See QMATCH.C
char        *findlist( unsigned char *, char * );
char        *findone( unsigned char *buffer, char *bufend );
void        flush1buf( void );                       // See below
void        flush1nobuf( void );                     // See below
int         grepbuffer( char *, char *, char * );    // See below
int         isexpr( unsigned char *, int );          // See QMATCH.C
void        matchstrings( char *, char *, int, int *, int * );
int         preveol( char * );
int         strncspn( char *, char *, int );
int         strnspn( char *, char *, int );
char        *strnupr( char *pch, int cch );
void        write1buf( char *, int, WORD );                // See below
void        (*addstr)( char *, int ) = NULL;
char        *(*find)( unsigned char *, char * ) = NULL;
void        (*flush1)( void ) = flush1buf;
int         (*grep)( char *, char *, char * ) = grepbuffer;
void        (*write1)( char *, int, WORD ) = write1buf;
void        write1nobuf( char *, int, WORD );

int
has_wild_cards(
    char* p
    )
{
    if (!p)
        return 0;

    for (; *p; p++) {
        if (*p == '?' || *p == '*') {
            return 1;
        }
    }

    return 0;
}


void
error(
    DWORD messageID
    )
{
    printmessage(stderr, messageID, program);
                                        // Print message
    exit(2);                            // Die
}


char *
alloc(
    unsigned size
    )
{
    char    *cp;        // Char pointer

    if ((cp = (char *) malloc(size)) == NULL) {   // If allocation fails
        printmessage(stderr, MSG_FINDSTR_OUT_OF_MEMORY, program);
                                        // Write error message
        exit(2);                        // Die
    }
    return(cp);                         // Return pointer to buffer
}


void
freenode(
    STRINGNODE *x
    )
{
    register STRINGNODE *y;             // Pointer to next node in list

    while(x != NULL) {                  // While not at end of list
        if (x->s_suf != NULL)
            freenode(x->s_suf);         // Free suffix list if not end
        else
            --strcnt;                   // Else decrement string count
        y = x;                          // Save pointer
        x = x->s_alt;                   // Move down the list
        free((char *)((INT_PTR) s_text(y) & ~(sizeof(void *) - 1)));
                                        // Free the node
    }
}


STRINGNODE  *
newnode(
    char *s,
    int n
    )
{
    register STRINGNODE *newNode;       // Pointer to new node
    char                *t;             // String pointer
    int                  d;             // rounds to a dword boundary

    d = n & (sizeof(void *) - 1) ? sizeof(void *) - (n & (sizeof(void *) - 1)) : 0;        // offset to next dword past n
    t = alloc(sizeof(STRINGNODE) + n + d);
                                        // Allocate string node
    t += d;                             // END of string word-aligned
    strncpy(t, s, n);                     // Copy string text
    newNode = (STRINGNODE *)(t + n);    // Set pointer to node
    newNode->s_alt = NULL;              // No alternates yet
    newNode->s_suf = NULL;              // No suffixes yet
    newNode->s_must = n;                // Set string length
    return(newNode);                    // Return pointer to new node
}


STRINGNODE  *
reallocnode(
    STRINGNODE *node,
    char *s,
    int n
    )
{
    register char       *cp;            // Char pointer

    assert(n <= node->s_must);          // Node must not grow
    waste += (unsigned)(node->s_must - n);
                                        // Add in wasted space
    assert(sizeof(char *) == sizeof(int));
                                        // Optimizer should eliminate this
    cp = (char *)((INT_PTR) s_text(node) & ~(sizeof(void *) - 1));
                                        // Point to start of text
    node->s_must = n;                   // Set new length
    if (n & (sizeof(void *) - 1))
        cp += sizeof(void *) - (n & (sizeof(void *) - 1));              // Adjust non dword-aligned string
    memmove(cp, s, n);                  // Copy new text
    cp += n;                            // Skip over new text
    memmove(cp, node, sizeof(STRINGNODE));// Copy the node
    return((STRINGNODE *) cp);          // Return pointer to moved node
}


/***    maketd1 - add entry for TD1 shift table
 *
 *      This function fills in the TD1 table for the given
 *      search string.  The idea is adapted from Daniel M.
 *      Sunday's QuickSearch algorithm as described in an
 *      article in the August 1990 issue of "Communications
 *      of the ACM".  As described, the algorithm is suitable
 *      for single-string searches.  The idea to extend it for
 *      multiple search strings is mine and is described below.
 *
 *              Think of searching for a match as shifting the search
 *              pattern p of length n over the source text s until the
 *              search pattern is aligned with matching text or until
 *              the end of the source text is reached.
 *
 *              At any point when we find a mismatch, we know
 *              we will shift our pattern to the right in the
 *              source text at least one position.  Thus,
 *              whenever we find a mismatch, we know the character
 *              s[n] will figure in our next attempt to match.
 *
 *              For some character c, TD1[c] is the 1-based index
 *              from right to left of the first occurrence of c
 *              in p.  Put another way, it is the count of places
 *              to shift p to the right on s so that the rightmost
 *              c in p is aligned with s[n].  If p does not contain
 *              c, then TD1[c] = n + 1, meaning we shift p to align
 *              p[0] with s[n + 1] and try our next match there.
 *
 *              Computing TD1 for a single string is easy:
 *
 *                      memset(TD1, n + 1, sizeof TD1);
 *                      for (i = 0; i < n; ++i) {
 *                          TD1[p[i]] = n - i;
 *                      }
 *
 *              Generalizing this computation to a case where there
 *              are multiple strings of differing lengths is trickier.
 *              The key is to generate a TD1 that is as conservative
 *              as necessary, meaning that no shift value can be larger
 *              than one plus the length of the shortest string for
 *              which you are looking.  The other key is to realize
 *              that you must treat each string as though it were only
 *              as long as the shortest string.  This is best illustrated
 *              with an example.  Consider the following two strings:
 *
 *              DYNAMIC PROCEDURE
 *              7654321 927614321
 *
 *              The numbers under each letter indicate the values of the
 *              TD1 entries if we computed the array for each string
 *              separately.  Taking the union of these two sets, and taking
 *              the smallest value where there are conflicts would yield
 *              the following TD1:
 *
 *              DYNAMICPODURE
 *              7654321974321
 *
 *              Note that TD1['P'] equals 9; since n, the length of our
 *              shortest string is 7, we know we should not have any
 *              shift value larger than 8.  If we clamp our shift values
 *              to this value, then we get
 *
 *              DYNAMICPODURE
 *              7654321874321
 *
 *              Already, this looks fishy, but let's try it out on
 *              s = "DYNAMPROCEDURE".  We know we should match on
 *              the trailing procedure, but watch:
 *
 *              DYNAMPROCEDURE
 *              ^^^^^^^|
 *
 *              Since DYNAMPR doesn't match one of our search strings,
 *              we look at TD1[s[n]] == TD1['O'] == 7.  Applying this
 *              shift, we get
 *
 *              DYNAMPROCEDURE
 *                     ^^^^^^^
 *
 *              As you can see, by shifting 7, we have gone too far, and
 *              we miss our match.  When computing TD1 for "PROCEDURE",
 *              we must take only the first 7 characters, "PROCEDU".
 *              Any trailing characters can be ignored (!) since they
 *              have no effect on matching the first 7 characters of
 *              the string.  Our modified TD1 then becomes
 *
 *              DYNAMICPODURE
 *              7654321752163
 *
 *              When applied to s, we get TD1[s[n]] == TD1['O'] == 5,
 *              leaving us with
 *
 *              DYNAMPROCEDURE
 *                   ^^^^^^^
 *              which is just where we need to be to match on "PROCEDURE".
 *
 *      Going to this algorithm has speeded qgrep up on multi-string
 *      searches from 20-30%.  The all-C version with this algorithm
 *      became as fast or faster than the C+ASM version of the old
 *      algorithm.  Thank you, Daniel Sunday, for your inspiration!
 *
 *      Note: if we are case-insensitive, then we expect the input
 *      string to be upper-cased on entry to this routine.
 *
 *      Pete Stewart, August 14, 1990.
 */

void
maketd1(
    unsigned char *pch,
    unsigned cch,
    unsigned cchstart
    )
{
    unsigned ch, ch1;                   // Character
    unsigned i;                         // String index
    unsigned char   s[2];

    s[1] = 0;
    if ((cch += cchstart) > cchmin)
        cch = cchmin;                   // Use smaller count
    for (i = cchstart; i < cch; ++i) {  // Examine each char left to right
        ch = *pch++;                    // Get the character
        for (;;) {                      // Loop to set up entries
            if (ch < chmin)
                chmin = ch;             // Remember if smallest
            if (ch > chmax)
                chmax = ch;             // Remember if largest
            if (cchmin - i < (unsigned) td1[ch])
                td1[ch] = (unsigned char)(cchmin - i);
                                        // Set value if smaller than previous
            if (casesen || !isalpha(ch) || islower(ch))
                break;                  // Exit loop if done
            ch1 = ch;
            s[0] = (char)ch;
            ch = (unsigned char)(_strlwr((char*)s))[0];       // Force to lower case
            if (ch1 == s[0])             // Lower case is the same to previous.
                break;                   // Exit loop if done
        }
    }
}

static int
newstring(
    unsigned char *s,
    int n
    )
{
    register STRINGNODE *cur;           // Current string
    register STRINGNODE **pprev;        // Pointer to previous link
    STRINGNODE          *newNode;       // New string
    int                 i;              // Index
    int                 j;              // Count
    int                 k;              // Count
    unsigned char       c[2];

    c[1] = 0;

    if ( (unsigned)n < cchmin)
        cchmin = n;                     // Remember length of shortest string

    if ((i = (UCHAR)transtab[*s]) == 0) {       // If no existing list

        //  We have to start a new list

        if ((i = clists++) >= TRTABLEN/2)
            error(MSG_FINDSTR_TOO_MANY_STRING_LISTS);       //"Too many string lists");
                                        // Die if too many string lists
        stringlist[i] = NULL;           // Initialize
        transtab[*s] = (char) i;        // Set pointer to new list
        if (!casesen && isalpha(*s)) {
            c[0] = *s;
            if ((unsigned char)(_strlwr((char*)c))[0] != *s ||
                (unsigned char)(_strupr((char*)c))[0] != *s)
                transtab[c[0]] = (char) i;   // Set pointer for other case
        }
    }
    else
        if (stringlist[i] == NULL)
            return(0);                  // Check for existing 1-byte string
    if (--n == 0) {                      // If 1-byte string
        freenode(stringlist[i]);        // Free any existing stuff
        stringlist[i] = NULL;           // No record here
        ++strcnt;                       // We have a new string
        return(1);                      // String added
    }
    ++s;                                // Skip first char
    pprev = stringlist + i;             // Get pointer to link
    cur = *pprev;                       // Get pointer to node
    while(cur != NULL) {                // Loop to traverse match tree
        i = (n > cur->s_must)? cur->s_must: n;
                                        // Find minimum of string lengths
        matchstrings((char *)s, s_text(cur), i, &j, &k);
                                        // Compare the strings
        if (j == 0) {                    // If complete mismatch
            if (k < 0)
                break;                  // Break if insertion point found
            pprev = &(cur->s_alt);      // Get pointer to alternate link
            cur = *pprev;               // Follow the link
        } else if (i == j) {             // Else if strings matched
            if (i == n) {                // If new is prefix of current
                cur = *pprev = reallocnode(cur, s_text(cur), n);
                                        // Shorten text of node
                if (cur->s_suf != NULL) { // If there are suffixes
                    freenode(cur->s_suf);
                                        // Suffixes no longer needed
                    cur->s_suf = NULL;
                    ++strcnt;           // Account for this string
                }
                return(1);              // String added
            }
            pprev = &(cur->s_suf);      // Get pointer to suffix link
            if ((cur = *pprev) == NULL) return(0);
                                        // Done if current is prefix of new
            s += i;                     // Skip matched portion
            n -= i;
        } else {                        // Else partial match

            //  We must split an existing node.
            //  This is the trickiest case.

            newNode = newnode(s_text(cur) + j, cur->s_must - j);
                                        // Unmatched part of current string
            cur = *pprev = reallocnode(cur, s_text(cur), j);
                                        // Set length to matched portion
            newNode->s_suf = cur->s_suf;    // Current string's suffixes
            if (k < 0) {                 // If new preceded current
                cur->s_suf = newnode((char *)s + j, n - j);
                                        // FIrst suffix is new string
                cur->s_suf->s_alt = newNode;// Alternate is part of current
            } else {                    // Else new followed current
                newNode->s_alt = newnode((char *)(s + j), n - j);
                                        // Unmatched new string is alternate
                cur->s_suf = newNode;   // New suffix list
            }
            ++strcnt;                   // One more string
            return(1);                  // String added
        }
    }
    *pprev = newnode((char *)s, n);     // Set pointer to new node
    (*pprev)->s_alt = cur;              // Attach alternates
    ++strcnt;                           // One more string
    return(1);                          // String added
}


void
addstring(
    char *s,
    int n
    )
{
    int                 endline;        // Match-at-end-of-line flag
    register char       *pch;           // Char pointer

    endline = flags & ENDLINE;          // Initialize flag
    pch = target;                       // Initialize pointer
    while(n-- > 0) {                    // While not at end of string
        switch(*pch = *s++) {           // Switch on character
            case '\\':                  // Escape
                if (n > 0 && !isalnum(*s)) {     // If next character "special"
                    --n;                // Decrement counter
                    *pch = *s++;        // Copy next character
                }
                ++pch;                  // Increment pointer
                break;

            default:                    // All others
                if (IsDBCSLeadByte(*pch)) {
                    --n;
                    ++pch;              // Increment pointer
                    *pch = *s++;
                }
                ++pch;                  // Increment pointer
                break;
        }
    }
    if (endline)
        *pch++ = EOS;                   // Add end character if needed
    targetlen = (int)(pch - target);    // Compute target string length
    if (!casesen)
        strnupr(target, targetlen);      // Force to upper case if necessary
    newstring((unsigned char *)target, targetlen);  // Add string
  }


int
addstrings(
    char *buffer,
    char *bufend,
    char *seplist
    )
{
    int     len;        // String length
    char    tmpbuf[MAXSTRLEN+2];

    while(buffer < bufend) {            // While buffer not empty
        len = strnspn(buffer, seplist, (int)(bufend - buffer));
                                        // Count leading separators
        if ((buffer += len) >= bufend) {
            break;                      // Skip leading separators
        }
        len = strncspn(buffer, seplist, (int)(bufend - buffer));
                                        // Get length of search string
        if (addstr == NULL) {
            addstr = isexpr( (unsigned char *) buffer, len ) ? addexpr : addstring;
                                        // Select search string type
        }

        if (len >= MAXSTRLEN)
            error(MSG_FINDSTR_SEARCH_STRING_TOO_LONG);

        memcpy(tmpbuf, buffer, len);
        tmpbuf[len] = '\n';
        tmpbuf[len+1] = 0;

        if ( addstr == addexpr || (flags & BEGLINE) ||
            findlist((unsigned char *)tmpbuf, tmpbuf + len + 1) == NULL) {
            // If no match within string
            (*addstr)(buffer, len);      // Add string to list
        }

        buffer += len;                  // Skip the string
    }
    return(0);                          // Keep looking
}


int
enumlist(
    STRINGNODE *node,
    int cchprev
    )
{
    int                 strcnt;         // String count

    strcnt = 0;                         // Initialize
    while(node != NULL) {               // While not at end of list
        maketd1((unsigned char *)s_text(node), node->s_must, cchprev);
                    // Make TD1 entries

#if DBG
        if (flags & DEBUG) {            // If verbose output wanted
            int  i;      // Counter


            for(i = 0; i < cchprev; ++i)
                fputc(' ', stderr);     // Indent line
            fwrite(s_text(node), sizeof(char), node->s_must, stderr);
                                        // Write this portion
            fprintf(stderr, "\n");       // Newline
        }
#endif

        strcnt += (node->s_suf != NULL) ?
          enumlist(node->s_suf, cchprev + node->s_must): 1;
                                        // Recurse to do suffixes
        node = node->s_alt;             // Do next alternate in list
    }
    return (strcnt ? strcnt: 1);          // Return string count
}

int
enumstrings()
{
    unsigned char       ch;             // Character
    unsigned            i;              // Index
    int                 strcnt;         // String count

    strcnt = 0;                         // Initialize
    for(i = 0; i < TRTABLEN; ++i) {     // Loop through translation table
        if (casesen || !isalpha(i) || !islower(i)) {
                                        // If case sensitive or not lower
            if (transtab[i] == 0)
                continue;               // Skip null entries
            ch = (char) i;              // Get character
            maketd1((unsigned char *)&ch, 1, 0);    // Make TD1 entry

#if DBG
            if (flags & DEBUG)
                fprintf(stderr, "%c\n", i);   // Print the first byte
#endif

            strcnt += enumlist(stringlist[transtab[i]], 1);
                                        // Enumerate the list
        }
    }
    return (strcnt);                     // Return string count
}


HANDLE
openfile(
    char *name
    )
{
    HANDLE  fd;
    DWORD   attr;

    attr = GetFileAttributes(name);

    if (attr != (DWORD) -1 && (attr & FILE_ATTRIBUTE_DIRECTORY))
        return (HANDLE)-1;

    // Skip offline files unless instructed otherwise
    if (attr != (DWORD) -1 && (attr & FILE_ATTRIBUTE_OFFLINE) && !(flags & OFFLINE_FILES)) {
        fOfflineSkipped = TRUE;
        return (HANDLE)-1;
    }

    if ((fd = CreateFile(name,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OPEN_NO_RECALL,
                        NULL)) == (HANDLE)-1) {

        printmessage(stderr, MSG_FINDSTR_CANNOT_OPEN_FILE, program, name);
    }
    return( fd );                       // Return file descriptor
}



void
startread(
    HANDLE fd,
    char *buffer,
    int buflen
    )
{
    if (bStdIn || bLargeFile) {
        arrc = ReadFile(fd,(PVOID)buffer, buflen, &cbread, NULL);
    }
}



int
finishread()
{
    return(arrc ? cbread : -1); // Return number of bytes read
}



void
startwrite( HANDLE fd, char *buffer, int buflen)
{
    awrc = WriteFile(fd,(PVOID)buffer, buflen, &cbwrite, NULL);
    return;
}


int
finishwrite()
{
    return(awrc ? cbwrite : -1);    // Return number of bytes written
}

BOOL
CtrlHandler(DWORD CtrlType)
{
    // We'll handle Ctrl-C events
    switch(CtrlType) {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
            if (csbi.wAttributes) {
                EnterCriticalSection(&critSection);
                fExiting = TRUE;
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
                    csbi.wAttributes);
                LeaveCriticalSection(&critSection);
            }
            break;
    }

    // Deal with all other events as normal
    return (FALSE);
}

void
write1nobuf(
    char *buffer,
    int buflen,
    WORD wAttributes
    )
{
    int                 nT;
    CBIO                cb;             // Count of bytes written
    BOOL                fCR;
    BOOL                fLF;
    char                buf[STKLEN];
    char                *szT;
    static HANDLE       hConOut = INVALID_HANDLE_VALUE;
    int                 remaining_length;

    // Get the console screen buffer info if we haven't yet.
    if (hConOut == INVALID_HANDLE_VALUE) {
        hConOut = GetStdHandle(STD_OUTPUT_HANDLE);
        InitializeCriticalSection(&critSection);
        SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlHandler, TRUE);
    }

    if (wAttributes) {
        EnterCriticalSection(&critSection);
        // if not exiting, highlight the output
        if (!fExiting)
            SetConsoleTextAttribute(hConOut, wAttributes);
        LeaveCriticalSection(&critSection);
        if (fExiting)
            ExitProcess(2);
    }

    remaining_length = buflen;

    while (remaining_length) {

        buflen = (int)min(sizeof(buf) / sizeof(buf[0]), remaining_length);
        szT = buf;

        if (IsDBCSCodePage) {
            memcpy(buf, buffer, buflen);
        } else {
            for(nT = 0; nT < buflen; nT++) {
                *(szT++) = ((isprint((unsigned char)buffer[nT]) ||
                             isspace((unsigned char)buffer[nT])) ?
                             buffer[nT] : '.');
            }
        }

        if (!WriteFile(hConOut, (PVOID)buf, buflen, &cb, NULL)
            || (cb != (CBIO)(buflen)))
        {
            SetConsoleTextAttribute(hConOut, csbi.wAttributes);
            error(MSG_FINDSTR_WRITE_ERROR); // Die if write fails
        }
        remaining_length -= buflen;
        buffer += buflen;
    }

    if (wAttributes)
        SetConsoleTextAttribute(hConOut, csbi.wAttributes);
}


void
write1buf(
    char *buffer,
    int buflen,
    WORD wAttributes
    )
{
    register int        cb;             // Byte count

    while(buflen > 0) {                 // While bytes remain
        if (!awrc) {                     // If previous write failed
            printmessage(stderr, MSG_FINDSTR_WRITE_ERROR, program);  // Print error message
            exit(2);                    // Die
        }
        if ((cb = ocnt[oi]) == 0) {      // If buffer full
            startwrite( GetStdHandle( STD_OUTPUT_HANDLE ), obuf[oi], OUTBUFLEN );
                                        // Write the buffer
            ocnt[oi] = OUTBUFLEN;       // Reset count and pointer
            optr[oi] = obuf[oi];
            oi ^= 1;                    // Switch buffers
            cb = ocnt[oi];              // Get space remaining
          }
        if (cb > buflen)
            cb = buflen;                // Get minimum
        memmove(optr[oi], buffer, cb);    // Copy bytes to buffer
        ocnt[oi] -= cb;                 // Update buffer length and pointers
        optr[oi] += cb;
        buflen -= cb;
        buffer += cb;
    }
}


void
flush1nobuf(
    void
    )
{
    ;
}


void
flush1buf(
    void
    )
{
    register int        cb;             // Byte count

    if ((cb = OUTBUFLEN - ocnt[oi]) > 0) { // If buffer not empty
        startwrite( GetStdHandle( STD_OUTPUT_HANDLE ), obuf[oi], cb );  // Start write
        if (finishwrite() != cb) {       // If write failed
            printmessage(stderr, MSG_FINDSTR_WRITE_ERROR, program);     // Print error message
            exit(2);                    // Die
        }
    }
}


int
grepbuffer(
    char *startbuf,
    char *endbuf,
    char *name
    )
{
    char  *cp;                          // Buffer pointer
    char  *lastmatch;                   // Last matching line
    int   linelen;                      // Line length
    int   namlen = 0;                   // Length of name
    char  lnobuf[LNOLEN];               // Line number buffer
    char  nambuf[PATHLEN];              // Name buffer

    cp = startbuf;                      // Initialize to start of buffer
    lastmatch = cp;                     // No previous match yet
    while((cp = (*find)((unsigned char *)cp, endbuf)) != NULL) {
                                        // While matches are found
        --cp;                           // Back up to previous character

        // Take care of '\n' as an artificial newline before line 1.
        if ((flags & BEGLINE) && (bStdIn || bLargeFile || cp >= BaseByteAddress) && *cp != '\n' ) {
            // If begin line conditions not met
            cp += strncspn(cp, "\n", (int)(endbuf - cp)) + 1;
                                        // Skip line
            continue;                   // Keep looking
        }
        status = 0;                     // Match found
        if (flags & NAMEONLY)
            return(1);                  // Return if filename only wanted
        cp -= preveol(cp) - 1;          // Point at start of line
        if (flags & SHOWNAME) {          // If name wanted
            if (namlen == 0) {           // If name not formatted yet
                namlen = sprintf(nambuf, "%s:", name);
                                        // Format name if not done already
            }
            (*write1)(nambuf, namlen, wAttrib);   // Show name
        }
        if (flags & LINENOS) {           // If line number wanted
            lineno += countlines(lastmatch, cp);
                                        // Count lines since last match
            (*write1)(lnobuf, sprintf(lnobuf, "%u:", lineno), wAttrib);
                                        // Print line number
            lastmatch = cp;             // New last match
        }
        if (flags & SEEKOFF) {           // If seek offset wanted
            (*write1)(lnobuf, sprintf(lnobuf, "%lu:",
                      cbfile + (long)(cp - startbuf)), wAttrib);
                                        // Print seek offset
        }
        linelen = strncspn(cp, "\n", (int)(endbuf - cp)) + 1;
                                        // Calculate line length
        if (linelen > endbuf - cp) {
            linelen = (int)(endbuf - cp);
        }
        (*write1)(cp, linelen, 0);      // Print the line
        cp += linelen;                  // Skip the line
    }
    lineno += countlines(lastmatch, endbuf);
                                        // Count remaining lines in buffer
    return(0);                          // Keep searching
}


void
showv(
    char *name,
    char *startbuf,
    char *lastmatch,
    char *thismatch
    )
{
    register int        linelen;
    int                 namlen = 0;     // Length of name
    char                lnobuf[LNOLEN]; // Line number buffer
    char                nambuf[PATHLEN];// Name buffer

    if (flags & (SHOWNAME | LINENOS | SEEKOFF)) {
        while(lastmatch < thismatch) {
            if (flags & SHOWNAME) {      // If name wanted
                if (namlen == 0) {       // If name not formatted yet
                    namlen = sprintf(nambuf, "%s:", name);
                                        // Format name if not done already
                }
                (*write1)(nambuf, namlen, wAttrib);
                                        // Write the name
            }
            if (flags & LINENOS)         // If line numbers wanted
              {
                (*write1)(lnobuf, sprintf(lnobuf, "%u:", lineno++), wAttrib);
                                        // Print the line number
            }
            if (flags & SEEKOFF) {       // If seek offsets wanted
                (*write1)(lnobuf, sprintf(lnobuf, "%lu:",
                          cbfile + (long)(lastmatch - startbuf)), wAttrib);
                                        // Print the line number
            }
            linelen = strncspn(lastmatch, "\n", (int)(thismatch - lastmatch));
            // If there's room for the '\n' then pull it in.  Otherwise
            // the buffer doesn't have a '\n' within the range here.
            if (linelen < thismatch - lastmatch) {
                linelen++;
            }
            (*write1)(lastmatch, linelen, 0);
            lastmatch += linelen;
        }
    }
    else
        (*write1)(lastmatch, (int)(thismatch - lastmatch), 0);
}


int
grepvbuffer(
    char *startbuf,
    char *endbuf,
    char *name
    )
{
    char   *cp;                         // Buffer pointer
    char   *lastmatch;                  // Pointer to line after last match

    cp = startbuf;                      // Initialize to start of buffer
    lastmatch = cp;
    while((cp = (*find)((unsigned char *)cp, endbuf)) != NULL) {
        --cp;               // Back up to previous character

        // Take care of '\n' as an artificial newline before line 1.
        if ((flags & BEGLINE) && (bStdIn || bLargeFile || cp >= BaseByteAddress) &&  *cp != '\n') {
            // If begin line conditions not met
            cp += strncspn(cp, "\n", (int)(endbuf - cp)) + 1;
                                        // Skip line
            continue;                   // Keep looking
        }
        cp -= preveol(cp) - 1;          // Point at start of line
        if (cp > lastmatch) {            // If we have lines without matches
            status = 0;                 // Lines without matches found
            if (flags & NAMEONLY) return(1);
                                        // Skip rest of file if NAMEONLY
            showv(name, startbuf, lastmatch, cp);
                                        // Show from last match to this
        }
        cp += strncspn(cp, "\n", (int)(endbuf - cp)) + 1;
                                        // Skip over line with match
        lastmatch = cp;                 // New "last" match
        ++lineno;                       // Increment line count
    }
    if (endbuf > lastmatch) {            // If we have lines without matches
        status = 0;                     // Lines without matches found
        if (flags & NAMEONLY)
            return(1);                  // Skip rest of file if NAMEONLY
        showv(name, startbuf, lastmatch, endbuf);
                                        // Show buffer tail
    }
    return(0);                          // Keep searching file
}


void
qgrep(
    int (*grep)( char *, char *, char * ),
    char *name,
    HANDLE fd
    )
{
    register int  cb;       // Byte count
    char     *cp;           // Buffer pointer
    char     *endbuf;       // End of buffer
    int      taillen;       // Length of buffer tail
    int      bufi;          // Buffer index
    HANDLE   MapHandle;     // File mapping handle
    BOOL     grep_result;

    cbfile = 0L;            // File empty so far
    lineno = 1;             // File starts on line 1
    taillen = 0;            // No buffer tail yet
    bufi = 0;               // Initialize buffer index
    cp = bufptr[0];         // Initialize to start of buffer

    bStdIn = (fd == GetStdHandle(STD_INPUT_HANDLE));

    // If fd is not std-input, use file mapping object method.

    if (!bStdIn) {
        DWORD   cbread_high;

        if ((((cbread = (CBIO)GetFileSize(fd, &cbread_high)) == -1) && (GetLastError() != NO_ERROR)) ||
            (cbread == 0 && cbread_high == 0)) {
            return; // skip the file
        }

        if (cbread_high) {
            bLargeFile = TRUE;  // too large to map and even if it succeed in mapping like under ia64, it
                                // will probably fail in pointer arithmetics
        } else {
            MapHandle = CreateFileMapping(fd,
                                          NULL,
                                          PAGE_READONLY,
                                          0L,
                                          0L,
                                          NULL);
            if (MapHandle == NULL) {
                printmessage(stderr, MSG_FINDSTR_CANNOT_CREATE_FILE_MAPPING, program);
                return;
            }

            BaseByteAddress = (char *) MapViewOfFile(MapHandle,
                                                     FILE_MAP_READ,
                                                     0L,
                                                     0L,
                                                     0);
            CloseHandle(MapHandle);
            if (BaseByteAddress == NULL) {
                bLargeFile = TRUE;   // use alternate method
            } else {
                cp = bufptr[0] = BaseByteAddress;
                arrc = TRUE;
            }
        }

    }

    if (bStdIn || bLargeFile) {
        // Reset buffer pointers since they might have been changed.
        cp = bufptr[0] = filbuf + 4;

        arrc = ReadFile(fd, (PVOID)cp, FILBUFLEN, &cbread, NULL);
    }

    if (flags & PRINTABLE_ONLY) {
        unsigned char *s;
        unsigned long n;

        s = (unsigned char *)cp;
        n = cbread;
        while (--n) {
            if (*s < ' ') {

                // If not backspace, tab, CR, LF, FF or Ctrl-Z then not a printable character.

                if (strchr("\b\t\v\r\n\f\032", *s) == NULL) {
                    goto skipfile;
                }
            }

            s += 1;
        }
    }

    // Note: if FILEMAP && !bStdIn, 'while' is executed once(taillen is 0).
    while((cb = finishread()) + taillen > 0) {
        // While search incomplete

        if (bStdIn || bLargeFile) {
            if (cb == -1) {       // If buffer tail is all that's left
                *cp++ = '\r';   // Add end of line sequence
                *cp++ = '\n';
                endbuf = cp;    // Note end of buffer
                taillen = 0;    // Set tail length to zero

            } else {            // Else start next read

                taillen = preveol(cp + cb - 1); // Find length of partial line
                endbuf = cp + cb - taillen;     // Get pointer to end of buffer
                cp = bufptr[bufi ^ 1];          // Pointer to other buffer
                memmove(cp, endbuf, taillen);   // Copy tail to head of other buffer
                cp += taillen;                  // Skip over tail
                if (taillen > (FILBUFLEN/2)) {
                    if (taillen >= FILBUFLEN) {

                        char    tmp[15];

                        cbfile += taillen;
                        taillen = 0;
                        cp = bufptr[bufi^1];
                        startread(fd, cp, FILBUFLEN);
                        _ultoa((unsigned long)lineno, tmp, 10);
                        printmessage(stderr, MSG_FINDSTR_LINE_TOO_LONG, program, tmp);
                    } else
                        startread(fd, cp, (FILBUFLEN - taillen));
                } else
                    startread(fd, cp, (FILBUFLEN - taillen) & (~0 << LG2SECLEN));
                                            // Start next read
            }
        } else {
            endbuf = cp + cb - taillen; // Get pointer to end of buffer

            // Cause 'while' to terminate(since no next read is needed.)
            cbread = 0;
            arrc = TRUE;
        }

        __try {
            grep_result = (*grep)(bufptr[bufi], endbuf, name);
        } __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            printmessage(stderr, MSG_FINDSTR_READ_ERROR, program, name);
            break;
        }

        if (grep_result) {               // If rest of file can be skipped
            (*write1)(name, strlen(name), 0);
                                        // Write file name
            (*write1)("\r\n", 2, 0);      // Write newline sequence

            if (!bStdIn  && !bLargeFile) {
                if (BaseByteAddress != NULL)
                    UnmapViewOfFile(BaseByteAddress);
            }

            return;                     // Skip rest of file
        }

        cbfile += (long)(endbuf - bufptr[bufi]);
                                        // Increment count of bytes in file
        bufi ^= 1;                      // Switch buffers
    }

skipfile:
    if (!bStdIn && !bLargeFile) {
        if (BaseByteAddress != NULL)
            UnmapViewOfFile(BaseByteAddress);
    }
}


char *
rmpath(
    char *name
    )
{
    char                *cp;            // Char pointer

    if (name[0] != '\0' && name[1] == ':')
        name += 2;                      // Skip drive spec if any
    cp = name;                          // Point to start
    while(*name != '\0') {              // While not at end
        ++name;                         // Skip to next character
        if (name[-1] == '/' || name[-1] == '\\') cp = name;
                                        // Point past path separator
    }
    return(cp);                         // Return pointer to name
}


void
prepend_path(
    char* file_name,
    char* path
    )
{
    int path_len;
    char* last;

    // First figure out how much of the path to take.
    // Check for the last occurance of '\' if there is one.

#ifdef FE_SB
    // DBCS tailbytes can contain '\' character.  Use MBCS function.
    last = _mbsrchr(path, '\\');
#else
    last = strrchr(path, '\\');
#endif

    if (last) {
        path_len = (int)(last - path) + 1;
    } else if (path[1] == ':') {
        path_len = 2;
    } else {
        path_len = 0;
    }

    memmove(file_name + path_len, file_name, strlen(file_name) + 1);
    memmove(file_name, path, path_len);
}


void
ConvertAppToOem(
    unsigned argc,
    char* argv[]
    )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;

    for( i=0; i<argc; i++ ) {
        CharToOem( argv[i], argv[i] );
    }
    SetFileApisToOEM();
}


int __cdecl
main(
    int argc,
    char **argv
    )
{
    char           *cp;
    char           *cpaddstrings[MAX_SLASH_C_OPTION];
    int             add_string_count = 0;
    char           *dirlist = NULL;

    HANDLE          fd;

    FILE           *fi;
    int             fsubdirs;           // Search subdirectories
    int             i;
    int             j;
    char           *inpfile = NULL;
    char           *strfile = NULL;
    unsigned long   tstart;             // Start time
    char            filnam[MAX_PATH+1];
    WIN32_FIND_DATA find_data;
    HANDLE          find_handle;
#ifdef FE_SB
    LANGID          LangId;
#endif
    char            *locale;
    BOOLEAN         option_L_specified = FALSE;
    BOOLEAN         option_R_specified = FALSE;

    ConvertAppToOem( argc, argv );
    tstart = clock();                   // Get start time

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    // Default color: just add intensity
    wAttrib = csbi.wAttributes | FOREGROUND_INTENSITY;

    memset(cpaddstrings, 0, sizeof(cpaddstrings));

#ifdef FE_SB
    //
    // Set TEB's language ID to correspond to the console output code page.  This
    // will ensure the correct language message is displayed when FormatMessage is
    // called.
    //

    switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            IsDBCSCodePage = FALSE;
            break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );

    if ((locale = setlocale(LC_ALL, ".OCP")) == NULL) {

        UINT Codepage;

        if (Codepage = GetConsoleOutputCP()) {

            char achCodepage[10];

            wsprintfA(achCodepage, ".%3.4d", Codepage);
            if ((locale = setlocale(LC_ALL, achCodepage)) == NULL) {
                error(MSG_FINDSTR_UNABLE_TO_SET_LOCALE);
            }
        } else
            error(MSG_FINDSTR_UNABLE_TO_SET_LOCALE);
    }
#endif

    asyncio = pmode = 1;                // Do asynchronous I/O

    // program = rmpath(argv[0]);       // Set program name
    program ="FINDSTR";

    memset(td1, 1, TRTABLEN);           // Set up TD1 for startup
    flags = 0;

    _setmode(_fileno(stdout), O_BINARY); // No linefeed translation on output
    _setmode(_fileno(stderr), O_BINARY); // No linefeed translation on output

    fsubdirs = 0;

    for(i = 1; i < argc && (argv[i][0] == '/' || argv[i][0] == '-'); ++i)
    {
        for(cp = &argv[i][1]; *cp != '\0'; ++cp)
        {
            switch(*cp)
            {
                case '?':
                    printmessage(stdout, MSG_FINDSTR_USAGE, NULL); // Verbose usage message
                    exit(0);

                case 'b':
                case 'B':
                    flags |= BEGLINE;
                    break;

                case 'e':
                case 'E':
                    flags |= ENDLINE;
                    break;

                case 'i':
                case 'I':
                    casesen = 0; // case-insensitive search
                    break;

                case 'l':
                case 'L':
                    addstr = addstring;   // Treat strings literally
                    option_L_specified = TRUE;
                    break;

                case 'm':
                case 'M':
                    flags |= NAMEONLY;
                    break;

                case 'n':
                case 'N':
                    flags |= LINENOS;
                    break;

                case 'o':
                case 'O':
                    // Check whether this is an /o or /offline switch
                    if (0 == _stricmp(cp, "OFFLINE")) {
                        flags |= OFFLINE_FILES;
                        cp += (lstrlen( "OFFLINE" ) - 1);
                    } else if (0 == _stricmp(cp, "OFF")) {
                        flags |= OFFLINE_FILES;
                        cp += (lstrlen( "OFF" ) - 1);
                    } else {
                        flags |= SEEKOFF;
                    }
                    break;

                case 'p':
                case 'P':
                    flags |= PRINTABLE_ONLY;
                    break;

                case 'r':
                case 'R':
                    addstr = addexpr;     // Add expression to list
                    option_R_specified = TRUE;
                    break;

                case 's':
                case 'S':
                    fsubdirs = 1;
                    break;

                case 'v':
                case 'V':
                    grep = grepvbuffer;
                    break;

                case 'x':
                case 'X':
                    flags |= BEGLINE | ENDLINE;
                    break;

#if DBG
                case 'd':
                    // This is kinda cheezy, but I didn't want to change the
                    // debug flag as it's been here a while and I couldn't come
                    // up with a different flag for the dirlist, so...
                    if (*(cp + 1) == ':')
                    {
                        *cp-- = 'D';
                        break;
                    }
                    flags |= DEBUG;
                    break;

                case 't':
                    flags |= TIMER;
                    break;
#endif

                default:
                {
                    int     cch;
                    char    chSwitch;
                    char    tmp[3];

                    chSwitch = *cp;

                    if (*(cp + 1) == ':')
                    {
                        if (!*(cp + 2))
                        {
                            tmp[0]=chSwitch;
                            tmp[1]='\0';
                            printmessage(stderr, MSG_FINDSTR_ARGUMENT_MISSING, program, tmp);
                            exit(2);
                        }

                        cp += 2;       // Point to string
                        cch = lstrlen(cp);
                        switch(chSwitch)
                        {
                            case 'd':
                            case 'D':
                                dirlist = cp;
                                cp += cch - 1;
                                continue;

                            case 'c':
                            case 'C':
                                // Add it after we've gone through all the flags
                                //   don't add it now as things may change with
                                //   later flags
                                addstr = addstring; // Treat strings literally
                                if (add_string_count >= MAX_SLASH_C_OPTION) {
                                    error(MSG_FINDSTR_TOO_MANY_SLASH_C_OPTION);
                                }
                                cpaddstrings[add_string_count++] = cp;
                                cp += cch - 1;
                                continue;

                            case 'g':
                            case 'G':       // Patterns in file
                            case 'f':
                            case 'F':       // Names of files to search in file
                                if (chSwitch == 'f' || chSwitch == 'F')
                                    inpfile = cp;
                                else
                                    strfile = cp;
                                cp += cch - 1;
                                continue;

                            case 'a':
                            case 'A':
                                wAttrib = 0;
                                for(; *cp && isxdigit(*cp); ++cp) {

                                    int digit = (int) (*cp <= TEXT('9'))
                                        ? (int)*cp - (int)'0'
                                        : (int)tolower(*cp)-(int)'W';

                                    wAttrib = (wAttrib << 4) + digit;
                                }
                                cp--;
                                continue;

                            default:
                                cp += cch - 1;
                                // break out and spit out the switch ignored msg
                                break;
                        }
                    }

                    tmp[0]='/';
                    tmp[1]=chSwitch;
                    tmp[2]='\0';
                    printmessage(stderr, MSG_FINDSTR_SWITCH_IGNORED, program, tmp);
                    break;
                }
            }
        }
    } // for( i=1;  )

    if (option_L_specified && option_R_specified)
        error(MSG_FINDSTR_CONFLICTING_OPTIONS_LR);
    else if (option_L_specified)
        addstr = addstring;
    else if (option_R_specified)
        addstr = addexpr;

    // Explicit string (no separators). Add string "as is"
    if (add_string_count) {
        for (j=0; j<add_string_count && cpaddstrings[j]; j++)
            addstrings( cpaddstrings[j], cpaddstrings[j] + lstrlen(cpaddstrings[j]), "" );
    }

    if (i == argc && strcnt == 0 && strfile == NULL)
        error(MSG_FINDSTR_BAD_COMMAND_LINE);

    bufptr[0][-1] = bufptr[1][-1] = '\n';   // Mark beginnings with newline

// Note:  4-Dec-90 w-barry  Since there currently exists no method to query a
//                          handle with the Win32 api (no equivalent to
//                          DosQueryHType() ), the following piece of code
//                          replaces the commented section.

    if (_isatty(_fileno(stdout))) {       // If stdout is a device
        write1 = write1nobuf;           // Use unbuffered output
        flush1 = flush1nobuf;
    }

//    /*
//     *  Check type of handle for std. out.
//     */
//    if (DosQueryHType(fileno(stdout),(PPARM) &j,(PPARM) &fd) != NO_ERROR)
//      {
//        error("Standard output bad handle");
//      }
//                                      // Die if error
//    if (j != 0 && (fd & ISCOT))        // If handle is console output
//#else
//    filbuf[3] = '\n';                 // Mark beginning with newline
//    if (isatty(fileno(stdout)))        // If stdout is a device
//#endif
//      {
//      write1 = write1nobuf;           // Use unbuffered output
//      flush1 = flush1nobuf;
//      }


    if (strfile != NULL) {               // If strings from file
        if ((strcmp(strfile, "/") != 0) && (strcmp(strfile, "-") != 0)) {
            // If strings not from std. input

            if ( ( fd = CreateFile( strfile,
                                    GENERIC_READ,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL ) ) == (HANDLE)-1 )
            {             // If open fails
                printmessage(stderr, MSG_FINDSTR_CANNOT_READ_STRINGS, program, strfile);
                exit(2);                // Die
            }
        }else {
             fd = GetStdHandle( STD_INPUT_HANDLE );     // Else use std. input
        }
        qgrep( addstrings, "\r\n", fd );// Do the work
        if ( fd != GetStdHandle( STD_INPUT_HANDLE ) ) {
            CloseHandle( fd );          // Close strings file
        }
    } else if (strcnt == 0) {            // Else if strings on command line
        cp = argv[i++];                 // Set pointer to strings
        addstrings(cp, cp + strlen(cp), " \t");
                                        // Add strings to list
    }

    if (strcnt == 0)
        error(MSG_FINDSTR_NO_SEARCH_STRINGS);   // Die if no strings

    if (addstr != addexpr) {             // If not using expressions
        memset(td1, cchmin + 1, TRTABLEN);// Initialize table
        find = findlist;                // Assume finding many
        if ((j = enumstrings()) != strcnt) {

            char    t1[15], t2[15];

            _itoa(j, t1, 10);
            _itoa(strcnt, t2, 10);
            printmessage(stderr, MSG_FINDSTR_STRING_COUNT_ERROR, t1, t2);
        }

        // Enumerate strings and verify count

#if DBG
        if (flags & DEBUG) {             // If debugging output wanted
            fprintf(stderr, "%u bytes wasted in heap\n", waste);
                                        // Print storage waste
            assert(chmin <= chmax);     // Must have some entries
            fprintf(stderr, "chmin = %u, chmax = %u, cchmin = %u\n", chmin, chmax, cchmin);
                                        // Print range info
            for (j = (int)chmin; j <= (int)chmax; ++j) {
                // Loop to print TD1 table
                if ( td1[j] <= (char)cchmin ) {  // If not maximum shift
                    if (isascii(j) && isprint(j))
                        fprintf(stderr, "'%c'=%2u  ", j, td1[j]);      // Show literally if printable
                    else
                        fprintf(stderr, "\\%02x=%2u  ", j, td1[j]);    // Else show hex value
                }
            }
            fprintf(stderr, "\n");
        }
#endif

        if (strcnt == 1 && casesen)
            find = findone;             // Find one case-sensitive string
    } else if (find == NULL) {
        find = findexpr;                // Else find expressions
    }

    if (inpfile != NULL) {               // If file list from file
        flags |= SHOWNAME;              // Always show name of file
        if ((strcmp(inpfile, "/") != 0) && (strcmp(inpfile, "-") != 0)) {
            if ((fi = fopen(inpfile, "r")) == NULL) {
                // If open fails
                printmessage(stderr, MSG_FINDSTR_CANNOT_READ_FILE_LIST, program, inpfile);
                exit(2);                // Error exit
            }
        } else
            fi = stdin;                 // Else read file list from stdin

        while(fgets(filnam, MAX_PATH+1, fi) != NULL) {
            // While there are names
            filnam[strcspn(filnam, "\r\n")] = '\0';  // Null-terminate the name
            if ((fd = openfile(filnam)) == (HANDLE)-1) {
                continue;               // Skip file if it cannot be opened
            }
            qgrep(grep, filnam, fd);      // Do the work
            CloseHandle( fd );
        }

        if (fi != stdin)
            fclose(fi);                 // Close the list file
    } else if (i == argc) {
        flags &= ~(NAMEONLY | SHOWNAME);
        qgrep( grep, NULL, GetStdHandle( STD_INPUT_HANDLE ) );
    }

    if (argc > i + 1 || fsubdirs || has_wild_cards(argv[i]))
        flags |= SHOWNAME;


    if (dirlist && *dirlist) {
        char *dir;
        char *dirend = (char *)-1;
        char *original_current_directory = NULL;
        DWORD   size;

        size = GetCurrentDirectory(0, NULL);
        if (size) {
            original_current_directory = (PCHAR)malloc(size);
            if (original_current_directory == NULL) {
                printmessage(stderr, MSG_FINDSTR_OUT_OF_MEMORY, program);
                exit(2);
            }
            size = GetCurrentDirectory(size, original_current_directory);
        }

        if (!size) {
            free(original_current_directory);
            printmessage(stderr, MSG_FINDSTR_UNABLE_TO_GET_CURRENT_DIRECTORY, program);
            exit(2);
        }

        for(dir = dirlist; dirend; dir = dirend + 1) {

            if (dirend = strchr(dir, ';'))
                *dirend = 0;

            if (*dir) {
                (*write1)("  ", 2, wAttrib);      // Indent a couple of spaces
                (*write1)(dir, lstrlen(dir), wAttrib);   // Show name
                (*write1)(":\r\n", 3, wAttrib);      // Write newline sequence

                if (!SetCurrentDirectory(original_current_directory)) {
                    free(original_current_directory);
                    printmessage(stderr, MSG_FINDSTR_CANNOT_OPEN_FILE, program,
                                 original_current_directory);
                    exit(2);
                }
                if (!SetCurrentDirectory(dir)) {
                    printmessage(stderr, MSG_FINDSTR_CANNOT_OPEN_FILE, program, dir);
                } else {
                    while (filematch(filnam, argv + i, argc - i, fsubdirs) >= 0) {
#ifdef FE_SB
//                        _mbslwr((unsigned char *)filnam);
#else
//                        _strlwr(filnam);
#endif
                        if ((fd = openfile(filnam)) != (HANDLE)-1) {
                            qgrep(grep, filnam, fd);
                            CloseHandle( fd );
                        }
                    }
                }
            }
        }
        free(original_current_directory);
    }
    else if (fsubdirs && argc > i) {         // If directory search wanted
        while (filematch(filnam, argv + i, argc - i, fsubdirs) >= 0) {
#ifdef FE_SB
//            _mbslwr((unsigned char *)filnam);
#else
//            _strlwr(filnam);
#endif
            if ((fd = openfile(filnam)) == (HANDLE)-1) {
                continue;
            }

            qgrep(grep, filnam, fd);
            CloseHandle( fd );
        }
    } else {              // Else search files specified
        for(; i < argc; ++i) {
#ifdef FE_SB
//            _mbslwr((unsigned char *) argv[i]);
#else
//            _strlwr(argv[i]);
#endif
            find_handle = FindFirstFile(argv[i], &find_data);
            if (find_handle == INVALID_HANDLE_VALUE) {
                printmessage(stderr, MSG_FINDSTR_CANNOT_OPEN_FILE, program, argv[i]);
                continue;
            }

            do {

#ifdef FE_SB
//                _mbslwr((unsigned char *)find_data.cFileName);
#else
//                _strlwr(find_data.cFileName);
#endif
                prepend_path(find_data.cFileName, argv[i]);
                fd = openfile(find_data.cFileName);

                if (fd != INVALID_HANDLE_VALUE) {
                    qgrep(grep, find_data.cFileName, fd);
                    CloseHandle( fd );
                }
            } while (FindNextFile(find_handle, &find_data));
        }
    }

    (*flush1)();

#if DBG
    if ( flags & TIMER ) {               // If timing wanted
        unsigned long tend;

        tend = clock();
        tstart = tend - tstart;     // Get time in milliseconds
        fprintf(stderr, "%lu.%03lu seconds\n", ( tstart / CLK_TCK ), ( tstart % CLK_TCK ) );
                                        // Print total elapsed time
    }
#endif

    // Print warning in case that offline files were skipped
    if (fOfflineSkipped) {
        printmessage(stderr, MSG_FINDSTR_OFFLINE_FILE_SKIPPED, program);
    }

    return( status );
}  // main


char * findsub( unsigned char *, char * );
char * findsubi( unsigned char *, char * );

char * (*flworker[])(unsigned char *, char *) = {             // Table of workers
    findsubi,
    findsub
};


char *
strnupr(
    char *pch,
    int cch
    )
{
    char    c[2];

#ifdef FE_SB
    int     max = cch;
    c[1] = 0;
    for ( cch = 0; cch < max; cch++ )  {
#else
    c[1] = 0;
    while (cch-- > 0) {                 // Convert string to upper case
#endif
        if (isalpha((unsigned char)pch[cch])) {
            c[0] = pch[cch];
            pch[cch] = (_strupr(c))[0];
        }
#ifdef FE_SB
        else if (IsDBCSCodePage && IsDBCSLeadByte(pch[cch]))
            cch++;
#endif
    }
    return(pch);
}


/*
 *  This is an implementation of the QuickSearch algorith described
 *  by Daniel M. Sunday in the August 1990 issue of CACM.  The TD1
 *  table is computed before this routine is called.
 */

char *
findone(
    unsigned char *buffer,
    char *bufend
    )
{
#ifdef FE_SB // Starting position of string for checking 2nd bytes of DBCS characters.
    unsigned char *bufferhead = buffer;
#endif

    if ((bufend -= targetlen - 1) <= (char *) buffer)
        return((char *) 0);             // Fail if buffer too small

    while (buffer < (unsigned char *) bufend) {     // While space remains
        int cch;                        // Character count
        register char *pch1;            // Char pointer
        register char *pch2;            // Char pointer

        pch1 = target;                  // Point at pattern
        pch2 = (char *) buffer;         // Point at buffer

#ifdef FE_SB
        // If buffer points to the 2nd byte of a DBCS character,
        // skip to next compare position.
        if ( !IsTailByte( bufferhead, (int)(buffer - bufferhead) ) )  {
#endif
            for (cch = targetlen; cch > 0; --cch) {
                                            // Loop to try match
                if (*pch1++ != *pch2++)
                    break;                  // Exit loop on mismatch
            }
            if (cch == 0)
                return((char *)buffer);     // Return pointer to match
#ifdef FE_SB
        }
#endif

        if (buffer + 1 < (unsigned char *) bufend)         // Make sure buffer[targetlen] is valid.
            buffer += ((unsigned char)td1[buffer[targetlen]]); // Skip ahead
        else
            break;
    }
    return((char *) 0);                 // No match
}


int
preveol(
    char *s
    )
{
    register  char   *cp;        // Char pointer

    cp = s + 1;             // Initialize pointer

    if (!bStdIn && !bLargeFile) {
        while((--cp >= BaseByteAddress) && (*cp != '\n'))
            ;    // Find previous end-of-line
    } else {
        while(*--cp != '\n') ;      // Find previous end-of-line
    }

    return (int)(s - cp);         // Return distance to match
}


int
countlines(
    char *start,
    char *finish
    )
{
    register int        count;          // Line count

    for(count = 0; start < finish; ) {
        // Loop to count lines
        if (*start++ == '\n')
            ++count;                    // Increment count if linefeed found
    }
    return(count);                      // Return count
}



char *
findlist(
    unsigned char *buffer,
    char *bufend
    )
{
    char        *match;                 // Pointer to matching string

    // Avoid writting to bufend. bufend[-1] is something(such as '\n') that is not
    // part of search and will cause the search to stop.

    match = (*flworker[casesen])(buffer, bufend);   // Call worker

    return(match);                      // Return matching string
}


char *
findsub(
    unsigned char *buffer,
    char *bufend
    )
{
    register char       *cp;            // Char pointer
    STRINGNODE          *s;             // String node pointer
    int                 i;              // Index
#ifdef FE_SB // Head of buffer for checking if a certain offset is the 2nd byte of a DBCS character.
    unsigned char       *bufhead = buffer;
#endif
    char                *real_bufend = bufend;

    if (cchmin != (unsigned)-1 &&
        cchmin != 0 &&
        (bufend -= cchmin - 1) < (char *) buffer)
        return((char *) 0);     // Compute effective buffer length

    while(buffer < (unsigned char *) bufend) {      // Loop to find match
#ifdef FE_SB
        // Search cannot start at the second byte of a DBCS character,
        // so check for it and skip it if it is a second byte.
        if ((i = (UCHAR)transtab[*buffer]) != 0 &&
            !IsTailByte( bufhead, (int)(buffer-bufhead) ) ) {
#else
        if ((i = (UCHAR)transtab[*buffer]) != 0) {
#endif
            // If valid first character
            if ((s = stringlist[i]) == 0) {
                return((char *)buffer);             // Check for 1-byte match
            }

            for(cp = (char *) buffer + 1; (real_bufend - cp) >= s->s_must; )  {    // Loop to search list

                if ((i = _strncoll(cp, s_text(s), s->s_must)) == 0) {
                                                    // If portions match
                    cp += s->s_must;                // Skip matching portion
                    if ((s = s->s_suf) == 0)
                        return((char *)buffer);     // Return match if end of list
                    continue;                       // Else continue
                }

                if (i < 0 || (s = s->s_alt) == 0) {
                    break;                          // Break if not in this list
                }
            }
        }

        if (buffer + 1 < (unsigned char *) bufend)   // Make sure buffer[cchmin] is valid.
            if (cchmin == (unsigned)-1)
                buffer++;
            else
                buffer += ((unsigned char)td1[buffer[cchmin]]); // Shift as much as possible
        else
            break;
    }
    return((char *) 0);                 // No match
}


char *
findsubi(
    unsigned char *buffer,
    char *bufend
    )
{
    register char       *cp;            // Char pointer
    STRINGNODE          *s;             // String node pointer
    int                 i;              // Index
#ifdef FE_SB
    // Keep head of buffer for checking if a certain offset is the 2nd byte of
    // a DBCS character.
    unsigned char       *bufhead = buffer;
#endif

    if (cchmin != (unsigned)-1 &&
        cchmin != 0 &&
        (bufend -= cchmin - 1) < (char *) buffer)
        return((char *) 0);                 // Compute effective buffer length

    while(buffer < (unsigned char *) bufend) {      // Loop to find match
#ifdef FE_SB
        // Search cannot start at the second byte of a DBCS character, so check for it
        // and skip it if it is a second byte.
        if ((i = (UCHAR)transtab[*buffer]) != 0 &&
            !IsTailByte( bufhead, (int)(buffer-bufhead) ) ) {
                                            // If valid first character
            BOOL    TailByte;               // Flag to check if 1st char is leadbyte.
#else
        if ((i = (UCHAR)transtab[*buffer]) != 0) {  // If valid first character
#endif

            if ((s = stringlist[i]) == 0)
                return((char *) buffer);    // Check for 1-byte match

#ifdef FE_SB
            // Same leadbytes with tailbytes such as 0x41 and 0x61 will become the same
            // character, so become aware of it and use the multibyte function.

            //
            // Check if buffer+1 is a tailbyte character.
            //

            TailByte = IsTailByte(buffer, 1);

            for(cp = (char *) buffer + 1; ; ) {     // Loop to search list
                if ((i = _mbsnicmp((unsigned char *)cp, (unsigned char *) s_text(s), s->s_must, &TailByte)) == 0) {
#else
            for(cp = (char *) buffer + 1; ; ) {     // Loop to search list
                if ((i = memicmp(cp, s_text(s), s->s_must)) == 0) {
#endif
                    // If portions match
                    cp += s->s_must;                // Skip matching portion
                    if ((s = s->s_suf) == 0)
                        return((char *) buffer);    // Return match if end of list
                    continue;                       // And continue
                }
                if (i < 0 || (s = s->s_alt) == 0)
                    break;              // Break if not in this list
            }
        }

        if (buffer + 1 < (unsigned char *) bufend)   // Make sure buffer[cchmin] is valid.
            if (cchmin == (unsigned)-1)
                buffer++;
            else
                buffer += ((unsigned char)td1[buffer[cchmin]]); // Shift as much as possible
        else
            break;
    }
    return((char *) 0);                 // No match
}


int
strnspn(
    char *s,
    char *t,
    int n
    )
/*
    Description:

        Finds the position of the first character in s of length n that is not
        in the character set t.

    Argument:

        s   - string to search from.
        t   - character set to search for
        n   - length of s

    Returns:

        Returns the offset of the first character in s that is not in t
*/
{
    register  char        *s1;          // String pointer
    register  char        *t1;          // String pointer

    for(s1 = s; n-- != 0; ++s1) {           // While not at end of s
        for(t1 = t; *t1 != '\0'; ++t1) {    // While not at end of t
            if (*s1 == *t1)
                break;                  // Break if match found
        }
        if (*t1 == '\0')
            break;                      // Break if no match found
    }
    return (int)(s1 - s);               // Return length
}


int
strncspn(
    char *s,
    char *t,
    int n
    )
/*
    Description:

        Finds the position of the first occurence of characters in t in string
        s of length n.

    Argument:

        s   - string to search from.
        t   - character set to search for
        n   - length of s

    Returns:

        Returns first offset position in s that consists of characters in t
        Returns length of s if not found.
*/
{
    register   char        *s1;         // String pointer
    register   char        *t1;         // String pointer

    for(s1 = s; n-- != 0; ++s1) {           // While not at end of s
        for(t1 = t; *t1 != '\0'; ++t1) {    // While not at end of t
            if (*s1 == *t1)
                return (int)(s1 - s);   // Return if match found
        }
    }
    return (int)(s1 - s);               // Return length
}


void
matchstrings(
    char *s1,
    char *s2,
    int len,
    int *nmatched,
    int *leg
    )
{
    register char       *cp;            // Char pointer
    register int (__cdecl *cmp)(const char*, const char*, size_t);       // Comparison function pointer

    cmp = casesen ? _strncoll: _strnicoll;       // Set pointer
    if ((*leg = (*cmp)(s1, s2, len)) != 0) {   // If strings don't match
        for(cp = s1; (*cmp)(cp, s2++, 1) == 0; ++cp)
            ;
                                        // Find mismatch
        *nmatched = (int)(cp - s1);     // Return number matched
    }
    else *nmatched = len;               // Else all matched
}



void
printmessage (
    FILE* fp,
    DWORD messageID,
    ...
    )
{
    char        messagebuffer[DISPLAYBUFFER_SIZE];
    WCHAR       widemessagebuffer[DISPLAYBUFFER_SIZE];
    ULONG       len;
    NTSTATUS    status;

    va_list     ap;

    va_start(ap, messageID);

    if (len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                            NULL,
                            messageID,
                            0,
                            messagebuffer,
                            DISPLAYBUFFER_SIZE,
                            &ap)) {
        // the messagebuffer should be null terminated
        status = RtlMultiByteToUnicodeN(widemessagebuffer,
                                        DISPLAYBUFFER_SIZE*sizeof(WCHAR),
                                        &len,
                                        messagebuffer,
                                        len);
        // the widemessagebuffer is not null terminated but len tells us how long
        if (NT_SUCCESS(status)) {
            status = RtlUnicodeToOemN(messagebuffer, DISPLAYBUFFER_SIZE-1, &len, widemessagebuffer, len);
            // the messagebuffer is not null terminated but len tells us how long
            if (NT_SUCCESS(status)) {
                messagebuffer[len] = 0;
                fprintf(fp, "%s", messagebuffer);
            } else {
                DbgPrint("Failure to convert Unicode to Oem: %d\n", GetLastError());
            }
        } else {
            DbgPrint("Failure to convert MultiByte to Unicode: %d\n", GetLastError());
        }
    } else {
        DbgPrint("FormatMessage failed: %d\n", GetLastError());
    }

    va_end(ap);
}

#ifdef FE_SB

int
IsTailByte(
    unsigned const char *text,
    const int offset
    )

/*
    Description:

        This routine checks to see if the byte at the offset location is a
        tail byte of a DBCS character.  The offset is calculated such that the
        first location has a value of 0.

    Argument:

        text   - Points to a MBCS text string.

        offset - zero base offset to check character is a tailbyte of a DBCS
                 character.

    Returns:

        TRUE   - offset position is a tailbyte character.

        FALSE  - otherwise.

    Modifications:

        v-junm:     05/06/93 - Original.
*/

{
    int i = offset;

    if ( !IsDBCSCodePage )
        return( FALSE );

    for ( ; i; i-- )
        if ( !IsDBCSLeadByte ( text[i-1] ) )
            break;

    return( ( offset - i ) % 2 );
}

char *
_mbsrchr(
    const char *string,
    int c
    )

/*
    Description:

        This function is a DBCS enabled version of the STRRCHR function
        included in the MS C/C++ library.  What DBCS enabled means is that
        the SBCS character 'c' is found in a MBCS string 'string'.  'c' is
        a SBCS character that cannot be contained in the tailbyte of a DBCS
        character.

    Argument:

        string - Points to a MBCS text string.

        offset - Character to find in string.

    Returns:

        Returns a pointer to the last occurance of c in string, or a NULL
        pointer if c is not found.

    Modifications:

        v-junm:     05/06/93 - Original.
*/

{
    register int    i = strlen( string );

    for (; i >= 0; i-- ) {
        if ( ( *(string + i) == (char)c ) && !IsTailByte( (unsigned char *) string, i ) )
            return( (char*)(string + i) );
    }
    return ( NULL );
}


unsigned char *
_mbslwr(
    unsigned char *s
    )

/*
    Description:

        This function is a DBCS aware version of the strlwr function
        included in the MS C/C++ library.  SBCS alphabets contained in
        the tailbyte of a DBCS character is not affected in the conversion.

    Argument:

        s - String to converted to lower case.

    Returns:

        Returns a string that was converted to lower case.

    Modifications:

        v-junm:     05/06/93 - Original.
*/

{
    //
    // If NonJP code page, use original routine.
    //
    if ( !IsDBCSCodePage )
        return( (unsigned char *) _strlwr( (char *) s ) );

    //
    // While not end of string convert to lower case.
    //
    for( ; *s; s++ )  {

        //
        // if Leadbyte and next character is not NULL
        //     skip tailbyte
        // else if uppercase character
        //     convert it to lowercase
        //
        if ( IsDBCSLeadByte( *s ) && *(s+1) )
            s++;
        else if ( *s >= 0x41 && *s <= 0x5a )
            *s = *s + 0x20;
    }
    return( s );
}

int
_mbsnicmp(
    const unsigned char *s1,
    const unsigned char *s2,
    int n,
    BOOL *TailByte
    )

/*
    Description:

        This is similar to a DBCS aware version of the memicmp function
        contained in the MS C/C++ library.  The only difference is that
        an additional parameter is passed which indicates if the first
        character is a tailbyte of a DBCS character.

    Argument:

        s1  - string 1 to compare.

        s2  - string 2 to compare.

        n   - maximum number of bytes to compare.

        TailByte - flag to indicate first character in s1 and s2 is a tailbyte
                   of a DBCS character.

    Returns:

        RetVal < 0  - s1 < s2

        RetVal = 0  - s1 == s2

        RetVal > 0  - s1 > s2

    Modifications:

        v-junm:     05/06/93 - Original.
*/

{
    BOOL    tail = *TailByte;
    int     i;

    *TailByte = FALSE;

    for( ; n; n--, s1++, s2++ )  {

        if ( *s1 == *s2 )  {

            if ( tail == FALSE && IsDBCSLeadByte( *s1 ) )
                tail = TRUE;
            else
                tail = FALSE;

            continue;

        }
        else if ( !tail )  {

            i = _strnicoll((char *)s1, (char *)s2, 1);
            if (i == 0)
                continue;
            return i;
        }

        return( *s1 - *s2 );
    }

    *TailByte = tail;

    return( 0 );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\findstr\qmatch.c ===
// static char *SCCSID = "@(#)qmatch.c   13.7 90/08/13";


#include <stdio.h>
#include <ctype.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdarg.h>
#include "fsmsg.h"

#define ASCLEN          256             // Number of ascii characters
#define BUFLEN          256             // Temporary buffer length
#define EOS             ('\r')          // End of string character
#define EOS2            ('\n')          // Alternate End of string character
#define PATMAX          512             // Maximum parsed pattern length

#define BEGLINE         0x08            // Match at beginning of line
#define DEBUG           0x20            // Print debugging output
#define ENDLINE         0x10            // Match at end of line

#define T_END           0               // End of expression
#define T_STRING        1               // String to match
#define T_SINGLE        2               // Single character to match
#define T_CLASS         3               // Class to match
#define T_ANY           4               // Match any character
#define T_STAR          5               // *-expr


typedef struct exprnode {
    struct exprnode     *ex_next;       // Next node in list
    unsigned char       *ex_pattern;    // Pointer to pattern to match
} EXPR;             // Expression node

static int      clists = 1;     // One is first available index
static int      toklen[] = {    // Table of token lengths
    32767,      // T_END: invalid
    32767,      // T_STRING: invalid
    2,          // T_SINGLE
    ASCLEN/8+1, // T_CLASS
    1,          // T_ANY
    32767       // T_STAR: invalid
};

static int      (__cdecl *ncmp)(const char *,const char *,size_t);
                                // String comparison pointer


extern int      casesen;        // Case-sensitivity flag
extern char     *(*find)(unsigned char *, char *); // Pointer to search function
extern int      flags;          // Flags
extern int      strcnt;         // String count
extern char     transtab[];     // Translation table
EXPR            *stringlist[ASCLEN];
                                // String table


void            addexpr( char *, int ); // Add expression
extern char     *alloc(unsigned);       // User-defined heap allocator
unsigned char   *simpleprefix();        // Match simple prefix
char            *strnupr( char *pch, int cch );
void            printmessage(FILE  *fp, DWORD messagegid, ...);
                // Message display function for internationalization(findstr.c)

unsigned char *
simpleprefix(
    unsigned char *s,          // String pointer
    unsigned char **pp         // Pointer to pattern pointer
    )
{
    register unsigned char  *p;          // Simple pattern pointer
    register int            c;           // Single character
    char                    tmp[2];

    tmp[1] = 0;
    p = *pp;                   // Initialize
    while(*p != T_END && *p != T_STAR) { // While not at end of pattern
        switch(*p++) {                   // Switch on token type
            case T_STRING:               // String to compare
                if((*ncmp)((char *)s, (char *)p + 1, *p) != 0)
                    return(NULL);
                                        // Fail if mismatch found
                s += *p;                // Skip matched portion
                p += *p + 1;            // Skip to next token
                break;

            case T_SINGLE:              // Single character
                c = *s++;               // Get character
                if(!casesen) {
                    tmp[0] = (char)c;
                    c = (unsigned char)(_strupr(tmp))[0];
                }
                                        // Map to upper case if necessary
                if(c != (int)*p++)
                    return(NULL);
                                        // Fail if mismatch found
                break;

            case T_CLASS:               // Class of characters
                if(!(p[*s >> 3] & (1 << (*s & 7))))
                    return(NULL);       // Failure if bit not set
                p += ASCLEN/8;          // Skip bit vector
                ++s;                    // Skip character
                break;

            case T_ANY:                 // Any character

                if(*s == EOS || *s == EOS2)
                    return(NULL);       // Match all but end of string
                ++s;
                break;
        }
    }
    *pp = p;                            // Update pointer
    return(s);                          // Pattern is prefix of s
}


int
match(
    unsigned char  *s,          // String to match
    unsigned char  *p           // Pattern to match against
    )
{
    register unsigned char *q;          // Temporary pointer
    unsigned char       *r;             // Temporary pointer
    register int        c;              // Character
    char                tmp[2];

    if(*p != T_END && *p != T_STAR && (s = simpleprefix(s,&p)) == NULL)
        return(0);                      // Failure if prefix mismatch
    if(*p++ == T_END)
        return(1);                      // Match if end of pattern
    tmp[1] = 0;
    q = r = p;                          // Point to repeated token
    r += toklen[*q];                    // Skip repeated token
    switch(*q++) {                      // Switch on token type
        case T_ANY:                     // Any character
            while(match(s,r) == 0) {    // While match not found
                if(*s == EOS || *s == EOS2)
                    return(0);          // Match all but end of string
                ++s;
            }
            return(1);                    // Success

        case T_SINGLE:                  // Single character
            while(match(s,r) == 0) {    // While match not found
                c = *s++;               // Get character
                if(!casesen) {
                    tmp[0] = (char)c;
                    c = (unsigned char)(_strupr(tmp))[0];     // Map to upper case if necessary
                }
                if((unsigned char) c != *q)
                    return(0);          // Fail if mismatch found
            }
            return(1);                  // Success

        case T_CLASS:                   // Class of characters
            while(match(s,r) == 0) {    // While match not found
                if(!(q[*s >> 3] & (1 << (*s & 7))))
                    return(0);          // Fail if bit not set
                ++s;                    // Else skip character
            }
            return(1);                    // Success
    }
    return(0);                          // Return failure
}


int
exprmatch(
    char *s,                // String
    char *p                 // Pattern
    )
{
    ncmp = _strncoll;                    // Assume case-sensitive
    if(!casesen) {
        ncmp = _strnicoll;
    }                                   // Be case-insensitive if flag set

    // See if pattern matches string
    return(match((unsigned char *)s, (unsigned char *)p));
}


void
bitset(
    char            *bitvec,      // Bit vector
    unsigned char   first,        // First character
    unsigned char   last,         // Last character
    int             bitval        // Bit value (0 or 1)
    )
{
    int             bitno;        // Bit number

    bitvec += first >> 3;               // Point at first byte
    bitno = first & 7;                  // Calculate first bit number
    while(first <= last) {              // Loop to set bits
        if(bitno == 0 && first + 8 <= last) {
                                        // If we have a whole byte's worth
            *bitvec++ = (char)(bitval? '\xFF': '\0');
                                        // Set the bits
            first += 8;                 // Increment the counter
            continue;                   // Next iteration
        }
        *bitvec=(char)(*bitvec & (unsigned char)(~(1 << bitno))) | (unsigned char)(bitval << bitno);
                                        // Set the appropriate bit
        if(++bitno == 8) {              // If we wrap into next byte
            ++bitvec;                   // Increment pointer
            bitno = 0;                  // Reset bit index
        }
        ++first;                        // Increment bit index
    }
}


unsigned char *
exprparse(
    unsigned char  *p   // Raw pattern
    )
{
    register char       *cp;            // Char pointer
    unsigned char       *cp2;           // Char pointer
    int                 i;              // Counter/index
    int                 j;              // Counter/index
    int                 n;
    int                 bitval;         // Bit value
    char                buffer[PATMAX]; // Temporary buffer
    char                tmp1[2];
    char                tmp2[2];
    char                tmp3[2];
    unsigned            x;

    tmp1[1] = tmp2[1] = tmp3[1] =  0;
    if(!casesen)
        strnupr((char *)p, strlen((char *)p));  // Force pattern to upper case
    cp = buffer;                        // Initialize pointer
    if(*p == '^')
        *cp++ = *p++;                   // Copy leading caret if any
    while(*p != '\0') {                 // While not end of pattern
        i = -2;                         // Initialize
        for(n = 0;;) {                  // Loop to delimit ordinary string
            n += strcspn((char *)(p + n),".\\[*");// Look for a special character
            if(p[n] != '\\')
                break;                  // Break if not backslash
            i = n;                      // Remember where backslash is
            if(p[++n] == '\0')
                return(NULL);           // Cannot be at very end
            ++n;                        // Skip escaped character
        }
        if(p[n] == '*') {               // If we found a *-expr.
            if(n-- == 0)
                return(NULL);           // Illegal first character
            if(i == n - 1)
                n = i;                  // Escaped single-char. *-expr.
        }
        if(n > 0) {                     // If we have string or single
            if(n == 1 || (n == 2 && *p == '\\')) {
                                        // If single character
                *cp++ = T_SINGLE;       // Set type
                if(*p == '\\')
                    ++p;                // Skip escape if any
                *cp++ = *p++;           // Copy single character
            } else {                    // Else we have a string
                *cp++ = T_STRING;       // Set type
                cp2 = (unsigned char *)cp++;             // Save pointer to length byte
                while(n-- > 0) {        // While bytes to copy remain
                    if(*p == '\\') {    // If escape found
                        ++p;            // Skip escape
                        --n;            // Adjust length
                    }
                    *cp++ = *p++;       // Copy character
                }
                *cp2 = (unsigned char)((cp - (char *)cp2) - 1);
                                        // Set string length
            }
        }
        if(*p == '\0')
            break;                      // Break if end of pattern
        if(*p == '.') {                 // If matching any
            if(*++p == '*') {           // If star follows any
                ++p;                    // Skip star, too
                *cp++ = T_STAR;         // Insert prefix ahead of token
            }
            *cp++ = T_ANY;              // Match any character
            continue;                   // Next iteration
        }
        if(*p == '[') {                 // If character class
            if(*++p == '\0')
                return(NULL);
                                        // Skip '['
            *cp++ = T_CLASS;            // Set type
            memset(cp,'\0',ASCLEN/8);   // Clear the vector
            bitval = 1;                 // Assume we're setting bits
            if(*p == '^') {             // If inverted class
                ++p;                    // Skip '^'
                memset(cp,'\xFF',ASCLEN/8);
                                        // Set all bits
                bitset(cp,EOS,EOS,0);   // All except end-of-string
                bitset(cp,'\n','\n',0); // And linefeed!
                bitval = 0;             // Now we're clearing bits
            }

            while(*p != ']') {          // Loop to find ']'
                if(*p == '\0')
                    return(NULL);       // Check for malformed string
                if(*p == '\\') {        // If escape found
                    if(*++p == '\0')
                        return(NULL);   // Skip escape
                }
                i = *p++;               // Get first character in range
                if(*p == '-' && p[1] != '\0' && p[1] != ']') {
                                        // If range found
                    ++p;                // Skip hyphen
                    if(*p == '\\' && p[1] != '\0')
                        ++p;            // Skip escape character
                    j = *p++;           // Get end of range
                } else
                    j = i;              // Else just one character

                tmp1[0] = (char)i;
                tmp2[0] = (char)j;
                if (strcoll(tmp1, tmp2) <= 0) {
                    for (x=0; x<ASCLEN; x++) {
                        tmp3[0] = (char)x;
                        if (strcoll(tmp1, tmp3) <= 0 &&
                            strcoll(tmp3, tmp2) <= 0) {
                            bitset(cp, (unsigned char)tmp3[0],
                                   (unsigned char)tmp3[0], bitval);
                            if (!casesen) {
                                if (isupper(x)) {
                                    _strlwr(tmp3);
                                } else if (islower(x))
                                    _strupr(tmp3);
                                else
                                    continue;
                                bitset(cp, (unsigned char)tmp3[0],
                                       (unsigned char)tmp3[0], bitval);
                            }
                        }
                    }
                }
            }

            if(*++p == '*') {           // If repeated class
                memmove(cp,cp - 1,ASCLEN/8 + 1);
                                        // Move vector forward 1 byte
                cp[-1] = T_STAR;        // Insert prefix
                ++cp;                   // Skip to start of vector
                ++p;                    // Skip star
            }
            cp += ASCLEN/8;             // Skip over vector
            continue;                   // Next iteration
        }
        *cp++ = T_STAR;                 // Repeated single character
        *cp++ = T_SINGLE;
        if(*p == '\\')
            ++p;                        // Skip escape if any
        *cp++ = *p++;                   // Copy the character
        assert(*p == '*');              // Validate assumption
        ++p;                            // Skip the star
    }
    *cp++ = T_END;                      // Mark end of parsed expression
    cp2 = (unsigned char *)alloc((int)(cp - buffer));  // Allocate buffer
    memmove(cp2, buffer,(int)(cp - buffer));   // Copy expression to buffer
    return(cp2);                        // Return buffer pointer
}


int
istoken(
    unsigned char  *s,      // String
    int             n       // Length
    )
{
    if(n >= 2 && s[0] == '\\' && s[1] == '<')
        return(1);                      // Token if starts with '\<'

    while(n-- > 0) {                    // Loop to find end of string
        if(*s++ == '\\') {              // If escape found
            if(--n == 0 && *s == '>')
                return(1);              // Token if ends with '\>'
            ++s;                        // Skip escaped character
        }
    }
    return(0);                          // Not a token
}


int
isexpr(
    unsigned char  *s,  // String
    int             n   // Length
    )
{
    unsigned char       *cp;            // Char pointer
    int                 status;         // Return status
    char                buffer[BUFLEN]; // Temporary buffer

    if(istoken(s, n))
        return(1);                      // Tokens are exprs
    memmove(buffer,s,n);                // Copy string to buffer
    buffer[n] = '\0';                   // Null-terminate string
    if (*buffer && buffer[n - 1] == '$')
        return(1);
    if((s = exprparse((unsigned char *)buffer)) == NULL)
        return(0);                      // Not an expression if parse fails
    status = 1;                         // Assume we have an expression
    if(*s != '^' && *s != T_END) {      // If no caret and not empty
        status = 0;                     // Assume not an expression
        cp = s;                         // Initialize
        do {                            // Loop to find special tokens
            switch(*cp++) {             // Switch on token type
                case T_STAR:            // Repeat prefix
                case T_CLASS:           // Character class
                case T_ANY:             // Any character
                    ++status;           // This is an expression
                    break;

                case T_SINGLE:          // Single character
                    ++cp;               // Skip character
                    break;

                case T_STRING:          // String
                    cp += *cp + 1;      // Skip string
                    break;
            }
        }
        while(!status && *cp != T_END)
            ;                           // Do while not at end of expression
    }
    free(s);                            // Free expression
    return(status);                     // Return status
}


#ifdef  gone // for DEBUG

void
exprprint(
    unsigned char *p,       // Pointer to expression
    FILE          *fo       // File pointer
    )
{
    int                 bit;            // Bit value
    int                 count;          // Count of characters in string
    int                 first;          // First character in range
    int                 last;           // Last character in range
    int                 star;           // Repeat prefix flag

    if(*p == '^')
        fputc(*p++,fo);                 // Print leading caret

    while(*p != T_END) {                // While not at end of expression
        star = 0;                       // Assume no prefix
        if(*p == T_STAR) {              // If repeat prefix found
            ++star;                     // Set flag
            ++p;                        // Skip prefix
        }
        switch(*p++) {                  // Switch on token type
            case T_END:                 // End of expression
            case T_STAR:                // Repeat prefix
                fprintf(stderr,"Internal error: exprprint\n");
                                        // Not valid
                exit(2);                // Die abnormal death

            case T_STRING:              // String
                count = *p++;           // Get string length
                goto common;            // Forgive me, Djikstra!

            case T_SINGLE:              // Single character
                count = 1;              // Only one character
common:
                while(count-- > 0) {    // While bytes remain
                    if(*p == EOS || *p == EOS2) {
                                        // If end-of-string found
                        ++p;            // Skip character
                        fputc('$',fo);  // Emit special marker
                        continue;       // Next iteration
                    }
                    if(strchr("*.[\\$",*p) != NULL)
                        fputc('\\',fo); // Emit escape if needed

                    fputc(*p++,fo);     // Emit the character
                }
                break;

            case T_ANY:                         // Match any
                fputc('.',fo);                  // Emit dot
                break;

            case T_CLASS:
                first = -1;                     // Initialize
                fputc('[',fo);                  // Open braces
                for(count = ' '; count <= '~'; ++count) {
                                                // Loop through printable characters
                    if((bit = p[count >> 3] & (1 << (count & 7))) != 0) {
                                                // If bit is set
                        if(first == -1)
                            first = count;
                                                // Set first bit
                        last = count;           // Set last bit
                    }
                    if((!bit || count == '~') && first != -1) {
                                                // If range to print
                        if(strchr("\\]-",first) != NULL)
                            fputc('\\',fo);     // Emit escape if needed
                        fputc(first,fo);        // Print first character in range
                        if(last != first) {     // If we have a range

                            if(last > first + 1)
                                fputc('-',fo);  // Emit hyphen if needed

                            if(strchr("\\]-",last) != NULL)
                                fputc('\\',fo); // Emit escape if needed

                            fputc(last,fo);
                                                // Print last character in range
                        }
                        first = -1;             // Range printed
                    }
                }
                fputc(']',fo);                  // Close braces
                p += ASCLEN/8;                  // Skip bit vector
                break;
        }
        if(star)
            fputc('*',fo);                      // Print star if needed
    }
    fputc('\n',fo);                             // Print newline
}

#endif


char *
get1stcharset(
    unsigned char *e,       // Pointer to expression
    char          *bitvec   // Pointer to bit vector
    )
{
    unsigned char       *cp;            // Char pointer
    int                 i;              // Index/counter
    int                 star;           // Repeat prefix flag

    if(*e == '^')
        ++e;                            // Skip leading caret if any
    memset(bitvec,'\0',ASCLEN/8);       // Clear bit vector
    cp = e;                             // Initialize
    while(*e != T_END) {                // Loop to process leading *-expr.s
        star = 0;                       // Assume no repeat prefix
        if(*e == T_STAR) {              // If repeat prefix found
            ++star;                     // Set flag
            ++e;                        // Skip repeat prefix
        }
        switch(*e++) {                  // Switch on token type
            case T_END:                 // End of expression
            case T_STAR:                // Repeat prefix

                assert(0);              // Not valid
                exit(2);                // Die abnormal death

            case T_STRING:              // String
                if(star || *e++ == '\0') { // If repeat prefix or zero count
                    assert(0);          // Not valid
                    exit(2);            // Die abnormal death
                }
                // Drop through

            case T_SINGLE:              // Single character
                bitset(bitvec,*e,*e,1); // Set the bit
                ++e;                    // Skip the character
                break;

            case T_ANY:                 // Match any
                memset(bitvec,'\xFF',ASCLEN/8);
                                      // Set all the bits
                bitset(bitvec,EOS,EOS,0);   // Except end-of-string
                bitset(bitvec,'\n','\n',0); // And linefeed!
                break;

            case T_CLASS:
                for(i = 0; i < ASCLEN/8; ++i)
                    bitvec[i] |= *e++;  // Or in all the bits
                break;
        }
        if(!star)
            break;                      // Break if not repeated
        cp = e;                         // Update pointer
    }
    return((char *)cp);                 // Point to 1st non-repeated expr.
}


char *
findall(
    unsigned char *buffer,  // Buffer in which to search
    char *bufend            // End of buffer
    )
{
    return(buffer < (unsigned char *) bufend ? (char *) buffer : NULL);  // Fail only on empty buffer
}


void
addtoken(
    char *e,        // Raw token expression
    int   n         // Length of expression
    )
{
    static char         achpref[] = "^";// Prefix
    static char         achprefsuf[] = "[^A-Za-z0-9_]";
                                        // Prefix/suffix
    static char         achsuf[] = "$"; // Suffix
    char                buffer[BUFLEN]; // Temporary buffer

    assert(n >= 2);                     // Must have at least two characters
    if(e[0] == '\\' && e[1] == '<') {   // If begin token
        if(!(flags & BEGLINE)) {        // If not matching at beginning only
            memcpy(buffer,achprefsuf,sizeof achprefsuf - 1);
                                        // Copy first prefix
            memcpy(buffer + sizeof achprefsuf - 1,e + 2,n - 2);
                                        // Attach expression
            addexpr(buffer,n + sizeof achprefsuf - 3);
                                        // Add expression
        }
        memcpy(buffer,achpref,sizeof achpref - 1);
                                        // Copy second prefix
        memcpy(buffer + sizeof achpref - 1,e + 2,n - 2);
                                        // Attach expression
        addexpr(buffer,n + sizeof achpref - 3);
                                        // Add expression
        return;                         // Done
    }
    assert(e[n-2] == '\\' && e[n - 1] == '>');
                                        // Must be end token
    if(!(flags & ENDLINE)) {            // If not matching at end only
        memcpy(buffer,e,n - 2);         // Copy expression
        memcpy(buffer + n - 2,achprefsuf,sizeof achprefsuf - 1);
                                        // Attach first suffix
        addexpr(buffer,n + sizeof achprefsuf - 3);
                                        // Add expression
    }
    memcpy(buffer,e,n - 2);             // Copy expression
    memcpy(buffer + n - 2,achsuf,sizeof achsuf - 1);
                                        // Attach second suffix
    addexpr(buffer,n + sizeof achsuf - 3);
                                        // Add expression
}


void
addexpr(
    char *e,        // Expression to add
    int   n         // Length of expression
    )
{
    EXPR                *expr;          // Expression node pointer
    int                 i;              // Index
    int                 j;              // Index
    int                 locflags;       // Local copy of flags
    char                bitvec[ASCLEN/8];
                                        // First char. bit vector
    char                buffer[BUFLEN]; // Temporary buffer
    char                tmp[2];

    if(find == findall)
        return;                         // Return if matching everything
    if(istoken((unsigned char *)e, n)) {    // If expr is token
        addtoken(e,n);                  // Convert and add tokens
        return;                         // Done
    }
    tmp[1] = 0;
    locflags = flags;                   // Initialize local copy
    if(*e == '^') locflags |= BEGLINE;  // Set flag if match must begin line
    j = -2;                             // Assume no escapes in string
    for(i = 0; i < n - 1; ++i) {        // Loop to find last escape
        if(e[i] == '\\') j = i++;       // Save index of last escape
    }
    if(n > 0 && e[n-1] == '$' && j != n-2) {
                                        // If expr. ends in unescaped '$'
        --n;                            // Skip dollar sign
        locflags |= ENDLINE;            // Match must be at end
    }
    strncpy(buffer,e,n);                // Copy pattern to buffer
    if(locflags & ENDLINE)
        buffer[n++] = EOS;              // Add end character if needed
    buffer[n] = '\0';                   // Null-terminate string
    if((e = (char *)exprparse((unsigned char *)buffer)) == NULL)
        return;                         // Return if invalid expression
    ++strcnt;                           // Increment string count
    if(!(locflags & BEGLINE)) {         // If match needn't be at beginning
        e = get1stcharset((unsigned char *)e, bitvec); // Remove leading *-expr.s
    }

    //  E now points to a buffer containing a preprocessed expression.
    //  We need to find the set of allowable first characters and make
    //  the appropriate entries in the string node table.

    if(*get1stcharset((unsigned char *)e, bitvec) == T_END) {
                                        // If expression will match anything
        find = findall;                 // Match everything
        return;                         // All done
    }

    for(j = 0; j < ASCLEN; ++j) {       // Loop to examine bit vector
        if(bitvec[j >> 3] & (1 << (j & 7))) {       // If the bit is set
            expr = (EXPR *) alloc(sizeof(EXPR));    // Allocate record
            expr->ex_pattern = (unsigned char *)e;  // Point it at pattern
            if((i = (UCHAR)transtab[j]) == 0) {            // If no existing list
                if((i = clists++) >= ASCLEN) {      // If too many string lists

                    printmessage(stderr,MSG_FINDSTR_TOO_MANY_STRING_LISTS,NULL);
                                        // Error message
                    exit(2);            // Die
                }
                stringlist[i] = NULL;   // Initialize
                transtab[j] = (char) i; // Set pointer to new list
                if(!casesen && isalpha(j)) {
                    tmp[0] = (char)j;
                    if ((unsigned char)(_strlwr(tmp))[0] != (unsigned char)j ||
                        (unsigned char)(_strupr(tmp))[0] != (unsigned char)j)
                        transtab[(unsigned char)tmp[0]] = (char)i;  // Set pointer for other case

                }
            }
            expr->ex_next = stringlist[i];          // Link new record into table
            stringlist[i] = expr;
        }
    }

    // if(locflags & DEBUG) exprprint(e,stderr);
                                        // Print the expression if debugging
}


char *
findexpr(
    unsigned char *buffer,  // Buffer in which to search
    char          *bufend   // End of buffer
    )
{
    EXPR          *expr;        // Expression list pointer
    unsigned char *pattern;     // Pattern
    int            i;           // Index
    unsigned char *bufbegin;
    int b;

    bufbegin = buffer;

    while(buffer < (unsigned char *)bufend) {            // Loop to find match
        if((i = (UCHAR)transtab[*buffer++]) == 0)
            continue;                   // Continue if not valid 1st char
        if((expr = (EXPR *) stringlist[i]) == NULL) {
            // If null pointer
            assert(0);
            exit(2);                    // Die
        }
        --buffer;                       // Back up to first character
        while(expr != NULL) {           // Loop to find match
            pattern = expr->ex_pattern; // Point to pattern
            expr = expr->ex_next;       // Point to next record
            if(pattern[0] == '^') {     // If match begin line
                ++pattern;              // Skip caret
                if(buffer > bufbegin && buffer[-1] != '\n') continue;
                                        // Don't bother if not at beginning
            }
            __try {
                b = exprmatch((char *)buffer, (char *)pattern);
            } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) {
                b = 0;
            }
            if (b) {
                return((char *)buffer);
            }
        }
        ++buffer;                       // Skip first character
    }
    return(NULL);                       // No match
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\findstr\recurse.c ===
// recurse.c

#include <ctype.h>
#include <direct.h>
#include <malloc.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <stdlib.h>

typedef struct patarray_s {
    HANDLE  hfind;           // handle for FindFirstFile/FindNextFile
    BOOLEAN find_next_file;  // TRUE if FindNextFile is to be called
    BOOLEAN IsDir;           // TRUE if current found file is a dir
    char    szfile[MAX_PATH];// Name of file/dir found
} patarray_t;

typedef struct dirstack_s {
    struct dirstack_s *next;    // Next element in stack
    struct dirstack_s *prev;    // Previous element in stack
    HANDLE  hfind;
    patarray_t *ppatarray;      // pointer to an array of pattern records
    char szdir[1];              // Directory name
} dirstack_t;                   // Directory stack

#define FA_ATTR(x)  ((x).dwFileAttributes)
#define FA_CCHNAME(x)   MAX_PATH
#define FA_NAME(x)  ((x).cFileName)
#define FA_ALL      (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | \
                     FILE_ATTRIBUTE_SYSTEM)
#define FA_DIR      FILE_ATTRIBUTE_DIRECTORY

static dirstack_t *pdircur = NULL;  // Current directory pointer

void
makename(
    char *pszfile,
    char *pszname
    )
{
    dirstack_t *pdir;               // Directory stack pointer

    *pszfile = '\0';                // Start with null string
    pdir = pdircur;                 // Point at last entry
    if (pdir->next != pdircur) {    // If not only entry
        do {
            pdir = pdir->next;      // Advance to next subdirectory
            strcat(pszfile,pdir->szdir);// Add the subdirectory
        } while (pdir != pdircur);  // Do until current directory
    } else
        strcpy(pszfile, pdircur->szdir);

    strcat(pszfile,pszname);
}


int
filematch(
    char *pszfile,
    char **ppszpat,
    int cpat,
    int fsubdirs
    )
{
    WIN32_FIND_DATA fi, fi2;
    BOOL            b;
    int i;
    dirstack_t *pdir;
    patarray_t *pPatFind;
    char       drive[_MAX_DRIVE];
    char       dir[_MAX_DIR];
    char       fname[_MAX_FNAME];
    char       ext[_MAX_EXT];

    assert(INVALID_HANDLE_VALUE != NULL);

    if (pdircur == NULL) {

       // If stack empty
       if ((pdircur = (dirstack_t *) malloc(sizeof(dirstack_t)+MAX_PATH+1)) == NULL)
            return(-1);                     // Fail if allocation fails

       if ((pdircur->ppatarray =
                (patarray_t *) malloc(sizeof(patarray_t)*cpat)) == NULL) {
            free(pdircur);
            return(-1);
       }
       pdircur->szdir[0] = '\0';                // Root has no name
       pdircur->hfind = INVALID_HANDLE_VALUE;   // No search handle yet
       pdircur->next = pdircur->prev = pdircur; // Entry points to self

       _splitpath(ppszpat[0], drive, dir, fname, ext);

       strcpy(pdircur->szdir, drive);
       strcat(pdircur->szdir, dir);

       strcpy(ppszpat[0], fname);
       strcat(ppszpat[0], ext);

       for (i=1; i<cpat; i++) {
          _splitpath(ppszpat[i], drive, dir, fname, ext);
          strcpy(ppszpat[i], fname);
          strcat(ppszpat[i], ext);
       }

       for (i=0; i<cpat; i++) {
           pdircur->ppatarray[i].hfind = INVALID_HANDLE_VALUE;
           pdircur->ppatarray[i].szfile[0] = '\0';
       }
    }

    while (pdircur != NULL) {
        // While directories remain

        b = TRUE;

        if (pdircur->hfind == INVALID_HANDLE_VALUE) {
            // If no handle yet

            makename(pszfile,"*.*");        // Make search name

            pdircur->hfind = FindFirstFile((LPSTR) pszfile,
            (LPWIN32_FIND_DATA) &fi);       // Find first matching entry
        } else

           b = FindNextFile(pdircur->hfind,
               (LPWIN32_FIND_DATA) &fi);    // Else find next matching entry

        if (b == FALSE || pdircur->hfind == INVALID_HANDLE_VALUE) {
            // If search fails

            if (pdircur->hfind != INVALID_HANDLE_VALUE)
                FindClose(pdircur->hfind);
            pdir = pdircur;     // Point at record to delete
            if ((pdircur = pdir->prev) != pdir) {
                // If no parent directory

                pdircur->next = pdir->next; // Delete record from list
                pdir->next->prev = pdircur;
            } else
                pdircur = NULL;             // Else cause search to stop

            pPatFind = pdir->ppatarray;
            for (i=0; i<cpat; i++) {
                if (pPatFind[i].hfind != NULL &&
                    pPatFind[i].hfind != INVALID_HANDLE_VALUE)
                    FindClose(pPatFind[i].hfind);
            }
            free(pdir->ppatarray);
            free(pdir);                     // Free the record
            continue;                       // Top of loop
        }


        if (FA_ATTR(fi) & FA_DIR) {
            // If subdirectory found

            if (fsubdirs &&
                strcmp(FA_NAME(fi),".") != 0 && strcmp(FA_NAME(fi),"..") != 0 &&
                (pdir = (dirstack_t *) malloc(sizeof(dirstack_t)+FA_CCHNAME(fi)+1)) != NULL)
            {
                if ((pdir->ppatarray =
                        (patarray_t *) malloc(sizeof(patarray_t)*cpat)) == NULL) {
                     free(pdir);
                     continue;
                }
                // If not "." nor ".." and alloc okay

                strcpy(pdir->szdir,FA_NAME(fi));      // Copy name to buffer
                strcat(pdir->szdir,"\\");             // Add trailing backslash
                pdir->hfind = INVALID_HANDLE_VALUE;   // No search handle yet
                pdir->next = pdircur->next;           // Insert entry in linked list
                pdir->prev = pdircur;
                for (i=0; i<cpat; i++) {
                    pdir->ppatarray[i].hfind = INVALID_HANDLE_VALUE;
                    pdir->ppatarray[i].szfile[0] = '\0';
                }
                pdircur->next = pdir;
                pdir->next->prev = pdir;
                pdircur = pdir;             // Make new entry current
            }
            continue;                       // Top of loop
        }

        pPatFind = pdircur->ppatarray;
        for (i = cpat; i-- > 0; ) {
            // Loop to see if we care
            b = (pPatFind[i].hfind != NULL);
            for (;;) {
                if (pPatFind[i].hfind == INVALID_HANDLE_VALUE) {
                    makename(pszfile, ppszpat[i]);
                    pPatFind[i].hfind = FindFirstFile(pszfile, &fi2);
                    b = (pPatFind[i].hfind != INVALID_HANDLE_VALUE);
                    pPatFind[i].find_next_file = FALSE;
                    if (b) {
                        strcpy(pPatFind[i].szfile, FA_NAME(fi2));
                        pPatFind[i].IsDir = (BOOLEAN)(FA_ATTR(fi2) & FA_DIR);
                    }
                } else if (pPatFind[i].find_next_file) {
                    b = FindNextFile(pPatFind[i].hfind, &fi2);
                    pPatFind[i].find_next_file = FALSE;
                    if (b) {
                        strcpy(pPatFind[i].szfile, FA_NAME(fi2));
                        pPatFind[i].IsDir = (BOOLEAN)(FA_ATTR(fi2) & FA_DIR);
                    }
                }
                if (b) {
                    if (pPatFind[i].IsDir) {
                        pPatFind[i].find_next_file = TRUE;
                    } else
                        break;   // found a file to do matching
                } else {
                    if (pPatFind[i].hfind != NULL &&
                            pPatFind[i].hfind != INVALID_HANDLE_VALUE) {
                        FindClose(pPatFind[i].hfind);
                        pPatFind[i].hfind = NULL;
                    }
                    pPatFind[i].find_next_file = FALSE;
                    break;    // exhausted all entries
                }
            } // for

            if (b) {
                if (strcmp(FA_NAME(fi), pPatFind[i].szfile) == 0) {
                    pPatFind[i].find_next_file = TRUE;
                    makename(pszfile, FA_NAME(fi));
                    return 1;
                }
            }
        }
    }
    return(-1);             // No match found
}



#ifdef  TEST
#include <process.h>
#include <stdio.h>

void
main(
    int carg,
    char **ppszarg
    )
{
    char szfile[MAX_PATH]; // if OS2: CCHPATHMAX];

    while (filematch(szfile,ppszarg,carg) >= 0)
    printf("%s\n",szfile);
    exit(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fdisk\windisk.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    windisk.c

Abstract:

    This module contains the main dialog and support routines for
    Disk Administrator.

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    11-Nov-93 (bobri) added doublespace and commit support.

--*/

#include "fdisk.h"
#include "shellapi.h"
#include <string.h>
#include <stdio.h>

#if DBG && DEVL

// stuff used in debug version

BOOL AllowAllDeletes = FALSE;   // whether to allow deleting boot/sys parts

#endif

// External from fdinit.

extern HWND    InitDlg;
extern BOOLEAN InitDlgComplete;
extern BOOLEAN StartedAsIcon;
HANDLE         hAccelerator;

// This is the maximum number of members that WinDisk will support
// in an FT Set.

#define     MaxMembersInFtSet   32

// The following vars keep track of the currently selected regions.

DWORD      SelectionCount = 0;
PDISKSTATE SelectedDS[MaxMembersInFtSet];
ULONG      SelectedRG[MaxMembersInFtSet];

#define    SELECTED_REGION(i)  (SelectedDS[i]->RegionArray[SelectedRG[i]])

FT_TYPE FtSelectionType;

// This variable tracks whether the system partition is secure.

BOOL SystemPartitionIsSecure = FALSE;

// Deleted a partition with no drive letter

BOOLEAN CommitDueToDelete = FALSE;
BOOLEAN CommitDueToMirror = FALSE;
BOOLEAN CommitDueToExtended = FALSE;

// If a mirror is made of the boot partition, this will become
// non-zero and indicate which disk should get some boot code in
// the MBR.

ULONG UpdateMbrOnDisk = 0;

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED

// If FmIfs.dll doesn't have double space routines this
// flag will reflect that fact.

extern BOOLEAN DoubleSpaceSupported;
BOOLEAN DoubleSpaceAutomount;
#endif


VOID
FrameCommandHandler(
    IN HWND  hwnd,
    IN DWORD wParam,
    IN LONG  lParam
    );

DWORD
SetUpMenu(
    IN PDISKSTATE *SinglySelectedDisk,
    IN DWORD      *SinglySelectedRegion
    );

BOOL
AssignDriveLetter(
    IN  BOOL  WarnIfNoLetter,
    IN  DWORD StringId,
    OUT PCHAR DriveLetter
    );

VOID
AdjustOptionsMenu(
    VOID
    );

ULONG
PartitionCount(
    IN ULONG Disk
    );

VOID
CheckForBootNumberChange(
    IN ULONG Disk
    )

/*++

Routine Description:

    Determine if the disk that has just changed is the boot disk.
    If so, determine if the boot partition number changed.  If it
    did, warn the user.

Arguments:

    RegionDescriptor - the region that has just changed.

Return Value:

    None

--*/

{
    ULONG newPart;
    CHAR  oldNumberString[8],
          newNumberString[8];
    DWORD msgCode;

    if (Disk == BootDiskNumber) {

        // Pass a pointer to Disk even though this is just to get the
        // old partition number back.

        if (BootPartitionNumberChanged(&Disk, &newPart)) {
#if i386
            msgCode = MSG_CHANGED_BOOT_PARTITION_X86;
#else
            msgCode = MSG_CHANGED_BOOT_PARTITION_ARC;
#endif
            sprintf(oldNumberString, "%d", Disk);
            sprintf(newNumberString, "%d", newPart);
            InfoDialog(msgCode, oldNumberString, newNumberString);
        }
    }
}


BOOL
IsSystemPartitionSecure(
    )

/*++

Routine Description:

    This routine knows where to go in the Registry to determine
    if the system partition for this boot is to be protected from
    modification.

Arguments:

    None

Return Value:

    TRUE if the system partition is secure
    FALSE otherwise.

--*/

{
    LONG ec;
    HKEY hkey;
    DWORD type;
    DWORD size;
    ULONG value;

    value = FALSE;

    ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                      0,
                      KEY_QUERY_VALUE,
                      &hkey);

    if (ec == NO_ERROR) {

        size = sizeof(ULONG);
        ec = RegQueryValueExA(hkey,
                              TEXT("Protect System Partition"),
                              NULL,
                              &type,
                              (PBYTE)&value,
                              &size);

        if ((ec != NO_ERROR) || (type != REG_DWORD)) {
            value = FALSE;
        }
        RegCloseKey(hkey);
    }
    return value;
}

VOID __cdecl
main(
    IN int     argc,
    IN char   *argv[],
    IN char   *envp[]
    )

/*++

Routine Description:

    This is were control is given to Disk Administrator when it
    is started.  This routine initializes the application and
    contains the control loop for getting and processing Windows
    messages.

Arguments:

    Standard "main" entry

Return Value:

    Standard "main" entry

--*/

{
    MSG      msg;
    NTSTATUS status;
    HANDLE   mutex;

    hModule = GetModuleHandle(NULL);

    mutex = CreateMutex(NULL,FALSE,"Disk Administrator Is Running");

    if (mutex == NULL) {
        // An error (like out of memory) has occurred.
        return;
    }

    // Make sure we are the only process with a handle to our named mutex.

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(mutex);
        InfoDialog(MSG_ALREADY_RUNNING);
        return;
    } else {
        DisplayInitializationMessage();
    }

    // Determine whether this is LanmanNt or Windows NT by looking at
    // HKEY_LOCAL_MACHINE,System\CurrentControlSet\Control\ProductOptions.
    // If the ProductType value therein is "LanmanNt" then this is LanmanNt.

    {
        LONG ec;
        HKEY hkey;
        DWORD type;
        DWORD size;
        UCHAR buf[100];

        IsLanmanNt = FALSE;

#if DBG
        // The code below will allow users to run WinDisk in Lanman
        // mode on WinNt.  It should never be enabled in a released
        // build, but is very useful for internal users.

        if (argc >= 2 && !_stricmp(argv[1], "-p:lanman")) {
            IsLanmanNt = TRUE;
        }
#endif
        ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                          0,
                          KEY_QUERY_VALUE,
                          &hkey);

        if (ec == NO_ERROR) {

            size = sizeof(buf);
            ec = RegQueryValueExA(hkey,
                                  TEXT("ProductType"),
                                  NULL,
                                  &type,
                                  buf,
                                  &size);

            if ((ec == NO_ERROR) && (type == REG_SZ)) {

                if (!lstrcmpiA(buf,"lanmannt")) {
                    IsLanmanNt = TRUE;
                }
                if (!lstrcmpiA(buf,"servernt")) {
                    IsLanmanNt = TRUE;
                }
            }

            RegCloseKey(hkey);
        }
    }

    // Set the Help file name to the file appropriate to
    // the product.

    HelpFile = IsLanmanNt ? LanmanHelpFile : WinHelpFile;

    // Determine whether the system partition is protected:

    SystemPartitionIsSecure = IsSystemPartitionSecure();

    try {

#if DBG
        InitLogging();
#endif

        // Insure that all drives are present before looking.

        RescanDevices();

        if (!NT_SUCCESS(status = FdiskInitialize())) {
            ErrorDialog(status == STATUS_ACCESS_DENIED ? MSG_ACCESS_DENIED : EC(status));
            goto xx1;
        }

        if (((DiskCount = GetDiskCount()) == 0) || AllDisksOffLine()) {
            ErrorDialog(MSG_NO_DISKS);
            goto xx2;
        }

        if (!InitializeApp()) {
            ErrorDialog(MSG_CANT_CREATE_WINDOWS);
            goto xx2;
        }

        InitRectControl();

        SetUpMenu(&SingleSel,&SingleSelIndex);
        AdjustOptionsMenu();

        InitHelp();
        hAccelerator = LoadAccelerators(hModule, TEXT("MainAcc"));

        if (InitDlg) {

            PostMessage(InitDlg,
                        (WM_USER + 1),
                        0,
                        0);
            InitDlg = (HWND) 0;
        }
        while (GetMessage(&msg,NULL,0,0)) {
            if (!TranslateAccelerator(hwndFrame, hAccelerator, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        TermHelp();
        UnloadIfsDll();

      xx2:

        FdiskCleanUp();

      xx1:

        ;

    } finally {

        // Destroy the mutex.

        CloseHandle(mutex);
    }
}

LONG
MyFrameWndProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN UINT  wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    This is the window handler for the main display of Disk Administrator.

Arguments:

    Standard window handler procedure

Return Value:

    Standard window handler procedure

--*/

{
    static BOOLEAN     oneTime = TRUE;
    PMEASUREITEMSTRUCT pMeasureItem;
    DWORD              ec;
    DWORD              action;
    DWORD              temp;
    RECT               rc;
    BOOL               profileWritten,
                       changesMade,
                       mustReboot,
                       configureFt;
    HMENU              hMenu;

    switch (msg) {
    case WM_CREATE:

        // create the listbox

        if (!StartedAsIcon) {
            StartedAsIcon = IsIconic(hwnd);
        }
        GetClientRect(hwnd,&rc);
#if 1
        hwndList = CreateWindow(TEXT("listbox"),
                                NULL,
                                WS_CHILD | WS_HSCROLL | WS_VSCROLL | WS_VISIBLE | LBS_NOTIFY |
                                    LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED,
                                0,
                                dyLegend,
                                rc.right - rc.left,
                                rc.bottom - rc.top - (StatusBar ? dyStatus : 0) - (Legend ? dyLegend : 0),
                                hwnd,
                                (HMENU)ID_LISTBOX,
                                hModule,
                                NULL);
#else
        hwndList = CreateWindow(TEXT("listbox"),
                                NULL,
                                WS_CHILD | WS_HSCROLL | WS_VSCROLL | WS_VISIBLE | LBS_NOTIFY |
                                    LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED,
                                0,
                                dyLegend,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                hwnd,
                                (HMENU)ID_LISTBOX,
                                hModule,
                                NULL);
#endif
        if (hwndList) {

            SetFocus(hwndList);

            // subclass the listbox so we can handle keyboard
            // input our way.

            SubclassListBox(hwndList);
        }

        // If we are not running the LanmanNt version of
        // Windisk, remove the Fault-Tolerance menu item.

        if (!IsLanmanNt && (hMenu = GetMenu( hwnd )) != NULL ) {

            DeleteMenu( hMenu, 1, MF_BYPOSITION );
            DrawMenuBar( hwnd );
        }

        StatusTextDrlt[0] = 0;
        StatusTextStat[0] = StatusTextSize[0] = 0;
        StatusTextType[0] = StatusTextVoll[0] = 0;
        break;

    case WM_SETFOCUS:

        SetFocus(hwndList);
        break;

    case WM_WININICHANGE:

        if ((lParam == (LONG)NULL) || !lstrcmpi((LPTSTR)lParam,TEXT("colors"))) {
            TotalRedrawAndRepaint();
            InvalidateRect(hwnd,NULL,FALSE);
        }
        break;

    case WM_SIZE:

        // resize the listbox

        GetClientRect(hwnd,&rc);
#if 0
        temp = rc.right - rc.left;

        if (GraphWidth != temp) {

            GraphWidth = temp;
            BarWidth = GraphWidth - dxBarTextMargin;
        }
#endif
        MoveWindow(hwndList,
                   rc.left,
                   rc.top,
                   rc.right  - rc.left,
                   rc.bottom - rc.top - (StatusBar ? dyStatus : 0) - (Legend ? dyLegend : 0),
                   TRUE);

        // invalidate status/legend area so that the clipping
        // rectangle is right for redraws

        rc.top = rc.bottom;

        if (StatusBar) {
            rc.top -= dyStatus;
        }
        if (Legend) {
            rc.top -= dyLegend;
        }
        if (rc.top != rc.bottom) {
            InvalidateRect(hwnd,&rc,FALSE);
        }

        // FALL THROUGH

    case WM_MOVE:

        // if not iconic or minimized, save new position for profile

        if (!IsZoomed(hwndFrame) && !IsIconic(hwndFrame)) {
            GetWindowRect(hwndFrame,&rc);
            ProfileWindowX = rc.left;
            ProfileWindowY = rc.top;
            ProfileWindowW = rc.right - rc.left;
            ProfileWindowH = rc.bottom - rc.top;
        }
        break;

    case WM_ENTERIDLE:

        if (ConfigurationSearchIdleTrigger == TRUE && wParam == MSGF_DIALOGBOX) {

            PostMessage((HWND)lParam,WM_ENTERIDLE,wParam,lParam);

        } else {

            // If we're coming from a dialog box and the F1 key is down,
            // kick the dialog box and make it spit out help.

            if ((wParam == MSGF_DIALOGBOX) &&
                (GetKeyState(VK_F1) & 0x8000) &&
                GetDlgItem((HANDLE) lParam, FD_IDHELP)) {

                PostMessage((HANDLE) lParam, WM_COMMAND, FD_IDHELP, 0L);
            }
        }

        return 1;      // indicate we did not process the message

    case WM_PAINT:

#if 1
        if ((!IsIconic(hwnd)) && !(InitDlg && StartedAsIcon)) {
#else
        if (!StartedAsIcon) {
#endif
            HDC         hdcTemp,hdcScr;
            HBITMAP     hbmTemp;
            PAINTSTRUCT ps;
            HBRUSH      hBrush;
            HFONT       hFontOld;
            RECT        rcTemp,rcTemp2;
            DWORD       ClientRight;

            BeginPaint(hwnd,&ps);
            hdcScr = ps.hdc;

            GetClientRect(hwnd,&rc);

            rcTemp2 = rc;
            ClientRight = rc.right;
            rc.top = rc.bottom - dyStatus + dyBorder;

            if (StatusBar) {

                hdcTemp = CreateCompatibleDC(hdcScr);
                hbmTemp = CreateCompatibleBitmap(hdcScr,rc.right-rc.left+1,rc.bottom-rc.top+1);
                SelectObject(hdcTemp,hbmTemp);

                // adjust position for off-screen bitmap

                rcTemp = rc;
                rc.bottom -= rc.top;
                rc.top = 0;

                hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
                if (hBrush) {
                    FillRect(hdcTemp,&rc,hBrush);
                    DeleteObject(hBrush);
                }

                // draw the status bar at the bottom of the window

                hFontOld = SelectObject(hdcTemp,hFontStatus);

                // Status text
                rc.left  = 8 * dyBorder;
                rc.right = 2 * GraphWidth / 5;
                DrawStatusAreaItem(&rc,hdcTemp,StatusTextStat,FALSE);

                // size
                rc.left  = rc.right + (8*dyBorder);
                rc.right = rc.left + (GraphWidth / 9);
                DrawStatusAreaItem(&rc,hdcTemp,StatusTextSize,FALSE);

                // type
                rc.left  = rc.right + (8*dyBorder);
                rc.right = rc.left + (GraphWidth / 5);
                DrawStatusAreaItem(&rc,hdcTemp,(LPTSTR)StatusTextType,TRUE);

                // drive letter
                rc.left  = rc.right + (8*dyBorder);
                rc.right = rc.left + (8*dyBorder) + dxDriveLetterStatusArea;
                DrawStatusAreaItem(&rc,hdcTemp,(LPTSTR)StatusTextDrlt,TRUE);

                // vol label
                rc.left  = rc.right + (8*dyBorder);
                rc.right = GraphWidth - (8*dyBorder);
                DrawStatusAreaItem(&rc,hdcTemp,(LPTSTR)StatusTextVoll,TRUE);

                BitBlt(hdcScr,
                       rcTemp.left,
                       rcTemp.top,
                       rcTemp.right-rcTemp.left+1,
                       rcTemp.bottom-rcTemp.top+1,
                       hdcTemp,
                       0,
                       0,
                       SRCCOPY);

                if (hFontOld) {
                    SelectObject(hdcTemp,hFontOld);
                }
                DeleteObject(hbmTemp);
                DeleteDC(hdcTemp);
            } else {
                rcTemp = rcTemp2;
                rcTemp.top = rcTemp.bottom;
            }

            if (Legend) {

                // draw the legend onto the screen

                if (StatusBar) {
                    rcTemp2.bottom -= dyStatus;
                }
                rcTemp2.top = rcTemp2.bottom - dyLegend + (2*dyBorder);
                if (StatusBar) {
                    rcTemp2.top += dyBorder;
                }
                rcTemp2.right = GraphWidth;
                DrawLegend(hdcScr,&rcTemp2);
            }

            // dark line across top of status/legend area

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNTEXT))) {

                if (StatusBar || Legend) {
                    rcTemp.bottom = rcTemp.top;
                    if (Legend) {
                        rcTemp.bottom -= dyLegend - 1;
                        rcTemp.top -= dyLegend - 1;
                    }
                    rcTemp.top -= dyBorder;
                    FillRect(hdcScr,&rcTemp,hBrush);
                }
                DeleteObject(hBrush);
            }

            EndPaint(hwnd,&ps);

        }
        if (InitDlg) {

            if (InitDlgComplete) {
                PostMessage(InitDlg,
                            (WM_USER + 1),
                            0,
                            0);
                InitDlg = (HWND) 0;
            }

        }
        if (oneTime) {
            if (!StartedAsIcon) {
                SetForegroundWindow(hwnd);
            }
            oneTime = FALSE;
        }
        break;

    case WM_COMMAND:

        FrameCommandHandler(hwnd,wParam,lParam);
        break;

    case WM_MEASUREITEM:

        pMeasureItem = (PMEASUREITEMSTRUCT)lParam;
        pMeasureItem->itemHeight = GraphHeight;
        break;

    case WM_DRAWITEM:

        WMDrawItem((PDRAWITEMSTRUCT)lParam);
        break;

    case WM_CTLCOLORLISTBOX:

        if (lParam == (LONG)hwndList) {
            return (LONG)GetStockObject(LTGRAY_BRUSH);
        } else {
            return DefWindowProc(hwnd,msg,wParam,lParam);
        }

    case WM_CLOSE:

        // Determine whether any disks have been changed, and whether
        // the system must be rebooted.  The system must be rebooted
        // if the registry has changed, if any non-removable disk has
        // changed, or if any removable disk that was not originally
        // unpartitioned has changed.

        changesMade = FALSE;
        configureFt = FALSE;
        mustReboot = RestartRequired;

        for (temp=0; temp<DiskCount; temp++) {
            if (HavePartitionsBeenChanged(temp)) {

                changesMade = TRUE;
                break;
            }
        }

        profileWritten = FALSE;

        // Determine if the commit can be done without a reboot.
        // If FT is in the system then it must be notified to
        // reconfigure if a reboot is not performed.  If it is
        // not in the system, but the new disk information requires
        // it, then a reboot must be forced.

        if (FtInstalled()) {
            configureFt = TRUE;
        }
        if (NewConfigurationRequiresFt()) {
            if (!configureFt) {

                // The FT driver is not loaded currently.

                mustReboot = TRUE;
            } else {

                // If the system is going to be rebooted, don't
                // have FT reconfigure prior to shutdown.

                if (mustReboot) {
                    configureFt = FALSE;
                }
            }
        }

        if (RegistryChanged | changesMade | RestartRequired) {
            if (RestartRequired) {
                action = IDYES;
            } else {
                action = ConfirmationDialog(MSG_CONFIRM_EXIT, MB_ICONQUESTION | MB_YESNOCANCEL);
            }

            if (action == IDYES) {
                ec = CommitLockVolumes(0);
                if (ec) {

                    // could not lock all volumes

                    ErrorDialog(MSG_CANNOT_LOCK_FOR_COMMIT);
                    CommitUnlockVolumes(DiskCount, FALSE);
                    break;
                }
                if (mustReboot) {
                    if (RestartRequired) {
                        action = IDYES;
                    } else {
                        action = ConfirmationDialog(MSG_REQUIRE_REBOOT, MB_ICONQUESTION | MB_YESNO);
                    }

                    if (action != IDYES) {

                        CommitUnlockVolumes(DiskCount, FALSE);
                        break;
                    }
                }

                SetCursor(hcurWait);
                ec = CommitChanges();
                SetCursor(hcurNormal);

                CommitUnlockVolumes(DiskCount, TRUE);
                if (ec != NO_ERROR) {
                    ErrorDialog(MSG_BAD_CONFIG_SET);
                } else {
                    ULONG oldBootPartitionNumber,
                          newBootPartitionNumber;
                    CHAR  oldNumberString[8],
                          newNumberString[8];
                    DWORD msgCode;

                    // Update the configuration registry

                    ec = SaveFt();
                    if (configureFt) {

                        // Issue device control to ftdisk driver to reconfigure.

                        FtConfigure();
                    }

                    // Register autochk to fix up file systems
                    // in newly extended volume sets, if necessary

                    if (RegisterFileSystemExtend()) {
                        mustReboot = TRUE;
                    }

                    // Determine if the FT driver must be enabled.

                    if (DiskRegistryRequiresFt() == TRUE) {
                        if (!FtInstalled()) {
                            mustReboot = TRUE;
                        }
                        DiskRegistryEnableFt();
                    } else {
                        DiskRegistryDisableFt();
                    }

                    if (ec == NO_ERROR) {
                        InfoDialog(MSG_OK_COMMIT);
                    } else {
                        ErrorDialog(MSG_BAD_CONFIG_SET);
                    }

                    // Has the partition number of the boot
                    // partition changed?

                    if (BootPartitionNumberChanged(&oldBootPartitionNumber, &newBootPartitionNumber)) {
#if i386
                        msgCode = MSG_BOOT_PARTITION_CHANGED_X86;
#else
                        msgCode = MSG_BOOT_PARTITION_CHANGED_ARC;
#endif
                        sprintf(oldNumberString, "%d", oldBootPartitionNumber);
                        sprintf(newNumberString, "%d", newBootPartitionNumber);
                        InfoDialog(msgCode, oldNumberString, newNumberString);
                    }

                    ClearCommittedDiskInformation();

                    if (UpdateMbrOnDisk) {

                        UpdateMasterBootCode(UpdateMbrOnDisk);
                        UpdateMbrOnDisk = 0;
                    }

                    // Reboot if necessary.

                    if (mustReboot) {

                        SetCursor(hcurWait);
                        Sleep(5000);
                        SetCursor(hcurNormal);
                        FdShutdownTheSystem();
                        profileWritten = TRUE;
                    }
                    CommitDueToDelete = CommitDueToMirror = FALSE;
                    CommitAssignLetterList();
                }
            } else if (action == IDCANCEL) {
                return 0;      // don't exit
            } else {
                FDASSERT(action == IDNO);
            }
        }

        if (!profileWritten) {
            WriteProfile();
        }
        DestroyWindow(hwnd);
        break;

    case WM_DESTROY:

        // BUGBUG clean up here -- release dc's, free DiskStates, etc.

        WinHelp(hwndFrame,HelpFile,HELP_QUIT,0);
        PostQuitMessage(0);
        break;

    case WM_MENUSELECT:

        SetMenuItemHelpContext(wParam,lParam);
        break;

    case WM_F1DOWN:

        Help(wParam);
        break;

    default:

        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

#if i386

VOID
SetUpMenui386(
    HMENU hMenu,
    DWORD SelectionCount
    )

/*++

Routine Description:

    X86 SPECIFIC

    This routine understands the X86 specific feature of
    "Active Partition".  It determines if the "set partition
    active" menu item should be enabled.

Arguments:

    hMenu          - menu handle
    SelectionCount - number of items currently selected.

Return Value:

    None

--*/

{
    BOOL                allowActive = FALSE;
    PREGION_DESCRIPTOR  regionDescriptor;

    if ((SelectionCount == 1) && (FtSelectionType == -1)) {

        regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];

        // allow it to be made active if
        // -  it is not free space
        // -  it is a primary partition
        // -  it is on disk 0
        // -  it is not already active
        // -  it is not part of an ft set

        if ((regionDescriptor->SysID != SYSID_UNUSED)
         && (regionDescriptor->RegionType == REGION_PRIMARY)
         && !regionDescriptor->Active
         && (GET_FT_OBJECT(regionDescriptor) == NULL)) {
            allowActive = TRUE;
        }
    }

    EnableMenuItem(hMenu,
                   IDM_PARTITIONACTIVE,
                   allowActive ? MF_ENABLED : MF_GRAYED);
}

#endif

DWORD
SetUpMenu(
    IN PDISKSTATE *SinglySelectedDisk,
    IN DWORD      *SinglySelectedRegion
    )

/*++

Routine Description:

    This routine sets up the menu bar based on the state of the app and
    the disks.

    If multiple items are selected, allow neither create nor delete.
    If a single partition is selected, allow delete.
    If a single free space is selected, allow create.
    If the free space is the only free space in the extended partitions,
    also allow delete.  (This is how to delete the extended partition).

Arguments:

    SinglySelectedDisk -- if there is only one selected item, the PDISKSTATE
                          pointed to by this paramater will get a pointer
                          to the selected region's disk structure.  If there are
                          multiple selected items (or none), then the value
                          will be set to NULL.

    SinglySelectedRegion -- if there is only one selected item, the DWORD
                            pointed to by this paramater will get the selected
                            region #.  Otherwise the DWORD gets -1.

Return Value:

    Count of selected regions.

--*/

{
    BOOL  allowCreate           = FALSE,
          allowCreateEx         = FALSE,
          allowDelete           = FALSE,
          allowFormat           = FALSE,
          allowLabel            = FALSE,
          allowBreakMirror      = FALSE,
          allowCreateMirror     = FALSE,
          allowCreateStripe     = FALSE,
          allowCreateVolumeSet  = FALSE,
          allowExtendVolumeSet  = FALSE,
          allowCreatePStripe    = FALSE,
          allowDriveLetter      = FALSE,
          allowRecoverParity    = FALSE,
          ftSetSelected         = FALSE,
          nonFtItemSelected     = FALSE,
          multipleItemsSelected = FALSE,
          volumeSetAndFreeSpaceSelected = FALSE,
          onDifferentDisks,
          possibleRecover;
    BOOL  allowCommit = CommitAllowed();
    WCHAR driveLetter = L' ';
    PWSTR typeName = NULL,
          volumeLabel = NULL;
    PDISKSTATE diskState,
               selDiskState = NULL;
    DWORD      i,
               j,
               selectedRegion = 0;
    ULONG      ordinal                 = 0,
               selectedFreeSpaces      = 0,
               freeSpaceIndex          = 0,
               componentsInFtSet       = 0,
               selectedNonFtPartitions = 0;
    HMENU      hMenu = GetMenu(hwndFrame);
    FT_TYPE    type = (FT_TYPE) 0;
    PULONG     diskSeenCounts;
    PFT_OBJECT_SET     ftSet = NULL;
    PFT_OBJECT         ftObject = NULL;
    PREGION_DESCRIPTOR regionDescriptor;
    PPERSISTENT_REGION_DATA regionData;

    diskSeenCounts = Malloc(DiskCount * sizeof(ULONG));
    RtlZeroMemory(diskSeenCounts,DiskCount * sizeof(ULONG));

    SelectionCount = 0;
    for (i=0; i<DiskCount; i++) {
        diskState = Disks[i];
        for (j=0; j<diskState->RegionCount; j++) {
            if (diskState->Selected[j]) {
                selDiskState = diskState;
                selectedRegion = j;
                SelectionCount++;
                if (SelectionCount <= MaxMembersInFtSet) {
                    SelectedDS[SelectionCount-1] = diskState;
                    SelectedRG[SelectionCount-1] = j;
                }
                diskSeenCounts[diskState->Disk]++;
                if (ftObject = GET_FT_OBJECT(&diskState->RegionArray[j])) {
                    ftSet = ftObject->Set;
                    if (componentsInFtSet == 0) {
                        ordinal = ftSet->Ordinal;
                        type = ftSet->Type;
                        ftSetSelected = TRUE;
                        componentsInFtSet = 1;
                    } else if ((ftSet->Ordinal == ordinal) && (ftSet->Type == type)) {
                        componentsInFtSet++;
                    } else {
                        ftSetSelected = FALSE;
                    }
                } else {

                    nonFtItemSelected = TRUE;

                    if (IsRecognizedPartition(diskState->RegionArray[j].SysID) ) {
                        selectedNonFtPartitions += 1;
                    }
                }
            }
        }
    }

    // Determine the number of free-space regions selected:

    selectedFreeSpaces = 0;
    for (i=0; i<SelectionCount && i < MaxMembersInFtSet; i++) {
        if (SELECTED_REGION(i).SysID == SYSID_UNUSED) {
            freeSpaceIndex = i;
            selectedFreeSpaces++;
        }
    }

    FtSelectionType = -1;
    possibleRecover = FALSE;
    if (nonFtItemSelected && ftSetSelected) {

        // Both FT and Non-FT items have been selected.  First,
        // check to see if a volume set and free space have been
        // selected; then reset the state to indicate that the
        // selection does not consists of a mix of FT and non-FT
        // objects.

        if (type == VolumeSet && selectedFreeSpaces + componentsInFtSet == SelectionCount ) {

            volumeSetAndFreeSpaceSelected = TRUE;
        }

        possibleRecover = TRUE;
        ftSetSelected = FALSE;
        nonFtItemSelected = FALSE;
        multipleItemsSelected = TRUE;
    }

    if ((SelectionCount == 1) && !ftSetSelected) {

        *SinglySelectedDisk = selDiskState;
        *SinglySelectedRegion = selectedRegion;

        regionDescriptor = &selDiskState->RegionArray[selectedRegion];

        if (regionDescriptor->SysID == SYSID_UNUSED) {

            // Free region.  Always allow create; let DoCreate() sort out
            // details about whether partition table is full, etc.

            allowCreate = TRUE;

            if (regionDescriptor->RegionType == REGION_PRIMARY) {
                allowCreateEx = TRUE;
            }

            // special case -- allow deletion of the extended partition if
            // there are no logicals in it.

            if ((regionDescriptor->RegionType == REGION_LOGICAL)
             &&  selDiskState->ExistExtended
             && !selDiskState->ExistLogical) {
                FDASSERT(regionDescriptor->SysID == SYSID_UNUSED);
                allowDelete = TRUE;
            }
        } else {

            // used region.  Delete always allowed.

            allowDelete = TRUE;
            regionData = (PPERSISTENT_REGION_DATA)(PERSISTENT_DATA(regionDescriptor));

            if (regionData) {
                if (regionData->VolumeExists) {
                    if ((regionData->DriveLetter != NO_DRIVE_LETTER_YET) && (regionData->DriveLetter != NO_DRIVE_LETTER_EVER)) {
                        allowFormat = TRUE;
                    }
                }
            }

            // If the region is recognized, then also allow drive letter
            // manipulation.

            if (IsRecognizedPartition(regionDescriptor->SysID)) {

                allowDriveLetter = TRUE;

                // DblSpace volumes are allowed on non-FT, FAT volumes only

                DetermineRegionInfo(regionDescriptor,
                                    &typeName,
                                    &volumeLabel,
                                    &driveLetter);

                if ((driveLetter != NO_DRIVE_LETTER_YET) && (driveLetter != NO_DRIVE_LETTER_EVER)) {
                    if (wcscmp(typeName, L"FAT") == 0) {
                        allowLabel = allowFormat;
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
                        allowDblSpace = allowFormat;
#endif

                        // Force the dll in now to know if Double Space
                        // support is offerred by the dll.

                        LoadIfsDll();
                    }

                    if ((wcscmp(typeName, L"NTFS") == 0) ||
                        (wcscmp(typeName, L"HPFS") == 0)) {
                        allowLabel = allowFormat;
                    }
                }
            }
        }
    } else {

        if (SelectionCount) {

            *SinglySelectedDisk = NULL;
            *SinglySelectedRegion = (DWORD)(-1);

            // Multiple regions are selected.  This might be an existing ft set,
            // a set of regions that allow creation of an ft set, or just plain
            // old multiple items.
            //
            // First deal with a selected ft set.

            if (ftSetSelected) {

                regionDescriptor = &SELECTED_REGION(0);
                regionData = (PPERSISTENT_REGION_DATA)(PERSISTENT_DATA(regionDescriptor));

                // RDR - should locate member zero of the set since it
                // may not be committed yet.

                if (regionData) {
                    if (regionData->VolumeExists) {
                        if ((regionData->DriveLetter != NO_DRIVE_LETTER_YET) && (regionData->DriveLetter != NO_DRIVE_LETTER_EVER)) {

                            // Now check for special cases on FT sets

                            ftObject = regionData->FtObject;
                            if (ftObject) {
                                ftSet = ftObject->Set;
                                if (ftSet) {
                                    FT_SET_STATUS setState = ftSet->Status;
                                    ULONG         numberOfMembers;

                                    LowFtVolumeStatus(regionDescriptor->Disk,
                                                      regionDescriptor->PartitionNumber,
                                                      &setState,
                                                      &numberOfMembers);

                                    if ((ftSet->Status != FtSetDisabled) &&
                                        (setState != FtSetDisabled)) {
                                        allowFormat = TRUE;
                                    }
                                }
                            }
                        }

                        if (regionData->TypeName) {
                            typeName = regionData->TypeName;
                        } else {

                            typeName = NULL;
                            DetermineRegionInfo(regionDescriptor,
                                                &typeName,
                                                &volumeLabel,
                                                &driveLetter);
                            if (!typeName) {

                                if (SelectionCount > 1) {

                                    // it is an FT set - try the next member.

                                    regionDescriptor = &SELECTED_REGION(1);
                                    DetermineRegionInfo(regionDescriptor,
                                                        &typeName,
                                                        &volumeLabel,
                                                        &driveLetter);
                                    regionDescriptor = &SELECTED_REGION(0);
                                }
                            }

                        }

                        if (typeName) {
                            if ((wcscmp(typeName, L"NTFS") == 0) ||
                                (wcscmp(typeName, L"HPFS") == 0) ||
                                (wcscmp(typeName, L"FAT") == 0)) {

                                allowLabel = allowFormat;
                            }
                        }
                    }
                }

                // Allow the correct type of ft-related delete.

                switch (type) {

                case Mirror:
                    allowBreakMirror = TRUE;
                    allowDelete = TRUE;
                    break;
                case StripeWithParity:

                    if ((SelectionCount == ftSet->NumberOfMembers) &&
                        (ftSet->Status == FtSetRecoverable)) {
                        allowRecoverParity = TRUE;
                    }
                    allowDelete = TRUE;
                    break;
                case Stripe:
                case VolumeSet:
                    allowDelete = TRUE;
                    break;
                default:
                    FDASSERT(FALSE);
                }

                FtSelectionType = type;

                if (type == StripeWithParity) {

                    // If the set is disabled.  Do not allow drive
                    // letter changes - This is done because there are
                    // conditions whereby the drive letter code will
                    // access violate if this is done.

                    if (ftSet->Status != FtSetDisabled) {

                        // Must have either member 0 or member 1 for access

                        for (ftObject = ftSet->Members; ftObject; ftObject = ftObject->Next) {
                            if ((ftObject->MemberIndex == 0) ||
                                (ftObject->MemberIndex == 1)) {
                                allowDriveLetter = TRUE;
                                break;
                            }
                        }

                        // if the drive letter cannot be done, then no live
                        // action can be done.

                        if (!allowDriveLetter) {

                            ftSet->Status = FtSetDisabled;
                            allowFormat = FALSE;
                            allowLabel = FALSE;
                        }
                    }
                } else {
                    allowDriveLetter = TRUE;
                }

            } else {

                // Next figure out whether some sort of ft object set could
                // be created out of the selected regions.

                if (SelectionCount <= MaxMembersInFtSet) {

                    // Determine whether the selected regions are all on
                    // different disks.

                    onDifferentDisks = TRUE;
                    for (i=0; i<DiskCount; i++) {
                        if (diskSeenCounts[i] > 1) {
                            onDifferentDisks = FALSE;
                            break;
                        }
                    }

                    // Check for allowing mirror creation.  User must have selected
                    // two regions -- one a recognized partition, the other a free space.

                    if (onDifferentDisks && (SelectionCount == 2)
                    &&((SELECTED_REGION(0).SysID == SYSID_UNUSED) != (SELECTED_REGION(1).SysID == SYSID_UNUSED))
                    &&( IsRecognizedPartition(SELECTED_REGION(0).SysID) ||
                        IsRecognizedPartition(SELECTED_REGION(1).SysID))
                    &&!GET_FT_OBJECT(&(SELECTED_REGION(0)))
                    &&!GET_FT_OBJECT(&(SELECTED_REGION(1))))
                    {
                        allowCreateMirror = TRUE;
                    }

                    // Check for allowing volume set or stripe set

                    if (selectedFreeSpaces == SelectionCount) {
                        allowCreateVolumeSet = TRUE;
                        if (onDifferentDisks) {
                            allowCreateStripe = TRUE;
                            if (selectedFreeSpaces > 2) {
                                allowCreatePStripe = TRUE;
                            }
                        }
                    }

                    // Check for allowing volume set expansion.  If
                    // the selected regions consist of one volume set
                    // and free space, then that volume set can be
                    // extended.  If the selection consists of one
                    // recognized non-FT partition and free space,
                    // then we can convert those regions into a
                    // volume set.

                    if (volumeSetAndFreeSpaceSelected ||
                        (SelectionCount > 1 &&
                         selectedFreeSpaces == SelectionCount - 1 &&
                         selectedNonFtPartitions == 1) ) {

                        allowExtendVolumeSet = TRUE;
                    }

                    // Check for allowing non-in-place FT recover

                    if ((SelectionCount > 1)
                     && (selectedFreeSpaces == 1)
                     && possibleRecover
                     && (type == StripeWithParity)
                     && (ftSet->Status == FtSetRecoverable)) {
                        BOOL OrphanOnSameDiskAsFreeSpace = FALSE;

                        if (!onDifferentDisks) {

                            // Determine whether the orphan is on the same
                            // disk as the free space.  First find the orphan.

                            for (i=0; i<SelectionCount; i++) {

                                PREGION_DESCRIPTOR reg = &SELECTED_REGION(i);

                                if ((i != freeSpaceIndex)
                                && (GET_FT_OBJECT(reg)->State == Orphaned))
                                {
                                    if (SELECTED_REGION(freeSpaceIndex).Disk == reg->Disk) {
                                        OrphanOnSameDiskAsFreeSpace = TRUE;
                                    }
                                    break;
                                }
                            }
                        }

                        if (onDifferentDisks || OrphanOnSameDiskAsFreeSpace) {
                            allowRecoverParity = TRUE;
                        }
                    }
                }
            }
        }
    }

    EnableMenuItem(hMenu,
                   IDM_PARTITIONCREATE,
                   allowCreate ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu,
                   IDM_PARTITIONCREATEEX,
                   allowCreateEx ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu,
                   IDM_PARTITIONDELETE,
                   allowDelete ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu,
                   IDM_PARTITIONFORMAT,
                   allowFormat ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu,
                   IDM_PARTITIONLABEL,
                   allowLabel ? MF_ENABLED : MF_GRAYED);

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
    EnableMenuItem(hMenu,
                   IDM_DBLSPACE,
                   (allowDblSpace & DoubleSpaceSupported) ? MF_ENABLED : MF_GRAYED);

    if (DoubleSpaceAutomount = DiskRegistryAutomountCurrentState()) {
        CheckMenuItem(hMenu, IDM_AUTOMOUNT, MF_BYCOMMAND | MF_CHECKED);
    }

    EnableMenuItem(hMenu,
                   IDM_AUTOMOUNT,
                   MF_ENABLED);
#endif
    EnableMenuItem(hMenu,
                   IDM_CDROM,
                   AllowCdRom ? MF_ENABLED : MF_GRAYED);
#if i386
    SetUpMenui386(hMenu,SelectionCount);
#else
    EnableMenuItem(hMenu,
                   IDM_SECURESYSTEM,
                   MF_ENABLED);

    CheckMenuItem(hMenu,
                  IDM_SECURESYSTEM,
                  SystemPartitionIsSecure ? MF_CHECKED : MF_UNCHECKED);

#endif

    EnableMenuItem(hMenu,
                   IDM_FTBREAKMIRROR,
                   allowBreakMirror ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTESTABLISHMIRROR,
                   IsLanmanNt &&
                   allowCreateMirror ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTCREATESTRIPE,
                   allowCreateStripe ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTCREATEPSTRIPE,
                   allowCreatePStripe ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTCREATEVOLUMESET,
                   allowCreateVolumeSet ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTEXTENDVOLUMESET,
                   allowExtendVolumeSet ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_PARTITIONLETTER,
                   allowDriveLetter ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTRECOVERSTRIPE,
                   IsLanmanNt &&
                   allowRecoverParity ? MF_ENABLED : MF_GRAYED);

    // If the registry has change allow commit.

    if (RegistryChanged) {
        allowCommit = TRUE;
    }
    EnableMenuItem(hMenu,
                   IDM_COMMIT,
                   allowCommit ? MF_ENABLED : MF_GRAYED);
    return SelectionCount;
}

VOID
CompleteSingleRegionOperation(
    IN PDISKSTATE DiskState
    )

/*++

Routine Description:

    Redraw the disk bar for the DiskState given and cause the
    display to refresh.

Arguments:

    DiskState - the disk involved.

Return Value:

    None

--*/

{
    RECT   rc;
    signed displayOffset;

    EnableMenuItem(GetMenu(hwndFrame), IDM_CONFIGSAVE, MF_GRAYED);
    DeterminePartitioningState(DiskState);
    DrawDiskBar(DiskState);
    SetUpMenu(&SingleSel, &SingleSelIndex);

    // BUGBUG use of disk# as offset in listbox

    displayOffset = (signed)DiskState->Disk
                  - (signed)SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);

    if (displayOffset > 0) {             // otherwise it's not visible

        // make a thin rectangle to force update

        rc.left   = BarLeftX + 5;
        rc.right  = rc.left + 5;
        rc.top    = (displayOffset * GraphHeight) + BarTopYOffset;
        rc.bottom = rc.top + 5;
        InvalidateRect(hwndList, &rc, FALSE);
    }

    ClearStatusArea();
    ResetLBCursorRegion();
    ForceLBRedraw();
}

VOID
TotalRedrawAndRepaint(
    VOID
    )

/*++

Routine Description:

    Invalidate the display and cause all disk bars to be redrawn.

Arguments:

    None

Return Value:

    None

--*/

{
    unsigned i;

    for (i=0; i<DiskCount; i++) {
        DrawDiskBar(Disks[i]);
    }
    ForceLBRedraw();
}


VOID
CompleteMultiRegionOperation(
    VOID
    )

/*++

Routine Description:

    This routine will cause the display to be updated
    after a multi-region action has been completed.

Arguments:

    None

Return Value:

    None

--*/

{
    unsigned i;

    EnableMenuItem(GetMenu(hwndFrame), IDM_CONFIGSAVE, MF_GRAYED);

    for (i=0; i<DiskCount; i++) {
        DeterminePartitioningState(Disks[i]);
    }

    TotalRedrawAndRepaint();
    SetUpMenu(&SingleSel, &SingleSelIndex);
    ClearStatusArea();
    ResetLBCursorRegion();
}

PPERSISTENT_REGION_DATA
DmAllocatePersistentData(
    IN PWSTR VolumeLabel,
    IN PWSTR TypeName,
    IN CHAR  DriveLetter
    )

/*++

Routine Description:

    Allocate a structure to hold persistent region data.  Fill in the volume
    label, type name, and drive letter.  The volume label and type name are
    duplicated.

Arguments:

    VolumeLabel - volume label to be stored in the the persistent data.
        The string will be duplicated first and a pointer to the duplicate
        copy is what is stored in the persistent data.  May be NULL.

    TypeName - name of type of region, ie unformatted, FAT, etc.  May be NULL.

    DriveLetter - drive letter to be stored in persistent data

Return Value:

    pointer to newly allocated persistent data structure.  The structure
    may be freed via DmFreePersistentData(), below.

--*/

{
    PPERSISTENT_REGION_DATA regionData = NULL;
    PWSTR volumeLabel = NULL,
          typeName    = NULL;

    if (VolumeLabel) {
        volumeLabel = Malloc((lstrlenW(VolumeLabel)+1)*sizeof(WCHAR));
        lstrcpyW(volumeLabel,VolumeLabel);
    }

    if (TypeName) {
        typeName = Malloc((lstrlenW(TypeName)+1)*sizeof(WCHAR));
        lstrcpyW(typeName,TypeName);
    }

    regionData = Malloc(sizeof(PERSISTENT_REGION_DATA));
    DmInitPersistentRegionData(regionData, NULL, volumeLabel, typeName, DriveLetter);
    return regionData;
}

VOID
DmFreePersistentData(
    IN OUT PPERSISTENT_REGION_DATA RegionData
    )

/*++

Routine Description:

    Free a persistent data structure and storage used for volume label
    and type name (does not free ft objects).

Arguments:

    RegionData - structure to be freed.

Return Value:

    None.

--*/

{
    if (RegionData->VolumeLabel) {
        Free(RegionData->VolumeLabel);
    }
    if (RegionData->TypeName) {
        Free(RegionData->TypeName);
    }
    Free(RegionData);
}

VOID
DoCreate(
    IN DWORD CreationType       // REGION_EXTENDED or REGION_PRIMARY
    )

/*++

Routine Description:

    This routine creates a new partition.

Arguments:

    CreationType - indicator of partition type (extended or primary).

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
    ULONG              diskNumber = regionDescriptor->Disk;
    MINMAXDLG_PARAMS   dlgParams;
    DWORD              creationSize;
    DWORD              ec;
    PPERSISTENT_REGION_DATA regionData;
    BOOLEAN            isRemovable;
    CHAR               driveLetter;


    FDASSERT(SingleSel);
    FDASSERT(regionDescriptor->SysID == SYSID_UNUSED);

    // WinDisk can only create a single partition on a removable
    // disk--no extended partitions and only one primary.

    isRemovable = IsDiskRemovable[diskNumber];

    if (isRemovable) {

        if (CreationType == REGION_EXTENDED) {

            ErrorDialog(MSG_NO_EXTENDED_ON_REMOVABLE);
            return;
        }

        if (Disks[diskNumber]->ExistAny) {

            ErrorDialog(MSG_ONLY_ONE_PARTITION_ON_REMOVABLE);
            return;
        }
    }

    // Make sure the partition table is not full, and that we are allowed to
    // create the type of partition to be created.

    if (regionDescriptor->RegionType == REGION_PRIMARY) {

        if (!SingleSel->CreatePrimary) {
            ErrorDialog(MSG_PART_TABLE_FULL);
            return;
        }

        if ((CreationType == REGION_EXTENDED) && !SingleSel->CreateExtended) {
            ErrorDialog(MSG_EXTENDED_ALREADY_EXISTS);
            return;
        }
    }

    // If not creating an extended partition, allocate a drive letter.
    // If no drive letter is available, warn the user and allow him to cancel.
    // If the new partition is on a removable disk, use the reserved
    // drive letter for that removable disk.

    if (CreationType != REGION_EXTENDED) {

        CreationType = regionDescriptor->RegionType;      // primary or logical

        if (isRemovable) {

            driveLetter = RemovableDiskReservedDriveLetters[diskNumber];

        } else {

            if (!AssignDriveLetter(TRUE, CreationType == REGION_LOGICAL ? IDS_LOGICALVOLUME : IDS_PARTITION, &driveLetter)) {
                return;
            }
        }
    } else {
        CommitDueToExtended = TRUE;
    }

#if i386
    // if the user is creating a primary partition and there are already
    // primary partitions, warn him that the scheme he will create may
    // not be DOS compatible.

    if ((CreationType == REGION_PRIMARY) && SingleSel->ExistPrimary) {

        if (ConfirmationDialog(MSG_CREATE_NOT_COMPAT, MB_ICONQUESTION | MB_YESNO) != IDYES) {
            return;
        }
    }
#endif

    // now get the size.

    dlgParams.MinSizeMB = FdGetMinimumSizeMB(diskNumber);
    dlgParams.MaxSizeMB = FdGetMaximumSizeMB(regionDescriptor, CreationType);

    switch (CreationType) {
    case REGION_PRIMARY:
        dlgParams.CaptionStringID = IDS_CRTPART_CAPTION_P;
        dlgParams.MinimumStringID = IDS_CRTPART_MIN_P;
        dlgParams.MaximumStringID = IDS_CRTPART_MAX_P;
        dlgParams.SizeStringID    = IDS_CRTPART_SIZE_P;
        dlgParams.HelpContextId   = HC_DM_DLG_CREATEPRIMARY;
        break;

    case REGION_EXTENDED:
        dlgParams.CaptionStringID = IDS_CRTPART_CAPTION_E;
        dlgParams.MinimumStringID = IDS_CRTPART_MIN_P;
        dlgParams.MaximumStringID = IDS_CRTPART_MAX_P;
        dlgParams.SizeStringID    = IDS_CRTPART_SIZE_P;
        dlgParams.HelpContextId   = HC_DM_DLG_CREATEEXTENDED;
        break;

    case REGION_LOGICAL:
        dlgParams.CaptionStringID = IDS_CRTPART_CAPTION_L;
        dlgParams.MinimumStringID = IDS_CRTPART_MIN_L;
        dlgParams.MaximumStringID = IDS_CRTPART_MAX_L;
        dlgParams.SizeStringID    = IDS_CRTPART_SIZE_L;
        dlgParams.HelpContextId   = HC_DM_DLG_CREATELOGICAL;
        break;

    default:
        FDASSERT(FALSE);
    }

    creationSize = DialogBoxParam(hModule,
                                  MAKEINTRESOURCE(IDD_MINMAX),
                                  hwndFrame,
                                  (DLGPROC)MinMaxDlgProc,
                                  (LONG)&dlgParams);

    if (!creationSize) {     // user cancelled
        return;
    }

    // Since the WinDisk can only create one partition on a removable
    // disk, if the user requests a size smaller than the maximum
    // on a removable disk, prompt to confirm:

    if (isRemovable && creationSize != FdGetMaximumSizeMB(regionDescriptor, CreationType)) {

        if (ConfirmationDialog(MSG_REMOVABLE_PARTITION_NOT_FULL_SIZE,MB_ICONQUESTION | MB_YESNO) != IDYES) {
            return;
        }
    }

#if i386

    // See whether the partition will cross over the 1024 cylinder boundary
    // and warn the user if it will.
    //
    // If the extended partition crosses the boundary and the user is creating
    // a logical drive, warn him even though the logical drive itself may not
    // cross the boundary -- he still won't be able to access it.

    {
        DWORD i,
              msgId = (DWORD)(-1);

        if (CreationType == REGION_LOGICAL) {

            PREGION_DESCRIPTOR extReg;

            //
            // Find the extended partition
            //

            for (i=0; i<Disks[diskNumber]->RegionCount; i++) {

                extReg = &Disks[diskNumber]->RegionArray[i];

                if (IsExtended(extReg->SysID)) {
                    break;
                }
                extReg = NULL;
            }

            FDASSERT(extReg);
            if (extReg && FdCrosses1024Cylinder(extReg, 0, REGION_LOGICAL)) {
                msgId = MSG_LOG_1024_CYL;
            }

        } else {
            if (FdCrosses1024Cylinder(regionDescriptor, creationSize, CreationType)) {
                msgId = (CreationType == REGION_PRIMARY) ? MSG_PRI_1024_CYL : MSG_EXT_1024_CYL;
            }
        }

        if ((msgId != (ULONG)(-1)) && (ConfirmationDialog(msgId, MB_ICONQUESTION | MB_YESNO) != IDYES)) {
            return;
        }
    }

#endif

    // If not creating an extended partition, we need to create a new
    // persistent region data structure to associate with the new
    // partition.

    if (CreationType == REGION_EXTENDED) {
        regionData = NULL;
    } else {
        regionData = DmAllocatePersistentData(L"", wszNewUnformatted, driveLetter);
    }

    SetCursor(hcurWait);

    ec = CreatePartition(regionDescriptor,
                         creationSize,
                         CreationType);
    if (ec != NO_ERROR) {
        SetCursor(hcurNormal);
        ErrorDialog(ec);
    }

    DmSetPersistentRegionData(regionDescriptor, regionData);
    if (CreationType != REGION_EXTENDED) {
        if (!isRemovable) {
            MarkDriveLetterUsed(driveLetter);
            CommitToAssignLetterList(regionDescriptor, FALSE);
        }
    }

    // this clears all selections on the disk

    CompleteSingleRegionOperation(SingleSel);
    SetCursor(hcurNormal);
}

VOID
DoDelete(
    VOID
    )

/*++

Routine Description:

    Using the global selection information, delete the partition.

Arguments:

    None

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
    ULONG              diskNumber = regionDescriptor->Disk;
    DWORD              actualIndex = SingleSelIndex;
    DWORD              i,
                       ec;
    PPERSISTENT_REGION_DATA regionData;
    BOOL               deletingExtended;

    FDASSERT(SingleSel);

    // if deleting a free space in the extended partition, then delete the
    // extended partition itself.

    if ((regionDescriptor->RegionType == REGION_LOGICAL) && !SingleSel->ExistLogical) {

        FDASSERT(SingleSel->ExistExtended);

        // find the extended partition

        for (i=0; i<SingleSel->RegionCount; i++) {
            if (IsExtended(SingleSel->RegionArray[i].SysID)) {
                actualIndex = i;
                break;
            }
        }

        deletingExtended = TRUE;
        FDASSERT(actualIndex != SingleSelIndex);

    } else {

        deletingExtended = FALSE;

        // Make sure deletion of this partition is allowed.  It is not allowed
        // if it is the boot partition (or sys partition on x86).

        if ((ec = DeletionIsAllowed(&SingleSel->RegionArray[actualIndex])) != NO_ERROR) {
            ErrorDialog(ec);
            return;
        }
    }

    // If this is a partition that will become the result of a
    // mirror break, insure that the break has occurred.  Otherwise
    // this delete will have bad results.

    regionDescriptor = &SingleSel->RegionArray[actualIndex];
    if (regionDescriptor->Reserved) {
        if (regionDescriptor->Reserved->Partition) {
            if (regionDescriptor->Reserved->Partition->CommitMirrorBreakNeeded) {
                ErrorDialog(MSG_MUST_COMMIT_BREAK);
                return;
            }
        }
    }

    if (!deletingExtended && (ConfirmationDialog(MSG_CONFIRM_DELETE, MB_ICONQUESTION | MB_YESNO) != IDYES)) {
        return;
    }

    // actualIndex is the thing to delete.

    FDASSERT(regionDescriptor->SysID != SYSID_UNUSED);
    regionData = PERSISTENT_DATA(regionDescriptor);

    if (regionData) {

        // Remember drive letter if there is one in order to lock it for delete.

        if (CommitToLockList(regionDescriptor, !IsDiskRemovable[diskNumber], TRUE, FALSE)) {

            // Could not lock exclusively - do not allow delete.

            if (IsPagefileOnDrive(regionData->DriveLetter)) {
                ErrorDialog(MSG_CANNOT_LOCK_PAGEFILE);
                return;
            } else {
                if (CommitToLockList(regionDescriptor, !IsDiskRemovable[diskNumber], TRUE, FALSE)) {
                    FDLOG((1,"DoDelete: Couldn't lock 2 times - popup shown\n"));
                    ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
                    return;
                }
            }
        }
    } else {

        // Deleting an extended partition - enable commit.

        CommitDueToDelete = TRUE;
    }

    SetCursor(hcurWait);

    // Perform the "delete" of internal structures.

    ec = DeletePartition(regionDescriptor);

    if (ec != NO_ERROR) {
        SetCursor(hcurNormal);
        ErrorDialog(ec);
    }

    if (regionData) {

        // Make the letter available for reuse.

        if (!IsDiskRemovable[diskNumber]) {
            MarkDriveLetterFree(regionData->DriveLetter);
        }

        // Free the persistent data associated with the region.

        DmFreePersistentData(regionData);
        DmSetPersistentRegionData(regionDescriptor,NULL);
    }

    // this clears all selections on the disk

    CompleteSingleRegionOperation(SingleSel);
    SetCursor(hcurNormal);
}

#if i386
VOID
DoMakeActive(
    VOID
    )

/*++

Routine Description:

    This routine sets that active partition bit on for the selected partition.
    This code is x86 specific.

Arguments:

    None

Return Value:

    None

--*/

{

    SetCursor(hcurWait);

    FDASSERT(SingleSel);
    FDASSERT(!SingleSel->RegionArray[SingleSelIndex].Active);
    FDASSERT(SingleSel->RegionArray[SingleSelIndex].RegionType == REGION_PRIMARY);
    FDASSERT(SingleSel->RegionArray[SingleSelIndex].SysID != SYSID_UNUSED);

    MakePartitionActive(SingleSel->RegionArray,
                        SingleSel->RegionCount,
                        SingleSelIndex);

    SetCursor(hcurNormal);
    InfoDialog(MSG_DISK0_ACTIVE);
    SetCursor(hcurWait);
    CompleteSingleRegionOperation(SingleSel);
    SetCursor(hcurNormal);
}
#endif

VOID
DoProtectSystemPartition(
    VOID
    )

/*++

Routine Description:

    This function toggles the state of the system partition security:
    if the system partition is secure, it makes it non-secure; if the
    system partition is not secure, it makes it secure.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LONG ec;
    HKEY hkey;
    DWORD value;
    DWORD MessageId;

    SetCursor(hcurWait);
    MessageId = SystemPartitionIsSecure ? MSG_CONFIRM_UNPROTECT_SYSTEM :
                                          MSG_CONFIRM_PROTECT_SYSTEM;

    if (ConfirmationDialog(MessageId, MB_ICONEXCLAMATION | MB_YESNO) != IDYES) {
        return;
    }

    ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                      0,
                      KEY_SET_VALUE,
                      &hkey);

    if (ec != ERROR_SUCCESS) {

        MessageId = SystemPartitionIsSecure ? MSG_CANT_UNPROTECT_SYSTEM :
                                              MSG_CANT_PROTECT_SYSTEM;
        ErrorDialog(MessageId);
        return;
    }

    // If the system partition is currently secure, change it
    // to not secure; if it is not secure, make it secure.

    value = SystemPartitionIsSecure ? 0 : 1;

    ec = RegSetValueEx(hkey,
                       TEXT("Protect System Partition"),
                       0,
                       REG_DWORD,
                       (PBYTE)&value,
                       sizeof(DWORD));
    RegCloseKey(hkey);

    if (ec != ERROR_SUCCESS) {

        MessageId = SystemPartitionIsSecure ? MSG_CANT_UNPROTECT_SYSTEM :
                                              MSG_CANT_PROTECT_SYSTEM;
        ErrorDialog(MessageId);
        return;
    }

    SystemPartitionIsSecure = !SystemPartitionIsSecure;

    SetUpMenu(&SingleSel,&SingleSelIndex);
    RestartRequired = TRUE;
    SetCursor(hcurNormal);
}


VOID
DoEstablishMirror(
    VOID
    )

/*++

Routine Description:

    Using the global selection values, this routine will associate
    freespace with an existing partition in order to construct a
    mirror.

Arguments:

    None

Return Value:

    None

--*/

{
    LARGE_INTEGER      partitionSize,
                       freeSpaceSize;
    DWORD              i,
                       part,
                       free = 0;
    PREGION_DESCRIPTOR regionDescriptor,
                       freeSpace = NULL,
                       existingPartition = NULL;
    PREGION_DESCRIPTOR regionArray[MaxMembersInFtSet];
    UCHAR              newSysID;
    PPERSISTENT_REGION_DATA regionData;
    HMENU              hMenu = GetMenu(hwndFrame);

    FDASSERT(SelectionCount == 2);

    // Make sure that the mirror pair does not include any
    // partitions on removable media.

    for (i=0; i<SelectionCount; i++) {

        if (IsDiskRemovable[SELECTED_REGION(i).Disk]) {

            ErrorDialog(MSG_NO_REMOVABLE_IN_MIRROR);
            return;
        }
    }

    for (i=0; i<2; i++) {
        regionDescriptor = &SELECTED_REGION(i);
        if (regionDescriptor->SysID == SYSID_UNUSED) {
            free = i;
            freeSpace = regionDescriptor;
        } else {
            part = i;
            existingPartition = regionDescriptor;
        }
    }

    FDASSERT((freeSpace != NULL) && (existingPartition != NULL));

    // Make sure that we are allowed to create a partition in the free space.

    if (!(    ((freeSpace->RegionType == REGION_LOGICAL) && SelectedDS[free]->CreateLogical)
           || ((freeSpace->RegionType == REGION_PRIMARY) && SelectedDS[free]->CreatePrimary))) {
        ErrorDialog(MSG_CRTSTRP_FULL);
        return;
    }

    // Make sure that the free space is large enough to hold a mirror of
    // the existing partition.  Do this by getting the EXACT size of
    // the existing partition and the free space.

    partitionSize = FdGetExactSize(existingPartition, FALSE);
    freeSpaceSize = FdGetExactSize(freeSpace, FALSE);

    if (freeSpaceSize.QuadPart < partitionSize.QuadPart) {
        ErrorDialog(MSG_CRTMIRROR_BADFREE);
        return;
    }

    if (BootDiskNumber != (ULONG)-1) {

        // If the disk number and original partition number of this
        // region match the recorded disk number and partition number
        // of the boot partition warn the user about mirroring the boot
        // drive.

        if (existingPartition->Disk == BootDiskNumber &&
            existingPartition->OriginalPartitionNumber == BootPartitionNumber) {

            WarningDialog(MSG_MIRROR_OF_BOOT);

            // Set up to write the boot code to the MBR of the mirror.

            UpdateMbrOnDisk = freeSpace->Disk;
        }
    }

    SetCursor(hcurWait);
    regionData = DmAllocatePersistentData(PERSISTENT_DATA(existingPartition)->VolumeLabel,
                                          PERSISTENT_DATA(existingPartition)->TypeName,
                                          PERSISTENT_DATA(existingPartition)->DriveLetter);

    // Finally, create the new partition.

    newSysID = (UCHAR)(existingPartition->SysID | (UCHAR)SYSID_FT);
    CreatePartitionEx(freeSpace,
                      partitionSize,
                      0,
                      freeSpace->RegionType,
                      newSysID);
    DmSetPersistentRegionData(freeSpace, regionData);

    // Set the partition type of the existing partition.

    SetSysID2(existingPartition, newSysID);
    regionArray[0] = existingPartition;
    regionArray[1] = freeSpace;

    FdftCreateFtObjectSet(Mirror,
                          regionArray,
                          2,
                          FtSetNewNeedsInitialization);

    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
    CommitDueToMirror = TRUE;
    EnableMenuItem(hMenu,
                   IDM_COMMIT,
                   MF_ENABLED);
}

VOID
DoBreakMirror(
    VOID
    )

/*++

Routine Description:

    Using the global selection variables, this routine will break
    the mirror relationship and modify their region descriptors to
    describe two non-ft partitions giving either the primary member
    of the mirror the drive letter for the mirror, or the only healthy
    member of the mirror the drive letter.  The remaining "new" partition
    will receive the next available drive letter.

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD              i;
    PFT_OBJECT_SET     ftSet;
    PFT_OBJECT         ftObject0,
                       ftObject1;
    PREGION_DESCRIPTOR regionDescriptor;
    PPERSISTENT_REGION_DATA regionData;
    ULONG              newDriveLetterRegion;
    CHAR               driveLetter;
    HMENU              hMenu = GetMenu(hwndFrame);

    FDASSERT((SelectionCount) == 1 || (SelectionCount == 2));

    ftObject0 = GET_FT_OBJECT(&SELECTED_REGION(0));
    if (SelectionCount == 2) {
        ftObject1 = GET_FT_OBJECT(&SELECTED_REGION(1));
    } else {
        ftObject1 = NULL;
    }
    ftSet = ftObject0->Set;

    // Determine if the action is allowed.

    switch (ftSet->Status) {

    case FtSetInitializing:
    case FtSetRegenerating:

        ErrorDialog(MSG_CANT_BREAK_INITIALIZING_SET);
        return;
        break;

    default:
        break;
    }

    if (ConfirmationDialog(MSG_CONFIRM_BRK_MIRROR,MB_ICONQUESTION | MB_YESNO) != IDYES) {
        return;
    }

    SetCursor(hcurWait);

    // Figure out which region gets the new drive letter.  A complication is
    // that selection 0 is not necessarily member 0.
    //
    // If there is only one selection, then only one part of the mirror set
    // is present -- no new drive letters are assigned.
    // Otherwise, if one of the members is orphaned, it gets the new
    // drive letter.  Else the secondary member gets the new drive letter.

    if (SelectionCount == 2) {

        if (ftObject0->State == Orphaned) {

            newDriveLetterRegion = 0;
        } else {

            if (ftObject1->State == Orphaned) {

                newDriveLetterRegion = 1;
            } else {

                // Neither member is orphaned;  determine which is
                // member 0 and give the other one the new drive letter.

                if (ftObject0->MemberIndex) {    // secondary member ?

                    newDriveLetterRegion = 0;
                } else {

                    newDriveLetterRegion = 1;
                }
            }
        }
    } else {

        // The one remaining member could be the shadow.
        // The drive letter must move to locate this partition

        regionDescriptor = &SELECTED_REGION(0);
        regionData = PERSISTENT_DATA(regionDescriptor);
        if (!regionData->FtObject->MemberIndex) {

            // The shadow has become the valid partition.
            // move the current letter there.

            CommitToAssignLetterList(regionDescriptor, TRUE);
        }
        newDriveLetterRegion = (ULONG)(-1);
    }

    // if newDriveLetterRegion is -1 this will still work and
    // select the 0 selected region.

    if (CommitToLockList(&SELECTED_REGION(newDriveLetterRegion ? 0 : 1), FALSE, TRUE, FALSE)) {
        if (ConfirmationDialog(MSG_CONFIRM_SHUTDOWN_FOR_MIRROR, MB_ICONQUESTION | MB_YESNO) != IDYES) {
            return;
        }
        RestartRequired = TRUE;
    }

    if (newDriveLetterRegion != (ULONG)(-1)) {
        if (AssignDriveLetter(FALSE, 0, &driveLetter)) {

            // Got a valid drive letter

            MarkDriveLetterUsed(driveLetter);
        } else {

            // didn't get a letter.  Instead the magic value
            // for no drive letter assigned has been returned

        }

        regionDescriptor = &SELECTED_REGION(newDriveLetterRegion);
        regionData = PERSISTENT_DATA(regionDescriptor);
        regionData->DriveLetter = driveLetter;
        CommitToAssignLetterList(regionDescriptor, FALSE);
        if (!regionData->FtObject->MemberIndex) {

            // The shadow has become the valid partition.
            // move the current letter there.

            CommitToAssignLetterList(&SELECTED_REGION(newDriveLetterRegion ? 0 : 1), TRUE);
        }

    } else {
        regionDescriptor = &SELECTED_REGION(0);
        regionData = PERSISTENT_DATA(regionDescriptor);
        if (regionData->FtObject->MemberIndex) {

            // The shadow is all that is left.

            CommitToAssignLetterList(regionDescriptor, TRUE);
        }
    }

    FdftDeleteFtObjectSet(ftSet, FALSE);

    for (i=0; i<SelectionCount; i++) {

        regionDescriptor = &SELECTED_REGION(i);
        if (regionDescriptor->Reserved) {
            if (regionDescriptor->Reserved->Partition) {
                regionDescriptor->Reserved->Partition->CommitMirrorBreakNeeded = TRUE;
            }
        }
        SET_FT_OBJECT(regionDescriptor, 0);
        SetSysID2(regionDescriptor, (UCHAR)(regionDescriptor->SysID & ~VALID_NTFT));
    }

    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
    CommitDueToMirror = TRUE;
    EnableMenuItem(hMenu,
                   IDM_COMMIT,
                   MF_ENABLED);
}

VOID
DoBreakAndDeleteMirror(
    VOID
    )

/*++

Routine Description:

    This routine will delete the mirror relationship information
    and the member partitions of the mirror.

Arguments:

    None

Return Value:

    None

--*/

{
    PFT_OBJECT_SET      ftSet;
    DWORD               i;
    PREGION_DESCRIPTOR  regionDescriptor;
    CHAR                driveLetter = '\0';

    FDASSERT( SelectionCount == 1 || SelectionCount == 2 );

    // Attempt to lock this before continuing.

    regionDescriptor = &SELECTED_REGION(0);
    if (CommitToLockList(regionDescriptor, TRUE, TRUE, FALSE)) {

        // Could not lock the volume - do not allow delete.

        ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
        return;
    }

    ftSet = (GET_FT_OBJECT(regionDescriptor))->Set;

    // Determine if the action is allowed.

    switch (ftSet->Status) {

    case FtSetInitializing:
    case FtSetRegenerating:

        ErrorDialog(MSG_CANT_DELETE_INITIALIZING_SET);
        return;
        break;

    default:
        break;
    }

    if (ConfirmationDialog(MSG_CONFIRM_BRKANDDEL_MIRROR, MB_ICONQUESTION | MB_YESNO) != IDYES) {
        return;
    }

    SetCursor(hcurWait);
    FdftDeleteFtObjectSet(ftSet, FALSE);
    for (i = 0; i < SelectionCount; i++) {

        regionDescriptor = &SELECTED_REGION(i);

        if (i) {
            FDASSERT(PERSISTENT_DATA(regionDescriptor)->DriveLetter == driveLetter);
        } else {
            driveLetter = PERSISTENT_DATA(regionDescriptor)->DriveLetter;
        }

        // Free the pieces of the set.

        DmFreePersistentData(PERSISTENT_DATA(regionDescriptor));
        DmSetPersistentRegionData(regionDescriptor, NULL);
        DeletePartition(regionDescriptor);
    }

    MarkDriveLetterFree(driveLetter);

    // Remember drive letter if there is one in order to lock it for delete.

    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}

VOID
DoCreateStripe(
    IN BOOL Parity
    )

/*++

Routine Description:

    This routine starts the dialog with the user to determine
    the parameters of the creation of a stripe or stripe set
    with parity.  Based on the user response it creates the
    internal structures necessary for the creation of a stripe
    or stripe set with parity.

    The regions involved in the stripe creation are located via
    the global parameters for multiple selections.

Arguments:

    Parity - boolean to indicate the presence of parity in the stripe.

Return Value

    None

--*/

{
    MINMAXDLG_PARAMS params;
    DWORD            smallestSize = (DWORD)(-1);
    DWORD            creationSize;
    unsigned         i;
    PREGION_DESCRIPTOR regionDescriptor,
                       regionArray[MaxMembersInFtSet];
    PPERSISTENT_REGION_DATA regionData;
    CHAR             DriveLetter;


    // Make sure that the volume set does not include any
    // partitions on removable media.

    for (i=0; i<SelectionCount; i++) {

        if (IsDiskRemovable[SELECTED_REGION(i).Disk]) {

            ErrorDialog(MSG_NO_REMOVABLE_IN_STRIPE);
            return;
        }
    }

    // Scan the disks to determine the maximum size, which is
    // the size of the smallest partition times the number of
    // partitions.

    for (i=0; i<SelectionCount; i++) {
        FDASSERT(SELECTED_REGION(i).SysID == SYSID_UNUSED);
        if (SELECTED_REGION(i).SizeMB < smallestSize) {
            smallestSize = SELECTED_REGION(i).SizeMB;
        }
    }

    // Figure out a drive letter.

    if (!AssignDriveLetter(TRUE, IDS_STRIPESET, &DriveLetter)) {
        return;
    }

    params.CaptionStringID = Parity ? IDS_CRTPSTRP_CAPTION : IDS_CRTSTRP_CAPTION;
    params.MinimumStringID = IDS_CRTSTRP_MIN;
    params.MaximumStringID = IDS_CRTSTRP_MAX;
    params.SizeStringID    = IDS_CRTSTRP_SIZE;
    params.MinSizeMB       = SelectionCount;
    params.MaxSizeMB       = smallestSize * SelectionCount;
    if (Parity) {
        params.HelpContextId   = HC_DM_DLG_CREATEPARITYSTRIPE;
    } else {
        params.HelpContextId   = HC_DM_DLG_CREATESTRIPESET;
    }

    creationSize = DialogBoxParam(hModule,
                                  MAKEINTRESOURCE(IDD_MINMAX),
                                  hwndFrame,
                                  (DLGPROC)MinMaxDlgProc,
                                  (LONG)&params);

    if (!creationSize) {     // user cancelled
        return;
    }

    // Determine how large we have to make each member of the stripe set.

    creationSize = (creationSize / SelectionCount);
    FDASSERT(creationSize <= smallestSize);
    if (creationSize % SelectionCount) {
        creationSize++;                             // round up.
    }

    SetCursor(hcurWait);

    // Make sure we are allowed to create all the partitions

    for (i=0; i<SelectionCount; i++) {
        regionDescriptor = &SELECTED_REGION(i);
        FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

        if (!(    ((regionDescriptor->RegionType == REGION_LOGICAL) && SelectedDS[i]->CreateLogical)
               || ((regionDescriptor->RegionType == REGION_PRIMARY) && SelectedDS[i]->CreatePrimary))) {
            SetCursor(hcurNormal);
            ErrorDialog(MSG_CRTSTRP_FULL);
            return;
        }

    }

    // Now actually perform the creation.

    for (i=0; i<SelectionCount; i++) {

        regionDescriptor = &SELECTED_REGION(i);

        CreatePartitionEx(regionDescriptor,
                          RtlConvertLongToLargeInteger(0L),
                          creationSize,
                          regionDescriptor->RegionType,
                          (UCHAR)(SYSID_BIGFAT | SYSID_FT));

        // Finish setting up the FT set

        regionData = DmAllocatePersistentData(L"", wszNewUnformatted, DriveLetter);
        DmSetPersistentRegionData(regionDescriptor, regionData);
        regionArray[i] = regionDescriptor;
    }

    // The zeroth element is the one to assign the drive letter to.

    CommitToAssignLetterList(&SELECTED_REGION(0), FALSE);

    FdftCreateFtObjectSet(Parity ? StripeWithParity : Stripe,
                          regionArray,
                          SelectionCount,
                          Parity ? FtSetNewNeedsInitialization : FtSetNew);
    MarkDriveLetterUsed(DriveLetter);
    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}


VOID
DoDeleteStripeOrVolumeSet(
    IN DWORD ConfirmationMsg
    )

/*++

Routine Description:

    Common code for the deletion of a stripe or volume set.
    This routine will display a message giving the user a 2nd
    chance to change their mind, then based on the answer perform
    the work of deleting the item.  This consists of removing
    the region descriptors (and related information) from the
    collection of Disk structures.

Arguments:

    ConfirmationMsg - text for comfirming what is being deleted.

Return Value:

    None

--*/

{
    DWORD              i;
    PFT_OBJECT_SET     ftSet;
    PFT_OBJECT         ftObject;
    PREGION_DESCRIPTOR regionDescriptor;
    FT_SET_STATUS      setState;
    ULONG              numberOfMembers;
    CHAR               driveLetter = '\0';
    BOOL               setIsHealthy = TRUE;

    regionDescriptor = &SELECTED_REGION(0);

    // Determine if the action is allowed.

    ftObject = GET_FT_OBJECT(regionDescriptor);
    ftSet = ftObject->Set;

    LowFtVolumeStatus(regionDescriptor->Disk,
                      regionDescriptor->PartitionNumber,
                      &setState,
                      &numberOfMembers);

    if (ftSet->Status != setState) {
        ftSet->Status = setState;
    }

    switch (ftSet->Status) {
    case FtSetDisabled:
        setIsHealthy = FALSE;
        break;

    case FtSetInitializing:
    case FtSetRegenerating:

        ErrorDialog(MSG_CANT_DELETE_INITIALIZING_SET);
        return;
        break;

    default:
        break;
    }

    // Attempt to lock this before continuing.

    if (CommitToLockList(regionDescriptor, TRUE, setIsHealthy, TRUE)) {

        // Could not lock the volume - try again, the file systems appear
        // to be confused.

        if (CommitToLockList(regionDescriptor, TRUE, setIsHealthy, TRUE)) {

            // Don't allow the delete.

            ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
            return;
        }
    }

    if (ConfirmationDialog(ConfirmationMsg,MB_ICONQUESTION | MB_YESNO) != IDYES) {
        return;
    }

    // Delete all partitions that are part of the stripe set

    SetCursor(hcurWait);
    FdftDeleteFtObjectSet(ftSet,FALSE);

    for (i=0; i<SelectionCount; i++) {
        ULONG diskNumber;

        regionDescriptor = &SELECTED_REGION(i);

        if (i) {
            FDASSERT(PERSISTENT_DATA(regionDescriptor)->DriveLetter == driveLetter);
        } else {
            driveLetter = PERSISTENT_DATA(regionDescriptor)->DriveLetter;
        }

        diskNumber = regionDescriptor->Disk;
        DmFreePersistentData(PERSISTENT_DATA(regionDescriptor));
        DmSetPersistentRegionData(regionDescriptor, NULL);
        DeletePartition(regionDescriptor);
    }

    // Mark the drive letter that was being used by the stripe or volume
    // set free.

    MarkDriveLetterFree(driveLetter);

    // Remember drive letter if there is one in order to lock it for delete.

    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}


VOID
DoDeleteStripe(
    VOID
    )

/*++

Routine Description:

    Routine is called to delete a stripe.  It calls a general
    routine for stripe and volume set deletion.

Arguments:

    None

Return Value:

    None

--*/

{
    DoDeleteStripeOrVolumeSet(MSG_CONFIRM_DEL_STRP);
}


VOID
DoCreateVolumeSet(
    VOID
    )

/*++

Routine Description:

    This routine uses the global selection information to collect
    a group of freespace regions on the disks and organize them into
    a volume set.

Arguments:

    None

Return Value:

    None

--*/

{
    MINMAXDLG_PARAMS params;
    DWORD            creationSize,
                     size,
                     maxTotalSize=0,
                     totalSizeUsed;
    DWORD            sizes[MaxMembersInFtSet];
    PULONG           primarySpacesToUseOnDisk;
    CHAR             driveLetter;
    unsigned         i;
    PREGION_DESCRIPTOR regionDescriptor,
                       regionArray[MaxMembersInFtSet];
    PPERSISTENT_REGION_DATA regionData;

    // Make sure that the volume set does not include any
    // partitions on removable media.

    for (i=0; i<SelectionCount; i++) {

        if (IsDiskRemovable[SELECTED_REGION(i).Disk]) {

            ErrorDialog(MSG_NO_REMOVABLE_IN_VOLUMESET);
            return;
        }
    }

    for (i=0; i<SelectionCount; i++) {
        FDASSERT(SELECTED_REGION(i).SysID == SYSID_UNUSED);
        size = SELECTED_REGION(i).SizeMB;
        sizes[i] = size;
        maxTotalSize += size;
    }

    // Figure out a drive letter.

    if (!AssignDriveLetter(TRUE, IDS_VOLUMESET, &driveLetter)) {
        return;
    }

    params.CaptionStringID = IDS_CRTVSET_CAPTION;
    params.MinimumStringID = IDS_CRTVSET_MIN;
    params.MaximumStringID = IDS_CRTVSET_MAX;
    params.SizeStringID    = IDS_CRTVSET_SIZE;
    params.MinSizeMB       = SelectionCount;
    params.MaxSizeMB       = maxTotalSize;
    params.HelpContextId   = HC_DM_DLG_CREATEVOLUMESET;

    creationSize = DialogBoxParam(hModule,
                                  MAKEINTRESOURCE(IDD_MINMAX),
                                  hwndFrame,
                                  (DLGPROC)MinMaxDlgProc,
                                  (LONG)&params);

    if (!creationSize) {     // user cancelled
        return;
    }

    // Determine how large we have to make each member of the volume set.
    // The percentage of each free space that will be used is the ratio
    // of the total space he chose to the total free space.
    //
    // Example: 2 75 meg free spaces for a total set size of 150 MB.
    //          User chooses a set size of 100 MB.  Use 50 MB of each space.

    totalSizeUsed = 0;

    for (i=0; i<SelectionCount; i++) {
        sizes[i] = sizes[i] * creationSize / maxTotalSize;
        if ((sizes[i] * creationSize) % maxTotalSize) {
            sizes[i]++;
        }

        if (sizes[i] == 0) {
            sizes[i]++;
        }

        totalSizeUsed += sizes[i];
    }

    // Make sure that the total amount used is not greater than the
    // maximum amount available.  Note that this loop is certain
    // to terminate because maxTotalSize >= SelectionCount; if
    // each of the sizes goes down to one, we will exit the loop

    while (totalSizeUsed > maxTotalSize) {

        for (i=0; (i<SelectionCount) && (totalSizeUsed > maxTotalSize); i++) {

             if (sizes[i] > 1) {

                sizes[i]--;
                totalSizeUsed--;
            }
        }
    }

    SetCursor(hcurWait);

    // Make sure that we are allowed to create a partition in the space.
    // This is tricky because a volume set could contain more than one
    // primary partition on a disk -- which means that if we're not careful
    // we could create a disk with more than 4 primary partitions!

    primarySpacesToUseOnDisk = Malloc(DiskCount * sizeof(ULONG));
    RtlZeroMemory(primarySpacesToUseOnDisk, DiskCount * sizeof(ULONG));

    for (i=0; i<SelectionCount; i++) {
        regionDescriptor = &SELECTED_REGION(i);
        FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

        if (regionDescriptor->RegionType == REGION_PRIMARY) {
            primarySpacesToUseOnDisk[SelectedDS[i]->Disk]++;
        }

        if (!(    ((regionDescriptor->RegionType == REGION_LOGICAL) && SelectedDS[i]->CreateLogical)
               || ((regionDescriptor->RegionType == REGION_PRIMARY) && SelectedDS[i]->CreatePrimary)))
        {
            SetCursor(hcurNormal);
            Free(primarySpacesToUseOnDisk);
            ErrorDialog(MSG_CRTSTRP_FULL);
            return;
        }
    }

    // Look through the array we built to see whether we are supposed to use
    // more than one primary partition on a given disk.  For each such disk,
    // make sure that we can actually create that many primary partitions.

    for (i=0; i<DiskCount; i++) {

        // If there are not enough primary partition slots, fail.

        if ((primarySpacesToUseOnDisk[i] > 1)
        &&  (4 - PartitionCount(i) < primarySpacesToUseOnDisk[i]))
        {
            SetCursor(hcurNormal);
            Free(primarySpacesToUseOnDisk);
            ErrorDialog(MSG_CRTSTRP_FULL);
            return;
        }
    }

    Free(primarySpacesToUseOnDisk);

    // Now actually perform the creation.

    for (i=0; i<SelectionCount; i++) {

        regionDescriptor = &SELECTED_REGION(i);
        FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

        CreatePartitionEx(regionDescriptor,
                          RtlConvertLongToLargeInteger(0L),
                          sizes[i],
                          regionDescriptor->RegionType,
                          (UCHAR)(SYSID_BIGFAT | SYSID_FT));

        regionData = DmAllocatePersistentData(L"", wszNewUnformatted, driveLetter);
        DmSetPersistentRegionData(regionDescriptor, regionData);
        regionArray[i] = regionDescriptor;
    }

    // The zeroth element is the one to assign the drive letter to.

    FdftCreateFtObjectSet(VolumeSet, regionArray, SelectionCount, FtSetNew);
    MarkDriveLetterUsed(driveLetter);
    CommitToAssignLetterList(&SELECTED_REGION(0), FALSE);
    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}


VOID
DoExtendVolumeSet(
    VOID
    )

/*++

Routine Description:

    This routine uses the global selection item information to
    add additional freespace to an existing volume set or partition.

Arguments:

    None

Return Value:

    None

--*/

{
    MINMAXDLG_PARAMS    params;
    DWORD               currentSize = 0,
                        freeSize = 0,
                        maxTotalSize = 0,
                        newSize = 0,
                        totalFreeSpaceUsed,
                        freeSpaceUsed,
                        Size;
    DWORD               Sizes[MaxMembersInFtSet];
    ULONG               nonFtPartitions = 0,
                        numberOfFreeRegions = 0;
    PULONG              primarySpacesToUseOnDisk;
    WCHAR               driveLetter = L' ';
    PWSTR               typeName = NULL,
                        volumeLabel = NULL;
    PREGION_DESCRIPTOR  regionDescriptor;
    PREGION_DESCRIPTOR  newRegions[MaxMembersInFtSet];
    PREGION_DESCRIPTOR  convertedRegion;
    PFT_OBJECT_SET      ftSet = NULL;
    PPERSISTENT_REGION_DATA regionData;
    unsigned            i;
    DWORD               ec;


    // Make sure that the volume set does not include any
    // partitions on removable media.

    for (i=0; i<SelectionCount; i++) {

        if (IsDiskRemovable[SELECTED_REGION(i).Disk]) {

            ErrorDialog(MSG_NO_REMOVABLE_IN_VOLUMESET);
            return;
        }
    }


    // First, determine the current size of the volume set,
    // it's file system type and associated drive letter,
    // and the size of the selected free space

    for (i = 0; i < SelectionCount; i++) {

        regionDescriptor = &(SELECTED_REGION(i));

        Size = regionDescriptor->SizeMB;
        Sizes[i] = Size;
        maxTotalSize += Size;

        if (regionDescriptor->SysID == SYSID_UNUSED) {

            // This region is a chunk of free space; include it
            // in the free space tallies.

            newRegions[numberOfFreeRegions] = regionDescriptor;
            Sizes[numberOfFreeRegions] = Size;

            numberOfFreeRegions++;
            freeSize += Size;

        } else if (GET_FT_OBJECT(regionDescriptor)) {

            // This is an element of an existing volume set.

            currentSize += Size;

            if ( ftSet == NULL ) {

                DetermineRegionInfo(regionDescriptor,
                                    &typeName,
                                    &volumeLabel,
                                    &driveLetter);
                ftSet = GET_FT_OBJECT(regionDescriptor)->Set;
            }

        } else {

            // This is a non-FT partition.

            nonFtPartitions++;
            DetermineRegionInfo(regionDescriptor,
                                &typeName,
                                &volumeLabel,
                                &driveLetter);
            currentSize = Size;
            convertedRegion = regionDescriptor;
        }
    }

    // Check for consistency: the selection must have either a volume
    // set or a partition, but not both, and cannot have more than
    // one non-FT partition.

    if (nonFtPartitions > 1 ||
        (ftSet != NULL && nonFtPartitions != 0) ||
        (ftSet == NULL && nonFtPartitions == 0)) {

        return;
    }


    if (nonFtPartitions != 0 &&
        (ec = DeletionIsAllowed(convertedRegion)) != NO_ERROR) {

        // If the error-message is delete-specific, remap it.
        //
        switch( ec ) {
#if i386
        case MSG_CANT_DELETE_ACTIVE0:   ec = MSG_CANT_EXTEND_ACTIVE0;
                                        break;
#endif
        case MSG_CANT_DELETE_WINNT:     ec = MSG_CANT_EXTEND_WINNT;
                                        break;
        default:                        break;
        }

        ErrorDialog(ec);
        return;
    }

    if (wcscmp(typeName, L"NTFS") != 0) {

        ErrorDialog(MSG_EXTEND_VOLSET_MUST_BE_NTFS);
        return;
    }


    params.CaptionStringID = IDS_EXPVSET_CAPTION;
    params.MinimumStringID = IDS_CRTVSET_MIN;
    params.MaximumStringID = IDS_CRTVSET_MAX;
    params.SizeStringID    = IDS_CRTVSET_SIZE;
    params.MinSizeMB       = currentSize + numberOfFreeRegions;
    params.MaxSizeMB       = maxTotalSize;
    params.HelpContextId   = HC_DM_DLG_EXTENDVOLUMESET;

    newSize = DialogBoxParam(hModule,
                             MAKEINTRESOURCE(IDD_MINMAX),
                             hwndFrame,
                             (DLGPROC)MinMaxDlgProc,
                             (LONG)&params);

    if (!newSize) {     // user cancelled
        return;
    }

    // Determine how large to make each new member of the volume
    // set.  The percentage of free space to use is the ratio of
    // the amount by which the volume set will grow to the total
    // free space.

    freeSpaceUsed = newSize - currentSize;
    totalFreeSpaceUsed = 0;

    for ( i = 0; i < numberOfFreeRegions; i++ ) {

        Sizes[i] = Sizes[i] * freeSpaceUsed / freeSize;
        if ((Sizes[i] * freeSpaceUsed) % freeSize) {
            Sizes[i]++;
        }

        if (Sizes[i] == 0) {
            Sizes[i]++;
        }

        totalFreeSpaceUsed += Sizes[i];
    }

    // Make sure that the total amount of free space used is not
    // greater than the amount available.  Note that this loop is
    // certain to terminate because the amount of free space used
    // is >= the number of free regions, so this loop will exit
    // if one megabyte is used in each free region (the degenerate
    // case).

    while (totalFreeSpaceUsed > freeSize) {

        for (i = 0;
             (i < numberOfFreeRegions) && (totalFreeSpaceUsed > freeSize);
             i++) {

            if ( Sizes[i] > 1 ) {

                Sizes[i]--;
                totalFreeSpaceUsed--;
            }
        }
    }

    SetCursor(hcurWait);

    // Make sure that we are allowed to create a partition in the space.
    //
    // This is tricky because a volume set could contain more than one
    // primary partition on a disk -- which means that if we're not careful
    // we could create a disk with more than 4 primary partitions!

    primarySpacesToUseOnDisk = Malloc(DiskCount * sizeof(ULONG));
    RtlZeroMemory(primarySpacesToUseOnDisk, DiskCount * sizeof(ULONG));

    for (i=0; i<SelectionCount; i++) {
        regionDescriptor = &SELECTED_REGION(i);

        if (regionDescriptor->SysID == SYSID_UNUSED) {

            FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

            if (regionDescriptor->RegionType == REGION_PRIMARY) {
                primarySpacesToUseOnDisk[SelectedDS[i]->Disk]++;
            }

            if (!(   ((regionDescriptor->RegionType == REGION_LOGICAL) && SelectedDS[i]->CreateLogical)
                  || ((regionDescriptor->RegionType == REGION_PRIMARY) && SelectedDS[i]->CreatePrimary))) {
                SetCursor(hcurNormal);
                Free(primarySpacesToUseOnDisk);
                ErrorDialog(MSG_CRTSTRP_FULL);
                return;
            }
        }
    }

    // Look through the array we built to see whether we are supposed to use
    // more than one primary partition on a given disk.  For each such disk,
    // make sure that we can actually create that many primary partitions.

    for (i=0; i<DiskCount; i++) {

        // If there are not enough primary partition slots, fail.

        if ((primarySpacesToUseOnDisk[i] > 1)
             && (4 - PartitionCount(i) < primarySpacesToUseOnDisk[i])) {
            SetCursor(hcurNormal);
            Free(primarySpacesToUseOnDisk);
            ErrorDialog(MSG_CRTSTRP_FULL);
            return;
        }
    }

    // Now actually perform the creation.

    for (i=0; i<numberOfFreeRegions; i++) {

        regionDescriptor = newRegions[i];
        FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

        CreatePartitionEx(regionDescriptor,
                          RtlConvertLongToLargeInteger(0L),
                          Sizes[i],
                          regionDescriptor->RegionType,
                          (UCHAR)(SYSID_IFS | SYSID_FT));
        regionData = DmAllocatePersistentData(volumeLabel, typeName, (CHAR)driveLetter);
        DmSetPersistentRegionData(regionDescriptor, regionData);
    }

    if (nonFtPartitions != 0) {

        // Create the volume set so we can extend it

        FdftCreateFtObjectSet(VolumeSet, &convertedRegion, 1, FtSetExtended);
        ftSet = GET_FT_OBJECT(convertedRegion)->Set;

        // Set the converted region's partition System Id to indicate
        // that it is now part of a volume set.

        SetSysID2(convertedRegion, (UCHAR)(convertedRegion->SysID | SYSID_FT));
    }

    FdftExtendFtObjectSet(ftSet, newRegions, numberOfFreeRegions);
    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}

VOID
DoDeleteVolumeSet(
    VOID
    )

/*++

Routine Description:

    Routine is called to delete a volume set.  It calls a general
    routine for stripe and volume set deletion.

Arguments:

    None

Return Value:

    None

--*/

{
    DoDeleteStripeOrVolumeSet(MSG_CONFIRM_DEL_VSET);
}

extern ULONG OrdinalToAllocate[];

VOID
DoRecoverStripe(
    VOID
    )

/*++

Routine Description:

    Using the global selection information this routine will
    set up a stripe with parity such that a problem member is
    regenerated.  This new member may either be the problem member
    (i.e. regeneration is "in place") or new free space on a
    different disk.

Arguments:

    None

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR freeSpace = NULL;
    PREGION_DESCRIPTOR unhealthy = NULL;
    ULONG              freeSpaceI = 0;
    ULONG              i;
    PREGION_DESCRIPTOR regionArray[MaxMembersInFtSet];
    LARGE_INTEGER      minimumSize;
    PFT_OBJECT         ftObject;

    // Initialize minimumSize to the maximum possible positive value

    minimumSize.HighPart = 0x7FFFFFFF;
    minimumSize.LowPart = 0xFFFFFFFF;

    if ((!IsRegionCommitted(&SELECTED_REGION(0))) &&
        (!IsRegionCommitted(&SELECTED_REGION(1)))) {
        ErrorDialog(MSG_NOT_COMMITTED);
        return;
    }

    FDASSERT(SelectionCount > 1);
    FDASSERT(SelectionCount <= MaxMembersInFtSet);

    SetCursor(hcurWait);

    // Determine the exact size of the smallest member of the stripe set.
    // If the user is regenerating using an additional free space, this
    // will be the size requirement for the free space.
    // Also find the free space (if any).
    // If there is no free space, then we're doing an 'in-place' recover
    // (ie regnerating into the unhealthy member).  If there is a free space,
    // make sure we are allowed to create a partition or logical drive in it.

    for (i=0; i<SelectionCount; i++) {

        regionArray[i] = &SELECTED_REGION(i);

        FDASSERT(!IsExtended(regionArray[i]->SysID));

        if (regionArray[i]->SysID == SYSID_UNUSED) {

            PDISKSTATE ds;

            FDASSERT(freeSpace == NULL);

            freeSpace  = regionArray[i];
            freeSpaceI = i;

            // Make sure we are allowed to create a partition or logical
            // drive in the selected free space.

            ds = SelectedDS[freeSpaceI];

            if (!(  ((freeSpace->RegionType == REGION_LOGICAL) && ds->CreateLogical)
                 || ((freeSpace->RegionType == REGION_PRIMARY) && ds->CreatePrimary))) {
                SetCursor(hcurNormal);
                ErrorDialog(MSG_CRTSTRP_FULL);
                return;
            }
        } else {

            LARGE_INTEGER largeTemp;

            largeTemp = FdGetExactSize(regionArray[i], FALSE);
            if (largeTemp.QuadPart < minimumSize.QuadPart) {
                minimumSize = largeTemp;
            }

            if (GET_FT_OBJECT(regionArray[i])->State != Healthy) {
                FDASSERT(unhealthy == NULL);
                unhealthy = regionArray[i];
            }
        }
    }

    // If there is a free space, place it at item 0 of the regionArray
    // to simplify processing later.

    if (freeSpace) {
        PREGION_DESCRIPTOR tempRegion = regionArray[0];

        regionArray[0] = regionArray[freeSpaceI];
        regionArray[freeSpaceI] = tempRegion;
        i = 1;
    } else {
        i = 0;
    }

    // Get a pointer to the FT object for the broken member.  Can't do this
    // in the loop above because the broken member might be on an off-line
    // disk.

    for (ftObject=GET_FT_OBJECT(regionArray[i])->Set->Members; ftObject; ftObject = ftObject->Next) {
        if (ftObject->State != Healthy) {
            break;
        }
    }
    FDASSERT(ftObject);

    // Determine if the action is allowed.

    if (ftObject->Set) {
        switch (ftObject->Set->Status) {

        case FtSetInitializing:
        case FtSetRegenerating:

            ErrorDialog(MSG_CANT_REGEN_INITIALIZING_SET);
            return;
            break;

        default:
            break;
        }
    }

    // Must lock the volume to perform this operation.

    if (CommitToLockList(regionArray[i], FALSE, TRUE, FALSE)) {

        // Could not lock the volume - try again, the file systems appear
        // to be confused.

        if (CommitToLockList(regionArray[i], FALSE, TRUE, FALSE)) {

            // Don't allow the delete.

            ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
            return;
        }
    }

    if (freeSpace) {

        LARGE_INTEGER           temp;
        PPERSISTENT_REGION_DATA regionData,
                                regionDataTemp;

        // Make sure the free space region is large enough.

        temp = FdGetExactSize(freeSpace, FALSE);
        if (temp.QuadPart < minimumSize.QuadPart) {
            SetCursor(hcurNormal);
            ErrorDialog(MSG_NOT_LARGE_ENOUGH_FOR_STRIPE);
            return;
        }

        // Create the new partition.

        CreatePartitionEx(freeSpace,
                          minimumSize,
                          0,
                          freeSpace->RegionType,
                          regionArray[1]->SysID);

        // Set up the new partition's persistent data

        regionDataTemp = PERSISTENT_DATA(regionArray[1]);
        regionData = DmAllocatePersistentData(regionDataTemp->VolumeLabel,
                                              regionDataTemp->TypeName,
                                              regionDataTemp->DriveLetter);
        regionData->FtObject = ftObject;
        DmSetPersistentRegionData(freeSpace, regionData);

        // Check to see if member zero of the set changed and
        // the drive letter needs to move.

        if (!ftObject->MemberIndex) {

            // This is member zero.  Move the drive letter to the
            // new region descriptor.

            CommitToAssignLetterList(freeSpace, TRUE);
        }

        // If the unhealthy member is on-line, delete it.
        // Otherwise remove it from the off-line disk.

        if (unhealthy) {
            DmFreePersistentData(PERSISTENT_DATA(unhealthy));
            DmSetPersistentRegionData(unhealthy, NULL);
            DeletePartition(unhealthy);
        }

        // Remove any offline disks - this doesn't really
        // delete the set.

        FdftDeleteFtObjectSet(ftObject->Set, TRUE);
    }

    ftObject->Set->Ordinal = FdftNextOrdinal(StripeWithParity);
    ftObject->State = Regenerating;
    ftObject->Set->Status = FtSetRecovered;
    RegistryChanged = TRUE;
    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}

VOID
AdjustOptionsMenu(
    VOID
    )

/*++

Routine Description:

    This routine updates the options menu (i.e. maintains
    the state of the menu items for whether the status bar
    or legend are displayed).

Arguments:

    None

Return Value:

    None

--*/

{
    RECT  rc;

    CheckMenuItem(GetMenu(hwndFrame),
                  IDM_OPTIONSSTATUS,
                  MF_BYCOMMAND | (StatusBar ? MF_CHECKED : MF_UNCHECKED));
    CheckMenuItem(GetMenu(hwndFrame),
                  IDM_OPTIONSLEGEND,
                  MF_BYCOMMAND | (Legend ? MF_CHECKED : MF_UNCHECKED));
    GetClientRect(hwndFrame, &rc);
    SendMessage(hwndFrame, WM_SIZE, SIZENORMAL, MAKELONG(rc.right, rc.bottom));
    InvalidateRect(hwndFrame, NULL, TRUE);
}

VOID
FrameCommandHandler(
    IN HWND  hwnd,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    This routine handles WM_COMMAND messages for the frame window.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD   i,
            pos;
    DWORD   HelpFlag;
    POINT   point;

    switch (LOWORD(wParam)) {

    case IDM_PARTITIONCREATE:

        DoCreate(REGION_PRIMARY);
        break;

    case IDM_PARTITIONCREATEEX:

        DoCreate(REGION_EXTENDED);
        break;

    case IDM_PARTITIONDELETE:

        switch (FtSelectionType) {

        case Mirror:

            DoBreakAndDeleteMirror();
            break;

        case Stripe:
        case StripeWithParity:
            DoDeleteStripe();
            break;

        case VolumeSet:
            DoDeleteVolumeSet();
            break;

        default:
            DoDelete();
            break;
        }

        break;

#if i386

    case IDM_PARTITIONACTIVE:

        DoMakeActive();
        break;
#endif

    case IDM_SECURESYSTEM:

        DoProtectSystemPartition();
        break;

    case IDM_PARTITIONLETTER:
    {
        int driveLetterIn,
            driveLetterOut;
        PREGION_DESCRIPTOR      regionDescriptor;
        PPERSISTENT_REGION_DATA regionData;
        PFT_OBJECT              ftObject;
        ULONG                   index;

        regionDescriptor = &SELECTED_REGION(0);
        FDASSERT(regionDescriptor);
        regionData = PERSISTENT_DATA(regionDescriptor);
        FDASSERT(regionData);

        if (ftObject = regionData->FtObject) {

            // Must find the zero member of this set for the
            // drive letter assignment.  Search all of the selected
            // regions

            index = 0;
            while (ftObject->MemberIndex) {

                // search the next selected item if there is one

                index++;
                if (index >= SelectionCount) {
                    ftObject = NULL;
                    break;
                }
                regionDescriptor = &SELECTED_REGION(index);
                FDASSERT(regionDescriptor);
                regionData = PERSISTENT_DATA(regionDescriptor);
                FDASSERT(regionData);
                ftObject = regionData->FtObject;

                // must have an FtObject to continue

                if (!ftObject) {
                    break;
                }
            }

            if (!ftObject) {

                // This is really an internal error.
            }

            // regionDescriptor locates the zero element now.
        }
        driveLetterIn = (int)(UCHAR)regionData->DriveLetter;

        if (IsDiskRemovable[regionDescriptor->Disk]) {
            ErrorDialog(MSG_CANT_ASSIGN_LETTER_TO_REMOVABLE);
        } else if (AllDriveLettersAreUsed() && ((driveLetterIn == NO_DRIVE_LETTER_YET) || (driveLetterIn == NO_DRIVE_LETTER_EVER))) {
            ErrorDialog(MSG_ALL_DRIVE_LETTERS_USED);
        } else {
            driveLetterOut = DialogBoxParam(hModule,
                                            MAKEINTRESOURCE(IDD_DRIVELET),
                                            hwndFrame,
                                            (DLGPROC)DriveLetterDlgProc,
                                            (LONG)regionDescriptor);
            if (driveLetterOut) {
                LETTER_ASSIGNMENT_RESULT result;

                if ((driveLetterIn == NO_DRIVE_LETTER_YET) || (driveLetterIn == NO_DRIVE_LETTER_EVER)) {

                    // Must insure that driveLetterIn maps to same things
                    // as is returned by the dialog when the user selects
                    // no letter.

                    driveLetterIn = NO_DRIVE_LETTER_EVER;
                }
                if (driveLetterOut != driveLetterIn) {
                    if (result = CommitDriveLetter(regionDescriptor, (CHAR) driveLetterIn, (CHAR)driveLetterOut)) {

                        // The following would be more rigorously correct:
                        // if non-ft, just set regionData->DriveLetter.  If
                        // ft, scan all regions on all disks for members of
                        // ft set and set their drive letter fields.
                        //
                        // The below is probably correct, though.

                        for (i=0; i<SelectionCount; i++) {
                            PERSISTENT_DATA(&SELECTED_REGION(i))->DriveLetter = (CHAR)driveLetterOut;
                        }

                        // Don't allow the letter that is actually in use
                        // and will only change on a reboot to cycle back
                        // into the free list.

                        if (result != MustReboot) {

                            // Mark old letter free, new one used.

                            MarkDriveLetterFree((CHAR)driveLetterIn);
                        }
                        MarkDriveLetterUsed((CHAR)driveLetterOut);

                        // force status area and all disk bars to be redrawn

                        if (SelectionCount > 1) {
                            CompleteMultiRegionOperation();
                        } else {
                            CompleteSingleRegionOperation(SingleSel);
                        }
                        EnableMenuItem(GetMenu(hwndFrame), IDM_CONFIGSAVE, MF_GRAYED);
                    }
                }
            }
        }
        break;
    }

    case IDM_PARTITIONFORMAT: {
        PREGION_DESCRIPTOR regionDescriptor;

        regionDescriptor = &SELECTED_REGION(0);
        FDASSERT(regionDescriptor);
        FormatPartition(regionDescriptor);
        break;
    }

    case IDM_PARTITIONLABEL: {
        PREGION_DESCRIPTOR regionDescriptor;

        regionDescriptor = &SELECTED_REGION(0);
        FDASSERT(regionDescriptor);
        LabelPartition(regionDescriptor);
        break;
    }

    case IDM_PARTITIONEXIT:

        SendMessage(hwndFrame,WM_CLOSE,0,0);
        break;

    case IDM_CONFIGMIGRATE:

        if (DoMigratePreviousFtConfig()) {

            // Determine if the FT driver must be enabled.

            SetCursor(hcurWait);
            Sleep(2000);
            if (DiskRegistryRequiresFt() == TRUE) {
                DiskRegistryEnableFt();
            } else {
                DiskRegistryDisableFt();
            }

            // wait four seconds before shutdown

            Sleep(4000);
            SetCursor(hcurNormal);
            FdShutdownTheSystem();
        }
        break;

    case IDM_CONFIGSAVE:

        DoSaveFtConfig();
        break;

    case IDM_CONFIGRESTORE:

        if (DoRestoreFtConfig()) {

            // Determine if the FT driver must be enabled.

            if (DiskRegistryRequiresFt() == TRUE) {
                DiskRegistryEnableFt();
            } else {
                DiskRegistryDisableFt();
            }

            // wait five seconds before shutdown

            SetCursor(hcurWait);
            Sleep(5000);
            SetCursor(hcurNormal);
            FdShutdownTheSystem();
        }
        break;

    case IDM_FTESTABLISHMIRROR:

        DoEstablishMirror();
        break;

    case IDM_FTBREAKMIRROR:

        DoBreakMirror();
        break;

    case IDM_FTCREATESTRIPE:

        DoCreateStripe(FALSE);
        break;

    case IDM_FTCREATEPSTRIPE:

        DoCreateStripe(TRUE);
        break;

    case IDM_FTCREATEVOLUMESET:

        DoCreateVolumeSet();
        break;

    case IDM_FTEXTENDVOLUMESET:

        DoExtendVolumeSet();
        break;

    case IDM_FTRECOVERSTRIPE:

        DoRecoverStripe();
        break;

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
    case IDM_DBLSPACE:
        DblSpace(hwndFrame, NULL);
        break;

    case IDM_AUTOMOUNT:  {
        HMENU hMenu;

        if (DoubleSpaceAutomount) {
            DoubleSpaceAutomount = FALSE;
        } else {
            DoubleSpaceAutomount = TRUE;
        }
        DiskRegistryDblSpaceRemovable(DoubleSpaceAutomount);
        hMenu = GetMenu(hwndFrame);
        CheckMenuItem(hMenu,
                      IDM_AUTOMOUNT,
                      (DoubleSpaceAutomount) ? MF_CHECKED : MF_UNCHECKED);
        break;
    }
#endif

    case IDM_CDROM:
        CdRom(hwndFrame, NULL);
        break;

    case IDM_COMMIT:
        CommitAllChanges(NULL);
        EnableMenuItem(GetMenu(hwndFrame), IDM_CONFIGSAVE, MF_ENABLED);
        break;

    case IDM_OPTIONSSTATUS:

        StatusBar = !StatusBar;
        AdjustOptionsMenu();
        break;

    case IDM_OPTIONSLEGEND:

        Legend = !Legend;
        AdjustOptionsMenu();
        break;

    case IDM_OPTIONSCOLORS:

        switch(DialogBox(hModule, MAKEINTRESOURCE(IDD_COLORS), hwnd, (DLGPROC)ColorDlgProc)) {
        case IDOK:
            for (i=0; i<BRUSH_ARRAY_SIZE; i++) {
                DeleteObject(Brushes[i]);
                Brushes[i] = CreateHatchBrush(AvailableHatches[BrushHatches[i] = SelectedHatch[i]],
                                              AvailableColors[BrushColors[i] = SelectedColor[i]]);
            }
            SetCursor(hcurWait);
            TotalRedrawAndRepaint();
            if (Legend) {
                InvalidateRect(hwndFrame, NULL, FALSE);
            }
            SetCursor(hcurNormal);
            break;

        case IDCANCEL:
            break;

        case -1:
            ErrorDialog(ERROR_NOT_ENOUGH_MEMORY);
            break;

        default:
            FDASSERT(0);
        }
        break;

    case IDM_OPTIONSDISPLAY: {

        PBAR_TYPE newBarTypes = Malloc(DiskCount * sizeof(BAR_TYPE));

        for (i=0; i<DiskCount; i++) {
            newBarTypes[i] = Disks[i]->BarType;
        }

        switch (DialogBoxParam(hModule,
                               MAKEINTRESOURCE(IDD_DISPLAYOPTIONS),
                               hwnd,
                               (DLGPROC)DisplayOptionsDlgProc,
                               (DWORD)newBarTypes)) {
        case IDOK:
            SetCursor(hcurWait);
            for (i=0; i<DiskCount; i++) {
                Disks[i]->BarType = newBarTypes[i];
            }
            TotalRedrawAndRepaint();
            SetCursor(hcurNormal);
            break;

        case IDCANCEL:
            break;

        default:
            FDASSERT(0);
        }

        Free(newBarTypes);
        break;
    }

    case IDM_HELPCONTENTS:
    case IDM_HELP:

        HelpFlag = HELP_INDEX;
        goto CallWinHelp;
        break;

    case IDM_HELPSEARCH:

        HelpFlag = HELP_PARTIALKEY;
        goto CallWinHelp;
        break;

    case IDM_HELPHELP:

        HelpFlag = HELP_HELPONHELP;
        goto CallWinHelp;
        break;

    case IDM_HELPABOUT: {
        TCHAR title[100];

        LoadString(hModule, IDS_APPNAME, title, sizeof(title)/sizeof(TCHAR));
        ShellAbout(hwndFrame, title, NULL, (HICON)GetClassLong(hwndFrame, GCL_HICON));
        break;
    }

#if DBG && DEVL

    case IDM_DEBUGALLOWDELETES:

        AllowAllDeletes = !AllowAllDeletes;
        CheckMenuItem(GetMenu(hwndFrame),
                      IDM_DEBUGALLOWDELETES,
                      AllowAllDeletes ? MF_CHECKED : MF_UNCHECKED);
        break;

#endif

    case ID_LISTBOX:

        switch (HIWORD(wParam)) {
        case LBN_SELCHANGE:
            point.x = LOWORD(pos = GetMessagePos());
            point.y = HIWORD(pos);
            MouseSelection(GetKeyState(VK_CONTROL) & ~1,     // strip toggle bit
                           &point);
            return;
        default:
            DefWindowProc(hwnd, WM_COMMAND, wParam, lParam);
            return;
        }
        break;

    default:

        DefWindowProc(hwnd, WM_COMMAND, wParam, lParam);
    }
    return;

CallWinHelp:

    if (!WinHelp(hwndFrame, HelpFile, HelpFlag, (LONG)"")) {
        WarningDialog(MSG_HELP_ERROR);
    }
}

DWORD
DeletionIsAllowed(
    IN PREGION_DESCRIPTOR Region
    )

/*++

Routine Description:

    This routine makes sure deletion of the partition is allowed.  We do not
    allow the user to delete the Windows NT boot partition or the active
    partition on disk 0 (x86 only).

    Note that this routine is also used to determine whether an existing
    single-partition volume can be extended into a volume set, since the
    criteria are the same.

Arguments:

    Region - points to region descriptor for the region which the user would
        like to delete.

Return Value:

    NO_ERROR if deletion is allowed;  error number for message to display
    if not.

--*/

{
    ULONG                   ec;
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(Region);

    FDASSERT(!IsExtended(Region->SysID));       // can't be extended partition
    FDASSERT(Region->SysID != SYSID_UNUSED);    // can't be free space

#if DBG && DEVL
    if (AllowAllDeletes) {
        return NO_ERROR;
    }
#endif

    // if this is not an original region, deletion is allowed.

    if (!Region->OriginalPartitionNumber) {
        return NO_ERROR;
    }

    // if there is no persistent data for this region, allow deletion.

    if (regionData == NULL) {
        return NO_ERROR;
    }

    ec = NO_ERROR;

    // Determine the Windows NT drive by determining the windows directory
    // and pulling out the first letter.

    if (BootDiskNumber != (ULONG)-1) {

        // If the disk number and original partition number of this
        // region match the recorded disk number and partition number
        // of the boot partition, don't allow deletion.

        if (Region->Disk == BootDiskNumber &&
            Region->OriginalPartitionNumber == BootPartitionNumber) {

            ec = MSG_CANT_DELETE_WINNT;
        }
    }

#if i386
    if (ec == NO_ERROR) {
        if (!Region->Disk && Region->Active) {
            ec = MSG_CANT_DELETE_ACTIVE0;
        }
    }
#endif

    return ec;
}


BOOLEAN
BootPartitionNumberChanged(
    PULONG OldNumber,
    PULONG NewNumber
    )

/*++

Routine Description

    This function determines whether the partition number of
    the boot partition has changed during this invocation of
    Windisk.  With dynamic partitioning enabled, the work of
    this routine increases.  This routine must guess what the
    partition numbers will be when the system is rebooted to
    determine if the partition number for the boot partition
    has changed.  It does this via the following algorithm:

    1. Count all primary partitions - These get numbers first
       starting from 1.

    2. Count all logical drives - These get numbers second starting
       from the count of primary partitions plus 1.

    The partition numbers located in the region structures cannot
    be assumed to be valid.  This work must be done from the
    region array located in the disk state structure for the
    disk.

Arguments:

    None.

Return Value:

    TRUE if the boot partition's partition number has changed.

--*/

{
    PDISKSTATE         bootDisk;
    PREGION_DESCRIPTOR regionDescriptor,
                       bootDescriptor = NULL;
    ULONG              i,
                       partitionNumber = 0;

    if (BootDiskNumber == (ULONG)(-1) || BootDiskNumber > DiskCount) {

        // Can't tell--assume it hasn't.

        return FALSE;
    }

    if (!ChangeCommittedOnDisk(BootDiskNumber)) {

        // disk wasn't changed - no possibility for a problem.

        return FALSE;
    }

    bootDisk = Disks[BootDiskNumber];

    // Find the region descriptor for the boot partition

    for (i = 0; i < bootDisk->RegionCount; i++) {
        regionDescriptor = &bootDisk->RegionArray[i];
        if (regionDescriptor->OriginalPartitionNumber == BootPartitionNumber) {
           bootDescriptor = regionDescriptor;
           break;
        }
    }

    if (!bootDescriptor) {

        // Can't find boot partition - assume no change

        return FALSE;
    }

    // No go through the region descriptors and count the partition
    // numbers as they will be counted during system boot.
    //
    // If the boot region is located determine if the partition
    // number changed.

    for (i = 0; i < bootDisk->RegionCount; i++) {

        regionDescriptor = &bootDisk->RegionArray[i];
        if ((regionDescriptor->RegionType == REGION_PRIMARY) &&
            (!IsExtended(regionDescriptor->SysID) &&
            (regionDescriptor->SysID != SYSID_UNUSED))) {
            partitionNumber++;
            if (regionDescriptor == bootDescriptor) {
                if (partitionNumber != regionDescriptor->OriginalPartitionNumber) {
                    *OldNumber = regionDescriptor->OriginalPartitionNumber;
                    *NewNumber = partitionNumber;
                    return TRUE;
                } else {

                    // Numbers match, no problem.

                    return FALSE;
                }
            }
        }
    }

    // Check the logical drives as well.

    for (i = 0; i < bootDisk->RegionCount; i++) {
        regionDescriptor = &bootDisk->RegionArray[i];

        if (regionDescriptor->RegionType == REGION_LOGICAL) {
            partitionNumber++;
            if (regionDescriptor == bootDescriptor) {
                if (partitionNumber != regionDescriptor->OriginalPartitionNumber) {
                    *OldNumber = regionDescriptor->OriginalPartitionNumber;
                    *NewNumber = partitionNumber;
                    return TRUE;
                } else {
                    return FALSE;
                }
            }
        }
    }

    return FALSE;
}

DWORD
CommitChanges(
    VOID
    )

/*++

Routine Description:

    This routine updates the disks to reflect changes made by the user
    the partitioning scheme, or to stamp signatures on disks.

    If the partitioning scheme on a disk has changed at all, a check will
    first be made for a valid signature on the mbr in sector 0.  If the
    signature is not valid, x86 boot code will be written to the sector.

Arguments:

    None.

Return Value:

    Windows error code.

--*/

{
    unsigned i;
    DWORD    ec,
             rc = NO_ERROR;

    for (i=0; i<DiskCount; i++) {

        if (HavePartitionsBeenChanged(i)) {
            ec = MasterBootCode(i, 0, TRUE, FALSE);

            // MasterBootCode has already translated the NT error
            // status into a Windows error status.

            if (rc == NO_ERROR) {
                rc = ec;            // save first non-success return code
            }
            ec = CommitPartitionChanges(i);

            // CommitPartitionChanges returns a native NT error, it
            // must be translated before it can be saved.

            if (ec != NO_ERROR) {
                ec = RtlNtStatusToDosError(ec);
            }
            if (rc == NO_ERROR) {   // save first non-success return code
                rc = ec;
            }
        }
    }
    if (rc != NO_ERROR) {

        // If CommitPartitionChanges returns an error, it will be
        // an NT status, which needs to be converted to a DOS status.

        if (rc == ERROR_MR_MID_NOT_FOUND) {
            ErrorDialog(MSG_ERROR_DURING_COMMIT);
        } else {
            ErrorDialog(rc);
        }
    }

    return rc;
}

BOOL
AssignDriveLetter(
    IN  BOOL  WarnIfNoLetter,
    IN  DWORD StringId,
    OUT PCHAR DriveLetter
    )

/*++

Routine Description:

    Determine the next available drive letter.  If no drive letters are
    available, optionally warn the user and allow him to cancel the
    operation.

Arguments:

    WarnIfNoLetter - whether to warn the user if no drive letters are
        available and allow him to cancel the operation.

    StringId - resource containing the name of the object being created
        that will need a drive letter (ie, partition, logical drive, stripe
        set, volume set).

    DriveLetter - receives the drive letter to assign, or NO_DRIVE_LETTER_YET
        if no more left.

Return Value:

    If there were no more drive letters, returns TRUE if the user wants
        to create anyway, FALSE if he canceled.  If there were drive letters
        available, the return value is undefined.

--*/

{
    CHAR driveLetter;
    TCHAR name[256];

    driveLetter = GetAvailableDriveLetter();
    if (WarnIfNoLetter && !driveLetter) {
        LoadString(hModule, StringId, name, sizeof(name)/sizeof(TCHAR));
        if (ConfirmationDialog(MSG_NO_AVAIL_LETTER, MB_ICONQUESTION | MB_YESNO, name) != IDYES) {
            return FALSE;
        }
    }
    if (!driveLetter) {
        driveLetter = NO_DRIVE_LETTER_YET;
    }
    *DriveLetter = driveLetter;
    return TRUE;
}

VOID
DeterminePartitioningState(
    IN OUT PDISKSTATE DiskState
    )

/*++

Routine Description:

    This routine determines the disk's partitioning state (ie, what types
    of partitions exist and may be created), filling out a DISKSTATE
    structure with the info.   It also allocates the array for the
    left/right position pairs for each region's on-screen square.

Arguments:

    DiskState - the CreateXXX and ExistXXX fields will be filled in for the
                disk in the Disk field

Return Value:

    None.

--*/

{
    DWORD i;

    // If there's an existing region array there, free it.

    if (DiskState->RegionArray) {
        FreeRegionArray(DiskState->RegionArray, DiskState->RegionCount);
    }

    // get the region array for the disk in question

    GetAllDiskRegions(DiskState->Disk,
                      &DiskState->RegionArray,
                      &DiskState->RegionCount);

    // Allocate the array for the left/right coords for the graph.
    // This may overallocate by one square (for extended partition).

    DiskState->LeftRight = Realloc(DiskState->LeftRight,
                                   DiskState->RegionCount * sizeof(LEFTRIGHT));
    DiskState->Selected  = Realloc(DiskState->Selected,
                                   DiskState->RegionCount * sizeof(BOOLEAN));

    for (i=0; i<DiskState->RegionCount; i++) {
        DiskState->Selected[i] = FALSE;
    }

    // figure out whether various creations are allowed

    IsAnyCreationAllowed(DiskState->Disk,
                         TRUE,
                         &DiskState->CreateAny,
                         &DiskState->CreatePrimary,
                         &DiskState->CreateExtended,
                         &DiskState->CreateLogical);

    // figure out whether various partition types exist

    DoesAnyPartitionExist(DiskState->Disk,
                          &DiskState->ExistAny,
                          &DiskState->ExistPrimary,
                          &DiskState->ExistExtended,
                          &DiskState->ExistLogical);
}

VOID
DrawDiskBar(
    IN PDISKSTATE DiskState
    )

/*++

Routine Description:

    This routine will draw the disk bar into the window.

Arguments:

    DiskState - current disk to draw.

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR   regionDescriptor;
    PDISKSTATE           diskState;
    LONGLONG temp1,
             temp2;
    HDC      hDCMem = DiskState->hDCMem;
    DWORD    leftAdjust = BarLeftX,
             xDiskText,
             cx = 0,
             brushIndex = 0;
    HPEN     hpenT;
    char     text[100],
             textBold[5];
    TCHAR    uniText[100],
             uniTextBold[5],
             mbBuffer[16];
    RECT     rc;
    HFONT    hfontT;
    COLORREF previousColor;
    HBRUSH   hbr;
    BOOL     isFree,
             isLogical;
    HDC      hdcTemp;
    HBITMAP  hbmOld;
    PWSTR    typeName,
             volumeLabel;
    WCHAR    driveLetter;
    BAR_TYPE barType;
    ULONG    diskSize,
             largestDiskSize;
    unsigned i;

    // If this is a removable.  Update to whatever its current
    // information may be.

    if (IsDiskRemovable[DiskState->Disk]) {
        PPERSISTENT_REGION_DATA regionData;

        // Update the information on this disk.

        regionDescriptor = &DiskState->RegionArray[0];
        regionData = PERSISTENT_DATA(regionDescriptor);

        if (GetVolumeTypeAndSize(DiskState->Disk,
                                 regionDescriptor->PartitionNumber,
                                 &volumeLabel,
                                 &typeName,
                                 &diskSize)) {

            // Update the values for the removable.

            if (regionData) {

                // Always want RAW file systems to display as "Unknown"

                if (!lstrcmpiW(typeName, L"raw")) {
                     Free(typeName);
                     typeName = Malloc((wcslen(wszUnknown) * sizeof(WCHAR)) + sizeof(WCHAR));
                     lstrcpyW(typeName, wszUnknown);
                }
                if (regionData->VolumeLabel) {
                    Free(regionData->VolumeLabel);
                }
                regionData->VolumeLabel = volumeLabel;
                if (regionData->TypeName) {
                    Free(regionData->TypeName);
                }
                regionData->TypeName = typeName;
            }

            DiskState->DiskSizeMB = diskSize;
        }
    }

    // figure out largest disk's size

    for (largestDiskSize = i = 0, diskState = Disks[0];
         i < DiskCount;
         diskState = Disks[++i]) {

        if (diskState->DiskSizeMB > largestDiskSize) {
            largestDiskSize = diskState->DiskSizeMB;
        }
    }

    // erase the graph background

    rc.left = rc.top = 0;
    rc.right = GraphWidth + 1;
    rc.bottom = GraphHeight + 1;
    FillRect(hDCMem, &rc, GetStockObject(LTGRAY_BRUSH));

    hpenT = SelectObject(hDCMem,hPenThinSolid);

    // Draw the disk info area: small disk bitmap, some text, and a
    // line across the top.
    //
    // First draw the bitmap.

    hdcTemp = CreateCompatibleDC(hDCMem);
    if (IsDiskRemovable[DiskState->Disk]) {
        hbmOld = SelectObject(hdcTemp, hBitmapRemovableDisk);
        BitBlt(hDCMem,
               xRemovableDisk,
               yRemovableDisk,
               dxRemovableDisk,
               dyRemovableDisk,
               hdcTemp,
               0,
               0,
               SRCCOPY);
    } else {
        hbmOld = SelectObject(hdcTemp, hBitmapSmallDisk);
        BitBlt(hDCMem,
               xSmallDisk,
               ySmallDisk,
               dxSmallDisk,
               dySmallDisk,
               hdcTemp,
               0,
               0,
               SRCCOPY);
    }

    if (hbmOld) {
        SelectObject(hdcTemp, hbmOld);
    }
    DeleteDC(hdcTemp);

    // Now draw the line.

    if (IsDiskRemovable[DiskState->Disk]) {
        MoveToEx(hDCMem, xRemovableDisk, BarTopYOffset, NULL);
        LineTo(hDCMem, BarLeftX - xRemovableDisk, BarTopYOffset);
        xDiskText = 2 * dxRemovableDisk;
    } else {
        MoveToEx(hDCMem, xSmallDisk, BarTopYOffset, NULL);
        LineTo(hDCMem, BarLeftX - xSmallDisk, BarTopYOffset);
        xDiskText = 2 * dxSmallDisk;
    }

    // Now draw the text.

    hfontT = SelectObject(hDCMem, hFontGraphBold);
    SetTextColor(hDCMem, RGB(0, 0, 0));
    SetBkColor(hDCMem, RGB(192, 192, 192));
    wsprintf(uniText, DiskN, DiskState->Disk);
    TextOut(hDCMem,
            xDiskText,
            BarTopYOffset + dyBarTextLine,
            uniText,
            lstrlen(uniText));

    SelectObject(hDCMem, hFontGraph);
    if (DiskState->OffLine) {
        LoadString(hModule, IDS_OFFLINE, uniText, sizeof(uniText)/sizeof(TCHAR));
    } else {
        LoadString(hModule, IDS_MEGABYTES_ABBREV, mbBuffer, sizeof(mbBuffer)/sizeof(TCHAR));
        wsprintf(uniText, TEXT("%u %s"), DiskState->DiskSizeMB, mbBuffer);
    }

    TextOut(hDCMem,
            xDiskText,
            BarTopYOffset + (4*dyBarTextLine),
            uniText,
            lstrlen(uniText));

    if (DiskState->OffLine) {

        SelectObject(hDCMem, GetStockObject(LTGRAY_BRUSH));
        Rectangle(hDCMem,
                  BarLeftX,
                  BarTopYOffset,
                  BarLeftX + BarWidth,
                  BarBottomYOffset);
        LoadString(hModule, IDS_NO_CONFIG_INFO, uniText, sizeof(uniText)/sizeof(TCHAR));
        TextOut(hDCMem,
                BarLeftX + dxBarTextMargin,
                BarTopYOffset + (4*dyBarTextLine),
                uniText,
                lstrlen(uniText));
    } else {

        // Account for extreme differences in largest to smallest disk
        // by insuring that a disk is always 1/4 the size of the
        // largest disk.

        diskSize = DiskState->DiskSizeMB;
        if (diskSize < largestDiskSize / 4) {
            diskSize = largestDiskSize / 4;
        }
#if 0
        // manage the horizontal size of the list box in order
        // to get a scroll bar.  Perhaps this only needs to be done
        // once.  BUGBUG:  This will cause a horizontal scroll bar
        // that works correctly, but the region selection code is
        // not prepared for this, so selection of regions doesn't
        // operate correctly.

        largestExtent = (WPARAM)(BarWidth + BarLeftX + 2);
        SendMessage(hwndList, LB_SETHORIZONTALEXTENT, largestExtent, 0);
#endif
        // If user wants WinDisk to decide which type of view to use, do that
        // here.  We'll use a proportional view unless any single region would
        // have a width less than the size of a drive letter.

        if ((barType = DiskState->BarType) == BarAuto) {
            ULONG regionSize;

            barType = BarProportional;

            for (i=0; i<DiskState->RegionCount; i++) {

                regionDescriptor = &DiskState->RegionArray[i];

                if (IsExtended(regionDescriptor->SysID)) {
                    continue;
                }

                temp1 = UInt32x32To64(BarWidth, diskSize);
                temp1 *= regionDescriptor->SizeMB;
                temp2 = UInt32x32To64(largestDiskSize, DiskState->DiskSizeMB);
                regionSize = (ULONG) (temp1 / temp2);

                if (regionSize < 12*SELECTION_THICKNESS) {
                    barType = BarEqual;
                    break;
                }
            }
        }

        if (barType == BarEqual) {

            temp1 = UInt32x32To64(BarWidth, diskSize);
            temp2 = UInt32x32To64((DiskState->RegionCount -
                       (DiskState->ExistExtended ? 1 : 0)), largestDiskSize);
            cx = (ULONG) (temp1 / temp2);
        }

        for (i=0; i<DiskState->RegionCount; i++) {
            PFT_OBJECT ftObject = NULL;

            regionDescriptor = &DiskState->RegionArray[i];
            if (!IsExtended(regionDescriptor->SysID)) {

                if (barType == BarProportional) {

                    temp1 = UInt32x32To64(BarWidth, diskSize);
                    temp1 *= regionDescriptor->SizeMB;
                    temp2 = UInt32x32To64(largestDiskSize, DiskState->DiskSizeMB);
                    cx = (ULONG) (temp1 / temp2);
                }

                isFree = (regionDescriptor->SysID == SYSID_UNUSED);
                isLogical = (regionDescriptor->RegionType == REGION_LOGICAL);

                if (!isFree) {

                    // If we've got a mirror or stripe set, use special colors.

                    ftObject = GET_FT_OBJECT(regionDescriptor);
                    switch(ftObject ? ftObject->Set->Type : -1) {
                    case Mirror:
                        brushIndex = BRUSH_MIRROR;
                        break;
                    case Stripe:
                    case StripeWithParity:
                        brushIndex = BRUSH_STRIPESET;
                        break;
                    case VolumeSet:
                        brushIndex = BRUSH_VOLUMESET;
                        break;
                    default:
                        brushIndex = isLogical ? BRUSH_USEDLOGICAL : BRUSH_USEDPRIMARY;
                    }       // end the switch
                }

                previousColor = SetBkColor(hDCMem, RGB(255, 255, 255));
                SetBkMode(hDCMem, OPAQUE);

                if (isFree) {

                    // Free space -- cross hatch the whole block.

                    hbr = SelectObject(hDCMem,isLogical ? hBrushFreeLogical : hBrushFreePrimary);
                    Rectangle(hDCMem,
                              leftAdjust,
                              BarTopYOffset,
                              leftAdjust + cx,
                              BarBottomYOffset);
                } else {

                    // Used space -- make most of the block white except for
                    // a small strip at the top, which gets an identifying color.
                    // If the partition is not recognized, leave it all white.

                    hbr = SelectObject(hDCMem, GetStockObject(WHITE_BRUSH));
                    Rectangle(hDCMem, leftAdjust, BarTopYOffset, leftAdjust + cx, BarBottomYOffset);

                    if (IsRecognizedPartition(regionDescriptor->SysID)) {
                        SelectObject(hDCMem, Brushes[brushIndex]);
                        Rectangle(hDCMem,
                                  leftAdjust,
                                  BarTopYOffset,
                                  leftAdjust + cx,
                                  BarTopYOffset + (4 * dyBarTextLine / 5) + 1);
                    }
                }

                if (hbr) {
                    SelectObject(hDCMem, hbr);
                }

                DiskState->LeftRight[i].Left  = leftAdjust;
                DiskState->LeftRight[i].Right = leftAdjust + cx - 1;

                // Figure out the type name (ie, unformatted, fat, etc) and
                // volume label.

                typeName = NULL;
                volumeLabel = NULL;
                DetermineRegionInfo(regionDescriptor, &typeName, &volumeLabel, &driveLetter);
                LoadString(hModule, IDS_MEGABYTES_ABBREV, mbBuffer, sizeof(mbBuffer)/sizeof(TCHAR));

                if (!typeName) {
                    typeName = wszUnknown;
                }
                if (!volumeLabel) {
                    volumeLabel = L"";
                }
                wsprintf(text,
                         "\n%ws\n%ws\n%u %s",
                         volumeLabel,
                         typeName,
                         regionDescriptor->SizeMB,
                         mbBuffer);

                *textBold = 0;
                if (driveLetter != L' ') {
                    wsprintf(textBold, "%wc:", driveLetter);
                }

                UnicodeHack(text, uniText);
                UnicodeHack(textBold, uniTextBold);

                // output the text

                rc.left   = leftAdjust + dxBarTextMargin;
                rc.right  = leftAdjust + cx - dxBarTextMargin;
                rc.top    = BarTopYOffset + dyBarTextLine;
                rc.bottom = BarBottomYOffset;

                SetBkMode(hDCMem, TRANSPARENT);
                SelectObject(hDCMem, hFontGraphBold);

                // If this is an unhealthy ft set member, draw the text in red.

                if (!isFree && ftObject
                && (ftObject->State != Healthy)
                && (ftObject->State != Initializing)) {
                    SetTextColor(hDCMem, RGB(192, 0, 0));
                } else {
                    SetTextColor(hDCMem, RGB(0, 0, 0));
                }

                DrawText(hDCMem, uniTextBold, -1, &rc, DT_LEFT | DT_NOPREFIX);
                SelectObject(hDCMem, hFontGraph);
                DrawText(hDCMem, uniText, -1, &rc, DT_LEFT | DT_NOPREFIX);
#if i386
                // if this guy is active make a mark in the upper left
                // corner of his rectangle.

                if ((regionDescriptor->SysID != SYSID_UNUSED)
                && (regionDescriptor->Disk == 0)
                && (regionDescriptor->RegionType == REGION_PRIMARY)
                && regionDescriptor->Active) {
                    TextOut(hDCMem,
                            leftAdjust + dxBarTextMargin,
                            BarTopYOffset + 2,
                            TEXT("*"),
                            1);
                }
#endif
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
                // Check for DoubleSpace volumes and update display accordingly

                dblSpaceIndex = 0;
                dblSpace = NULL;
                while (dblSpace = DblSpaceGetNextVolume(regionDescriptor, dblSpace)) {

                    if (dblSpace->Mounted) {
                        SetTextColor(hDCMem, RGB(192,0,0));
                    } else {
                        SetTextColor(hDCMem, RGB(0,0,0));
                    }
                    wsprintf(uniText,
                             TEXT("%c: %s"),
                             dblSpace->DriveLetter,
                             dblSpace->FileName);
                    rc.left   = leftAdjust + dxBarTextMargin + 60;
                    rc.right  = leftAdjust + cx - dxBarTextMargin;
                    rc.top    = BarTopYOffset + dyBarTextLine + (dblSpaceIndex * 15);
                    rc.bottom = BarBottomYOffset;
                    DrawText(hDCMem, uniText, -1, &rc, DT_LEFT | DT_NOPREFIX);
                    dblSpaceIndex++;
                }
#endif
                SetBkColor(hDCMem, previousColor);
                leftAdjust += cx - 1;
            } else {
                DiskState->LeftRight[i].Left = DiskState->LeftRight[i].Right = 0;
            }
        }
    }

    SelectObject(hDCMem, hpenT);
    SelectObject(hDCMem, hfontT);
}

VOID
AdjustMenuAndStatus(
    VOID
    )

/*++

Routine Description:

    This routine updates the information in the Status bar
    if something is selected and if the status bar is to be
    displayed.

Arguments"

    None

Return Value:

    None

--*/

{
    TCHAR      mbBuffer[16],
               statusBarPartitionString[200],
               dblSpaceString[200];
    DWORD      selectionCount,
               msg,
               regionIndex;
    PDISKSTATE diskState;
    PWSTR      volumeLabel,
               typeName;
    WCHAR      driveLetter;


    switch (selectionCount = SetUpMenu(&SingleSel,&SingleSelIndex)) {

    case 0:

        StatusTextDrlt[0] = 0;
        StatusTextSize[0] = StatusTextStat[0] = 0;
        StatusTextVoll[0] = StatusTextType[0] = 0;
        break;

    case 1:

        // Might be part of a partial FT set.

        if (FtSelectionType != -1) {
            goto FtSet;
        }

        diskState = SingleSel;
        regionIndex = SingleSelIndex;

        DetermineRegionInfo(&diskState->RegionArray[regionIndex],
                            &typeName,
                            &volumeLabel,
                            &driveLetter);
        lstrcpyW(StatusTextType,typeName);
        lstrcpyW(StatusTextVoll,volumeLabel);

        if (diskState->RegionArray[regionIndex].SysID == SYSID_UNUSED) {
            if (diskState->RegionArray[regionIndex].RegionType == REGION_LOGICAL) {
                if (diskState->ExistLogical) {
                    msg = IDS_FREEEXT;
                } else {
                    msg = IDS_EXTENDEDPARTITION;
                }
            } else {
                msg = IDS_FREESPACE;
            }
            driveLetter = L' ';
            StatusTextType[0] = 0;
        } else {
            msg = (diskState->RegionArray[regionIndex].RegionType == REGION_LOGICAL)
                ? IDS_LOGICALVOLUME
                : IDS_PARTITION;

#if i386
            if ((msg == IDS_PARTITION) && (diskState->Disk == 0) && diskState->RegionArray[regionIndex].Active) {
                msg = IDS_ACTIVEPARTITION;
            }
#endif
        }
        LoadString(hModule, msg, statusBarPartitionString, STATUS_TEXT_SIZE/sizeof(StatusTextStat[0]));
        if (DblSpaceVolumeExists(&diskState->RegionArray[regionIndex])) {
            LoadString(hModule, IDS_WITH_DBLSPACE, dblSpaceString, STATUS_TEXT_SIZE/sizeof(StatusTextStat[0]));
        } else {
            dblSpaceString[0] = dblSpaceString[1] = 0;
        }
        wsprintf(StatusTextStat,
                 "%s %s",
                 statusBarPartitionString,
                 dblSpaceString);
        LoadString(hModule, IDS_MEGABYTES_ABBREV, mbBuffer, sizeof(mbBuffer)/sizeof(TCHAR));
        wsprintf(StatusTextSize,
                 "%u %s",
                 diskState->RegionArray[regionIndex].SizeMB,
                 mbBuffer);

        StatusTextDrlt[0] = driveLetter;
        StatusTextDrlt[1] = (WCHAR)((driveLetter == L' ') ? 0 : L':');
        break;

    default:
    FtSet:

        // Might be an ft set, might be multiple items

        if (FtSelectionType == -1) {
            LoadString(hModule, IDS_MULTIPLEITEMS, StatusTextStat, STATUS_TEXT_SIZE/sizeof(StatusTextStat[0]));
            StatusTextDrlt[0] = 0;
            StatusTextSize[0] = 0;
            StatusTextType[0] = StatusTextVoll[0] = 0;
        } else {
            PREGION_DESCRIPTOR regionDescriptor;
            DWORD          resid = 0,
                           i;
            DWORD          Size = 0;
            TCHAR          textbuf[STATUS_TEXT_SIZE];
            PFT_OBJECT_SET ftSet;
            PFT_OBJECT     ftObject;
            FT_SET_STATUS  setState;
            ULONG          numberOfMembers;
            WCHAR          ftstat[65];
            STATUS_CODE    status;

            typeName = NULL;
            DetermineRegionInfo(&SELECTED_REGION(0),
                                &typeName,
                                &volumeLabel,
                                &driveLetter);
            if (!typeName) {
                if (SelectionCount > 1) {
                    DetermineRegionInfo(&SELECTED_REGION(0),
                                        &typeName,
                                        &volumeLabel,
                                        &driveLetter);
                }
            }
            if (!typeName) {
                typeName = wszUnknown;
                volumeLabel = L"";
            }
            lstrcpyW(StatusTextType, typeName);
            lstrcpyW(StatusTextVoll, volumeLabel);

            switch (FtSelectionType) {
            case Mirror:
                resid = IDS_STATUS_MIRROR;
                Size = SELECTED_REGION(0).SizeMB;
                break;
            case Stripe:
                resid = IDS_STATUS_STRIPESET;
                goto CalcSize;
            case StripeWithParity:
                resid = IDS_STATUS_PARITY;
                goto CalcSize;
            case VolumeSet:
                resid = IDS_STATUS_VOLUMESET;
                goto CalcSize;
CalcSize:
                for (i=0; i<selectionCount; i++) {
                    Size += SELECTED_REGION(i).SizeMB;
                }
                break;
            default:
                FDASSERT(FALSE);
            }

            ftObject = GET_FT_OBJECT(&SELECTED_REGION(0));
            ftSet = ftObject->Set;

            if (FtSelectionType != VolumeSet) {
                regionDescriptor = LocateRegionForFtObject(ftSet->Member0);

                if (!regionDescriptor) {

                    // The zeroth member is off line

                    ftObject = ftSet->Members;
                    while (ftObject) {

                        // Find member 1

                        if (ftObject->MemberIndex == 1) {
                            regionDescriptor = LocateRegionForFtObject(ftObject);
                            break;
                        }
                        ftObject = ftObject->Next;
                    }
                }

                // If the partition number is zero, then this set has
                // not been committed to the disk yet.

                if ((regionDescriptor) && (regionDescriptor->PartitionNumber)) {
                    status = LowFtVolumeStatus(regionDescriptor->Disk,
                                               regionDescriptor->PartitionNumber,
                                               &setState,
                                               &numberOfMembers);
                    if (status == OK_STATUS) {
                        if ((ftSet->Status != FtSetNewNeedsInitialization) &&
                            (ftSet->Status != FtSetNew)) {

                            if (ftSet->Status != setState) {
                                PFT_OBJECT         tempFtObjectPtr;

                                ftSet->Status = setState;

                                // Determine if each object should be updated.

                                switch (setState) {
                                case FtSetHealthy:

                                    // Each object in the set should have
                                    // the partition state updated.  Determine
                                    // the value for the update and walk
                                    // the chain to perform the update.

                                    for (tempFtObjectPtr = ftSet->Members;
                                         tempFtObjectPtr;
                                         tempFtObjectPtr = tempFtObjectPtr->Next) {
                                        tempFtObjectPtr->State = Healthy;
                                    }
                                    TotalRedrawAndRepaint();
                                    break;

                                case FtSetInitializing:
                                case FtSetRegenerating:
                                case FtSetDisabled:

                                    FdftUpdateFtObjectSet(ftSet, setState);
                                    TotalRedrawAndRepaint();
                                    break;

                                default:
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            LoadString(hModule, resid, textbuf, sizeof(textbuf)/sizeof(TCHAR));

            switch (resid) {
            case IDS_STATUS_STRIPESET:
            case IDS_STATUS_VOLUMESET:
                wsprintf(StatusTextStat, textbuf, ftSet->Ordinal);
                break;
            case IDS_STATUS_PARITY:
            case IDS_STATUS_MIRROR:
                switch(ftSet->Status) {
                case FtSetHealthy:
                    resid = IDS_HEALTHY;
                    break;
                case FtSetNew:
                case FtSetNewNeedsInitialization:
                    resid = IDS_NEW;
                    break;
                case FtSetBroken:
                    resid = IDS_BROKEN;
                    break;
                case FtSetRecoverable:
                    resid = IDS_RECOVERABLE;
                    break;
                case FtSetRecovered:
                    resid = IDS_REGENERATED;
                    break;
                case FtSetInitializing:
                    resid = IDS_INITIALIZING;
                    break;
                case FtSetRegenerating:
                    resid = IDS_REGENERATING;
                    break;
                case FtSetDisabled:
                    resid = IDS_DISABLED;
                    break;
                case FtSetInitializationFailed:
                    resid = IDS_INIT_FAILED;
                    break;
                default:
                    FDASSERT(FALSE);
                }
                LoadStringW(hModule, resid, ftstat, sizeof(ftstat)/sizeof(WCHAR));
                wsprintf(StatusTextStat, textbuf, ftSet->Ordinal,ftstat);
                break;
            default:
                FDASSERT(FALSE);
            }

            LoadString(hModule, IDS_MEGABYTES_ABBREV, mbBuffer, sizeof(mbBuffer)/sizeof(TCHAR));
            wsprintf(StatusTextSize, "%u %s", Size, mbBuffer);

            StatusTextDrlt[0] = driveLetter;
            StatusTextDrlt[1] = (WCHAR)((driveLetter == L' ') ? 0 : L':');
        }
    }
    UpdateStatusBarDisplay();
}

ULONG
PartitionCount(
    IN ULONG Disk
    )

/*++

Routine Description:

    Given a disk index, this routine calculates the number of partitions the
    disk contains.

Arguments:

    Disk - This disk index for the count.

Return Value:

    The number of partitions on the disk

--*/

{
    unsigned i;
    ULONG partitions = 0;
    PREGION_DESCRIPTOR regionDescriptor;

    for (i=0; i<Disks[Disk]->RegionCount; i++) {

        regionDescriptor = &Disks[Disk]->RegionArray[i];

        if ((regionDescriptor->RegionType != REGION_LOGICAL) && (regionDescriptor->SysID != SYSID_UNUSED)) {
            partitions++;
        }
    }

    return partitions;
}


BOOL
RegisterFileSystemExtend(
    VOID
    )

/*++

Routine Description:

    This function adds registry entries to extend the file
    system structures in volume sets that have been extended.

Arguments:

    None.

Return Value:

    non-zero if there was a file system that was extended.

--*/
{
    BYTE                buf[1024];
    PSTR                template = "autochk /x ";
    CHAR                extendedDrives[26];
    PDISKSTATE          diskState;
    PREGION_DESCRIPTOR  regionDescriptor;
    PFT_OBJECT          ftObject;
    DWORD               cExt = 0,
                        i,
                        j,
                        valueType,
                        size,
                        templateLength;
    HKEY                hkey;
    LONG                ec;

    // Traverse the disks to find any volume sets that
    // have been extended.

    for (i = 0; i < DiskCount; i++) {

        diskState = Disks[i];
        for (j = 0; j < diskState->RegionCount; j++) {

            regionDescriptor = &diskState->RegionArray[j];
            if ((ftObject = GET_FT_OBJECT(regionDescriptor)) != NULL
                && ftObject->MemberIndex == 0
                && ftObject->Set->Type == VolumeSet
                && ftObject->Set->Status == FtSetExtended) {

                extendedDrives[cExt++] = PERSISTENT_DATA(regionDescriptor)->DriveLetter;
            }
        }
    }

    if (cExt) {

        // Fetch the BootExecute value of the Session Manager key.

        ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          &hkey);

        if (ec != NO_ERROR) {
            return 0;
        }

        size = sizeof(buf);
        ec = RegQueryValueExA(hkey,
                              TEXT("BootExecute"),
                              NULL,
                              &valueType,
                              buf,
                              &size);

        if (ec != NO_ERROR || valueType != REG_MULTI_SZ) {
            return 0;
        }

        // Decrement size to get rid of the extra trailing null

        if (size) {
            size--;
        }

        templateLength = strlen(template);

        for (i = 0; i < cExt; i++) {

            // Add an entry for this drive to the BootExecute value.

            strncpy(buf+size, template, templateLength);
            size += templateLength;

            buf[size++] = extendedDrives[i];
            buf[size++] = ':';
            buf[size++] = 0;
        }

        // Add an additional trailing null at the end

        buf[size++] = 0;

        // Save the value.

        ec = RegSetValueExA(hkey,
                            TEXT("BootExecute"),
                            0,
                            REG_MULTI_SZ,
                            buf,
                            size);

        RegCloseKey( hkey );
        if (ec != NO_ERROR) {
            return 0;
        }
        return 1;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\diskcopy.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
};
#include "fmifsmsg.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"
#include "mldcopy.hxx"


VOID
DiskCopy(
    IN  PWSTR           SourceDrive,
    IN  PWSTR           DestDrive,
    IN  BOOLEAN         Verify,
    IN  FMIFS_CALLBACK  Callback
    )
/*++

Routine Description:

    This routine copies the contents of the floppy in the
    source drive to the floppy in the destination drive.

Arguments:

    SourceDrive - Supplies the dos style name of the source drive.
    DestDrive   - Supplies the dos style name of the destination drive.
    Verify      - Supplies whether or not writes should be verified.
    Callback    - Supplies the file manager call back function.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     src_dos_name, dst_dos_name;
    DSTRING                     src_nt_name, dst_nt_name;
    INT                         r;
    FMIFS_FINISHED_INFORMATION  finished_info;

    if (!message.Initialize(Callback) ||
        !src_dos_name.Initialize(SourceDrive) ||
        !dst_dos_name.Initialize(DestDrive) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&src_dos_name, &src_nt_name) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dst_dos_name, &dst_nt_name)) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    r = DiskCopyMainLoop(&src_nt_name,
                         &dst_nt_name,
                         &src_dos_name,
                         &dst_dos_name,
                         Verify,
                         &message,
                         &message);

    finished_info.Success = (r <= 1) ? TRUE : FALSE;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\chkmsg.cxx ===
#include "ulib.hxx"
#include "system.hxx"
#include "chkmsg.hxx"
#include "rtmsg.h"


#define MAX_CHKDSK_MESSAGE_LENGTH 400


DEFINE_CONSTRUCTOR(FMIFS_CHKMSG, FMIFS_MESSAGE);


FMIFS_CHKMSG::~FMIFS_CHKMSG(
    )
/*++

Routine Description:

    Destructor for FMIFS_CHKMSG.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
FMIFS_CHKMSG::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
FMIFS_CHKMSG::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
FMIFS_CHKMSG::Initialize(
    IN  FMIFS_CALLBACK  CallBack
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    CallBack    - Supplies the callback to the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();
    _lastyesnoquery = UNINITIALIZED_BOOLEAN;
    return FMIFS_MESSAGE::Initialize(CallBack);
}


BOOLEAN
FMIFS_CHKMSG::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN r = TRUE;
    DSTRING string;
    STR sz[MAX_CHKDSK_MESSAGE_LENGTH];
    FMIFS_PERCENT_COMPLETE_INFORMATION  percent_info;
    FMIFS_CHECKONREBOOT_INFORMATION     reboot_info;
    FMIFS_TEXT_MESSAGE                  textMsg;

    if (! (_msgvisual & GUI_MESSAGE) )
    {
        return TRUE;
    }

    switch (GetMessageId())
    {
        case MSG_PERCENT_COMPLETE:
        case MSG_PERCENT_COMPLETE2:
        {
            percent_info.PercentCompleted = va_arg(VarPointer, ULONG);
            r = _callback(FmIfsPercentCompleted,
                          sizeof(FMIFS_PERCENT_COMPLETE_INFORMATION),
                          &percent_info);
            break;
        }

        case MSG_CHKDSK_ON_REBOOT_PROMPT:
        {
            reboot_info.QueryResult = UNINITIALIZED_BOOLEAN;
            r = _callback(FmIfsCheckOnReboot,
                          sizeof(FMIFS_CHECKONREBOOT_INFORMATION),
                          &reboot_info);

            _lastyesnoquery = reboot_info.QueryResult;

            break;
        }

        case MSG_CHK_WRITE_PROTECTED: {
            r = _callback(FmIfsMediaWriteProtected, 0, NULL);
            break;
        }

        case MSG_CHK_NO_MULTI_THREAD: {
            r = _callback(FmIfsCantChkMultiVolumeOfSameFS, 0, NULL);
            break;
        }

        case MSG_DASD_ACCESS_DENIED:
        {
           r = _callback(FmIfsAccessDenied, 0, NULL);
           break;
        }

        default:
        {
            if (!SYSTEM::QueryResourceStringV(
                            &string,
                            GetMessageId(),
                            Format,
                            VarPointer))
            {
                return FALSE;
            }

            if (IsLoggingEnabled() && !IsSuppressedMessage())
                LogMessage(&string);

            string.QuerySTR(0,TO_END,sz,MAX_CHKDSK_MESSAGE_LENGTH);
            textMsg.Message = sz;

            switch (GetMessageId())
            {
            case MSG_CHKDSK_CANNOT_SCHEDULE:
            case MSG_CHKDSK_SCHEDULED:
            case MSG_CHK_NTFS_ERRORS_FOUND:
            {
                textMsg.MessageType = MESSAGE_TYPE_FINAL;

                break;
            }

            default:
            {
                switch (_msgtype)
                {
                case PROGRESS_MESSAGE:
                    textMsg.MessageType = MESSAGE_TYPE_PROGRESS;
                    break;

                default:
                    textMsg.MessageType = MESSAGE_TYPE_RESULTS;
                    break;
                }

                break;
            }
            }

            r = _callback(
                    FmIfsTextMessage,
                    sizeof(FMIFS_TEXT_MESSAGE),
                    &textMsg);

            break;
        }
    }

    return r;
}


BOOLEAN
FMIFS_CHKMSG::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine returns returns the value loaded from the user during
    the previous DisplayV() with a query message, or the default
    if no response (which currently isn't possible...)

Arguments:

    Default - Supplies the default answer

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    DebugPrintTrace((
            "FMIFS_CHKMSG::IsYesResponse: _lastyesnoquery == %d\n",
            _lastyesnoquery));

    return (UNINITIALIZED_BOOLEAN == _lastyesnoquery)
            ? Default
            : _lastyesnoquery
            ;
}


PMESSAGE
FMIFS_CHKMSG::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    PFMIFS_CHKMSG  p;

    if (!(p = NEW FMIFS_CHKMSG)) {
        return NULL;
    }

    if (!p->Initialize(_callback)) {
        DELETE(p);
        return NULL;
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\fmifs.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    fmifs.cxx

Abstract:

        This module contains run-time, global support for the
    FM IFS Utilities library (FMIFS).   This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

    Norbert P. Kusters (norbertk) 30-May-1991

Environment:

        User Mode

Notes:

--*/

#include "ulib.hxx"


//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

extern "C" BOOLEAN
InitializeFmIfs (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        );

BOOLEAN
InitializeFmIfs (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        )
/*++

Routine Description:

    Initialize FmIfs by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    static ULONG    count = 0;

    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_FMIFS_MEM_LEAK)
                DebugPrintTrace(("FMIFS.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

#if defined(TRACE_FMIFS_MEM_LEAK)
            DebugPrint("FMIFS.DLL got attached.\n");
#endif

            if (!DefineClassDescriptors() ) {
                UndefineClassDescriptors();
                DebugAbort( "FmIfs initialization failed!!!\n" );
                return( FALSE );
            }
            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_FMIFS_MEM_LEAK)
                DebugPrintTrace(("FMIFS.DLL got detached.  %d time(s) left.", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_FMIFS_MEM_LEAK)
                DebugPrint("FMIFS.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_FMIFS_MEM_LEAK)
                DebugPrint("FMIFS.DLL detached more than attached\n");
#endif
            }
            break;
    }
    return TRUE;
}



DECLARE_CLASS(  FMIFS_MESSAGE           );
DECLARE_CLASS(  FMIFS_CHKMSG            );

STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
    if( DEFINE_CLASS_DESCRIPTOR(    FMIFS_MESSAGE           )
     && DEFINE_CLASS_DESCRIPTOR(    FMIFS_CHKMSG            )
        ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR(    FMIFS_MESSAGE           );
    UNDEFINE_CLASS_DESCRIPTOR(    FMIFS_CHKMSG            );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\format.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
#include "stdio.h"
};
#include "fmifsmsg.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"
#include "ifsentry.hxx"
#include "system.hxx"
#include "hmem.hxx"
#include "drive.hxx"

typedef struct _FILE_SYSTEM_FORMAT_RECORD {
    WCHAR       FileSystemName[MAX_FILE_SYSTEM_FORMAT_NAME_LEN];    // FAT, FAT32, NTFS
    UCHAR       MajorVersion;                                       // major revision number
    UCHAR       MinorVersion;                                       // minor revision number
    BOOLEAN     Latest;                                             // TRUE for most up-to-date version
} FILE_SYSTEM_FORMAT_RECORD;

//
// Defines all the format type Format() and FormatEx() can do
// This needs to be updated on each official release
//
FILE_SYSTEM_FORMAT_RECORD   fsFormatAvailable[] = {
    {{'F','A','T'},         0, 0, TRUE},
    {{'F','A','T','3','2'}, 0, 0, TRUE},
    {{'N','T','F','S'},     4, 0, FALSE},
    {{'N','T','F','S'},     5, 0, TRUE}
};

MEDIA_TYPE
ComputeNtMediaType(
    IN  FMIFS_MEDIA_TYPE    MediaType
    )
/*++

Routine Description:

    This routine translates the FMIFS media type to the NT media type.

Arguments:

    MediaType   - Supplies the FMIFS media type.

Return Value:

    The NT media type corresponding to the input.

--*/
{
    MEDIA_TYPE  media_type;

    switch (MediaType) {
        case FmMediaFixed:
            media_type = FixedMedia;
            break;
        case FmMediaRemovable:
            media_type = RemovableMedia;
            break;
        case FmMediaF5_1Pt2_512:
            media_type = F5_1Pt2_512;
            break;
        case FmMediaF5_360_512:
            media_type = F5_360_512;
            break;
        case FmMediaF5_320_512:
            media_type = F5_320_512;
            break;
        case FmMediaF5_320_1024:
            media_type = F5_320_1024;
            break;
        case FmMediaF5_180_512:
            media_type = F5_180_512;
            break;
        case FmMediaF5_160_512:
            media_type = F5_160_512;
            break;
        case FmMediaF3_2Pt88_512:
            media_type = F3_2Pt88_512;
            break;
        case FmMediaF3_1Pt44_512:
            media_type = F3_1Pt44_512;
            break;
        case FmMediaF3_720_512:
            media_type = F3_720_512;
            break;
        case FmMediaF3_20Pt8_512:
            media_type = F3_20Pt8_512;
            break;
        case FmMediaF3_120M_512:
            media_type = F3_120M_512;
            break;
        case FmMediaF3_200Mb_512:
            media_type = F3_200Mb_512;
            break;
        case FmMediaF3_240Mb_512:
            media_type = F3_240M_512;
            break;
#ifdef FE_SB // JAPAN && i386
        // FMR Sep.8.1994 SFT YAM :ADD
        // FMR Jul.12.1994 SFT KMR
        // Add the media-type for 2HD/2HC
        case FmMediaF5_1Pt23_1024:
            media_type = F5_1Pt23_1024;
            break;
        case FmMediaF3_1Pt23_1024:
            media_type = F3_1Pt23_1024;
            break;
        case FmMediaF3_1Pt2_512:
            media_type = F3_1Pt2_512;
            break;
        // Add the media-type for 2DD(640KB/720KB)
        case FmMediaF5_720_512:
            media_type = F5_720_512;
            break;
        case FmMediaF5_640_512:
            media_type = F5_640_512;
            break;
        // NEC98 '94.09.22 NES
        // add  FmMediaF5_1Pt2_1024
        //      FmMediaF8_256_128
        //      FmMediaF3_640_512
        //      FmMediaF3_128Mb_512

        // deleted F5_1Pt2_1024 by eichim, 11/14/94
        // please see also public\sdk\inc\ntdddisk.h@v5
        //  case FmMediaF5_1Pt2_1024:
        //  media_type = F5_1Pt2_1024;
        //  break;
#if (_WIN32_WINNT < 0x0400)
        //
        // FmMediaF8_256_128 is no longer supported.
        //
        case FmMediaF8_256_128:
            media_type = F8_256_128;
            break;
#endif
        case FmMediaF3_640_512:
            media_type = F3_640_512;
            break;

        //
        // OpticalDisk format...
        //
        case FmMediaF3_128Mb_512:
            media_type = F3_128Mb_512;
            break;
        case FmMediaF3_230Mb_512:
            media_type = F3_230Mb_512;
            break;
#endif // FE_SB

        case FmMediaUnknown:
        default:
            media_type = Unknown;
            break;
    }

    return media_type;
}


FMIFS_MEDIA_TYPE
ComputeFmMediaType(
    IN  MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine translates the NT media type to the FMIFS media type.

Arguments:

    MediaType   - Supplies the NT media type.

Return Value:

    The FMIFS media type corresponding to the input.

--*/
{
    FMIFS_MEDIA_TYPE    media_type;

    switch (MediaType) {
        case FixedMedia:
            media_type = FmMediaFixed;
            break;
        case RemovableMedia:
            media_type = FmMediaRemovable;
            break;
        case F5_1Pt2_512:
            media_type = FmMediaF5_1Pt2_512;
            break;
        case F5_360_512:
            media_type = FmMediaF5_360_512;
            break;
        case F5_320_512:
            media_type = FmMediaF5_320_512;
            break;
        case F5_320_1024:
            media_type = FmMediaF5_320_1024;
            break;
        case F5_180_512:
            media_type = FmMediaF5_180_512;
            break;
        case F5_160_512:
            media_type = FmMediaF5_160_512;
            break;
        case F3_2Pt88_512:
            media_type = FmMediaF3_2Pt88_512;
            break;
        case F3_1Pt44_512:
            media_type = FmMediaF3_1Pt44_512;
            break;
        case F3_720_512:
            media_type = FmMediaF3_720_512;
            break;
        case F3_20Pt8_512:
            media_type = FmMediaF3_20Pt8_512;
            break;
        case F3_120M_512:
            media_type = FmMediaF3_120M_512;
            break;
        case F3_200Mb_512:
            media_type = FmMediaF3_200Mb_512;
            break;
        case F3_240M_512:
            media_type = FmMediaF3_240Mb_512;
            break;
#ifdef FE_SB // JAPAN && i386
        // FMR Sep.8.1994 SFT YAM :ADD
        // FMR Jul.12.1994 SFT KMR
        // Add the media-type for 2HD
        case F5_1Pt23_1024:
            media_type = FmMediaF5_1Pt23_1024;
            break;
        case F3_1Pt23_1024:
            media_type = FmMediaF3_1Pt23_1024;
            break;
        case F3_1Pt2_512:
            media_type = FmMediaF3_1Pt2_512;
            break;
        // Add the media-type for 2DD(640KB/720KB)
        case F5_720_512:
            media_type = FmMediaF5_720_512;
            break;
        case F5_640_512:
            media_type = FmMediaF5_640_512;
            break;
        // NEC98 '94.09.22 NES
        // add       F5_1Pt2_1024:
        //           F8_256_128:
        //           F3_640_512:
        //           F3_128Mb_512:

        // deleted F5_1Pt2_1024 by eichim, 11/14/94
        // please see also public\sdk\inc\ntdddisk.h@v5
        //  case F5_1Pt2_1024:
        //  media_type = FmMediaF5_1Pt2_1024;
        //  break;
#if (_WIN32_WINNT < 0x0400)
        //
        // FmMediaF8_256_128 is no longer supported.
        //
        case F8_256_128:
            media_type = FmMediaF8_256_128;
            break;
#endif
        case F3_640_512:
            media_type = FmMediaF3_640_512;
            break;

        //
        // OpticalDisk format...
        //
        case F3_128Mb_512:
            media_type = FmMediaF3_128Mb_512;
            break;
        case F3_230Mb_512:
            media_type = FmMediaF3_230Mb_512;
            break;
#endif // FE_SB

        case Unknown:
        default:
            media_type = FmMediaUnknown;
            break;
    }

    return media_type;
}

#if defined(FE_SB) && defined (_X86_)
BOOLEAN
ConvertSectorSizeIfNeeded(
    IN  PDSTRING                ntdrivename,
    IN  FMIFS_MEDIA_TYPE        MediaType,
    OUT PUCHAR                  FirstByte
)
/*++

Routine Description:

    Given the drive name and media type, this routine writes 0 to the first byte of the boot sector.
    This routine returns original value of the first byte.

Arguments:

    ntdrivename     - Supplies the name of the drive name.
    MediaType       - Supplies the media type.
    FirstByte       - Returns First byte of first sector.

Return Value:

    TRUE  - Success
    FALSE - Failure

--*/
{
    // FMR Oct.13.1994 SFT YAM
    // If the sector-size when the last format differ from next format,
    // initialize a hard one-byte of disk.

    ULONG       old_sec_size;
    ULONG       new_sec_size;
    HMEM    hmem;
    PUCHAR      rw_buff = NULL;
    DP_DRIVE    dpdrive;
    BOOLEAN     result = TRUE;

    *FirstByte = 0;

    if (dpdrive.Initialize(ntdrivename)) {
        if (dpdrive.QueryMediaType() != Unknown) {

            old_sec_size = dpdrive.QuerySectorSize();

            if (ComputeNtMediaType(MediaType) == F5_1Pt23_1024 ||
                ComputeNtMediaType(MediaType) == F3_1Pt23_1024) {
                new_sec_size = 1024;
            } else {
                new_sec_size = 512;
            }

            if (new_sec_size != old_sec_size) {
                LOG_IO_DP_DRIVE *LDpDrive = NEW LOG_IO_DP_DRIVE;

                if (LDpDrive->Initialize(ntdrivename,NULL,TRUE)) {
                    if (IsNEC_98 ? hmem.Acquire(dpdrive.QuerySectorSize(), max(dpdrive.QueryAlignmentMask(),
                                                          dpdrive.QuerySectorSize()-1)) :
                                   hmem.Acquire(dpdrive.QuerySectorSize(), dpdrive.QueryAlignmentMask())) {
                        rw_buff = (PUCHAR)hmem.GetBuf();
                        LDpDrive->Read(0,1,rw_buff);
                        *FirstByte = rw_buff[0];
                        rw_buff[0] = 0;
                        LDpDrive->Write(0,1,rw_buff);
                    } else {
                        result = FALSE;
                    }
                } else {
                    result = FALSE;
                }
                DELETE(LDpDrive);
            }
        }
    } else {
        result = FALSE;
    }
    return result;
}

VOID
RevertToOriginalSectorSize(
    IN  PDSTRING                ntdrivename,
    IN  UCHAR                   FirstByte
)
/*++

Routine Description:

    Given the drive name, this routine write back the first byte of first sector.

Arguments:

    ntdrivename     - Supplies the name of the drive name.
    FirstByte       - Returns First byte of first sector.

Return Value:

--*/
{
    HMEM    hmem;
    PUCHAR      rw_buff;
    DP_DRIVE    dpdrive;

    if (FirstByte) {
        if (dpdrive.Initialize(ntdrivename)) {
            LOG_IO_DP_DRIVE *LDpDrive = NEW LOG_IO_DP_DRIVE;

        if (LDpDrive->Initialize(ntdrivename,NULL,TRUE)) {
                if (IsNEC_98 ? hmem.Acquire(dpdrive.QuerySectorSize(), max(dpdrive.QueryAlignmentMask(),
                                                      dpdrive.QuerySectorSize()-1)) :
                               hmem.Acquire(dpdrive.QuerySectorSize(), dpdrive.QueryAlignmentMask())) {
                    rw_buff = (PUCHAR)hmem.GetBuf();
                    LDpDrive->Read(0,1,rw_buff);
                    rw_buff[0] = FirstByte;
                    LDpDrive->Write(0,1,rw_buff);
                }
            }
            DELETE(LDpDrive);
        }
    }
    return;
}
#endif // FE_SB && _X86_

VOID
Format(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  FMIFS_CALLBACK      Callback
    )
/*++

Routine Description:

    This routine loads and calls the correct DLL to format the
    given volume.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    MediaType       - Supplies the media type.
    FileSystemName  - Supplies the file system type to format to.
    Label           - Supplies a new label for the volume.
    Quick           - Supplies whether or not to perform a quick
                        format.
    Callback        - Supplies the necessary call back for
                        communication with the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     format_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    FORMAT_FN                   format_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     label_string;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;

    DSTRING                     ntfs_str, ntfs_minus_str, ntfs_previous_str, ntfs_current_str;
    DSTRING                     fat_str, fat32_str, fat32_current_str;
    BOOLEAN                     backward_compatible;
    BOOLEAN                     rst;

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (!message.Initialize(Callback) ||
        !format_string.Initialize("Format") ||
        !library_name.Initialize("U") ||
        !file_system_name.Initialize(FileSystemName) ||
        !ntfs_str.Initialize("NTFS") ||
        !ntfs_minus_str.Initialize("NTFS-") ||
        !ntfs_previous_str.Initialize("NTFS 4.0") ||
        !ntfs_current_str.Initialize("NTFS 5.0") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !fat32_current_str.Initialize("FAT32 0.0")) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    if (file_system_name == ntfs_str) {
        rst = TRUE;
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_minus_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == fat_str) {
        rst = TRUE;
        backward_compatible = TRUE;
    } else if (file_system_name == fat32_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == fat32_current_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_previous_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == ntfs_current_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = FALSE;
    } else
        rst = FALSE;

    if (!rst ||
        !library_name.Strcat(&file_system_name) ||
        !(format_function = (FORMAT_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &format_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        !label_string.Initialize(Label) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

#if defined(FE_SB) && defined (_X86_)
    UCHAR       FirstByte;

    if (ConvertSectorSizeIfNeeded(&ntdrivename, MediaType, &FirstByte) == FALSE) {

        SYSTEM::FreeLibraryHandle(dll_handle);

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }
#endif // FE_SB

    // Call format.

    result = format_function(&ntdrivename,
                             &message,
                             Quick,
                             backward_compatible,
                             ComputeNtMediaType(MediaType),
                             &label_string, 0);

#if defined(FE_SB) && defined (_X86_)
    if (!result && FirstByte)
    RevertToOriginalSectorSize(&ntdrivename, FirstByte);
#endif // FE_SB && _X86_

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}


VOID
FormatEx(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  DWORD               ClusterSize,
    IN  FMIFS_CALLBACK      Callback
    )
/*++

Routine Description:

    This routine loads and calls the correct DLL to format the
    given volume.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    MediaType       - Supplies the media type.
    FileSystemName  - Supplies the file system type to format to.
    Label           - Supplies a new label for the volume.
    Quick           - Supplies whether or not to perform a quick
                        format.
    ClusterSize     - Size of volume cluster in bytes.
    Callback        - Supplies the necessary call back for
                        communication with the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     format_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    FORMAT_FN                   format_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     label_string;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;

    DSTRING                     ntfs_str, ntfs_minus_str, ntfs_previous_str, ntfs_current_str;
    DSTRING                     fat_str, fat32_str, fat32_current_str;
    BOOLEAN                     backward_compatible;
    BOOLEAN                     rst = TRUE;

#if 0
    FMIFS_FORMATEX2_PARAM       param;

    VOID
    FormatEx2(
        IN  PWSTR                   DriveName,
        IN  FMIFS_MEDIA_TYPE        MediaType,
        IN  PWSTR                   FileSystemName,
        IN  PFMIFS_FORMATEX2_PARAM  Param,
        IN  FMIFS_CALLBACK          Callback
        );

    memset(&param, 0, sizeof(param));
    param.Major = 1;
    param.Minor = 0;
    if (Quick)
        param.Flags |= FMIFS_FORMAT_QUICK;
    param.Flags |= FMIFS_FORMAT_FORCE;
    param.ClusterSize = ClusterSize;
    param.LabelString = Label;

    FormatEx2(DriveName,
              MediaType,
              FileSystemName,
              &param,
              Callback);
    return;
#endif

#if 0 // test code for API within
    {
        STR             x[100];
        UCHAR           major, minor;
        BOOLEAN         latest;
        unsigned            i;
        WSTR            fsName[10];

        for (i=0; QueryAvailableFileSystemFormat(i++, fsName, &major, &minor, &latest);) {
            OutputDebugStringW(fsName);
            sprintf(x, "; Major %d; Minor %d; Latest %d\n", major, minor, latest);
            OutputDebugStringA(x);
        }
    }
#endif

#if 0 // test code for API within
    {
        STR         x[100];
        WSTR        fsname[MAX_FILE_SYSTEM_FORMAT_VERSION_NAME_LEN];
        UCHAR       major, minor;
        NTSTATUS    errcode;

        if (QueryFileSystemName(DriveName,
                                fsname,
                                &major,
                                &minor,
                                &errcode)) {
            OutputDebugStringW(fsname);
            sprintf(x, "; Major %d; Minor %d; Errcode %d\n", major, minor, errcode);
            OutputDebugStringA(x);
        } else
            OutputDebugStringA("QueryFileSystemName failed\n");
    }
#endif

#if 0 // test code for API within
    {
        STR         x[100];
        UCHAR       major, minor;

        if (QueryLatestFileSystemVersion(FileSystemName, &major, &minor)) {
            OutputDebugStringW(FileSystemName);
            sprintf(x, "; Major %d; Minor %d\n", major, minor);
            OutputDebugStringA(x);
        } else
            OutputDebugStringA("QueryLatestFileSystemVersion failed\n");
    }
#endif

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (!message.Initialize(Callback) ||
        !format_string.Initialize("Format") ||
        !library_name.Initialize("U") ||
        !file_system_name.Initialize(FileSystemName) ||
        !ntfs_str.Initialize("NTFS") ||
        !ntfs_minus_str.Initialize("NTFS-") ||
        !ntfs_previous_str.Initialize("NTFS 4.0") ||
        !ntfs_current_str.Initialize("NTFS 5.0") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !fat32_current_str.Initialize("FAT32 0.0")) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    if (file_system_name == ntfs_str) {
        rst = TRUE;
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_minus_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == fat_str) {
        rst = TRUE;
        backward_compatible = TRUE;
    } else if (file_system_name == fat32_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == fat32_current_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_previous_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == ntfs_current_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = FALSE;
    } else
        rst = FALSE;

    if (!rst ||
        !library_name.Strcat(&file_system_name) ||
        !(format_function = (FORMAT_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &format_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        !label_string.Initialize(Label) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

#if defined(FE_SB) && defined (_X86_)
    UCHAR       FirstByte;

    if (ConvertSectorSizeIfNeeded(&ntdrivename, MediaType, &FirstByte) == FALSE) {

        SYSTEM::FreeLibraryHandle(dll_handle);

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }
#endif // FE_SB && _X86_

    // Call format.

    result = format_function(&ntdrivename,
                             &message,
                             Quick,
                             backward_compatible,
                             ComputeNtMediaType(MediaType),
                             &label_string, ClusterSize);

#if defined(FE_SB) && defined (_X86_)
    if (!result && FirstByte)
    RevertToOriginalSectorSize(&ntdrivename, FirstByte);
#endif // FE_SB && _X86_

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}


VOID
FormatEx2(
    IN  PWSTR                   DriveName,
    IN  FMIFS_MEDIA_TYPE        MediaType,
    IN  PWSTR                   FileSystemName,
    IN  PFMIFS_FORMATEX2_PARAM  Param,
    IN  FMIFS_CALLBACK          Callback
    )
/*++

Routine Description:

    This routine loads and calls the correct DLL to format the
    given volume.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    MediaType       - Supplies the media type.
    FileSystemName  - Supplies the file system type to format to.
    Param           - Supplies the format parameter block
    Callback        - Supplies the necessary call back for
                        communication with the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     format_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    FORMATEX_FN                 format_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     label_string;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;

    DSTRING                     ntfs_str, ntfs_minus_str, ntfs_previous_str, ntfs_current_str;
    DSTRING                     fat_str, fat32_str, fat32_current_str;
    BOOLEAN                     backward_compatible;
    BOOLEAN                     rst = TRUE;
    FORMATEX_FN_PARAM           param;

#if 0 // test code for API within
    {
        STR             x[100];
        UCHAR           major, minor;
        BOOLEAN         latest;
        unsigned            i;
        WSTR            fsName[10];

        for (i=0; QueryAvailableFileSystemFormat(i++, fsName, &major, &minor, &latest);) {
            OutputDebugStringW(fsName);
            sprintf(x, "; Major %d; Minor %d; Latest %d\n", major, minor, latest);
            OutputDebugStringA(x);
        }
    }
#endif

#if 0 // test code for API within
    {
        STR         x[100];
        WSTR        fsname[MAX_FILE_SYSTEM_FORMAT_VERSION_NAME_LEN];
        UCHAR       major, minor;
        NTSTATUS    errcode;

        if (QueryFileSystemName(DriveName,
                                fsname,
                                &major,
                                &minor,
                                &errcode)) {
            OutputDebugStringW(fsname);
            sprintf(x, "; Major %d; Minor %d; Errcode %d\n", major, minor, errcode);
            OutputDebugStringA(x);
        } else
            OutputDebugStringA("QueryFileSystemName failed\n");
    }
#endif

#if 0 // test code for API within
    {
        STR         x[100];
        UCHAR       major, minor;

        if (QueryLatestFileSystemVersion(FileSystemName, &major, &minor)) {
            OutputDebugStringW(FileSystemName);
            sprintf(x, "; Major %d; Minor %d\n", major, minor);
            OutputDebugStringA(x);
        } else
            OutputDebugStringA("QueryLatestFileSystemVersion failed\n");
    }
#endif

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (Param->Major != 1 ||
        Param->Minor != 0 ||
        !message.Initialize(Callback) ||
        !format_string.Initialize("FormatEx") ||
        !library_name.Initialize("U") ||
        !file_system_name.Initialize(FileSystemName) ||
        !ntfs_str.Initialize("NTFS") ||
        !ntfs_minus_str.Initialize("NTFS-") ||
        !ntfs_previous_str.Initialize("NTFS 4.0") ||
        !ntfs_current_str.Initialize("NTFS 5.0") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !fat32_current_str.Initialize("FAT32 0.0")) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    if (file_system_name == ntfs_str) {
        rst = TRUE;
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_minus_str) {
        rst = FALSE; // file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == fat_str) {
        rst = TRUE;
        backward_compatible = TRUE;
    } else if (file_system_name == fat32_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == fat32_current_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_previous_str) {
        rst = FALSE; // file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == ntfs_current_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = FALSE;
    } else
        rst = FALSE;

    if (!rst ||
        !library_name.Strcat(&file_system_name) ||
        !(format_function = (FORMATEX_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &format_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        !label_string.Initialize(Param->LabelString) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

#if defined(FE_SB) && defined (_X86_)
    UCHAR       FirstByte;

    if (ConvertSectorSizeIfNeeded(&ntdrivename, MediaType, &FirstByte) == FALSE) {

        SYSTEM::FreeLibraryHandle(dll_handle);

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }
#endif // FE_SB && _X86_

#if ((FMIFS_FORMAT_QUICK != FORMAT_QUICK) || \
     (FMIFS_FORMAT_BACKWARD_COMPATIBLE != FORMAT_BACKWARD_COMPATIBLE) || \
     (FMIFS_FORMAT_FORCE != FORMAT_FORCE))

#error FMIFS_FORMAT_* definition must be the same as that of CHKDSK_*

#endif

    param.Major = 1;
    param.Minor = 0;
    param.Flags = Param->Flags |
                  (backward_compatible ? FORMAT_BACKWARD_COMPATIBLE : 0);
    param.LabelString = &label_string;
    param.ClusterSize = Param->ClusterSize;

    // Call format.

    result = format_function(&ntdrivename,
                             &message,
                             &param,
                             ComputeNtMediaType(MediaType));

#if defined(FE_SB) && defined (_X86_)
    if (!result && FirstByte)
    RevertToOriginalSectorSize(&ntdrivename, FirstByte);
#endif // FE_SB && _X86_

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}


BOOLEAN
EnableVolumeCompression(
    IN  PWSTR               DriveName,
    IN  USHORT              CompressionFormat
    )
/*++

Routine Description:

    This sets the compression attribute on the root directory of an NTFS volume.
    Note that the compression state of any files already contained on the
    volume is not affected.

Arguments:

    DriveName          - Supplies the drive name.
                         Expects a string like "C:\".

    CompressionFormat  - COMPRESSION_FORMAT_NONE      = Uncompressed.
                         COMPRESSION_FORMAT_DEFAULT   = Default compression.
                         COMPRESSION_FORMAT_LZNT1     = Use LZNT1 compression format.
                         (as defined in NTRTL.H)

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
   HANDLE hFile;
   BOOLEAN bStatus = FALSE;

   //
   // Don't even try if no drive name provided.
   //
   if (DriveName[0])
   {
      //
      //  Try to open the root directory - READ_DATA | WRITE_DATA.
      //
      if ((hFile = CreateFile(DriveName,
                              FILE_READ_DATA | FILE_WRITE_DATA,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_BACKUP_SEMANTICS,
                              NULL )) != INVALID_HANDLE_VALUE)
      {
          ULONG Length = 0;

          if (DeviceIoControl( hFile,
                 FSCTL_SET_COMPRESSION,
                 &CompressionFormat,
                 sizeof(CompressionFormat),
                 NULL,
                 0,
                 &Length,
                 NULL))
          {
              //
              //  Successfully set compression on root directory.
              //
              bStatus = TRUE;
          }
          CloseHandle(hFile);
      }
   }
   return bStatus;
}

BOOLEAN
QuerySupportedMedia(
    IN  PWSTR               DriveName,
    OUT PFMIFS_MEDIA_TYPE   MediaTypeArray,
    IN  ULONG               NumberOfArrayEntries,
    OUT PULONG              NumberOfMediaTypes
    )
/*++

Routine Description:

    This routine computes a list of the supported media types for
    the given drive.

    If NULL is passed for the array then 'NumberOfMediaTypes'
    is filled in with the correct number.

Arguments:

    DriveName               - Supplies the drive name.
    MediaTypeArray          - Returns the supported media types.
    NumberOfArrayEntries    - Supplies the number of entries in
                                'MediaTypeArray'.
    NumberOfMediaTypes      - Returns the number of media types
                                returned in the media type array.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING             dosdrivename, ntdrivename;
    DP_DRIVE            dpdrive;
    PCDRTYPE            nt_media_types;
    INT                 num_types;
    ULONG               i, j;
    FMIFS_MEDIA_TYPE    tmp;

    if (!dosdrivename.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        return FALSE;
    }

    if (!dpdrive.Initialize(&ntdrivename)) {
        SetLastError(RtlNtStatusToDosError(dpdrive.QueryLastNtStatus()));
        return FALSE;
    }

    if (!(nt_media_types = dpdrive.GetSupportedList(&num_types))) {
        return FALSE;
    }

    if (!MediaTypeArray) {
        *NumberOfMediaTypes = num_types;
        return TRUE;
    }

    *NumberOfMediaTypes = min(NumberOfArrayEntries, (ULONG)num_types);

    for (i = 0; i < *NumberOfMediaTypes; i++) {
        MediaTypeArray[i] = ComputeFmMediaType(nt_media_types[i].MediaType);
    }

#ifndef FE_SB // JAPAN && i386
    //
    // NT-US diaplays the dialog box by MediaType order.
    // The MediaType order matches media size order on NT-US.
    // But PC98 has more media_types than US one.
    // And these does NOT match on PC98.
    // We wish to display the dialog box by size order.
    // See also..
    //   \nt\private\utils\ifsutil\src\drive.cxx
    //   DP_DRIVE::Initialize
    //
    for (i = 0; i < *NumberOfMediaTypes; i++) {
        for (j = 0; j < *NumberOfMediaTypes - 1; j++) {
            if (MediaTypeArray[j] < MediaTypeArray[j + 1]) {
                tmp = MediaTypeArray[j];
                MediaTypeArray[j] = MediaTypeArray[j + 1];
                MediaTypeArray[j + 1] = tmp;
            }
        }
    }
#endif

    return TRUE;
}

BOOLEAN
QueryAvailableFileSystemFormat(
    IN     ULONG            Index,
    OUT    PWSTR            FileSystemName,
    OUT    PUCHAR           MajorVersion,
    OUT    PUCHAR           MinorVersion,
    OUT    PBOOLEAN         Latest
)
/*++

Routine Description:

    This routine returns file system that the Format()
    and FormatEx() routines know how to format.

Arguments:

    Index                   - Supplies the index like 0, 1, 2, etc.
    FileSystemName          - Returns the name of the file system (FAT, NTFS, FAT32)
    MajorVersion            - Returns the major version number of the FS.
    MinorVersion            - Returns the minor version number of the FS.
    Latest                  - Returns TRUE if the return FS info is the latest one.

    Note that length of FileSystemName should be long enough to hold the
    return string.  The maximum length is MAX_FILE_SYSTEM_FORMAT_NAME_LEN.


Return Value:

    N/A

--*/
{
    if (Index >= sizeof(fsFormatAvailable)/sizeof(FILE_SYSTEM_FORMAT_RECORD))
        return FALSE;

    if (!FileSystemName || !MajorVersion || !MinorVersion || !Latest)
        return FALSE;

    memcpy(FileSystemName,
           fsFormatAvailable[Index].FileSystemName,
           sizeof(WCHAR)*(wcslen(fsFormatAvailable[Index].FileSystemName)+1));

    *MajorVersion = fsFormatAvailable[Index].MajorVersion;
    *MinorVersion = fsFormatAvailable[Index].MinorVersion;
    *Latest = fsFormatAvailable[Index].Latest;

    return TRUE;
}

BOOLEAN
QueryFileSystemName(
    IN  PWSTR        DriveName,
    OUT PWSTR        FileSystemName,
    OUT PUCHAR       MajorVersion,
    OUT PUCHAR       MinorVersion,
    OUT PNTSTATUS    ErrorCode
)
/*++

Routine Description:

    This routine returns the file system format on the specified drive.

Arguments:

    DriveName               - Supplies the DOS style drive name
    FileSystemName          - Returns the name of the file system (FAT, NTFS, FAT32)
    MajorVersion            - Returns the major version number of the FS.
    MinorVersion            - Returns the minor version number of the FS.
    ErrorCode               - Returns the error code if the routine returns FALSE.

    Note that length of FileSystemName should be long enough to hold the
    return string.  The maximum length is MAX_FILE_SYSTEM_FORMAT_NAME_LEN.

Return Value:

    TRUE  - Success
    FALSE - Failure

--*/
{
    DSTRING         dos_drive_name, nt_drive_name;
    DSTRING         file_system_name;
    DSTRING         file_system_name_and_version;
    DSTRING         fat_str, fat32_str, ntfs_str;
    PWSTR           fs_name_and_version;

    if (!ErrorCode || !MinorVersion || !MajorVersion ||
        !FileSystemName || !DriveName) {
        if (ErrorCode)
            *ErrorCode = 0;
        return FALSE;
    }

    *ErrorCode = 0;

    if (!fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !ntfs_str.Initialize("NTFS") ||
        !dos_drive_name.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dos_drive_name, &nt_drive_name) ||
        !IFS_SYSTEM::QueryFileSystemName(&nt_drive_name,
                                         &file_system_name,
                                         ErrorCode,
                                         &file_system_name_and_version))
        return FALSE;

    *ErrorCode = 0;

    file_system_name.QueryWSTR(0, TO_END, FileSystemName,
                               MAX_FILE_SYSTEM_FORMAT_VERSION_NAME_LEN);
    if (file_system_name == fat_str) {
        *MajorVersion = *MinorVersion = 0;
    } else if (file_system_name == fat32_str) {
        *MajorVersion = *MinorVersion = 0;
    } else if (file_system_name == ntfs_str) {
        if (file_system_name_and_version == file_system_name) {
            *MajorVersion = (UCHAR)0;
            *MinorVersion = (UCHAR)0;
            return TRUE;
        }
        fs_name_and_version = file_system_name_and_version.QueryWSTR();
        if (!fs_name_and_version)
            return FALSE;

        DWORD dwMajor, dwMinor;

        if (swscanf(fs_name_and_version,
                    L"NTFS %d.%d",
                    &dwMajor,
                    &dwMinor ) != 2) {
            FREE(fs_name_and_version);
            return FALSE;
        } else {
            *MajorVersion = (UCHAR)dwMajor;
            *MinorVersion = (UCHAR)dwMinor;
        }
        FREE(fs_name_and_version);
    } else {
        DebugAbort("Unknown file system\n");
        return FALSE;
    }
    return TRUE;
}

BOOLEAN
QueryLatestFileSystemVersion(
    IN  PWSTR   FileSystemName,
    OUT PUCHAR  MajorVersion,
    OUT PUCHAR  MinorVersion
)
/*++

Routine Description:

    Given the file system, this routine returns the latest
    major and minor version of that file system.

Arguments:

    FileSystemName          - Supplies the name of the file system (FAT, NTFS, FAT32)
    MajorVersion            - Returns the major version number of the FS.
    MinorVersion            - Returns the minor version number of the FS.

Return Value:

    TRUE  - Success
    FALSE - Failure

--*/
{
    BOOLEAN latest;
    ULONG   i;
    WCHAR   fsname[MAX_FILE_SYSTEM_FORMAT_NAME_LEN];

    if (!FileSystemName || !MajorVersion || !MinorVersion)
        return FALSE;

    for(i=0;
        QueryAvailableFileSystemFormat(i,
                                       fsname,
                                       MajorVersion,
                                       MinorVersion,
                                       &latest);
        i++) {
        if (wcscmp(fsname, FileSystemName) == 0 && latest) {
            return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
QueryDeviceInformation(
    IN     PWSTR                                DriveName,
       OUT PFMIFS_DEVICE_INFORMATION            DevInfo,
    IN     ULONG                                DevInfoSize
    )
/*++

Routine Description:

    This routine returns the attributes of a device.

Arguments:

    DriveName               - Supplies the drive name.
    DevInfo                 - Returns the device information.
    DevInfoSize             - Supplies the size of the device info structure.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DP_DRIVE            dpdrive;
    DSTRING             dosdrivename, ntdrivename;

    if (!dosdrivename.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        return FALSE;
    }

    if (!dpdrive.Initialize(&ntdrivename)) {
        return FALSE;
    }

    if (DevInfoSize < sizeof(FMIFS_DEVICE_INFORMATION)) {
        return FALSE;
    }

    DevInfo->Flags = (dpdrive.IsSonyMS() ? (FMIFS_SONY_MS | FMIFS_NTFS_NOT_SUPPORTED) : 0);
    DevInfo->Flags |= (dpdrive.IsSonyMSFmtCmdCapable() ? FMIFS_SONY_MS_FMT_CMD_CAPABLE : 0);
    DevInfo->Flags |= (dpdrive.IsSonyMSProgressIndicatorCapable() ? FMIFS_SONY_MS_PROGRESS_INDICATOR_CAPABLE : 0);
    DevInfo->Flags |= (dpdrive.IsNtfsNotSupported() ? FMIFS_NTFS_NOT_SUPPORTED : 0);

    return TRUE;
}

BOOLEAN
QueryDeviceInformationByHandle(
    IN     HANDLE                               DriveHandle,
       OUT PFMIFS_DEVICE_INFORMATION            DevInfo,
    IN     ULONG                                DevInfoSize
    )
/*++

Routine Description:

    This routine returns the attributes of a device.

Arguments:

    DriveHandle             - Supplies the handle to the volume.
    DevInfo                 - Returns the device information.
    DevInfoSize             - Supplies the size of the device info structure.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    CURRENTLY, THIS ROUTINE ONLY RETURNS THE FMIFS_NTFS_NOT_SUPPORTED FLAG AND
    DOES NOT WORK ON MEMORY STICK.  IF FMIFS_NTFS_NOT_SUPPORTED IS NOT SET ON RETURN,
    USER SHOULD CALL QueryDeviceInformation() AS WELL.

--*/
{
    BOOLEAN     NoNtfsSupport;
    NTSTATUS    status;

    if (DevInfoSize < sizeof(FMIFS_DEVICE_INFORMATION)) {
        return FALSE;
    }

    status = DP_DRIVE::QueryNtfsSupportInfo(DriveHandle, &NoNtfsSupport);

    if (NT_SUCCESS(status)) {
        DevInfo->Flags = (NoNtfsSupport ? FMIFS_NTFS_NOT_SUPPORTED : 0);
    }

    return NT_SUCCESS(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\chkdsk.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
};
#include "fmifsmsg.hxx"
#include "chkmsg.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"
#include "ifsentry.hxx"
#include "system.hxx"
#include "drive.hxx"
#include "rtmsg.h"

// IFMIFS_CHKDSK_ALGORITHM_SPECIFIED
//  - For NTFS, this indicates an algorithm value is specified
//    This bit cannot be used together with FMIFS_CHKDSK_SKIP_INDEX_SCAN

#define IFMIFS_CHKDSK_ALGORITHM_SPECIFIED      0x00000800UL

//
//
// Values related to the above bits
//
#define IFMIFS_CHKDSK_MAX_ALGORITHM_VALUE      50

VOID
Chkdsk(
    IN  PWSTR               DriveName,
    IN  PWSTR               FileSystemName,
    IN  BOOLEAN             Fix,
    IN  BOOLEAN             Verbose,
    IN  BOOLEAN             OnlyIfDirty,
    IN  BOOLEAN             Recover,
    IN  PWSTR               PathToCheck,
    IN  BOOLEAN             Extend,
    IN  FMIFS_CALLBACK      Callback
    )

/*++

Routine Description:

    This routine loads and calls the correct DLL to chkdsk the
    given volume.

    This is is for either GUI or text mode.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    FileSystemName  - Supplies the file system name (e.g., FAT) of the volume
    Fix             - Whether or not to fix detected consistency problems
    Verbose         - Whether to print every filename 
    OnlyIfDirty     - Whether to check consistency only if the volume is dirty
    Recover         - Whether to perform a full sector read test
    PathToCheck     - Supplies a path to check for fragmentation
    Extend          - Whether the volume is being extended
    Callback        - Supplies the necessary call back for
                        communication with the client

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if 0

    // test code

    FMIFS_CHKDSKEX_PARAM   Param;


    Param.Major = 1;
    Param.Minor = 0;
    Param.Flags = Verbose ? CHKDSK_VERBOSE : 0;
    Param.Flags |= OnlyIfDirty ? CHKDSK_CHECK_IF_DIRTY : 0;
    Param.Flags |= Recover ? CHKDSK_RECOVER : 0;
    Param.Flags |= Extend ? CHKDSK_EXTEND : 0;

    ChkdskEx(
        L"\\\\?\\Volume{d4031341-da5e-11d1-93f6-000000000000}\\pretty\\x",
        FileSystemName,
        Fix,
        &Param,
        Callback
        );
#else
    FMIFS_CHKMSG                message;
    DSTRING                     chkdsk_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    CHKDSK_FN                   chkdsk_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;
    PATH                        check_path;
    ULONG                       chkdsk_result;
    DSTRING                     fat32_name;

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (!message.Initialize(Callback) ||
        !chkdsk_string.Initialize("Chkdsk") ||
        !library_name.Initialize("U") ||

        // Intercept the FAT32 file system name string and convert it into
        // FAT.

        !file_system_name.Initialize(FileSystemName) ||
        !fat32_name.Initialize("FAT32") ||
        !file_system_name.Strupr() ||
        (file_system_name == fat32_name ? !file_system_name.Initialize("FAT") : FALSE) ||
        !library_name.Strcat(&file_system_name) ||
        !(chkdsk_function = (CHKDSK_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &chkdsk_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        (NULL != PathToCheck && !check_path.Initialize(PathToCheck)) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename))
    {
        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    // Call chkdsk.

    message.SetLoggingEnabled();

    message.Set(MSG_CHK_RUNNING);
    message.Log("%W", &dosdrivename);

    result = chkdsk_function(&ntdrivename,
                             &message,
                             Fix,
                             Verbose,
                             OnlyIfDirty,
                             Recover,
                             (NULL == PathToCheck) ? NULL : &check_path,
                             Extend,
                             FALSE,
                             0,
                             &chkdsk_result);

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
#endif
}


VOID
ChkdskEx(
    IN  PWSTR                   DriveName,
    IN  PWSTR                   FileSystemName,
    IN  BOOLEAN                 Fix,
    IN  PFMIFS_CHKDSKEX_PARAM   Param,
    IN  FMIFS_CALLBACK          Callback
    )

/*++

Routine Description:

    This routine loads and calls the correct DLL to chkdsk the
    given volume.

    This is for either GUI or text mode.

Arguments:

    DriveName       - Supplies the DOS style drive name optionally with a path
    FileSystemName  - Supplies the file system name (e.g., FAT) of the volume
    Fix             - Whether or not to fix detected consistency problems
    Param           - Supplies the parameter block (see fmifs.h for details)
    Callback        - Supplies the necessary call back for
                        communication with the client

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_CHKMSG                message;
    DSTRING                     chkdsk_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    CHKDSKEX_FN                 chkdsk_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;
    PATH                        fullpath;
    PATH                        drivepath;
    DSTRING                     drive_path_string;
    BOOLEAN                     is_drivepath_invalid;
    PATH_ANALYZE_CODE           rst;
    ULONG                       chkdsk_result;
    DSTRING                     fat32_name;
    CHKDSKEX_FN_PARAM           param;

    //
    // This structure is the internal version of FMIFS_CHKDSKEX_PARAM.
    //
    typedef struct {
        UCHAR   Major;      // initial version is 1.0
        UCHAR   Minor;
        ULONG   Flags;
        USHORT  Algorithm;  // version 1.1
    } IFMIFS_CHKDSKEX_PARAM, *PIFMIFS_CHKDSKEX_PARAM;

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    DebugPrint("FMIFS: Using new ChkdskEx\n");

    if (Param->Major != 1 ||
        (Param->Minor != 0 && Param->Minor != 1) ||
        !message.Initialize(Callback) ||
        !chkdsk_string.Initialize("ChkdskEx") ||
        !library_name.Initialize("U") ||

        // Intercept the FAT32 file system name string and convert it into
        // FAT.

        !file_system_name.Initialize(FileSystemName) ||
        !fat32_name.Initialize("FAT32") ||
        !file_system_name.Strupr() ||
        (file_system_name == fat32_name ? !file_system_name.Initialize("FAT") : FALSE) ||
        !library_name.Strcat(&file_system_name) ||
        !(chkdsk_function = (CHKDSKEX_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &chkdsk_string,
                                           &dll_handle)) ||
        !drivepath.Initialize(DriveName))
    {
        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    rst = drivepath.AnalyzePath(&dosdrivename,
                                &fullpath,
                                &drive_path_string);

    switch (rst) {
        case PATH_OK:
            is_drivepath_invalid = fullpath.IsDrive() ||
                                   (fullpath.GetPathString()->QueryChCount() == 0);

            message.SetLoggingEnabled();

            message.Set(MSG_CHK_RUNNING);
            message.Log("%W", fullpath.GetPathString());

            if (fullpath.GetPathString()->QueryChCount() == 2 &&
                fullpath.GetPathString()->QueryChAt(1) == (WCHAR)':') {
                // if there is a drive letter for this drive, use it
                // instead of the guid volume name
                if (!dosdrivename.Initialize(fullpath.GetPathString())) {
                    finished_info.Success = FALSE;
                    Callback(FmIfsFinished,
                             sizeof(FMIFS_FINISHED_INFORMATION),
                             &finished_info);
                    return;
                }
            }
            if (IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename) &&
                fullpath.AppendString(&drive_path_string) &&
                drivepath.Initialize(&drive_path_string))
                break;

            // fall thru to indicate an error

        default:
            finished_info.Success = FALSE;
            Callback(FmIfsFinished,
                     sizeof(FMIFS_FINISHED_INFORMATION),
                     &finished_info);
            return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

#if ((FMIFS_CHKDSK_VERBOSE != CHKDSK_VERBOSE) || \
     (FMIFS_CHKDSK_RECOVER != CHKDSK_RECOVER) || \
     (FMIFS_CHKDSK_RECOVER_FREE_SPACE != CHKDSK_RECOVER_FREE_SPACE) || \
     (FMIFS_CHKDSK_RECOVER_ALLOC_SPACE != CHKDSK_RECOVER_ALLOC_SPACE) || \
     (FMIFS_CHKDSK_EXTEND != CHKDSK_EXTEND) || \
     (FMIFS_CHKDSK_DOWNGRADE != CHKDSK_DOWNGRADE) || \
     (FMIFS_CHKDSK_ENABLE_UPGRADE != CHKDSK_ENABLE_UPGRADE) || \
     (FMIFS_CHKDSK_CHECK_IF_DIRTY != CHKDSK_CHECK_IF_DIRTY) || \
     (FMIFS_CHKDSK_SKIP_INDEX_SCAN != CHKDSK_SKIP_INDEX_SCAN) || \
     (FMIFS_CHKDSK_SKIP_CYCLE_SCAN != CHKDSK_SKIP_CYCLE_SCAN) || \
     (FMIFS_CHKDSK_FORCE != CHKDSK_FORCE) || \
     (IFMIFS_CHKDSK_MAX_ALGORITHM_VALUE != CHKDSK_MAX_ALGORITHM_VALUE) || \
     (IFMIFS_CHKDSK_ALGORITHM_SPECIFIED != CHKDSK_ALGORITHM_SPECIFIED))

#error FMIFS_CHKDSK_* definition must be the same as that of CHKDSK_*

#endif

    param.Major = 1;
    param.Minor = 1;
    param.Flags = Param->Flags;
    param.PathToCheck = &fullpath;
    param.RootPath    = (is_drivepath_invalid ? NULL : &drivepath);
    param.LogFileSize = 0;
    if (Param->Major > 1 || (Param->Major == 1 && Param->Minor == 1))
        param.Algorithm = ((PIFMIFS_CHKDSKEX_PARAM)Param)->Algorithm;

    // Call chkdsk.

    result = chkdsk_function(&ntdrivename,
                             &message,
                             Fix,
                             &param,
                             &chkdsk_result);

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\label.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
};
#include "ifssys.hxx"
#include "wstring.hxx"

BOOLEAN
SetLabel(
    IN  PWSTR   DriveName,
    IN  PWSTR   Label
    )
/*++

Routine Description:

    This routine sets the label on the given drive.

Arguments:

    DriveName   - Supplies the drive name on which to place the
                    label.
    Label       - Supplies the label.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   length  = sizeof(FILE_FS_LABEL_INFORMATION) + MAX_PATH*sizeof(WCHAR);

    DSTRING                     dosdrivename, ntdrivename;
    UNICODE_STRING              string;
    OBJECT_ATTRIBUTES           oa;
    IO_STATUS_BLOCK             status_block;
    HANDLE                      handle;
    DSTRING                     label;
    PFILE_FS_LABEL_INFORMATION  info;
    STR                         info_buf[length];
    NTSTATUS                    nts;
    BOOLEAN                     result;
    DWORD                       error;

    if (!dosdrivename.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (!(string.Buffer = ntdrivename.QueryWSTR())) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    string.Length = (USHORT) (ntdrivename.QueryChCount()*sizeof(WCHAR));
    string.MaximumLength = string.Length;

    InitializeObjectAttributes( &oa, &string, OBJ_CASE_INSENSITIVE, 0, 0 );

    nts = NtOpenFile(&handle,
                     SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                     &oa, &status_block,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     FILE_SYNCHRONOUS_IO_ALERT | FILE_WRITE_THROUGH);

    if (!NT_SUCCESS(nts)) {

        DELETE(string.Buffer);
        SetLastError(RtlNtStatusToDosError(nts));
        return FALSE;
    }

    DELETE(string.Buffer);

    if (!label.Initialize(Label)) {

        NtClose(handle);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    info =  (PFILE_FS_LABEL_INFORMATION) info_buf;


    label.QueryWSTR(0, TO_END, info->VolumeLabel, length - sizeof(ULONG));

    info->VolumeLabelLength = label.QueryChCount()*sizeof(WCHAR);

    nts = NtSetVolumeInformationFile(
            handle, &status_block, info, length, FileFsLabelInformation);

    if (!NT_SUCCESS(nts)) {

        result = FALSE;
        error = RtlNtStatusToDosError(nts);

        // Remap ERROR_LABEL_TOO_LONG, since its message text is
        // misleading.
        //
        if( error == ERROR_LABEL_TOO_LONG ) {

            error = ERROR_INVALID_NAME;
        }

        SetLastError(error);

    } else {

        result = TRUE;
    }

    NtClose(handle);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\extend.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
};
#include "fmifsmsg.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"
#include "ifsentry.hxx"
#include "system.hxx"
#include "drive.hxx"


VOID
Extend(
    IN  PWSTR               DriveName,
    IN  BOOLEAN             Verify,
    IN  FMIFS_CALLBACK      Callback
    )

/*++

Routine Description:

    This routine loads and calls the correct DLL to extend the
    given volume.  Currently only NTFS can do this.

	This is is for either GUI or text mode.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    Verify          - Whether or not to verify the extended space
    Callback        - Supplies the necessary call back for
                        communication with the client

Return Value:

    None.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     extend_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    EXTEND_FN                   extend_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (!message.Initialize(Callback) ||
        !extend_string.Initialize("Extend") ||
        !library_name.Initialize("U") ||
        !file_system_name.Initialize("NTFS") ||
        !library_name.Strcat(&file_system_name) ||
        !(extend_function = (EXTEND_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &extend_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename))
    {
        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    // Call chkdsk.

    result = extend_function(&ntdrivename,
                             &message,
                             Verify
                             );

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\fmifsmsg.cxx ===
#include "ulib.hxx"
#include "fmifsmsg.hxx"
#include "rtmsg.h"


DEFINE_CONSTRUCTOR(FMIFS_MESSAGE, MESSAGE);


FMIFS_MESSAGE::~FMIFS_MESSAGE(
    )
/*++

Routine Description:

    Destructor for FMIFS_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
FMIFS_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _callback = NULL;
    _kilobytes_total_disk_space = 0;
    _values_in_mb = 0;
}


VOID
FMIFS_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _callback = NULL;
    _kilobytes_total_disk_space = 0;
}


BOOLEAN
FMIFS_MESSAGE::Initialize(
    IN  FMIFS_CALLBACK  CallBack
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    CallBack    - Supplies the callback to the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();
    _callback = CallBack;
    return _callback ? MESSAGE::Initialize() : FALSE;
}


BOOLEAN
FMIFS_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_PERCENT_COMPLETE_INFORMATION  percent_info;
    FMIFS_FORMAT_REPORT_INFORMATION     fmt_report;
    FMIFS_INSERT_DISK_INFORMATION       insert_info;
    FMIFS_IO_ERROR_INFORMATION          io_error_info;
    BOOLEAN                             r = TRUE;
    PWSTRING                            drive_name, file_name;
    ULONG                               unit_bits = 0;

    switch (GetMessageId()) {

        case MSG_PERCENT_COMPLETE:
        case MSG_PERCENT_COMPLETE2: // Should never get this on FORMAT (only CHKDSK)
            percent_info.PercentCompleted = va_arg(VarPointer, ULONG);
            r = _callback(FmIfsPercentCompleted,
                          sizeof(FMIFS_PERCENT_COMPLETE_INFORMATION),
                          &percent_info);
            break;

        case MSG_DCOPY_INSERT_TARGET:
            insert_info.DiskType = DISK_TYPE_TARGET;
            r = _callback(FmIfsInsertDisk,
                          sizeof(FMIFS_INSERT_DISK_INFORMATION),
                          &insert_info);
            break;

        case MSG_DCOPY_INSERT_SOURCE:
            insert_info.DiskType = DISK_TYPE_SOURCE;
            r = _callback(FmIfsInsertDisk,
                          sizeof(FMIFS_INSERT_DISK_INFORMATION),
                          &insert_info);
            break;

        case MSG_DCOPY_INSERT_SOURCE_AND_TARGET:
            insert_info.DiskType = DISK_TYPE_SOURCE_AND_TARGET;
            r = _callback(FmIfsInsertDisk,
                          sizeof(FMIFS_INSERT_DISK_INFORMATION),
                          &insert_info);
            break;

        case MSG_DCOPY_FORMATTING_WHILE_COPYING:
            r = _callback(FmIfsFormattingDestination, 0, NULL);
            break;

        case MSG_DCOPY_BAD_DEST:
            r = _callback(FmIfsIncompatibleMedia, 0, NULL);
            break;

#if 1
        case MSG_DCOPY_NON_COMPAT_DISKS:
            r = _callback(FmIfsIncompatibleMedia, 0, NULL);
            break;
#else
        // MSG_DCOPY_BAD_DEST may need to call a different FmIfs....
        case MSG_DCOPY_NON_COMPAT_DISKS:
            // pop a dialog and ask for retry or cancel
            // TRUE signals CANCEL selected instead of RETRY
            break;
#endif


        case MSG_TOTAL_DISK_SPACE:
            _kilobytes_total_disk_space = va_arg(VarPointer, ULONG)/1024;
            break;

        case MSG_AVAILABLE_DISK_SPACE:
            fmt_report.KiloBytesTotalDiskSpace = _kilobytes_total_disk_space;
            fmt_report.KiloBytesAvailable = va_arg(VarPointer, ULONG)/1024;
            r = _callback(FmIfsFormatReport,
                          sizeof(FMIFS_FORMAT_REPORT_INFORMATION),
                          &fmt_report);
            break;

        case MSG_TOTAL_MEGABYTES:
        case MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_MB:
            unit_bits = TOTAL_DISK_SPACE_IN_MB;

            // fall thru

        case MSG_TOTAL_KILOBYTES:
        case MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_KB:
            _values_in_mb = unit_bits;
            _kilobytes_total_disk_space = va_arg(VarPointer, ULONG);
            break;

        case MSG_AVAILABLE_MEGABYTES:
        case MSG_CHK_NTFS_AVAILABLE_SPACE_IN_MB:
            _values_in_mb |= BYTES_AVAILABLE_IN_MB;

            // fall thru

        case MSG_AVAILABLE_KILOBYTES:
        case MSG_CHK_NTFS_AVAILABLE_SPACE_IN_KB:
            fmt_report.KiloBytesTotalDiskSpace = _kilobytes_total_disk_space;
            fmt_report.KiloBytesAvailable = va_arg(VarPointer, ULONG);
            r = _callback(FmIfsFormatReport,
                          sizeof(FMIFS_FORMAT_REPORT_INFORMATION),
                          &fmt_report);
            break;

        case MSG_DCOPY_WRITE_ERROR:
        case MSG_DCOPY_READ_ERROR:
            io_error_info.DiskType = (GetMessageId() == MSG_DCOPY_READ_ERROR) ?
                                     DISK_TYPE_SOURCE : DISK_TYPE_TARGET;
            va_arg(VarPointer, PVOID);
            io_error_info.Head = va_arg(VarPointer, ULONG);
            io_error_info.Track = va_arg(VarPointer, ULONG);
            r = _callback(FmIfsIoError,
                          sizeof(FMIFS_IO_ERROR_INFORMATION),
                          &io_error_info);
            break;

        case MSG_CANT_LOCK_THE_DRIVE:
            r = _callback(FmIfsCantLock, 0, NULL);
            break;

        case MSG_CANT_UNLOCK_THE_DRIVE:
            // similiar to FmIfsCantLock
            break;

        case MSG_DCOPY_NO_MEDIA_IN_DEVICE:
            drive_name = va_arg(VarPointer, PWSTRING);
            {
                WCHAR wchLetter = drive_name->QueryChAt(0);
                r = _callback(FmIfsNoMediaInDevice, sizeof(WCHAR),
                    (void*) &wchLetter);
            }
            break;

        case MSG_DCOPY_UNRECOGNIZED_MEDIA:
            // pop a dialog and ask for retry or cancel
            // TRUE signals CANCEL selected instead of RETRY
            break;

        case MSG_DASD_ACCESS_DENIED:
            r = _callback(FmIfsAccessDenied, 0, NULL);
            break;

        case MSG_CANT_QUICKFMT:
            r = _callback(FmIfsCantQuickFormat, 0, NULL);
            break;

        case MSG_FMT_TOO_MANY_CLUSTERS:
            r = _callback(FmIfsClustersCountBeyond32bits, 0, NULL);
            break;

        case MSG_DCOPY_MEDIA_WRITE_PROTECTED:
            r = _callback(FmIfsMediaWriteProtected, 0, NULL);
            break;

        case MSG_FMT_WRITE_PROTECTED_MEDIA:
            r = _callback(FmIfsMediaWriteProtected, 0, NULL);
            break;

        case MSG_INVALID_LABEL_CHARACTERS:
            r = _callback(FmIfsBadLabel, 0, NULL);
            break;

        case MSG_HIDDEN_STATUS:
            r = _callback(FmIfsHiddenStatus, 0, NULL);
            break;

#if defined ( DBLSPACE_ENABLED )
        case MSG_DBLSPACE_VOLUME_NOT_CREATED:
            r = _callback(FmIfsDblspaceCreateFailed, 0, NULL);
            break;

        case MSG_DBLSPACE_CANT_MOUNT:
            r = _callback(FmIfsDblspaceMountFailed, 0, NULL);
            break;

        case MSG_DBLSPACE_CANT_ASSIGN_DRIVE_LETTER:
            r = _callback(FmIfsDblspaceDriveLetterFailed, 0, NULL);
            break;

        case MSG_DBLSPACE_VOLUME_CREATED:
            // Both arguments to this message are PWSTRING's;
            // the first is the drive, the second is the
            // Compressed Volume File name.
            //
            drive_name = va_arg( VarPointer, PWSTRING );
            file_name = va_arg( VarPointer, PWSTRING );
            r = _callback(FmIfsDblspaceCreated,
                          file_name->QueryChCount() * sizeof(WCHAR),
                          (PVOID)file_name->GetWSTR() );
            break;

        case MSG_DBLSPACE_MOUNTED:
            r = _callback(FmIfsDblspaceMounted, 0, NULL);
            break;
#endif // DBLSPACE_ENABLED

        case MSG_FMT_CLUSTER_SIZE_TOO_SMALL:
            r = _callback(FmIfsClusterSizeTooSmall, 0, NULL);
            break;

        case MSG_FMT_CLUSTER_SIZE_TOO_BIG:
            r = _callback(FmIfsClusterSizeTooBig, 0, NULL);
            break;

        case MSG_FMT_VOL_TOO_SMALL:
        case MSG_FMT_VOLUME_TOO_SMALL:
            r = _callback(FmIfsVolumeTooSmall, 0, NULL);
            break;

        case MSG_FMT_VOL_TOO_BIG:
            r = _callback(FmIfsVolumeTooBig, 0, NULL);
            break;



        default:
            break;
    }

    return r;
}


PMESSAGE
FMIFS_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    PFMIFS_MESSAGE  p;

    if (!(p = NEW FMIFS_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize(_callback)) {
        DELETE(p);
        return NULL;
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\fmifs\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=fmifs
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib    \
           ..\..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
           ..\..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib  \
           ..\..\..\ufat\src\$(ALT_PROJECT)\$(O)\ufat.lib

USE_MSVCRT=1

DLLENTRY=InitializeFmIfs

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\fmifsmsg.cxx \
        ..\format.cxx \
        ..\label.cxx \
        ..\diskcopy.cxx \
        ..\fmifs.rc \
        ..\fmifs.cxx \
        ..\chkdsk.cxx \
        ..\chkmsg.cxx \
        ..\extend.cxx


INCLUDES=..\..\inc;..\..\..\ulib\inc;..\..\..\ifsutil\inc;..\..\..\ufat\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

UMTYPE=windows
DLLDEF=..\fmifs.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\format\format.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

        format.cxx

Abstract:

        Utility to format a disk

Author:

        Norbert P. Kusters (norbertk) 12-April-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "drive.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "system.hxx"
#include "ifssys.hxx"
#include "ulibcl.hxx"
#include "ifsentry.hxx"
#include "path.hxx"
#include "parse.hxx"
#include "hmem.hxx"
#include "volume.hxx"

extern "C" {
    #include "nturtl.h"
}

VOID
DisplayFormatUsage(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine outputs usage information on format.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    None.

--*/
{
    Message->Set(MSG_FORMAT_INFO);
    Message->Display("");
    Message->Set(MSG_FORMAT_COMMAND_LINE_1);
    Message->Display("");
    Message->Set(MSG_FORMAT_COMMAND_LINE_2);
    Message->Display("");
#if defined(FE_SB) && defined(_X86_)
    if(!IsPC98_N()) {
#endif
        Message->Set(MSG_FORMAT_COMMAND_LINE_3);
        Message->Display("");
#if defined(FE_SB) && defined(_X86_)
    }
#endif
    Message->Set(MSG_FORMAT_COMMAND_LINE_4);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_V);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_Q);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_C);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_X);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_F);
    Message->Display("");
//    Message->Set(MSG_FORMAT_SUPPORTED_SIZES);
//    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_T);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_N);
    Message->Display("");
#if defined(FE_SB) && defined(_X86_)
    if(!IsPC98_N()) {
#endif
//        Message->Set(MSG_FORMAT_SLASH_1);
//        Message->Display("");
//        Message->Set(MSG_FORMAT_SLASH_4);
//        Message->Display("");
//        Message->Set(MSG_FORMAT_SLASH_8);
//        Message->Display("");
#if defined(FE_SB) && defined(_X86_)
    }
#endif
}


BOOLEAN
DetermineMediaType(
    OUT     PMEDIA_TYPE     MediaType,
    IN OUT  PMESSAGE        Message,
    IN      BOOLEAN         Request160,
    IN      BOOLEAN         Request180,
    IN      BOOLEAN         Request320,
    IN      BOOLEAN         Request360,
    IN      BOOLEAN         Request720,
    IN      BOOLEAN         Request1200,
    IN      BOOLEAN         Request1440,
    IN      BOOLEAN         Request2880,
    IN      BOOLEAN         Request20800
#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.12.1994 SFT KMR
    // Add Request640 on to the parmeter of DetermineMediaType()
    // Add Request1232 on to the parmeter of DetermineMediaType()
   ,IN       BOOLEAN         Request256
   ,IN       BOOLEAN         Request640
   ,IN       BOOLEAN         Request1232
#endif
    )
/*++

Routine Description:

    This routine determines the media type to format to.

Arguments:

    MediaType       - Supplies the current media type and returns
                        a new media type.
    Message         - Supplies an outlet for messages.
    Request160      - Supplies whether or not the user wished to format 160.
    Request180      - Supplies whether or not the user wished to format 180.
    Request320      - Supplies whether or not the user wished to format 320.
    Request360      - Supplies whether or not the user wished to format 360.
    Request720      - Supplies whether or not the user wished to format 720.
    Request1200     - Supplies whether or not the user wished to format 1200.
    Request1440     - Supplies whether or not the user wished to format 1440.
    Request2880     - Supplies whether or not the user wished to format 2880.
    Request20800    - Supplies whether or not the use wished to format 20800.
#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.12.1994 SFT KMR
    Request256      - Supplies whether or not the user wished to format 256. --NEC--
    // Add Request640 on to the parmeter of DetermineMediaType()
    Request640      - Supplies whether or not the user wished to format 640.
    // Add Request1232 on to the parmeter of DetermineMediaType()
    Request1232      - Supplies whether or not the user wished to format 1232.
#endif

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    INT sum;

    // First, normalize all of the booleans.

    if (Request160) {
        Request160 = 1;
        *MediaType = F5_160_512;
    }

    if (Request180) {
        Request180 = 1;
        *MediaType = F5_180_512;
    }

#if defined(FE_SB) && (_X86_)
    if (Request256) {
        Request256 = 1;
        *MediaType = F8_256_128;
    }
#endif

    if (Request320) {
        Request320 = 1;
        *MediaType = F5_320_512;
    }

    if (Request360) {
        Request360 = 1;
        *MediaType = F5_360_512;
    }

#if defined(FE_SB) && (_X86_)
    if (Request640) {
        Request640 = 1;
        *MediaType = F5_640_512;
    }
#endif

    if (Request720) {
        Request720 = 1;
        *MediaType = F3_720_512;
    }

    if (Request1200) {
        Request1200 = 1;
        *MediaType = F5_1Pt2_512;
    }

#if defined(FE_SB) && (_X86_)
    if (Request1232) {
        Request1232 = 1;
        *MediaType = F5_1Pt23_1024;
    }
#endif

    if (Request1440) {
        Request1440 = 1;
        *MediaType = F3_1Pt44_512;
    }

    if (Request2880) {
        Request2880 = 1;
        *MediaType = F3_2Pt88_512;
    }

    if (Request20800) {
        Request20800 = 1;
        *MediaType = F3_20Pt8_512;
    }

    sum = Request160 +
          Request180 +
#if defined(FE_SB) && defined(_X86_)
          Request256 +
#endif
          Request320 +
          Request360 +
#if defined(FE_SB) && defined(_X86_)
          Request640 +
#endif
          Request720 +
          Request1200 +
#if defined(FE_SB) && defined(_X86_)
          Request1232 +
#endif
          Request1440 +
          Request2880 +
          Request20800;

    if (sum > 1) {

        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display();
        return FALSE;
    }

    if (sum == 0) {
        *MediaType = Unknown;
    }

    return TRUE;
}

int __cdecl
main(
    )
/*++

Routine Description:

    This routine is the main procedure for format.  This routine
    parses the arguments, determines the appropriate file system,
    and invokes the appropriate version of format.

    The arguments accepted by format are:

        /fs:fs      - specifies file system to install on volume
        /v:label    - specifies a volume label.
        /q          - specifies a "quick" format.
        /c          - the file system is compressed.
        /f:size     - specifies the size of the floppy disk to format
        /t          - specifies the number of tracks per disk side
        /n          - specifies the number of sectors per track
        /1          - formats a single side of a floppy
        /4          - formats a 360K floppy in a high density drive
        /8          - formats eight sectors per track
        /backup     - refrain from prompting the user

Arguments:

    None.

Return Value:

    0   - Success.
    1   - Failure.
    4   - Fatal error
    5   - User pressed N to stop formatting

--*/
{
    STREAM_MESSAGE      msg;
    PMESSAGE            message;
    MEDIA_TYPE          media_type, cmd_line_media_type;
    DSTRING             dosdrivename;
    DSTRING             displaydrivename;
    DSTRING             arg_fsname;
    DSTRING             arg_label;
    BOOLEAN             label_spec;
    BOOLEAN             quick_format;
    BOOLEAN             compressed;
    BOOLEAN             force_mode;
    INT                 errorlevel;
    DSTRING             ntdrivename;
    DSTRING             fsname;
    DSTRING             fsNameAndVersion;
    DSTRING             currentdrive;
    DSTRING             raw_str;
    DSTRING             fat_str;
    DSTRING             fat32_str;
    DSTRING             ntfs_str;
    DSTRING             hpfs_str;
    PWSTRING            old_volume_label = NULL;
    PATH                dos_drive_path;
    VOL_SERIAL_NUMBER   old_serial;
    DSTRING             user_old_label;
    DSTRING             null_string;
    BOOLEAN             do_format;
    BOOLEAN             do_floppy_return;
    DSTRING             LibSuffix;
    DSTRING             LibraryName;
    HANDLE              FsUtilityHandle = NULL;
    DSTRING             FormatString;
    FORMATEX_FN         Format = NULL;
    DRIVE_TYPE          drive_type;
    BIG_INT             bigint;
    NTSTATUS            Status;
    DWORD               OldErrorMode;
    ULONG               cluster_size;
    BOOLEAN             no_prompts;
    BOOLEAN             force_dismount;
    BOOLEAN             old_fs = TRUE;
    FORMATEX_FN_PARAM   Param;
    BOOLEAN             writeable;

#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.14.1994 SFT KMR
    // Add the value to use the process to judge for 5inci or 3.5inch

    PCDRTYPE            nt_media_types;
    INT                 num_types;
    INT                 i;
    // FMR Oct.07.1994 SFT YAM
    // Add the flag check whether unformat-disk.
    INT             Unknown_flag = FALSE;

    InitializeMachineData();
#endif

    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {
        return 4;
    }

    if( !null_string.Initialize( "" ) ) {
        return 4;
    }

    if (!ParseArguments(&msg, &cmd_line_media_type, &dosdrivename, &displaydrivename,
                        &arg_label, &label_spec, &arg_fsname, &quick_format,
                        &force_mode, &cluster_size, &compressed, &no_prompts,
                        &force_dismount, &errorlevel )) {

        return errorlevel;
    }

    if (force_mode) {
        force_dismount = TRUE;  // don't ask the user; just do it
        if (!label_spec) {      // if no label is specified, assume it's empty
            if (!arg_label.Initialize("")) {
                return 4;
            }
            label_spec = TRUE;
        }
    }

    message = &msg;

    if (!hpfs_str.Initialize("HPFS")) {
        return 4;
    }

    if (arg_fsname == hpfs_str) {
        message->Set(MSG_HPFS_NO_FORMAT);
        message->Display("");
        return 1;
    }

    // Disable popups while we determine the drive type.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    drive_type = SYSTEM::QueryDriveType(&dosdrivename);

    // Re-enable harderror popups.
    SetErrorMode( OldErrorMode );

    switch (drive_type) {
        case UnknownDrive:
            message->Set(MSG_NONEXISTENT_DRIVE);
            message->Display("");
            return 1;

        case RemoteDrive:
            message->Set(MSG_FORMAT_NO_NETWORK);
            message->Display("");
            return 1;

        case RamDiskDrive:
            message->Set(MSG_FORMAT_NO_RAMDISK);
            message->Display("");
            return 1;

        default:
            break;

    }

    if (!SYSTEM::QueryCurrentDosDriveName(&currentdrive) ||
        currentdrive == dosdrivename) {

        message->Set(MSG_CANT_LOCK_CURRENT_DRIVE);
        message->Display();
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {
        return 4;
    }

    if (!raw_str.Initialize("RAW") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !ntfs_str.Initialize("NTFS")) {

        return 4;
    }

    for (;;) {

        DP_DRIVE    dpdrive;

        // ------------------------------------
        // Figure out if the drive is a floppy.
        // ------------------------------------

        if (drive_type == FixedDrive && cmd_line_media_type != Unknown) {
            message->Set(MSG_INCOMPATIBLE_PARAMETERS_FOR_FIXED);
            message->Display("");
            return 1;
        }

        if (drive_type == RemovableDrive && !no_prompts) {
            message->Set(MSG_INSERT_DISK);
            message->Display("%W", &displaydrivename);
            message->Set(MSG_PRESS_ENTER_WHEN_READY);
            message->Display("");
            message->WaitForUserSignal();
        }




        // -----------------------
        // Now get the media type.
        // -----------------------

        // Disable hard-error popups while we initialize the drive.
        // Otherwise, we'll may get the 'unformatted medium' popup,
        // which doesn't make a lot of sense.

        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        if (!dpdrive.Initialize(&ntdrivename, message)) {
            // Re-enable hard-error popups
            SetErrorMode( OldErrorMode );

            return 4;
        }

#if defined(FE_SB) && defined(_X86_)
        // FMR Oct.07.1994 SFT YAM
        // Add the check whether unformat-disk.
        if(dpdrive.QueryMediaType()==Unknown) {
            Unknown_flag = TRUE;
        }

        // FMR Jul.14.1994 SFT KMR
        // Add the process to judge for 5inch or 3.5inch
        // FMR is surport 3.5/5 inch disk drive. System default 2HD.
        // Return 3.5 or 5inch type media. driver used.
        // Search drive list on media type.

        // FJMERGE.16 95/07/13 J.Yamamoto 3mode PC/AT uses.
        //if (IsFMR_N() || IsPC98_N()) {
            if (!(nt_media_types = dpdrive.GetSupportedList(&num_types))) {
                return 4;
            }
            for (i = 0; i < num_types; i++) {
                if ( nt_media_types[i].MediaType == cmd_line_media_type) break;
            }
           if (i == num_types) {
                MEDIA_TYPE alt_media_type;

                switch(cmd_line_media_type) {
                    case F5_1Pt23_1024:
                        alt_media_type = F3_1Pt23_1024;
                        break;
                    case F3_1Pt23_1024:
                        alt_media_type = F5_1Pt23_1024;
                        break;
                    case F5_1Pt2_512:
                        alt_media_type = F3_1Pt2_512;
                        break;
                    case F3_1Pt2_512:
                        alt_media_type = F5_1Pt2_512;
                        break;
                    case F3_720_512:
                        alt_media_type = F5_720_512;
                        break;
                    case F5_720_512:
                        alt_media_type = F3_720_512;
                        break;
                    case F5_640_512:
                        alt_media_type = F3_640_512;
                        break;
                    case F3_640_512:
                        alt_media_type = F5_640_512;
                        break;
                    default:
                        alt_media_type = Unknown;
                        break;
                }
                for (i = 0; i < num_types; i++) {
                    if ( nt_media_types[i].MediaType == alt_media_type){
                        cmd_line_media_type = alt_media_type;
                        break;
                    }
                }
            }
        // FJMERGE.16 95/07/13 J.Yamamoto
        //}
#endif

        // Re-enable hard-error popups
        SetErrorMode( OldErrorMode );

        if (cmd_line_media_type == Unknown) {
            media_type = dpdrive.QueryMediaType();
        } else {
            media_type = cmd_line_media_type;
        }

        if (media_type == Unknown) {

            media_type = dpdrive.QueryRecommendedMediaType();

            if (media_type == Unknown) {
                // This should never happen.
                DebugPrint("No media types supported by this device.\n");
                return 4;
            }
        }

        do_floppy_return = dpdrive.IsFloppy();

        // Disable hard error popups.  This will prevent the file system
        // from throwing up the popup that says 'unformatted medium'.

        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        if (!IFS_SYSTEM::QueryFileSystemName(&ntdrivename, &fsname,
                                             &Status, &fsNameAndVersion)) {

            if( Status == STATUS_ACCESS_DENIED ) {

                message->Set( MSG_DASD_ACCESS_DENIED );
                message->Display( "" );

            } else {

                message->Set( MSG_FS_NOT_DETERMINED );
                message->Display( "%W", &displaydrivename );
            }

            // Re-enable hard error popups.
            SetErrorMode( OldErrorMode );

            return 1;
        }

        // Re-enable hard error popups.
        SetErrorMode( OldErrorMode );

        if (!fsname.Strupr()) {
            message->Set(MSG_FS_NOT_DETERMINED);
            message->Display("%W", &displaydrivename);
            return 4;
        }

        if (drive_type == CdRomDrive) {
            if (0 == ntfs_str.Stricmp( 0 != arg_fsname.QueryChCount() ?
                                          &arg_fsname : &fsname )) {
                message->Set(MSG_FMT_NO_NTFS_ALLOWED);
                message->Display();
                return 1;
            }
        }

        if (dpdrive.IsSonyMS() || dpdrive.IsNtfsNotSupported()) {
            if (0 == ntfs_str.Stricmp( 0 != arg_fsname.QueryChCount() ?
                                       &arg_fsname : &fsname )) {
                message->Set(dpdrive.IsSonyMS() ?
                              MSG_FMT_NO_NTFS_ALLOWED :
                              MSG_FMT_NTFS_NOT_SUPPORTED);
                message->Display();
                return 1;
            }
        }

        if (dpdrive.IsSonyMS()) {

            if (cmd_line_media_type == F3_1Pt44_512) {
                message->Set(MSG_FMT_INVALID_SLASH_F_OPTION);
                message->Display();
                return 1;
            }

            if (0 == fat32_str.Stricmp( 0 != arg_fsname.QueryChCount() ?
                                       &arg_fsname : &fsname )) {
                message->Set(MSG_FMT_NO_FAT32_ALLOWED);
                message->Display();
                return 1;
            }

            if (dpdrive.IsFloppy()) {  // no hw to test this on
                message->Set(MSG_FMT_SONY_MEM_STICK_ON_FLOPPY_NOT_ALLOWED);
                message->Display();
                return 1;
            }
        }

        message->Set(MSG_FILE_SYSTEM_TYPE);
        message->Display("%W", &fsname);

        //
        // If compression is requested, make sure we can compress the
        // indicated file system type (or the current filesystem type,
        // if the user didn't specify one). Compression is not supported
        // for 64k-cluster NTFS volumes.
        //

        if (compressed) {
            if (0 != ntfs_str.Stricmp( 0 != arg_fsname.QueryChCount() ?
                                      &arg_fsname : &fsname )) {

                message->Set(MSG_COMPRESSION_NOT_AVAILABLE);
                message->Display("%W", 0 != arg_fsname.QueryChCount() ?
                                      &arg_fsname : &fsname );
                return 1;
            }
            if (cluster_size > 4096) {
                message->Set(MSG_CANNOT_COMPRESS_HUGE_CLUSTERS);
                message->Display();
                return 1;
            }
        }

        //
        // Determine which IFS library to load.  The IFS
        // utilities for file system xxxx reside in Uxxxx.DLL.
        // If the use specified the file system with the /FS:
        // parameter, use that file system; otherwise, take
        // whatever's already on the disk (returned from
        // SYSTEM::QueryFileSystemName).
        //

        if( !LibraryName.Initialize( "U" ) ) {

                return 4;
        }

        if (!LibSuffix.Initialize(arg_fsname.QueryChCount() ?
                                  &arg_fsname : &fsname) ||
            !LibSuffix.Strupr()) {
            return 4;
        }

        if (LibSuffix == ntfs_str)
            old_fs = FALSE;

        if (fsname != LibSuffix) {
            message->Set(MSG_NEW_FILE_SYSTEM_TYPE);
            message->Display("%W", &LibSuffix);
        } else if (fsname == raw_str) {
            if (dpdrive.IsFloppy()) {
                if (!LibSuffix.Initialize(&fat_str)) {
                    return 4;
                }
                message->Set(MSG_NEW_FILE_SYSTEM_TYPE);
                message->Display("%W", &LibSuffix);
            } else {
                message->Set(MSG_FORMAT_PLEASE_USE_FS_SWITCH);
                message->Display("");
                return 1;
            }
        }

        if (LibSuffix == fat32_str) {

            if(!LibSuffix.Initialize("FAT")) {
                return 4;
            }
            old_fs = FALSE;
        }

        if ( !LibraryName.Strcat( &LibSuffix ) ) {

                return 4;
        }

        if( !FormatString.Initialize( "FormatEx" ) ) {

                return 4;
        }

        if( (Format =
             (FORMATEX_FN)SYSTEM::QueryLibraryEntryPoint( &LibraryName,
                                                          &FormatString,
                                                          &FsUtilityHandle )) ==
             NULL ) {

            message->Set( MSG_FS_NOT_SUPPORTED );
            message->Display( "%s%W", "FORMAT", &LibSuffix );
            message->Set( MSG_BLANK_LINE );
            message->Display( "" );
            return 1;
        }


        if (drive_type != RemovableDrive) {

            // If the volume has a label, prompt the user for it.
            // Note that if we can't get the label, we'll treat it
            // as without a label (since we have to handle unformatted
            // volumes).

            OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

            if( !force_mode &&
                dos_drive_path.Initialize( &dosdrivename) &&
                (old_volume_label =
                    SYSTEM::QueryVolumeLabel( &dos_drive_path,
                                              &old_serial )) != NULL &&
                old_volume_label->Stricmp( &null_string ) != 0 ) {

                // This fixed drive has a label.  To give the user
                // a bit more protection, prompt for the old label:

                message->Set( MSG_ENTER_CURRENT_LABEL );
                message->Display( "%W", &displaydrivename );
                message->QueryStringInput( &user_old_label );

                if( old_volume_label->Stricmp( &user_old_label ) != 0 ) {

                    // Re-enable hard error popups.
                    SetErrorMode( OldErrorMode );

                    message->Set( MSG_WRONG_CURRENT_LABEL );
                    message->Display( "" );

                    DELETE( old_volume_label );

                    return 1;
                }
            }

            // Re-enable hard error popups.
            SetErrorMode( OldErrorMode );

            DELETE( old_volume_label );
            old_volume_label = NULL;
            if (!force_mode) {
                message->Set(MSG_WARNING_FORMAT);
                message->Display("%W", &displaydrivename);
                if (!message->IsYesResponse(FALSE)) {
                    return 5;
                }
            }
        }

        // ------------------------------------
        // Print the formatting <size> message.
        // ------------------------------------

        do_format = (BOOLEAN) (media_type != dpdrive.QueryMediaType());

        switch (media_type) {
            case F5_160_512:
            case F5_180_512:
            case F5_320_512:
            case F5_360_512:
            case F3_720_512:
#if defined (FE_SB) && defined(_X86_)
            // FMR Jul.12.1994 SFT KMR
            // Modify the process to be display
            // when formating 640KB and 5inch's 720KB disk
            case F8_256_128:
            case F5_640_512:
            case F3_640_512:
            case F5_720_512:
#endif
                if (quick_format) {
                    message->Set(MSG_QUICKFORMATTING_KB);
                } else if (do_format) {
                    message->Set(MSG_FORMATTING_KB);
                } else {
                    message->Set(MSG_VERIFYING_KB);
                }
                break;

            case F5_1Pt2_512:
            case F3_1Pt44_512:
            case F3_2Pt88_512:
            case F3_20Pt8_512:
#if defined(FE_SB) && defined(_X86_)
            // FMR Jul.12.1994 SFT KMR
            // Modify the process to be display
            // when formating 1.20/1.23MB disk
            case F3_1Pt2_512:
            case F5_1Pt23_1024:
            case F3_1Pt23_1024:
#endif
                if (quick_format) {
                    message->Set(MSG_QUICKFORMATTING_DOT_MB);
                } else if (do_format) {
                    message->Set(MSG_FORMATTING_DOT_MB);
                } else {
                    message->Set(MSG_VERIFYING_DOT_MB);
                }
                break;

            case RemovableMedia:
            case FixedMedia:
            case F3_120M_512:
            case F3_200Mb_512:
            case F3_240M_512:
#if defined(FE_SB) // main():OpticalDisk support
            case F3_128Mb_512:
            case F3_230Mb_512:
#endif
                if (quick_format) {
                    message->Set(MSG_QUICKFORMATTING_MB);
                } else if (do_format) {
                    message->Set(MSG_FORMATTING_MB);
                } else {
                    message->Set(MSG_VERIFYING_MB);
                }
                break;

            case F5_320_1024:
            case Unknown:
                // This can't happen.
                return 4;
        }

        switch (media_type) {
            case F5_160_512:
                message->Display("%d", 160);
                break;

            case F5_180_512:
                message->Display("%d", 180);
                break;

#if defined(FE_SB) && defined(_X86_)
            case F8_256_128:
                message->Display("%d", 256);
                break;
#endif

            case F5_320_512:
                message->Display("%d", 320);
                break;

            case F5_360_512:
                message->Display("%d", 360);
                break;

            case F3_720_512:
#if defined(FE_SB) && defined(_X86_)
            case F5_720_512:
#endif
                message->Display("%d", 720);
                break;

            case F5_1Pt2_512:
#if defined(FE_SB) && defined(_X86_)
            case F3_1Pt2_512:
#endif
                message->Display("%d%d", 1, 2);
                break;

            case F3_1Pt44_512:
                message->Display("%d%d", 1, 44);
                break;

            case F3_2Pt88_512:
                message->Display("%d%d", 2, 88);
                break;

            case F3_20Pt8_512:
                message->Display("%d%d", 20, 8);
                break;

            case RemovableMedia:
            case FixedMedia:
            case F3_120M_512:
            case F3_200Mb_512:
            case F3_240M_512:
#if defined(FE_SB) // main():Optical Disk support
            case F3_128Mb_512:
            case F3_230Mb_512:
#endif
                bigint = dpdrive.QuerySectors()*
                         dpdrive.QuerySectorSize()/
                         1048576;

                DebugAssert(bigint.GetHighPart() == 0);

                message->Display("%d", bigint.GetLowPart());
                break;

            case F5_320_1024:
            case Unknown:
                // This can't happen.
                return 4;

#if defined(FE_SB) && defined(_X86_)
            case F5_640_512:
            case F3_640_512:
                message->Display("%d", 640);
                break;

            case F5_1Pt23_1024:
            case F3_1Pt23_1024:
                if (IsPC98_N()){
                    message->Display("%d%d", 1, 25);
                }
                else{
                    message->Display("%d%d", 1, 23);
                }
                break;
#endif
        }

#if defined (FE_SB) && defined (_X86_)
        // FMR Oct.07.1994 SFT YAM
        // If the sector-size when the last format differ from next format,
        // initialize a hard one-byte of disk.
        // at this time,if next formated disk is unformat-disk,
        // this process is undone.

        ULONG       old_sec_size;
        ULONG       new_sec_size;
        HMEM        hmem;
        PUCHAR      rw_buff;
        LOG_IO_DP_DRIVE *LDpDrive = NEW LOG_IO_DP_DRIVE;
        UCHAR       FirstByte = 0;

        if ((IsPC98_N() && drive_type == FixedDrive) ?
            !hmem.Acquire(dpdrive.QuerySectorSize(), max(dpdrive.QueryAlignmentMask(), dpdrive.QuerySectorSize()-1)) :
            !hmem.Acquire(dpdrive.QuerySectorSize(), dpdrive.QueryAlignmentMask())) {
            message->Set(MSG_INSUFFICIENT_MEMORY);
            message->Display();
            return 1;
        }
        rw_buff = (PUCHAR)hmem.GetBuf();

        if(drive_type == RemovableDrive && !no_prompts) {
            if(Unknown_flag == FALSE) {
                old_sec_size = dpdrive.QuerySectorSize();

                if(cmd_line_media_type == F5_1Pt23_1024 || cmd_line_media_type == F3_1Pt23_1024) {
                    new_sec_size = 1024;
                }
                else {
                    new_sec_size = 512;
                }

                if(new_sec_size != old_sec_size) {
                    // PC98 Sep.25.1995 UPDATE
                    // When LDpDrive is fales to initialize,
                    // we don't have to use LDpDrive.
                    if( LDpDrive->Initialize(&ntdrivename,message,TRUE)){
                        LDpDrive->Read(0,1,rw_buff);
                        FirstByte = rw_buff[0];
                        rw_buff[0] = 0;
                        LDpDrive->Write(0,1,rw_buff);
                    }
                }
            }
        }
        else {
            if (IsFMR_N()) {
                if(LibSuffix.Stricmp(&fsname)) {
                    LDpDrive->Initialize(&ntdrivename,message,TRUE);
                    LDpDrive->Read(0,1,rw_buff);
                    FirstByte = rw_buff[0];
                    rw_buff[0] = 0;
                    LDpDrive->Write(0,1,rw_buff);
                }
            }
        }

        // PC98 Sep.25.1995 ADD
        // If the sector-size when the last format differ from next format,
        // initialize a hard one-byte of disk.
        // at this time,if next formated disk is unformat-disk,
        // this process is undone.

        if( IsPC98_N() ){
            if( drive_type == FixedDrive && Unknown_flag == FALSE &&
                dpdrive.QuerySectorSize()!=dpdrive.QueryPhysicalSectorSize()){
                if( LDpDrive->Initialize(&ntdrivename,message,TRUE)){
                    LDpDrive->Read(0,1,rw_buff);
                    FirstByte = rw_buff[0];
                    rw_buff[0] = 0;
                    LDpDrive->Write(0,1,rw_buff);
                }
            }
        }

        DELETE( LDpDrive );
#endif

        // Disable hard-error popups.
        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        Param.Major = 1;
        Param.Minor = 0;
        Param.Flags = (quick_format ? FORMAT_QUICK : 0) |
                      (old_fs ? FORMAT_BACKWARD_COMPATIBLE : 0) |
                      (force_dismount ? FORMAT_FORCE : 0) |
                      (force_mode ? FORMAT_YES : 0);
        Param.LabelString = (label_spec ? &arg_label : NULL);
        Param.ClusterSize = cluster_size;


        if( !Format( &ntdrivename,
                     message,
                     &Param,
                     media_type
                   ) ) {

#if defined (FE_SB) && defined (_X86_)
            if (FirstByte) {
                LOG_IO_DP_DRIVE *LDpDrive = NEW LOG_IO_DP_DRIVE;
                if( LDpDrive->Initialize(&ntdrivename,message,TRUE)){
                    rw_buff[0] = FirstByte;
                    LDpDrive->Write(0,1,rw_buff);
                }
                DELETE( LDpDrive );
            }
#endif

            // Enable hard-error popups.
            SetErrorMode( OldErrorMode );

            SYSTEM::FreeLibraryHandle( FsUtilityHandle );
            return 4;
        }

        // Enable hard-error popups.
        SetErrorMode( OldErrorMode );


        SYSTEM::FreeLibraryHandle( FsUtilityHandle );


        if (do_floppy_return && !no_prompts) {
            message->Set(quick_format ? MSG_QUICKFMT_ANOTHER : MSG_FORMAT_ANOTHER);
            message->Display("");
            if (!message->IsYesResponse(FALSE)) {
                break;
            }
        } else {
            break;
        }
    }


    // Make sure that the file system is installed.

    if (!do_floppy_return &&
        !IFS_SYSTEM::IsFileSystemEnabled(&LibSuffix)) {

        message->Set(MSG_FMT_INSTALL_FILE_SYSTEM);
        message->Display("%W", &LibSuffix);
        if (message->IsYesResponse(TRUE)) {
            if (!IFS_SYSTEM::EnableFileSystem(&LibSuffix)) {
                message->Set(MSG_FMT_CANT_INSTALL_FILE_SYSTEM);
                message->Display();
                return 1;
            }

            message->Set(MSG_FMT_FILE_SYSTEM_INSTALLED);
            message->Display();
        }
    }

    if (compressed && !IFS_SYSTEM::EnableVolumeCompression(&ntdrivename)) {
        message->Set(MSG_CANNOT_ENABLE_COMPRESSION);
        message->Display();

        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\help\makefile.inc ===
msg.h msg.rc msg00001.bin: msg.mc
    mc -v msg.mc

$(NTTARGETFILE0): msg.rc msg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\format\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=format
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\parse.cxx ..\format.cxx ..\format.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF

TARGETLIBS=     \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\inc\bootreg.h ===
#include <nt.h>
#include <ntrtl.h>

ULONG
CharsInMultiString(
    IN PWSTR pw
    );

BOOLEAN
QueryAutocheckEntries(
    OUT PVOID   Buffer,
    IN  ULONG   BufferSize
    );

BOOLEAN
SaveAutocheckEntries(
    IN  PVOID   Value
    );

BOOLEAN
QueryTimeOutValue(
    OUT PULONG  TimeOut
    );

BOOLEAN
SetTimeOutValue(
    IN  ULONG   TimeOut
    );

NTSTATUS
QuerySystemPartitionValue(
    OUT PVOID   Buffer,
    IN  ULONG   BufferSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\format\parse.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "error.hxx"
#include "drive.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "system.hxx"
#include "ifssys.hxx"
#include "ulibcl.hxx"
#include "ifsentry.hxx"
#include "path.hxx"
#include "parse.hxx"

extern "C" {
    #include "nturtl.h"
}

BOOLEAN
ParseArguments(
    IN OUT  PMESSAGE    Message,
    OUT     PMEDIA_TYPE MediaType,
    OUT     PWSTRING    DosDriveName,
    OUT     PWSTRING    DisplayDriveName,
    OUT     PWSTRING    Label,
    OUT     PBOOLEAN    IsLabelSpeced,
    OUT     PWSTRING    FileSystemName,
    OUT     PBOOLEAN    QuickFormat,
    OUT     PBOOLEAN    ForceMode,
    OUT     PULONG      ClusterSize,
    OUT     PBOOLEAN    Compress,
    OUT     PBOOLEAN    NoPrompts,
    OUT     PBOOLEAN    ForceDismount,
    OUT     PINT        ErrorLevel
    )
{
    PWSTRING            pwstring;
    BOOLEAN             req160;
    BOOLEAN             req180;
    BOOLEAN             req320;
    BOOLEAN             req360;
    BOOLEAN             req720;
    BOOLEAN             req1200;
    BOOLEAN             req1440;
    BOOLEAN             req2880;
    BOOLEAN             req20800;
#if defined(FE_SB) && defined(_X86_)
    BOOLEAN             req256 = FALSE;
    BOOLEAN             req640 = FALSE;
    BOOLEAN             req1232 = FALSE;
#endif
    DSTRING             tmp_string;
    ULONG               v;

    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    PSTRING_ARGUMENT    progname = NULL;
    PFLAG_ARGUMENT      dummyv = NULL;
    PFLAG_ARGUMENT      dummyu = NULL;
    PPATH_ARGUMENT      drive = NULL;
    PFLAG_ARGUMENT      quick = NULL;
    PFLAG_ARGUMENT      compress = NULL;
    PFLAG_ARGUMENT      force = NULL;       // dangerous option not to be documented
    PFLAG_ARGUMENT      null_label = NULL;
    PSTRING_ARGUMENT    label = NULL;
    PFLAG_ARGUMENT      f160 = NULL;
    PFLAG_ARGUMENT      f160k = NULL;
    PFLAG_ARGUMENT      f160kb = NULL;
    PFLAG_ARGUMENT      f180 = NULL;
    PFLAG_ARGUMENT      f180k = NULL;
    PFLAG_ARGUMENT      f180kb = NULL;
    PFLAG_ARGUMENT      f320 = NULL;
    PFLAG_ARGUMENT      f320k = NULL;
    PFLAG_ARGUMENT      f320kb = NULL;
    PFLAG_ARGUMENT      f360 = NULL;
    PFLAG_ARGUMENT      f360k = NULL;
    PFLAG_ARGUMENT      f360kb = NULL;
#if defined(FE_SB) && defined(_X86_)
    PFLAG_ARGUMENT      f256 = NULL;
    PFLAG_ARGUMENT      f256k = NULL;
    PFLAG_ARGUMENT      f256kb = NULL;
#endif
    PFLAG_ARGUMENT      f720 = NULL;
    PFLAG_ARGUMENT      f720k = NULL;
    PFLAG_ARGUMENT      f720kb = NULL;
    PFLAG_ARGUMENT      f1200 = NULL;
    PFLAG_ARGUMENT      f1200k = NULL;
    PFLAG_ARGUMENT      f1200kb = NULL;
    PFLAG_ARGUMENT      f12 = NULL;
    PFLAG_ARGUMENT      f12m = NULL;
    PFLAG_ARGUMENT      f12mb = NULL;
#if defined(FE_SB) && defined(_X86_)
    PFLAG_ARGUMENT      f1250 = NULL;
    PFLAG_ARGUMENT      f1250k = NULL;
    PFLAG_ARGUMENT      f1250kb = NULL;
    PFLAG_ARGUMENT      f125 = NULL;
    PFLAG_ARGUMENT      f125m = NULL;
    PFLAG_ARGUMENT      f125mb = NULL;
    PFLAG_ARGUMENT      f1 = NULL;
    PFLAG_ARGUMENT      f1m = NULL;
    PFLAG_ARGUMENT      f1mb = NULL;
#endif
    PFLAG_ARGUMENT      f1440 = NULL;
    PFLAG_ARGUMENT      f1440k = NULL;
    PFLAG_ARGUMENT      f1440kb = NULL;
    PFLAG_ARGUMENT      f144 = NULL;
    PFLAG_ARGUMENT      f144m = NULL;
    PFLAG_ARGUMENT      f144mb = NULL;
    PFLAG_ARGUMENT      f2880 = NULL;
    PFLAG_ARGUMENT      f2880k = NULL;
    PFLAG_ARGUMENT      f2880kb = NULL;
    PFLAG_ARGUMENT      f288 = NULL;
    PFLAG_ARGUMENT      f288m = NULL;
    PFLAG_ARGUMENT      f288mb = NULL;
    PFLAG_ARGUMENT      f208 = NULL;
    PFLAG_ARGUMENT      f208m = NULL;
    PFLAG_ARGUMENT      f208mb = NULL;
#if defined(FE_SB) && defined(_X86_)
    PFLAG_ARGUMENT      f640 = NULL;
    PFLAG_ARGUMENT      f640k = NULL;
    PFLAG_ARGUMENT      f640kb = NULL;

    PFLAG_ARGUMENT      f1232 = NULL;
    PFLAG_ARGUMENT      f1232k = NULL;
    PFLAG_ARGUMENT      f1232kb = NULL;

    PFLAG_ARGUMENT      f123 = NULL;
    PFLAG_ARGUMENT      f123m = NULL;
    PFLAG_ARGUMENT      f123mb = NULL;
#endif
    PFLAG_ARGUMENT      cs512 = NULL;
    PFLAG_ARGUMENT      cs1024 = NULL;
    PFLAG_ARGUMENT      cs2048 = NULL;
    PFLAG_ARGUMENT      cs4096 = NULL;
    PFLAG_ARGUMENT      cs8192 = NULL;
    PFLAG_ARGUMENT      cs16k = NULL;
    PFLAG_ARGUMENT      cs32k = NULL;
    PFLAG_ARGUMENT      cs64k = NULL;
    PFLAG_ARGUMENT      cs128k = NULL;
    PFLAG_ARGUMENT      cs256k = NULL;
    PFLAG_ARGUMENT      one = NULL;
    PFLAG_ARGUMENT      four = NULL;
    PFLAG_ARGUMENT      eight = NULL;
    PLONG_ARGUMENT      secpertrack = NULL;
    PLONG_ARGUMENT      numtracks = NULL;
    PSTRING_ARGUMENT    arg_fs_name = NULL;
    PFLAG_ARGUMENT      helparg = NULL;
    PFLAG_ARGUMENT      no_prompts = NULL;  // dangerous option not to be documented
    PFLAG_ARGUMENT      yes = NULL;         // dangerous option not to be documented
    PFLAG_ARGUMENT      force_dismount = NULL;


    DebugAssert(Message);
    DebugAssert(MediaType);
    DebugAssert(DosDriveName);
    DebugAssert(DisplayDriveName);
    DebugAssert(Label);
    DebugAssert(FileSystemName);
    DebugAssert(QuickFormat);
    DebugAssert(ErrorLevel);
    DebugAssert(NoPrompts);
    DebugAssert(ForceDismount);


#if defined(FE_SB) && defined(_X86_)
    // FMR is surpport 640KB&2HD, non surpport 2D Media.
    // NT format is compatible for DOS format.
    if( IsFMR_N() ) {
        if (!(progname = NEW STRING_ARGUMENT) ||
            !(dummyv = NEW FLAG_ARGUMENT) ||
            !(dummyu = NEW FLAG_ARGUMENT) ||
            !(drive = NEW PATH_ARGUMENT) ||
            !(quick = NEW FLAG_ARGUMENT) ||
            !(compress = NEW FLAG_ARGUMENT) ||
            !(force = NEW FLAG_ARGUMENT) ||
            !(null_label = NEW FLAG_ARGUMENT) ||
            !(no_prompts = NEW FLAG_ARGUMENT) ||
            !(yes = NEW FLAG_ARGUMENT) ||
            !(force_dismount = NEW FLAG_ARGUMENT) ||
            !(label = NEW STRING_ARGUMENT) ||
            !(f640 = NEW FLAG_ARGUMENT) ||
            !(f640k = NEW FLAG_ARGUMENT) ||
            !(f640kb = NEW FLAG_ARGUMENT) ||
            !(f720 = NEW FLAG_ARGUMENT) ||
            !(f720k = NEW FLAG_ARGUMENT) ||
            !(f720kb = NEW FLAG_ARGUMENT) ||
            !(f1200 = NEW FLAG_ARGUMENT) ||
            !(f1200k = NEW FLAG_ARGUMENT) ||
            !(f1200kb = NEW FLAG_ARGUMENT) ||
            // Add the 2HD_check on to the ParseArguments()
            !(f1232 = NEW FLAG_ARGUMENT) ||
            !(f1232k = NEW FLAG_ARGUMENT) ||
            !(f1232kb = NEW FLAG_ARGUMENT) ||
            !(f12 = NEW FLAG_ARGUMENT) ||
            !(f12m = NEW FLAG_ARGUMENT) ||
            !(f12mb = NEW FLAG_ARGUMENT) ||
            // Add the 2HD_check on to the ParseArguments()
            !(f123 = NEW FLAG_ARGUMENT) ||
            !(f123m = NEW FLAG_ARGUMENT) ||
            !(f123mb = NEW FLAG_ARGUMENT) ||
            !(f1440 = NEW FLAG_ARGUMENT) ||
            !(f1440k = NEW FLAG_ARGUMENT) ||
            !(f1440kb = NEW FLAG_ARGUMENT) ||
            !(f144 = NEW FLAG_ARGUMENT) ||
            !(f144m = NEW FLAG_ARGUMENT) ||
            !(f144mb = NEW FLAG_ARGUMENT) ||
            !(f2880 = NEW FLAG_ARGUMENT) ||
            !(f2880k = NEW FLAG_ARGUMENT) ||
            !(f2880kb = NEW FLAG_ARGUMENT) ||
            !(f288 = NEW FLAG_ARGUMENT) ||
            !(f288m = NEW FLAG_ARGUMENT) ||
            !(f288mb = NEW FLAG_ARGUMENT) ||
            !(f208 = NEW FLAG_ARGUMENT)) {

            *ErrorLevel = 4;
            return FALSE;
        }
    } else if(IsPC98_N()) {
        if (!(progname = NEW STRING_ARGUMENT) ||
            !(dummyv = NEW FLAG_ARGUMENT) ||
            !(dummyu = NEW FLAG_ARGUMENT) ||
            !(drive = NEW PATH_ARGUMENT) ||
            !(quick = NEW FLAG_ARGUMENT) ||
            !(compress = NEW FLAG_ARGUMENT) ||
            !(force = NEW FLAG_ARGUMENT) ||
            !(null_label = NEW FLAG_ARGUMENT) ||
            !(no_prompts = NEW FLAG_ARGUMENT) ||
            !(yes = NEW FLAG_ARGUMENT) ||
            !(force_dismount = NEW FLAG_ARGUMENT) ||
            !(label = NEW STRING_ARGUMENT) ||
            !(f160 = NEW FLAG_ARGUMENT) ||
            !(f160k = NEW FLAG_ARGUMENT) ||
            !(f160kb = NEW FLAG_ARGUMENT) ||
            !(f180 = NEW FLAG_ARGUMENT) ||
            !(f180k = NEW FLAG_ARGUMENT) ||
            !(f180kb = NEW FLAG_ARGUMENT) ||
            !(f256 = NEW FLAG_ARGUMENT) ||
            !(f256k = NEW FLAG_ARGUMENT) ||
            !(f256kb = NEW FLAG_ARGUMENT) ||
            !(f320 = NEW FLAG_ARGUMENT) ||
            !(f320k = NEW FLAG_ARGUMENT) ||
            !(f320kb = NEW FLAG_ARGUMENT) ||
            !(f360 = NEW FLAG_ARGUMENT) ||
            !(f360k = NEW FLAG_ARGUMENT) ||
            !(f360kb = NEW FLAG_ARGUMENT) ||
            !(f640 = NEW FLAG_ARGUMENT) ||
            !(f640k = NEW FLAG_ARGUMENT) ||
            !(f640kb = NEW FLAG_ARGUMENT) ||
            !(f1232 = NEW FLAG_ARGUMENT) ||
            !(f1232k = NEW FLAG_ARGUMENT) ||
            !(f1232kb = NEW FLAG_ARGUMENT) ||
            !(f123 = NEW FLAG_ARGUMENT) ||
            !(f123m = NEW FLAG_ARGUMENT) ||
            !(f123mb = NEW FLAG_ARGUMENT) ||
            !(f720 = NEW FLAG_ARGUMENT) ||
            !(f720k = NEW FLAG_ARGUMENT) ||
            !(f720kb = NEW FLAG_ARGUMENT) ||
            !(f1200 = NEW FLAG_ARGUMENT) ||
            !(f1200k = NEW FLAG_ARGUMENT) ||
            !(f1200kb = NEW FLAG_ARGUMENT) ||
            !(f12 = NEW FLAG_ARGUMENT) ||
            !(f12m = NEW FLAG_ARGUMENT) ||
            !(f12mb = NEW FLAG_ARGUMENT) ||
            !(f1250 = NEW FLAG_ARGUMENT) ||
            !(f1250k = NEW FLAG_ARGUMENT) ||
            !(f1250kb = NEW FLAG_ARGUMENT) ||
            !(f125 = NEW FLAG_ARGUMENT) ||
            !(f125m = NEW FLAG_ARGUMENT) ||
            !(f125mb = NEW FLAG_ARGUMENT) ||
            !(f1 = NEW FLAG_ARGUMENT) ||
            !(f1m = NEW FLAG_ARGUMENT) ||
            !(f1mb = NEW FLAG_ARGUMENT) ||
            !(f1440 = NEW FLAG_ARGUMENT) ||
            !(f1440k = NEW FLAG_ARGUMENT) ||
            !(f1440kb = NEW FLAG_ARGUMENT) ||
            !(f144 = NEW FLAG_ARGUMENT) ||
            !(f144m = NEW FLAG_ARGUMENT) ||
            !(f144mb = NEW FLAG_ARGUMENT) ||
            !(f2880 = NEW FLAG_ARGUMENT) ||
            !(f2880k = NEW FLAG_ARGUMENT) ||
            !(f2880kb = NEW FLAG_ARGUMENT) ||
            !(f288 = NEW FLAG_ARGUMENT) ||
            !(f288m = NEW FLAG_ARGUMENT) ||
            !(f288mb = NEW FLAG_ARGUMENT) ||
            !(f208 = NEW FLAG_ARGUMENT)) {

            *ErrorLevel = 4;
            return FALSE;
        }
    }else
#endif
    if (!(progname = NEW STRING_ARGUMENT) ||
        !(dummyv = NEW FLAG_ARGUMENT) ||
        !(dummyu = NEW FLAG_ARGUMENT) ||
        !(drive = NEW PATH_ARGUMENT) ||
        !(quick = NEW FLAG_ARGUMENT) ||
        !(compress = NEW FLAG_ARGUMENT) ||
        !(force = NEW FLAG_ARGUMENT) ||
        !(null_label = NEW FLAG_ARGUMENT) ||
        !(no_prompts = NEW FLAG_ARGUMENT) ||
        !(yes = NEW FLAG_ARGUMENT) ||
        !(force_dismount = NEW FLAG_ARGUMENT) ||
        !(label = NEW STRING_ARGUMENT) ||
        !(f160 = NEW FLAG_ARGUMENT) ||
        !(f160k = NEW FLAG_ARGUMENT) ||
        !(f160kb = NEW FLAG_ARGUMENT) ||
        !(f180 = NEW FLAG_ARGUMENT) ||
        !(f180k = NEW FLAG_ARGUMENT) ||
        !(f180kb = NEW FLAG_ARGUMENT) ||
        !(f320 = NEW FLAG_ARGUMENT) ||
        !(f320k = NEW FLAG_ARGUMENT) ||
        !(f320kb = NEW FLAG_ARGUMENT) ||
        !(f360 = NEW FLAG_ARGUMENT) ||
        !(f360k = NEW FLAG_ARGUMENT) ||
        !(f360kb = NEW FLAG_ARGUMENT) ||
#if defined(FE_SB) && defined(_X86_)
        // FMR Jul.13.1994 SFT KMR
        // 3mode PC/AT surpports 640KB&2HD Media.
        // NT format is compatible for DOS format.
        !(f640 = NEW FLAG_ARGUMENT) ||
        !(f640k = NEW FLAG_ARGUMENT) ||
        !(f640kb = NEW FLAG_ARGUMENT) ||
        !(f1232 = NEW FLAG_ARGUMENT) ||
        !(f1232k = NEW FLAG_ARGUMENT) ||
        !(f1232kb = NEW FLAG_ARGUMENT) ||
        !(f123 = NEW FLAG_ARGUMENT) ||
        !(f123m = NEW FLAG_ARGUMENT) ||
        !(f123mb = NEW FLAG_ARGUMENT) ||
#endif
        !(f720 = NEW FLAG_ARGUMENT) ||
        !(f720k = NEW FLAG_ARGUMENT) ||
        !(f720kb = NEW FLAG_ARGUMENT) ||
        !(f1200 = NEW FLAG_ARGUMENT) ||
        !(f1200k = NEW FLAG_ARGUMENT) ||
        !(f1200kb = NEW FLAG_ARGUMENT) ||
        !(f12 = NEW FLAG_ARGUMENT) ||
        !(f12m = NEW FLAG_ARGUMENT) ||
        !(f12mb = NEW FLAG_ARGUMENT) ||
        !(f1440 = NEW FLAG_ARGUMENT) ||
        !(f1440k = NEW FLAG_ARGUMENT) ||
        !(f1440kb = NEW FLAG_ARGUMENT) ||
        !(f144 = NEW FLAG_ARGUMENT) ||
        !(f144m = NEW FLAG_ARGUMENT) ||
        !(f144mb = NEW FLAG_ARGUMENT) ||
        !(f2880 = NEW FLAG_ARGUMENT) ||
        !(f2880k = NEW FLAG_ARGUMENT) ||
        !(f2880kb = NEW FLAG_ARGUMENT) ||
        !(f288 = NEW FLAG_ARGUMENT) ||
        !(f288m = NEW FLAG_ARGUMENT) ||
        !(f288mb = NEW FLAG_ARGUMENT) ||
        !(f208 = NEW FLAG_ARGUMENT)) {

        *ErrorLevel = 4;
        return FALSE;
    }

    if (!(f208m = NEW FLAG_ARGUMENT) ||
        !(f208mb = NEW FLAG_ARGUMENT) ||
        !(cs512 = NEW FLAG_ARGUMENT) ||
        !(cs1024 = NEW FLAG_ARGUMENT) ||
        !(cs2048 = NEW FLAG_ARGUMENT) ||
        !(cs4096 = NEW FLAG_ARGUMENT) ||
        !(cs8192 = NEW FLAG_ARGUMENT) ||
        !(cs16k = NEW FLAG_ARGUMENT) ||
        !(cs32k = NEW FLAG_ARGUMENT) ||
        !(cs64k = NEW FLAG_ARGUMENT) ||
        !(cs128k = NEW FLAG_ARGUMENT) ||
        !(cs256k = NEW FLAG_ARGUMENT) ||
        !(one = NEW FLAG_ARGUMENT) ||
        !(four = NEW FLAG_ARGUMENT) ||
        !(eight = NEW FLAG_ARGUMENT) ||
        !(secpertrack = NEW LONG_ARGUMENT) ||
        !(numtracks = NEW LONG_ARGUMENT) ||
        !(arg_fs_name = NEW STRING_ARGUMENT) ||
        !(helparg = NEW FLAG_ARGUMENT)) {

        *ErrorLevel = 4;
        return FALSE;
    }


    if (!lex_array.Initialize() ||
        !arg_array.Initialize() ||
        !arglex.Initialize(&lex_array)) {

        *ErrorLevel = 4;
        return FALSE;
    }

    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {

        *ErrorLevel = 4;
        return FALSE;
    }


#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.13.1994 SFT KMR
    // FMR is surpport 640KB&2HD, non surpport 2D Media.
    // NT format is compatible for DOS format.
    if ( IsFMR_N() ) {
        if (!progname->Initialize("*") ||
            !dummyv->Initialize("/v") ||
            !dummyu->Initialize("/u") ||
            !drive->Initialize("*") ||
            !quick->Initialize("/q") ||
            !compress->Initialize("/c") ||
            !force->Initialize("/force") ||
            !null_label->Initialize("/v:\"\"") ||
            !label->Initialize("/v:*") ||
            !no_prompts->Initialize("/backup") ||
            !yes->Initialize("/y") ||
            !force_dismount->Initialize("/x") ||
            !f640->Initialize("/f:640") ||
            !f640k->Initialize("/f:640K") ||
            !f640kb->Initialize("/f:640KB") ||
            !f720->Initialize("/f:720") ||
            !f720k->Initialize("/f:720K") ||
            !f720kb->Initialize("/f:720KB") ||
            !f1200->Initialize("/f:1200") ||
            !f1200k->Initialize("/f:1200K") ||
            !f1200kb->Initialize("/f:1200KB") ||
            // Add the 2HD_check on to the ParseArguments()
            !f1232->Initialize("/f:1232") ||
            !f1232k->Initialize("/f:1232K") ||
            !f1232kb->Initialize("/f:1232KB") ||
            !f12->Initialize("/f:1.2") ||
            !f12m->Initialize("/f:1.2M") ||
            !f12mb->Initialize("/f:1.2MB") ||
            // Add the 2HD_check on to the ParseArguments()
            !f123->Initialize("/f:1.23") ||
            !f123m->Initialize("/f:1.23M") ||
            !f123mb->Initialize("/f:1.23MB") ||
            !f1440->Initialize("/f:1440") ||
            !f1440k->Initialize("/f:1440K") ||
            !f1440kb->Initialize("/f:1440KB") ||
            !f144->Initialize("/f:1.44") ||
            !f144m->Initialize("/f:1.44M") ||
            !f144mb->Initialize("/f:1.44MB") ||
            !f2880->Initialize("/f:2880") ||
            !f2880k->Initialize("/f:2880K") ||
            !f2880kb->Initialize("/f:2880KB") ||
            !f288->Initialize("/f:2.88") ||
            !f288m->Initialize("/f:2.88M") ||
            !f288mb->Initialize("/f:2.88MB") ||
            !f208->Initialize("/f:20.8") ||
            !f208m->Initialize("/f:20.8M") ||
            !f208mb->Initialize("/f:20.8MB") ||
            !cs512->Initialize("/a:512") ||
            !cs1024->Initialize("/a:1024") ||
            !cs2048->Initialize("/a:2048") ||
            !cs4096->Initialize("/a:4096") ||
            !cs8192->Initialize("/a:8192") ||
            !cs16k->Initialize("/a:16k") ||
            !cs32k->Initialize("/a:32k") ||
            !cs64k->Initialize("/a:64k") ||
            !cs128k->Initialize("/a:128k") ||
            !cs256k->Initialize("/a:256k") ||
            !one->Initialize("/1") ||
            !four->Initialize("/4") ||
            !eight->Initialize("/8") ||
            !secpertrack->Initialize("/n:*") ||
            !numtracks->Initialize("/t:*") ||
            !arg_fs_name->Initialize("/fs:*") ||
            !helparg->Initialize("/?")) {

            *ErrorLevel = 4;
            return FALSE;
        }
    }
    else if(IsPC98_N()) {
        if (!progname->Initialize("*") ||
            !dummyv->Initialize("/v") ||
            !dummyu->Initialize("/u") ||
            !drive->Initialize("*") ||
            !quick->Initialize("/q") ||
            !compress->Initialize("/c") ||
            !force->Initialize("/force") ||
            !null_label->Initialize("/v:\"\"") ||
            !label->Initialize("/v:*") ||
            !no_prompts->Initialize("/backup") ||
            !yes->Initialize("/y") ||
            !force_dismount->Initialize("/x") ||
            !f160->Initialize("/f:160") ||
            !f160k->Initialize("/f:160K") ||
            !f160kb->Initialize("/f:160KB") ||
            !f180->Initialize("/f:180") ||
            !f180k->Initialize("/f:180K") ||
            !f180kb->Initialize("/f:180KB") ||
            !f256->Initialize("/f:256") ||
            !f256k->Initialize("/f:256K") ||
            !f256kb->Initialize("/f:256KB") ||
            !f320->Initialize("/f:320") ||
            !f320k->Initialize("/f:320K") ||
            !f320kb->Initialize("/f:320KB") ||
            !f360->Initialize("/f:360") ||
            !f360k->Initialize("/f:360K") ||
            !f360kb->Initialize("/f:360KB") ||
            !f640->Initialize("/f:640") ||
            !f640k->Initialize("/f:640K") ||
            !f640kb->Initialize("/f:640KB") ||
            !f720->Initialize("/f:720") ||
            !f720k->Initialize("/f:720K") ||
            !f720kb->Initialize("/f:720KB") ||
            !f1200->Initialize("/f:1200") ||
            !f1200k->Initialize("/f:1200K") ||
            !f1200kb->Initialize("/f:1200KB") ||
            !f12->Initialize("/f:1.2") ||
            !f12m->Initialize("/f:1.2M") ||
            !f12mb->Initialize("/f:1.2MB") ||
            !f1250->Initialize("/f:1250") ||
            !f1250k->Initialize("/f:1250K") ||
            !f1250kb->Initialize("/f:1250KB") ||
            !f125->Initialize("/f:1.25") ||
            !f125m->Initialize("/f:1.25M") ||
            !f125mb->Initialize("/f:1.25MB") ||
            !f1->Initialize("/f:1") ||
            !f1m->Initialize("/f:1M") ||
            !f1mb->Initialize("/f:1MB") ||
            !f1440->Initialize("/f:1440") ||
            !f1440k->Initialize("/f:1440K") ||
            !f1440kb->Initialize("/f:1440KB") ||
            !f144->Initialize("/f:1.44") ||
            !f144m->Initialize("/f:1.44M") ||
            !f144mb->Initialize("/f:1.44MB") ||
            !f2880->Initialize("/f:2880") ||
            !f2880k->Initialize("/f:2880K") ||
            !f2880kb->Initialize("/f:2880KB") ||
            !f288->Initialize("/f:2.88") ||
            !f288m->Initialize("/f:2.88M") ||
            !f288mb->Initialize("/f:2.88MB") ||
            !f208->Initialize("/f:20.8") ||
            !f208m->Initialize("/f:20.8M") ||
            !f208mb->Initialize("/f:20.8MB") ||
            !cs512->Initialize("/a:512") ||
            !cs1024->Initialize("/a:1024") ||
            !cs2048->Initialize("/a:2048") ||
            !cs4096->Initialize("/a:4096") ||
            !cs8192->Initialize("/a:8192") ||
            !cs16k->Initialize("/a:16k") ||
            !cs32k->Initialize("/a:32k") ||
            !cs64k->Initialize("/a:64k") ||
            !cs128k->Initialize("/a:128k") ||
            !cs256k->Initialize("/a:256k") ||
            !one->Initialize("/1") ||
            !four->Initialize("/4") ||
            !eight->Initialize("/8") ||
            !secpertrack->Initialize("/n:*") ||
            !numtracks->Initialize("/t:*") ||
            !arg_fs_name->Initialize("/fs:*") ||
            !helparg->Initialize("/?")) {

            *ErrorLevel = 4;
            return FALSE;
        }
    }else
#endif
    if (!progname->Initialize("*") ||
        !dummyv->Initialize("/v") ||
        !dummyu->Initialize("/u") ||
        !drive->Initialize("*") ||
        !quick->Initialize("/q") ||
        !compress->Initialize("/c") ||
        !force->Initialize("/force") ||
        !null_label->Initialize("/v:\"\"") ||
        !label->Initialize("/v:*") ||
        !no_prompts->Initialize("/backup") ||
        !yes->Initialize("/y") ||
        !force_dismount->Initialize("/x") ||
        !f160->Initialize("/f:160") ||
        !f160k->Initialize("/f:160K") ||
        !f160kb->Initialize("/f:160KB") ||
        !f180->Initialize("/f:180") ||
        !f180k->Initialize("/f:180K") ||
        !f180kb->Initialize("/f:180KB") ||
        !f320->Initialize("/f:320") ||
        !f320k->Initialize("/f:320K") ||
        !f320kb->Initialize("/f:320KB") ||
        !f360->Initialize("/f:360") ||
        !f360k->Initialize("/f:360K") ||
        !f360kb->Initialize("/f:360KB") ||
#if defined(FE_SB) && defined(_X86_)
        // FMR Jul.13.1994 SFT KMR
        // 3mode PC/AT surpports 640KB&2HD Media.
        // NT format is compatible for DOS format.
        !f640->Initialize("/f:640") ||
        !f640k->Initialize("/f:640K") ||
        !f640kb->Initialize("/f:640KB") ||
        !f1232->Initialize("/f:1232") ||
        !f1232k->Initialize("/f:1232K") ||
        !f1232kb->Initialize("/f:1232KB") ||
        !f123->Initialize("/f:1.23") ||
        !f123m->Initialize("/f:1.23M") ||
        !f123mb->Initialize("/f:1.23MB") ||
#endif
        !f720->Initialize("/f:720") ||
        !f720k->Initialize("/f:720K") ||
        !f720kb->Initialize("/f:720KB") ||
        !f1200->Initialize("/f:1200") ||
        !f1200k->Initialize("/f:1200K") ||
        !f1200kb->Initialize("/f:1200KB") ||
        !f12->Initialize("/f:1.2") ||
        !f12m->Initialize("/f:1.2M") ||
        !f12mb->Initialize("/f:1.2MB") ||
        !f1440->Initialize("/f:1440") ||
        !f1440k->Initialize("/f:1440K") ||
        !f1440kb->Initialize("/f:1440KB") ||
        !f144->Initialize("/f:1.44") ||
        !f144m->Initialize("/f:1.44M") ||
        !f144mb->Initialize("/f:1.44MB") ||
        !f2880->Initialize("/f:2880") ||
        !f2880k->Initialize("/f:2880K") ||
        !f2880kb->Initialize("/f:2880KB") ||
        !f288->Initialize("/f:2.88") ||
        !f288m->Initialize("/f:2.88M") ||
        !f288mb->Initialize("/f:2.88MB") ||
        !f208->Initialize("/f:20.8") ||
        !f208m->Initialize("/f:20.8M") ||
        !f208mb->Initialize("/f:20.8MB") ||
        !cs512->Initialize("/a:512") ||
        !cs1024->Initialize("/a:1024") ||
        !cs2048->Initialize("/a:2048") ||
        !cs4096->Initialize("/a:4096") ||
        !cs8192->Initialize("/a:8192") ||
        !cs16k->Initialize("/a:16k") ||
        !cs32k->Initialize("/a:32k") ||
        !cs64k->Initialize("/a:64k") ||
        !cs128k->Initialize("/a:128k") ||
        !cs256k->Initialize("/a:256k") ||
        !one->Initialize("/1") ||
        !four->Initialize("/4") ||
        !eight->Initialize("/8") ||
        !secpertrack->Initialize("/n:*") ||
        !numtracks->Initialize("/t:*") ||
        !arg_fs_name->Initialize("/fs:*") ||
        !helparg->Initialize("/?")) {

        *ErrorLevel = 4;
        return FALSE;
    }

    if (!arg_array.Put(progname) ||
        !arg_array.Put(dummyv) ||
        !arg_array.Put(dummyu) ||
        !arg_array.Put(drive) ||
        !arg_array.Put(quick) ||
        !arg_array.Put(compress) ||
        !arg_array.Put(force) ||
        !arg_array.Put(null_label) ||
        !arg_array.Put(label) ||
        !arg_array.Put(no_prompts) ||
        !arg_array.Put(yes) ||
        !arg_array.Put(force_dismount) ||
        !arg_array.Put(f1440) ||
        !arg_array.Put(f1440k) ||
        !arg_array.Put(f1440kb) ||
        !arg_array.Put(f144) ||
        !arg_array.Put(f144m) ||
        !arg_array.Put(f144mb) ||
        !arg_array.Put(cs512) ||
        !arg_array.Put(cs1024) ||
        !arg_array.Put(cs2048) ||
        !arg_array.Put(cs4096) ||
        !arg_array.Put(cs8192) ||
        !arg_array.Put(cs16k) ||
        !arg_array.Put(cs32k) ||
        !arg_array.Put(cs64k) ||
        !arg_array.Put(cs128k) ||
        !arg_array.Put(cs256k) ||
        !arg_array.Put(secpertrack) ||
        !arg_array.Put(numtracks) ||
        !arg_array.Put(arg_fs_name) ||
        !arg_array.Put(helparg)) {

        *ErrorLevel = 4;
        return FALSE;
    }



    if (!arglex.DoParsing(&arg_array)) {

        Message->Set(MSG_INVALID_PARAMETER);
        Message->Display("%W", pwstring = arglex.QueryInvalidArgument());
        DELETE(pwstring);
        arg_array.DeleteAllMembers();

        *ErrorLevel = 4;
        return FALSE;
    }

    if (helparg->QueryFlag()) {

        DisplayFormatUsage(Message);
        arg_array.DeleteAllMembers();

        *ErrorLevel = 0;
        return FALSE;
    }

    if (drive->IsValueSet()) {

        PPATH               ppath;
        PATH                fullpath;
        DSTRING             drive_path_string;
        PATH_ANALYZE_CODE   rst;

        ppath = drive->GetPath();

#if defined(RUN_ON_NT4)
        if (!DosDriveName->Initialize(ppath->GetPathString())) {
            DebugPrint("Out of memory.\n");
            *ErrorLevel = 1;
            return FALSE;
        }
#endif

#if !defined(RUN_ON_NT4)
        rst = ppath->AnalyzePath(DosDriveName,
                                 &fullpath,
                                 &drive_path_string);

        switch (rst) {
            case PATH_OK:
            case PATH_COULD_BE_FLOPPY:
                if (drive_path_string.QueryChCount() != 0) {
                    Message->Set(MSG_FMT_INVALID_DRIVE_SPEC);
                    Message->Display();
                    *ErrorLevel = 1;
                    return FALSE;
                }
                if (ppath->IsGuidVolName()) {
                    if (!DisplayDriveName->Initialize(DosDriveName)) {
                        DebugPrint("Out of memory.\n");
                        *ErrorLevel = 1;
                        return FALSE;
                    }
                } else {
                    if (!DisplayDriveName->Initialize(fullpath.GetPathString())) {
                        DebugPrint("Out of memory.\n");
                        *ErrorLevel = 1;
                        return FALSE;
                    }
                }
                break;

            case PATH_OUT_OF_MEMORY:
                DebugPrint("Out of memory.\n");
                *ErrorLevel = 1;
                return FALSE;

            case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
                Message->Set(MSG_FMT_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH);
                Message->Display();
                *ErrorLevel = 1;
                return FALSE;

            default:
                Message->Set(MSG_FMT_INVALID_DRIVE_SPEC);
                Message->Display();
                *ErrorLevel = 1;
                return FALSE;
        }
#endif

        if (!DosDriveName->Strupr()) {
            *ErrorLevel = 1;
            return FALSE;
        }

    } else {
        Message->Set(MSG_REQUIRED_PARAMETER);
        Message->Display("");
        arg_array.DeleteAllMembers();

        *ErrorLevel = 1;
        return FALSE;
    }

    if (label->IsValueSet() && null_label->QueryFlag()) {

        Message->Set(MSG_INVALID_PARAMETER);
        Message->Display("%s", "/v:\"\"");

        *ErrorLevel = 4;
        arg_array.DeleteAllMembers();
        return FALSE;
    }

    *IsLabelSpeced = label->IsValueSet() || null_label->QueryFlag();

    if (label->IsValueSet()) {

        if (!Label->Initialize(label->GetString())) {

            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }

    } else {

        if (!Label->Initialize("")) {

            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }
    }


    if (arg_fs_name->IsValueSet()) {

        if (!FileSystemName->Initialize(arg_fs_name->GetString()) ||
            !FileSystemName->Strupr()) {

            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }

        if (FileSystemName->QueryChCount() == 0) {
            Message->Set(MSG_INVALID_PARAMETER);
            Message->Display("%W", arg_fs_name->GetLexeme());
            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }

    } else {

        if (!FileSystemName->Initialize("")) {

            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }

    }


    *NoPrompts = no_prompts->QueryFlag();
    *ForceDismount = force_dismount->QueryFlag();
    *QuickFormat = quick->QueryFlag();
    *ForceMode = force->QueryFlag();

    if (yes->QueryFlag()) {
        *NoPrompts = *ForceMode = TRUE;
    }

    *Compress = compress->QueryFlag();

    if (label->IsValueSet()) {
        if (eight->QueryFlag()) {

            Message->Set(MSG_NO_LABEL_WITH_8);
            Message->Display("");

            *ErrorLevel = 1;
            arg_array.DeleteAllMembers();
            return FALSE;
        }
    }

    v = 0;
    *ClusterSize = 0;

    if (cs512->QueryFlag()) {
        *ClusterSize = 512;
        v++;
    }

    if (cs1024->QueryFlag()) {
        *ClusterSize = 1024;
        v++;
    }

    if (cs2048->QueryFlag()) {
        *ClusterSize = 2048;
        v++;
    }

    if (cs4096->QueryFlag()) {
        *ClusterSize = 4096;
        v++;
    }

    if (cs8192->QueryFlag()) {
        *ClusterSize = 8192;
        v++;
    }

    if (cs16k->QueryFlag()) {
        *ClusterSize = 16*1024;
        v++;
    }

    if (cs32k->QueryFlag()) {
        *ClusterSize = 32*1024;
        v++;
    }

    if (cs64k->QueryFlag()) {
        *ClusterSize = 64*1024;
        v++;
    }

    if (cs128k->QueryFlag()) {
        *ClusterSize = 128*1024;
        v++;
    }

    if (cs256k->QueryFlag()) {
        *ClusterSize = 256*1024;
        v++;
    }

    if (v > 1) {
        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display();

        *ErrorLevel = 4;
        arg_array.DeleteAllMembers();
        return FALSE;
    }


    // -----------------------
    // Compute the media type.
    // -----------------------

#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.13.1994 SFT KMR
    // When /T:80 and /N:8, modify the process to be 640KB's
    // Delete the /F:160,180,320 and 360 process from the ParseArguments()
    // Not surported media 2D.
    // NT format is compatible for DOS format.
    if ( IsFMR_N() ) {
        req160 = FALSE;
        req180 = FALSE;
        req320 = FALSE;
        req360 = FALSE;
    } else {
#endif
    req160 = f160->QueryFlag() || f160k->QueryFlag() || f160kb->QueryFlag();
    req180 = f180->QueryFlag() || f180k->QueryFlag() || f180kb->QueryFlag();
    req320 = f320->QueryFlag() || f320k->QueryFlag() || f320kb->QueryFlag();
    req360 = f360->QueryFlag() || f360k->QueryFlag() || f360kb->QueryFlag();
#if defined(FE_SB) && defined(_X86_)
    }

    if(IsPC98_N()) {
        req256 = f256->QueryFlag() || f256k->QueryFlag() || f256kb->QueryFlag();
    } else {
        req256 = FALSE;
    }

    // FMR, 3mode PC/AT(FMV) and PC98 uses f640,
    // FMR and 3mode PC/AT(FMV) uses f1230,
    // PC98 uses f1250.
    req640 = f640->QueryFlag() || f640k->QueryFlag() || f640kb->QueryFlag();

    if ( IsPC98_N() ) {
        req1232 = f1250->QueryFlag() || f1250k->QueryFlag() || f1250kb->QueryFlag() ||
                  f125->QueryFlag() || f125m->QueryFlag() || f125mb->QueryFlag() ||
                  f1->QueryFlag() || f1m->QueryFlag() || f1mb->QueryFlag();
    } else {
        req1232 = f1232->QueryFlag() || f1232k->QueryFlag() || f1232kb->QueryFlag() ||
                  f123->QueryFlag() || f123m->QueryFlag() || f123mb->QueryFlag();
    }

#endif

    req720 = f720->QueryFlag() || f720k->QueryFlag() || f720kb->QueryFlag();
    req1200 = f1200->QueryFlag() || f1200k->QueryFlag() || f1200kb->QueryFlag() ||
              f12->QueryFlag() || f12m->QueryFlag() || f12mb->QueryFlag();
    req1440 = f1440->QueryFlag() || f1440k->QueryFlag() || f1440kb->QueryFlag() ||
              f144->QueryFlag() || f144m->QueryFlag() || f144mb->QueryFlag();
    req2880 = f2880->QueryFlag() || f2880k->QueryFlag() || f2880kb->QueryFlag() ||
              f288->QueryFlag() || f288m->QueryFlag() || f288mb->QueryFlag();
    req20800 = f208->QueryFlag() || f208m->QueryFlag() || f208mb->QueryFlag();

    if (one->QueryFlag() && four->QueryFlag() && !eight->QueryFlag()) {

        req180 = TRUE;

    } else if (one->QueryFlag() && !four->QueryFlag() && eight->QueryFlag()) {

        req160 = TRUE;

    } else if (!one->QueryFlag() && four->QueryFlag() && !eight->QueryFlag()) {

        req360 = TRUE;

    } else if (!one->QueryFlag() && !four->QueryFlag() && eight->QueryFlag()) {

        req320 = TRUE;

    } else if (!one->QueryFlag() && !four->QueryFlag() && !eight->QueryFlag()) {
    } else {
        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display("");
        *ErrorLevel = 1;
        arg_array.DeleteAllMembers();
        return FALSE;
    }

    if (secpertrack->IsValueSet() && numtracks->IsValueSet()) {
        if (secpertrack->QueryLong() == 8) {
            if (numtracks->QueryLong() == 40) {

                req320 = TRUE;

#if defined(FE_SB) && defined(_X86_)
            }
            else if ( numtracks->QueryLong() == 77)  {
                // When /T:77 and /N:8, modify the process to be 1.2MB's
                req1232 = TRUE;
            }
            else if ( numtracks->QueryLong() == 80 ) {
                // When /T:80 and /N:8, modify the process to be 640KB's
                req640 = TRUE;
#endif
            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
        } else if (secpertrack->QueryLong() == 9) {
            if (numtracks->QueryLong() == 40) {

                req360 = TRUE;

            } else if (numtracks->QueryLong() == 80) {

                req720 = TRUE;

            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
        } else if (secpertrack->QueryLong() == 15) {
            if (numtracks->QueryLong() == 80) {

                req1200 = TRUE;

            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
        } else if (secpertrack->QueryLong() == 18) {
            if (numtracks->QueryLong() == 80) {

                req1440 = TRUE;

            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
        } else if (secpertrack->QueryLong() == 36) {
            if (numtracks->QueryLong() == 80) {

                req2880 = TRUE;

            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
#if defined(FE_SB) && defined(_X86_)
        // NEC98 '94.09.22 NES
        } else if(IsPC98_N() && (secpertrack->QueryLong() == 26)) {
            req256 = TRUE;
#endif
        } else {
            Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
            Message->Display("");
            *ErrorLevel = 1;
            arg_array.DeleteAllMembers();
            return FALSE;
        }
    } else if (secpertrack->IsValueSet() || numtracks->IsValueSet()) {
        Message->Set(MSG_NEED_BOTH_T_AND_N);
        Message->Display("");
        *ErrorLevel = 1;
        arg_array.DeleteAllMembers();
        return FALSE;
    }

   if (!DetermineMediaType(MediaType, Message, req160, req180, req320,
                            req360, req720, req1200, req1440, req2880,
                            req20800
#if defined(FE_SB) && defined(_X86_)
                           ,req256,req640,req1232
#endif
                           )
       ) {

        *ErrorLevel = 1;
        arg_array.DeleteAllMembers();
        return FALSE;
    }

    // If the media type was specified then it's gotten by now.

    arg_array.DeleteAllMembers();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\autoentr.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    autoentr

Abstract:

    This module contains the definition of the AUTOENTR class.

Author:

    Ramon J. San Andres (ramonsa) 11 Mar 1991

Environment:

    Ulib, User Mode


--*/

#include <pch.cxx>

#include "ulib.hxx"
#include "autoentr.hxx"

DEFINE_CONSTRUCTOR( AUTOENTRY, OBJECT );



AUTOENTRY::~AUTOENTRY (
    )
/*++

Routine Description:

    Destructor for AUTOENTRY

Arguments:

	None.

Return Value:

	None.

--*/
{
    Destroy();
}




VOID
AUTOENTRY::Construct (
    )
/*++

Routine Description:

    Constructor for AUTOENTRY

Arguments:

	None.

Return Value:

	None.

--*/
{
}




VOID
AUTOENTRY::Destroy (
    )
/*++

Routine Description:

    Destroys an  AUTOENTRY object

Arguments:

	None.

Return Value:

	None.

--*/
{

}



BOOLEAN
AUTOENTRY::Initialize (
    IN  PCWSTRING    EntryName,
    IN  PCWSTRING    CommandLine
    )
/*++

Routine Description:

    Initializes an AUTOENTRY object

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if success

--*/
{
    return ( _EntryName.Initialize( EntryName )   &&
             _CommandLine.Initialize( CommandLine ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\help\help.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    Help.c

Abstract:

    Simple minded utility that prints one-line help or spawns other
    utilities for their help.

Author:

    Mark Zbikowski 5/18/2001

Environment:

    User Mode

--*/

#include <windows.h>
#include <winnlsp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>

#include "msg.h"

#ifndef SHIFT
#define SHIFT(c,v)      {(c)--; (v)++;}
#endif //SHIFT



BOOL
PrintString(
    PWCHAR String
    )
/*++

Routine Description:

    Output a unicode string to the standard output handling
    redirection

Arguments:

    String
        NUL-terminated UNICODE string for display

Return Value:

    TRUE if string was successfully output to STD_OUTPUT_HANDLE
    
    FALSE otherwise
        
--*/
{
    DWORD   BytesWritten;
    DWORD   Mode;
    HANDLE  OutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);    

    //
    //  If the output handle is for the console
    //
    
    if ((GetFileType( OutputHandle ) & FILE_TYPE_CHAR) && 
        GetConsoleMode( OutputHandle, &Mode) ) {

        return WriteConsoleW( OutputHandle, String, wcslen( String ), &BytesWritten, 0);

    } else {

        BOOL RetValue;
        int Count = WideCharToMultiByte( GetConsoleOutputCP(), 
                                         0, 
                                         String, 
                                         -1, 
                                         0, 
                                         0, 
                                         0, 
                                         0 );
         
        PCHAR SingleByteString = (PCHAR) malloc( Count );

        WideCharToMultiByte( GetConsoleOutputCP( ), 
                             0, 
                             String, 
                             -1, 
                             SingleByteString, 
                             Count, 
                             0, 
                             0 );

        RetValue = WriteFile( OutputHandle, SingleByteString, Count - 1, &BytesWritten, 0 );

        free( SingleByteString );

        return RetValue;
    }

}



PWCHAR
GetMsg(
    ULONG MsgNum, 
    ...
    )
/*++

Routine Description:

    Retrieve, format, and return a message string with all args substituted

Arguments:

    MsgNum - the message number to retrieve
    
    Optional arguments can be supplied

Return Value:

    NULL if the message retrieval/formatting failed 
    
    Otherwise pointer to the formatted string.
        
--*/
{
    PTCHAR Buffer = NULL;
    ULONG msglen;
    
    va_list arglist;

    va_start( arglist, MsgNum );

    msglen = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE
                            | FORMAT_MESSAGE_FROM_SYSTEM
                            | FORMAT_MESSAGE_ALLOCATE_BUFFER ,
                            NULL,
                            MsgNum,
                            0,
                            (LPTSTR) &Buffer,
                            0,
                            &arglist
                            );
    
    va_end(arglist);

    return msglen == 0 ? NULL : Buffer;
    
}


void
DisplayMessageError(
    ULONG MsgNum
    )
/*++

Routine Description:

    Displays a message if we cannot retrieve a message

Arguments:

    MsgNum
        Message number to display

Return Value:

    None.
        
--*/
{
    WCHAR Buffer[32];
    PWCHAR MessageString;

    _ultow( MsgNum, Buffer, 16 );
    MessageString = GetMsg( ERROR_MR_MID_NOT_FOUND, Buffer, L"Application" );
    if (MessageString == NULL) {
        PrintString( L"Unable to get Message-Not-Found message\n" );
    } else {
        PrintString( MessageString );
        LocalFree( MessageString );
    }

}



BOOL
DisplayFullHelp(
    void
    )
/*++

Routine Description:

    Display the full help set. This assumes all messages in the message
    file are in the correct order

Arguments:

    None.

Return Value:

    TRUE if all messages were correctly output
    
    FALSE otherwise
        
--*/
{
    ULONG Message;
    BOOL RetValue = TRUE;

    for (Message = HELP_FIRST_HELP_MESSAGE; RetValue && Message <= HELP_LAST_HELP_MESSAGE; Message++) {
        PWCHAR MessageString = GetMsg( Message );
        if (MessageString == NULL) {
            DisplayMessageError( Message );
            RetValue = FALSE;
        } else {
            RetValue = PrintString( MessageString );
            LocalFree( MessageString );
        }
    }

    return RetValue;
}



BOOL
DisplaySingleHelp(
    PWCHAR Command
    )
/*++

Routine Description:

    Display the help appropriate to the specific command

Arguments:

    Command
        NUL-terminated UNICODE string for command

Return Value:

    TRUE if help was correctly output
    
    FALSE otherwise
        
--*/
{
    ULONG Message;
    ULONG Count = wcslen( Command );
    PWCHAR MessageString;

    //
    //  Walk through the messages one by one and determine which
    //  one has the specified command as the prefix.  
    //
    
    for (Message = HELP_FIRST_COMMAND_HELP_MESSAGE; 
         Message <= HELP_LAST_HELP_MESSAGE; 
         Message++) {

        MessageString = GetMsg( Message );
        if (MessageString == NULL) {
            DisplayMessageError( Message );
            return FALSE;
        } else {

            if (!_wcsnicmp( Command, MessageString, Count ) &&
                MessageString[Count] == L' ') {

                //
                //  We've found a match. Let the command
                //  display it's own help
                //

                WCHAR CommandString[MAX_PATH];

                wcscpy( CommandString, Command );
                wcscat( CommandString, L" /?" );
                
                _wsystem( CommandString );

                LocalFree( MessageString );
                return TRUE;
            }
            
            LocalFree( MessageString );
        }
    }

    MessageString = GetMsg( HELP_NOT_FOUND_MESSAGE, Command );

    if (MessageString == NULL) {
        DisplayMessageError( Message );
        return FALSE;
    }
    
    PrintString( MessageString );
    
    LocalFree( MessageString );

    return FALSE;
}


//
//  HELP with no arguments will display a series of one-line help summaries
//  for a variety of tools.
//
//  HELP with a single argument will walk through the list of tools it knows
//  about and attempt to match the tool against the argument.  If one is found,
//  the tool is executed with the /? switch and then the tool displays more
//  detailed help.
//

INT
__cdecl wmain(
    INT argc,
    PWSTR argv[]
    )
/*++

Routine Description:

    Source entry point for the 

Arguments:

    argc - The argument count.
    argv - string arguments, the first being the name of the executable and the
        remainder being parameters, only a single one is allowed.

Return Value:

    INT - Return Status:
        0 if help was successfully displayed
        1 otherwise
        
--*/

{
    PWSTR ProgramName = argv[0];
    PWSTR HelpString;
    BOOL RetValue;
    
    //
    //  Set up all the various international stuff
    //

    setlocale( LC_ALL, ".OCP" ) ;
    SetThreadUILanguage( 0 );
    
    //
    //  Get past the name of the program
    //

    SHIFT( argc, argv );

    //
    //  No arguments means a quick blurt of all the messages
    //
    
    if (argc == 0) {
        return DisplayFullHelp( );
    }

    //
    //  A single argument is looked up in the message set and
    //  that command is executed
    //  

    if (argc == 1 && wcscmp( argv[0], L"/?" )) {
        return DisplaySingleHelp( argv[0] );
    }

    //
    //  More than one argument was supplied.  This is an error
    //

    HelpString = GetMsg( HELP_USAGE_MESSAGE, ProgramName );
    
    if (HelpString == NULL) {
        PrintString( L"Unable to display usage message\n" );
        return 1;
    }

    RetValue = PrintString( HelpString );

    LocalFree( HelpString );

    return RetValue;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\bootreg.c ===
#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>
#include "bootreg.h"

#define SESSION_MANAGER_KEY      L"Session Manager"
#define BOOT_EXECUTE_VALUE       L"BootExecute"
#define NEW_ENTRY                L"autocheck new entry"
#define TIME_OUT_VALUE           L"AutoChkTimeOut"

#define SYSTEM_PARTITION         L"SystemPartition"

ULONG
CharsInMultiString(
    IN PWSTR pw
    )
/*++

Routine Description:

    This computes the number of characters in a multi-string.  Note
    that this includes the terminating nulls of the component strings
    but not the terminating null of the multi-string itself.

Arguments:

    pw  --  Supplies a pointer to the multi-string.

Return Value:

    the number of characters in the multi-string.

--*/
{
    ULONG Length = 0;

    while( *pw ) {

        while( *pw++ ) {

            Length++;
        }

        Length++;
    }


    return Length;
}


BOOLEAN
QueryAutocheckEntries(
    OUT PVOID   Buffer,
    IN  ULONG   BufferSize
    )
/*++

Routine Description:

    This function fetches the BootExecute value of the Session
    Manager key.

Arguments:

    Buffer      --  Supplies a buffer into which the value
                    will be written.
    BufferSize  --  Supplies the size of the client's buffer.

Return Value:

    TRUE upon successful completion.

--*/
{
    UNICODE_STRING OutputString;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    NTSTATUS Status;

    // Set up the query table:
    //
    OutputString.Length = 0;
    OutputString.MaximumLength = (USHORT)BufferSize;
    OutputString.Buffer = (PWSTR)Buffer;

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[0].Name = BOOT_EXECUTE_VALUE;
    QueryTable[0].EntryContext = &OutputString;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    QueryTable[1].EntryContext = NULL;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     SESSION_MANAGER_KEY,
                                     QueryTable,
                                     NULL,
                                     NULL );

    return( NT_SUCCESS( Status ) );
}


BOOLEAN
SaveAutocheckEntries(
    IN  PVOID   Value
    )
/*++

Routine Description:

    This function writes the BootExecute value of the Session
    Manager key.

Arguments:

    Value       --  Supplies the value (as a MULTI_STRING)

Return Value:

    TRUE upon successful completion.

--*/
{
    NTSTATUS Status;
    ULONG Length;

    Length = ( CharsInMultiString( Value ) + 1 ) * sizeof( WCHAR );

    Status = RtlWriteRegistryValue( RTL_REGISTRY_CONTROL,
                                    SESSION_MANAGER_KEY,
                                    BOOT_EXECUTE_VALUE,
                                    REG_MULTI_SZ,
                                    Value,
                                    Length );

    return( NT_SUCCESS( Status ) );
}


BOOLEAN
QueryTimeOutValue(
    OUT PULONG  TimeOut
)
/*++

Routine Description:

    This function reads the AutoChkTimeOut value of the Session
    Manager key.

Arguments:

    TimeOut     --  Supplies the location to store the timeout value

Return Value:

    TRUE upon successful completion.

--*/
{
    RTL_QUERY_REGISTRY_TABLE    QueryTable[2];
    NTSTATUS                    Status;

    // Set up the query table:
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = TIME_OUT_VALUE;
    QueryTable[0].EntryContext = TimeOut;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    QueryTable[1].EntryContext = NULL;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     SESSION_MANAGER_KEY,
                                     QueryTable,
                                     NULL,
                                     NULL );

    return( NT_SUCCESS( Status ) );
}


BOOLEAN
SetTimeOutValue(
    IN  ULONG  TimeOut
)
/*++

Routine Description:

    This function sets the AutoChkTimeOut value of the Session
    Manager key.

Arguments:

    TimeOut     --  Supplies the time out value

Return Value:

    TRUE upon successful completion.

--*/
{
    NTSTATUS                    Status;

    Status = RtlWriteRegistryValue( RTL_REGISTRY_CONTROL,
                                    SESSION_MANAGER_KEY,
                                    TIME_OUT_VALUE,
                                    REG_DWORD,
                                    &TimeOut,
                                    sizeof(TimeOut) );

    return( NT_SUCCESS( Status ) );
}


NTSTATUS
QuerySystemPartitionValue(
    OUT PVOID   Buffer,
    IN  ULONG   BufferSize
    )
/*++

Routine Description:

    This function fetches the value of the HKLM\System\Setup\SystemPartition key.

Arguments:

    Buffer      --  Supplies a buffer into which the value
                    will be written.
    BufferSize  --  Supplies the size of the client's buffer.

Return Value:

    TRUE upon successful completion.

--*/
{
    UNICODE_STRING OutputString;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    NTSTATUS Status;

    // Set up the query table:
    //
    OutputString.Length = 0;
    OutputString.MaximumLength = (USHORT)BufferSize;
    OutputString.Buffer = (PWSTR)Buffer;

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[0].Name = SYSTEM_PARTITION;
    QueryTable[0].EntryContext = &OutputString;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    QueryTable[1].EntryContext = NULL;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                                     L"\\Registry\\Machine\\System\\Setup",
                                     QueryTable,
                                     NULL,
                                     NULL );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\bigint.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "bigint.hxx"

IFSUTIL_EXPORT
VOID
BIG_INT::Set(
    IN  UCHAR   ByteCount,
    IN  PCUCHAR CompressedInteger
    )
/*++

Routine Description:

    This routine sets the big_int with the given compressed integer.

Arguments:

    ByteCount           - Supplies the number of bytes in the compressed
                            integer.
    CompressedInteger   - Supplies the compressed integer.

Return Value:

    None.

--*/
{
    // If the number is completely compressed then we'll say that the
    // number is zero.  QueryCompressed should always return at least
    // one byte though.

    if (ByteCount == 0) {
        x = 0;
        return;
    }


    // First fill the integer with -1 if it's negative or 0 if it's
    // positive.

    if (CompressedInteger[ByteCount - 1] >= 0x80) {

        x = -1;

    } else {

        x = 0;
    }


    // Now copy over the integer.

    DebugAssert( ByteCount <= 8 );

    memcpy( &x, CompressedInteger, ByteCount );
}


IFSUTIL_EXPORT
VOID
BIG_INT::QueryCompressedInteger(
    OUT PUCHAR  ByteCount,
    OUT PUCHAR  CompressedInteger
    ) CONST
/*++

Routine Descrtiption:

    This routine returns a compressed form of the integer.

Arguments:

    ByteCount           - Returns the number of bytes in the compressed
                            integer.
    CompressedInteger   - Returns a 'little endian' string of bytes
                            representing a signed 'ByteCount' byte integer
                            into this supplied buffer.

Return Value:

    None.

--*/
{
    INT     i;
    PUCHAR  p;

    DebugAssert(ByteCount);
    DebugAssert(CompressedInteger);

    // First copy over the whole thing then determine the number
    // of bytes that you have to keep.

    memcpy(CompressedInteger, &x, sizeof(LARGE_INTEGER));


    p = CompressedInteger;


    // First check to see whether the number is positive or negative.

    if (p[7] >= 0x80) { // high byte is negative.

        for (i = 7; i >= 0 && p[i] == 0xFF; i--) {
        }

        if (i < 0) {
            *ByteCount = 1;
            return;
        }

        if (p[i] < 0x80) { // high byte is non-negative.
            i++;
        }

    } else { // high byte is non-negative.

        for (i = 7; i >= 0 && p[i] == 0; i--) {
        }

        if (i < 0) {
            *ByteCount = 1;
            return;
        }

        if (p[i] >= 0x80) { // high byte is negative.
            i++;
        }

    }


    // Now 'i' marks the position of the last character that you
    // have to keep.

    *ByteCount = (UCHAR) (i + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\cache.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "cache.hxx"

#if defined( _AUTOCHECK_ )
extern "C" {
    #include "ntos.h"
}
#endif

DEFINE_CONSTRUCTOR( CACHE, OBJECT );


CACHE::~CACHE(
    )
/*++

Routine Description:

    Destructor for CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
CACHE::Construct(
    )
/*++

Routine Description:

    This routine initializes this class to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buffer = NULL;
    _block_number = NULL;
    _inuse = NULL;
    _num_blocks = 0;
    _block_size = 0;
    _next_add = 0;
    _next_add_inuse = 0;
    _timeout.QuadPart = 0;
}


VOID
CACHE::Destroy(
    )
/*++

Routine Description:

    This routine returns this object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;

    if (_buffer)
        for (i = 0; i < _num_blocks; i++) {
            FREE(_buffer[i]);
        }
    DELETE(_buffer);
    DELETE(_block_number);
    FREE(_inuse);

    _num_blocks = 0;
    _block_size = 0;
    _next_add = 0;
    _next_add_inuse = 0;
    _timeout.QuadPart = 0;
}


BOOLEAN
CACHE::Initialize(
    IN  ULONG   BlockSize,
    IN  ULONG   MaximumNumberOfBlocks
    )
/*++

Routine Description:

    This routine initializes this object to a valid initial state.

Arguments:

    BlockSize               - Supplies the size of the cache blocks.
    MaximumNumberOfBlocks   - Supplies the maximum number of cache blocks.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;

    Destroy();

    _num_blocks = MaximumNumberOfBlocks;
    _block_size = BlockSize;

    if (!(_buffer = NEW PVOID[_num_blocks]) ||
        !(_block_number = NEW BIG_INT[_num_blocks]) ||
        !(_inuse = (LONG *)MALLOC(_num_blocks*sizeof(LONG)))) {

        Destroy();
        return FALSE;
    }

    for (i = 0; i < _num_blocks; i++) {

        _buffer[i] = NULL;
        _block_number[i] = -1;
        _inuse[i] = 0;
    }

    for (i = 0; i < _num_blocks; i++) {

        if (!(_buffer[i] = MALLOC((UINT) _block_size))) {

            Destroy();
            return FALSE;
        }
    }

    _timeout.QuadPart = -10000;

    return TRUE;
}


BOOLEAN
CACHE::Read(
    IN  BIG_INT BlockNumber,
    OUT PVOID   Buffer
    ) CONST
/*++

Routine Description:

    This routine searches the cache for the requested block and
    copies it to the buffer if it is available.  If the block is
    not available then this routine will return FALSE.

Arguments:

    BlockNumber - Supplies the number of the block requested.
    Buffer      - Returns the buffer for the block requested.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;
    LONG    final_value;

    for (i = 0; i < _num_blocks; i++) {

        while (InterlockedCompareExchange(&_inuse[i], 1, 0) != 0) {
            NtDelayExecution(FALSE, &(LARGE_INTEGER)_timeout);
        }

        if (BlockNumber == _block_number[i]) {

            memcpy(Buffer, _buffer[i], (UINT) _block_size);
            final_value = InterlockedDecrement(&_inuse[i]);
            DebugAssert(final_value == 0);
            return TRUE;
        }

        final_value = InterlockedDecrement(&_inuse[i]);
        DebugAssert(final_value == 0);

    }

    return FALSE;
}


VOID
CACHE::AddBlock(
    IN  BIG_INT BlockNumber,
    IN  PCVOID  Buffer
    )
/*++

Routine Description:

    This routine adds a new block to the cache.  This will remove the
    oldest existing block out of the cache.

Arguments:

    BlockNumber - Supplies the block number of the new block.
    Buffer      - Supplies the buffer for the new block.

Return Value:

    None.

--*/
{
    LONG    final_value;

    while (InterlockedCompareExchange(&_next_add_inuse, 1, 0) != 0) {
        NtDelayExecution(FALSE, &_timeout);
    }

    while (InterlockedCompareExchange(&_inuse[_next_add], 1, 0) != 0) {
        NtDelayExecution(FALSE, &_timeout);
    }

    memcpy(_buffer[_next_add], Buffer, (UINT) _block_size);
    _block_number[_next_add] = BlockNumber;

    final_value = InterlockedDecrement(&_inuse[_next_add]);
    DebugAssert(final_value == 0);

    _next_add = (_next_add + 1) % _num_blocks;

    final_value = InterlockedDecrement(&_next_add_inuse);
    DebugAssert(final_value == 0);
}


VOID
CACHE::Empty(
    )
/*++

Routine Description:

    This routine eliminates all of the blocks from the cache.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;
    LONG    final_value;

    for (i = 0; i < _num_blocks; i++) {

        while (InterlockedCompareExchange(&_inuse[i], 1, 0) != 0) {
            NtDelayExecution(FALSE, &_timeout);
        }

        _block_number[i] = -1;

        final_value = InterlockedDecrement(&_inuse[i]);
        DebugAssert(final_value == 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\autoreg.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    autoreg

Abstract:

    This module contains the definition of the AUTOREG class.

    The AUTOREG class contains methods for the registration and
    de-registration of those programs that are to be executed at
    boot time.

Author:

    Ramon J. San Andres (ramonsa) 11 Mar 1991

Environment:

    Ulib, User Mode


--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "autoreg.hxx"
#include "autoentr.hxx"


extern "C" {
    #include <stdio.h>
    #include "bootreg.h"
}

CONST BootExecuteBufferSize = 0x2000;

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::AddEntry (
    IN  PCWSTRING    CommandLine
    )
{
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    ULONG   CharsInValue, NewCharCount;


    // Fetch the existing autocheck entries.
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    // Determine if the new entry fits in our buffer.  The
    // new size will be the chars in the existing value
    // plus the length of the new string plus a terminating
    // null for the new string plus a terminating null for
    // the multi-string value.
    //
    CharsInValue = CharsInMultiString( BootExecuteValue );

    NewCharCount = CharsInValue + CommandLine->QueryChCount() + 2;

    if( NewCharCount * sizeof( WCHAR ) > BootExecuteBufferSize ) {

        // Not enough room.
        //
        return FALSE;
    }


    // Add the new entry to the buffer and add a terminating null
    // for the multi-string:
    //
    if( !CommandLine->QueryWSTR( 0,
                                 TO_END,
                                 BootExecuteValue + CharsInValue,
                                 BootExecuteBufferSize/sizeof(WCHAR) -
                                    CharsInValue ) ) {

        // Couldn't get the WSTR.
        //
        return FALSE;
    }

    BootExecuteValue[ NewCharCount - 1 ] = 0;


    // Write the value back into the registry:
    //
    return( SaveAutocheckEntries( BootExecuteValue ) );
}

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::PushEntry (
    IN  PCWSTRING    CommandLine
    )
{
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    ULONG   CharsInValue, NewCharCount;


    // Fetch the existing autocheck entries.
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    // Determine if the new entry fits in our buffer.  The
    // new size will be the chars in the existing value
    // plus the length of the new string plus a terminating
    // null for the new string plus a terminating null for
    // the multi-string value.
    //
    CharsInValue = CharsInMultiString( BootExecuteValue ) + 1;

    NewCharCount = CharsInValue + CommandLine->QueryChCount() + 1;

    if( NewCharCount * sizeof( WCHAR ) > BootExecuteBufferSize ) {

        // Not enough room.
        //
        return FALSE;
    }


    // Add the new entry to the buffer and add a terminating null
    // for the multi-string:
    //
    memmove(BootExecuteValue + CommandLine->QueryChCount() + 1,
            BootExecuteValue,
            CharsInValue*sizeof(WCHAR));

    if( !CommandLine->QueryWSTR( 0,
                                 TO_END,
                                 BootExecuteValue,
                                 NewCharCount
                                )) {
        // Couldn't get the WSTR.
        //
        return FALSE;
    }

    // Write the value back into the registry:
    //
    return( SaveAutocheckEntries( BootExecuteValue ) );
}

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::DeleteEntry (
    IN  PCWSTRING    LineToMatch,
    IN  BOOLEAN      PrefixOnly
    )
/*++

Routine Description:

    This method removes an Autocheck entry.

Arguments:

    LineToMatch --  Supplies a pattern for the entry to delete.
                    All lines which match this pattern will be
                    deleted.

    PrefixOnly  --  LineToMatch specifies a prefix, and all lines
                    beginning with that prefix are deleted.

Return Value:

    TRUE upon successful completion.  Note that this function
    will return TRUE if no matching entry is found, or if a
    matching entry is found and removed.

Notes:

    Since the utilities only assume responsibility for removing
    entries which we created in the first place, we can place
    very tight constraints on the matching pattern.  In particular,
    we can require an exact match (except for case).

--*/
{
    DSTRING CurrentString;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( LineToMatch ) == 0 ||
            (PrefixOnly && CurrentString.Stricmp( LineToMatch,
                                                  0, LineToMatch->QueryChCount(),
                                                  0, LineToMatch->QueryChCount()) == 0)) {

            // This line is a match--delete it.  We simply expunge
            // the current string plus its terminating null by
            // shifting the data beyond that point down.
            //
            memmove( pw,
                     pw + CurrentString.QueryChCount() + 1,
                     BootExecuteBufferSize - (unsigned int)(pw - BootExecuteValue) * sizeof(WCHAR) );

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return( SaveAutocheckEntries( BootExecuteValue ) );
}


IFSUTIL_EXPORT
BOOLEAN
AUTOREG::DeleteEntry (
    IN  PCWSTRING    PrefixToMatch,
    IN  PCWSTRING    ContainingString
    )
/*++

Routine Description:

    This method removes an entry that matches the PrefixToMatch and
    also contains the ContainingString.

Arguments:

    PrefixToMatch    --  Supplies a prefix pattern of interest.

    ContainingString --  Supplies a string to look for in each entry.

Return Value:

    TRUE upon successful completion.  Note that this function
    will return TRUE if no matching entry is found, or if a
    matching entry is found and removed.

Notes:

    Since the utilities only assume responsibility for removing
    entries which we created in the first place, we can place
    very tight constraints on the matching pattern.  In particular,
    we can require an exact match (except for case).

--*/
{
    DSTRING CurrentString;
    DSTRING ContainingStringUpcase;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    if (!ContainingStringUpcase.Initialize( ContainingString ) ||
        !ContainingStringUpcase.Strupr())

        return FALSE;


    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ||
            !CurrentString.Strupr() ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( PrefixToMatch,
                                   0,
                                   PrefixToMatch->QueryChCount(),
                                   0,
                                   TO_END ) == 0 &&
            CurrentString.Strstr( &ContainingStringUpcase ) != INVALID_CHNUM ) {

            // This line is a match--delete it.  We simply expunge
            // the current string plus its terminating null by
            // shifting the data beyond that point down.
            //
            memmove( pw,
                     pw + CurrentString.QueryChCount() + 1,
                     BootExecuteBufferSize - (unsigned int)(pw - BootExecuteValue) * sizeof(WCHAR) );

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return( SaveAutocheckEntries( BootExecuteValue ) );
}


IFSUTIL_EXPORT
BOOLEAN
AUTOREG::IsEntryPresent (
    IN PCWSTRING     LineToMatch
    )
/*++

Routine Description:

    This method determines whether a proposed entry for the
    autocheck list is already in the registry.

Arguments:

    LineToMatch --  Supplies a pattern for proposed entry.

Return Value:

    TRUE if a matching entry exists.
--*/
{
    DSTRING CurrentString;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( LineToMatch ) == 0 ) {

            // This line is a match.
            //
            return TRUE;

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::IsEntryPresent (
    IN  PCWSTRING    PrefixToMatch,
    IN  PCWSTRING    ContainingString
    )
/*++

Routine Description:

    This method search for an entry that matches the PrefixToMatch and
    also contains the ContainingString.

Arguments:

    PrefixToMatch    --  Supplies a prefix pattern of interest.

    ContainingString --  Supplies a string to look for in each entry.

Return Value:

    TRUE if a matching entry exists.
--*/
{
    DSTRING CurrentString;
    DSTRING ContainingStringUpcase;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    if (!ContainingStringUpcase.Initialize( ContainingString ) ||
        !ContainingStringUpcase.Strupr())

        return FALSE;


    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ||
            !CurrentString.Strupr() ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( PrefixToMatch,
                                   0,
                                   PrefixToMatch->QueryChCount(),
                                   0,
                                   TO_END ) == 0 &&
            CurrentString.Strstr( &ContainingStringUpcase ) != INVALID_CHNUM ) {

            return TRUE;

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::IsFrontEndPresent (
    IN  PCWSTRING    PrefixToMatch,
    IN  PCWSTRING    SuffixToMatch
    )
/*++

Routine Description:

    This method search for an entry that matches the PrefixToMatch and
    the SuffixToMatch.

Arguments:

    PrefixToMatch    --  Supplies a prefix pattern of interest.
    SuffixToMatch    --  Supplies a suffix pattern of interest.

Return Value:

    TRUE if a matching entry exists.
--*/
{
    DSTRING CurrentString;
    DSTRING SuffixUpcase;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    if (!SuffixUpcase.Initialize( SuffixToMatch ) ||
        !SuffixUpcase.Strupr())

        return FALSE;


    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ||
            !CurrentString.Strupr() ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( PrefixToMatch,
                                   0,
                                   PrefixToMatch->QueryChCount(),
                                   0,
                                   TO_END ) == 0 ) {

            if ((CurrentString.QueryChCount() >=
                 (PrefixToMatch->QueryChCount() + SuffixUpcase.QueryChCount())) &&
                CurrentString.Stricmp( SuffixToMatch,
                                       CurrentString.QueryChCount() - SuffixUpcase.QueryChCount(),
                                       TO_END,
                                       0,
                                       TO_END ) == 0 ) {

                return TRUE;
            } else {

                // This line is not a match.  Advance to the next.
                // Note that this will bump over the terminating
                // null for this component string, which is what
                // we want.
                //
                while( *pw++ );
            }

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\cannedsd.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    cannedsd.cxx

Abstract:

    This module contains member function definitions for the
    CANNED_SECURITY class, which is a repository for the canned
    Security Descriptors used by the utilities.

    Initializing an object of this type generates the canned
    security descriptors used by the utilities, which can
    then be gotten from the object.

    These security descriptors are all in the self-relative
    format.

    Note that this class uses the NT Api and RTL routines, rather
    than the Win32 API, since it needs to be available to AutoChk
    and AutoConvert.

Author:

    Bill McJohn (billmc) 04-March-1992

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "ntrtl.h"
#include "nturtl.h"

#include "cannedsd.hxx"

// This generic mapping array is copied from ntos\io\ioinit.c.
//
GENERIC_MAPPING IopFileMapping = {

    STANDARD_RIGHTS_READ |
        FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE,
    STANDARD_RIGHTS_WRITE |
        FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_EXECUTE,
    FILE_ALL_ACCESS
};



DEFINE_EXPORTED_CONSTRUCTOR( CANNED_SECURITY, OBJECT, IFSUTIL_EXPORT );

IFSUTIL_EXPORT
CANNED_SECURITY::~CANNED_SECURITY(
    )
{
    Destroy();
}

VOID
CANNED_SECURITY::Construct(
    )
/*++

Routine Description:

    This method is the helper function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _NoAccessLength = 0;
    _NoAclLength = 0;
    _ReadLength = 0;
    _WriteLength = 0;
    _EditLength = 0;
    _EditWorldDirLength = 0;
    _EditWorldFileLength = 0;

    _NoAccessSd = NULL;
    _NoAclSd = NULL;
    _ReadSd = NULL;
    _WriteSd = NULL;
    _EditSd = NULL;
    _EditWorldDirSd = NULL;
    _EditWorldFileSd = NULL;
    _NoAclFileSd = NULL;
}

VOID
CANNED_SECURITY::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if !defined( _SETUP_LOADER_ )
    _NoAccessLength = 0;
    _NoAclLength = 0;
    _ReadLength = 0;
    _WriteLength = 0;
    _EditLength = 0;
    _EditWorldDirLength = 0;
    _EditWorldFileLength = 0;

    // Since the canned security descriptors are ultimately
    // generated by RtlNewSecurityObject, they have to be
    // freed using RtlFreeHeap.
    //
    if( _NoAccessSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _NoAccessSd );
        _NoAccessSd = NULL;
    }

    if( _NoAclSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _NoAclSd );
        _NoAclSd = NULL;
    }

    if( _ReadSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _ReadSd );
        _ReadSd = NULL;
    }

    if( _WriteSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _WriteSd );
        _WriteSd = NULL;
    }

    if( _EditSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _EditSd );
        _EditSd = NULL;
    }

    if( _EditWorldDirSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _EditWorldDirSd );
        _EditWorldDirSd = NULL;
    }

    if( _EditWorldFileSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _EditWorldFileSd );
        _EditWorldFileSd = NULL;

    if( _NoAclFileSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _NoAclFileSd );
        _NoAclFileSd = NULL;
    }

    }
#endif // _SETUP_LOADER_
}


IFSUTIL_EXPORT
BOOLEAN
CANNED_SECURITY::Initialize(
    )
/*++

Routine Description:

    This method initializes the object.  It builds the canned
    security descriptors, puts them into self-relative form,
    and squirrels them away for later use.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
#if defined( _SETUP_LOADER_ )

    // Canned security descriptors are not available in
    // the setup loader environment.
    //
    return FALSE;

#else

    CONST SidBufferLength = 512;
    PSID SystemSid = NULL;
    PSID AdminsSid = NULL;
    ULONG AdminsSidBufferLength, SystemSidBufferLength;
    NTSTATUS Status;
    HANDLE TokenHandle;

    Destroy();

    // Get the SID's for Admins and System.
    //
    SystemSidBufferLength = SidBufferLength;
    AdminsSidBufferLength = SidBufferLength;

    if( (SystemSid = (PSID)MALLOC( SystemSidBufferLength )) == NULL ||
        !QuerySystemSid( SystemSid, &SystemSidBufferLength ) ||
        (AdminsSid = (PSID)MALLOC( AdminsSidBufferLength )) == NULL ||
        !QueryAdminsSid( AdminsSid, &AdminsSidBufferLength ) ) {

        FREE( SystemSid );
        FREE( AdminsSid );
        Destroy();
        return FALSE;
    }

    // Get a handle to the token for the current process:
    //
    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &TokenHandle );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: NtOpenProcessToken failed: status = 0x%x\n", Status ));
        FREE( SystemSid );
        FREE( AdminsSid );
        Destroy();
        return FALSE ;
    }

    // Generate the canned security descriptors.  All but _NoAclSd
    // have a discretionary ACL, so pass in TRUE for the DaclPresent
    // parameter for all but that exception.
    //
    _NoAccessSd = GenerateCannedSd( NoAccessCannedSd,
                                    0,
                                    AdminsSid,
                                    SystemSid,
                                    TokenHandle,
                                    &_NoAccessLength );

    _NoAclSd = GenerateCannedSd( NoAclCannedSd,
                                 0,
                                 AdminsSid,
                                 SystemSid,
                                 TokenHandle,
                                 &_NoAclLength );

    _ReadSd = GenerateCannedSd( ReadCannedSd,
                                GENERIC_READ,
                                AdminsSid,
                                SystemSid,
                                TokenHandle,
                                &_ReadLength );

    _WriteSd = GenerateCannedSd( WriteCannedSd,
                                 GENERIC_READ | GENERIC_WRITE,
                                 AdminsSid,
                                 SystemSid,
                                 TokenHandle,
                                 &_WriteLength );

    _EditSd = GenerateCannedSd( EditCannedSd,
                                GENERIC_ALL,
                                AdminsSid,
                                SystemSid,
                                TokenHandle,
                                &_EditLength );

    _EditWorldDirSd = GenerateCannedSd( EditWorldCannedDirSd,
                                        GENERIC_ALL,
                                        AdminsSid,
                                        SystemSid,
                                        TokenHandle,
                                        &_EditWorldDirLength );

    _EditWorldFileSd = GenerateCannedSd( EditWorldCannedFileSd,
                                         GENERIC_ALL,
                                         AdminsSid,
                                         SystemSid,
                                         TokenHandle,
                                         &_EditWorldFileLength );

    _NoAclFileSd = GenerateCannedSd( EditWorldCannedFileSd,
                                     0,
                                     AdminsSid,
                                     SystemSid,
                                     TokenHandle,
                                     &_NoAclFileLength );
    //
    // New Security descriptor with a different format from those created
    // above.
    //

    _NewRootSd = GenerateCannedSd( NewRootSd,
                                   0,
                                   0,
                                   0,
                                   TokenHandle,
                                   &_NewRootSdLength );

    // We're done with the SID's for Admins and System, and with
    // the token for the current process.
    //
    FREE( SystemSid );
    FREE( AdminsSid );
    NtClose( TokenHandle );

    // Make sure that all the canned security descriptors were
    // successful generated.
    //
    if( _NoAccessSd == NULL ||
        _NoAclSd == NULL    ||
        _ReadSd == NULL     ||
        _WriteSd == NULL    ||
        _EditSd == NULL    ||
        _EditWorldDirSd == NULL ||
        _EditWorldFileSd == NULL ||
        _NewRootSd == NULL ||
        _NoAclFileSd == NULL) {

        Destroy();
        return FALSE;
    }

    return TRUE;

#endif // _SETUP_LOADER_
}


IFSUTIL_EXPORT
PVOID
CANNED_SECURITY::GetCannedSecurityDescriptor(
    IN  CANNED_SECURITY_TYPE   Type,
    OUT PULONG                 Length
    )
/*++

Routine Description:

    This method fetches one of the canned security descriptors.

Arguments:

    Type    --  Supplies a code indicating which security
                descriptor to get.
    Length  --  Receives the length (in bytes) of the security
                descriptor.

Return Value:

    A pointer to the canned security descriptor.  (A return value
    of NULL indicates that an error has occurred.)

--*/
{
    DebugPtrAssert( Length );

    switch( Type ) {

    case NoAccessCannedSd     : *Length = _NoAccessLength;
                                return _NoAccessSd;

    case NoAclCannedSd        : *Length = _NoAclLength;
                                return _NoAclSd;

    case ReadCannedSd         : *Length = _ReadLength;
                                return _ReadSd;

    case WriteCannedSd        : *Length = _WriteLength;
                                return _WriteSd;

    case EditCannedSd         : *Length = _EditLength;
                                return _EditSd;

    case EditWorldCannedDirSd : *Length = _EditWorldDirLength;
                                return _EditWorldDirSd;

    case EditWorldCannedFileSd: *Length = _EditWorldFileLength;
                                return _EditWorldFileSd;

    case NewRootSd            : *Length = _NewRootSdLength;
                                return _NewRootSd;

    case NoAclCannedFileSd    : *Length = _NoAclFileLength;
                                return _NoAclFileSd;

    default                   : *Length = 0;
                                return NULL;
    }
}

#if !defined( _SETUP_LOADER_ )

BOOLEAN
QueryWorldSid(
    OUT     PSID    NewSid,
    IN OUT  PULONG  Length
    )
/*++

Routine Description:

    This functions fetches the SID for WORLD.

Arguments:

    NewSid  --  Supplies buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the
                length of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // WORLD is a well-known SID with one subauthority.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 1 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               1 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_WORLD_RID;

    return TRUE;
}

NTSTATUS
AddInheritableAccessAllowedAce(
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN UCHAR AceFlags,
    IN PSID Sid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.  The inheritance
    flags are set so that this ACE will apply to the current item
    and will be propagated to child containers and objects.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be granted to the specified SID.

    AceFlags - Inheritance flags for new ACE

    Sid - Pointer to the SID being granted access.


Return Value:

    STATUS_SUCCESS - The ACE was successfully added.
    anything else  - The ACE was not successfully added.

--*/
{
    PACCESS_ALLOWED_ACE NewAce;
    ULONG AceSize;
    NTSTATUS Status;

    AceSize = (USHORT)(sizeof(ACE_HEADER) +
                      sizeof(ACCESS_MASK) +
                      RtlLengthSid(Sid));

    NewAce = (PACCESS_ALLOWED_ACE)MALLOC( AceSize );

    if( NewAce == NULL ) {

        return STATUS_NO_MEMORY;
    }

    NewAce->Header.AceFlags = AceFlags;
    NewAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    NewAce->Header.AceSize = (USHORT)AceSize;
    NewAce->Mask = AccessMask;
    RtlCopySid( RtlLengthSid(Sid), (PSID)(&NewAce->SidStart), Sid );

    Status = RtlAddAce( Acl, AceRevision, MAXULONG, NewAce, AceSize );

    FREE( NewAce );

    return Status;
}


BOOLEAN
GenerateWorldAcl(
    OUT PACL        AclBuffer,
    IN  ULONG       BufferLength
    )
/*++

Routine Description:

    This function creates an ACL that grants full access to all
    the world.

Arguments:

    AclBuffer       --  Supplies the buffer in which the ACL
                        will be created.
    BufferLength    --  Supplies the length of the buffer

Return Value:

    TRUE upon successful completion.

--*/
{
    CONST WorldSidBufferLength = 64;
    BYTE WorldSidBuffer[WorldSidBufferLength];

    ULONG WorldSidLength = WorldSidBufferLength;
    PSID  WorldSid = (PSID)WorldSidBuffer;

    if( !QueryWorldSid( WorldSid, &WorldSidLength ) ) {

        return FALSE;
    }

    ACL_SIZE_INFORMATION AclSizeInfo;
    PACL NewAcl;
    NTSTATUS Status;

    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //
    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }


    // Now determine the size of this ACL:
    //
    RtlQueryInformationAcl( NewAcl,
                            &AclSizeInfo,
                            sizeof( ACL_SIZE_INFORMATION ),
                            AclSizeInformation );

    // Now reinitialize and rebuild the ACL with the correct size:
    //
    Status = RtlCreateAcl( NewAcl, AclSizeInfo.AclBytesInUse, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }


    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryUsersSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the USERS alias.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // Users is a well-known SID with two subauthorities.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 2 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               2 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( NewSid, 1 )) = DOMAIN_ALIAS_RID_USERS;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryPowerUsersSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the POWER USERS SID pseudo-account.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // Power Users is a well-known SID with two subauthorities.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 2 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               2 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( NewSid, 1 )) = DOMAIN_ALIAS_RID_POWER_USERS;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryCreatorOwnerSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the CREATOR OWNER pseudo-account.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // System is a well-known SID with one subauthority.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 1 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               1 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryPrincipalSelfSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the PRINCIPAL SELF SID pseudo-account.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // System is a well-known SID with one subauthority.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 1 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               1 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_PRINCIPAL_SELF_RID;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QuerySystemSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the SYSTEM account.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // System is a well-known SID with one subauthority.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 1 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               1 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryAdminsSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the WORKSTATION ADMINISTRATORS
    alias.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // Admins is a well-known SID with two subauthorities.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 2 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the two subauthorities:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               2 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( NewSid, 1 )) = DOMAIN_ALIAS_RID_ADMINS;

    return TRUE;
}



PVOID
CANNED_SECURITY::GenerateCannedSd(
    IN  CANNED_SECURITY_TYPE    SecurityType,
    IN  ACCESS_MASK             GrantedAccess,
    IN  PSID                    AdminsSid,
    IN  PSID                    SystemSid,
    IN  HANDLE                  TokenHandle,
    OUT PULONG                  Length
    )
/*++

Routine Description:

    This method generates a self-relative Security Descriptor
    which grants the specified access to System and Administrators.

Arguments:

    SecurityType    --  Identifies the sort of security descriptor to generate
    GrantedAccess   --  Supplies the access that System and Administrators
                        will have to the file protected by this Security
                        Descriptor.  A value of zero indicates that no
                        aces are to be created.
    AdminsSid       --  Supplies the SID for Administrators.
    SystemSid       --  Supplies the SID for System.
    Length          --  Receives the length of the Security Descriptor.

Return Value:

    A pointer to the generated Security Descriptor.  NULL indicates
    failure.

--*/
{
    CONST CannedAclBufferLength = 4096;
    BYTE  CannedAclBuffer[CannedAclBufferLength];

    SECURITY_DESCRIPTOR AbsoluteSd;
    PSECURITY_DESCRIPTOR SelfRelativeSd;
    NTSTATUS Status;

    // Create an absolute Security Descriptor.
    //
    Status = RtlCreateSecurityDescriptor( &AbsoluteSd,
                                          SECURITY_DESCRIPTOR_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "RtlCreateSecurityDescriptor failed--status 0x%x.\n", Status ));
        return NULL;
    }

    //
    // got rid of setting of owner as Admin (see WinSE #:6709, Whistler #:53503)
    //

    //
    // The group is ADMINS.
    //

    Status = RtlSetGroupSecurityDescriptor( &AbsoluteSd,
                                            AdminsSid,
                                            TRUE );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlSetGroupSecurityDescriptor failed--status 0x%x\n", Status ));
        return NULL;
    }

    switch (SecurityType) {
        case NoAccessCannedSd:
        case ReadCannedSd:
        case WriteCannedSd:
        case EditCannedSd:
            // The client wants to put a discretionary ACL on this
            // security descriptor.
            //
            if( !GenerateCannedAcl( (PACL)CannedAclBuffer,
                                    CannedAclBufferLength,
                                    GrantedAccess,
                                    AdminsSid,
                                    SystemSid ) ) {

                return NULL;
            }
            break;

        case NoAclCannedSd:
            // The client has not specified a discretionary ACL, so
            // we'll create an ACL that grants full access to all
            // the world.
            //
            if( !GenerateWorldAcl( (PACL)CannedAclBuffer,
                                   CannedAclBufferLength ) ) {

                return NULL;
            }
            break;

        case EditWorldCannedDirSd:
            // The client has not specified a discretionary ACL, so
            // we'll create an ACL that grants full access to all
            // the world.
            //
            if( !GenerateCannedWorldDirAcl( (PACL)CannedAclBuffer,
                                            CannedAclBufferLength,
                                            GrantedAccess,
                                            AdminsSid,
                                            SystemSid ) ) {

                return NULL;
            }
            break;

        case EditWorldCannedFileSd:
            // The client has not specified a discretionary ACL, so
            // we'll create an ACL that grants full access to all
            // the world.
            //
            if( !GenerateCannedWorldFileAcl( (PACL)CannedAclBuffer,
                                             CannedAclBufferLength,
                                             GrantedAccess,
                                             AdminsSid,
                                             SystemSid ) ) {

                return NULL;
            }
            break;

        case NewRootSd:

            if( !GenerateCannedNewRootAcl( (PACL)CannedAclBuffer,
                                           CannedAclBufferLength ) ) {

                return NULL;
            }

            break;

        default:
            DebugPrintTrace(("IFSUTIL: Unknown security type %d\n", SecurityType));
            return NULL;
    }

    // Attach the new ACL to the Security Descriptor.  Pass in
    // TRUE for DaclPresent (since that's what we're setting)
    // and for DaclDefaulted (since these canned Security
    // Descriptors are defaults).
    //
    Status = RtlSetDaclSecurityDescriptor( &AbsoluteSd,
                                           TRUE,
                                           (PACL)CannedAclBuffer,
                                           TRUE );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "RtlSetDaclSecurityDescriptor failed--status 0x%x.\n", Status ));
        return NULL;
    }

    // Now call RtlNewSecurityObject to massage this security
    // descriptor into a self-relative security descriptor
    // that canned be slammed onto files.
    //
    Status = RtlNewSecurityObject( NULL,
                                   &AbsoluteSd,
                                   &SelfRelativeSd,
                                   FALSE,
                                   TokenHandle,
                                   &IopFileMapping );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL:  RtlNewSecurityObject failed--status = 0x%x\n", Status ));
        return NULL;
    }

    // Make sure the returned security descriptor is valid:
    //
    if( !RtlValidSecurityDescriptor( SelfRelativeSd ) ) {

        DebugPrint( "IFSUTIL: RtlNewSecurityObject did not return a valid security descriptor.\n" );

        RtlFreeHeap( RtlProcessHeap(), 0, SelfRelativeSd );
        return NULL;
    }

    *Length = RtlLengthSecurityDescriptor( SelfRelativeSd );
    return SelfRelativeSd;
}


BOOLEAN
CANNED_SECURITY::GenerateCannedAcl(
    IN  PACL        AclBuffer,
    IN  ULONG       BufferLength,
    IN  ACCESS_MASK GrantedAccess,
    IN  PSID        AdminsSid,
    IN  PSID        SystemSid
    )
/*++

Routine Description:

    This method builds up an ACL in the supplied buffer.

Arguments:

    AclBuffer       --  Supplies the buffer in which to build the ACL.
    BufferLength    --  Supplies the length of the buffer (in bytes).
    GrantedAccess   --  Supplies the access the ACL will grant to
                        SYSTEM and ADMINS.
    AdminsSid       --  Supplies the SID for administrators.
    SystemSid       --  Supplies the SID for SYSTEM.

--*/
{
    ACL_SIZE_INFORMATION AclSizeInfo;
    PACL NewAcl;
    NTSTATUS Status;

    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //
    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    // Now determine the size of this ACL:
    //
    RtlQueryInformationAcl( NewAcl,
                            &AclSizeInfo,
                            sizeof( ACL_SIZE_INFORMATION ),
                            AclSizeInformation );

    // Now reinitialize and rebuild the ACL with the correct size:
    //
    Status = RtlCreateAcl( NewAcl, AclSizeInfo.AclBytesInUse, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::GenerateCannedWorldDirAcl(
    IN  PACL        AclBuffer,
    IN  ULONG       BufferLength,
    IN  ACCESS_MASK GrantedAccess,
    IN  PSID        AdminsSid,
    IN  PSID        SystemSid
    )
/*++

Routine Description:

    This method builds up an ACL in the supplied buffer.

Arguments:

    AclBuffer       --  Supplies the buffer in which to build the ACL.
    BufferLength    --  Supplies the length of the buffer (in bytes).
    GrantedAccess   --  Supplies the access the ACL will grant to
                        SYSTEM and ADMINS.
    AdminsSid       --  Supplies the SID for administrators.
    SystemSid       --  Supplies the SID for SYSTEM.

--*/
{
    ACL_SIZE_INFORMATION    AclSizeInfo;
    PACL                    NewAcl;
    NTSTATUS                Status;
    CONST                   WorldSidBufferLength = 64;
    BYTE                    WorldSidBuffer[WorldSidBufferLength];
    ULONG                   WorldSidLength = WorldSidBufferLength;
    PSID                    WorldSid = (PSID)WorldSidBuffer;

    if( !QueryWorldSid( WorldSid, &WorldSidLength ) ) {

        return FALSE;
    }

    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //
    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = AddInheritableAccessAllowedAce ( NewAcl,
                                                  ACL_REVISION,
                                                  GrantedAccess,
                                                  OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                                  SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = AddInheritableAccessAllowedAce( NewAcl,
                                                 ACL_REVISION,
                                                 GrantedAccess,
                                                 OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                                 AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    // Now determine the size of this ACL:
    //
    RtlQueryInformationAcl( NewAcl,
                            &AclSizeInfo,
                            sizeof( ACL_SIZE_INFORMATION ),
                            AclSizeInformation );

    // Now reinitialize and rebuild the ACL with the correct size:
    //
    Status = RtlCreateAcl( NewAcl, AclSizeInfo.AclBytesInUse, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = AddInheritableAccessAllowedAce( NewAcl,
                                                 ACL_REVISION,
                                                 GrantedAccess,
                                                 OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                                 SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = AddInheritableAccessAllowedAce( NewAcl,
                                                 ACL_REVISION,
                                                 GrantedAccess,
                                                 OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                                 AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    return TRUE;
}



BOOLEAN
CANNED_SECURITY::GenerateCannedNewRootAcl(
    IN  PACL        AclBuffer,
    IN  ULONG       BufferLength
    )
/*++

Routine Description:

    This method builds up an the following ACL in the supplied buffer:

            BUILTIN\Administrators:(OI)(CI)F
            NT AUTHORITY\SYSTEM:(OI)(CI)F
            CREATOR OWNER:(OI)(CI)(IO)F
            BUILTIN\Users:(OI)(CI)R
            BUILTIN\Users:(CI)(special access:) FILE_APPEND_DATA
            BUILTIN\Users:(CI)(IO)(special access:) FILE_WRITE_DATA
            Everyone:R

    Where:

        OI stands for Object Inherit
        CI stands for Container Inherit
        IO stands for Inherit Only

Arguments:

    AclBuffer       --  Supplies the buffer in which to build the ACL.
    BufferLength    --  Supplies the length of the buffer (in bytes).

--*/
{
    ACL_SIZE_INFORMATION    AclSizeInfo;
    PACL                    NewAcl;
    NTSTATUS                Status;

    CONST                   SidBufferLength = 256;
    BYTE                    SidBuffer[SidBufferLength];
    ULONG                   SidLength = SidBufferLength;
    PSID                    Sid = (PSID)SidBuffer;

    //
    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //

    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add Adminstrator:F CI OI
    //

    if( !QueryAdminsSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QueryAdminsSid failed\n"));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             Sid );
    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add Admin SID to ACL failed--status 0x%x.\n", Status ));
         return FALSE;
    }

    //
    // Add System:F CI OI
    //

    SidLength = SidBufferLength;
    if( !QuerySystemSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QuerySystemSid failed\n"));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             Sid );
    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add System SID to ACL failed--status 0x%x.\n", Status ));
         return FALSE;
    }

    //
    // Add Creator Owner:F CI OI IO
    //

    SidLength = SidBufferLength;
    if( !QueryCreatorOwnerSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QueryCreatorOwnerSid failed\n"));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
                                             Sid );
    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add Creator Owner SID to ACL failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add Users: Read, Execute, Synchronize CI OI
    //

    SidLength = SidBufferLength;
    if( !QueryUsersSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QueryUsersSid failed\n"));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_READ | FILE_EXECUTE | SYNCHRONIZE,
                                             CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                                             Sid );

    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add First Users SID to ACL failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add Users: Create Directory CI (must be different ACE from above, because
    //            Create Directory is the same bit as FILE_APPEND_DATA, so we can't let
    //            it inherit to files.
    //

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             FILE_ADD_SUBDIRECTORY,
                                             CONTAINER_INHERIT_ACE,
                                             Sid );

    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add Second Users SID to ACL failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add Users: Add File CI IO
    //

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             FILE_ADD_FILE,
                                             CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
                                             Sid );

    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add Third Users SID to ACL failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add World:R CI OI + traverse + synchronize (for cmd.exe)
    //

    SidLength = SidBufferLength;
    if( !QueryWorldSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QueryWorldSid failed\n"));
        return FALSE;
    }

    Status = RtlAddAccessAllowedAce( NewAcl,
                                     ACL_REVISION,
                                     GENERIC_READ | FILE_TRAVERSE | SYNCHRONIZE,
                                     Sid );
    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add World SID to ACL failed--status 0x%x.\n", Status ));
         return FALSE;
    }

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::GenerateCannedWorldFileAcl(
    IN  PACL        AclBuffer,
    IN  ULONG       BufferLength,
    IN  ACCESS_MASK GrantedAccess,
    IN  PSID        AdminsSid,
    IN  PSID        SystemSid
    )
/*++

Routine Description:

    This method builds up an ACL in the supplied buffer.

Arguments:

    AclBuffer       --  Supplies the buffer in which to build the ACL.
    BufferLength    --  Supplies the length of the buffer (in bytes).
    GrantedAccess   --  Supplies the access the ACL will grant to
                        SYSTEM and ADMINS.
    AdminsSid       --  Supplies the SID for administrators.
    SystemSid       --  Supplies the SID for SYSTEM.

--*/
{
    ACL_SIZE_INFORMATION    AclSizeInfo;
    PACL                    NewAcl;
    NTSTATUS                Status;
    CONST                   WorldSidBufferLength = 64;
    BYTE                    WorldSidBuffer[WorldSidBufferLength];
    ULONG                   WorldSidLength = WorldSidBufferLength;
    PSID                    WorldSid = (PSID)WorldSidBuffer;

    if( !QueryWorldSid( WorldSid, &WorldSidLength ) ) {

        return FALSE;
    }

    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //
    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = RtlAddAccessAllowedAce( NewAcl,
                                     ACL_REVISION,
                                     GENERIC_ALL,
                                     WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = RtlAddAccessAllowedAce ( NewAcl,
                                          ACL_REVISION,
                                          GrantedAccess,
                                          SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    // Now determine the size of this ACL:
    //
    RtlQueryInformationAcl( NewAcl,
                            &AclSizeInfo,
                            sizeof( ACL_SIZE_INFORMATION ),
                            AclSizeInformation );

    // Now reinitialize and rebuild the ACL with the correct size:
    //
    Status = RtlCreateAcl( NewAcl, AclSizeInfo.AclBytesInUse, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = RtlAddAccessAllowedAce( NewAcl,
                                     ACL_REVISION,
                                     GENERIC_ALL,
                                     WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    return TRUE;
}


#endif // _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\dcache.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "dcache.hxx"


DEFINE_CONSTRUCTOR( DRIVE_CACHE, OBJECT );


DRIVE_CACHE::~DRIVE_CACHE(
    )
/*++

Routine Description:

    Destructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
DRIVE_CACHE::Construct (
	)
/*++

Routine Description:

    Contructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


VOID
DRIVE_CACHE::Destroy(
    )
/*++

Routine Description:

    Destructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


BOOLEAN
DRIVE_CACHE::Initialize(
    IN OUT  PIO_DP_DRIVE    Drive
    )
/*++

Routine Description:

    This routine initializes a DRIVE_CACHE object.

Arguments:

    Drive   - Supplies the drive to cache for.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Drive);

    Destroy();
    _drive = Drive;
    return TRUE;
}


BOOLEAN
DRIVE_CACHE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads the requested sectors directly from the disk.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies the buffer to read the run of sectors to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_drive);
    return _drive->HardRead(StartingSector, NumberOfSectors, Buffer);
}


BOOLEAN
DRIVE_CACHE::Write(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    IN  PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes the requested sectors directly to the disk.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_drive);
    return _drive->HardWrite(StartingSector, NumberOfSectors, Buffer);
}


BOOLEAN
DRIVE_CACHE::Flush(
    )
/*++

Routine Description:

    This routine flushes all dirty cache blocks to disk.  This routine
    returns FALSE if there has ever been an write error since the last
    flush.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\drive.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    drive.cxx

Abstract:

    Provide drive methods.
    See drive.hxx for details.

Author:

        Mark Shavlik (marks) Jun-90
        Norbert P. Kusters (norbertk) 22-Feb-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "drive.hxx"
#include "rtmsg.h"
#include "message.hxx"
#include "numset.hxx"
#include "dcache.hxx"
#include "hmem.hxx"
#include "ifssys.hxx"

extern "C" {
#include <stdio.h>
#include <ntdddisk.h>
#include <initguid.h>
#include <diskguid.h>
#include <mountmgr.h>

#include "bootreg.h"
};

#if defined(IO_PERF_COUNTERS)
LARGE_INTEGER IO_DP_DRIVE::_wtotal = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_rtotal = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_ctotal = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_rrtotal = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_wcount = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_rcount = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_wsize = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_rsize = {0, 0};
#endif

//#define TRAP_A_WRITE    1
//#define TRAP_A_READ     1

// Don't lock down more that 64K for IO.
CONST   MaxIoSize   = 65536;

DEFINE_CONSTRUCTOR( DRIVE, OBJECT );

VOID
DRIVE::Construct (
        )
/*++

Routine Description:

    Contructor for DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
        // unreferenced parameters
        (void)(this);
}


DRIVE::~DRIVE(
    )
/*++

Routine Description:

    Destructor for DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
DRIVE::Initialize(
    IN      PCWSTRING    NtDriveName,
    IN OUT  PMESSAGE     Message
    )
/*++

Routine Description:

    This routine initializes a drive object.

Arguments:

    NtDriveName - Supplies an NT style drive name.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!NtDriveName) {
        Destroy();
        return FALSE;
    }

    if (!_name.Initialize(NtDriveName)) {
        Destroy();
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    return TRUE;
}


VOID
DRIVE::Destroy(
    )
/*++

Routine Description:

    This routine returns a DRIVE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
        // unreferenced parameters
        (void)(this);
}


DEFINE_EXPORTED_CONSTRUCTOR( DP_DRIVE, DRIVE, IFSUTIL_EXPORT );

VOID
DP_DRIVE::Construct (
        )
/*++

Routine Description:

    Constructor for DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(&_actual, 0, sizeof(DRTYPE));
    _supported_list = NULL;
    _num_supported = 0;
    _alignment_mask = 0;
    _last_status = 0;
    _handle = 0;
    _alternate_handle = 0;
    _hosted_drive = FALSE;
    _super_floppy = FALSE;
    _is_writeable = FALSE;
    _is_primary_partition = FALSE;
    _is_system_partition = FALSE;
#if defined(FE_SB) && defined(_X86_)
    _format_type = NONE;
#endif
    memset(&_partition_info, 0, sizeof(_partition_info));
    _sony_ms = FALSE;
    _sony_ms_fmt_cmd = FALSE;
    _sony_ms_progress_indicator = FALSE;
    _ntfs_not_supported = FALSE;
}


IFSUTIL_EXPORT
DP_DRIVE::~DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

NTSTATUS
DP_DRIVE::OpenDrive(
    IN      PCWSTRING   NtDriveName,
    IN      ACCESS_MASK DesiredAccess,
    IN      BOOLEAN     ExclusiveWrite,
    OUT     PHANDLE     Handle,
    OUT     PULONG      Alignment,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This method is a worker function for the Initialize methods,
    to open a volume and determine its alignment requirement.

Arguments:

    NtDriveName     - Supplies the name of the drive.
    DesiredAccess   - Supplies the access the client desires to the volume.
    ExclusiveWrite  - Supplies a flag indicating whether the client
                      wishes to exclude other write handles.
    Handle          - Receives the handle to the opened volume.
    Alignment       - Receives the alignment requirement for the volume.
    Message         - Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.


--*/
{
    UNICODE_STRING              string;
    OBJECT_ATTRIBUTES           oa;
    IO_STATUS_BLOCK             status_block;
    FILE_ALIGNMENT_INFORMATION  alignment_info;
    MSGID                       MessageId;
    NTSTATUS                    Status;


    string.Length = (USHORT) NtDriveName->QueryChCount() * sizeof(WCHAR);
    string.MaximumLength = string.Length;
    string.Buffer = (PWSTR)NtDriveName->GetWSTR();

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    Status = NtOpenFile(Handle,
                        DesiredAccess,
                        &oa, &status_block,
                        FILE_SHARE_READ |
                        (ExclusiveWrite ? 0 : FILE_SHARE_WRITE),
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status)) {

        MessageId = ( Status == STATUS_ACCESS_DENIED ) ?
                                MSG_DASD_ACCESS_DENIED :
                                MSG_CANT_DASD;
        Message ? Message->DisplayMsg( MessageId ) : 1;
        return Status;
    }


    // Query the disk alignment information.

    Status = NtQueryInformationFile(*Handle,
                                    &status_block,
                                    &alignment_info,
                                    sizeof(FILE_ALIGNMENT_INFORMATION),
                                    FileAlignmentInformation);

    if (!NT_SUCCESS(Status)) {

        MessageId = (Status == STATUS_DEVICE_BUSY ||
                     Status == STATUS_DEVICE_NOT_READY ) ?
                        MSG_DEVICE_BUSY :
                        MSG_BAD_IOCTL;

        DebugPrintTrace(("IFSUTIL: Failed NtQueryInformationFile (%x)\n", Status));

        Message ? Message->DisplayMsg(MessageId) : 1;


        return Status;
    }

    *Alignment = alignment_info.AlignmentRequirement;

    //
    //  Set the ALLOW_EXTENDED_DASD_IO flag for the file handle,
    //  which ntfs format and chkdsk depend on to write the backup
    //  boot sector.  We ignore the return code from this, but we
    //  could go either way.
    //

    (VOID)NtFsControlFile( *Handle,
                           0, NULL, NULL,
                           &status_block,
                           FSCTL_ALLOW_EXTENDED_DASD_IO,
                           NULL, 0, NULL, 0);

    return Status;
}


IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsTransient,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes a DP_DRIVE object based on the supplied drive
    path.

Arguments:

    NtDriveName     - Supplies the drive path.
    Message         - Supplies an outlet for messages.
    IsTransient     - Supplies whether or not to keep the handle to the
                        drive open beyond this method.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined(RUN_ON_W2K)
    CONST NumMediaTypes         = 20;

    IO_STATUS_BLOCK             status_block;
    DISK_GEOMETRY               disk_geometry;
    DISK_GEOMETRY               media_types[NumMediaTypes];
    INT                         i;
    PARTITION_INFORMATION       partition_info;
    BOOLEAN                     partition;
    MSGID                       MessageId;
#if !defined(_AUTOCHECK_)
    PWCHAR                      wstr;
#else
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;
#endif

    Destroy();

    if (!DRIVE::Initialize(NtDriveName, Message)) {
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( NtDriveName,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              ExclusiveWrite,
                              &_handle,
                              &_alignment_mask,
                              Message );

    if(!NT_SUCCESS(_last_status)) {

        Destroy();
        DebugPrintTrace(("IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        return FALSE;
    }

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_IS_WRITABLE,
                                         NULL, 0, NULL, 0);

    _is_writeable = (_last_status != STATUS_MEDIA_WRITE_PROTECTED);

#if defined(FE_SB) && defined(_X86_)
    SetFormatType(FormatType);
#endif

#if defined(_AUTOCHECK_)
    _last_status = NtQueryVolumeInformationFile(_handle,
                                                &status_block,
                                                &DeviceInfo,
                                                sizeof(DeviceInfo),
                                                FileFsDeviceInformation);

    // this is from ::GetDriveType()

    if (!NT_SUCCESS(_last_status)) {
        _drive_type = UnknownDrive;
    } else if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) {
        _drive_type = RemoteDrive;
    } else {
        switch (DeviceInfo.DeviceType) {
          case FILE_DEVICE_NETWORK:
          case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            _drive_type = RemoteDrive;
             break;

          case FILE_DEVICE_CD_ROM:
          case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
             _drive_type = CdRomDrive;
             break;

          case FILE_DEVICE_VIRTUAL_DISK:
             _drive_type = RamDiskDrive;
             break;

          case FILE_DEVICE_DISK:
          case FILE_DEVICE_DISK_FILE_SYSTEM:

             if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                 _drive_type = RemovableDrive;
                 }
             else {
                 _drive_type = FixedDrive;
                 }
             break;

          default:
             _drive_type = UnknownDrive;
             break;
        }
    }
#endif

    // Record that this is not a hosted volume:
    //
    _hosted_drive = FALSE;

    // Query the disk geometry.

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                         NULL, 0, &disk_geometry,
                                         sizeof(DISK_GEOMETRY));

    if (!NT_SUCCESS(_last_status)) {
       DebugPrintTrace(("IFSUTIL: Can't query disk geometry. Status returned = %x.\n", _last_status));
       if ((_last_status == STATUS_UNSUCCESSFUL) ||
            (_last_status == STATUS_UNRECOGNIZED_MEDIA)) {
            disk_geometry.MediaType = Unknown;
        } else {
            Destroy();
            switch( _last_status ) {

                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_CANT_DASD;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }

            Message ? Message->DisplayMsg(MessageId) : 1;

            return FALSE;
        }
    }

    if (disk_geometry.MediaType == Unknown) {
        memset(&disk_geometry, 0, sizeof(DISK_GEOMETRY));
        disk_geometry.MediaType = Unknown;
    }

    partition = FALSE;

    // Try to read the partition entry.

    if (disk_geometry.MediaType == FixedMedia ||
        disk_geometry.MediaType == RemovableMedia) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_PARTITION_INFO,
                                             NULL, 0, &partition_info,
                                             sizeof(PARTITION_INFORMATION));

        partition = (BOOLEAN) NT_SUCCESS(_last_status);

        if (!NT_SUCCESS(_last_status) &&
            _last_status != STATUS_INVALID_DEVICE_REQUEST) {
            DebugPrintTrace(("IFSUTIL: Can't read partition entry. Status returned = %x.\n", _last_status));
            Destroy();
            Message ? Message->DisplayMsg(MSG_READ_PARTITION_TABLE) : 1;
            return FALSE;
        }

    }


    // Store the information in the class.

    if (partition) {

        //
        // Preserve the partition information in the drive object.
        //
        _partition_info = partition_info;

#if defined(FE_SB) && defined(_X86_)
        // PC98 Oct.21.1995
        // PC98 must support ATA cards which is formatted with similar
        // AT compatible machine.
        // So we need to know whether it is ATA card or not to judge the way of
        // format(PC98 or AT compatible).
        //
        // NEC Oct.15.1994
        // PC98 Oct.31.1994
        // PC98 supports special FAT file system. Its sector size is imaginay.
        // This idea was based on specification of early DOS (not PC-DOS)
        // when we had to support large device at DOS 3.x.
        // The logical sector (SectorSize in BPB) is not always same size
        // as the Physical sector (SectorSize of target disk's specification).
        // For example, Logical sector was made from collecting 4 Physical sector,
        // we could support 128MB partition in DOS 3.x.
        //   2048(bytes per LOGICAL sector) * 0xFFFF(sectors) = 128MB(-2048bytes)
        //
        // PC98 supports special HPFS, too.
        // It is made on disks whose physical sector size is 2048 bytes.
        // We realized it to congeal 4 logical sectors on 1 physical sector,
        // when MS OS/2 v1.21.

        if (IsPC98_N()) {
            if (disk_geometry.MediaType == RemovableMedia)
                _next_format_type = FORMAT_MEDIA_AT;
            else
                _next_format_type = FORMAT_MEDIA_98;
        }

        if (IsPC98_N() && _next_format_type!=FORMAT_MEDIA_AT) {
            PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK  Bpb_Data;
            BIG_INT     numSectors = 0;

            _actual.PhysicalHiddenSectors =
                            (BIG_INT)(partition_info.StartingOffset /
                                      disk_geometry.BytesPerSector);
            // June.23.1995
            // store phisicalsectorsize for QueryPhysicalSectorSize

            _actual.PhysicalSectorSize = 0L;
            memcpy(&_actual.PhysicalSectorSize,&disk_geometry.BytesPerSector,sizeof(USHORT));

            if (QueryFormatType() == NONE ){
                ULONG       buffer_size = 10*1024;
                HMEM        hmem;
                PUCHAR      Buffer;
                ULONG       tmp = 0L;
                BIG_INT     biSectors;

                if (!hmem.Acquire(buffer_size, QueryAlignmentMask())) {
                    return FALSE;
                }
                Buffer = (PUCHAR)hmem.GetBuf();

                Bpb_Data = (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer;

                _last_status = NtReadFile(_handle, 0, NULL, NULL,
                                          &status_block,
                                          Buffer, buffer_size,
                                          NULL, NULL);

                if (NT_ERROR(_last_status) ||
                    status_block.Information != buffer_size) {
                    return FALSE;

                }

                memcpy(&tmp, Bpb_Data->Bpb.Sectors, sizeof(USHORT));

                if (!tmp) {
                    memcpy(&tmp, Bpb_Data->Bpb.LargeSectors, sizeof(ULONG));
                }

                biSectors = (BIG_INT)tmp;

                if (IFS_SYSTEM::IsThisFat( biSectors,
                                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer)) {
                    //
                    // set Logical sector size
                    //
                    memcpy(&disk_geometry.BytesPerSector,
                           Bpb_Data->Bpb.BytesPerSector, sizeof(USHORT));
                } else if (IFS_SYSTEM::IsThisHpfs( biSectors,
                                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer,
                                (PULONG)(&Buffer[16*512]),    // super block
                                (PULONG)(&Buffer[17*512]))) { // spare block
                    //
                    // emulate HPFS made on not 512 bytes/sector with
                    // exclusive driver that we are prepared.
                    // June.23.1995 bug fix

                    if (disk_geometry.BytesPerSector != 512) {
                        disk_geometry.BytesPerSector = 512;
                    }
                } else {
                    // none
                }

#if 0 // We do not support the format of logical sector != 512 on NT4.0
      // merged by V-HIDEKK 1996.10.14
            } else
            if (QueryFormatType() == FAT) {
                if (disk_geometry.MediaType != FixedMedia &&
                    disk_geometry.MediaType != RemovableMedia ||
                    partition_info.PartitionLength >= (129<<20)) {
                    // FD & 3.5"MO & Large Partition

                } else if (disk_geometry.BytesPerSector == 2048 ||
                    partition_info.PartitionLength >= (65<<20)) {
                    //  Small partition (Logical sector size = 2048)

                    disk_geometry.BytesPerSector = 2048;
                    if((numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector)
                       > 0xFFFF){
                      numSectors = 0xFFFF;
                    }

                } else {
                    //  Small partition (Logical sector size = 1024)

                    disk_geometry.BytesPerSector = 1024;
                    if((numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector)
                       > 0xFFFF){
                      numSectors = 0xFFFF;
                    }
                }

            } else
            if (QueryFormatType() == HPFS){
                if (disk_geometry.BytesPerSector == 2048)
                    disk_geometry.BytesPerSector = 512;
            }
#endif // #if 0:
            }
            if(numSectors == 0){
                 numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector;
            }
            DiskGeometryToDriveType(&disk_geometry,
                                    numSectors,
                                    partition_info.HiddenSectors,
                                    &_actual);

        } else if (IsFMR_N()) {

            // FMR Jul.14.1994 SFT KMR
            // Check the sector_length by the partition size
            // FMR's sector size is different, when partition size changed.
            // Set under 126MB is 1024 or 2048Byte, or 2048Byte.
            // Nothing sector size 512.

            if (partition_info.PartitionType == PARTITION_FAT_12) {
                if(partition_info.PartitionLength <= 3*1024*1024)
                    disk_geometry.BytesPerSector = 1024;
                else
                    disk_geometry.BytesPerSector = 2048;
            } else if (partition_info.PartitionType == PARTITION_FAT_16 ||
                       partition_info.PartitionType == PARTITION_HUGE)
                disk_geometry.BytesPerSector = 2048;
        } else if (IsPC98_N() && _next_format_type == FORMAT_MEDIA_AT){
            _actual.PhysicalHiddenSectors =
                         (BIG_INT)(partition_info.StartingOffset /
                          disk_geometry.BytesPerSector);
            _actual.PhysicalSectorSize = 0L;
            memcpy(&_actual.PhysicalSectorSize,&disk_geometry.BytesPerSector,sizeof(USHORT));
        }

        if (!IsPC98_N() || (IsPC98_N() && _next_format_type==FORMAT_MEDIA_AT))
#endif // FE_SB && _X86_

        DiskGeometryToDriveType(&disk_geometry,
                                partition_info.PartitionLength/
                                disk_geometry.BytesPerSector,
                                partition_info.HiddenSectors,
                                &_actual);

#if !defined(_AUTOCHECK_)
        if (Message && (wstr = _wgetenv(L"5XUFWX_FORMAT_SECTORS"))) {

            ULONG   sectors;
            INT     r;

            r = swscanf(wstr, L"%d", &sectors);
            if (r != 0 && r != EOF && sectors != 0 &&
                sectors <= _actual.Sectors.GetLowPart()) {
                Message->DisplayMsg(MSG_FMT_SECTORS, "%d", sectors);
                _actual.Sectors.Set(sectors, 0);
            } else {
                Message->DisplayMsg(MSG_FMT_BAD_SECTORS);
                return FALSE;
            }
        }
#endif

    } else {

        DiskGeometryToDriveType(&disk_geometry, &_actual);

        if (IsFloppy()) {

            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_GET_MEDIA_TYPES,
                                                 NULL, 0, media_types,
                                                 NumMediaTypes*
                                                 sizeof(DISK_GEOMETRY));

            if (!NT_SUCCESS(_last_status)) {
                DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_MEDIA_TYPES (%x)\n", _last_status));
                Destroy();
                if (Message) {

                    MSGID   MessageId;

                    switch (_last_status) {
                        case STATUS_NO_MEDIA_IN_DEVICE:
                            MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                            break;

                        case STATUS_DEVICE_BUSY:
                        case STATUS_DEVICE_NOT_READY:
                            MessageId = MSG_DEVICE_BUSY;
                            break;

                        default:
                            MessageId = MSG_BAD_IOCTL;
                            break;
                    }
                    Message->DisplayMsg(MessageId);
                }
                return FALSE;
            }



            _num_supported = (INT) (status_block.Information/
                                    sizeof(DISK_GEOMETRY));

            if (!_num_supported) {
                Destroy();
                if (Message) {
                    Message->DisplayMsg(MSG_BAD_IOCTL);
                }
                return FALSE;
            }

#if defined(FE_SB)
            INT j;
            DISK_GEOMETRY temp;

#if defined(_X86_)
    // PC98 Aug.26,1996

            if (IsPC98_N()) {
                for(i = 0; i < _num_supported; i++) {
                    // Remove F5_360_512 Media Type
                    if(media_types[i].MediaType==F5_360_512) {
                        for(j = i; j < _num_supported - 1; j++) {
                            media_types[j]=media_types[j+1];
                        }
                        _num_supported--;
                    }
                    // Remove F8_256_128 Media Type
                    if(media_types[i].MediaType==F8_256_128) {
                        for(j = i; j < _num_supported - 1; j++) {
                            media_types[j]=media_types[j+1];
                        }
                        _num_supported--;
                    }
                }
            }
#endif // _X86_

            // NT-US diaplays the dialog box by MediaType order.
            // The MediaType order matches media size order on NT-US.
            // But PC98 has more media_types than US one.
            // And these does NOT match on PC98.
            // We wish to display the dialog box by size order.
            // See also..
            //   \nt\private\utils\fmifs\src\format.cxx
            //   QuerySupportedMedia()

            for(i = 0; i < _num_supported ; i++) {
                for(j = 0; j < _num_supported - 1; j++) {
                    if(media_types[j].Cylinders.LowPart *
                       media_types[j].TracksPerCylinder *
                       media_types[j].SectorsPerTrack *
                       media_types[j].BytesPerSector <
                       media_types[j+1].Cylinders.LowPart *
                       media_types[j+1].TracksPerCylinder *
                       media_types[j+1].SectorsPerTrack *
                       media_types[j+1].BytesPerSector) {
                         temp=media_types[j];
                         media_types[j]=media_types[j+1];
                         media_types[j+1]=temp;
                     }
                 }
            }
#endif // FE_SB
                        if (!(_supported_list = NEW DRTYPE[_num_supported])) {
                Destroy();
                Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
                return FALSE;
            }

            for (i = 0; i < _num_supported; i++) {
                DiskGeometryToDriveType(&media_types[i], &_supported_list[i]);
            }
        }
    }

    if (!_num_supported) {
        _num_supported = 1;

        if (!(_supported_list = NEW DRTYPE[1])) {
            Destroy();
            Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
            return FALSE;
        }

        _supported_list[0] = _actual;
    }

    if (!CheckForPrimaryPartition()) {
        DebugPrintTrace(("IFSUTIL: Failed CheckForPrimaryPartition (%x)\n", _last_status));
        Destroy();
        if (Message) {

            MSGID   MessageId;

            switch (_last_status) {
                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }
            Message->DisplayMsg(MessageId);
        }
        return FALSE;
    }

    if (!CheckForSystemPartition()) {

        switch (_last_status) {
          case STATUS_BUFFER_TOO_SMALL:
            return FALSE;   // should not continue as the buffer should be long enough

          case STATUS_OBJECT_NAME_NOT_FOUND:
            break;          // ignore this one since it can happen in textmode setup

          default:
            //
            // Let's not fail just because we cannot determine if this is a system partition
            // This can happen in textmode setup.
            //
            DebugPrintTrace(("IFSUTIL: Failed CheckForSystemPartition (%x).\n", _last_status));
        }
    }

    //
    // Determine whether the media is a super-floppy; non-floppy
    // removable media which is not partitioned.  Such media will
    // have but a single partition, normal media will have at least 4.
    //

    if (disk_geometry.MediaType == RemovableMedia) {

        CONST INT EntriesPerBootRecord = 4;
        CONST INT MaxLogicalVolumes = 23;
        CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION) +
                            EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                                sizeof(PARTITION_INFORMATION);

        UCHAR buf[Length];

        DRIVE_LAYOUT_INFORMATION *layout_info = (DRIVE_LAYOUT_INFORMATION *)buf;

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT,
                                             NULL, 0, layout_info,
                                             Length);

        if (!NT_SUCCESS(_last_status)) {
            DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_DRIVE_LAYOUT (%x)\n", _last_status));
            Destroy();
            if (Message) {

                MSGID   MessageId;

                switch (_last_status) {
                    case STATUS_NO_MEDIA_IN_DEVICE:
                        MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                        break;

                    case STATUS_DEVICE_BUSY:
                    case STATUS_DEVICE_NOT_READY:
                        MessageId = MSG_DEVICE_BUSY;
                        break;

                    default:
                        MessageId = MSG_BAD_IOCTL;
                        break;
                }
                Message->DisplayMsg(MessageId);
            }
            return FALSE;
        }

        if (layout_info->PartitionCount < 4) {

            _super_floppy = TRUE;
        }
    }

    if (!IsTransient) {
        NtClose(_handle);
        _handle = 0;
    }

    return TRUE;
#else // defined(RUN_ON_W2K)
    CONST NumMediaTypes             = 20;

    IO_STATUS_BLOCK                 status_block;
    DISK_GEOMETRY                   disk_geometry;
    DISK_GEOMETRY                   media_types[NumMediaTypes];
    INT                             i;
    PARTITION_INFORMATION_EX        partition_info;
    GET_LENGTH_INFORMATION          length_info;
    BOOLEAN                         partition;
    MSGID                           MessageId;
#if !defined(_AUTOCHECK_)
    PWCHAR                          wstr;
#else
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;
#endif

    Destroy();

    if (!DRIVE::Initialize(NtDriveName, Message)) {
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( NtDriveName,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              ExclusiveWrite,
                              &_handle,
                              &_alignment_mask,
                              Message );

    if(!NT_SUCCESS(_last_status)) {

        Destroy();
        DebugPrintTrace(("IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        return FALSE;
    }

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_IS_WRITABLE,
                                         NULL, 0, NULL, 0);

    _is_writeable = (_last_status != STATUS_MEDIA_WRITE_PROTECTED);

#if defined(FE_SB) && defined(_X86_)
    SetFormatType(FormatType);
#endif

#if defined(_AUTOCHECK_)
    _last_status = NtQueryVolumeInformationFile(_handle,
                                                &status_block,
                                                &DeviceInfo,
                                                sizeof(DeviceInfo),
                                                FileFsDeviceInformation);

    // this is from ::GetDriveType()

    if (!NT_SUCCESS(_last_status)) {
        _drive_type = UnknownDrive;
    } else if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) {
        _drive_type = RemoteDrive;
    } else {
        switch (DeviceInfo.DeviceType) {
          case FILE_DEVICE_NETWORK:
          case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            _drive_type = RemoteDrive;
             break;

          case FILE_DEVICE_CD_ROM:
          case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
             _drive_type = CdRomDrive;
             break;

          case FILE_DEVICE_VIRTUAL_DISK:
             _drive_type = RamDiskDrive;
             break;

          case FILE_DEVICE_DISK:
          case FILE_DEVICE_DISK_FILE_SYSTEM:

             if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                 _drive_type = RemovableDrive;
                 }
             else {
                 _drive_type = FixedDrive;
                 }
             break;

          default:
             _drive_type = UnknownDrive;
             break;
        }
    }
#endif

    // Record that this is not a hosted volume:
    //
    _hosted_drive = FALSE;


    // Query the disk geometry.

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                         NULL, 0, &disk_geometry,
                                         sizeof(DISK_GEOMETRY));

    if (!NT_SUCCESS(_last_status)) {
       DebugPrintTrace(("IFSUTIL: Can't query disk geometry. Status returned = %x.\n", _last_status));
       if ((_last_status == STATUS_UNSUCCESSFUL) ||
            (_last_status == STATUS_UNRECOGNIZED_MEDIA)) {
            disk_geometry.MediaType = Unknown;
        } else {
            Destroy();
            switch( _last_status ) {

                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_CANT_DASD;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }

            Message ? Message->DisplayMsg(MessageId) : 1;

            return FALSE;
        }
    }

    if (disk_geometry.MediaType == Unknown) {
        memset(&disk_geometry, 0, sizeof(DISK_GEOMETRY));
        disk_geometry.MediaType = Unknown;
    }

    partition = FALSE;

    // Try to read the partition entry.

    if (disk_geometry.MediaType == FixedMedia ||
        disk_geometry.MediaType == RemovableMedia) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_LENGTH_INFO,
                                             NULL, 0, &length_info,
                                             sizeof(GET_LENGTH_INFORMATION));

        partition = (BOOLEAN) NT_SUCCESS(_last_status);

        if (!NT_SUCCESS(_last_status) &&
            _last_status != STATUS_INVALID_DEVICE_REQUEST) {
            DebugPrintTrace(("IFSUTIL: Can't get volume size. Status returned = %x.\n", _last_status));
            Destroy();
            Message ? Message->DisplayMsg(MSG_READ_PARTITION_TABLE) : 1;
            return FALSE;
        }

        if (partition) {

            _last_status = NtDeviceIoControlFile(
                               _handle, 0, NULL, NULL, &status_block,
                               IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
                               &partition_info,
                               sizeof(PARTITION_INFORMATION_EX));

            if (!NT_SUCCESS(_last_status)) {
                if (_last_status != STATUS_INVALID_DEVICE_REQUEST) {
                    DebugPrintTrace(("IFSUTIL: Can't read partition entry. Status returned = %x.\n", _last_status));
                    Destroy();
                    Message ? Message->DisplayMsg(MSG_READ_PARTITION_TABLE) : 1;
                    return FALSE;
                }

                //
                // GET_PARTITION_INFO_EX will fail outright on an EFI Dynamic
                // Volume.  In this case, just make up the starting offset
                // so that FORMAT/CHKDSK can proceed normally.
                //

                partition_info.PartitionStyle = PARTITION_STYLE_GPT;
                partition_info.StartingOffset.QuadPart = 0x7E00;
                partition_info.PartitionLength.QuadPart = length_info.Length.QuadPart;
                partition_info.Gpt.PartitionType = PARTITION_BASIC_DATA_GUID;
            }

            if (partition_info.PartitionStyle != PARTITION_STYLE_MBR) {

                // If this is EFI, then just make up reasonable MBR values
                // so that CHKDSK/FORMAT can proceed with business as usual.

                partition_info.PartitionStyle = PARTITION_STYLE_MBR;
                if (IsEqualGUID(partition_info.Gpt.PartitionType,
                                PARTITION_BASIC_DATA_GUID)) {

                    partition_info.Mbr.PartitionType = 0x7;
                } else {
                    partition_info.Mbr.PartitionType = 0xEE;
                }

                partition_info.Mbr.BootIndicator = FALSE;
                partition_info.Mbr.RecognizedPartition = TRUE;
                partition_info.Mbr.HiddenSectors =
                        (ULONG) (partition_info.StartingOffset.QuadPart/
                                 disk_geometry.BytesPerSector);
            }
        }
    }


    // Store the information in the class.

    if (partition) {

        _partition_info = partition_info;

#if defined(FE_SB) && defined(_X86_)
        // PC98 Oct.21.1995
        // PC98 must support ATA cards which is formatted with similar
        // AT compatible machine.
        // So we need to know whether it is ATA card or not to judge the way of
        // format(PC98 or AT compatible).
        //
        // NEC Oct.15.1994
        // PC98 Oct.31.1994
        // PC98 supports special FAT file system. Its sector size is imaginay.
        // This idea was based on specification of early DOS (not PC-DOS)
        // when we had to support large device at DOS 3.x.
        // The logical sector (SectorSize in BPB) is not always same size
        // as the Physical sector (SectorSize of target disk's specification).
        // For example, Logical sector was made from collecting 4 Physical sector,
        // we could support 128MB partition in DOS 3.x.
        //   2048(bytes per LOGICAL sector) * 0xFFFF(sectors) = 128MB(-2048bytes)
        //
        // PC98 supports special HPFS, too.
        // It is made on disks whose physical sector size is 2048 bytes.
        // We realized it to congeal 4 logical sectors on 1 physical sector,
        // when MS OS/2 v1.21.

        if (IsPC98_N()) {
            if (disk_geometry.MediaType == RemovableMedia)
                _next_format_type = FORMAT_MEDIA_AT;
            else
                _next_format_type = FORMAT_MEDIA_98;
        }

        if (IsPC98_N() && _next_format_type!=FORMAT_MEDIA_AT) {
            PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK  Bpb_Data;
            BIG_INT     numSectors = 0;

            _actual.PhysicalHiddenSectors =
                            (BIG_INT)(partition_info.StartingOffset /
                                      disk_geometry.BytesPerSector);
            // June.23.1995
            // store phisicalsectorsize for QueryPhysicalSectorSize

            _actual.PhysicalSectorSize = 0L;
            memcpy(&_actual.PhysicalSectorSize,&disk_geometry.BytesPerSector,sizeof(USHORT));

            if (QueryFormatType() == NONE ){
                ULONG       buffer_size = 10*1024;
                HMEM        hmem;
                PUCHAR      Buffer;
                ULONG       tmp = 0L;
                BIG_INT     biSectors;

                if (!hmem.Acquire(buffer_size, QueryAlignmentMask())) {
                    return FALSE;
                }
                Buffer = (PUCHAR)hmem.GetBuf();

                Bpb_Data = (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer;

                _last_status = NtReadFile(_handle, 0, NULL, NULL,
                                          &status_block,
                                          Buffer, buffer_size,
                                          NULL, NULL);

                if (NT_ERROR(_last_status) ||
                    status_block.Information != buffer_size) {
                    return FALSE;

                }

                memcpy(&tmp, Bpb_Data->Bpb.Sectors, sizeof(USHORT));

                if (!tmp) {
                    memcpy(&tmp, Bpb_Data->Bpb.LargeSectors, sizeof(ULONG));
                }

                biSectors = (BIG_INT)tmp;

                if (IFS_SYSTEM::IsThisFat( biSectors,
                                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer)) {
                    //
                    // set Logical sector size
                    //
                    memcpy(&disk_geometry.BytesPerSector,
                           Bpb_Data->Bpb.BytesPerSector, sizeof(USHORT));
                } else if (IFS_SYSTEM::IsThisHpfs( biSectors,
                                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer,
                                (PULONG)(&Buffer[16*512]),    // super block
                                (PULONG)(&Buffer[17*512]))) { // spare block
                    //
                    // emulate HPFS made on not 512 bytes/sector with
                    // exclusive driver that we are prepared.
                    // June.23.1995 bug fix

                    if (disk_geometry.BytesPerSector != 512) {
                        disk_geometry.BytesPerSector = 512;
                    }
                } else {
                    // none
                }

#if 0 // We do not support the format of logical sector != 512 on NT4.0
      // merged by V-HIDEKK 1996.10.14
            } else
            if (QueryFormatType() == FAT) {
                if (disk_geometry.MediaType != FixedMedia &&
                    disk_geometry.MediaType != RemovableMedia ||
                    partition_info.PartitionLength >= (129<<20)) {
                    // FD & 3.5"MO & Large Partition

                } else if (disk_geometry.BytesPerSector == 2048 ||
                    partition_info.PartitionLength >= (65<<20)) {
                    //  Small partition (Logical sector size = 2048)

                    disk_geometry.BytesPerSector = 2048;
                    if((numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector)
                       > 0xFFFF){
                      numSectors = 0xFFFF;
                    }

                } else {
                    //  Small partition (Logical sector size = 1024)

                    disk_geometry.BytesPerSector = 1024;
                    if((numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector)
                       > 0xFFFF){
                      numSectors = 0xFFFF;
                    }
                }

            } else
            if (QueryFormatType() == HPFS){
                if (disk_geometry.BytesPerSector == 2048)
                    disk_geometry.BytesPerSector = 512;
            }
#endif // #if 0:
            }
            if(numSectors == 0){
                 numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector;
            }
            DiskGeometryToDriveType(&disk_geometry,
                                    numSectors,
                                    partition_info.Mbr.HiddenSectors,
                                    &_actual);

        } else if (IsFMR_N()) {

            // FMR Jul.14.1994 SFT KMR
            // Check the sector_length by the partition size
            // FMR's sector size is different, when partition size changed.
            // Set under 126MB is 1024 or 2048Byte, or 2048Byte.
            // Nothing sector size 512.

            if (partition_info.Mbr.PartitionType == PARTITION_FAT_12) {
                if(partition_info.PartitionLength <= 3*1024*1024)
                    disk_geometry.BytesPerSector = 1024;
                else
                    disk_geometry.BytesPerSector = 2048;
            } else if (partition_info.Mbr.PartitionType == PARTITION_FAT_16 ||
                       partition_info.Mbr.PartitionType == PARTITION_HUGE)
                disk_geometry.BytesPerSector = 2048;
        } else if (IsPC98_N() && _next_format_type == FORMAT_MEDIA_AT){
            _actual.PhysicalHiddenSectors =
                         (BIG_INT)(partition_info.StartingOffset /
                          disk_geometry.BytesPerSector);
            _actual.PhysicalSectorSize = 0L;
            memcpy(&_actual.PhysicalSectorSize,&disk_geometry.BytesPerSector,sizeof(USHORT));
        }

        if (!IsPC98_N() || (IsPC98_N() && _next_format_type==FORMAT_MEDIA_AT))
#endif // FE_SB && _X86_

        DiskGeometryToDriveType(&disk_geometry,
                                partition_info.PartitionLength/
                                disk_geometry.BytesPerSector,
                                partition_info.Mbr.HiddenSectors,
                                &_actual);

#if !defined(_AUTOCHECK_)
        if (Message && (wstr = _wgetenv(L"5XUFWX_FORMAT_SECTORS"))) {

            ULONG   sectors;
            INT     r;

            r = swscanf(wstr, L"%d", &sectors);
            if (r != 0 && r != EOF && sectors != 0 &&
                sectors <= _actual.Sectors.GetLowPart()) {
                Message->DisplayMsg(MSG_FMT_SECTORS, "%d", sectors);
                _actual.Sectors.Set(sectors, 0);
            } else {
                Message->DisplayMsg(MSG_FMT_BAD_SECTORS);
                return FALSE;
            }
        }
#endif

    } else {

        DiskGeometryToDriveType(&disk_geometry, &_actual);

        if (IsFloppy()) {

            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_GET_MEDIA_TYPES,
                                                 NULL, 0, media_types,
                                                 NumMediaTypes*
                                                 sizeof(DISK_GEOMETRY));

            if (!NT_SUCCESS(_last_status)) {
                DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_MEDIA_TYPES (%x)\n", _last_status));
                Destroy();
                if (Message) {

                    MSGID   MessageId;

                    switch (_last_status) {
                        case STATUS_NO_MEDIA_IN_DEVICE:
                            MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                            break;

                        case STATUS_DEVICE_BUSY:
                        case STATUS_DEVICE_NOT_READY:
                            MessageId = MSG_DEVICE_BUSY;
                            break;

                        default:
                            MessageId = MSG_BAD_IOCTL;
                            break;
                    }
                    Message->DisplayMsg(MessageId);
                }
                return FALSE;
            }



            _num_supported = (INT) (status_block.Information/
                                    sizeof(DISK_GEOMETRY));

            if (!_num_supported) {
                Destroy();
                if (Message) {
                    Message->DisplayMsg(MSG_BAD_IOCTL);
                }
                return FALSE;
            }

#if defined(FE_SB)
            INT j;
            DISK_GEOMETRY temp;

#if defined(_X86_)
    // PC98 Aug.26,1996

            if (IsPC98_N()) {
                for(i = 0; i < _num_supported; i++) {
                    // Remove F5_360_512 Media Type
                    if(media_types[i].MediaType==F5_360_512) {
                        for(j = i; j < _num_supported - 1; j++) {
                            media_types[j]=media_types[j+1];
                        }
                        _num_supported--;
                    }
                    // Remove F8_256_128 Media Type
                    if(media_types[i].MediaType==F8_256_128) {
                        for(j = i; j < _num_supported - 1; j++) {
                            media_types[j]=media_types[j+1];
                        }
                        _num_supported--;
                    }
                }
            }
#endif // _X86_

            // NT-US diaplays the dialog box by MediaType order.
            // The MediaType order matches media size order on NT-US.
            // But PC98 has more media_types than US one.
            // And these does NOT match on PC98.
            // We wish to display the dialog box by size order.
            // See also..
            //   \nt\private\utils\fmifs\src\format.cxx
            //   QuerySupportedMedia()

            for(i = 0; i < _num_supported ; i++) {
                for(j = 0; j < _num_supported - 1; j++) {
                    if(media_types[j].Cylinders.LowPart *
                       media_types[j].TracksPerCylinder *
                       media_types[j].SectorsPerTrack *
                       media_types[j].BytesPerSector <
                       media_types[j+1].Cylinders.LowPart *
                       media_types[j+1].TracksPerCylinder *
                       media_types[j+1].SectorsPerTrack *
                       media_types[j+1].BytesPerSector) {
                         temp=media_types[j];
                         media_types[j]=media_types[j+1];
                         media_types[j+1]=temp;
                     }
                 }
            }
#endif // FE_SB
            if (!(_supported_list = NEW DRTYPE[_num_supported])) {
                Destroy();
                Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
                return FALSE;
            }

            for (i = 0; i < _num_supported; i++) {
                DiskGeometryToDriveType(&media_types[i], &_supported_list[i]);
            }
        }
    }

    if (!_num_supported) {
        _num_supported = 1;

        if (!(_supported_list = NEW DRTYPE[1])) {
            Destroy();
            Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
            return FALSE;
        }

        _supported_list[0] = _actual;
    }

    if (!CheckForPrimaryPartition()) {
        DebugPrintTrace(("IFSUTIL: Failed CheckForPrimaryPartition (%x)\n", _last_status));
        Destroy();
        if (Message) {

            MSGID   MessageId;

            switch (_last_status) {
                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }
            Message->DisplayMsg(MessageId);
        }
        return FALSE;
    }

    if (!CheckForSystemPartition()) {

        switch (_last_status) {
          case STATUS_BUFFER_TOO_SMALL:
            return FALSE;   // should not continue as the buffer should be long enough

          case STATUS_OBJECT_NAME_NOT_FOUND:
            break;          // ignore this one since it can happen in textmode setup

          default:
            //
            // Let's not fail just because we cannot determine if this is a system partition
            // This can happen in textmode setup.
            //
            DebugPrintTrace(("IFSUTIL: Failed CheckForSystemPartition (%x)\n", _last_status));
        }
    }

    //
    // Determine whether the media is a super-floppy; non-floppy
    // removable media which is not partitioned.  Such media will
    // have but a single partition, normal media will have at least 4.
    //

    if (disk_geometry.MediaType == RemovableMedia) {

        BOOLEAN   bFallBack = FALSE;

        CONST INT EntriesPerBootRecord = 4;
        CONST INT MaxLogicalVolumes = 23;
        CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                            EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                                sizeof(PARTITION_INFORMATION_EX);

        UCHAR buf[Length];

        DRIVE_LAYOUT_INFORMATION_EX *layout_info = (DRIVE_LAYOUT_INFORMATION_EX *)buf;

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                             NULL, 0, layout_info,
                                             Length);

#if 1
        if (!NT_SUCCESS(_last_status)) {

            if (_last_status == STATUS_INVALID_DEVICE_REQUEST) {

                CONST INT EntriesPerBootRecord = 4;
                CONST INT MaxLogicalVolumes = 23;
                CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION) +
                                    EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                                        sizeof(PARTITION_INFORMATION);

                UCHAR buf[Length];

                DRIVE_LAYOUT_INFORMATION *layout_info = (DRIVE_LAYOUT_INFORMATION *)buf;

                bFallBack = TRUE;

                _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                     &status_block,
                                                     IOCTL_DISK_GET_DRIVE_LAYOUT,
                                                     NULL, 0, layout_info,
                                                     Length);

                if (!NT_SUCCESS(_last_status)) {
                    DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_DRIVE_LAYOUT (%x)\n", _last_status));
                } else if (layout_info->PartitionCount < 4) {
                    _super_floppy = TRUE;
                }

            } else {
                DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_DRIVE_LAYOUT_EX (%x)\n", _last_status));
            }
        }
#endif

        if (!NT_SUCCESS(_last_status)) {

            Destroy();

            if (Message) {

                MSGID   MessageId;

                switch (_last_status) {
                    case STATUS_NO_MEDIA_IN_DEVICE:
                        MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                        break;

                    case STATUS_DEVICE_BUSY:
                    case STATUS_DEVICE_NOT_READY:
                        MessageId = MSG_DEVICE_BUSY;
                        break;

                    default:
                        MessageId = MSG_BAD_IOCTL;
                        break;
                }
                Message->DisplayMsg(MessageId);
            }
            return FALSE;
        }

        if (!bFallBack) {
            if (layout_info->PartitionStyle == PARTITION_STYLE_MBR) {
                if (layout_info->PartitionCount < 4) {
                    _super_floppy = TRUE;
                }
            } else if (layout_info->PartitionStyle == PARTITION_STYLE_GPT) {
                if (layout_info->PartitionCount == 1 &&
                    layout_info->PartitionEntry[0].StartingOffset.QuadPart == 0) {

                    _super_floppy = TRUE;
                }
            }
        }

        CheckHotPlugInfo();
        CheckSonyMS();

        if (IsSonyMS()) {

#if !defined(_AUTOCHECK_)

            STORAGE_BUS_TYPE    bus_type;

            if (QueryBusType(&bus_type) && BusTypeUsb == bus_type) {

                SONY_MS_INQUIRY_DATA    inquiry_data;

                if (SendSonyMSInquiryCmd(&inquiry_data)) {

                    if (0 == memcmp(inquiry_data.device_capability, "MEMORYSTICK         ", 20) ||
                        0 == memcmp(inquiry_data.device_capability, "MEMORYSTICK-MG      ", 20)) {

                        DebugPrintTrace(("IFSUTIL: Fmt cmd capable reader\n"));
                        _sony_ms_fmt_cmd = TRUE;

                        SONY_MS_MODE_SENSE_DATA mode_sense_data;

                        if (SendSonyMSModeSenseCmd(&mode_sense_data)) {
                            if (mode_sense_data.srfp) {
                                DebugPrintTrace(("IFSUTIL: Reader also supports progress bar\n"));
                                _sony_ms_progress_indicator = TRUE;
                            }
                        }
                    }
                }
            }
#endif
        }
    }

    if (!IsTransient) {
        NtClose(_handle);
        _handle = 0;
    }

    return TRUE;
#endif // defined(RUN_ON_W2K)
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsTransient,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This method initializes a hosted drive, i.e. a volume which
    is implemented as a file on another volume.  Instead of opening
    this file by its actual name, we open it by the host file name,
    to prevent interactions with the file system.

Arguments:

    NtDriveName     - Supplies the NT name of the drive itself.
    HostFileName    - Supplies the fully qualified name of the file
                      which contains this drive.
    Message         - Supplies an outlet for messages.
    IsTransient     - Supplies whether or not to keep the handle to the
                        drive open beyond this method.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    TRUE upon successful completion.

--*/
{
    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK StatusBlock;
    BIG_INT Sectors, FileSize;
    ULONG AlignmentMask, ExtraUlong;


    Destroy();

    if( !DRIVE::Initialize(HostFileName, Message)) {

        Destroy();
        return FALSE;
    }

    _hosted_drive = TRUE;

    // First, make the host file not-readonly.
    //
    if( !IFS_SYSTEM::FileSetAttributes( HostFileName,
                                        FILE_ATTRIBUTE_NORMAL,
                                        &_old_attributes ) ) {

        Message ? Message->DisplayMsg( MSG_CANT_DASD ) : 1;
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( HostFileName,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA |
                                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                              ExclusiveWrite,
                              &_handle,
                              &_alignment_mask,
                              Message );

    if( !NT_SUCCESS( _last_status ) ) {

        IFS_SYSTEM::FileSetAttributes( HostFileName,
                                       _old_attributes,
                                       &ExtraUlong );

        DebugPrintTrace(("IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        Destroy();
        return FALSE;
    }

    if( NtDriveName ) {

        _last_status = OpenDrive( NtDriveName,
                                  SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                  ExclusiveWrite,
                                  &_alternate_handle,
                                  &AlignmentMask,
                                  Message );
    }

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &StatusBlock,
                                         IOCTL_DISK_IS_WRITABLE,
                                         NULL, 0, NULL, 0);

    _is_writeable = (_last_status != STATUS_MEDIA_WRITE_PROTECTED);

    // Fill in the drive type information.  Everything except the
    // Sectors field is fixed by default.  The number of Sectors
    // on the drive is determined from the host file's size.
    //
    _actual.MediaType = HostedDriveMediaType;
    _actual.SectorSize = HostedDriveSectorSize;
    _actual.HiddenSectors = HostedDriveHiddenSectors;
    _actual.SectorsPerTrack = HostedDriveSectorsPerTrack;
    _actual.Heads = HostedDriveHeads;

    _last_status = NtQueryInformationFile( _handle,
                                           &StatusBlock,
                                           &FileStandardInfo,
                                           sizeof( FileStandardInfo ),
                                           FileStandardInformation );

    if( !NT_SUCCESS( _last_status ) ) {

        Destroy();
        Message ? Message->DisplayMsg( MSG_DISK_TOO_LARGE_TO_FORMAT ) : 1;
        return FALSE;
    }

    FileSize = FileStandardInfo.EndOfFile;
    Sectors = FileSize / _actual.SectorSize;

    if( Sectors.GetHighPart() != 0 ) {

        Destroy();
        Message ? Message->DisplayMsg( MSG_BAD_IOCTL ) : 1;
        return FALSE;
    }

    _actual.Sectors = Sectors.GetLargeInteger();


    // This drive has only one supported drive type
    //
    _num_supported = 1;

    if (!(_supported_list = NEW DRTYPE[1])) {
        Destroy();
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    _supported_list[0] = _actual;

    // If this was a transient open, clean it up.
    //
    if (!IsTransient) {

        IFS_SYSTEM::FileSetAttributes( _handle, _old_attributes, &ExtraUlong );
        NtClose(_handle);
        _alternate_handle ? NtClose(_alternate_handle) : 1;
        _handle = 0;
        _alternate_handle = 0;
    }


    return TRUE;
}

IFSUTIL_EXPORT
ULONG
DP_DRIVE::QuerySectorSize(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bytes per sector.

Arguments:

    None.

Return Value:

    The number of bytes per sector.

--*/
{
    return _actual.SectorSize;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
ULONG
DP_DRIVE::QueryPhysicalSectorSize(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bytes per sector.

Arguments:

    None.

Return Value:

    The number of bytes per physical sector.

--*/
{
    return _actual.PhysicalSectorSize;
}
#endif


IFSUTIL_EXPORT
BIG_INT
DP_DRIVE::QuerySectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number sectors on the disk.  This does not
    include the hidden sectors.

Arguments:

    None.

Return Value:

    The number of sectors on the disk.

--*/
{
    return _actual.Sectors;
}


IFSUTIL_EXPORT
UCHAR
DP_DRIVE::QueryMediaByte(
        ) CONST
/*++

Routine Description:

        This routine computes the media byte used by the FAT and HPFS file
        systems to represent the current media type.

Arguments:

        None.

Return Value:

        The media byte for the drive.

--*/
{
    switch (_actual.MediaType) {
        case F5_1Pt2_512:   // 5.25", 1.2MB,  512 bytes/sector
            return 0xF9;

        case F3_1Pt44_512:  // 3.5",  1.44MB, 512 bytes/sector
        case F3_2Pt88_512:  // 3.5",  2.88MB, 512 bytes/sector
        case F3_120M_512:   // 3.5",  120MB,  512 bytes/sector
        case F3_200Mb_512:  // 3.5",  200MB,  512 bytes/sector
        case F3_240M_512:   // 3.5",  240MB,  512 bytes/sector
            return 0xF0;

        case F3_20Pt8_512:  // 3.5",  20.8MB, 512 bytes/sector
            return 0xF9;

        case F3_720_512:    // 3.5",  720KB,  512 bytes/sector
            return 0xF9;

        case F5_360_512:    // 5.25", 360KB,  512 bytes/sector
            return 0xFD;

        case F5_320_512:    // 5.25", 320KB,  512 bytes/sector
            return 0xFF;

        case F5_180_512:    // 5.25", 180KB,  512 bytes/sector
            return 0xFC;

        case F5_160_512:    // 5.25", 160KB,  512 bytes/sector
            return 0xFE;

        case RemovableMedia:// Removable media other than floppy
            return 0xF8;    // There is no better choice than this.

        case FixedMedia:    // Fixed hard disk media
#if defined(FE_SB) && defined(_X86_)
            // FMR Jul.13.1994 SFT KMR
            // Add the set up process for the fixed_hard_disk_mediaID for FMR
            // FMR's media id is different. Case under 64MB or not.

            if(IsFMR_N()) {
                if(_actual.SectorSize * _actual.Sectors <= 63*1024*1024) {
                    return 0xF9;
                } else {
                    return 0xFA;
                }
            } else
#endif
            return 0xF8;

#if defined(FE_SB)
        case F3_128Mb_512:  // 3.5"MO, 128MB, 512 bytes/sector
        case F3_230Mb_512:  // 3.3"MO, 230MB, 512 bytes/sector
            return 0xF0;

#if defined(_X86_)
        // NEC Oct.15.1994
        // FMR Jul.14.1994 SFT KMR

        // For 8"1S , 256KB , 128 bytes/sector
        // If the media_type is 2HD, return the mediaID:FE

        case F8_256_128:    // 8"1S , 256KB , 128 bytes/sector
        case F5_1Pt23_1024: // 5.25", 1.23MB,  1024 bytes/sector
        case F3_1Pt23_1024: // 3.5",  1.23MB,  1024 bytes/sector
            return 0xFE;

        // If the media_type is 2HC, return the mediaID:F9
        // If the media_type is 2DD(720KB), return the mediaID:F9

        case F5_720_512:    // 5.25",  720KB,  512 bytes/sector
        case F3_1Pt2_512:   // 3.5",  1.2MB,    512 bytes/sector
            return 0xF9;

        // If the media_type is 2DD(640KB), return the mediaID:FB

        case F5_640_512:    // 5",    640KB,  512 bytes/sector
        case F3_640_512:    // 3.5",  640KB,  512 bytes/sector
            return 0xFB;
#endif // _X86_
#endif // FE_SB

        case F5_320_1024:
        case Unknown:
            break;

    }

    return 0;
}


VOID
DP_DRIVE::Destroy(
        )
/*++

Routine Description:

    This routine returns a DP_DRIVE to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG ExtraUlong;

    memset(&_actual, 0, sizeof(DRTYPE));
    DELETE_ARRAY(_supported_list);
    _num_supported = 0;
    _alignment_mask = 0;
    _super_floppy = FALSE;
    _is_writeable = FALSE;
    _is_primary_partition = FALSE;
    _is_system_partition = FALSE;
#if defined(FE_SB) && defined(_X86_)
    _format_type = NONE;
#endif
    _sony_ms = FALSE;
    _sony_ms_fmt_cmd = FALSE;
    _sony_ms_progress_indicator = FALSE;
    _ntfs_not_supported = FALSE;

    if (_hosted_drive) {

        IFS_SYSTEM::FileSetAttributes( _handle, _old_attributes, &ExtraUlong );
    }

    if (_alternate_handle) {

        NtClose(_alternate_handle);
        _alternate_handle = 0;
    }

    if (_handle) {

        NtClose(_handle);
        _handle = 0;
    }

    _hosted_drive = FALSE;
    memset(&_partition_info, 0, sizeof(_partition_info));
}


VOID
DP_DRIVE::CloseDriveHandle(
    )
{
    if (_handle) {
        NtClose(_handle);
        _handle = 0;
    }
}


BOOLEAN
DP_DRIVE::IsSupported(
    IN  MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine computes whether or not the supplied media type is supported
    by the drive.

Arguments:

    MediaType   - Supplies the media type.

Return Value:

    FALSE   - The media type is not supported by the drive.
    TRUE    - The media type is supported by the drive.

--*/
{
    INT i;

    for (i = 0; i < _num_supported; i++) {
        if (MediaType == _supported_list[i].MediaType) {
            return TRUE;
        }
    }

    return FALSE;
}


IFSUTIL_EXPORT
MEDIA_TYPE
DP_DRIVE::QueryRecommendedMediaType(
    ) CONST
/*++

Routine Description:

    This routine computes the recommended media type for
    drive.  This media type is independant of any existing
    media type for the drive.  It is solely based on the
    list of recommended media types for the drive.

Arguments:

    None.

Return Value:

    The recommended media type for the drive.

--*/
{
    INT         i;
    MEDIA_TYPE  media_type;
    SECTORCOUNT sectors;

    media_type = Unknown;
    sectors = 0;
    for (i = 0; i < _num_supported; i++) {

        // Special case 1.44.  If a drive supports it then
        // that should be the recommended media type.

        if (_supported_list[i].MediaType == F3_1Pt44_512) {
            media_type = _supported_list[i].MediaType;
            break;
        }

        if (_supported_list[i].Sectors > sectors) {
            media_type = _supported_list[i].MediaType;
        }
    }

    return media_type;
}

#if defined ( DBLSPACE_ENABLED )
BOOLEAN
DP_DRIVE::QueryMountedFileSystemName(
    OUT PWSTRING FileSystemName,
    OUT PBOOLEAN IsCompressed
    )
/*++

Routine Description:

    This method returns the name of the file system
    which has mounted this volume.

Arguments:

    FileSystemName  - Receives the name of the file system
                      which has mounted this volume.
    IsCompressed    - Receives TRUE if the volume is compressed,
                      FALSE if it's not compressed or if the
                      method fails.

Return Value:

    TRUE upon successful completion.

--*/
{
    CONST                           buffer_length = 64;
    BYTE                            buffer[buffer_length];
    PFILE_FS_ATTRIBUTE_INFORMATION  fs_info;
    IO_STATUS_BLOCK                 status_block;
    NTSTATUS                        status;

    DebugPtrAssert( FileSystemName );
    DebugPtrAssert( IsCompressed );

    *IsCompressed = FALSE;

    fs_info = (PFILE_FS_ATTRIBUTE_INFORMATION) buffer;

    status = NtQueryVolumeInformationFile( (_alternate_handle != 0) ?
                                                _alternate_handle : _handle,
                                           &status_block,
                                           fs_info,
                                           buffer_length,
                                           FileFsAttributeInformation );

    if( !NT_SUCCESS( status ) || fs_info->FileSystemNameLength == 0 ) {

        return FALSE;
    }

    *IsCompressed =
        (fs_info->FileSystemAttributes & FILE_VOLUME_IS_COMPRESSED) ?
        TRUE : FALSE;

    return( FileSystemName->Initialize( fs_info->FileSystemName,
                                        fs_info->FileSystemNameLength ) );
}

BOOLEAN
DP_DRIVE::MountCvf(
    IN  PCWSTRING   CvfName,
    IN  PMESSAGE    Message
    )
/*++

Routine Description:

    This method mounts a file on the drive as a Double Space volume.

Arguments:

    CvfName --  Supplies the name of the Compressed Volume File.
    Message --  Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion

--*/
{
    CONST                   MountBufferSize = 64;
    IO_STATUS_BLOCK         status_block;
    BYTE                    MountBuffer[MountBufferSize];
    PFILE_MOUNT_DBLS_BUFFER MountInfo;

    MountInfo = (PFILE_MOUNT_DBLS_BUFFER)MountBuffer;

    if( _hosted_drive ||
        !CvfName->QueryWSTR( 0,
                             TO_END,
                             MountInfo->CvfName,
                             (MountBufferSize - sizeof(ULONG))/sizeof(WCHAR),
                             TRUE ) ) {

        Message->DisplayMsg( MSG_DBLSPACE_CANT_MOUNT, "%W", CvfName );
        return FALSE;
    }

    MountInfo->CvfNameLength = CvfName->QueryChCount() * sizeof(WCHAR);

    _last_status = NtFsControlFile( _handle,
                                    0, NULL, NULL,
                                    &status_block,
                                    FSCTL_MOUNT_DBLS_VOLUME,
                                    MountBuffer,
                                    sizeof( MountBuffer ),
                                    NULL, 0 );

    if( !NT_SUCCESS( _last_status ) ) {

        Message->DisplayMsg( MSG_DBLSPACE_CANT_MOUNT, "%W", CvfName );
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
DP_DRIVE::SetCvfSize(
    IN  ULONG   Size
    )
/*++

Routine Description:

    This routine sets the size of the cvf.  Used to grow or
    shrink the cvf while converted filesystems from or to
    dblspace.  The caller is responsible for placing the
    proper signature at the end of the last sector in the cvf.

Arguments:

    Size - desired size, in bytes, of the entire cvf.

Return Value:

    TRUE  -   Success.
    FALSE -   Failure.

--*/
{
    IO_STATUS_BLOCK status_block;
    FILE_ALLOCATION_INFORMATION allocation;

    allocation.AllocationSize.HighPart = 0;
    allocation.AllocationSize.LowPart = Size;

    _last_status = NtSetInformationFile(_handle,
                                        &status_block,
                                        &allocation,
                                        sizeof(allocation),
                                        FileAllocationInformation
                                        );
    if (!NT_SUCCESS(_last_status)) {
        return FALSE;
    }

    DebugAssert(Size % _actual.SectorSize == 0);

    _actual.Sectors = Size / _actual.SectorSize;

    return TRUE;
}
#endif  // DBLSPACE_ENABLED

BOOLEAN
DP_DRIVE::SetMediaType(
    IN  MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine alters the media type of the drive.  If 'MediaType' is
    'Unknown' and the current media type for the drive is also 'Unknown'
    then this routine selects the highest density supported by the
    driver.  If the current media type is known then this function
    will have no effect if 'MediaType' is 'Unknown'.

Arguments:

    MediaType   - Supplies the new media type for the drive.

Return Value:

    FALSE   - The proposed media type is not supported by the drive.
    TRUE    - Success.

--*/
{
    INT i;

    if (MediaType == Unknown) {
        if (_actual.MediaType != Unknown) {
            return TRUE;
        } else if (!_num_supported) {
            return FALSE;
        }

        for (i = 0; i < _num_supported; i++) {
            if (_supported_list[i].Sectors > QuerySectors()) {
                _actual = _supported_list[i];
            }
        }

        return TRUE;
    }

    for (i = 0; i < _num_supported; i++) {
        if (_supported_list[i].MediaType == MediaType) {
            _actual = _supported_list[i];
            return TRUE;
        }
    }

    return FALSE;
}


VOID
DP_DRIVE::DiskGeometryToDriveType(
    IN  PCDISK_GEOMETRY DiskGeometry,
    OUT PDRTYPE         DriveType
    )
/*++

Routine Description:

    This routine computes the drive type given the disk geometry.

Arguments:

    DiskGeometry    - Supplies the disk geometry for the drive.
    DriveType       - Returns the drive type for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DriveType->MediaType = DiskGeometry->MediaType;
    DriveType->SectorSize = DiskGeometry->BytesPerSector;
    DriveType->Sectors = DiskGeometry->Cylinders*
                         DiskGeometry->TracksPerCylinder*
                         DiskGeometry->SectorsPerTrack;
    DriveType->HiddenSectors = 0;
    DriveType->SectorsPerTrack = DiskGeometry->SectorsPerTrack;
    DriveType->Heads = DiskGeometry->TracksPerCylinder;
}


VOID
DP_DRIVE::DiskGeometryToDriveType(
    IN  PCDISK_GEOMETRY DiskGeometry,
    IN  BIG_INT         NumSectors,
    IN  BIG_INT         NumHiddenSectors,
    OUT PDRTYPE         DriveType
    )
/*++

Routine Description:

    This routine computes the drive type given the disk geometry.

Arguments:

    DiskGeometry        - Supplies the disk geometry for the drive.
    NumSectors          - Supplies the total number of non-hidden sectors on
                        the disk.
    NumHiddenSectors    - Supplies the number of hidden sectors on the disk.
    DriveType           - Returns the drive type for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DriveType->MediaType = DiskGeometry->MediaType;
    DriveType->SectorSize = DiskGeometry->BytesPerSector;
    DriveType->Sectors = NumSectors;
    DriveType->HiddenSectors = NumHiddenSectors;
    DriveType->SectorsPerTrack = DiskGeometry->SectorsPerTrack;
    DriveType->Heads = DiskGeometry->TracksPerCylinder;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::IsATformat(
    ) CONST
/*++

Routine Description:

    This routine judged whether it is AT format.

Arguments:

    None.

Return Value:

    FALSE   - The disk is not AT format.
    TRUE    - The disk is AT format.

History:

    PC98 Oct.21.1995

--*/
{
    return _next_format_type == FORMAT_MEDIA_AT;
}
#endif


DEFINE_CONSTRUCTOR( IO_DP_DRIVE, DP_DRIVE );

VOID
IO_DP_DRIVE::Construct (
        )

/*++

Routine Description:

    Constructor for IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _is_locked = FALSE;
    _is_exclusive_write = FALSE;
    _cache = NULL;
    _ValidBlockLengthForVerify = 0;
    _message = NULL;
}


VOID
IO_DP_DRIVE::Destroy(
    )
/*++

Routine Description:

    This routine returns an IO_DP_DRIVE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_cache);

    if (_is_exclusive_write) {
        Dismount();
        _is_exclusive_write = FALSE;
    }

    if (_is_locked) {
        Unlock();
        _is_locked = FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = NULL;
}


IO_DP_DRIVE::~IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes an IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the drive path.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!DP_DRIVE::Initialize(NtDriveName, Message, TRUE, ExclusiveWrite, FormatType)) {
        Destroy();
        return FALSE;
    }

    _is_exclusive_write = ExclusiveWrite;

    if (!(_cache = NEW DRIVE_CACHE) ||
        !_cache->Initialize(this)) {

        Destroy();
        return FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = Message;

    return TRUE;
}

BOOLEAN
IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes an IO_DP_DRIVE object for a hosted
    drive, i.e. one which is implemented as a file on another
    volume.

Arguments:

    NtDriveName     - Supplies the drive path.
    HostFileName    - Supplies the fully qualified name of the host file.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if( !DP_DRIVE::Initialize(NtDriveName,
                              HostFileName,
                              Message,
                              TRUE,
                              ExclusiveWrite)) {
        Destroy();
        return FALSE;
    }

    _is_exclusive_write = ExclusiveWrite;

    if (!(_cache = NEW DRIVE_CACHE) ||
        !_cache->Initialize(this)) {

        Destroy();
        return FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = Message;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector  - Supplies the first sector to be read.
    NumberOfSectors - Supplies the number of sectors to be read.
    Buffer          - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Read(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Write(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Write(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
VOID
IO_DP_DRIVE::SetCache(
    IN OUT  PDRIVE_CACHE    Cache
    )
/*++

Routine Description:

    This routine relaces the current cache with the one supplied.
    The object then takes ownership of this cache and it will be
    deleted by the object.

Arguments:

    Cache   - Supplies the new cache to install.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(Cache);
    DELETE(_cache);
    _cache = Cache;
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::FlushCache(
    )
/*++

Routine Description:

    This routine flushes the cache and report returns whether any
    IO error occurred during the life of the cache.

Arguments:

    None.

Return Value:

    FALSE   - Some IO errors have occured during the life of the cache.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Flush();
}


BOOLEAN
IO_DP_DRIVE::HardRead(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           sector_size;
    ULONG           buffer_size;
    IO_STATUS_BLOCK status_block;
    BIG_INT         secptr;
    BIG_INT         endofrange;
    SECTORCOUNT     increment;
    PCHAR           bufptr;
    BIG_INT         byte_offset;
    BIG_INT         tmp;
    LARGE_INTEGER   l;
#if defined(IO_PERF_COUNTERS)
    LARGE_INTEGER   rt1, rt2;
#endif

#if TRAP_A_READ
    BIG_INT         end_offset;
    char            bufptr2[0x10000];
#endif

    DebugAssert(!(((ULONG_PTR) Buffer) & QueryAlignmentMask()));

    sector_size = QuerySectorSize();
    endofrange = StartingSector + NumberOfSectors;
    increment = MaxIoSize/sector_size;

#if defined(IO_PERF_COUNTERS)
    _rcount.QuadPart++;
#endif
    bufptr = (PCHAR) Buffer;
    for (secptr = StartingSector; secptr < endofrange; secptr += increment) {

        byte_offset = secptr*sector_size;

        if (secptr + increment > endofrange) {
            tmp = endofrange - secptr;
            DebugAssert(tmp.GetHighPart() == 0);
            buffer_size = sector_size*tmp.GetLowPart();
#if defined(IO_PERF_COUNTERS)
            _rsize.QuadPart = _rsize.QuadPart + tmp.GetQuadPart();
#endif
        } else {
            buffer_size = sector_size*increment;
#if defined(IO_PERF_COUNTERS)
            _rsize.QuadPart = _rsize.QuadPart + increment;
#endif
        }

        l = byte_offset.GetLargeInteger();

#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&rt1);
#endif
        _last_status = NtReadFile(_handle, 0, NULL, NULL, &status_block,
                                  bufptr, buffer_size, &l, NULL);
#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&rt2);
        _rrtotal.QuadPart = _rrtotal.QuadPart + (rt2.QuadPart - rt1.QuadPart);
#endif

#if TRAP_A_READ
        end_offset = byte_offset + buffer_size - 1;
        if (((0x5eUL*0x200UL) <= end_offset && end_offset <= (0x5fUL*0x200UL)) ||
                ((0x5eUL*0x200UL) <= byte_offset && byte_offset <= (0x5fUL*0x200UL)) ||
                (byte_offset <= (0x5eUL*0x200UL) && (0x5fUL*0x200UL) <= end_offset)) {
            _last_status = NtReadFile(_handle, 0, NULL, NULL, &status_block,
                                      bufptr2, buffer_size, &l, NULL);
            __asm int 3;
        }
        if (((0x18fffUL*0x200UL) <= end_offset && end_offset <= (0x19000UL*0x200UL)) ||
                ((0x18fffUL*0x200UL) <= byte_offset && byte_offset <= (0x19000UL*0x200UL)) ||
                (byte_offset <= (0x18fffUL*0x200UL) && (0x19000UL*0x200UL) <= end_offset)) {
            _last_status = NtReadFile(_handle, 0, NULL, NULL, &status_block,
                                      bufptr2, buffer_size, &l, NULL);
            __asm int 3;
        }
#endif

        if (_last_status == STATUS_NO_MEMORY) {
            increment /= 2;
            secptr -= increment;
            continue;
        }

        if (NT_ERROR(_last_status) || status_block.Information != buffer_size) {

            if (NT_ERROR(_last_status)) {
                DebugPrintTrace(("HardRead: NtReadFile failure: %x, %I64x, %x\n",
                                 _last_status, l, buffer_size));
            } else {
                DebugPrintTrace(("HardRead: NtReadFile failure: %I64x, %x, %x\n",
                                 l, status_block.Information, buffer_size));
            }

            if (_message) {
                if (NT_ERROR(_last_status)) {
                    _message->LogMsg(MSG_CHKLOG_READ_FAILURE,
                                     "%x%I64x%x", _last_status, l, buffer_size);
                } else {
                    _message->LogMsg(MSG_CHKLOG_READ_INCORRECT,
                                     "%I64d%x%x", l, status_block.Information, buffer_size);
                }
            }

            return FALSE;
        }

        bufptr += buffer_size;
    }

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::HardWrite(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

    MJB: After writing each chunk, we read it back to make sure the write
    really succeeded.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           sector_size;
    ULONG           buffer_size;
    IO_STATUS_BLOCK status_block;
    BIG_INT         secptr;
    BIG_INT         endofrange;
    SECTORCOUNT     increment;
    PCHAR           bufptr;
    PCHAR           scratch_ptr;
    BIG_INT         byte_offset;
    BIG_INT         tmp;
    LARGE_INTEGER   l;
    CHAR            ScratchIoBuf[MaxIoSize + 511];

#if defined(IO_PERF_COUNTERS)
    LARGE_INTEGER   wt1, wt2, rt1, rt2, ct1, ct2;
#endif

#if TRAP_A_WRITE
    BIG_INT     end_offset;
#endif

    DebugAssert(!(((ULONG_PTR) Buffer) & QueryAlignmentMask()));
    DebugAssert(QueryAlignmentMask() < 0x200);

    if (! ((ULONG_PTR)ScratchIoBuf & QueryAlignmentMask())) {
        scratch_ptr = ScratchIoBuf;
    } else {
        scratch_ptr = (PCHAR)((ULONG_PTR) ((PCHAR)ScratchIoBuf +
            QueryAlignmentMask()) & (~(ULONG_PTR)QueryAlignmentMask()));
    }
    DebugAssert(!(((ULONG_PTR) scratch_ptr) & QueryAlignmentMask()));

    sector_size = QuerySectorSize();
    endofrange = StartingSector + NumberOfSectors;
    increment = MaxIoSize/sector_size;

#if defined(IO_PERF_COUNTERS)
    _wcount.QuadPart++;
#endif
    bufptr = (PCHAR) Buffer;
    for (secptr = StartingSector; secptr < endofrange; secptr += increment) {

        byte_offset = secptr*sector_size;

        if (secptr + increment > endofrange) {
            tmp = endofrange - secptr;
            DebugAssert(tmp.GetHighPart() == 0);
            buffer_size = sector_size*tmp.GetLowPart();
#if defined(IO_PERF_COUNTERS)
            _wsize.QuadPart = _wsize.QuadPart + tmp.GetQuadPart();
#endif
        } else {
            buffer_size = sector_size*increment;
#if defined(IO_PERF_COUNTERS)
            _wsize.QuadPart = _wsize.QuadPart + increment;
#endif
        }

        l = byte_offset.GetLargeInteger();

#if TRAP_A_WRITE
        end_offset = byte_offset + buffer_size - 1;
        if (((0x5eUL*0x200UL) <= end_offset && end_offset <= (0x5fUL*0x200UL)) ||
                ((0x5eUL*0x200UL) <= byte_offset && byte_offset <= (0x5fUL*0x200UL)) ||
                (byte_offset <= (0x5eUL*0x200UL) && (0x5fUL*0x200UL) <= end_offset)) {
            __asm int 3;
        }
        if (((0x18fffUL*0x200UL) <= end_offset && end_offset <= (0x19000UL*0x200UL)) ||
                ((0x18fffUL*0x200UL) <= byte_offset && byte_offset <= (0x19000UL*0x200UL)) ||
                (byte_offset <= (0x18fffUL*0x200UL) && (0x19000UL*0x200UL) <= end_offset)) {
            __asm int 3;
        }
#endif

#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&wt1);
#endif
        _last_status = NtWriteFile(_handle, 0, NULL, NULL, &status_block,
                                   bufptr, buffer_size, &l, NULL);
#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&wt2);
        _wtotal.QuadPart = _wtotal.QuadPart + (wt2.QuadPart - wt1.QuadPart);
#endif

        if (_last_status == STATUS_NO_MEMORY) {
            increment /= 2;
            secptr -= increment;
            continue;
        }

        if (NT_ERROR(_last_status) || status_block.Information != buffer_size) {

            if (NT_ERROR(_last_status)) {
                DebugPrintTrace(("HardWrite: NtWriteFile failure: %x, %I64x, %x\n",
                                 _last_status, l, buffer_size));
            } else {
                DebugPrintTrace(("HardWrite: NtWriteFile failure: %I64x, %x, %x\n",
                                 l, status_block.Information, buffer_size));
            }

            if (_message) {
                if (NT_ERROR(_last_status)) {
                    _message->LogMsg(MSG_CHKLOG_WRITE_FAILURE,
                                     "%x%I64x%x", _last_status, l, buffer_size);
                } else {
                    _message->LogMsg(MSG_CHKLOG_WRITE_INCORRECT,
                                     "%I64d%x%x", l, status_block.Information, buffer_size);
                }
            }

            return FALSE;
        }

        DebugAssert(buffer_size <= MaxIoSize);

#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&rt1);
#endif
        _last_status = NtReadFile(_handle, 0, NULL, NULL, &status_block,
                                  scratch_ptr, buffer_size, &l, NULL);
#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&rt2);
        _rtotal.QuadPart = _rtotal.QuadPart + (rt2.QuadPart - rt1.QuadPart);
#endif

        if (NT_ERROR(_last_status) || status_block.Information != buffer_size) {

            if (NT_ERROR(_last_status)) {
                DebugPrintTrace(("HardWrite: NtReadFile failure: %x, %I64x, %x\n",
                                 _last_status, l, buffer_size));
            } else {
                DebugPrintTrace(("HardWrite: NtReadFile failure: %I64x, %x, %x\n",
                                 l, status_block.Information, buffer_size));
            }

            if (_message) {
                if (NT_ERROR(_last_status)) {
                    _message->LogMsg(MSG_CHKLOG_WRITE_FAILURE,
                                  "%x%I64x%x", _last_status, l, buffer_size);
                } else {
                    _message->LogMsg(MSG_CHKLOG_WRITE_INCORRECT,
                                 "%I64x%x%x", l, status_block.Information, buffer_size);
                }
            }

            return FALSE;
        }

#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&ct1);
#endif
        if (0 != memcmp(scratch_ptr, bufptr, buffer_size)) {

            DebugPrint("What's read back does not match what's written out\n");
            if (_message) {
                _message->LogMsg(MSG_CHKLOG_READ_BACK_FAILURE,
                                 "%I64x%x", l, buffer_size);
            }

            return FALSE;
        }
#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&ct2);
        _ctotal.QuadPart = _ctotal.QuadPart + (ct2.QuadPart - ct1.QuadPart);
#endif

        bufptr += buffer_size;
    }

    return TRUE;
}


BOOLEAN
DP_DRIVE::CheckForPrimaryPartition(
    )
/*++

Routine Description:

    This routine checks to see if the volume is on a primary partition.
    It sets the result returned by IsPrimaryPartition routine.

Arguments:

    N/A

Return Value:

    TRUE if successfully determined if the volume is on a primary
    partition.
--*/
{
#if defined(RUN_ON_W2K)
    CONST INT EntriesPerBootRecord = 4;
    CONST INT MaxLogicalVolumes = 23;
    CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                        EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                            sizeof(PARTITION_INFORMATION_EX);

    IO_STATUS_BLOCK             status_block;
    STORAGE_DEVICE_NUMBER       device_info;
    UCHAR                       buf[Length];
    DRIVE_LAYOUT_INFORMATION *layout_info = (DRIVE_LAYOUT_INFORMATION *)buf;

    ULONG                       i, partition_count;

    _is_primary_partition = FALSE;

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                         NULL, 0, &device_info,
                                         sizeof(STORAGE_DEVICE_NUMBER));

    if (NT_SUCCESS(_last_status) && device_info.DeviceType == FILE_DEVICE_DISK &&
        (device_info.PartitionNumber != -1 && device_info.PartitionNumber != 0)) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT,
                                             NULL, 0, layout_info,
                                             Length);

        if (!NT_SUCCESS(_last_status))
            return FALSE;

        partition_count = min(4, layout_info->PartitionCount);

        for (i=0; i<partition_count; i++) {
            if (layout_info->PartitionEntry[i].PartitionNumber ==
                device_info.PartitionNumber) {
                _is_primary_partition = TRUE;
                break;
            }
        }
    }

    return TRUE;
#else // defined(RUN_ON_W2K)
    CONST INT EntriesPerBootRecord = 4;
    CONST INT MaxLogicalVolumes = 23;
    CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                        EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                            sizeof(PARTITION_INFORMATION_EX);

    IO_STATUS_BLOCK             status_block;
    STORAGE_DEVICE_NUMBER       device_info;
    UCHAR                       buf[Length];
    DRIVE_LAYOUT_INFORMATION_EX *layout_info = (DRIVE_LAYOUT_INFORMATION_EX *)buf;

    ULONG                       i, partition_count;

    _is_primary_partition = FALSE;

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                         NULL, 0, &device_info,
                                         sizeof(STORAGE_DEVICE_NUMBER));

    if (NT_SUCCESS(_last_status) && device_info.DeviceType == FILE_DEVICE_DISK &&
        (device_info.PartitionNumber != -1 && device_info.PartitionNumber != 0)) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                             NULL, 0, layout_info,
                                             Length);

        if (!NT_SUCCESS(_last_status))
            return FALSE;

        if (layout_info->PartitionStyle == PARTITION_STYLE_MBR) {
            partition_count = min(4, layout_info->PartitionCount);

            for (i=0; i<partition_count; i++) {
                if (layout_info->PartitionEntry[i].PartitionNumber ==
                    device_info.PartitionNumber) {
                    _is_primary_partition = TRUE;
                    break;
                }
            }
        }
    }

    return TRUE;
#endif // defined(RUN_ON_W2K)
}

BOOLEAN
DP_DRIVE::CheckForSystemPartition(
    )
/*++

Routine Description:

    This routine checks to see if the volume is a system partition.
    It sets the result returned by IsSystemPartition routine.

Arguments:

    N/A

Return Value:

    TRUE if successfully determined if the volume is a system partition.
--*/
{
    BYTE                buffer[MAX_PATH*sizeof(WCHAR)+sizeof(MOUNTDEV_NAME)];
    PMOUNTDEV_NAME      mountdev_name = (PMOUNTDEV_NAME)buffer;
    WCHAR               system_partition[MAX_PATH];
    IO_STATUS_BLOCK     status_block;

    _is_system_partition = FALSE;

    _last_status = QuerySystemPartitionValue(system_partition, sizeof(system_partition));

    if (!NT_SUCCESS(_last_status)) {
        DebugPrintTrace(("IFSUTIL: Unable to query system partition in registry (%x)\n", _last_status));
        return FALSE;
    }
    // DebugPrintTrace(("CheckForSystemPartition: SP: %ls\n", system_partition));

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                         NULL, 0, mountdev_name,
                                         sizeof(buffer));

    if (!NT_SUCCESS(_last_status)) {
        DebugPrintTrace(("IFSUTIL: Failed IOCTL_MOUNTDEV_QUERY_DEVICE_NAME (%x)\n", _last_status));
        return FALSE;
    }

    if (mountdev_name->NameLength < MAX_PATH) {
        mountdev_name->Name[mountdev_name->NameLength/sizeof(WCHAR)] = 0;
    } else {
        DebugPrintTrace(("IFSUTIL: CheckForSystemPartition: Device Name too long (%d, %d)\n",
                         mountdev_name->NameLength, status_block.Information));
        _last_status = STATUS_BUFFER_TOO_SMALL;
        return FALSE;
    }

    // DebugPrintTrace(("CheckForSystemPartition: DN: %ls\n", mountdev_name->Name));

    if (WSTRING::Stricmp(system_partition, mountdev_name->Name) == 0) {
        // DebugPrintTrace(("CheckForSystemPartition: This is a system partition\n"));
        _is_system_partition = TRUE;
    }

    return TRUE;
}

BOOLEAN
DP_DRIVE::QueryBusType(
    OUT PSTORAGE_BUS_TYPE   BusType
    )
/*++

Routine Description:

    This routine returns the bus type of the device.

Arguments:

    N/A

Return Value:

    TRUE if successful retrieval of the bus type.

--*/
{
    STORAGE_PROPERTY_QUERY      spq;
    IO_STATUS_BLOCK             status_block;
    BYTE                        buffer[sizeof(STORAGE_DEVICE_DESCRIPTOR)+0x100];
    PSTORAGE_DEVICE_DESCRIPTOR  sdd = (PSTORAGE_DEVICE_DESCRIPTOR)buffer;

    spq.PropertyId = StorageDeviceProperty;
    spq.QueryType = PropertyStandardQuery;

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block, IOCTL_STORAGE_QUERY_PROPERTY,
                                         &spq,
                                         sizeof(spq),
                                         sdd,
                                         sizeof(buffer));

    if (NT_SUCCESS(_last_status)) {
        *BusType = sdd->BusType;
        return TRUE;
    } else {
        DebugPrintTrace(("IFSUTIL: Failed IOCTL_STORAGE_QUERY_PROPERTY (%x)\n", _last_status));
        return FALSE;
    }
}

BOOLEAN
DP_DRIVE::CheckHotPlugInfo(
    )
/*++

Routine Description:

    This routine determines if ntfs file system should be used on this device.

Arguments:

    N/A

Return Value:

    TRUE if successful.

--*/
{
    BOOLEAN     NoNtfsSupport;

    _last_status = DP_DRIVE::QueryNtfsSupportInfo(_handle, &NoNtfsSupport);

    if (NT_SUCCESS(_last_status)) {
        _ntfs_not_supported = NoNtfsSupport;
        return TRUE;
    } else {
        _ntfs_not_supported = FALSE;
        return FALSE;
    }
}

NTSTATUS
DP_DRIVE::QueryNtfsSupportInfo(
    IN     HANDLE                   DriveHandle,
       OUT PBOOLEAN                 NoNtfsSupport
    )
/*++

Routine Description:

    This routine determines if ntfs file system should be used on this device.

Arguments:

    DriveHandle     - Supplies a handle to the volume.
    NoNtfsSupport   - Retrieves a boolean which tells if ntfs should be used on the device.

Return Value:

    NTSTATUS of the query

--*/
{
    IO_STATUS_BLOCK         status_block;
    NTSTATUS                status;
    STORAGE_HOTPLUG_INFO    hpinfo;

    status = NtDeviceIoControlFile(DriveHandle, 0, NULL, NULL,
                                   &status_block, IOCTL_STORAGE_GET_HOTPLUG_INFO,
                                   NULL,
                                   0,
                                   &hpinfo,
                                   sizeof(STORAGE_HOTPLUG_INFO));

    if (NT_SUCCESS(status)) {
        if (NoNtfsSupport != NULL) {
            *NoNtfsSupport = (hpinfo.MediaHotplug || hpinfo.DeviceHotplug);
        }
    } else {
        DebugPrintTrace(("IFSUTIL: Failed IOCTL_STORAGE_GET_HOTPLUG_INFO (%x)\n", status));
    }

    return status;
}

IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Verify(
    IN  BIG_INT StartingSector,
    IN  BIG_INT NumberOfSectors
    )
/*++

Routine Description:

    This routine verifies a run of sectors on the disk.

Arguments:

    StartingSector  - Supplies the first sector of the run to verify.
    NumberOfSectors - Supplies the number of sectors in the run to verify.

Return Value:

    FALSE   - Some of the sectors in the run are bad.
    TRUE    - All of the sectors in the run are good.

--*/
{
    VERIFY_INFORMATION  verify_info;
    IO_STATUS_BLOCK     status_block;
    BIG_INT             starting_offset;
    BIG_INT             verify_size;

    DebugAssert(QuerySectorSize());

    _last_status = STATUS_SUCCESS;

    if (IsFloppy() || !_is_exclusive_write) {
        return VerifyWithRead(StartingSector, NumberOfSectors);
    }

    starting_offset = StartingSector*QuerySectorSize();
    verify_size = NumberOfSectors*QuerySectorSize();

    verify_info.StartingOffset = starting_offset.GetLargeInteger();

    // Note: norbertk Verify IOCTL is destined to go to a BIG_INT length.
    DebugAssert(verify_size.GetHighPart() == 0);
    verify_info.Length = verify_size.GetLowPart();

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block, IOCTL_DISK_VERIFY,
                                         &verify_info,
                                         sizeof(VERIFY_INFORMATION),
                                         NULL, 0);

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Verify(
    IN      BIG_INT         StartingSector,
    IN      BIG_INT         NumberOfSectors,
    IN OUT  PNUMBER_SET     BadSectors
    )
/*++

Routine Description:

    This routine computes which sectors in the given range are bad
    and adds these bad sectors to the bad sectors list.

Arguments:

    StartingSector  - Supplies the starting sector.
    NumberOfSectors - Supplies the number of sectors.
    BadSectors      - Supplies the bad sectors list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       MaxSectorsInVerify = 512;

    ULONG       MaxDiskHits;
    BIG_INT     half;
    PBIG_INT    starts;
    PBIG_INT    run_lengths;
    ULONG       i, n;
    BIG_INT     num_sectors;

    if (NumberOfSectors == 0) {
        return TRUE;
    }

    if (NumberOfSectors.GetHighPart() != 0) {
        DebugPrint("IFSUTIL: Number of sectors to verify exceeded 32 bits\n");
        return FALSE;
    }


    //
    // Check to see if block length has been set
    //
    if (!_ValidBlockLengthForVerify) {

        num_sectors = min(NumberOfSectors, MaxSectorsInVerify);

        while (!Verify(StartingSector, num_sectors)) {
            if (QueryLastNtStatus() == STATUS_INVALID_BLOCK_LENGTH ||
                QueryLastNtStatus() == STATUS_INVALID_DEVICE_REQUEST) {
                if (num_sectors == 1) {
                    DebugPrint("IFSUTIL: Number of sectors to verify mysteriously down to 1\n");
                    return FALSE;
                }
                num_sectors = num_sectors / 2;
            } else
                break;
        }

        DebugAssert(num_sectors.GetHighPart() == 0);

        if (QueryLastNtStatus() == STATUS_SUCCESS) {

            if (!(NumberOfSectors < MaxSectorsInVerify &&
                  NumberOfSectors == num_sectors))
                MaxSectorsInVerify = _ValidBlockLengthForVerify = num_sectors.GetLowPart();


            if (num_sectors == NumberOfSectors)
                return TRUE;    // done, return
            else {
                //
                // skip over sectors that has been verified
                //
                StartingSector += num_sectors;
                NumberOfSectors -= num_sectors;
            }
        }
    } else
        MaxSectorsInVerify = _ValidBlockLengthForVerify;


    // Allow 20 retries so that a single bad sector in this region
    // will be found accurately.

    MaxDiskHits = (20 + NumberOfSectors/MaxSectorsInVerify + 1).GetLowPart();

    if (!(starts = NEW BIG_INT[MaxDiskHits]) ||
        !(run_lengths = NEW BIG_INT[MaxDiskHits])) {

        DELETE_ARRAY(starts);
        DELETE_ARRAY(run_lengths);
        return FALSE;
    }

    num_sectors = NumberOfSectors;
    for (i = 0; num_sectors > 0; i++) {
        starts[i] = StartingSector + i*MaxSectorsInVerify;
        if (MaxSectorsInVerify > num_sectors) {
            run_lengths[i] = num_sectors;
        } else {
            run_lengths[i] = MaxSectorsInVerify;
        }
        num_sectors -= run_lengths[i];
    }

    n = i;

    for (i = 0; i < n; i++) {

        if (!Verify(starts[i], run_lengths[i])) {

            if (QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE) {
                DELETE_ARRAY(starts);
                DELETE_ARRAY(run_lengths);
                return FALSE;
            }

            DebugAssert(QueryLastNtStatus() != STATUS_INVALID_BLOCK_LENGTH &&
                        QueryLastNtStatus() != STATUS_INVALID_DEVICE_REQUEST);

            if (BadSectors == NULL) {
                DELETE_ARRAY(starts);
                DELETE_ARRAY(run_lengths);
                return FALSE;
            }

            if (n + 2 > MaxDiskHits) {

                if (!BadSectors->Add(starts[i], run_lengths[i])) {
                    DELETE_ARRAY(starts);
                    DELETE_ARRAY(run_lengths);
                    return FALSE;
                }

            } else {

                if (run_lengths[i] == 1) {

                    if (!BadSectors->Add(starts[i])) {
                        DELETE_ARRAY(starts);
                        DELETE_ARRAY(run_lengths);
                        return FALSE;
                    }

                } else {

                    half = run_lengths[i]/2;

                    starts[n] = starts[i];
                    run_lengths[n] = half;
                    starts[n + 1] = starts[i] + half;
                    run_lengths[n + 1] = run_lengths[i] - half;

                    n += 2;
                }
            }
        }
    }


    DELETE_ARRAY(starts);
    DELETE_ARRAY(run_lengths);

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::VerifyWithRead(
    IN  BIG_INT StartingSector,
    IN  BIG_INT NumberOfSectors
    )
/*++

Routine Description:

    This routine verifies the usability of the given range of sectors
    using read.

Arguments:

    StartingSector      - Supplies the starting sector of the verify.
    Number OfSectors    - Supplies the number of sectors to verify.

Return Value:

    FALSE   - At least one of the sectors in the given range was unreadable.
    TRUE    - All of the sectors in the given range are readable.

--*/
{
    HMEM    hmem;
    ULONG   grab;
    BIG_INT i;

    if (!hmem.Initialize() ||
        !hmem.Acquire(MaxIoSize, QueryAlignmentMask())) {

        return FALSE;
    }

    grab = MaxIoSize/QuerySectorSize();
    for (i = 0; i < NumberOfSectors; i += grab) {

        if (NumberOfSectors - i < grab) {
            grab = (NumberOfSectors - i).GetLowPart();
        }

        if (!HardRead(StartingSector + i, grab, hmem.GetBuf())) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::Lock(
    )
/*++

Routine Description:

    This routine locks the drive.  If the drive is already locked then
    this routine will do nothing.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;

    if (_is_locked) {
        return TRUE;
    }

    if (_hosted_drive && _alternate_handle == 0) {

        // This is a hosted volume which is not mounted as
        // a drive--locking succeeds.
        //
        _is_locked = TRUE;
        _is_exclusive_write = TRUE;
        return TRUE;
    }

    _last_status = NtFsControlFile( (_alternate_handle != 0) ?
                                        _alternate_handle : _handle,
                                    0, NULL, NULL,
                                    &status_block,
                                    FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

    _is_locked = (BOOLEAN) NT_SUCCESS(_last_status);

    if (_is_locked) {
        _is_exclusive_write = TRUE;
    } else {
        DebugPrintTrace(("IFSUTIL: Unable to lock the volume (%x)\n", _last_status));
    }

    return _is_locked;
}


BOOLEAN
IO_DP_DRIVE::InvalidateVolume(
    )
/*++

Routine Description:

    This routine invalidates the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HANDLE              handle;
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   attributes;
    IO_STATUS_BLOCK     ioStatusBlock;
#if 0
    BOOLEAN             WasEnabled;
    NTSTATUS            status;
    PNTSTATUS           pstatus;

    _last_status = RtlAdjustPrivilege( SE_TCB_PRIVILEGE,
                                       TRUE,              // Enable
                                       FALSE,             // Client
                                       &WasEnabled
                                     );

    if (!NT_SUCCESS(_last_status)) {
        DebugPrintTrace(("IFSUTIL: Unable to adjust privilege (%x)\n", _last_status));
        return FALSE;
    }
#endif

    RtlInitUnicodeString(&unicodeString, L"\\Fat");

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    _last_status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                        &attributes,
                        &ioStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(_last_status)) {
        _last_status = NtFsControlFile( handle,
                                        0, NULL, NULL,
                                        &ioStatusBlock,
                                        FSCTL_INVALIDATE_VOLUMES,
                                        (_alternate_handle != 0) ? &_alternate_handle : &_handle,
                                        sizeof(HANDLE), NULL, 0);

        if (!NT_SUCCESS(_last_status)) {
            DebugPrintTrace(("IFSUTIL: Unable to invalidate volume (%x)\n", _last_status));
        }

    } else {
        DebugPrintTrace(("IFSUTIL: Unable to obtain a handle from fastfat driver (%x)\n", _last_status));
    }

#if 0
    if (WasEnabled) {

        if (NT_SUCCESS(_last_status))
            pstatus = &_last_status;
        else
            pstatus = &status;

        *pstatus = RtlAdjustPrivilege( SE_TCB_PRIVILEGE,
                                       FALSE,             // Enable
                                       FALSE,             // Client
                                       &WasEnabled
                                     );

        if (!NT_SUCCESS(*pstatus)) {
            DebugPrintTrace(("IFSUTIL: Unable to restore privilege (%x) but return successful status anyway.\n",
                             *pstatus));
        }
    }
#endif

    return (BOOLEAN)NT_SUCCESS(_last_status);
}


BOOLEAN
IO_DP_DRIVE::ForceDirty(
    )
/*++

Routine Description:

    This routine forces the volume to be dirty, so that autochk will
    run next time the system reboots.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;

    _last_status = NtFsControlFile((_alternate_handle != 0) ?
                                        _alternate_handle : _handle,
                                   0, NULL, NULL,
                                   &status_block,
                                   FSCTL_MARK_VOLUME_DIRTY,
                                   NULL, 0, NULL, 0);

    return ((BOOLEAN) NT_SUCCESS(_last_status));
}


BOOLEAN
IO_DP_DRIVE::Unlock(
    )
/*++

Routine Description:

    This routine unlocks the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;
    NTSTATUS        status;

    if (_hosted_drive && _alternate_handle == 0 ) {

        return TRUE;
    }

    status = NtFsControlFile((_alternate_handle != 0) ?
                                      _alternate_handle : _handle,
                                      0, NULL, NULL,
                                      &status_block,
                                      FSCTL_UNLOCK_VOLUME,
                                      NULL, 0, NULL, 0);

    return NT_SUCCESS(status);

}


BOOLEAN
IO_DP_DRIVE::Dismount(
    )
/*++

Routine Description:

    This routine dismounts the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;

    if( _hosted_drive && _alternate_handle == 0 ) {

        return TRUE;
    }

    if( !NT_SUCCESS(NtFsControlFile((_alternate_handle != 0) ?
                                          _alternate_handle : _handle,
                                    0, NULL, NULL,
                                    &status_block,
                                    FSCTL_DISMOUNT_VOLUME,
                                    NULL, 0, NULL, 0)) ) {

        return FALSE;
        }

        return TRUE;
}


BOOLEAN
IO_DP_DRIVE::DismountAndUnlock(
    )
/*++

Routine Description:

    This routine dismounts the drive and unlocks it.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN r = TRUE;

    if (_is_exclusive_write) {
        r = Dismount();
        _is_exclusive_write = FALSE;
    }

    if (_is_locked) {
        r = Unlock() && r;
        _is_locked = FALSE;
    }

    return r;
}


BOOLEAN
IO_DP_DRIVE::FormatVerifyFloppy(
    IN      MEDIA_TYPE  MediaType,
    IN OUT  PNUMBER_SET BadSectors,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsDmfFormat
    )
/*++

Routine Description:

    This routine low level formats an entire floppy disk to the media
    type specified.  If no MediaType is specified then a logical one will
    be selected.

Arguments:

    MediaType   - Supplies an optional media type to format to.
    BadSectors  - Returns a list of bad sectors on the disk.
    Message     - Supplies a message object to route messages to.
    IsDmfFormat - Supplies whether or not to perform a DMF type format.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK         status_block;
    CONST                   format_parameters_size = sizeof(FORMAT_EX_PARAMETERS) + 20*sizeof(USHORT);
    CHAR                    format_parameters_buffer[format_parameters_size];
    PFORMAT_EX_PARAMETERS   format_parameters;
    PBAD_TRACK_NUMBER       bad;
    ULONG                   num_bad, j;
    ULONG                   i;
    ULONG                   cyl;
    ULONG                   percent;
    ULONG                   sec_per_track;
    ULONG                   sec_per_cyl;
    HMEM                    hmem;
    MSGID                   MessageId;
    USHORT                  swap_buffer[3];

    // We don't make sure that the volume is locked here because
    // it's not strictly necessary and 'diskcopy' will format
    // floppies without locking them.

    if (!SetMediaType(MediaType) ||
        (IsDmfFormat && QueryMediaType() != F3_1Pt44_512)) {

        Message ? Message->DisplayMsg(MSG_NOT_SUPPORTED_BY_DRIVE) : 1;
        return FALSE;
    }

    format_parameters = (PFORMAT_EX_PARAMETERS) format_parameters_buffer;
    format_parameters->MediaType = QueryMediaType();
    format_parameters->StartHeadNumber = 0;
    format_parameters->EndHeadNumber = QueryHeads() - 1;

    if (IsDmfFormat) {
        sec_per_track = 21;
        format_parameters->FormatGapLength = 8;
        format_parameters->SectorsPerTrack = (USHORT) sec_per_track;
        format_parameters->SectorNumber[0] = 12;
        format_parameters->SectorNumber[1] = 2;
        format_parameters->SectorNumber[2] = 13;
        format_parameters->SectorNumber[3] = 3;
        format_parameters->SectorNumber[4] = 14;
        format_parameters->SectorNumber[5] = 4;
        format_parameters->SectorNumber[6] = 15;
        format_parameters->SectorNumber[7] = 5;
        format_parameters->SectorNumber[8] = 16;
        format_parameters->SectorNumber[9] = 6;
        format_parameters->SectorNumber[10] = 17;
        format_parameters->SectorNumber[11] = 7;
        format_parameters->SectorNumber[12] = 18;
        format_parameters->SectorNumber[13] = 8;
        format_parameters->SectorNumber[14] = 19;
        format_parameters->SectorNumber[15] = 9;
        format_parameters->SectorNumber[16] = 20;
        format_parameters->SectorNumber[17] = 10;
        format_parameters->SectorNumber[18] = 21;
        format_parameters->SectorNumber[19] = 11;
        format_parameters->SectorNumber[20] = 1;
    } else {
        sec_per_track = QuerySectorsPerTrack();
    }
    sec_per_cyl = sec_per_track*QueryHeads();

    DebugAssert(QueryCylinders().GetHighPart() == 0);
    cyl = QueryCylinders().GetLowPart();
    num_bad = QueryHeads();
    if (num_bad == 0 || cyl == 0) {
        return FALSE;
    }

        if (!(bad = NEW BAD_TRACK_NUMBER[num_bad])) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    if (!hmem.Acquire(sec_per_cyl*QuerySectorSize(), QueryAlignmentMask())) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }


    Message ? Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0) : 1;

    percent = 0;
    for (i = 0; i < cyl; i++) {

        format_parameters->StartCylinderNumber = i;
        format_parameters->EndCylinderNumber = i;

        if (IsDmfFormat) {
            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_FORMAT_TRACKS_EX,
                                                 format_parameters,
                                                 format_parameters_size,
                                                 bad, num_bad*
                                                 sizeof(BAD_TRACK_NUMBER));

            // Skew the next cylinder by 3 sectors from this one.

            RtlMoveMemory(swap_buffer,
                          &format_parameters->SectorNumber[18],
                          3*sizeof(USHORT));
            RtlMoveMemory(&format_parameters->SectorNumber[3],
                          &format_parameters->SectorNumber[0],
                          18*sizeof(USHORT));
            RtlMoveMemory(&format_parameters->SectorNumber[0],
                          swap_buffer,
                          3*sizeof(USHORT));

        } else {
            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_FORMAT_TRACKS,
                                                 format_parameters,
                                                 sizeof(FORMAT_PARAMETERS),
                                                 bad, num_bad*
                                                 sizeof(BAD_TRACK_NUMBER));
        }

        if (!NT_SUCCESS(_last_status)) {
            DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_FORMAT_TRACKS (%x)\n", _last_status));
            DELETE_ARRAY(bad);

            switch( _last_status ) {

                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                    break;

                case STATUS_MEDIA_WRITE_PROTECTED:
                    MessageId = MSG_FMT_WRITE_PROTECTED_MEDIA ;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }

            Message ? Message->DisplayMsg(MessageId) : 1;
            return FALSE;
        }


        // Verify the sectors.

        if (BadSectors) {

            if (!Read(i*sec_per_cyl, sec_per_cyl, hmem.GetBuf())) {

                // If this is the first track then give out.
                // A disk with a bad cylinder 0 is not
                // worth continuing on.
                //
                // As of 7/29/94, formatting 2.88 floppies to 1.44
                // doesn't work on Alphas; if we can't format to
                // 1.44 and 2.88 is supported, try 2.88.
                //
                if (i == 0) {

                    if( !IsDmfFormat &&
                        QueryMediaType() == F3_1Pt44_512 &&
                        SetMediaType(F3_2Pt88_512) ) {

                        return( FormatVerifyFloppy( F3_2Pt88_512,
                                                    BadSectors,
                                                    Message,
                                                    IsDmfFormat ) );

                    } else {

                        Message ? Message->DisplayMsg(MSG_UNUSABLE_DISK) : 1;
                        return FALSE;
                    }
                }

                for (j = 0; j < sec_per_cyl; j++) {
                    if (!Read(i*sec_per_cyl + j, 1, hmem.GetBuf())) {
                        if (!BadSectors->Add(i*sec_per_cyl + j)) {
                            return FALSE;
                        }
                    }
                }
            }
        }

        if ((i + 1)*100/cyl > percent) {
            percent = (i + 1)*100/cyl;
            if (percent > 100) {
                percent = 100;
            }

            // This check for success on the message object
            // has to be there for FMIFS to implement CANCEL.

            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                DELETE_ARRAY(bad);
                return FALSE;
            }
        }
    }

    DELETE_ARRAY(bad);

    return TRUE;
}


DEFINE_EXPORTED_CONSTRUCTOR( LOG_IO_DP_DRIVE, IO_DP_DRIVE, IFSUTIL_EXPORT );


IFSUTIL_EXPORT
LOG_IO_DP_DRIVE::~LOG_IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for LOG_IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes a LOG_IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the path of the drive object.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite, FormatType);
}

IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a LOG_IO_DP_DRIVE object for a hosted
    drive, i.e. one which is implemented as a file on another volume.


Arguments:

    NtDriveName     - Supplies the path of the drive object.
    HostFileName    - Supplies the fully qualified name of the host file.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName,
                                   HostFileName,
                                   Message,
                                   ExclusiveWrite);
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::SetSystemId(
    IN  PARTITION_SYSTEM_ID   SystemId
    )
/*++

Routine Description:

    This routine sets the system identifier (or partition type) in the
    hidden sectors of a logical volume on a fixed disk.

Arguments:

    SystemId    - Supplies the system id to write in the partition entry.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK             status_block;
    SET_PARTITION_INFORMATION   partition_info;

    //
    // This operation is unnecessary on floppies, super-floppies, and
    // hosted volumes.
    //

    if (IsFloppy() || IsSuperFloppy() || _hosted_drive) {
        return TRUE;
    }

    if( SystemId == SYSID_NONE ) {

        // Note: billmc -- we should never set it to zero!

        DebugPrint( "Skip setting the partition type to zero.\n" );
        return TRUE;
    }

    partition_info.PartitionType = (UCHAR)SystemId;

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_SET_PARTITION_INFO,
                                         &partition_info,
                                         sizeof(SET_PARTITION_INFORMATION),
                                         NULL, 0);

    return NT_SUCCESS(_last_status) ||
           _last_status == STATUS_INVALID_DEVICE_REQUEST;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector  - Supplies the first sector to be read.
    NumberOfSectors - Supplies the number of sectors to be read.
    Buffer          - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Read(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Write(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Write(StartingSector, NumberOfSectors, Buffer);
}
#endif // FE_SB && _X86_


DEFINE_CONSTRUCTOR( PHYS_IO_DP_DRIVE, IO_DP_DRIVE );

PHYS_IO_DP_DRIVE::~PHYS_IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for PHYS_IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
PHYS_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes a PHYS_IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the path of the drive object.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite, FormatType);
}

#if defined(IO_PERF_COUNTERS)
VOID
IO_DP_DRIVE::QueryPerformanceCounters(
        PLARGE_INTEGER          Wtime,
        PLARGE_INTEGER          Rtime,
        PLARGE_INTEGER          Ctime,
        PLARGE_INTEGER          WSecCount,
        PLARGE_INTEGER          WCount,
        PLARGE_INTEGER          RRtime,
        PLARGE_INTEGER          RSecCount,
        PLARGE_INTEGER          RCount
)
{
        *Wtime = _wtotal;
        *Rtime = _rtotal;
        *Ctime = _ctotal;
        *WSecCount = _wsize;
        *WCount = _wcount;

        *RRtime = _rrtotal;
        *RSecCount = _rsize;
        *RCount = _rcount;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\digraph.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

        digraph.cxx

Abstract:

        This module implements the Directed Graph class.

Author:

        Matthew Bradburn (mattbr)  11-Nov-1994

Remarks:

    The class is implemented as a mapping from parent to child.
    There is a hash table of parents, with a linked-list of parent nodes
    from each hash table bucket... each parent node then holds a pointer
    to a tree of child nodes which share an edge with that parent.  In an
    attempt to save memory, each child node actually has a starting value
    and a bitmap which describes the possible children immediately following
    that starting value.

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "digraph.hxx"
#include "numset.hxx"
#include "bitvect.hxx"
#include "list.hxx"
#include "intstack.hxx"


CONST NumHeads = 1024;

DEFINE_EXPORTED_CONSTRUCTOR( DIGRAPH, OBJECT, IFSUTIL_EXPORT );

DEFINE_EXPORTED_CONSTRUCTOR( DIGRAPH_EDGE, OBJECT, IFSUTIL_EXPORT );

VOID
DIGRAPH::Construct (
        )
/*++

Routine Description:

    Constructor for DIGRAPH.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _parent_head = NULL;
    _num_nodes = 0;
}


VOID
DIGRAPH::Destroy(
    )
/*++

Routine Description:

    This routine returns the DIGRAPH to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE_ARRAY(_parent_head);
    _num_nodes = 0;
}


IFSUTIL_EXPORT
DIGRAPH::~DIGRAPH(
    )
/*++

Routine Description:

    Destructor for DIGRAPH.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::Initialize(
    IN  ULONG   NumberOfNodes
    )
/*++

Routine Description:

    This routine initializes this class to an empty directed graph.

Arguments:

    NumberOfNodes   - Supplies the number of nodes in the graph.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _num_nodes = NumberOfNodes;

    if (!(_parent_head = NEW PPARENT_ENTRY[NumHeads]) ||
        !_parent_mgr.Initialize(sizeof(PARENT_ENTRY)) ||
        !_element_mgr.Initialize()) {

        return FALSE;
    }

    memset(_parent_head, 0, sizeof(PPARENT_ENTRY)*NumHeads);

    return TRUE;
}

RTL_GENERIC_COMPARE_RESULTS
GenericChildCompare(
    RTL_GENERIC_TABLE *Table,
    PVOID First,
    PVOID Second
    )
/*++

Routine Description:

    This routine is required for use by the Generic Table package.
    In this case it will be used only to find the node containing
    a particular child, and the caller will search the bits in that
    node after that.


--*/
{
    PCHILD_ENTRY FirstChild = PCHILD_ENTRY(First);
    PCHILD_ENTRY SecondChild = PCHILD_ENTRY(Second);

    if (FirstChild->Child < SecondChild->Child) {
        return GenericLessThan;
    }
    if (FirstChild->Child > SecondChild->Child) {
        return GenericGreaterThan;
    }
    return GenericEqual;
}

PVOID
NTAPI
GenericChildAllocate(
    RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    )
{
    return ((PDIGRAPH)Table->TableContext)->AllocChild(ByteSize);
}

VOID
NTAPI
GenericChildDeallocate(
    RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    )
{
    ((PDIGRAPH)Table->TableContext)->FreeChild(Buffer);
}

PPARENT_ENTRY
DIGRAPH::GetParentEntry(
    IN  ULONG   Parent
    ) CONST
/*++

Routine Description:

    This routine searches for the requested parent entry and returns it if
    it is found.

Arguments:

    Parent  - Supplies the number of the parent.

Return Value:

    A pointer to the requested parent entry or NULL.

--*/
{
    PPARENT_ENTRY   r;

    for (r = _parent_head[Parent%NumHeads]; NULL != r; r = r->Next) {
        if (r->Parent == Parent) {
            break;
        }
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::AddEdge(
    IN  ULONG   Parent,
    IN  ULONG   Child
    )
/*++

Routine Description:

    This routine adds an edge to the digraph.

Arguments:

    Parent  - Supplies the source node of the edge.
    Child   - Supplies the destination node of the edge.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Parent < _num_nodes);
    DebugAssert(Child < _num_nodes);

    PPARENT_ENTRY   parent_entry;
    CHILD_ENTRY     new_child;
    PCHILD_ENTRY    pChild;
    RTL_BITMAP      bitmap_hdr;

    memset(&new_child, 0, sizeof(new_child));

    //
    // Figure out which node we're looking for by rounding Child down
    // to the appropriate alignment.
    //

    new_child.Child = Child & ~(BITS_PER_CHILD_ENTRY - 1);

    DebugAssert(new_child.Child <= Child);
    DebugAssert(new_child.Child + BITS_PER_CHILD_ENTRY >= Child);

    if (!(parent_entry = GetParentEntry(Parent))) {
        if (!(parent_entry = (PPARENT_ENTRY) _parent_mgr.Alloc())) {
            return FALSE;
        }

        parent_entry->Next = _parent_head[Parent%NumHeads];
        parent_entry->Parent = Parent;

        RtlInitializeGenericTable(
            &parent_entry->Children,
            GenericChildCompare,
            GenericChildAllocate,
            GenericChildDeallocate,
            this
            );

        _parent_head[Parent%NumHeads] = parent_entry;
    }

    pChild = (PCHILD_ENTRY)RtlInsertElementGenericTable(
                &parent_entry->Children,
                &new_child,
                sizeof(new_child),
                NULL
                );
    if (NULL == pChild) {
        return FALSE;
    }

    RtlInitializeBitMap(&bitmap_hdr, pChild->ChildBits, BITS_PER_CHILD_ENTRY);

    RtlSetBits(&bitmap_hdr, Child - new_child.Child, 1);

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::RemoveEdge(
    IN  ULONG   Parent,
    IN  ULONG   Child
    )
/*++

Routine Description:

    This routine removes an edge from the digraph.

Arguments:

    Parent  - Supplies the source node of the edge.
    Child   - Supplies the destination node of the edge.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Parent < _num_nodes);
    DebugAssert(Child < _num_nodes);

    PPARENT_ENTRY   parent_entry;
    CHILD_ENTRY     curr;
    PCHILD_ENTRY    pChild;
    RTL_BITMAP      bitmap_hdr;

    curr.Child = Child & ~(BITS_PER_CHILD_ENTRY - 1);

    if (!(parent_entry = GetParentEntry(Parent))) {
        return TRUE;
    }

    pChild = (PCHILD_ENTRY)RtlLookupElementGenericTable(
        &parent_entry->Children,
        &curr);
    if (NULL == pChild) {
        return TRUE;
    }

    RtlInitializeBitMap(&bitmap_hdr, pChild->ChildBits, BITS_PER_CHILD_ENTRY);

    RtlClearBits(&bitmap_hdr, Child - curr.Child, 1);

    //
    // Now if the entire bitmap for this node is clear, we'll delete
    // the node itself.
    //

    if ((ULONG)-1 == RtlFindSetBits(&bitmap_hdr, 1, 0)) {
        RtlDeleteElementGenericTable(&parent_entry->Children, &curr);
    }

    return TRUE;
}


ULONG
DIGRAPH::QueryNumChildren(
    IN  ULONG   Parent
    ) CONST
/*++

Routine Description:

    This routine computes the number of children that belong to the
    given parent.

Arguments:

    Parent  - Supplies the parent node.

Return Value:

    The number of children pointed to by the parent.

--*/
{
    PPARENT_ENTRY   parent_entry;
    RTL_BITMAP      bitmap_hdr;
    PVOID           restart_key;
    PVOID           ptr;
    ULONG           r;

    if (!(parent_entry = GetParentEntry(Parent))) {
        return 0;
    }

    //
    // Need to enuerate through all the children and count the bits in
    // each bitmap.
    //

    r = 0;
    restart_key = NULL;

    for (ptr = RtlEnumerateGenericTableWithoutSplaying(
            &parent_entry->Children, &restart_key);
         ptr != NULL;
         ptr = RtlEnumerateGenericTableWithoutSplaying(
            &parent_entry->Children, &restart_key)) {

        RtlInitializeBitMap(&bitmap_hdr, PCHILD_ENTRY(ptr)->ChildBits,
             BITS_PER_CHILD_ENTRY);

        r += RtlNumberOfSetBits(&bitmap_hdr);
    }

    return r;
}


ULONG
DIGRAPH::QueryNumParents(
    IN  ULONG   Child
    ) CONST
/*++

Routine Description:

    This routine computes the number of parents that belong to the
    given child.

Arguments:

    Child   - Supplies the child node.

Return Value:

    The number of parents that point to the child.

--*/
{
    ULONG           i, r;
    PPARENT_ENTRY   currp;
    CHILD_ENTRY     curr;
    RTL_BITMAP      bitmap_hdr;
    PCHILD_ENTRY    pChild;

    curr.Child = Child & ~(BITS_PER_CHILD_ENTRY - 1);

    r = 0;
    for (i = 0; i < NumHeads; i++) {
        for (currp = _parent_head[i]; currp; currp = currp->Next) {

            //
            // Increment <r> if the child tree contains <Child>.
            //

            pChild = (PCHILD_ENTRY)RtlLookupElementGenericTable(
                &currp->Children, &curr);
            if (NULL == pChild) {
                continue;
            }

            RtlInitializeBitMap(&bitmap_hdr, pChild->ChildBits,
                BITS_PER_CHILD_ENTRY);

            if (RtlCheckBit(&bitmap_hdr, Child - curr.Child)) {
                r++;
            }
        }
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::QueryChildren(
    IN  ULONG       Parent,
    OUT PNUMBER_SET Children
    ) CONST
/*++

Routine Description:

    This routine computes the children of the given parent.

Arguments:

    Parent      - Supplies the parent.
    Children    - Return the children.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPARENT_ENTRY   parent_entry;
    RTL_BITMAP      bitmap_hdr;
    PVOID           restart_key;
    PVOID           ptr;
    ULONG           i;

    if (!Children->Initialize()) {
        return FALSE;
    }

    if (!(parent_entry = GetParentEntry(Parent))) {
        return TRUE;
    }

    restart_key = NULL;
    for (ptr = RtlEnumerateGenericTableWithoutSplaying(
            &parent_entry->Children, &restart_key);
         ptr != NULL;
         ptr = RtlEnumerateGenericTableWithoutSplaying(
            &parent_entry->Children, &restart_key)) {

        //
        // Add a child for each set bit in this node.
        //

        RtlInitializeBitMap(&bitmap_hdr, PCHILD_ENTRY(ptr)->ChildBits,
            BITS_PER_CHILD_ENTRY);

        for (i = 0; i < BITS_PER_CHILD_ENTRY; ++i) {

            if (RtlCheckBit(&bitmap_hdr, i)) {

                if (!Children->Add(PCHILD_ENTRY(ptr)->Child + i)) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::QueryParents(
    IN  ULONG       Child,
    OUT PNUMBER_SET Parents
    ) CONST
/*++

Routine Description:

    This routine computes the parents of the given child.

Arguments:

    Child      - Supplies the child.
    Parents    - Return the parents.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;
    PPARENT_ENTRY   currp;
    CHILD_ENTRY     curr;
    PCHILD_ENTRY    pChild;
    RTL_BITMAP      bitmap_hdr;

    curr.Child = Child & ~(BITS_PER_CHILD_ENTRY - 1);

    if (!Parents->Initialize()) {
        return FALSE;
    }

    for (i = 0; i < NumHeads; i++) {
        for (currp = _parent_head[i]; currp; currp = currp->Next) {

            pChild = (PCHILD_ENTRY)RtlLookupElementGenericTable(
                &currp->Children, &curr);
            if (NULL == pChild) {
                continue;
            }

            RtlInitializeBitMap(&bitmap_hdr, pChild->ChildBits,
                BITS_PER_CHILD_ENTRY);

            if (RtlCheckBit(&bitmap_hdr, Child - curr.Child)) {

                if (!Parents->Add(currp->Parent)) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::QueryParentsWithChildren(
    OUT PNUMBER_SET Parents,
    IN  ULONG       MinimumNumberOfChildren
    ) CONST
/*++

Routine Description:

    This routine returns a list of all digraph nodes with out degree
    greater than or equal to the given minimum.

Arguments:

    Parents                 - Returns a list of parents.
    MinimumNumberOfChildren - Supplies the minimum number of children
                                that a parent must have to qualify for
                                the list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;
    PPARENT_ENTRY   currp;
    ULONG           count;
    RTL_BITMAP      bitmap_hdr;
    PVOID           ptr;
    PVOID           restart_key;

    if (!Parents->Initialize()) {
        return FALSE;
    }

    if (!MinimumNumberOfChildren) {
        return Parents->Add(0, _num_nodes);
    }

    for (i = 0; i < NumHeads; i++) {
        for (currp = _parent_head[i]; currp; currp = currp->Next) {

            //
            // Need to enumerate nodes of the tree and count bits in
            // each node.
            //

            restart_key = NULL;
            count = 0;

            for (ptr = RtlEnumerateGenericTableWithoutSplaying(
                    &currp->Children, &restart_key);
                 ptr != NULL;
                 ptr = RtlEnumerateGenericTableWithoutSplaying(
                    &currp->Children, &restart_key)) {

                RtlInitializeBitMap(&bitmap_hdr, PCHILD_ENTRY(ptr)->ChildBits,
                    BITS_PER_CHILD_ENTRY);

                count += RtlNumberOfSetBits(&bitmap_hdr);

                if (count >= MinimumNumberOfChildren) {
                    break;
                }
            }

            if (count >= MinimumNumberOfChildren) {
                if (!Parents->Add(currp->Parent)) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::EliminateCycles(
    IN OUT  PCONTAINER  RemovedEdges
    )
/*++

Routine Description:

    This routine eliminates cycles from the digraph and then returns
    the edges that had to be removed.

Arguments:

    RemovedEdges    - Returns the edges removed from the digraph.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BITVECTOR   visited;
    ULONG       i;
    INTSTACK    ancestors;

    if (!visited.Initialize(_num_nodes) || !ancestors.Initialize()) {
        return FALSE;
    }

    for (i = 0; i < _num_nodes; i++) {

        if (!visited.IsBitSet(i) &&
            !DescendDigraph(i, &visited, &ancestors, RemovedEdges)) {

            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
DIGRAPH::DescendDigraph(
    IN      ULONG       CurrentNode,
    IN OUT  PBITVECTOR  Visited,
    IN OUT  PINTSTACK   Ancestors,
    IN OUT  PCONTAINER  RemovedEdges
    )
/*++

Routine Description:

    This routine does a depth first search on the digraph.

Arguments:

    CurrentNode - Supplies the current node being evaluated.
    Visited     - Supplies a list of nodes which have been visited.
    Ancestors   - Supplies a stack of direct ancestors.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPARENT_ENTRY   parent_entry;
    PNUMBER_SET     nodes_to_delete;
    ULONG           i, set_card, child_node;
    PDIGRAPH_EDGE   p;
    RTL_BITMAP      bitmap_hdr;
    PVOID           restart_key;
    PVOID           ptr;

    Visited->SetBit(CurrentNode);
    if (!Ancestors->Push(CurrentNode)) {
        return FALSE;
    }

    nodes_to_delete = NULL;

    if (NULL != (parent_entry = GetParentEntry(CurrentNode))) {

        // traverse list

        restart_key = NULL;
        for (ptr = RtlEnumerateGenericTableWithoutSplaying(
                &parent_entry->Children, &restart_key);
             ptr != NULL;
             ptr = RtlEnumerateGenericTableWithoutSplaying(
                &parent_entry->Children, &restart_key)) {

            for (i = 0; i < BITS_PER_CHILD_ENTRY; ++i) {

                RtlInitializeBitMap(&bitmap_hdr, PCHILD_ENTRY(ptr)->ChildBits,
                    BITS_PER_CHILD_ENTRY);

                if (0 == RtlCheckBit(&bitmap_hdr, i)) {
                    continue;
                }

                //
                // Child + i is a child of this parent.
                //


                if (Visited->IsBitSet(PCHILD_ENTRY(ptr)->Child + i)) {

                    // Check for cycle.

                    if (Ancestors->IsMember(PCHILD_ENTRY(ptr)->Child + i)) {

                        // Cycle detected.

                        if (!nodes_to_delete) {
                            if (!(nodes_to_delete = NEW NUMBER_SET) ||
                                !nodes_to_delete->Initialize()) {

                                DELETE(nodes_to_delete);
                                return FALSE;
                            }
                        }

                        if (!nodes_to_delete->Add(PCHILD_ENTRY(ptr)->Child + i)) {
                            DELETE(nodes_to_delete);
                            return FALSE;
                        }
                    }

                } else if (!DescendDigraph(PCHILD_ENTRY(ptr)->Child + i, Visited,
                    Ancestors, RemovedEdges)) {

                    DELETE(nodes_to_delete);
                    return FALSE;
                }
            }
        }
    }

    if (nodes_to_delete) {

        set_card = nodes_to_delete->QueryCardinality().GetLowPart();

        for (i = 0; i < set_card; i++) {

            child_node = nodes_to_delete->QueryNumber(i).GetLowPart();

            if (!RemoveEdge(CurrentNode, child_node)) {
                DELETE(nodes_to_delete);
                return FALSE;
            }

            if (!(p = NEW DIGRAPH_EDGE)) {
                DELETE(nodes_to_delete);
                return FALSE;
            }

            p->Parent = CurrentNode;
            p->Child = child_node;

            if (!RemovedEdges->Put(p)) {
                DELETE(nodes_to_delete);
                return FALSE;
            }
        }
    }

    Ancestors->Pop();
    DELETE(nodes_to_delete);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\ifsutil.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    ifsutil.cxx

Abstract:

        This module contains run-time, global support for the
    IFS Utilities library (IFSUTIL).   This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Bill McJohn (billmc) 30-May-1991

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

extern "C"
IFSUTIL_EXPORT
BOOLEAN
InitializeIfsUtil (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

IFSUTIL_EXPORT
BOOLEAN
InitializeIfsUtil (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Ufat by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#if defined(FE_SB) && defined(_X86_)
    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // Initialize machine id.
        //
        InitializeMachineData();
    }
#endif

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ )

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "IfsUtil initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_IFSUTIL_MEM_LEAK)
    DebugPrint("IFSUTIL.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrintTrace(("IFSUTIL.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "IfsUtil initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_IFSUTIL_MEM_LEAK)
            DebugPrint("IFSUTIL.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrintTrace(("IFSUTIL.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrint("IFSUTIL.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrint("IFSUTIL.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif _AUTOCHECK_ || _SETUP_LOADER_

    return TRUE;
}


DECLARE_CLASS(  AUTOENTRY           );
DECLARE_CLASS(  CACHE               );
DECLARE_CLASS(  CANNED_SECURITY     );
DECLARE_CLASS(  DIGRAPH             );
DECLARE_CLASS(  DIGRAPH_EDGE        );
DECLARE_CLASS(  DP_DRIVE            );
DECLARE_CLASS(  DRIVE               );
DECLARE_CLASS(  DRIVE_CACHE         );
DECLARE_CLASS(  INTSTACK            );
DECLARE_CLASS(  IO_DP_DRIVE         );
DECLARE_CLASS(  LOG_IO_DP_DRIVE     );
DECLARE_CLASS(  MOUNT_POINT_MAP     );
DECLARE_CLASS(  MOUNT_POINT_TUPLE   );
DECLARE_CLASS(  NUMBER_EXTENT       );
DECLARE_CLASS(  NUMBER_SET          );
DECLARE_CLASS(  PHYS_IO_DP_DRIVE    );
DECLARE_CLASS(  READ_CACHE          );
DECLARE_CLASS(  READ_WRITE_CACHE    );
DECLARE_CLASS(  SECRUN              );
DECLARE_CLASS(  SPARSE_SET          );
DECLARE_CLASS(  SUPERAREA           );
DECLARE_CLASS(  TLINK               );
DECLARE_CLASS(  VOL_LIODPDRV        );


STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
    if( DEFINE_CLASS_DESCRIPTOR(    AUTOENTRY           ) &&
        DEFINE_CLASS_DESCRIPTOR(    CACHE               ) &&
        DEFINE_CLASS_DESCRIPTOR(    CANNED_SECURITY     ) &&
        DEFINE_CLASS_DESCRIPTOR(    DIGRAPH             ) &&
        DEFINE_CLASS_DESCRIPTOR(    DIGRAPH_EDGE        ) &&
        DEFINE_CLASS_DESCRIPTOR(    DP_DRIVE            ) &&
        DEFINE_CLASS_DESCRIPTOR(    DRIVE               ) &&
        DEFINE_CLASS_DESCRIPTOR(    DRIVE_CACHE         ) &&
        DEFINE_CLASS_DESCRIPTOR(    INTSTACK            ) &&
        DEFINE_CLASS_DESCRIPTOR(    IO_DP_DRIVE         ) &&
        DEFINE_CLASS_DESCRIPTOR(    LOG_IO_DP_DRIVE     ) &&
        DEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_MAP     ) &&
        DEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_TUPLE   ) &&
        DEFINE_CLASS_DESCRIPTOR(    NUMBER_EXTENT       ) &&
        DEFINE_CLASS_DESCRIPTOR(    NUMBER_SET          ) &&
        DEFINE_CLASS_DESCRIPTOR(    PHYS_IO_DP_DRIVE    ) &&
        DEFINE_CLASS_DESCRIPTOR(    READ_CACHE          ) &&
        DEFINE_CLASS_DESCRIPTOR(    READ_WRITE_CACHE    ) &&
        DEFINE_CLASS_DESCRIPTOR(    SECRUN              ) &&
        DEFINE_CLASS_DESCRIPTOR(    SPARSE_SET          ) &&
        DEFINE_CLASS_DESCRIPTOR(    SUPERAREA           ) &&
        DEFINE_CLASS_DESCRIPTOR(    TLINK               ) &&
        DEFINE_CLASS_DESCRIPTOR(    VOL_LIODPDRV        ) ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR(    AUTOENTRY           );
    UNDEFINE_CLASS_DESCRIPTOR(    CACHE               );
    UNDEFINE_CLASS_DESCRIPTOR(    CANNED_SECURITY     );
    UNDEFINE_CLASS_DESCRIPTOR(    DIGRAPH             );
    UNDEFINE_CLASS_DESCRIPTOR(    DIGRAPH_EDGE        );
    UNDEFINE_CLASS_DESCRIPTOR(    DP_DRIVE            );
    UNDEFINE_CLASS_DESCRIPTOR(    DRIVE               );
    UNDEFINE_CLASS_DESCRIPTOR(    DRIVE_CACHE         );
    UNDEFINE_CLASS_DESCRIPTOR(    INTSTACK            );
    UNDEFINE_CLASS_DESCRIPTOR(    IO_DP_DRIVE         );
    UNDEFINE_CLASS_DESCRIPTOR(    LOG_IO_DP_DRIVE     );
    UNDEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_MAP     );
    UNDEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_TUPLE   );
    UNDEFINE_CLASS_DESCRIPTOR(    NUMBER_EXTENT       );
    UNDEFINE_CLASS_DESCRIPTOR(    NUMBER_SET          );
    UNDEFINE_CLASS_DESCRIPTOR(    PHYS_IO_DP_DRIVE    );
    UNDEFINE_CLASS_DESCRIPTOR(    READ_CACHE          );
    UNDEFINE_CLASS_DESCRIPTOR(    READ_WRITE_CACHE    );
    UNDEFINE_CLASS_DESCRIPTOR(    SECRUN              );
    UNDEFINE_CLASS_DESCRIPTOR(    SPARSE_SET          );
    UNDEFINE_CLASS_DESCRIPTOR(    SUPERAREA           );
    UNDEFINE_CLASS_DESCRIPTOR(    TLINK               );
    UNDEFINE_CLASS_DESCRIPTOR(    VOL_LIODPDRV        );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\intstack.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "intstack.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( INTSTACK, OBJECT, IFSUTIL_EXPORT );

VOID
INTSTACK::Construct (
        )
/*++

Routine Description:

    Constructor for INTSTACK.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _stack = NULL;
    _size = 0;
}


IFSUTIL_EXPORT
INTSTACK::~INTSTACK(
    )
/*++

Routine Description:

    Destructor for INTSTACK.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
INTSTACK::Initialize(
    )
/*++

Routine Description:

    This routine initializes the stack for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();
    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
INTSTACK::Push(
    IN  BIG_INT Data
    )
/*++

Routine Description:

    This routine pushes 'Data' on the stack.

Arguments:

    Data    - Supplies the integer to push on the stack.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PINTNODE    p;

    p = _stack;
        if (!(_stack = NEW INTNODE)) {
        _stack = p;
        return FALSE;
    }

    _stack->Next = p;
    _stack->Data = Data;
    _size++;

    return TRUE;
}


IFSUTIL_EXPORT
VOID
INTSTACK::Pop(
    IN  ULONG   HowMany
    )
/*++

Routine Description:

    This routine attempts to remove 'HowMany' elements from the top of
    the stack.  If there are not that many to remove then all that
    can be removed, will be removed and FALSE will be returned.

Arguments:

    HowMany - Supplies the number of elements to remove from the top of the
                stack.

Return Value:

    None.

--*/
{
    PINTNODE    p;

    for (; HowMany; HowMany--) {

        DebugAssert(_stack);

        p = _stack->Next;
                DELETE( _stack );
        _stack = p;
        _size--;
    }
}


IFSUTIL_EXPORT
BIG_INT
INTSTACK::Look(
    IN  ULONG   Index
    ) CONST
/*++

Routine Description:

    This routine returns the 'Index'th element of the stack.  Index 0 denotes
    the top of the stack.  Index 1 denotes one element from the top of the
    stack and so on.  If the stack is smaller than the element requested then
    this routine will return 0.  This is not a limitation since 'QuerySize'
    will return the depth of the stack.

Arguments:

    Index   - Supplies the index of the data requested.

Return Value:

    The value of the stack element at position 'Index' or 0.

--*/
{
    PINTNODE    p;

    p = _stack;
    for (; Index; Index--) {
        p = p ? p->Next : NULL;
    }

    if (!p) {
        return 0;
    }

    return p->Data;
}


BOOLEAN
INTSTACK::IsMember(
    IN  BIG_INT Data
    ) CONST
/*++

Routine Description:

    This routine searches the stack to see if there is an element equal
    to 'Data'.  It returns TRUE if there is.

Arguments:

    Data    - Supplies the element to search for.

Return Value:

    FALSE   - 'Data' is not an element of the stack.
    TRUE    - 'Data' is an element of the stack.

--*/
{
    PINTNODE    p;

    for (p = _stack; p; p = p->Next) {
        if (Data == p->Data) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
INTSTACK::Destroy(
    )
/*++

Routine Description:

    This routine returns the INTSTACK to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PINTNODE    p;

    while (_stack) {
        p = _stack->Next;
                DELETE( _stack );
        _stack = p;
    }
    _size = 0;
}


BOOLEAN
INTSTACK::ReverseCopy(
    PINTSTACK   x
    )
/*++

Routine Description:

    This routine copies the INTSTACK backwards.

Arguments:

    x       - Supplies the INTSTACK to copy from.

Return Value:

    TRUE    - if successful
    FALSE   - if failure

--*/
{
    BOOLEAN     result = TRUE;
    PINTNODE    p;

    for (p = x->_stack; p && result; p = p->Next) {
        result = Push(p->Data);
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\ifssys.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

        ifssys.cxx

Abstract:

    This module contains the implementation for the IFS_SYSTEM class.
    The IFS_SYSTEM class is an abstract class which offers an
    interface for communicating with the underlying operating system
    on specific IFS issues.

Author:

        Norbert P. Kusters (norbertk) 03-Sep-1991

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "ifssys.hxx"
#include "bigint.hxx"
#include "wstring.hxx"
#include "cannedsd.hxx"
#include "drive.hxx"
#include "secrun.hxx"
#include "hmem.hxx"
#include "bpb.hxx"
#include "volume.hxx"

#include "untfs2.hxx"

#if defined(_AUTOCHECK_)
extern "C" {
    #include "ntos.h"
}
#endif

PCANNED_SECURITY    IFS_SYSTEM::_CannedSecurity = NULL;

BOOLEAN
IFS_SYSTEM::IsThisFat(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines if the given boot sector is a FAT
    boot sector.

Arguments:

    Sectors     - Supplies the number of sectors on this drive.
    BootSector  - Supplies the boot sector data.

Return Value:

    FALSE   - This is not a FAT boot sector.
    TRUE    - This is a FAT boot sector.

--*/
{
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK  BootSector =
                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)BootSectorData;
    BOOLEAN r;
    USHORT  bytes_per_sector, reserved_sectors, root_entries, sectors;
    USHORT  sectors_per_fat;
    ULONG   large_sectors;

    r = TRUE;

    memcpy(&bytes_per_sector, BootSector->Bpb.BytesPerSector, sizeof(USHORT));
    memcpy(&reserved_sectors, BootSector->Bpb.ReservedSectors, sizeof(USHORT));
    memcpy(&root_entries, BootSector->Bpb.RootEntries, sizeof(USHORT));
    memcpy(&sectors, BootSector->Bpb.Sectors, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->Bpb.LargeSectors, sizeof(ULONG));
    memcpy(&sectors_per_fat, BootSector->Bpb.SectorsPerFat, sizeof(USHORT));

#if defined(FE_SB) && defined(_X86_)
    //
    // 3mode PC/AT support 'I' of 'IPL1'
    //
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9 &&
        BootSector->IntelNearJumpCommand[0] != 0x49) {  // FMR 'I' of 'IPL1'
#else
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9) {
#endif
        r = FALSE;

    } else if ((bytes_per_sector != 128) &&
               (bytes_per_sector != 256) &&
               (bytes_per_sector != 512) &&
               (bytes_per_sector != 1024) &&
               (bytes_per_sector != 2048) &&
               (bytes_per_sector != 4096)) {

        r = FALSE;

    } else if ((BootSector->Bpb.SectorsPerCluster[0] != 1) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 2) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 4) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 8) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 16) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 32) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 64) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 128)) {

        r = FALSE;

    } else if (reserved_sectors == 0) {

        r = FALSE;

    } else if (BootSector->Bpb.Fats[0] == 0) {

        r = FALSE;

    } else if (root_entries == 0) {

        r = FALSE;

    } else if (Sectors.GetHighPart() != 0) {

        r = FALSE;

    } else if (sectors != 0 && sectors > Sectors.GetLowPart()) {

        r = FALSE;

    } else if (sectors == 0 && large_sectors > Sectors.GetLowPart()) {

        r = FALSE;

    } else if (sectors == 0 && large_sectors == 0) {

        r = FALSE;

    } else if (sectors_per_fat == 0) {

        r = FALSE;

    }

    return r;
}

BOOLEAN
IFS_SYSTEM::IsThisFat32(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines if the given boot sector is a FAT32
    boot sector.

Arguments:

    Sectors     - Supplies the number of sectors on this drive.
    BootSector  - Supplies the boot sector data.

Return Value:

    FALSE   - This is not a FAT32 boot sector.
    TRUE    - This is a FAT32 boot sector.

--*/
{
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK BootSector =
            (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)BootSectorData;
    BOOLEAN r;
    USHORT  bytes_per_sector, reserved_sectors, sectors;
    ULONG   root_entries, sectors_per_fat;
    ULONG   large_sectors;

    r = TRUE;

    root_entries=0;
    memcpy(&root_entries, BootSector->Bpb.RootEntries, sizeof(USHORT));

    memcpy(&bytes_per_sector, BootSector->Bpb.BytesPerSector, sizeof(USHORT));
    memcpy(&reserved_sectors, BootSector->Bpb.ReservedSectors, sizeof(USHORT));
    memcpy(&sectors, BootSector->Bpb.Sectors, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->Bpb.LargeSectors, sizeof(ULONG));
    memcpy(&sectors_per_fat, BootSector->Bpb.BigSectorsPerFat, sizeof(ULONG));

#if defined(FE_SB) && defined(_X86_)
    //
    // 3mode PC/AT support 'I' of 'IPL1'
    //
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9 &&
        BootSector->IntelNearJumpCommand[0] != 0x49) {  // FMR 'I' of 'IPL1'
#else
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9) {
#endif
        r = FALSE;

    } else if ((bytes_per_sector != 128) &&
               (bytes_per_sector != 256) &&
               (bytes_per_sector != 512) &&
               (bytes_per_sector != 1024) &&
               (bytes_per_sector != 2048) &&
               (bytes_per_sector != 4096)) {

        r = FALSE;

    } else if ((BootSector->Bpb.SectorsPerCluster[0] != 1) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 2) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 4) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 8) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 16) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 32) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 64) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 128)) {

        r = FALSE;

    } else if ( sectors_per_fat == 0 || (0 != BootSector->Bpb.SectorsPerFat[0] &&
                                         0 != BootSector->Bpb.SectorsPerFat[1]) ) {

        DebugPrint("IsThisFat32() not fat 32 sectors/fat value\n");
        r = FALSE;

    } else {

        if (reserved_sectors == 0) {

            r = FALSE;

        } else if (BootSector->Bpb.Fats[0] == 0) {

            r = FALSE;

        } else if (root_entries != 0) {

            r = FALSE;

        } else if (Sectors.GetHighPart() != 0) {

            r = FALSE;

        } else if (sectors != 0 && sectors > Sectors.GetLowPart()) {

            r = FALSE;

        } else if (sectors == 0 && large_sectors > Sectors.GetLowPart()) {

            r = FALSE;

        } else if (sectors == 0 && large_sectors == 0) {

            r = FALSE;

        }
    }

    return r;
}

BOOLEAN
IFS_SYSTEM::IsThisHpfs(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData,
    IN  PULONG  SuperBlock,
    IN  PULONG  SpareBlock
    )
/*++

Routine Description:

    This routine determines whether or not the given structures
    are part of an HPFS file system.

Arguments:

    Sectors     - Supplies the number of sectors on the volume.
    BootSector  - Supplies the unaligned boot sector.
    SuperBlock  - Supplies the super block.
    SpareBlock  - Supplies the spare block.

Return Value:

    FALSE   - The given structures are not part on an HPFS volume.
    TRUE    - The given structures are part of an HPFS volume.

--*/
{
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK BootSector =
                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)BootSectorData;
    BOOLEAN r;
    USHORT  bytes_per_sector, sectors;
    ULONG   large_sectors;

    r = TRUE;

    memcpy(&bytes_per_sector, BootSector->Bpb.BytesPerSector, sizeof(USHORT));
    memcpy(&sectors, BootSector->Bpb.Sectors, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->Bpb.LargeSectors, sizeof(ULONG));

#if defined(FE_SB) && defined(_X86_)
    //
    // 3mode PC/AT support 'I' of 'IPL1'
    //
    if ((BootSector->IntelNearJumpCommand[0] != 0xeb &&
         BootSector->IntelNearJumpCommand[0] != 0xe9 &&
         BootSector->IntelNearJumpCommand[0] != 0x49) ||
#else
    if ((BootSector->IntelNearJumpCommand[0] != 0xeb &&
         BootSector->IntelNearJumpCommand[0] != 0xe9) ||
#endif
        bytes_per_sector != 512 ||
        ((PUCHAR) BootSector)[510] != 0x55 ||
        ((PUCHAR) BootSector)[511] != 0xaa ||
        BootSector->Bpb.Fats[0] != 0 ||
        (sectors == 0 && large_sectors == 0) ||
        (sectors != 0 && large_sectors != 0) ||
        (sectors > Sectors.GetLowPart()) ||
        (large_sectors > Sectors.GetLowPart()) ||
        Sectors.GetHighPart() != 0) {

        r = FALSE;

    } else if (SuperBlock[0] != 0xF995E849 ||
               SuperBlock[1] != 0xFA53E9C5 ||
               SpareBlock[0] != 0xf9911849 ||
               SpareBlock[1] != 0xfa5229c5) {

        r = FALSE;

    }

    return r;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsThisNtfs(
    IN  BIG_INT Sectors,
    IN  ULONG   SectorSize,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines whether or not the given structure
    is part of an NTFS partition.

Arguments:

    Sectors     - Supplies the number of sectors on the drive.
    SectorSize  - Supplies the number of bytes per sector.
    BootSectorData
                - Supplies an unaligned boot sector.

Return Value:

    FALSE   - The supplied boot sector is not part of an NTFS
    TRUE    - The supplied boot sector is part of an NTFS volume.

--*/
{
    PPACKED_BOOT_SECTOR BootSector = (PPACKED_BOOT_SECTOR)BootSectorData;
    BOOLEAN r;
    ULONG   checksum;
    PULONG  l;
    USHORT  reserved_sectors, root_entries, sectors, sectors_per_fat;
    USHORT  bytes_per_sector;
    ULONG   large_sectors;

    memcpy(&reserved_sectors, BootSector->PackedBpb.ReservedSectors, sizeof(USHORT));
    memcpy(&root_entries, BootSector->PackedBpb.RootEntries, sizeof(USHORT));
    memcpy(&sectors, BootSector->PackedBpb.Sectors, sizeof(USHORT));
    memcpy(&sectors_per_fat, BootSector->PackedBpb.SectorsPerFat, sizeof(USHORT));
    memcpy(&bytes_per_sector, BootSector->PackedBpb.BytesPerSector, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->PackedBpb.LargeSectors, sizeof(ULONG));


    r = TRUE;

    checksum = 0;
    for (l = (PULONG) BootSector; l < (PULONG) &BootSector->Checksum; l++) {
        checksum += *l;
    }

    if (BootSector->Oem[0] != 'N' ||
        BootSector->Oem[1] != 'T' ||
        BootSector->Oem[2] != 'F' ||
        BootSector->Oem[3] != 'S' ||
        BootSector->Oem[4] != ' ' ||
        BootSector->Oem[5] != ' ' ||
        BootSector->Oem[6] != ' ' ||
        BootSector->Oem[7] != ' ' ||
        // BootSector->Checksum != checksum ||
        bytes_per_sector != SectorSize) {

        r = FALSE;

    } else if ((BootSector->PackedBpb.SectorsPerCluster[0] != 0x1) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x2) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x4) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x8) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x10) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x20) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x40) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x80)) {

        r = FALSE;

    } else if (reserved_sectors != 0 ||
               BootSector->PackedBpb.Fats[0] != 0 ||
               root_entries != 0 ||
               sectors != 0 ||
               sectors_per_fat != 0 ||
               large_sectors != 0 ||
               BootSector->NumberSectors > Sectors ||
               BootSector->MftStartLcn >= Sectors ||
               BootSector->Mft2StartLcn >= Sectors) {

        r = FALSE;
    }

    if (!r) {
        return r;
    }

    if (BootSector->ClustersPerFileRecordSegment < 0) {

        LONG temp = LONG(BootSector->ClustersPerFileRecordSegment);

        temp = 2 << -temp;

        if (temp < 512) {
            return FALSE;
        }
    } else if ((BootSector->ClustersPerFileRecordSegment != 0x1) &&
               (BootSector->ClustersPerFileRecordSegment != 0x2) &&
               (BootSector->ClustersPerFileRecordSegment != 0x4) &&
               (BootSector->ClustersPerFileRecordSegment != 0x8) &&
               (BootSector->ClustersPerFileRecordSegment != 0x10) &&
               (BootSector->ClustersPerFileRecordSegment != 0x20) &&
               (BootSector->ClustersPerFileRecordSegment != 0x40) &&
               (BootSector->ClustersPerFileRecordSegment != 0x80)) {

        return FALSE;
    }

    if (BootSector->DefaultClustersPerIndexAllocationBuffer < 0) {

        LONG temp = LONG(BootSector->DefaultClustersPerIndexAllocationBuffer);

        temp = 2 << -temp;

        if (temp < 512) {
            return FALSE;
        }
    } else if ((BootSector->DefaultClustersPerIndexAllocationBuffer != 0x1) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x2) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x4) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x8) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x10) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x20) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x40) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x80)) {

        r = FALSE;
    }

    return r;
}


#define BOOTBLKSECTORS 4
typedef int DSKPACKEDBOOTSECT;

BOOLEAN
IsThisOfs(
    IN      LOG_IO_DP_DRIVE *           Drive,
    IN      DSKPACKEDBOOTSECT *         PackedBootSect
    )
{
    return(FALSE);
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryNtfsVersion(
    OUT PUCHAR           Major,
    OUT PUCHAR           Minor,
    IN  PLOG_IO_DP_DRIVE Drive,
    IN  PVOID            BootSectorData
    )
/*++

Routine Description:

    This routine extracts the version number of the NTFS partition.
    Note:  Caller should call IsThisNtfs() first.

Arguments:

    Major      - Receives the major version number of NTFS partition.
    Minor      - Receives the minor version number of NTFS partition.
    Drive      - Supplies the drive that partition is on.
    BootSectorData
               - Supplies an unaligned boot sector.

Return Value:

    FALSE   - The supplied boot sector is not part of an NTFS
    TRUE    - The supplied boot sector is part of an NTFS volume.

--*/
{
    PPACKED_BOOT_SECTOR BootSector = (PPACKED_BOOT_SECTOR)BootSectorData;
    SECRUN              mftsec;
    HMEM                mftsec_hmem;
    ULONG               sectors_per_frs;
    BIG_INT             start_sector, alternate_sector;

    PFILE_RECORD_SEGMENT_HEADER vol_frs;
    PATTRIBUTE_RECORD_HEADER    attr_rec;
    PCHAR                       attr_rec_end;
    PVOLUME_INFORMATION         vol_info;

    if (BootSector->ClustersPerFileRecordSegment > 0) {
        sectors_per_frs = BootSector->ClustersPerFileRecordSegment *
                          *BootSector->PackedBpb.SectorsPerCluster;
    } else {
        sectors_per_frs = (1<<-BootSector->ClustersPerFileRecordSegment) /
                          *(USHORT UNALIGNED *)BootSector->PackedBpb.BytesPerSector;
    }

    start_sector = *BootSector->PackedBpb.SectorsPerCluster *
                   BootSector->MftStartLcn +
                   sectors_per_frs * VOLUME_DASD_NUMBER;

    alternate_sector = *BootSector->PackedBpb.SectorsPerCluster *
                       BootSector->Mft2StartLcn +
                       sectors_per_frs * VOLUME_DASD_NUMBER;

    //
    // Read in the VOLUME_DASD_NUMBER FRS
    //
    for (;;) {

        if (!mftsec_hmem.Initialize() ||
            !mftsec.Initialize(&mftsec_hmem, Drive, start_sector, sectors_per_frs))
            return FALSE;

        if (!mftsec.Read()) {
            //
            // try the mirror copy
            //
            if (start_sector != alternate_sector) {
                start_sector = alternate_sector;
                continue;
            } else
                break;
        }

        vol_frs = (PFILE_RECORD_SEGMENT_HEADER)mftsec.GetBuf();
        if (vol_frs->MultiSectorHeader.Signature[0] != 'F' ||
            vol_frs->MultiSectorHeader.Signature[1] != 'I' ||
            vol_frs->MultiSectorHeader.Signature[2] != 'L' ||
            vol_frs->MultiSectorHeader.Signature[3] != 'E') {
            if (start_sector != alternate_sector) {
                start_sector = alternate_sector;
                continue;
            } else
                break;
        }

        attr_rec = (PATTRIBUTE_RECORD_HEADER)
                   ((PCHAR)vol_frs + vol_frs->FirstAttributeOffset);
        if ((ULONG_PTR)attr_rec != DwordAlign((ULONG_PTR)attr_rec))
            return FALSE;

        attr_rec_end = ((PCHAR)vol_frs +
                       sectors_per_frs* *(USHORT UNALIGNED *)BootSector->PackedBpb.BytesPerSector);

        //
        // Scan thru the attributes for $VOLUME_INFORMATION
        //
        while ((PCHAR)attr_rec < attr_rec_end &&
            attr_rec->TypeCode != $END &&
            attr_rec->RecordLength != 0 &&
            attr_rec->TypeCode != $VOLUME_INFORMATION) {

            attr_rec = (PATTRIBUTE_RECORD_HEADER)
                       ((PCHAR)attr_rec + attr_rec->RecordLength);

            if ((ULONG_PTR)attr_rec != DwordAlign((ULONG_PTR)attr_rec))
                return FALSE;
        }

        if ((PCHAR)attr_rec < attr_rec_end) {
            if (attr_rec->TypeCode == $VOLUME_INFORMATION &&
                attr_rec->FormCode == RESIDENT_FORM &&
                attr_rec->RecordLength > SIZE_OF_RESIDENT_HEADER &&
                attr_rec->Form.Resident.ValueLength < attr_rec->RecordLength &&
                (attr_rec->RecordLength - attr_rec->Form.Resident.ValueLength) >=
                attr_rec->Form.Resident.ValueOffset &&
                attr_rec->Form.Resident.ValueLength >= sizeof(VOLUME_INFORMATION) &&
                ((PCHAR)attr_rec + attr_rec->RecordLength) <= attr_rec_end) {

                vol_info = (PVOLUME_INFORMATION)
                           ((PCHAR)attr_rec + attr_rec->Form.Resident.ValueOffset);
                if ((ULONG_PTR)vol_info != DwordAlign((ULONG_PTR)vol_info))
                    return FALSE;
                *Major = vol_info->MajorVersion;
                *Minor = vol_info->MinorVersion;
                if (!(
                      (*Major != 1 || (*Minor != 0 && *Minor != 1 && *Minor != 2)) &&
                      (*Major != 2 || (*Minor != 0)) &&
                      (*Major != 3 || (*Minor != 0))
                     ))
                    return TRUE;
            }
        }

        if (start_sector != alternate_sector) {
            start_sector = alternate_sector;
            continue;
        } else
            break;
    }

    return FALSE;
}

#if !defined( _SETUP_LOADER_ )

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryFileSystemName(
    IN  PCWSTRING    NtDriveName,
    OUT PWSTRING     FileSystemName,
    OUT PNTSTATUS    ErrorCode,
    OUT PWSTRING     FileSystemNameAndVersion
    )
/*++

Routine Description:

    This routine computes the file system name for the drive specified.

Arguments:

    NtDriveName     - Supplies an NT style drive name.
    FileSystemName  - Returns the file system name for the drive.
    ErrorCode       - Receives an error code (if the method fails).
                        Note that this may be NULL, in which case the
                        exact error is not reported.
    FileSystemNameAndVersion
                    - Returns the file system name and version for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LOG_IO_DP_DRIVE drive;
    HMEM            bootsec_hmem;
    SECRUN          bootsec;
    HMEM            super_hmem;
    SECRUN          super_secrun;
    HMEM            spare_hmem;
    SECRUN          spare;
    BOOLEAN         could_be_fat;
    BOOLEAN         could_be_hpfs;
    BOOLEAN         could_be_ntfs;
    BOOLEAN         could_be_ofs;
    ULONG           num_boot_sectors;
    BOOLEAN         first_read_failed = FALSE;
    UCHAR           major, minor;
    DSTRING         fs_name_version;

    if (ErrorCode) {
        *ErrorCode = 0;
    }
    if (FileSystemNameAndVersion == NULL)
        FileSystemNameAndVersion = &fs_name_version;

    if (!drive.Initialize(NtDriveName)) {
        if (ErrorCode) {
            *ErrorCode = drive.QueryLastNtStatus();
        }
        return FALSE;
    }

    could_be_fat = could_be_hpfs = could_be_ntfs = could_be_ofs = TRUE;


    if (drive.QueryMediaType() == Unknown) {
        return FileSystemName->Initialize("RAW") &&
               FileSystemNameAndVersion->Initialize("RAW");
    }

    num_boot_sectors = max(1, BYTES_PER_BOOT_SECTOR/drive.QuerySectorSize());

    if (!bootsec_hmem.Initialize() ||
        !bootsec.Initialize(&bootsec_hmem, &drive, 0, num_boot_sectors)) {

        return FileSystemName->Initialize("RAW") &&
               FileSystemNameAndVersion->Initialize("RAW");
    }

    if (!bootsec.Read()) {

        could_be_fat = could_be_hpfs = FALSE;
        first_read_failed = TRUE;

        bootsec.Relocate(drive.QuerySectors());

        if (!bootsec.Read()) {

            bootsec.Relocate(drive.QuerySectors()/2);

            if (!bootsec.Read()) {

                could_be_ntfs = FALSE;
            }
        }
    }

    if (could_be_ntfs &&
        IsThisNtfs(drive.QuerySectors(),
                   drive.QuerySectorSize(),
                   (PPACKED_BOOT_SECTOR) bootsec.GetBuf())) {
        if (QueryNtfsVersion(&major,
                             &minor,
                             &drive,
                             (PPACKED_BOOT_SECTOR) bootsec.GetBuf())) {
            if (major >= 2) {
                return FileSystemName->Initialize("NTFS") &&
                       FileSystemNameAndVersion->Initialize("NTFS 5.0");
            } else {
                return FileSystemName->Initialize("NTFS") &&
                       FileSystemNameAndVersion->Initialize("NTFS 4.0");
            }
        } else {
            return FileSystemName->Initialize("NTFS") &&
                   FileSystemNameAndVersion->Initialize("NTFS");
        }
    }

    if (first_read_failed) {

        bootsec.Relocate(BOOTBLKSECTORS);

        if (!bootsec.Read()) {
            could_be_ofs = FALSE;
        }
    }

    // Check if it is ofs

    if (could_be_ofs &&
        IsThisOfs(&drive, (DSKPACKEDBOOTSECT *) bootsec.GetBuf())) {

        return FileSystemName->Initialize("OFS") &&
               FileSystemNameAndVersion->Initialize("OFS");
    }

    if (could_be_hpfs) {
        if (!super_hmem.Initialize() ||
            !super_secrun.Initialize(&super_hmem, &drive,
                              16*num_boot_sectors, num_boot_sectors) ||
            !super_secrun.Read() ||
            !spare_hmem.Initialize() ||
            !spare.Initialize(&spare_hmem, &drive,
                              17*num_boot_sectors, num_boot_sectors) ||
            !spare.Read()) {

            could_be_hpfs = FALSE;
        }
    }

    if (could_be_hpfs &&
        IsThisHpfs(drive.QuerySectors(),
                   (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf(),
                   (PULONG) super_secrun.GetBuf(),
                   (PULONG) spare.GetBuf())) {

        return FileSystemName->Initialize("HPFS") &&
               FileSystemNameAndVersion->Initialize("HPFS");
    }

    if (could_be_fat) {
        //
        //  Check if we have an OS/2 Boot Manager partition and treat is as an
        //  Unknown file system.  We check the partition type in from the
        //  partition table and we ensure that it has less than 0x80 sectors.
        //
        //  The OS/2 Boot Manager partition boot sector mimics a FAT12 partition
        //  but does not adhere to the FAT12 file system.  For example, the
        //  boot sector indicates it has 2 FATs but only really has one.  The
        //  boot manager code overlays the second FAT.  Because of this we want
        //  to ingore partitions of this type.
        //
        if (drive.QueryPartitionType() == SYSID_OS2BOOTMGR) {

             PPACKED_BIOS_PARAMETER_BLOCK  Pbpb;
             USHORT                        Sectors;

             Pbpb = &(((PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf())->Bpb);
             CopyUchar2( &Sectors, Pbpb->Sectors);
             if (( Sectors != 0 ) &&
                 ( Sectors < 0x80 )) {
                DebugPrintTrace(( "IFSUTIL: OS/2 Boot Manager partition detected, Unknown file system. \n" ));
                return FileSystemName->Initialize("OS/2 Boot Manager") &&
                       FileSystemNameAndVersion->Initialize("OS/2 Boot Manager");
             }
        }
    }

    if (could_be_fat &&
        IsThisFat(drive.QuerySectors(),
                  (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf())) {

        return FileSystemName->Initialize("FAT") &&
               FileSystemNameAndVersion->Initialize("FAT");
    }

    if (could_be_fat &&
        IsThisFat32(drive.QuerySectors(),
                  (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf())) {

        return FileSystemName->Initialize("FAT32") &&
               FileSystemNameAndVersion->Initialize("FAT32");
    }

    return FileSystemName->Initialize("RAW") &&
           FileSystemNameAndVersion->Initialize("RAW");
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::DosDriveNameToNtDriveName(
    IN  PCWSTRING    DosDriveName,
    OUT PWSTRING            NtDriveName
    )
/*++

Routine Description:

    This routine converts a dos style drive name to an NT style drive
    name.

Arguments:

    DosDriveName    - Supplies the dos style drive name.
    NtDriveName     - Supplies the nt style drive name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNICODE_STRING  string;
    WSTR            buffer[80];
    CHNUM           l;
    PWSTR           Wstr;
    BOOLEAN         result;

    Wstr = DosDriveName->QueryWSTR(0, TO_END, buffer, 80);

    if (!Wstr) {
        return FALSE;
    }

    l = DosDriveName->QueryChCount() + 1;

    buffer[l - 1] = '\\';
    buffer[l] = 0;

    if (!RtlDosPathNameToNtPathName_U(buffer, &string, NULL, NULL)) {
        return FALSE;
    }

    string.Buffer[string.Length/sizeof(WSTR) - 1] = 0;

    result = NtDriveName->Initialize(string.Buffer);

    RtlFreeUnicodeString(&string);

    return result;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::NtDriveNameToDosDriveName(
    IN  PCWSTRING    NtDriveName,
    OUT PWSTRING     DosDriveName
    )
/*++

Routine Description:

    This routine converts an NT style drive name to a DOS style drive
    name.

Arguments:

    NtDriveName     - Supplies the nt style drive name.
    DosDriveName    - Receives the dos style drive name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING     nt_name_prefix;
    DSTRING     guid_volname_prefix;

    if (!nt_name_prefix.Initialize(NT_NAME_PREFIX) ||
        !guid_volname_prefix.Initialize(GUID_VOLNAME_PREFIX)) {
        DebugPrint("Out of memory.\n");
        return FALSE;
    }

    if (NtDriveName->Stricmp(&nt_name_prefix,
                             0,
                             nt_name_prefix.QueryChCount()) != 0)
        return FALSE;   // does not recognize name at all

    if (NtDriveName->Stricmp(&guid_volname_prefix,
                             nt_name_prefix.QueryChCount(),
                             guid_volname_prefix.QueryChCount()) == 0) {
        if (!DosDriveName->Initialize(DOS_GUIDNAME_PREFIX) ||
            !DosDriveName->InsertString(DosDriveName->QueryChCount(),
                                        NtDriveName,
                                        nt_name_prefix.QueryChCount())) {
            DebugPrint("Out of memory.\n");
            return FALSE;
        }
        return TRUE;
    } else if (NtDriveName->QueryChCount() == (nt_name_prefix.QueryChCount() + 2) &&
               NtDriveName->QueryChAt(nt_name_prefix.QueryChCount()+1) == (WCHAR)':') {
        if (!DosDriveName->Initialize() ||
            !DosDriveName->InsertString(0,
                                        NtDriveName,
                                        nt_name_prefix.QueryChCount())) {
            DebugPrint("Out of memory.\n");
            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

VOID
IFS_SYSTEM::Reboot (
    IN BOOLEAN PowerOff
    )
/*++

Routine Description:

    Reboots the machine

Arguments:

    PowerOff -- if TRUE, we will ask the system to shut down and
                power off.

Return Value:

    Only returns in case of error.

--*/
{

#if defined ( _AUTOCHECK_ )

    CONST PrivilegeBufferSize = 32;
    CHAR PrivilegeBuffer[PrivilegeBufferSize];
    NTSTATUS Status;
    HANDLE TokenHandle;

    PTOKEN_PRIVILEGES TokenPrivileges = (PTOKEN_PRIVILEGES)PrivilegeBuffer;

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_ADJUST_PRIVILEGES,
                                 &TokenHandle );

    if( !NT_SUCCESS( Status ) ) {

        return;
    }

    memset( TokenPrivileges, 0, PrivilegeBufferSize );

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = RtlConvertUlongToLuid( SE_SHUTDOWN_PRIVILEGE );
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    Status = NtAdjustPrivilegesToken( TokenHandle,
                                      FALSE,
                                      TokenPrivileges,
                                      0,
                                      NULL,
                                      NULL );

    if( !NT_SUCCESS( Status ) ) {

        NtClose( TokenHandle );
        return;
    }

    Status = NtShutdownSystem( PowerOff ? ShutdownPowerOff: ShutdownReboot );

    if( !NT_SUCCESS( Status ) ) {

        NtClose( TokenHandle );
        return;
    }

#endif

}

IFSUTIL_EXPORT
PCANNED_SECURITY
IFS_SYSTEM::GetCannedSecurity(
    )
/*++

Routine Description:

    This method fetches the canned security object.

Arguments:

    None.

Return Value:

    A pointer to the canned security object; NULL to indicate
    failure.

--*/
{
    STATIC LONG     InitializingCannedSecurity = 0;
    STATIC          Initialized = FALSE;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingCannedSecurity, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

    if( !Initialized ) {

        // The canned security information has not yet been
        // generated; allocate and initialize a canned security
        // object.  Note that if initialization fails, DELETE
        // will set _CannedSecurity back to NULL.
        //
        _CannedSecurity = NEW CANNED_SECURITY;

        if( _CannedSecurity == NULL ||
            !_CannedSecurity->Initialize() ) {

            DebugPrint( "IFSUTIL: cannot initialize canned security.\n" );
            DELETE( _CannedSecurity );
        }

        Initialized = TRUE;
    }

    status = InterlockedDecrement(&InitializingCannedSecurity);
    DebugAssert(status == 0);

    return _CannedSecurity;
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryFreeDiskSpace(
    IN  PCWSTRING   DosDriveName,
    OUT PBIG_INT    BytesFree
    )
/*++

Routine Description:

    Returns the amount of free space in a volume (in bytes).

Arguments:

    DosDrivename    -   Supplies the DOS name  of the drive
    BytesFree       -   Supplies the BIG_INT in which the result
                        is returned.

Return Value:

    BOOLEAN -   TRUE if the amount of free space was obtained.

--*/
{
    BOOLEAN Ok = FALSE;

#if !defined( _AUTOCHECK_ )

    WCHAR   Buffer[MAX_PATH];
    LPWSTR  Drive;
    BIG_INT TmpBigInt;

    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD NumberOfFreeClusters;
    DWORD TotalNumberOfClusters;

    DebugPtrAssert( DosDriveName );

    Drive = DosDriveName->QueryWSTR( 0, TO_END, Buffer, MAX_PATH );

    if ( Drive ) {

        if ( GetDiskFreeSpace( Drive,
                               &SectorsPerCluster,
                               &BytesPerSector,
                               &NumberOfFreeClusters,
                               &TotalNumberOfClusters
                               ) ) {

            // Use a temporary big_int so that the following happens in
            // large integer arithmetic.

            TmpBigInt = BytesPerSector;
            *BytesFree = TmpBigInt * SectorsPerCluster * NumberOfFreeClusters;

            Ok = TRUE;
        }
    }

#endif

    return Ok;
}


BOOLEAN
QueryDriverName(
    IN  PCWSTRING    FileSystemName,
    OUT PWSTRING            DriverName
    )
/*++

Routine Description:

    This routine computes the driver name corresponding to the
    given file system name.

Arguments:

    FileSystemName  - Supplies the name of the file system.
    DriverName      - Returns the name of the corresponding driver.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING fat_name, hpfs_name;

    if (!fat_name.Initialize("FAT") || !hpfs_name.Initialize("HPFS")) {
        return FALSE;
    }

    if (!FileSystemName->Stricmp(&fat_name)) {
        return DriverName->Initialize("FASTFAT");
    } else if (!FileSystemName->Stricmp(&hpfs_name)) {
        return DriverName->Initialize("PINBALL");
    }

    return DriverName->Initialize(FileSystemName);
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::EnableFileSystem(
    IN  PCWSTRING    FileSystemName
    )
/*++

Routine Description:

    This routine will simply return TRUE because file systems are
    enabled automatically due to a recent IO system change.
    Formerly, this routine used to enable the file system in
    the registry.

Arguments:

    FileSystemName  - Supplies the name of the file system to enable.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNREFERENCED_PARAMETER(FileSystemName);

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsFileSystemEnabled(
    IN  PCWSTRING   FileSystemName,
    OUT PBOOLEAN    Error
    )
/*++

Routine Description:

    This routine will always return TRUE now that the IO
    system will automatically load file systems when needed.
    Formerly, this method used to examine the registry
    for this information.

Argument:

    FileSystemName  - Supplies the name of the file system.
    Error           - Returns whether or not an error occurred.

Return Value:

    FALSE   - The file system is not enabled.
    TRUE    - The file system is enabled.

--*/
{
    UNREFERENCED_PARAMETER(FileSystemName);

    if (Error) {
        *Error = FALSE;
    }

    return TRUE;
}


#endif // _SETUP_LOADER_


IFSUTIL_EXPORT
VOID
IFS_SYSTEM::QueryNtfsTime(
    OUT PLARGE_INTEGER NtfsTime
    )
/*++

Routine Description:

    This method returns the current time in NTFS (ie. NT) format.

Arguments

    NtfsTime    --  receives the current time in NTFS format.

Return Value:

    None.

--*/
{
#if !defined( _SETUP_LOADER_ )

    NtQuerySystemTime( NtfsTime );

#else

    TIME_FIELDS TimeFields;

    SpGetTimeFields( &TimeFields );
    RtlTimeFieldsToTime( &TimeFields, NtfsTime );

#endif // _SETUP_LOADER_
}


IFSUTIL_EXPORT
ULONG
IFS_SYSTEM::QueryPageSize(
    )
/*++

Routine Description:

    This method determines the page size of the system.

Arguments:

    None.

Return Value:

    The system page size.  A return value of 0 indicates error.

--*/
{
#if !defined( _SETUP_LOADER_ )

    SYSTEM_BASIC_INFORMATION BasicInfoBuffer;
    NTSTATUS Status;

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &BasicInfoBuffer,
                                       sizeof( BasicInfoBuffer ),
                                       NULL );

    if( !NT_SUCCESS( Status ) ) {

        return 0;

    } else {

        return BasicInfoBuffer.PageSize;
    }

#else

    // The setup loader environment assumes a page size of 4K.
    //
    return 0x1000;

#endif // _SETUP_LOADER_
}


#if !defined( _SETUP_LOADER_ )

CONST   MaxNtNameLength = MAX_PATH;

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryCanonicalNtDriveName(
    IN  PCWSTRING   NtDriveName,
    OUT PWSTRING    CanonicalNtDriveName
    )
/*++

Routine Description:

    This routine follows the given NT drive name through all
    of the links until it hits the end of the link chain.
    The element at the end of the chain is the "canonical"
    form.

Arguments:

    NtDriveName             - Supplies the NT drive name to canonicalize.
    CanonicalNtDriveName    - Returns the canoncal form of the given drive
                                name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNICODE_STRING      source, target;
    PUNICODE_STRING     psource, ptarget, tmp;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              handle;
    WSTR                buffer[MaxNtNameLength];

    RtlInitUnicodeString(&source, NtDriveName->GetWSTR());
    psource = &source;
    ptarget = &target;

    for (;;) {

        InitializeObjectAttributes(&oa, psource, OBJ_CASE_INSENSITIVE,
                                   NULL, NULL);

        status = NtOpenSymbolicLinkObject(&handle,
                                          READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                          &oa);

        if (!NT_SUCCESS(status)) {
            ptarget = psource;
            break;
        }

        ptarget->Buffer = buffer;
        ptarget->MaximumLength = MaxNtNameLength*sizeof(WCHAR);
        status = NtQuerySymbolicLinkObject(handle, ptarget, NULL);
        NtClose(handle);

        if (!NT_SUCCESS(status)) {
            ptarget = psource;
            break;
        }

        tmp = psource;
        psource = ptarget;
        ptarget = tmp;
    }

    if (!CanonicalNtDriveName->Initialize(ptarget->Buffer,
                                          ptarget->Length/sizeof(WCHAR))) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
IFS_SYSTEM::QueryNtSystemDriveName(
    OUT PWSTRING    NtSystemDriveName
    )
/*++

Routine Description:

    This routine returns the NT device name for the partition
    which contains the NT system files (ie. ntoskrnl.exe).

Arguments:

    NtSystemDriveName   - Returns the NT drive name for the partition
                          on which ntoskrnl.exe resides.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WSTR            buffer[MaxNtNameLength];
    UNICODE_STRING  source, target;
    FSTRING         dos_name;
    NTSTATUS        status;

    RtlInitUnicodeString(&source, (PWSTR) L"%SystemRoot%");

    target.Buffer = buffer;
    target.MaximumLength = MaxNtNameLength*sizeof(WCHAR);

    status = RtlExpandEnvironmentStrings_U(NULL, &source, &target, NULL);

    if (!NT_SUCCESS(status) ||
        target.Length/sizeof(WCHAR) < 2 ||
        target.Buffer[1] != ':') {

        return FALSE;
    }

    target.Buffer[2] = 0;
    dos_name.Initialize(target.Buffer);

    return DosDriveNameToNtDriveName(&dos_name, NtSystemDriveName);
}

BOOLEAN
IFS_SYSTEM::QuerySystemEnvironmentVariableValue(
    IN  PWSTRING    VariableName,
    IN  ULONG       ValueBufferLength,
    OUT PVOID       ValueBuffer,
    OUT PUSHORT     ValueLength
    )
/*++

Routine Description:

    This method fetches the value of an NT System Variable.  (Note
    that this is a set of variables distinct from the Windows
    environment variables.)

Arguments:

    VariableName
    ValueBufferLength   --  Supplies the length (in bytes) of the
                            buffer supplied to hold the output value.
    ValueBuffer         --  Receives the UNICODE value of the
                            environment variable.
    ValueLength         --  Receives the length (in bytes) of the
                            value.

Return Value:

    TRUE if the method was able to query the value of the specified
    environment variable.

--*/
{
    UNICODE_STRING Name;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    Name.Buffer = (PWSTR)VariableName->GetWSTR();
    Name.Length = (USHORT)VariableName->QueryChCount() * sizeof(WCHAR);
    Name.MaximumLength = Name.Length;

    // Adjust the privileges so we can access system variables:
    //
    Status = RtlAdjustPrivilege( SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                                 TRUE,
                                 FALSE,
                                 &WasEnabled );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: Could not adjust privileges (Status 0x%x).\n", Status ));
        return FALSE;
    }

    Status = NtQuerySystemEnvironmentValue( &Name,
                                            (PWSTR)ValueBuffer,
                                            (USHORT)ValueBufferLength,
                                            ValueLength );

    // Set the privilege back:
    //
    RtlAdjustPrivilege( SE_SYSTEM_PROFILE_PRIVILEGE,
                        WasEnabled,
                        FALSE,
                        &WasEnabled );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: Couldn't query system variable--status 0x%x\n", Status ));
        return FALSE;

    } else {

        return TRUE;
    }
}



IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsArcSystemPartition(
    IN  PCWSTRING   NtDriveName,
    OUT PBOOLEAN    Error
    )
/*++

Routine Description:

    This routine determines whether the specified drive
    appears in the list of System Partitions in the ARC
    boot selections.

Arguments:

    NtDriveName --  Supplies the name
    Error       --  Receives TRUE if the method encountered an
                    error.

Return Value:

    TRUE if the specified volume is a System Partition for a
    system boot selection.

Notes:

    The System Partitions is the volume from which the system
    loads OSLOADER.EXE and HAL.DLL.  The system partitions
    for the various boot selections are listed in the system
    environment variable SYSTEMPARTITION.  The value of this
    variable is a list of ARC names delimited by semicolons.

--*/
{
#if defined( i386 )

    *Error = FALSE;
    return FALSE;

#else

    CONST ULONG ValueBufferSize = 512;
    BYTE SystemPartitionValue[ValueBufferSize];
    DSTRING SearchName, CurrentNameString, CurrentCanonicalName, VariableName,
            ZeroString, ArcPrefixString;
    PWSTR CurrentName, CurrentChar;
    ULONG RemainingLength, CurrentNameLength, i;
    USHORT ValueLength = 0;

    DebugPtrAssert( NtDriveName );
    DebugPtrAssert( Error );

    // Assume innocent until...
    //
    *Error = FALSE;

    // Initialize the helper strings:
    //
    if( !ZeroString.Initialize( "0" ) ||
        !ArcPrefixString.Initialize( "\\ArcName\\" ) ) {

        *Error = TRUE;
        return FALSE;
    }

    // Canonicalize the search name:
    //
    if( !QueryCanonicalNtDriveName( NtDriveName, &SearchName ) ) {

        *Error = TRUE;
        return FALSE;
    }

    // Fetch the value of the system environment variable
    // SystemPartition.
    //
    if( !VariableName.Initialize( "SystemPartition" ) ||
        !QuerySystemEnvironmentVariableValue( &VariableName,
                                              ValueBufferSize,
                                              SystemPartitionValue,
                                              &ValueLength ) ) {

        *Error = TRUE;
        return FALSE;
    }

    // Step through the list of partition names in the
    // value of the SystemPartition variable.  For each
    // partition name, canonicalize it and compare it to
    // the search name.
    //
    RemainingLength = ValueLength/sizeof(WCHAR);
    CurrentChar = (PWSTR)SystemPartitionValue;

    while( RemainingLength ) {

        // Determine the length of the current name:
        //
        CurrentName = CurrentChar;
        CurrentNameLength = 0;

        while( RemainingLength && *CurrentChar != ';' ) {

            CurrentNameLength++;
            RemainingLength--;
            CurrentChar++;
        }

        if( CurrentNameLength != 0 ) {

            // Initialize a DSTRING for the current name
            // and canonicalize it for comparison with the
            // (canonicalized) search name.
            //
            if( !CurrentNameString.Initialize( CurrentName,
                                               CurrentNameLength ) ) {

                *Error = TRUE;
                return FALSE;
            }

            // Now normalize the current ARC name--prepend it
            // with \ArcName\ and replace any occurrence of
            // "()" with "(0)".
            //
            if( !CurrentNameString.InsertString( 0, &ArcPrefixString ) ) {

                *Error = TRUE;
                return FALSE;
            }

            // Find the first occurrence of '(':
            //
            i = CurrentNameString.Strchr( '(', 0 );

            while( i != INVALID_CHNUM ) {

                i++;

                if( CurrentNameString.QueryChAt( i ) == ')' &&
                    !CurrentNameString.InsertString( i, &ZeroString ) ) {

                    *Error = TRUE;
                    return FALSE;
                }

                // Find the next occurrence of '(':
                //
                i = CurrentNameString.Strchr( '(', i );
            }

            // CurrentNameString is now a symbolic link to an ARC
            // System Partition.  Canonicalize this name in the
            // NT name space and compare it to the (previously
            // canonicalized) search name.
            //
            if( !QueryCanonicalNtDriveName( &CurrentNameString,
                                            &CurrentCanonicalName ) ) {

                *Error = TRUE;
                return FALSE;
            }

            if( SearchName.Stricmp( &CurrentCanonicalName ) == 0 ) {

                // Found a match--the search name is an ARC System
                // Partition.
                //
                return TRUE;
            }

        }

        // If RemainingLength is non-zero, then CurrentChar is
        // pointing at a semicolon delimiter.  Step over it
        // to the next name.
        //
        if( RemainingLength ) {

            RemainingLength--;
            CurrentChar++;
        }
    }

    // No match was found--this name is not an ARC System Partition.
    //
    return FALSE;
#endif  // i386
}


BOOLEAN
IFS_SYSTEM::FileSetAttributes(
    IN  HANDLE  FileHandle,
    IN  ULONG   NewAttributes,
    OUT PULONG  OldAttributes
    )
/*++

Routine Description:

    This method changes the attributes (read-only, system, hidden,
    archive) on a file.

Arguments:

    FileHandle      --  Supplies the handle of the target file.
    NewAttributes   --  Supplies the new attributes for the file.
    OldAttributes   --  Receives the existing file attributes.

Return Value:

    TRUE upon successful completion.

--*/
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    Status = NtQueryInformationFile( FileHandle,
                                     &IoStatusBlock,
                                     &BasicInfo,
                                     sizeof(BasicInfo),
                                     FileBasicInformation
                                     );

    if( !NT_SUCCESS( Status ) ) {

        return FALSE;
    }

    *OldAttributes = BasicInfo.FileAttributes;

    BasicInfo.FileAttributes = NewAttributes;

    Status = NtSetInformationFile( FileHandle,
                                   &IoStatusBlock,
                                   &BasicInfo,
                                   sizeof(BasicInfo),
                                   FileBasicInformation
                                   );

    return( NT_SUCCESS( Status ) );
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::FileSetAttributes(
    IN  PCWSTRING FileName,
    IN  ULONG     NewAttributes,
    OUT PULONG    OldAttributes
    )
/*++

Routine Description:

    This method changes the attributes (read-only, system, hidden,
    archive) on a file.

Arguments:

    FileName        --  Supplies the name of the target file.
    NewAttributes   --  Supplies the new attributes for the file.
    OldAttributes   --  Receives the existing file attributes.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING string;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN Result;

    string.Buffer = (PWSTR)FileName->GetWSTR();
    string.Length = (USHORT)FileName->QueryChCount() * sizeof( WCHAR );
    string.MaximumLength = string.Length;

    InitializeObjectAttributes(
        &Obja,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if( !NT_SUCCESS( Status ) )  {

        return FALSE;
    }

    Result = FileSetAttributes( Handle, NewAttributes, OldAttributes );

    NtClose( Handle );

    return Result;
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::WriteToFile(
    IN  PCWSTRING   QualifiedFileName,
    IN  PVOID       Data,
    IN  ULONG       DataLength,
    IN  BOOLEAN     Append
    )
/*++

Routine Description:

    This method appends the given data to the specified file
    using the NT-native file-system API.  If the file does not
    exist, it is created.

Arguments:

    QualifiedFileName   --  Supplies the fully-qualified file name.
    Data                --  Supplies the data to be written to the file.
    DataLength          --  Supplies the length of data in bytes.
    Append              --  Supplies a flag indicating that new data
                            should be appended to the file, rather than
                            overwriting it.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING string;
    IO_STATUS_BLOCK StatusBlock;
    LARGE_INTEGER FileOffset;

    if( Append && DataLength == 0 ) {

        return TRUE;
    }

    string.Buffer = (PWSTR)QualifiedFileName->GetWSTR();
    string.Length = (USHORT)QualifiedFileName->QueryChCount() * sizeof( WCHAR );
    string.MaximumLength = string.Length;

    InitializeObjectAttributes(
        &Obja,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    // If we're appending to the file, open; if that fails, create
    // it.  If we're not appending, just create it.
    //
    if( Append ) {

        Status = NtOpenFile(
                    &Handle,
                    FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                    &Obja,
                    &StatusBlock,
                    FILE_SHARE_READ,
                    0
                    );
    }

    if( !Append ||
        Status == STATUS_NO_SUCH_FILE ||
        Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        Status = NtCreateFile( &Handle,
                               FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                               &Obja,
                               &StatusBlock,
                               NULL,        // No pre-allocation
                               FILE_ATTRIBUTE_NORMAL,
                               0,           // No sharing.
                               FILE_OVERWRITE_IF,
                               FILE_NON_DIRECTORY_FILE,
                               NULL,        // No EA's
                               0 );
    }

    if( !NT_SUCCESS( Status ) )  {

        // Can't open or create the file.
        //
        DebugPrintTrace(( "IFSUTIL: Error opening/creating file--status 0x%x\n", Status ));
        return FALSE;
    }

    FileOffset = RtlConvertLongToLargeInteger( FILE_WRITE_TO_END_OF_FILE );

    Status = NtWriteFile( Handle,
                          0, NULL, NULL,
                          &StatusBlock,
                          Data,
                          DataLength,
                          &FileOffset,
                          NULL );

    NtClose( Handle );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: NtWriteFile failed with status 0x%s\n", Status ));
        return FALSE;

    } else {

        return TRUE;
    }
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::EnableVolumeCompression(
    IN  PCWSTRING   NtDriveName
    )
/*++

Routine Description:

    This routine sets the bit on the root directory of the given
    volume so that files added to the volume will be compressed.

Arguments:

    NtDriveName     -- the name of the volume


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              Handle;
    UNICODE_STRING      string;
    IO_STATUS_BLOCK     IoStatusBlock;
    USHORT              State = 1;
    DSTRING             FileName;
    DSTRING             backslash;

    if (!backslash.Initialize("\\") ||
        !FileName.Initialize(NtDriveName) ||
        !FileName.Strcat(&backslash)) {
        return FALSE;
    }

    string.Buffer = (PWSTR)FileName.GetWSTR();
    string.Length = (USHORT)FileName.QueryChCount() * sizeof( WCHAR );
    string.MaximumLength = string.Length;

    InitializeObjectAttributes(
        &Obja,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtFsControlFile(
                Handle,
                NULL,                       /* Event */
                NULL,                       /* ApcRoutine */
                NULL,                       /* ApcContext */
                &IoStatusBlock,
                FSCTL_SET_COMPRESSION,
                (PVOID)&State,              /* InputBuffer */
                sizeof(State),              /* InputBufferLength */
                NULL,                       /* OutputBuffer */
                0                           /* OutputBufferLength */
                );

    NtClose(Handle);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::EnableVolumeUpgrade(
    IN  PCWSTRING   NtDriveName
    )
/*++

Routine Description:

    This routine sets the bit on the root directory of the given
    volume so that files added to the volume will be compressed.

Arguments:

    NtDriveName     -- the name of the volume


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::DismountVolume(
    IN  PCWSTRING   NtDriveName
    )
/*++

Routine Description:

    This routine dismounts the given volume.

Arguments:

    NtDriveName     -- the name of the volume


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              Handle;
    UNICODE_STRING      string;
    IO_STATUS_BLOCK     IoStatusBlock;
    DSTRING             FileName;

    if (!FileName.Initialize(NtDriveName))
        return FALSE;

    string.Buffer = (PWSTR)FileName.GetWSTR();
    string.Length = (USHORT)FileName.QueryChCount() * sizeof( WCHAR );
    string.MaximumLength = string.Length + sizeof(WCHAR);   // null char too

    InitializeObjectAttributes(
        &Obja,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT
                );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtFsControlFile(
                Handle,
                NULL,                       /* Event */
                NULL,                       /* ApcRoutine */
                NULL,                       /* ApcContext */
                &IoStatusBlock,
                FSCTL_DISMOUNT_VOLUME,
                NULL,                       /* InputBuffer */
                0,                          /* InputBufferLength */
                NULL,                       /* OutputBuffer */
                0                           /* OutputBufferLength */
                );

    NtClose(Handle);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::CheckValidSecurityDescriptor(
    IN ULONG Length,
    IN PISECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    Validates a security descriptor for structural correctness.

Arguments:

    Length - Length in bytes of passed Security Descriptor.

    SecurityDescriptor - Points to the Security Descriptor (in kernel memory) to be
        validatated.

Return Value:

    TRUE - The passed security descriptor is correctly structured
    FALSE - The passed security descriptor is badly formed

--*/
{
    return RtlValidRelativeSecurityDescriptor(SecurityDescriptor, Length, 0);
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsVolumeDirty(
    IN  PWSTRING    NtDriveName,
    OUT PBOOLEAN    Result
    )
/*++

Routine Description:

    This routine opens the given nt drive and sends down
    FSCTL_IS_VOLUME_DIRTY to determine the state of that volume's
    dirty bit.

Arguments:

    NtDriveName     -- supplies the volume in question
    Result          -- returns the state of the dirty bit

Return Value:

    FALSE           -- the dirty bit could not be queried
    TRUE            -- success

--*/
{
    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   obj;
    NTSTATUS            status;
    IO_STATUS_BLOCK     iosb;
    HANDLE              h;
    ULONG               r;


    u.Length = (USHORT)NtDriveName->QueryChCount() * sizeof(WCHAR);
    u.MaximumLength = u.Length;
    u.Buffer = (PWSTR)NtDriveName->GetWSTR();

    InitializeObjectAttributes(&obj, &u, OBJ_CASE_INSENSITIVE, 0, 0);

    status = NtOpenFile(&h,
                        FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &obj,
                        &iosb,
                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(status)) {

        return FALSE;
    }

    status = NtFsControlFile(h, NULL, NULL, NULL,
                             &iosb,
                             FSCTL_IS_VOLUME_DIRTY,
                             NULL, 0,
                             &r, sizeof(r));

    if (!NT_SUCCESS(status)) {
        NtClose(h);
        return FALSE;
    }

#if(_WIN32_WINNT >= 0x0500)
    *Result = (BOOLEAN)(r & VOLUME_IS_DIRTY);
#else
    *Result = (BOOLEAN)r;
#endif
    NtClose(h);

    return TRUE;
}

#endif // _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\numset.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "numset.hxx"
#include "iterator.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NUMBER_SET, OBJECT, IFSUTIL_EXPORT );

DEFINE_CONSTRUCTOR( NUMBER_EXTENT, OBJECT );

VOID
NUMBER_SET::Construct (
        )
/*++

Routine Description:

    Constructor for NUMBER_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _card = 0;
    _iterator = NULL;
}


VOID
NUMBER_SET::Destroy(
    )
/*++

Routine Description:

    This routine returns the NUMBER_SET to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _list.DeleteAllMembers();
    _card = 0;
    DELETE(_iterator);
}


IFSUTIL_EXPORT
NUMBER_SET::~NUMBER_SET(
    )
/*++

Routine Description:

    Destructor for NUMBER_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Initialize(
    )
/*++

Routine Description:

    This routine initializes the stack for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!_list.Initialize() ||
        !(_iterator = _list.QueryIterator())) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number  - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (p) {

        next = p->Start + p->Length;

        if (Number < next) {
            return TRUE;
        }

        if (Number == next) {

            p->Length += 1;
            _card += 1;

            if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {

                if (pn->Start == Number + 1) {

                    p->Length += pn->Length;
                    pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                    DELETE(pn);
                }
            }

            return TRUE;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        if (Number + 1 == p->Start) {

            p->Start = Number;
            p->Length += 1;
            _card += 1;
            return TRUE;
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::AddStart(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.  Call this routine once before calling 
    AddNext.

    NOTE: Do not insert other calls of this class in between AddStart and AddNext.

Arguments:

    Number    - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    _iterator->Reset();
    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    while (p != NULL) {
        if (p->Start <= Number) {
            next = p->Start + p->Length;

            // if within range, then done
            if (Number < next)
                return TRUE;

            // if passed the range by 1, try to expand the range to include it
            if (Number == next) {
                p->Length += 1;
                _card += 1;
                // see if the next range can be merged with the expanded range
                if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {
                   if (pn->Start == Number + 1) {
                       p->Length += pn->Length;
                       pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                       DELETE(pn);
                   }
                }
                p = (PNUMBER_EXTENT)_iterator->GetPrevious();
                return TRUE;
            }

            // if less than the next range by 1, try to expand the range to
            // include it.  There won't be a merge as there must be more than
            // one hole in between the two ranges
            if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
                if (p->Start <= Number)
                    continue;
                if ((Number+1) == p->Start) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
            }
            break;
        } else {
            // search backwards
            p = (PNUMBER_EXTENT) _iterator->GetPrevious();
            if (p == NULL) {
                p = (PNUMBER_EXTENT) _iterator->GetNext();
                DebugAssert(p);
                if (p && ((Number+1) == p->Start)) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
                break;
            }
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::AddNext(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.  Call this routine after calling
    AddStart once.  This routine differs from Add ni the sense that it searches
    through each of the subset from where it last added instead of starting
    backwards like Add does.

    NOTE: Do not insert any other call of this class in between two AddNext calls.

Arguments:

    Number    - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    if (!(p = (PNUMBER_EXTENT) _iterator->GetCurrent())) {
        _iterator->Reset();
        p = (PNUMBER_EXTENT) _iterator->GetPrevious();
    }

    while (p != NULL) {
        if (p->Start <= Number) {
            next = p->Start + p->Length;

            // if within range, then done
            if (Number < next)
                return TRUE;

            // if passed the range by 1, try to expand the range to include it
            if (Number == next) {
                p->Length += 1;
                _card += 1;
                // see if the next range can be merged with the expanded range
                if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {
                   if (pn->Start == Number + 1) {
                       p->Length += pn->Length;
                       pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                       DELETE(pn);
                   }
                }
                p = (PNUMBER_EXTENT)_iterator->GetPrevious();
                return TRUE;
            }

            // if less than the next range by 1, try to expand the range to
            // include it.  There won't be a merge as there must be more than
            // one hole in between the two ranges
            if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
                if (p->Start <= Number)
                    continue;
                if ((Number+1) == p->Start) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
            }
            break;
        } else {
            // search backwards
            p = (PNUMBER_EXTENT) _iterator->GetPrevious();
            if (p == NULL) {
                p = (PNUMBER_EXTENT) _iterator->GetNext();
                DebugAssert(p);
                if (p && ((Number+1) == p->Start)) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
                break;
            }
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    )
/*++

Routine Description:

    This routine adds the range of numbers to the set.

Arguments:

    Start   - Supplies the first number to add to the set.
    Length  - Supplies the length of the run to add.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT i, sup;
    BOOLEAN r;

    sup = Start + Length;

    r = TRUE;
    for (i = Start; i < sup; i += 1) {
        r = Add(i) && r;
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  PCNUMBER_SET    NumberSet
    )
/*++

Routine Description:

    This routine adds all of the elements in the given number set to
    this one.

Arguments:

    NumberSet   - Supplies the numbers to add.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, n;
    BIG_INT s, l;

    n = NumberSet->QueryNumDisjointRanges();

    for (i = 0; i < n; i++) {

        NumberSet->QueryDisjointRange(i, &s, &l);

        if (!Add(s, l)) {
            return FALSE;
        }
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::CheckAndAdd(
    IN  BIG_INT   Number,
    OUT PBOOLEAN  Duplicate
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number  - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);
    DebugAssert(Duplicate);

    *Duplicate = FALSE;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (p) {

        next = p->Start + p->Length;

        if (Number < next) {
            *Duplicate = TRUE;
            return TRUE;
        }

        if (Number == next) {

            p->Length += 1;
            _card += 1;

            if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {

                if (pn->Start == Number + 1) {

                    p->Length += pn->Length;
                    pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                    DELETE(pn);
                }
            }

            return TRUE;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        if (Number + 1 == p->Start) {

            p->Start = Number;
            p->Length += 1;
            _card += 1;
            return TRUE;
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  BIG_INT     Number
    )
/*++

Routine Description:

    This routine removes a number from the number set.

Arguments:

    Number  - Supplies the number to remove.

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next, new_length;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
        if (p->Start > Number) {
            break;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {

        next = p->Start + p->Length;

        if (p->Start == Number) {
            p->Start += 1;
            p->Length -= 1;
            _card -= 1;

            if (p->Length == 0) {
                p = (PNUMBER_EXTENT) _list.Remove(_iterator);
                DELETE(p);
            }

            return TRUE;
        }

        if (Number + 1 == next) {
            p->Length -= 1;
            _card -= 1;
            return TRUE;
        }

        if (Number < next) {

            if (!(new_extent = NEW NUMBER_EXTENT)) {
                return FALSE;
            }

            _iterator->GetNext();

            if (!_list.Insert(new_extent, _iterator)) {
                DELETE(new_extent);
                return FALSE;
            }

            new_length = Number - p->Start;

            new_extent->Start = Number + 1;
            new_extent->Length = p->Length - 1 - new_length;

            p->Length = new_length;

            _card -= 1;
        }
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::RemoveAll(
     )
{
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    if ((p = (PNUMBER_EXTENT) _iterator->GetNext())) 
        do {
            p = (PNUMBER_EXTENT) _list.Remove(_iterator);
            DELETE(p);
        } while ((p=(PNUMBER_EXTENT)_iterator->GetCurrent()));
    _card = 0;
    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::CheckAndRemove(
    IN  BIG_INT     Number,
     OUT PBOOLEAN   DoesExists
    )
/*++

Routine Description:

    This routine removes a number from the number set.

Arguments:

    Number      - Supplies the number to remove.
     DoesExists - TRUE if Number was found in the set

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next, new_length;

    DebugAssert(_iterator);
    DebugAssert(DoesExists);

    *DoesExists = FALSE;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
        if (p->Start > Number) {
            break;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {

        next = p->Start + p->Length;

        if (p->Start == Number) {
            p->Start += 1;
            p->Length -= 1;
            _card -= 1;
            *DoesExists = TRUE;

            if (p->Length == 0) {
                p = (PNUMBER_EXTENT) _list.Remove(_iterator);
                DELETE(p);
            }

            return TRUE;
        }

        if (Number + 1 == next) {
            p->Length -= 1;
            _card -= 1;
            *DoesExists = TRUE;
            return TRUE;
        }

        if (Number < next) {

            if (!(new_extent = NEW NUMBER_EXTENT)) {
                return FALSE;
            }

            _iterator->GetNext();

            if (!_list.Insert(new_extent, _iterator)) {
                DELETE(new_extent);
                return FALSE;
            }

            new_length = Number - p->Start;

            new_extent->Start = Number + 1;
            new_extent->Length = p->Length - 1 - new_length;

            p->Length = new_length;

            _card -= 1;
            *DoesExists = TRUE;
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    )
/*++

Routine Description:

    This routine removes the given range from the number set.

Arguments:

    Start   - Supplies the beginning of the range.
    Length  - Supplies the length of the range.

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT i, sup;
    BOOLEAN r;

    sup = Start + Length;

    r = TRUE;
    for (i = Start; i < sup; i += 1) {
        r = Remove(i) && r;
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  PCNUMBER_SET    NumberSet
    )
/*++

Routine Description:

    This routine removes all of the elements in the given number set from
    this one.

Arguments:

    NumberSet   - Supplies the numbers to remove.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, n;
    BIG_INT s, l;

    n = NumberSet->QueryNumDisjointRanges();
    for (i = 0; i < n; i++) {

        NumberSet->QueryDisjointRange(i, &s, &l);

        if (!Remove(s, l)) {
            return FALSE;
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BIG_INT
NUMBER_SET::QueryNumber(
    IN  BIG_INT Index
    ) CONST
/*++

Routine Description:

    This routine returns the Nth number contained in this set.

Arguments:

    Index   - Supplies a zero-based index into the ordered set.

Return Value:

    The Nth number in this set.

--*/
{
    PNUMBER_EXTENT  p;
    BIG_INT         r;
    BIG_INT         count;

    DebugAssert(Index < _card);

    _iterator->Reset();
    count = 0;
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        count += p->Length;

        if (count > Index) {
            break;
        }
    }

    DebugAssert(p);

    return p->Start + Index - (count - p->Length);
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::DoesIntersectSet(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    ) CONST
/*++

Routine Description:

    This routine computes whether or not the range specified intersects
    the current number set.  This routine will return FALSE if the
    intersection is empty, TRUE otherwise.

Arguments:

    Start   - Supplies the start of the range.
    Length  - Supplies the length of the range.

Return Value:

    FALSE   - The specified range does not intersect the number set.
    TRUE    - The specified range makes a non-empty intersection with
                the number set.

--*/
{
    PNUMBER_EXTENT  p;
    BIG_INT         pnext, next;

    DebugAssert(_iterator);

    if (Length == 0) {
        return FALSE;
    }

    next = Start + Length;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        pnext = p->Start + p->Length;

        if (Start >= p->Start) {

            if (Start < pnext) {
                return TRUE;
            }
        } else {

            if (next > p->Start) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


IFSUTIL_EXPORT
VOID
NUMBER_SET::QueryDisjointRange(
    IN  ULONG       Index,
    OUT PBIG_INT    Start,
    OUT PBIG_INT    Length
    ) CONST
/*++

Routine Description:

    This routine returns the 'Index'th disjoint range.  (This is zero
    based).

Arguments:

    Index   - Supplies the index of the disjoint range.
    Start   - Returns the start of the disjoint range.
    Length  - Returns the length of the disjoint range.

Return Value:

    None.

--*/
{
    ULONG           i;
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    for (i = 0; i <= Index; i++) {
        p = (PNUMBER_EXTENT) _iterator->GetNext();
    }

    DebugAssert(p);
    DebugAssert(Start);
    DebugAssert(Length);

    *Start = p->Start;
    *Length = p->Length;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::QueryContainingRange(
    IN  BIG_INT     Number,
    OUT PBIG_INT    Start,
    OUT PBIG_INT    Length
    ) CONST
/*++

Routine Description:

    This routine returns the range that contains the given number.

Arguments:

    Number  - Supplies the number.
    Start   - Returns the start of the range.
    Length  - Returns the length of the range.

Return Value:

    FALSE   - The given number was not in the set.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (!p || Number >= p->Start + p->Length) {
        return FALSE;
    }

    *Start = p->Start;
    *Length = p->Length;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\mpmap.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "mpmap.hxx"
#include "arrayit.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( MOUNT_POINT_MAP, OBJECT, IFSUTIL_EXPORT );

DEFINE_EXPORTED_CONSTRUCTOR( MOUNT_POINT_TUPLE, OBJECT, IFSUTIL_EXPORT );

VOID
MOUNT_POINT_MAP::Construct (
        )
/*++

Routine Description:

    Constructor for MOUNT_POINT_MAP.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _parr = NULL;
}


VOID
MOUNT_POINT_MAP::Destroy(
    )
/*++

Routine Description:

    This routine returns the MOUNT_POINT_MAP to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (_parr)
        DELETE(_parr);
}


IFSUTIL_EXPORT
MOUNT_POINT_MAP::~MOUNT_POINT_MAP(
    )
/*++

Routine Description:

    Destructor for MOUNT_POINT_MAP.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::Initialize(
    )
/*++

Routine Description:

    This routine initializes the stack for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _parr = NEW ARRAY;

    if (!_parr || !_parr->Initialize()) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::AddVolumeName(
    IN     PWSTRING     DeviceName,
    IN     PWSTRING     VolumeName
    )
/*++

Routine Description:

    This routine adds a mount point tuple consisting of
    DeviceName and VolumeName pair into the array.
    If the tuple already exists, it just updates it.

Arguments:

    DeviceName  - Supplies the name of the device.
    VolumeName  - Supplies the volume name of the device.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PMOUNT_POINT_TUPLE  mptuple;
    PARRAY_ITERATOR     iter;

    iter = (PARRAY_ITERATOR)_parr->QueryIterator();

    if (iter == NULL)
        return FALSE;

    while (mptuple = (PMOUNT_POINT_TUPLE)iter->GetNext()) {
        if (mptuple->_DeviceName.Stricmp(DeviceName) == 0) {
            DELETE(iter);
            return mptuple->_VolumeName.Initialize(VolumeName);
        }
    }

    DELETE(iter);

    DebugAssert(mptuple == NULL);

    if (mptuple == NULL) {
        mptuple = NEW MOUNT_POINT_TUPLE;
        if (mptuple == NULL) {
            DebugPrint("Out of memory\n");
            return FALSE;
        }
    }

    if (!mptuple->_DeviceName.Initialize(DeviceName) ||
        !mptuple->_VolumeName.Initialize(VolumeName) ||
        !mptuple->_DriveName.Initialize() ||
        !_parr->Put(mptuple)) {
        DELETE(mptuple);
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::AddDriveName(
    IN     PWSTRING     DeviceName,
    IN     PWSTRING     DriveName
    )
/*++

Routine Description:

    This routine adds a mount point tuple consisting of
    DeviceName and DriveName pair into the array.
    If the tuple already exists, it just updates it.

Arguments:

    DeviceName  - Supplies the name of the device.
    DriveName   - Supplies the drive name of the device.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PMOUNT_POINT_TUPLE  mptuple;
    PARRAY_ITERATOR     iter;

    iter = (PARRAY_ITERATOR)_parr->QueryIterator();

    if (iter == NULL)
        return FALSE;

    while (mptuple = (PMOUNT_POINT_TUPLE)iter->GetNext()) {
        if (mptuple->_DeviceName.Stricmp(DeviceName) == 0) {
            DELETE(iter);
            return mptuple->_DriveName.Initialize(DriveName);
        }
    }

    DELETE(iter);

    DebugAssert(mptuple == NULL);

    if (mptuple == NULL) {
        mptuple = NEW MOUNT_POINT_TUPLE;
        if (mptuple == NULL) {
            DebugPrint("Out of memory\n");
            return FALSE;
        }
    }

    if (!mptuple->_DeviceName.Initialize(DeviceName) ||
        !mptuple->_DriveName.Initialize(DriveName) ||
        !mptuple->_VolumeName.Initialize() ||
        !_parr->Put(mptuple)) {
        DELETE(mptuple);
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::QueryVolumeName(
    IN     PWSTRING DriveName,
       OUT PWSTRING VolumeName
    )
/*++

Routine Description:

    This routine retrieves the associated VolumeName given
    the DeviceName.

Arguments:

    DriveName   - Supplies the drive name.
    VolumeName  - Receives the volume name of the device.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PMOUNT_POINT_TUPLE  mptuple;
    PARRAY_ITERATOR     iter;

    iter = (PARRAY_ITERATOR)_parr->QueryIterator();

    if (iter == NULL)
        return FALSE;

    while (mptuple = (PMOUNT_POINT_TUPLE)iter->GetNext()) {
        if (mptuple->_DriveName.Stricmp(DriveName) == 0) {
            DELETE(iter);
            return VolumeName->Initialize(&(mptuple->_VolumeName));
        }
    }

    DELETE(iter);

    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::QueryDriveName(
    IN     PWSTRING VolumeName,
       OUT PWSTRING DriveName
    )
/*++

Routine Description:

    This routine retrieves the associated DriveName given
    the DeviceName.

Arguments:

    VolumeName  - Supplies the volume name.
    DriveName   - Receives the drive name of the device.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PMOUNT_POINT_TUPLE  mptuple;
    PARRAY_ITERATOR     iter;

    iter = (PARRAY_ITERATOR)_parr->QueryIterator();

    if (iter == NULL)
        return FALSE;

    while (mptuple = (PMOUNT_POINT_TUPLE)iter->GetNext()) {
        if (mptuple->_VolumeName.Stricmp(VolumeName) == 0) {
            DELETE(iter);
            return DriveName->Initialize(&(mptuple->_DriveName));
        }
    }

    DELETE(iter);

    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::GetAt(
    IN     ULONG    Index,
       OUT PWSTRING DriveName,
       OUT PWSTRING VolumeName
    )
{
    PMOUNT_POINT_TUPLE  mptuple;

    DebugPtrAssert(DriveName);
    DebugPtrAssert(VolumeName);

    mptuple = (PMOUNT_POINT_TUPLE)_parr->GetAt(Index);

    if (mptuple == NULL)
        return FALSE;

    if (!DriveName->Initialize(&mptuple->_DriveName) ||
        !VolumeName->Initialize(&mptuple->_VolumeName)) {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\mldcopy.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

extern "C" {
#include "ntlsa.h"
#include "md4.h"
}

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "ifssys.hxx"
#include "wstring.hxx"
#include "drive.hxx"
#include "mldcopy.hxx"
#include "rtmsg.h"
#include "supera.hxx"
#include "hmem.hxx"
#include "cmem.hxx"
#include "message.hxx"


#define JIMS_BIG_NUMBER 718315
#define RegPath TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName")
#define RegVal  TEXT("ComputerName")
#define DmfPath TEXT("System\\CurrentControlSet\\Control\\Windows")
#define DmfVal  TEXT("DmfEnabled")

#define MAX_DISK_SIZE_ALLOWED    (3)   // in Megabytes

BOOLEAN
GetWidget(
    OUT PSID *Sid,
    OUT PULONG SidLength
    )

/*++

Routine Description:

    This routine retrieves the sid of this machine's account
    domain and returns it in memory allocated with MALLOC.
    If this machine is a server in a domain, then this SID will
    be domain's SID.


Arguments:

    Sid - receives a pointer to the returned SID.

    SidLength - Receives the length (in bytes) of the returned SID.


Return Value:

    TRUE - The SID was allocated and returned.

    FALSE - Some error prevented the SID from being returned.

--*/

{
    NTSTATUS
        Status;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    LSA_HANDLE
        PolicyHandle;

    POLICY_ACCOUNT_DOMAIN_INFO
        *DomainInfo = NULL;

    PSID
        ReturnSid;

    BOOLEAN
        ReturnStatus = FALSE;



    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,       // No name
                                0,          // No attributes
                                0,          // No root handle
                                NULL        // No SecurityDescriptor
                                );

    Status = LsaOpenPolicy( NULL,           // Local System
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle
                            );

    if (NT_SUCCESS(Status)) {

        Status = LsaQueryInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     (PVOID*) &DomainInfo
                     );

        if (NT_SUCCESS(Status)) {

            ASSERT(DomainInfo != NULL);

            //
            // Allocate the return buffer
            //

            (*SidLength) = RtlLengthSid( DomainInfo->DomainSid );
            ReturnSid = MALLOC(*SidLength);

            if (ReturnSid != NULL) {

                //
                // Copy the sid
                //

                RtlMoveMemory( ReturnSid, DomainInfo->DomainSid, (*SidLength) );
                (*Sid) = ReturnSid;
                ReturnStatus = TRUE;
            }


            LsaFreeMemory( DomainInfo );
        }

        Status = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(Status));
    }

    return(ReturnStatus);
}


IFSUTIL_EXPORT
ULONG
QueryMachineUniqueToken(
    )
/*++

Routine Description:

    This routine will compute a unique 32-bit value for this machine.

Arguments:

    None.

Return Value:

    0   - Failure.
    A 32-bit value unique for this machine.

--*/
{
    HKEY    hKey;
    int     err;
    WCHAR   szMN[64];
    DWORD   dwType;
    DWORD   cbMN = 64 * sizeof(WCHAR);
    MD4_CTX MD4Context;
    DWORD   Final;
    DWORD * pDigest;
    PSID    sid;
    ULONG   sidLength;

    err = RegOpenKey(HKEY_LOCAL_MACHINE, RegPath, &hKey);
    if (err) {
        return 0;
    }

    err = RegQueryValueEx(hKey, RegVal, NULL, &dwType, (PBYTE) szMN, &cbMN);
    if (err) {
        return 0;
    }

    RegCloseKey(hKey);

    if (!GetWidget(&sid, &sidLength)) {
        return 0;
    }

    MD4Init(&MD4Context);

    MD4Update(&MD4Context, (PBYTE) szMN, cbMN);
    MD4Update(&MD4Context, (PBYTE) sid, sidLength);

    MD4Final(&MD4Context);
    pDigest = (DWORD *) MD4Context.digest;

    Final = pDigest[0] ^ pDigest[1] ^ pDigest[2] ^ pDigest[3];

    FREE(sid);

    return Final;
}


BOOLEAN
TestTokenForAdmin(
    )
/*++

Routine Description:

    This routine checks if the current process token represents an admin
    user.

    Code taken from Winlogon.

Arguments:

    None.

Return Value:

    FALSE   - The current process does not represent an administrator.
    TRUE    - The current process represents an administrator.

--*/
{
    NTSTATUS                    Status;
    BOOL                        IsMember;
    PSID                        gAdminSid;
    SID_IDENTIFIER_AUTHORITY    gSystemSidAuthority = SECURITY_NT_AUTHORITY;

    Status = RtlAllocateAndInitializeSid(
                    &gSystemSidAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &gAdminSid
                    );

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    if (!CheckTokenMembership(NULL, gAdminSid, &IsMember)) {
        DebugPrintTrace(("IFSUTIL: CheckTokenMembership failed %d\n", GetLastError()));
        return FALSE;
    } else
        return (IsMember == TRUE);
}


IFSUTIL_EXPORT
INT
DiskCopyMainLoop(
    IN      PCWSTRING    SrcNtDriveName,
    IN      PCWSTRING    DstNtDriveName,
    IN      PCWSTRING    SrcDosDriveName,
    IN      PCWSTRING    DstDosDriveName,
    IN      BOOLEAN      Verify,
    IN OUT  PMESSAGE     Message,
    IN OUT  PMESSAGE     PercentMessage
    )
/*++

Routine Description:

    This routine copies on floppy diskette to another floppy diskette.

Arguments:

    SrcNtDriveName  - Supplies the NT style drive name for the source.
    DstNtDriveName  - Supplies the NT style drive name for the destination.
    SrcDosDriveName - Supplies the DOS style drive name for the source.
    DstDosDriveName - Supplies the DOS style drive name for the destination.
    Message         - Supplies an outlet for messages.
    PercentMessage  - Supplies an outlet for percent complete messages.

Return Value:

    0   - Success.
    1   - Io error occured.
    3   - Fatal hard error.
    4   - Initialization error.

--*/
{
    PLOG_IO_DP_DRIVE    src_drive = NULL;
    LOG_IO_DP_DRIVE     dst_drive;
    HMEM                src_hmem;
    HMEM                dst_hmem;
    CONT_MEM            src_cmem;
    PVOID               mem_ptr;
    SECRUN              src_secrun;
    SECRUN              dst_secrun;
    SECTORCOUNT         sec_per_track;
    ULONG               total_tracks;
    ULONG               grab;       // number of tracks to grab at once.
    ULONG               sector_size;
    BOOLEAN             one_drive;
    ULONG               src_top;    // src track pointer -- next read
    ULONG               dst_top;    // dst track pointer -- next write
    ULONG               src_volume_id, volume_id;
    PCHAR               pchar;
    ULONG               i;
    PUSHORT             pus;
    ULONG               heads;
    DSTRING             fsname;
    BOOLEAN             io_error;
    ULONG               percent_complete, newp;
    DWORD               OldErrorMode;
    BOOLEAN             dmf;
    UCHAR               saved_char;
    BOOLEAN             cancel;
    BOOLEAN             done = FALSE;
    MSGID               msg;
    BIG_INT             src_drive_Sectors;
    BIG_INT             src_drive_Tracks;
    MEDIA_TYPE          src_drive_MediaType;
#if defined(FE_SB) && defined(_X86_)
    // FMR Nov.21.94 NaokiM
    MEDIA_TYPE          AltMediaType;
#endif

    one_drive = (*SrcDosDriveName == *DstDosDriveName);

    if (!one_drive) {
        Message->Set(MSG_DCOPY_INSERT_SOURCE_AND_TARGET);
        Message->Display("%W%W", SrcDosDriveName, DstDosDriveName);
    } else {
        Message->Set(MSG_DCOPY_INSERT_SOURCE);
        Message->Display("%W", SrcDosDriveName);
    }

    Message->Set(MSG_PRESS_ENTER_WHEN_READY);
    Message->Display();
    Message->WaitForUserSignal();


    if (!(src_drive = NEW LOG_IO_DP_DRIVE)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return 4;
    }

    if (!src_drive->Initialize(SrcNtDriveName)) {

        // Verify that we can access the source drive:

        if (src_drive->QueryLastNtStatus() == STATUS_ACCESS_DENIED) {
            Message->Set(MSG_DASD_ACCESS_DENIED);
            Message->Display();
            DELETE(src_drive);
            return 4;
        }

        Message->Set(MSG_DCOPY_BAD_SOURCE);
        Message->Display();
        DELETE(src_drive);
        return 3;
    }

    if (!src_drive->IsFloppy()) {
        Message->Set(MSG_DCOPY_INVALID_DRIVE);
        Message->Display();
        DELETE(src_drive);
        return 4;
    }

    if (!src_drive->Lock()) {
        Message->Set(MSG_CANT_LOCK_THE_DRIVE);
        Message->Display("");
        DELETE(src_drive);
        return 3;
    }

    if (src_drive->QueryMediaType() == Unknown ||
        src_drive->QuerySectorsPerTrack() == 0) {
        Message->Set(MSG_DCOPY_BAD_SOURCE);
        Message->Display();
        DELETE(src_drive);
        return 3;
    }

    src_drive_Sectors = src_drive->QuerySectors();
    src_drive_MediaType = src_drive->QueryMediaType();
    src_drive_Tracks = src_drive->QueryTracks();

    if (src_drive->QueryMediaType() == F3_1Pt44_512 &&
        src_drive->QuerySectorsPerTrack() != 18) {

        if (!src_hmem.Initialize() ||
            !src_secrun.Initialize(&src_hmem, src_drive, 0, 1) ||
            !src_secrun.Read()) {

            Message->Set(MSG_DCOPY_BAD_SOURCE);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }

        if (src_drive->QuerySectorsPerTrack() != 21 ||
            memcmp(((PUCHAR) src_secrun.GetBuf()) + 3, "MSDMF3.2", 8)) {

            Message->Set(MSG_DCOPY_UNRECOGNIZED_FORMAT);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }


        {
            HKEY    hKey;
            int     err;
            DWORD   dwType;
            DWORD   JimsBigNumber, machineToken;
            MD4_CTX MD4Context;
            DWORD   Final;
            DWORD * pDigest;
            DWORD   regFinal;
            DWORD   regFinalSize = sizeof(DWORD);

            JimsBigNumber = JIMS_BIG_NUMBER;

            machineToken = QueryMachineUniqueToken();

            MD4Init(&MD4Context);

            MD4Update(&MD4Context, (PBYTE) &machineToken, sizeof(DWORD));
            MD4Update(&MD4Context, (PBYTE) &JimsBigNumber, sizeof(DWORD));

            MD4Final(&MD4Context);
            pDigest = (DWORD *) MD4Context.digest;

            Final = pDigest[0] ^ pDigest[1] ^ pDigest[2] ^ pDigest[3];


            //
            // Reserve the upper two bits for VERSIONing.
            // This is version 0.0
            //

            Final &= 0x3FFFFFFF;


            err = RegOpenKey(HKEY_LOCAL_MACHINE, DmfPath, &hKey);
            if (err) {
                Message->Set(MSG_DCOPY_UNRECOGNIZED_FORMAT);
                Message->Display();
                DELETE(src_drive);
                return 3;
            }

            err = RegQueryValueEx(hKey, DmfVal, NULL, &dwType, (PBYTE) &regFinal,
                                  &regFinalSize);
            if (err || regFinalSize != sizeof(DWORD)) {
                Message->Set(MSG_DCOPY_UNRECOGNIZED_FORMAT);
                Message->Display();
                DELETE(src_drive);
                return 3;
            }

            RegCloseKey(hKey);

            if (regFinal != Final) {
                Message->Set(MSG_DCOPY_UNRECOGNIZED_FORMAT);
                Message->Display();
                DELETE(src_drive);
                return 3;
            }
        }


        dmf = TRUE;
        Verify = TRUE;

        if (!TestTokenForAdmin()) {
            Message->Set(MSG_DCOPY_NOT_ADMINISTRATOR);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }

        if (src_drive->IsSupported(F3_2Pt88_512)) {
            Message->Set(MSG_FMT_DMF_NOT_SUPPORTED_ON_288_DRIVES);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }

    } else {
        dmf = FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    // FMR Nov.21.94 NaokiM
    AltMediaType = src_drive->QueryMediaType();
#endif

    // If there is more than one drive then open the second
    // one right away to determine if it's compatible or not.

    if (!one_drive) {

        // Disable popups while we determine the drive type.
        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        if (!dst_drive.Initialize(DstNtDriveName)) {

            // Restore the error mode.
            SetErrorMode( OldErrorMode );

            // Verify that we can access the destination drive:

            if (dst_drive.QueryLastNtStatus() == STATUS_ACCESS_DENIED) {
                Message->Set(MSG_DASD_ACCESS_DENIED);
                Message->Display();
                DELETE(src_drive);
                return 4;
            }

            Message->Set(MSG_DCOPY_BAD_DEST);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }

        // Restore the error mode.
        SetErrorMode( OldErrorMode );

        if (!dst_drive.Lock()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            DELETE(src_drive);
            return 4;
        }

        // Make sure that the destination floppy will support the same media
        // as the source floppy.

#if defined(FE_SB) && defined(_X86_)
        //
        // FMR Nov.21.94 NaokiM
        // If source media type is not supported on target drive, try another
        // Media type that has same format.(F5_ ... -> F3_ ...)
        //

        if (!dst_drive.IsSupported(src_drive->QueryMediaType())) {

            switch(src_drive->QueryMediaType()) {
                case F5_1Pt23_1024:
                    AltMediaType = F3_1Pt23_1024;
                    break;
                case F3_1Pt23_1024:
                    AltMediaType = F5_1Pt23_1024;
                    break;
                case F5_1Pt2_512:
                    AltMediaType = F3_1Pt2_512;
                    break;
                case F3_1Pt2_512:
                    AltMediaType = F5_1Pt2_512;
                    break;
                case F3_720_512:
                    AltMediaType = F5_720_512;
                    break;
                case F5_720_512:
                    AltMediaType = F3_720_512;
                    break;
                case F5_640_512:
                    AltMediaType = F3_640_512;
                    break;
                case F3_640_512:
                    AltMediaType = F5_640_512;
                    break;
                default:
                    break;
            }
        }

        if (!dst_drive.IsSupported(AltMediaType)) {
#else
        if (!dst_drive.IsSupported(src_drive->QueryMediaType())) {
#endif
            Message->Set(MSG_DCOPY_BAD_DEST);
            Message->Display();
            DELETE(src_drive);
            return 4;
        }
    }

    sec_per_track = src_drive->QuerySectorsPerTrack();
    sector_size = src_drive->QuerySectorSize();
    total_tracks = src_drive->QueryTracks().GetLowPart();
    heads = src_drive->QueryHeads();

    if (total_tracks*sec_per_track*sector_size >
        MAX_DISK_SIZE_ALLOWED*1024*1024) {
        Message->Set(MSG_DCOPY_DISK_TOO_LARGE);
        Message->Display("%d", MAX_DISK_SIZE_ALLOWED);
        DELETE(src_drive);
        return 3;
    }

    Message->Set(MSG_DCOPY_COPYING);
    Message->Display("%d%d%d", src_drive->QueryCylinders().GetLowPart(),
                               sec_per_track,
                               heads);

    DebugAssert(src_drive->QuerySectors().GetHighPart() == 0);

    if (!dst_hmem.Initialize()) {
        DELETE(src_drive);
        return 4;
    }

    io_error = FALSE;

    percent_complete = 0;
    if (PercentMessage) {
        PercentMessage->Set(MSG_PERCENT_COMPLETE);
        if (!PercentMessage->Display("%d", 0)) {
            DELETE(src_drive);
            return 4;
        }
    }

    for (src_top = dst_top = 0; dst_top < total_tracks; dst_top++) {

        if (src_top == dst_top) {

            if (src_top && one_drive) {

                // Gets here because diskcopy is doing multiple passes

                ASSERT(FALSE); // shouldn't get here anymore

                if (!dst_drive.Unlock()) {
                    Message->Set(MSG_CANT_UNLOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 3;
                }

                Message->Set(MSG_DCOPY_INSERT_SOURCE);
                Message->Display("%W", SrcDosDriveName);
                Message->Set(MSG_PRESS_ENTER_WHEN_READY);
                Message->Display();
                Message->WaitForUserSignal();

                if (!src_drive->Lock()) {
                    Message->Set(MSG_CANT_LOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 3;
                }
            }


            // Allocate memory for read.
            for (grab = total_tracks - src_top;
                 !src_hmem.Initialize() ||
                 !(mem_ptr = src_hmem.Acquire(grab*sector_size*sec_per_track,
                                              src_drive->QueryAlignmentMask()));
                 grab /= 2) {

//                if (grab < 2) {
                    Message->Set(MSG_CHK_NO_MEMORY);
                    Message->Display();
                    DELETE(src_drive);
                    return 4;
//                }
            }

            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                DELETE(src_drive);
                return 4;
            }


            // Read the source, track by track.

            for (i = 0; i < grab; i++) {
                if (!src_secrun.Initialize(&src_cmem, src_drive,
                                           src_top*sec_per_track,
                                           sec_per_track)) {
                    DELETE(src_drive);
                    return 4;
                }

              ReadAgain:

                if (!src_secrun.Read()) {

                    if (src_drive->QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                        src_drive->QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                        if (src_drive->QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE)
                            msg = MSG_DCOPY_NO_MEDIA_IN_DEVICE;
                        else
                            msg = MSG_DCOPY_UNRECOGNIZED_MEDIA;
                        Message->Set(msg, NORMAL_MESSAGE, GUI_MESSAGE);
                        cancel = Message->Display("%W", SrcDosDriveName);
                        if (!cancel) // if not cancel that means the user want to retry
                            goto ReadAgain;
                        DELETE(src_drive);
                        return 3;
                    }

                    Message->Set(MSG_DCOPY_READ_ERROR);
                    Message->Display("%W%d%d", SrcDosDriveName,
                                               src_top%heads, src_top/heads);
                    io_error = TRUE;
                }

                src_top++;

                newp = (100*(src_top + dst_top)/
                       (2*src_drive->QueryTracks())).GetLowPart();
                if (newp != percent_complete && PercentMessage) {
                    PercentMessage->Set(MSG_PERCENT_COMPLETE);
                    if (!PercentMessage->Display("%d", newp)) {
                        DELETE(src_drive);
                        return 4;
                    }
                }
                percent_complete = newp;
            }

            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                DELETE(src_drive);
                return 4;
            }

            if (one_drive) {

                if (!src_drive->Unlock()) {
                    Message->Set(MSG_CANT_UNLOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 4;
                } else {
                   DELETE(src_drive);
                   src_drive = NULL;
                }

                Message->Set(MSG_DCOPY_INSERT_TARGET);
                Message->Display("%W", DstDosDriveName);
                Message->Set(MSG_PRESS_ENTER_WHEN_READY);
                Message->Display();
                Message->WaitForUserSignal();

                if (dst_top && !dst_drive.Lock()) {
                    Message->Set(MSG_CANT_LOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 3;
                }

            }

            if (!dst_top) { // first time

              DstInitializeAgain:

                // Disable popups while we determine the drive type.
                OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

                if (!dst_drive.Initialize(DstNtDriveName)) {

                    // Restore the error mode.
                    SetErrorMode( OldErrorMode );

                    // Verify that we can access the destination drive:

                    if (dst_drive.QueryLastNtStatus() == STATUS_ACCESS_DENIED) {
                        Message->Set(MSG_DASD_ACCESS_DENIED);
                        Message->Display();
                        DELETE(src_drive);
                        return 4;
                    }

                    if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                        dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                        if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE)
                            msg = MSG_DCOPY_NO_MEDIA_IN_DEVICE;
                        else
                            msg = MSG_DCOPY_UNRECOGNIZED_MEDIA;
                        Message->Set(msg, NORMAL_MESSAGE, GUI_MESSAGE);
                        cancel = Message->Display("%W", DstDosDriveName);
                        if (!cancel) // if not cancel that means the user want to retry
                            goto DstInitializeAgain;
                    }

                    Message->Set(MSG_DCOPY_BAD_DEST);
                    Message->Display();
                    DELETE(src_drive);
                    return 3;
                }

                // Restore the error mode.
                SetErrorMode( OldErrorMode );

                // Only try to lock the drive if the source disk has
                // a serial number.  Don't lock if the source and
                // destination drive name are the same (since they
                // may have the same serial number).
                // If the target is DMF, don't write protect it until
                // we're done with it.

                if (dmf) {
                    saved_char = ((PUCHAR) mem_ptr)[3];
                    ((PUCHAR) mem_ptr)[3] = 'X';
                }

                if (((PUCHAR) mem_ptr)[0x26] == 0x28 ||
                    ((PUCHAR) mem_ptr)[0x26] == 0x29) {

                    memcpy(&src_volume_id, (PCHAR) mem_ptr + 0x27,
                           sizeof(ULONG));
                } else {
                    src_volume_id = 0;
                }

                if (!dst_drive.Lock()) {
                    Message->Set(MSG_CANT_LOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 3;
                }

                // Only format the target if it isn't formatted.
                // If it is formatted then it must be of the same
                // media type.

#if defined(FE_SB) && defined(_X86_)
                //
                // FMR Nov.21.94 NaokiM
                // Add conditions that we shuold format target on.
                //

                if (((AltMediaType == F3_1Pt44_512) &&
                      ((dst_drive.QueryMediaType() == F3_1Pt2_512) ||
                       (dst_drive.QueryMediaType() == F3_1Pt23_1024))) ||
                    ((AltMediaType == F3_1Pt2_512) &&
                      ((dst_drive.QueryMediaType() == F3_1Pt44_512) ||
                       (dst_drive.QueryMediaType() == F3_1Pt23_1024))) ||
                    ((AltMediaType == F3_1Pt23_1024) &&
                      ((dst_drive.QueryMediaType() == F3_1Pt44_512) ||
                       (dst_drive.QueryMediaType() == F3_1Pt2_512))) ||
                    ((AltMediaType == F3_720_512) &&
                       (dst_drive.QueryMediaType() == F3_640_512)) ||
                    ((AltMediaType == F3_640_512) &&
                       (dst_drive.QueryMediaType() == F3_720_512)) ||
                    ((AltMediaType == F5_1Pt2_512) &&
                       (dst_drive.QueryMediaType() == F5_1Pt23_1024)) ||
                    ((AltMediaType == F5_1Pt23_1024) &&
                       (dst_drive.QueryMediaType() == F5_1Pt2_512)) ||
                    // FMR Feb.02.95 JunY
                    // Add 5.25" 720KB/640KB types that we shuold format target on.
                    ((AltMediaType == F5_720_512) &&
                       (dst_drive.QueryMediaType() == F5_640_512)) ||
                    ((AltMediaType == F5_640_512) &&
                       (dst_drive.QueryMediaType() == F5_720_512)) ||

                    (dst_drive.QueryMediaType() == Unknown) ||
                    (dst_drive.QueryMediaType() == src_drive_MediaType &&
                     (dmf || dst_drive.QuerySectors() != src_drive_Sectors))) {
                    if (!dst_drive.IsSupported(AltMediaType)) {
#else
                if (dst_drive.QueryMediaType() == Unknown ||
                    (dst_drive.QueryMediaType() == src_drive_MediaType &&
                     (dmf || dst_drive.QuerySectors() != src_drive_Sectors))) {
                    if (!dst_drive.IsSupported(src_drive_MediaType)) {
#endif
                        Message->Set(MSG_DCOPY_BAD_DEST);
                        Message->Display();
                        DELETE(src_drive);
                        return 4;
                    }

                    Message->Set(MSG_DCOPY_FORMATTING_WHILE_COPYING);
                    Message->Display();


#if defined(FE_SB) && defined(_X86_)
                    // FMR Nov.21.94 NaokiM
                    //
                    // Make destination media "Unknwon" before formatting.
                    // This is to ensure write operation in case that sector size is changed
                    // after formatting.
                    //

                    if (dst_drive.QueryMediaType() != Unknown ) {

                        // Disable popups while we determine the drive type.
                        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

                        if (!dst_hmem.Initialize() ||
                            !dst_secrun.Initialize(&dst_hmem, &dst_drive,
                                                    0, 1)) {
                            DELETE(src_drive);
                            return 4;
                        }

                        if (dst_secrun.Read()) {
                            //
                            // if boot sector can be read, destroy boot sector.
                            //
                            pchar = (PCHAR) dst_secrun.GetBuf();
                            *pchar = 0x00;

                            dst_secrun.Write();
                        }

                        //
                        // Dismount desination volume
                        //
                        dst_drive.Initialize(DstNtDriveName);

                        //
                        // Re-initialize dst_hmem for the verify code
                        //
                        if (!dst_hmem.Initialize()) {
                            DELETE(src_drive);
                            return 4;
                        }

                        // Restore the error mode.
                        SetErrorMode( OldErrorMode );

                    }

                    if (!dst_drive.FormatVerifyFloppy(
                                AltMediaType, NULL, NULL, dmf)) {
#else
                    if (!dst_drive.FormatVerifyFloppy(
                                src_drive_MediaType, NULL, NULL, dmf)) {
#endif
                        Message->Set(MSG_DCOPY_BAD_DEST);
                        Message->Display("");
                        DELETE(src_drive);
                        return 3;
                    }

#if defined(FE_SB) && defined(_X86_)
                } else if (dst_drive.QueryMediaType() !=
                                   AltMediaType) {
#else
                } else if (dst_drive.QueryMediaType() !=
                                   src_drive_MediaType) {
#endif

#if defined(FE_SB) && defined(_X86_)
                    // NEC Oct.16.1994
                    // Try to format the destination floppy.
                    // Need user's agreement before the destination floppy will be format.
                    //
                    if ( IsPC98_N() ) {
#ifdef LATER
                        Message->Set(MSG_FORMAT_AND_COPY_OK);
                        Message->Display("");
                        if (!Message->IsYesResponse(TRUE)) {
                                Message->Set(MSG_DCOPY_NON_COMPAT_DISKS);
                                Message->Display();
                                DELETE(src_drive);
                                return 4;
                        }
#endif

                        Message->Set(MSG_DCOPY_FORMATTING_WHILE_COPYING);
                        Message->Display();

                        if (!dst_drive.FormatVerifyFloppy(
                                    src_drive_MediaType, NULL, NULL, dmf)) {

                            Message->Set(MSG_DCOPY_BAD_DEST);
                            Message->Display("");
                            DELETE(src_drive);
                            return 3;
                        }
                    } else {
#endif

                    dst_drive.Unlock();
                    Message->Set(MSG_DCOPY_NON_COMPAT_DISKS);
                    cancel = Message->Display();
                    if (!cancel)
                        goto DstInitializeAgain;
                    DELETE(src_drive);
                    return 4;
#if defined(FE_SB) && defined(_X86_)
                    }
#endif
                }
            }
        }

      FinalWrite:

        if (!dst_secrun.Initialize(&src_cmem, &dst_drive,
                                   dst_top*sec_per_track, sec_per_track)) {
            DELETE(src_drive);
            return 4;
        }

        if (!dst_top && !done) {
            if (src_volume_id) {

                while (!(volume_id = SUPERAREA::ComputeVolId())) {
                }

                pchar = (PCHAR) dst_secrun.GetBuf();
                memcpy(pchar + 0x27, &volume_id, sizeof(ULONG));
            }
            continue;
        }

      WriteAgain:

        if (!dst_secrun.Write()) {

            if (dst_drive.QueryLastNtStatus() == STATUS_MEDIA_WRITE_PROTECTED  ||
                dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE)
                    msg = MSG_DCOPY_NO_MEDIA_IN_DEVICE;
                else if (dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA)
                    msg = MSG_DCOPY_UNRECOGNIZED_MEDIA;
                else {
                    msg = MSG_DCOPY_MEDIA_WRITE_PROTECTED;
                    // Assuming this is the first write.  That means the user has
                    // to either unprotect the disk or put in a different disk.
                    // If the user puts in a different disk, we will have to start
                    // over again.  That's why we should unlock first.
                    dst_drive.Unlock();
                }
                Message->Set(msg, NORMAL_MESSAGE, GUI_MESSAGE);
                cancel = Message->Display("%W", DstDosDriveName);
                if (!cancel) // if not cancel that means the user want to retry
                    if (msg == MSG_DCOPY_MEDIA_WRITE_PROTECTED) {
                        if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                            DELETE(src_drive);
                            return 4;
                        }
                        done = FALSE;
                        dst_top = 0;
                        goto DstInitializeAgain;
                    } else
                        goto WriteAgain;
                DELETE(src_drive);
                return 3;
            }

            Message->Set(MSG_DCOPY_WRITE_ERROR);
            Message->Display("%W%d%d", DstDosDriveName,
                                       dst_top%heads, dst_top/heads);

            io_error = TRUE;

        } else if (Verify) {
            pchar = (PCHAR) dst_secrun.GetBuf();

            if (!dst_secrun.Initialize(&dst_hmem, &dst_drive,
                                       dst_top*sec_per_track, sec_per_track)) {
                DELETE(src_drive);
                return 4;
            }

          VerifyReadAgain:

            if (!dst_secrun.Read() ||
                memcmp(dst_secrun.GetBuf(), pchar,
                       (UINT) (sec_per_track*sector_size))) {

                if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                    dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                    if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE)
                        msg = MSG_DCOPY_NO_MEDIA_IN_DEVICE;
                    else
                        msg = MSG_DCOPY_UNRECOGNIZED_MEDIA;
                    Message->Set(msg, NORMAL_MESSAGE, GUI_MESSAGE);
                    cancel = Message->Display("%W", DstDosDriveName);
                    if (!cancel) // if not cancel that means the user want to retry
                        goto VerifyReadAgain;
                    DELETE(src_drive);
                    return 3;
                }

                Message->Set(MSG_DCOPY_WRITE_ERROR);
                Message->Display("%W%d%d", DstDosDriveName,
                                           dst_top%heads, dst_top/heads);

                io_error = TRUE;
            }
        }

        if (dst_top == total_tracks-1) {
            dst_top = 0;
            done = TRUE;
            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                DELETE(src_drive);
                return 4;
            }
            goto FinalWrite;
        }

        if (done)
           dst_top = total_tracks;

        newp = (100*(src_top + dst_top-1)/
               (2*src_drive_Tracks)).GetLowPart();
        if (newp != percent_complete && PercentMessage) {
            PercentMessage->Set(MSG_PERCENT_COMPLETE);
            if (!PercentMessage->Display("%d", newp)) {
                DELETE(src_drive);
                return 4;
            }
        }
        percent_complete = newp;
    }

    DELETE(src_drive);

    // If this is DMF then write-protect the target floppy.

    if (dmf) {
        if (!dst_hmem.Initialize() ||
            !dst_secrun.Initialize(&dst_hmem, &dst_drive, 0, 1) ||
            !dst_secrun.Read() ||
            (((PUCHAR) dst_secrun.GetBuf())[3] = saved_char) != saved_char ||
            !dst_secrun.Write()) {

            Message->Set(MSG_DCOPY_WRITE_ERROR);
            Message->Display("%W%d%d", DstDosDriveName, 0, 0);
            io_error = TRUE;
        }
    }

    if (src_volume_id) {
        pus = (PUSHORT) &volume_id;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", pus[1], pus[0]);
    }

    // In that we didn't lock the
    // volume previously.  We need to do this so
    // that the file system will do a verify and
    // thus be able to see the new label if any.
    // We shouldn't fail if we can't do this though.

    dst_drive.Lock();

    return io_error ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\rcache.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "rcache.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( READ_CACHE, DRIVE_CACHE, IFSUTIL_EXPORT );


READ_CACHE::~READ_CACHE(
    )
/*++

Routine Description:

    Destructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
READ_CACHE::Construct (
        )
/*++

Routine Description:

    Contructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
READ_CACHE::Destroy(
    )
/*++

Routine Description:

    Destructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


IFSUTIL_EXPORT
BOOLEAN
READ_CACHE::Initialize(
    IN OUT  PIO_DP_DRIVE    Drive,
    IN      ULONG           NumberOfCacheBlocks
    )
/*++

Routine Description:

    This routine initializes a READ_CACHE object.

Arguments:

    Drive   - Supplies the drive to cache for.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!DRIVE_CACHE::Initialize(Drive)) {
        Destroy();
        return FALSE;
    }

    if (!_cache.Initialize(Drive->QuerySectorSize(),
                           NumberOfCacheBlocks)) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
READ_CACHE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads the requested sectors.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies the buffer to read the run of sectors to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, j;
    ULONG   sector_size;
    PCHAR   buf;

    // Bypass the cache for large reads.

    if (NumberOfSectors > _cache.QueryMaxNumBlocks()) {
        return HardRead(StartingSector, NumberOfSectors, Buffer);
    }

    sector_size = _cache.QueryBlockSize();
    buf = (PCHAR) Buffer;

    for (i = 0; i < NumberOfSectors; i++) {

        for (j = i; j < NumberOfSectors; j++) {

            if (_cache.Read(StartingSector + j, &buf[j*sector_size])) {

                break;
            }
        }


        // Now do a hard read on everything from i to j and add these
        // blocks to the cache.

        if (j - i) {

            if (!HardRead(StartingSector + i, j - i, &buf[i*sector_size])) {

                return FALSE;
            }

            for (; i < j; i++) {

                _cache.AddBlock(StartingSector + i, &buf[i*sector_size]);
            }
        }
    }

    return TRUE;
}


BOOLEAN
READ_CACHE::Write(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    IN  PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes the requested sectors directly to the disk.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _cache.Empty();
    return HardWrite(StartingSector, NumberOfSectors, Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\rwcache.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "rwcache.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( READ_WRITE_CACHE, DRIVE_CACHE, IFSUTIL_EXPORT );


READ_WRITE_CACHE::~READ_WRITE_CACHE(
    )
/*++

Routine Description:

    Destructor for READ_WRITE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
READ_WRITE_CACHE::Construct(
        )
/*++

Routine Description:

    Contructor for READ_WRITE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _cache_blocks = NULL;
    _num_blocks = 0;
    _sector_size = 0;
    _error_occurred = FALSE;
    _sectors_per_buffer = 0;
#if defined(RWCACHE_PERF_COUNTERS)
    _WMiss = _WHit = 0;
    _RMiss = _RHit = _ROverHead = 0;
    _Usage = 0;
#endif
}


VOID
READ_WRITE_CACHE::Destroy(
    )
/*++

Routine Description:

    Destructor for READ_WRITE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;

    Flush();

    for (i = 0; i < _num_blocks; i++) {
        DELETE(_cache_blocks[i]);
    }
    DELETE(_cache_blocks);

    _num_blocks = 0;
    _sector_size = 0;
    _error_occurred = FALSE;
    _sectors_per_buffer = 0;
#if defined(RWCACHE_PERF_COUNTERS)
    _WMiss = _WHit = 0;
    _RMiss = _RHit = _ROverHead = 0;
    _Usage = 0;
#endif
}


IFSUTIL_EXPORT
BOOLEAN
READ_WRITE_CACHE::Initialize(
    IN OUT  PIO_DP_DRIVE    Drive,
    IN      ULONG           NumberOfCacheBlocks
    )
/*++

Routine Description:

    This routine initializes a READ_WRITE_CACHE object.

Arguments:

    Drive               - Supplies the drive to cache for.
    NumberOfCacheBlocks - Supplies the number of cache blocks.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;

    Destroy();

    _num_blocks = NumberOfCacheBlocks;
    _sector_size = Drive->QuerySectorSize();
    _error_occurred = FALSE;

    if (!DRIVE_CACHE::Initialize(Drive) ||
        !_sectors_cached.Initialize() ||
        !(_cache_blocks = NEW PRW_CACHE_BLOCK[_num_blocks]) ||
        !_write_buffer.Initialize() ||
        !_write_buffer.Acquire(1024*1024,
                               Drive->QueryAlignmentMask())) {

        Destroy();
        return FALSE;
    }

    DebugAssert((_write_buffer.QuerySize() % _sector_size) == 0);
    _sectors_per_buffer = _write_buffer.QuerySize()/_sector_size;

    for (i = 0; i < _num_blocks; i++) {

        if (!(_cache_blocks[i] = NEW RW_CACHE_BLOCK) ||
            !_cache_blocks[i]->SectorBuffer.Initialize() ||
            !_cache_blocks[i]->SectorBuffer.Acquire(_sector_size)) {

            Destroy();
            return FALSE;
        }

        _cache_blocks[i]->InUse = FALSE;
        _cache_blocks[i]->IsDirty = FALSE;
        _cache_blocks[i]->Age = 0;
        _cache_blocks[i]->SectorNumber = 0;
    }

    return TRUE;
}


BOOLEAN
READ_WRITE_CACHE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads the requested sectors.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies the buffer to read the run of sectors to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i, j;
    PRW_CACHE_BLOCK p;
    PCHAR           pchar;

    pchar = (PCHAR) Buffer;

    // First check to see if the whole thing can come from the cache.

    for (i = 0; i < NumberOfSectors; i++) {

        if (!(p = GetSectorCacheBlock(StartingSector + i))) {
            break;
        }

#if defined(RWCACHE_PERF_COUNTERS)
        _RHit++;
#endif
        memcpy(&pchar[i*_sector_size], p->SectorBuffer.GetBuf(), _sector_size);
    }

    if (i == NumberOfSectors) {
        return TRUE;
    }


    // Not all of it was available so we first read the whole thing in from
    // disk and then modify that with any dirty cache blocks.

    if (!HardRead(StartingSector + i, NumberOfSectors - i,
                  &pchar[i*_sector_size])) {

        return FALSE;
    }

    // First, spin through the sectors just read to determine
    // if any are dirty in the cache; if a sector is present
    // and dirty, copy it from the cache block to the client
    // buffer.
    //
    for (j = i; j < NumberOfSectors; j++) {

        if (p = GetSectorCacheBlock(StartingSector + j)) {

            // The sector is in the cache.  Update its timestamp;
            // if it's dirty, copy the data from the cache block
            // into the client buffer.
            //
#if defined(RWCACHE_PERF_COUNTERS)
            _ROverHead++;
#endif
            if (p->IsDirty) {
                memcpy(&pchar[j*_sector_size], p->SectorBuffer.GetBuf(), _sector_size);
            }
        }
    }

    // Now spin through them again, copying the read data that
    // isn't already in the cache into the cache.  Note that this
    // loop must be kept separate from the loop above to prevent
    // dirty cache blocks associated with this read from getting
    // preempted.
    //
    for (j = i; j < NumberOfSectors; j++) {

        if (!GetSectorCacheBlock(StartingSector + j)) {

            // The sector is not already in the cache--grab a
            // cache block and stuff this sector's data into it
            //
            if (p = GetNextAvailbleCacheBlock(StartingSector + j)) {

                if (p->InUse) {
                    if (p->IsDirty) {
                        FlushThisCacheBlock(p);
                    }

                    _sectors_cached.Remove(p->SectorNumber);
                }

#if defined(RWCACHE_PERF_COUNTERS)
                _RMiss++;
#endif
                p->InUse = TRUE;
                p->IsDirty = FALSE;
                p->SectorNumber = StartingSector + j;
                memcpy(p->SectorBuffer.GetBuf(), &pchar[j*_sector_size], _sector_size);

                _sectors_cached.Add(p->SectorNumber);

            } else {
                DebugAbort("This can't happen!");
            }
        }
    }

    return TRUE;
}


BOOLEAN
READ_WRITE_CACHE::Write(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    IN  PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes the requested sectors directly to the disk.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;
    PRW_CACHE_BLOCK p;
    PCHAR           pchar;

    pchar = (PCHAR) Buffer;

    for (i = 0; i < NumberOfSectors; i++) {

        if (!(p = GetSectorCacheBlock(StartingSector + i))) {

            p = GetNextAvailbleCacheBlock(StartingSector + i);
            DebugAssert(p);

            if (p->InUse) {
                if (p->IsDirty) {
                    FlushThisCacheBlock(p);
                }

                _sectors_cached.Remove(p->SectorNumber);
            }

#if defined(RWCACHE_PERF_COUNTERS)
            _WMiss++;
#endif
            p->InUse = TRUE;
            p->SectorNumber = StartingSector + i;
            _sectors_cached.Add(p->SectorNumber);
        } else {
#if defined(RWCACHE_PERF_COUNTERS)
            _WHit++;
#endif
        }

        p->IsDirty = TRUE;
        memcpy(p->SectorBuffer.GetBuf(), &pchar[i*_sector_size], _sector_size);
    }

    return !_error_occurred;
}


BOOLEAN
READ_WRITE_CACHE::Flush(
    )
/*++

Routine Description:

    This routine flushes all dirty cache blocks to disk.  This routine
    returns FALSE if there has ever been an write error since the last
    flush.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;
    PRW_CACHE_BLOCK p;

    for (i=0; i < _num_blocks; i++) {
        p = _cache_blocks[i];
        if (p->InUse && p->IsDirty) {
            FlushThisCacheBlock(p);
        }
#if defined(RWCACHE_PERF_COUNTERS)
        if (p->InUse) {
            _Usage++;
        }
#endif
    }

    return !_error_occurred;
}


PRW_CACHE_BLOCK
READ_WRITE_CACHE::GetSectorCacheBlock(
    IN  BIG_INT SectorNumber
    )
/*++

Routine Description:

    This routine searches the cache block list and return the block corresponding
    to the given sector.  If no such block exists then this routine returns NULL.

Arguments:

    SectorNumber    - Supplies the sector searched for.

Return Value:

    The cache block for the given sector or NULL.

--*/
{
    ULONG           i;
    PRW_CACHE_BLOCK p;

    i = (SectorNumber % _num_blocks).GetLowPart();
    p = _cache_blocks[i];
    if (p->InUse && (p->SectorNumber == SectorNumber)) {
        return p;
    } else
        return NULL;
}


PRW_CACHE_BLOCK
READ_WRITE_CACHE::GetNextAvailbleCacheBlock(
    IN  BIG_INT SectorNumber
    )
/*++

Routine Description:

    This routine searches the cache block list and return the next available
    one.  This routine will return either the oldest cache block or one that
    is not in use.

Arguments:

    None.

Return Value:

    The next available cache block.

--*/
{
    ULONG   i;

    i = (SectorNumber % _num_blocks).GetLowPart();

    return _cache_blocks[i];
}


VOID
READ_WRITE_CACHE::FlushThisCacheBlock(
    IN OUT  PRW_CACHE_BLOCK Block
    )
/*++

Routine Description:

    This routine flushes the given block along with all of its adjacent
    neighbours.  All of these cache blocks are then marked clean.

Arguments:

    Block   - Supplies a pointer to the cache block to flush.

Return Value:

    None.

Notes:

    Because we don't check return values from the NUMBER_SET calls, we can't
    depend on this structure being valid.  If it is not then only the given
    block will be flushed.

--*/
{
    ULONG           i, n;
    BIG_INT         start, length;
    PCHAR           flush_buffer;
    PRW_CACHE_BLOCK p;
    ULONG           sectors_per_buffer;
    ULONG           offset;

    // First figure out which group to flush.

    n = _sectors_cached.QueryNumDisjointRanges();
    for (i = 0; i < n; i++) {

        _sectors_cached.QueryDisjointRange(i, &start, &length);

        if (Block->SectorNumber >= start && Block->SectorNumber < (start + length)) {
            break;
        }
    }

    if (i == n) {
        DebugPrintTrace(("IFSUTIL: FlushThisCacheBlock failure 1\n"));
        _error_occurred = TRUE;
        DebugAssert(FALSE);
        return;
    }

    flush_buffer = (PCHAR) _write_buffer.GetBuf();

    offset = 0;
    do {
        sectors_per_buffer = min(_sectors_per_buffer, length.GetLowPart()-offset);

        for (i = 0; i < sectors_per_buffer; i++) {

            if (!(p = GetSectorCacheBlock(start + i))) {

                DebugPrintTrace(("IFSUTIL: FlushThisCacheBlock failure 2\n"));
                _error_occurred = TRUE;
                DebugAssert(FALSE);
                return;
            }

            p->IsDirty = FALSE;
            memcpy(&flush_buffer[i*_sector_size], p->SectorBuffer.GetBuf(), _sector_size);
        }
        _error_occurred = !HardWrite(start, sectors_per_buffer, flush_buffer) || _error_occurred;
        if (_error_occurred) {
            DebugPrintTrace(("IFSUTIL: FlushThisCacheBlock failure 3\n"));
            return;
        }
        start += sectors_per_buffer;
        offset += sectors_per_buffer;
    } while (offset < length.GetLowPart());
}

#if defined(RWCACHE_PERF_COUNTERS)
VOID
READ_WRITE_CACHE::QueryPerformanceCounters(
    PULONG      RMiss,
    PULONG      RHit,
    PULONG      ROverHead,
    PULONG      WMiss,
    PULONG      WHit,
    PULONG      Usage
    )
{
    *RMiss = _RMiss;
    *RHit  = _RHit;
    *ROverHead = _ROverHead;
    *WMiss = _WMiss;
    *WHit  = _WHit;
    *Usage = _Usage;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\pch.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

        pch.cxx

Abstract:

        This module implements

Author:

        Matthew Bradburn (mattbr)  27-Apr-1994

--*/

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "ifsutil.hxx"
#include "autoentr.hxx"
#include "autoreg.hxx"
#include "bigint.hxx"
#include "bpb.hxx"
#include "cache.hxx"
#include "cannedsd.hxx"
#include "dcache.hxx"
#include "digraph.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "intstack.hxx"
#include "mldcopy.hxx"
#include "mpmap.hxx"
#include "numset.hxx"
#include "rcache.hxx"
#include "rwcache.hxx"
#include "secrun.hxx"
#include "spaset.hxx"
#include "supera.hxx"
#include "tlink.hxx"
#include "volume.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\smsdtect.cxx ===
/*++

Copyright (c) 1992-2001 Microsoft Corporation

Module Name:

    smsdtect.cxx

Abstract:

    This module contains routines that used to detect
    if the device is a Sony Memory Stick and what kind of
    capability it has.

Author:

    Daniel Chan (danielch) 21 Feb, 2001

Environment:

    Ulib, User Mode

Note:

    These routines should be grouped into a class and
    instantiated through one of the DRIVE class.

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "drive.hxx"

#if !defined(_AUTOCHECK_)

extern "C" {
#include <stdio.h>
#include <ntdddisk.h>
#include <initguid.h>
#include <diskguid.h>
#include <setupapi.h>
#include <cfgmgr32.h>
};

typedef struct  {
    SCSI_PASS_THROUGH   Spt;
    SENSE_DATA          SenseData;
    UCHAR               DataBuffer[1];
    // Allocate buffer space after this
} SPT_WITH_BUFFERS, *PSPT_WITH_BUFFERS;

NTSTATUS
SendCdbToDevice(
    IN      HANDLE      DeviceHandle,
    IN      PCDB        Cdb,
    IN      UCHAR       CdbSize,
    IN      PUCHAR      Buffer,
    IN OUT  PDWORD      BufferSize,
    IN      BOOLEAN     GetDataFromDevice,
       OUT  PSENSE_DATA SenseInfo,
       OUT  PUCHAR      ScsiStatus
    );

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSFormatCmd(
    )
/*++

Routine Description:

    This routine sends a Sony Generation 2 Memory Stick format command.

Arguments:

    N/A

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    UCHAR   FmtCmd[12] = { 0xFA,    // OP Code
                           0x0B,    // LUN/Reserved
                           0xA0,    // Sub OP Code
                           'M',
                           'G',
                           'f',
                           'm',
                           't',
                           0x00,    // Reserved
                           0x00,    // Reserved
                           0x00,    // Reserved
                           0x00     // Reserved
                         };

    DWORD   buffer_size = 0;
    UCHAR   scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)FmtCmd,
                                   sizeof(FmtCmd),
                                   NULL,
                                   &buffer_size,
                                   FALSE,
                                   NULL,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) && scsi_status != SCSISTAT_GOOD) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSModeSenseCmd(
       OUT PSONY_MS_MODE_SENSE_DATA ModeSenseData
    )
/*++

Routine Description:

    This routine sends a Sony Memory Stick Mode Sense command.

Arguments:

    ModeSenseData - Returns the mode sense data

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD                       buffer_size = sizeof(SONY_MS_MODE_SENSE_DATA);
    UCHAR   ModeSenseCmd[12] = { SCSIOP_MODE_SENSE10,    // OP Code
                                 0x00,    // LUN/Reserved
                                 0x20,    // PC/PageCode
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                 0x00,    // Parameter List Length (MSB)
                                 (UCHAR)buffer_size, // Parameter List Length (LSB)
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                };
    UCHAR                       scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)ModeSenseCmd,
                                   sizeof(ModeSenseCmd),
                                   (PUCHAR)ModeSenseData,
                                   &buffer_size,
                                   TRUE,
                                   NULL,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) && scsi_status != SCSISTAT_GOOD) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSRequestSenseCmd(
       OUT PSENSE_DATA  SenseInfo
    )
/*++

Routine Description:

    This routine sends a Sony Memory Stick Request Sense command.

Arguments:

    SenseInfo - Returns the sense info data

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD   buffer_size = sizeof(SENSE_DATA);
    UCHAR   RequestSenseCmd[12] = { SCSIOP_REQUEST_SENSE,
                                    0x00,    // LUN/Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    (UCHAR)buffer_size,    // Allocation Length
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00     // Reserved
                                  };

    UCHAR   scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)&RequestSenseCmd,
                                   sizeof(RequestSenseCmd),
                                   (PUCHAR)SenseInfo,
                                   &buffer_size,
                                   TRUE,
                                   NULL,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) &&
        (scsi_status != SCSISTAT_GOOD &&
         scsi_status != SCSISTAT_CHECK_CONDITION)) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSInquiryCmd(
    PSONY_MS_INQUIRY_DATA       InquiryData
    )
/*++

Routine Description:

    This routine sends Sony Memory Stick Inquiry command.

Arguments:

    InquiryData - Returns the inquiry data

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD   buffer_size = sizeof(SONY_MS_INQUIRY_DATA);
    UCHAR   InquiryCmd[12] = { SCSIOP_INQUIRY,
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               (UCHAR)buffer_size,  // Allocation Length
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00     // Reserved
                             };
    UCHAR   scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)InquiryCmd,
                                   sizeof(InquiryCmd),
                                   (PUCHAR)InquiryData,
                                   &buffer_size,
                                   TRUE,
                                   NULL,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) && scsi_status != SCSISTAT_GOOD) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSTestUnitReadyCmd(
       OUT PSENSE_DATA  SenseInfo
    )
/*++

Routine Description:

    This routine sends Sony Memory Stick Test Unit Ready command.

Arguments:

    SenseInfo - Returns the sense info data

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    UCHAR   TestUnitReadyCmd[12] = { SCSIOP_TEST_UNIT_READY,
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00   // Reserved
                                   };
    DWORD   buffer_size = 0;
    UCHAR   scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)TestUnitReadyCmd,
                                   sizeof(TestUnitReadyCmd),
                                   NULL,
                                   &buffer_size,
                                   FALSE,
                                   SenseInfo,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) &&
        (scsi_status != SCSISTAT_GOOD &&
         scsi_status != SCSISTAT_CHECK_CONDITION)) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

NTSTATUS
SendCdbToDevice(
    IN      HANDLE      DeviceHandle,
    IN      PCDB        Cdb,
    IN      UCHAR       CdbSize,
    IN      PUCHAR      Buffer,
    IN OUT  PDWORD      BufferSize,
    IN      BOOLEAN     GetDataFromDevice,
       OUT  PSENSE_DATA SenseInfo,
       OUT  PUCHAR      ScsiStatus
    )
/*++

Routine Description:

    This routine sends/receives SCSI pass through commands.

Arguments:

    DeviceHandle    -
    Cdb             - Supplies the command data block
    CdbSize         - Supplies the size of the command data block
    Buffer          - Supplies and receives the data in and out
    BufferSize      - Supplies the size of the buffer
    GetDataFromDevice - Supplies TRUE if data is needed from device; otherwise, FALSE
    SenseInfo       - Retrieves the sense info data
    ScsiStatus      - Retrieves the scsi status

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSPT_WITH_BUFFERS   p;
    DWORD               packetSize;
    NTSTATUS            status;
    IO_STATUS_BLOCK     status_block;

    if (Cdb == NULL) {
        DebugPrint("IFSUTIL: SendDdbToDevice: Cdb is NULL\n");
        return STATUS_INVALID_PARAMETER;
    }

    if (CdbSize < 1 || CdbSize > 16) {
        DebugPrintTrace(("IFSUTIL: SendDdbToDevice: Cdb size (0x%x) too large/small\n", CdbSize));
        return STATUS_INVALID_PARAMETER;
    }

    if (BufferSize == NULL) {
        DebugPrint("IFSUTIL: SendDdbToDevice: BufferSize pointer cannot be NULL\n");
        return STATUS_INVALID_PARAMETER;
    }

    if ((*BufferSize != 0) && (Buffer == NULL)) {
        DebugPrint("IFSUTIL: SendDdbToDevice: Buffer cannot be NULL if *BufferSize is non-zero\n");
        return STATUS_INVALID_PARAMETER;
    }

    if ((*BufferSize == 0) && (Buffer != NULL)) {
        DebugPrint("IFSUTIL: SendDdbToDevice: Buffer must be NULL if *BufferSize is zero\n");
        return STATUS_INVALID_PARAMETER;
    }

    if ((*BufferSize) && GetDataFromDevice) {

        //
        // pre-zero output buffer (not input buffer)
        //

        memset(Buffer, 0, (*BufferSize));
    }

    packetSize = sizeof(SPT_WITH_BUFFERS) + (*BufferSize);
    p = (PSPT_WITH_BUFFERS)MALLOC(packetSize);
    if (p == NULL) {
        DebugPrint("IFSUTIL: SendDdbToDevice: Could not allocate memory for pass-through\n");
        return STATUS_NO_MEMORY;
    }

    //
    // this has the side effect of pre-zeroing the output buffer
    // if DataIn is TRUE
    //
    memset(p, 0, packetSize);
    memcpy(p->Spt.Cdb, Cdb, CdbSize);

    p->Spt.Length             = sizeof(SCSI_PASS_THROUGH);
    p->Spt.CdbLength          = CdbSize;
    p->Spt.SenseInfoLength    = sizeof(p->SenseData);
    p->Spt.DataIn             = (GetDataFromDevice ? 1 : 0);
    p->Spt.DataTransferLength = (*BufferSize);
    p->Spt.TimeOutValue       = 10;     // ten seconds
    p->Spt.SenseInfoOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, SenseData);
    p->Spt.DataBufferOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, DataBuffer[0]);

    if ((*BufferSize != 0) && (!GetDataFromDevice)) {

        //
        // if we're sending the device data, copy the user's buffer
        //
        RtlCopyMemory(&(p->DataBuffer[0]), Buffer, *BufferSize);

    }

    status = NtDeviceIoControlFile(DeviceHandle,
                                   0,
                                   NULL,
                                   NULL,
                                   &status_block,
                                   IOCTL_SCSI_PASS_THROUGH,
                                   p,
                                   packetSize,
                                   p,
                                   packetSize);

    if (!NT_SUCCESS(status)) {

        DebugPrintTrace(("IFSUTIL: SendDdbToDevice: "
                         "Error sending command %x with status %x and scsi status %x\n",
                         p->Spt.Cdb[0], status, p->Spt.ScsiStatus));

    } else if (GetDataFromDevice) {

        //
        // upon successful completion of a command getting data from the
        // device, copy the returned data back to the user.
        //

        if (*BufferSize >= p->Spt.DataTransferLength) {
            *BufferSize = p->Spt.DataTransferLength;
        } else {
            DebugPrintTrace(("IFSUTIL: SendDdbToDevice: "
                             "DataTransferLength (%x) exceeded buffer size (%x)\n",
                             p->Spt.DataTransferLength,
                             *BufferSize));
            status = STATUS_BUFFER_OVERFLOW;
        }
        memcpy(Buffer, p->DataBuffer, *BufferSize);

    }

    if (ScsiStatus) {
        *ScsiStatus = p->Spt.ScsiStatus;
    }

    if (SenseInfo) {
        *SenseInfo = p->SenseData;
    }

    //
    // free our memory and return
    //

    FREE(p);

    return status;
}

#define MAX_DEVICEID        200
#define MAX_PNPID           MAX_PATH
#define MAX_PNPINSTID       MAX_PATH
#define MAX_KEY             200

BOOLEAN
GetDeviceIDDiskFromDeviceIDVolume(
    IN     LPWSTR   pszNtVolumeName,
       OUT LPWSTR   pszDeviceIDDisk,
    IN     DWORD    cchDeviceIDDisk
    )
/*++

Routine Description:

    This routine retrieves the device id string from the volume name.

Arguments:

    pszNtVolumeName - Supplies the volume name of the device
    pszDeviceIDDisk - Retrieves the device id string
    cchDeviceIDDisk - Supplies the maximum length of the device id string

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    const GUID guidVolumeClass = {0x53f5630d, 0xb6bf, 0x11d0,
                                  {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

    HMACHINE    hMachine = NULL;
    ULONG       ulSize;
    ULONG       ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;
    CONFIGRET   cr;
    PWCHAR      pszDeviceInterface;
    ULONG       devnum;
    DEVICE_TYPE devtype;
    BOOLEAN     bRemovable;

    cr = CM_Get_Device_Interface_List_Size_Ex(
             &ulSize,
             (GUID*)&guidVolumeClass,
             NULL,
             ulFlags,
             hMachine);

    if (CR_SUCCESS != cr || ulSize <= 1) {
        DebugPrintTrace(("IFSUTIL: CM_Get_Device_Interface_List_Size_Ex1 failed %x\n", cr));
        return FALSE;
    }

    pszDeviceInterface = (PWCHAR)MALLOC(ulSize*sizeof(WCHAR));

    if (NULL == pszDeviceInterface) {
        DebugPrintTrace(("IFSUTIL: Out of memory.\n"));
        return FALSE;
    }

    cr = CM_Get_Device_Interface_List_Ex(
             (GUID*)&guidVolumeClass,
              NULL,
             pszDeviceInterface,
             ulSize,
             ulFlags,
             hMachine);

    if (CR_SUCCESS != cr) {
        DebugPrintTrace(("IFSUTIL: CM_Get_Device_Interface_List_Size_Ex2 failed %x\n", cr));
        FREE(pszDeviceInterface);
        return FALSE;
    }

    PWCHAR  psz = pszDeviceInterface;
    WCHAR   saveChar;
    ULONG   len;
    DSTRING dos_name, nt_name, backslash;
    BOOLEAN result = FALSE;

    if (!nt_name.Initialize(pszNtVolumeName)) {
        DebugPrintTrace(("IFSUTIL: Out of memory.\n"));
        return FALSE;
    }

    if (!IFS_SYSTEM::NtDriveNameToDosDriveName(&nt_name, &dos_name)) {
        DebugPrintTrace(("IFSUTIL: NtDriveNameToDosDriveName failed\n"));
        return FALSE;
    }

    if (!backslash.Initialize(TEXT("\\")) ||
        !dos_name.Strcat(&backslash)) {
        DebugPrintTrace(("IFSUTIL: Out of memory.\n"));
        return FALSE;
    }

    if (!GetVolumeNameForVolumeMountPoint(dos_name.GetWSTR(), pszDeviceIDDisk, cchDeviceIDDisk)) {
        DebugPrintTrace(("IFSUTIL: GetVolumeNameForVolumeMountPoint %ls failed %d\n",
                         dos_name.GetWSTR(), GetLastError()));
        return FALSE;
    }

    if (!dos_name.Initialize(pszDeviceIDDisk)) {
        DebugPrintTrace(("IFSUTIL: Out of memory.\n"));
        return FALSE;
    }

    do {

        // append a blackslash

        len = lstrlen(psz);
        psz[len] = '\\';
        saveChar = psz[len+1];
        psz[len+1] = 0;

        if (!GetVolumeNameForVolumeMountPoint(psz, pszDeviceIDDisk, cchDeviceIDDisk)) {
            DebugPrintTrace(("IFSUTIL: GetVolumeNameForVolumeMountPoint %ls failed %d\n",
                             psz, GetLastError()));
            break;
        }

        if (_wcsicmp(pszDeviceIDDisk, dos_name.GetWSTR()) == 0) {
            psz[len] = 0;
            if (len < cchDeviceIDDisk) {
                wcscpy(pszDeviceIDDisk, psz);
                result = TRUE;
            } else {
                DebugPrintTrace(("IFSUTIL: GetDeviceIDDiskFromDeviceIDVolume failed\n"
                                 "IFSUTIL: Output string too short.  Needed %d.  Actual %d\n",
                                 len+1, cchDeviceIDDisk));
            }
            break;
        }

        psz[len+1] = saveChar;
        psz = psz + len + 1;

    } while (*psz);

    FREE(pszDeviceInterface);
    return result;
}

BOOLEAN
GetDeviceInstance(
    IN     LPCWSTR     pszDeviceIntfID,
       OUT DEVINST*    pdevinst
    )
/*++

Routine Description:

    This routine returns the device instance based on the device interface ID.

Arguments:

    pszDeviceIntfID - Supplies device interface id
    pdevinst        - Retrieves the device instance

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    BOOLEAN     result = FALSE;
    HDEVINFO    hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    *pdevinst = NULL;

    if (INVALID_HANDLE_VALUE != hdevinfo) {

        SP_DEVICE_INTERFACE_DATA sdid = {0};

        sdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        if (SetupDiOpenDeviceInterface(hdevinfo, pszDeviceIntfID, 0, &sdid)) {

            DWORD           cbsdidd = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                                      (MAX_DEVICE_ID_LEN * sizeof(WCHAR));

            SP_DEVINFO_DATA sdd = {0};

            SP_DEVICE_INTERFACE_DETAIL_DATA*    psdidd;

            psdidd = (SP_DEVICE_INTERFACE_DETAIL_DATA*)MALLOC(cbsdidd);

            if (psdidd) {

                memset(psdidd, 0, cbsdidd);

                psdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                sdd.cbSize = sizeof(SP_DEVINFO_DATA);

                // SetupDiGetDeviceInterfaceDetail (below) requires that the
                // cbSize member of SP_DEVICE_INTERFACE_DETAIL_DATA be set
                // to the size of the fixed part of the structure, and to pass
                // the size of the full thing as the 4th param.

                if (SetupDiGetDeviceInterfaceDetail(hdevinfo,
                                                    &sdid,
                                                    psdidd,
                                                    cbsdidd,
                                                    NULL,
                                                    &sdd)) {
                    *pdevinst = sdd.DevInst;
                    result = TRUE;

                } else {
                    DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Unable to get device interface (%d)\n",
                                     GetLastError()));
                }

                FREE(psdidd);

            } else {
                DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Out of memory\n"));
            }
        } else {
            DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Unable to open device interface (%d)\n",
                             GetLastError()));
        }

        if (!SetupDiDestroyDeviceInfoList(hdevinfo)) {
            DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Unable to destroy device info list (%d)\n",
                             GetLastError()));
        }
    } else {
        DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Unable to create device info list (%d)\n",
                         GetLastError()));
    }

    return result;
}

BOOLEAN
DeviceInstIsRemovable(
    IN     DEVINST     devinst,
       OUT PBOOLEAN    pfRemovable
    )
/*++

Routine Description:

    This routine checks to see if the given device instance is removable.

Arguments:

    devinst      - Supplies the device instance
    pfRemovable  - Receives TRUE if the device is removable

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD dwCap;
    DWORD cbCap = sizeof(dwCap);

    CONFIGRET cr;

    cr = CM_Get_DevNode_Registry_Property_Ex(
            devinst,
            CM_DRP_CAPABILITIES,
            NULL,
            &dwCap,
            &cbCap,
            0,
            NULL);

    if (CR_SUCCESS == cr) {
        *pfRemovable = (CM_DEVCAP_REMOVABLE & dwCap) ? TRUE : FALSE;
    } else {
        *pfRemovable = FALSE;
    }

    return TRUE;
}

BOOLEAN
GetRemovableDeviceInstRecurs(
    IN     DEVINST     devinst,
       OUT DEVINST*    pdevinst
    )
/*++

Routine Description:

    This routine recursively goes up the device chain to locate the
    correct device instance.

Arguments:

    devinst      - Supplies the initial device instance
    pdevinst     - Retrieves the correct device instance

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    BOOLEAN fRemovable;
    BOOLEAN result = DeviceInstIsRemovable(devinst, &fRemovable);

    if (result)
    {
        if (fRemovable)
        {
            // Found it!
            *pdevinst = devinst;
        }
        else
        {
            // Recurse
            DEVINST devinstParent;

            CONFIGRET cr;

            cr = CM_Get_Parent_Ex(&devinstParent,
                                  devinst,
                                  0,
                                  NULL);

            if (CR_SUCCESS == cr)
            {
                result = GetRemovableDeviceInstRecurs(devinstParent, pdevinst);
            }
            else
            {
                result = FALSE;
            }
        }
    }

    return result;
}

BOOLEAN
FindPnpInstID(
    IN OUT LPWSTR pszPnpID,
       OUT LPWSTR pszPnpInstId,
    IN     ULONG  cchPnpInstId
    )
/*++

Routine Description:

    This routine scans thru the given PNP Id string and splits it up into just
    PNP Id and PNP Instance Id.

Arguments:

    pszPnpID     - Supplies the PNP Id string
    pszPnpInstID - Supplies the PNP Instance Id string
    cchPnpInstId - Supplies the maximum length of the PNP Instance Id string

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD cToFind = 2;
    LPWSTR psz = pszPnpID;

    if (cchPnpInstId) {
        pszPnpInstId[0] = 0;
    }

    while (*psz && cToFind) {

        if ((TEXT('\\') == *psz)) {
            --cToFind;
        }

        if (cToFind) {
            ++psz;
        }
    }

    if (*psz) {
        *psz = 0;
        psz++;
        wcsncpy(pszPnpInstId, psz, cchPnpInstId);
    }

    return TRUE;
}

BOOLEAN
GetPropertyHelper(
    IN     LPCWSTR pszKey,
    IN     LPCWSTR pszPropName,
       OUT PBYTE pbData,
    IN     DWORD cbData
    )
/*++

Routine Description:

    This routine opens the given registry key and retrieves the value of the property name.

Arguments:

    pszKey       - Supplies the registry key
    pszPropName  - Supplies the property name
    pbData       - Supplies the data buffer to store the value associated with the
                   property name
    cbData       - Supplies the maximum length of the data buffer

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    HKEY    hkey;
    LONG    errcode;

    errcode = RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey);

    if (ERROR_SUCCESS != errcode) {
        return FALSE;
    }

    errcode =RegQueryValueEx(hkey, pszPropName, 0, NULL, pbData, &cbData);

    if (ERROR_SUCCESS != errcode) {
        return FALSE;
    }

    errcode = RegCloseKey(hkey);

    if (ERROR_SUCCESS != errcode) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SetupDiGetDeviceExtendedProperty(
    IN     LPCWSTR pszPnpID,
    IN     LPCWSTR pszPnpInstID,
    IN     LPCWSTR pszPropName,
    DWORD /*dwFlags*/,
    DWORD /*dwType*/,
       OUT PBYTE pbData,
    IN     DWORD cbData
    )
/*++

Routine Description:

    This routine goes thru the registry entries and return the value of the property name
    for the given PNP Id & PNP Instance Id.

Arguments:

    pszPnpID     - Supplies the PNP Id string
    pszPnpInstID - Supplies the PNP Instance Id string
    pszPropName  - Supplies the property name
    pbData       - Supplies the data buffer to store the value associated with the
                   property name
    cbData       - Supplies the maximum length of the data buffer

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    ULONG   ulLength;
    ULONG   temp;
    WCHAR   szKey[MAX_KEY];
    PWCHAR  psz = TEXT("System\\CurrentControlSet\\Enum\\");
    PWCHAR  pszDevParm = TEXT("\\Device Parameters");

    // Temporary fct to use while PnP team writes the real one
    //
    // First we look under the DeviceNode for the value and if not there
    // we go to the "database".
    //
    //

    ulLength = wcslen(psz) +
               wcslen(pszPnpID) +
               1 +
               wcslen(pszPnpInstID) +
               wcslen(pszDevParm) +
               1;

    if (ulLength <= MAX_KEY) {
        wcscpy(szKey, psz);
        wcscat(szKey, pszPnpID);
        wcscat(szKey, TEXT("\\"));
        wcscat(szKey, pszPnpInstID);
        wcscat(szKey, pszDevParm);

        if (GetPropertyHelper(szKey, pszPropName, pbData, cbData)) {
            return TRUE;
        }
    }

    psz = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\DeviceStorage\\");
    temp = wcslen(psz);
    ulLength = temp + wcslen(pszPnpID) + 1;

    if (ulLength <= MAX_KEY) {
        wcscpy(szKey, psz);
        psz = szKey + temp;
        wcscat(szKey, pszPnpID);

        while (*psz) {
            if (TEXT('\\') == *psz) {
                *psz = TEXT('#');
            }
            ++psz;
        }

        if (GetPropertyHelper(szKey, pszPropName, pbData, cbData)) {
            return TRUE;
        }
    }

    return FALSE;
}
#endif

BOOLEAN
DP_DRIVE::CheckSonyMS()
/*++

Routine Description:

    This routine determines if the given device is a Sony Memory Stick.

Arguments:

    N/A

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
#if !defined(_AUTOCHECK_)
    IO_STATUS_BLOCK             status_block;
    STORAGE_DEVICE_NUMBER       device_info;
    BYTE                        bData[30];
    DWORD                       cbData = sizeof(bData);
    PBYTE                       pbData = bData;
    HMACHINE                    hMachine = NULL;
    CONFIGRET                   cr;
    WCHAR                       szDeviceIDDisk[MAX_DEVICEID];
    WCHAR                       szVolumeName[MAX_PATH];
    DEVINST                     devinstDisk;
    DEVINST                     devinstHWDevice;
    WCHAR                       szPnpID[MAX_PNPID];
    WCHAR                       szPnpInstID[MAX_PNPINSTID];
    ULONG                       cchPnpID = sizeof(szPnpID)/sizeof(szPnpID[0]);
    ULONG                       cchPnpInstID = sizeof(szPnpInstID)/sizeof(szPnpInstID[0]);
    

    // first get device interface

    if (!GetDeviceIDDiskFromDeviceIDVolume((LPWSTR)GetNtDriveName()->GetWSTR(),
                                           szDeviceIDDisk,
                                           sizeof(szDeviceIDDisk)/sizeof(szDeviceIDDisk[0]))) {
        DebugPrintTrace(("IFSUTIL: GetDeviceIDDiskFromDeviceIDVolume failed\n"));
        return FALSE;
    }

    // now get device number

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                         NULL, 0, &device_info,
                                         sizeof(STORAGE_DEVICE_NUMBER));

    if (NT_SUCCESS(_last_status)) {

        if (device_info.DeviceType != FILE_DEVICE_DISK) {
            return TRUE;    // cannot be a memory stick
        }

        if (!GetDeviceInstance(szDeviceIDDisk, &devinstDisk)) {
            DebugPrintTrace(("IFSUTIL: GetDeviceInstance failed\n"));
            return FALSE;
        }

        /* ------------------------------------------------------------------------
        This has been commented out since if there is a removable device in the 
        chain which is not a memory stick then this will not be able to identify 
        a possible memory stick further up the chain 
        
        
        if (!GetRemovableDeviceInstRecurs(devinstDisk, &devinstHWDevice)) {
        
            DebugPrintTrace(("IFSUTIL: GetRemovableDeviceInstRecurs finds no parent\n"));

            // may be it's a non-removable reader
            // try to go up one level at a time and
            // see if we can find a match
        
          
            for (;;) {

                cr = CM_Get_Parent_Ex(&devinstHWDevice,
                                      devinstDisk,
                                      0,
                                      NULL);

                if (CR_SUCCESS != cr) {
                    DebugPrintTrace(("IFSUTIL: Unable to retrieve device parent\n"));
                    return FALSE;
                }

                cbData = sizeof(bData);

                cr = CM_Get_DevNode_Custom_Property(devinstHWDevice,
                                                    TEXT("DeviceGroup"),
                                                    NULL,
                                                    pbData,
                                                    &cbData,
                                                    NULL);

                if (CR_NO_SUCH_VALUE == cr) {
                    devinstDisk = devinstHWDevice;  // up one level
                    continue;                       // and try again
                }

                if (CR_SUCCESS != cr) {
                    DebugPrintTrace(("IFSUTIL: CM_Get_DevNode_Custom_Property (%x)\n", cr));
                    return FALSE;
                }

                if (_wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK")) == 0 ||
                    _wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK-MG")) == 0) {
                    _sony_ms = TRUE;
                    return TRUE;
                }

                devinstDisk = devinstHWDevice;  // up one level
            }
        }
        ------------------------------------------------------------------------*/

        // may be it's a non-removable reader
        // try to go up one level at a time and
        // see if we can find a match
        // once we reach the root and still do not find a memory stick 
        // we exit
        
        for (;;) {
            cbData = sizeof(bData);

            cr = CM_Get_DevNode_Custom_Property(devinstDisk,
                                                TEXT("DeviceGroup"),
                                                NULL,
                                                pbData,
                                                &cbData,
                                                NULL);

            if (CR_NO_SUCH_VALUE != cr) {
                // Check for failure or success     
                if (CR_SUCCESS != cr) {
                    DebugPrintTrace(("IFSUTIL: CM_Get_DevNode_Custom_Property (%x)\n", cr));
                    return FALSE;
                } else {
                    if (_wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK")) == 0 ||
                        _wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK-MG")) == 0) {
                        _sony_ms = TRUE;
                        return TRUE;
                    }
                }
            }

            // up one level and try again
            cr = CM_Get_Parent_Ex(&devinstHWDevice,
                                      devinstDisk,
                                      0,
                                      NULL);

            if (CR_SUCCESS != cr) {
                // if can't find parent, end search for mem stick
                DebugPrintTrace(("IFSUTIL: Unable to retrieve device parent\n"));
                return FALSE;
            } else {
                devinstDisk = devinstHWDevice;
            }
            
        }
        
        DebugAssert(FALSE); // should never get here
    
    } else {

        if (!GetDeviceInstance(szDeviceIDDisk, &devinstHWDevice)) {
            DebugPrintTrace(("IFSUTIL: GetDeviceInstance failed\n"));
            return FALSE;
        }
    }

    cr = CM_Get_DevNode_Custom_Property(devinstHWDevice,
                                        TEXT("DeviceGroup"),
                                        NULL,
                                        pbData,
                                        &cbData,
                                        NULL);

    if (CR_SUCCESS != cr) {
        DebugPrintTrace(("IFSUTIL: CM_Get_DevNode_Custom_Property (%x)\n", cr));
        return FALSE;
    }

    if (_wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK")) == 0 ||
        _wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK-MG")) == 0) {
        _sony_ms = TRUE;
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\spaset.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "spaset.hxx"

extern "C" {
#include "stdio.h"
}

DEFINE_EXPORTED_CONSTRUCTOR( SPARSE_SET, OBJECT, IFSUTIL_EXPORT );

typedef union {
    ULONG   x;
    struct {
        USHORT  y1;
        USHORT  y2;
    } y;
    struct {
        UCHAR   z1;
        UCHAR   z2;
        UCHAR   z3;
        UCHAR   z4;
    } z;
} HASH_KEY;

VOID
SPARSE_SET::Construct (
        )
/*++

Routine Description:

    Constructor for SPARSE_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _card = 0;
    _hashTable = NULL;
}


VOID
SPARSE_SET::Destroy(
    )
/*++

Routine Description:

    This routine returns the SPARSE_SET to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PHASH_ELEMENT   hashElementPtr;
    USHORT          i;

    _card = 0;
    if (_hashTable == NULL)
        return;

    hashElementPtr = _hashTable;
    for (i=0; i<SPA_SET_HASH_TABLE_SIZE; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    FREE(_hashTable);
}


IFSUTIL_EXPORT
SPARSE_SET::~SPARSE_SET(
    )
/*++

Routine Description:

    Destructor for SPARSE_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
SPARSE_SET::Initialize(
    )
/*++

Routine Description:

    This routine initializes the set for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PHASH_ELEMENT   hashElementPtr;
    USHORT          i;

    Destroy();

    _hashTable = (PHASH_ELEMENT)MALLOC(sizeof(HASH_ELEMENT)*SPA_SET_HASH_TABLE_SIZE);
    if (_hashTable == NULL)
        return FALSE;

    hashElementPtr = _hashTable;
    for (i=0; i<SPA_SET_HASH_TABLE_SIZE; i++) {
        hashElementPtr->elements = NULL;
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
SPARSE_SET::CheckAndAdd(
    IN  BIG_INT   Number,
    OUT PBOOLEAN  Duplicate
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number    - Supplies the number to add to the set.
    Duplicate - Returns TRUE if Number already exists in the set

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HASH_KEY        key;
    UCHAR           hashKey;
    PHASH_ELEMENT   hashElementPtr;
    PBIG_INT        tmpPtr;
    PBIG_INT        elementPtr;
    BOOLEAN         duplicate;
    ULONG           i;


    if (Duplicate == NULL)
        Duplicate = &duplicate;

    *Duplicate = FALSE;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    key.x = Number.GetLowPart() ^ Number.GetHighPart();
    hashKey = key.z.z1 ^ key.z.z2 ^ key.z.z3 ^ key.z.z4;

    hashElementPtr = &(_hashTable[hashKey]);
    if (hashElementPtr->elements == NULL) {
        hashElementPtr->elements = (PBIG_INT)MALLOC(sizeof(BIG_INT)*
                                                    SPA_SET_HASH_ELEMENT_INC);
        if (hashElementPtr->elements == NULL)
            return FALSE;
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = SPA_SET_HASH_ELEMENT_INC;
    }

    //
    // Check for duplicates
    //

    elementPtr = hashElementPtr->elements;
    DebugAssert(hashElementPtr->elementCount.GetHighPart() == 0);
    for (i=0; i<hashElementPtr->elementCount; i++) {
        if (*(elementPtr++) == Number)
            return (*Duplicate = TRUE);
    }

    if (hashElementPtr->elementCount == hashElementPtr->maxElementCount) {
        DebugAssert(hashElementPtr->maxElementCount.GetHighPart() == 0);
        tmpPtr = (PBIG_INT)REALLOC(hashElementPtr->elements,
                                   sizeof(BIG_INT)*
                                   (SPA_SET_HASH_ELEMENT_INC +
                                    hashElementPtr->maxElementCount.GetLowPart()));
        if (tmpPtr == NULL)
            return FALSE;
        hashElementPtr->elements = tmpPtr;
        hashElementPtr->maxElementCount += SPA_SET_HASH_ELEMENT_INC;
    }

        DebugAssert(hashElementPtr->elementCount.GetHighPart() == 0);
    hashElementPtr->elements[hashElementPtr->elementCount.GetLowPart()] = Number;
    hashElementPtr->elementCount += 1;
    DebugAssert(hashElementPtr->elementCount <= hashElementPtr->maxElementCount);
    _card += 1;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
SPARSE_SET::RemoveAll(
     )
{
    PHASH_ELEMENT   hashElementPtr;
    USHORT          i;

    DebugPtrAssert(_hashTable);
    hashElementPtr = _hashTable;
    _card = 0;
    for (i=0; i<SPA_SET_HASH_TABLE_SIZE; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
SPARSE_SET::CheckAndRemove(
    IN  BIG_INT     Number,
     OUT PBOOLEAN   DoesExists
    )
/*++

Routine Description:

    This routine removes a number from the number set.

Arguments:

    Number      - Supplies the number to remove.
    DoesExists  - TRUE if Number was found in the set

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HASH_KEY        key;
    UCHAR           hashKey;
    PBIG_INT        elementPtr;
    PHASH_ELEMENT   hashElementPtr;
    BOOLEAN         doesExist;
    ULONG           i;

    if (DoesExists == NULL)
        DoesExists = &doesExist;

    *DoesExists = TRUE;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    key.x = Number.GetLowPart() ^ Number.GetHighPart();
    hashKey = key.z.z1 ^ key.z.z2 ^ key.z.z3 ^ key.z.z4;

    hashElementPtr = &(_hashTable[hashKey]);
    if (hashElementPtr->elements == NULL) {
        *DoesExists = FALSE;
        return TRUE;
    }

    //
    // Check for existence
    //

    elementPtr = hashElementPtr->elements;
    DebugAssert(hashElementPtr->elementCount.GetHighPart() == 0);
    for (i=0; i<hashElementPtr->elementCount; i++) {
        if (*(elementPtr++) == Number) {
            if (hashElementPtr->elementCount == 1) {
                FREE(hashElementPtr->elements);
            } else {
                DebugAssert(hashElementPtr->elementCount > 1);
                hashElementPtr->elementCount -= 1;
                *(--elementPtr) = hashElementPtr->elements[
                                    hashElementPtr->elementCount.GetLowPart()];
            }
            _card -= 1;
            return TRUE;
        }
    }
    *DoesExists = FALSE;
    return TRUE;
}

IFSUTIL_EXPORT
VOID
SPARSE_SET::DumpHashTable(
    )
/*++

Routine Description:

    This routine dumps out the hash table

--*/
{
#if 0
    USHORT          i;
    PHASH_ELEMENT   hashElementPtr;

    hashElementPtr = _hashTable;
    for (i=0; i<SPA_SET_HASH_TABLE_SIZE; i++) {
        if (hashElementPtr->elements != NULL) {
            printf("%d, %d\n", i, hashElementPtr->elementCount);
        }
        hashElementPtr++;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\secrun.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "secrun.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( SECRUN, OBJECT, IFSUTIL_EXPORT );


VOID
SECRUN::Construct (
        )

/*++

Routine Description:

    Constructor for class SECRUN.  This function initializes the
    member variables to "dummy" states.  The member function 'Init'
    must be called to make this class "work".

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _drive = NULL;
    _start_sector = 0;
    _num_sectors = 0;
}


VOID
SECRUN::Destroy(
    )
/*++

Routine Description:

    This routine puts the object back into its initial and empty state.
    It is not necessary to call this function between calls to 'Init'
    as Init will call this function automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _drive = NULL;
    _start_sector = 0;
    _num_sectors = 0;
}


IFSUTIL_EXPORT
SECRUN::~SECRUN(
    )
/*++

Routine Description:

    Destructor of sector run object.  Returns references.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Initialize(
    IN OUT  PMEM            Mem,
    IN OUT  PIO_DP_DRIVE    Drive,
    IN      BIG_INT         StartSector,
    IN      SECTORCOUNT     NumSectors
    )
/*++

Routine Description:

    This member function initializes the class so that reads and writes
    may take place.

Arguments:

    Mem                 - Supplies means by which to acquire sufficient memory.
    Drive               - Supplies drive interface.
    StartSector         - Supplies starting LBN.
    NumSector           - Supplies the number of LBNs.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    ULONG   size;

    Destroy();

    DebugAssert(Drive);
    DebugAssert(Mem);

    _drive = Drive;
    _start_sector = StartSector;
    _num_sectors = NumSectors;
    size = _num_sectors*_drive->QuerySectorSize();
    _buf = Mem->Acquire(size, _drive->QueryAlignmentMask());

    if (!size || !_buf) {
        return FALSE;
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Read(
    )
/*++

Routine Description:

    This member function reads the sectors on disk into memory.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(_buf);
    return _drive->Read(_start_sector, _num_sectors, _buf);
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Write(
    )
/*++

Routine Description:

    This member function writes onto the disk.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(_buf);
    return _drive->Write(_start_sector, _num_sectors, _buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ifsutil
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib    \
    ..\..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\cfgmgr32.lib \
    $(SDK_LIB_PATH)\setupapi.lib \
    $(SDK_LIB_PATH)\ntdll.lib

USE_MSVCRT=1

DLLENTRY=InitializeIfsUtil

PRECOMPILED_INCLUDE= ..\pch.cxx

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\autoentr.cxx    \
        ..\autoreg.cxx     \
        ..\bigint.cxx      \
        ..\bootreg.c       \
        ..\cache.cxx       \
        ..\cannedsd.cxx    \
        ..\dcache.cxx      \
        ..\digraph.cxx     \
        ..\drive.cxx       \
        ..\ifssys.cxx      \
        ..\ifsutil.cxx     \
        ..\intstack.cxx    \
        ..\mldcopy.cxx     \
        ..\mpmap.cxx       \
        ..\numset.cxx      \
        ..\rcache.cxx      \
        ..\rwcache.cxx     \
        ..\secrun.cxx      \
        ..\smsdtect.cxx    \
        ..\spaset.cxx      \
        ..\supera.cxx      \
        ..\tlink.cxx       \
        ..\volume.cxx      \
        ..\ifsutil.rc

INCLUDES= \
    ..;\
    ..\..\inc;\
    ..\..\..\ulib\inc; \
    $(DS_INC_PATH)\crypto; \
    $(DDK_INC_PATH)

C_DEFINES=-DUNICODE=1 -DSTRICT=1

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console

DLLDEF=

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\supera.cxx ===
#include <pch.cxx>

#if i386
//
// Temporarily disable optimizations until cl386 Drop 077 is fixed.
//
#pragma optimize("",off)
#endif

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "supera.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ifssys.hxx"

#define MaxLabelLength      1024

DEFINE_EXPORTED_CONSTRUCTOR( SUPERAREA, SECRUN, IFSUTIL_EXPORT );

IFSUTIL_EXPORT
SUPERAREA::~SUPERAREA(
    )
/*++

Routine Description:

    Destructor for SUPERAREA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
SUPERAREA::Construct(
        )
/*++

Routine Description:

        Constructor for SUPERAREA.

Arguments:

        None.

Return Value:

        None.

--*/
{
    _drive = NULL;
}


VOID
SUPERAREA::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state freeing up
    any memory in the process.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


IFSUTIL_EXPORT
BOOLEAN
SUPERAREA::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      SECTORCOUNT         NumberOfSectors,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine initializes the SUPERAREA for the given drive.

Arguments:

    Mem             - Supplies necessary memory for the underlying sector run.
    Drive           - Supplies the drive where the superarea resides.
    NumberOfSectors - Supplies the number of sectors in the superarea.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(Drive);
    DebugAssert(NumberOfSectors);

    if (!SECRUN::Initialize(Mem, Drive, 0, NumberOfSectors)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    _drive = Drive;

    return TRUE;
}


IFSUTIL_EXPORT
VOLID
SUPERAREA::ComputeVolId(
    IN  VOLID   Seed
    )
/*++

Routine Description:

    This routine computes a new and unique volume identifier.

Arguments:

    None.

Return Value:

    A unique volume id.

--*/
{
    VOLID           volid;
    PUCHAR          p;
    INT             i;
    LARGE_INTEGER   NtfsTime;

    if (Seed) {
        volid = Seed;
    } else {
        volid = 0;
    }

    do {

        if (!volid) {
            IFS_SYSTEM::QueryNtfsTime( &NtfsTime );
            if (NtfsTime.LowPart) {
                volid = (VOLID) NtfsTime.LowPart;
            } else {
                volid = (VOLID) NtfsTime.HighPart;
            }

            if (volid == 0) { // This should never happen.
                volid = 0x11111111;
            }
        }

        p = (PUCHAR) &volid;
        for (i = 0; i < sizeof(VOLID); i++) {
            volid += *p++;
            volid = (volid >> 2) + (volid << 30);
        }

    } while (!volid);

    return volid;
}

NTSTATUS
SUPERAREA::FormatNotification(
    IN     PWSTRING                        Label,
       OUT PFILE_FS_SIZE_INFORMATION       FsSizeInfo,
       OUT PFILE_FS_VOLUME_INFORMATION     FsVolInfo
    )
/*++

Routine Description:

    This routine sets the volume label which serves as a notification
    to the rest of the system that format has completed and the volume
    is avaiable for use again.

Arguments:

    Label        - Supplies the volume label.  If NULL, the current volume
                   label will be used.
    FsSizeInfo   - Retrieves the File System Size Information
    FsVolInfo    - Retrieves the File System Volume Information

Return Value:

    NT status

--*/
{
    //
    // Close the current drive handle first
    //
    _drive->CloseDriveHandle();

    return SUPERAREA::GenerateLabelNotification(_drive->GetNtDriveName(),
                                                Label,
                                                FsSizeInfo,
                                                FsVolInfo);
}

NTSTATUS
SUPERAREA::GenerateLabelNotification(
    IN     PCWSTRING                       NtDriveName,
    IN     PWSTRING                        Label,
       OUT PFILE_FS_SIZE_INFORMATION       FsSizeInfo,
       OUT PFILE_FS_VOLUME_INFORMATION     FsVolInfo
    )
/*++

Routine Description:

    This routine sets the volume label which serves as a notification
    to the rest of the system that the volume has changed.

Arguments:

    NtDriveName  - Supplies the name of the volume.
    Label        - Supplies the volume label.  If NULL, the current volume
                   label will be used.
    FsSizeInfo   - Retrieves the File System Size Information
    FsVolInfo    - Retrieves the File System Volume Information

Return Value:

    NT status

--*/
{
    CONST                       vollen = sizeof(FILE_FS_VOLUME_INFORMATION) +
                                         MaxLabelLength;
    CONST                       lablen = sizeof(FILE_FS_LABEL_INFORMATION) +
                                         MaxLabelLength;
    PFILE_FS_VOLUME_INFORMATION volinfo;
    PFILE_FS_LABEL_INFORMATION  labinfo;
    STR                         vol_info_buf[vollen];
    STR                         lab_info_buf[lablen];

    IO_STATUS_BLOCK             status_block;
    NTSTATUS                    status;

    PCWSTRING                   ntDriveName;
    UNICODE_STRING              string;
    OBJECT_ATTRIBUTES           oa;
    HANDLE                      handle;

    ntDriveName = NtDriveName;

    string.Length = (USHORT) ntDriveName->QueryChCount() * sizeof(WCHAR);
    string.MaximumLength = string.Length;
    string.Buffer = (PWSTR)ntDriveName->GetWSTR();

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT | FILE_WRITE_THROUGH);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("IFSUTIL: Unable to open handle with status %x\n", status));
        return status;
    }

    // status is good at this point

    if (FsVolInfo) {

        status = NtQueryVolumeInformationFile(handle,
                                              &status_block,
                                              FsVolInfo,
                                              sizeof(*FsVolInfo),
                                              FileFsVolumeInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to query file system volume information with status %x\n", status));
        }
    }

    if (NT_SUCCESS(status) &&
        FsSizeInfo) {
        status = NtQueryVolumeInformationFile(handle,
                                              &status_block,
                                              FsSizeInfo,
                                              sizeof(*FsSizeInfo),
                                              FileFsSizeInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to query file system size information with status %x\n", status));
        }
    }

    if (NT_SUCCESS(status) &&
        Label == NULL) {
        volinfo = (PFILE_FS_VOLUME_INFORMATION) vol_info_buf;

        status = NtQueryVolumeInformationFile(handle,
                                              &status_block,
                                              volinfo,
                                              vollen,
                                              FileFsVolumeInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to query volume label with status %x\n", status));
        }
    }

    if (NT_SUCCESS(status)) {

        labinfo = (PFILE_FS_LABEL_INFORMATION)lab_info_buf;

        if (Label == NULL) {
            labinfo->VolumeLabelLength = volinfo->VolumeLabelLength;
            memcpy(labinfo->VolumeLabel, volinfo->VolumeLabel, labinfo->VolumeLabelLength);
        } else {
            labinfo->VolumeLabelLength = Label->QueryChCount()*sizeof(WCHAR);
            memcpy(labinfo->VolumeLabel, Label->GetWSTR(), labinfo->VolumeLabelLength);
        }

        status = NtSetVolumeInformationFile(handle,
                                            &status_block,
                                            labinfo,
                                            lablen,
                                            FileFsLabelInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to set volume label with status %x\n", status));
        }
    }

    NtClose(handle);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\tlink.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

extern "C" {
    #include <stdio.h>
}

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "tlink.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( TLINK, OBJECT, IFSUTIL_EXPORT );

VOID
TLINK::Construct (
        )
/*++

Routine Description:

    Constructor for TLINK.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _array = NULL;
    _size = _maxSize = 0;
}

VOID
TLINK::Destroy(
    )
/*++

Routine Description:

    This routine returns the TLINK to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_array);
    _array = NULL;
    _size = _maxSize = 0;
}

IFSUTIL_EXPORT
TLINK::~TLINK(
    )
/*++

Routine Description:

    Destructor for TLINK.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
TLINK::Initialize(
    IN  USHORT  Size
    )
/*++

Routine Description:

    This routine initializes the triple link list for insertion.

Arguments:

    Size    - Supplies the maximum number of elements that will be in the list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();
    if ((_array = (PBIG_INT_NODE)MALLOC((Size+2)*sizeof(BIG_INT_NODE))) == NULL)
        return FALSE;
    _maxSize = Size;
    _array[0].prev = NULL;
    _array[0].next = &(_array[1]);
    _array[0].buffer = NULL;
    return TRUE;
}

RBIG_INT
TLINK::GetNextDataSlot(
)
/*++

Routine Description:

    This routine returns a reference to the next available data slot.

NOTE:

    USER IS RESPONSIBLE FOR NOT ACCESSING BEYOND THE BOUNDARY OF THE LINK LIST.

Arguments:

    None.

Return Value:

    A reference to the BIG_INT of the next available slot in the link list.

--*/
{
    PBIG_INT_NODE   pArray;

    DebugAssert(_size < _maxSize);

    pArray = _array + ++_size;

    pArray->buffer = NULL;
    pArray->next = pArray+1;
    pArray->prev = pArray-1;
    return pArray->data;
}


NONVIRTUAL
IFSUTIL_EXPORT
PVOID
TLINK::QueryDisjointRangeAndAssignBuffer(
    OUT PBIG_INT        Start,
    OUT PUSHORT         Length,
    OUT PUSHORT         EffectiveLength,
    IN  PVOID           Buffer,
    IN  ULONG           DataSize,
    IN  PVOID           Pnode
)
/*++

Routine Description:

    This routine returns the start and length of a disjoint set starting at the
    given node.  It also assigns the appropriate buffer address to the
    corresponding data node.

Arguments:

    Start       - receives the first data value in given Pnode.
    Length      - receives the number of elements in the disjoint range.
    EffectiveLength
                - receives the number of distinct elements in the disjoint range.
    Buffer      - supplies the start address of the buffer for the given Pnode.
    DataSize    - supplies the length of the buffer for each node.
    Pnode       - supplies the first node in the disjoint range

Return Value:

    Points to the first node after the disjoint range

--*/
{
    BIG_INT next_data_value;
    PCHAR   dataPtr;

    DebugPtrAssert(Pnode);
    DebugPtrAssert(Start);
    DebugPtrAssert(Length);
    DebugPtrAssert(EffectiveLength);
    DebugPtrAssert(Buffer);

    dataPtr = (PCHAR)Buffer;

    *Length = 0;
    *EffectiveLength = 1;
    *Start = ((PBIG_INT_NODE)Pnode)->data;
    next_data_value = *Start + 1;
    ((PBIG_INT_NODE)Pnode)->buffer = Buffer;
    Pnode = ((PBIG_INT_NODE)Pnode)+1;

    for (;;) {
        if ((((PBIG_INT_NODE)Pnode)-1)->data == ((PBIG_INT_NODE)Pnode)->data) {
            ((PBIG_INT_NODE)Pnode)->buffer = dataPtr;
            (*Length)++;
            Pnode = ((PBIG_INT_NODE)Pnode)+1;
        } else if (next_data_value == ((PBIG_INT_NODE)Pnode)->data) {
            next_data_value += 1;
            (*EffectiveLength)++;
            dataPtr += DataSize;
            ((PBIG_INT_NODE)Pnode)->buffer = dataPtr;
            Pnode = ((PBIG_INT_NODE)Pnode)+1;
        } else
            break;
    }
    *Length += *EffectiveLength;
    return Pnode;
}

#if DBG == 1
IFSUTIL_EXPORT
void
TLINK::TraverseLinkList(
    )
/*++

Routine Description:

    This routine prints the link list in sorted, initial forward, and initial
    reverse orders.

Arguments:

Return Value:

    N/A

--*/
{
#if 0
    USHORT          i;
    PBIG_INT_NODE   pNode;

    printf("Sorted order:\n");
    for (i=1; i<=_size; i++) {
        printf("[%d]=%x ", i, _array[i].data.GetLowPart());
    }
    printf("\n");

    printf("Initial forward order:\n");
    pNode = _array->next;
    i=1;
    while (i <= _size) {
        printf("[%d]=%x ", i++, pNode->data.GetLowPart());
        pNode = pNode->next;
    }
    printf("\n");

    printf("Initial reverse order:\n");
    pNode = _array[_size+1].prev;
    i=_size;
    while (i > 0) {
        printf("[%d]=%x ", i--, pNode->data.GetLowPart());
        pNode = pNode->prev;
    }
    printf("\n");
#endif
}

IFSUTIL_EXPORT
void
TLINK::CheckLinkList(
    )
/*++

Routine Description:

    This routine checks the link list to make sure it is sorted
    correctly.

Arguments:

Return Value:

    N/A

--*/
{
    USHORT  i;

    for (i=1; i<_size; i++) {
        DebugAssert(_array[i].data <= _array[i+1].data);
    }
}
#endif

IFSUTIL_EXPORT
void
TLINK::ShellSort(
    )
/*++

Routine Description:

    This routine sorts the given list using quick sort algorithm.

Arguments:

    pHeadRec        - supplies the first node in the link list.
    pTailRec        - supplies the last node in the link list.

Return Value:

    N/A

--*/
{
    USHORT          i, incr;
    INT             j;
    BIG_INT         tmp;
    PBIG_INT_NODE   pLeft, pRight, lPrev, lNext, rPrev, rNext;

    incr = _size / 2;
    while (incr > 0) {
        for (i=incr+1; i<=_size; i++) {
            j = i - incr;
            while (j > 0) {
                if (_array[j].data > _array[j+incr].data) {

                    pLeft = _array+j;
                    pRight = _array+j+incr;

                    tmp = pLeft->data;
                    pLeft->data = pRight->data;
                    pRight->data = tmp;

                    lPrev = pLeft->prev;
                    lNext = pLeft->next;
                    rPrev = pRight->prev;
                    rNext = pRight->next;

                    if (pLeft == rPrev) {
                        DebugAssert(lNext == pRight);
                        lPrev->next = pLeft->prev = pRight;
                        pRight->next = rNext->prev = pLeft;

                        pRight->prev = lPrev;
                        pLeft->next = rNext;
                    } else if (pRight == lPrev) {
                        DebugAssert(pLeft == rNext);
                        rPrev->next = pRight->prev = pLeft;
                        pLeft->next = lNext->prev = pRight;

                        pLeft->prev = rPrev;
                        pRight->next = lNext;
                    } else {
                        lPrev->next = lNext->prev = pRight;
                        pRight->prev = lPrev;
                        pRight->next = lNext;

                        rPrev->next = rNext->prev = pLeft;
                        pLeft->prev = rPrev;
                        pLeft->next = rNext;
                    }
                    j -= incr;
                } else
                    break;
            }
        }
        incr /= 2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\com.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    Com

Abstract:

    Takes care of request involving a COM device

Author:

    Ramon Juan San Andres (ramonsa) 26-Jun-1991

Revision History:

--*/



#include "mode.hxx"
#include "com.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "file.hxx"
#include "path.hxx"
#include "registry.hxx"
#include "regvalue.hxx"


#define     DEFAULT_PARITY      COMM_PARITY_EVEN
#define     DEFAULT_DATA_BITS   7




//
//  Local prototypes
//
BOOLEAN
ComStatus(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
ComSetup(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
IsAValidCommDevice (
    IN  DEVICE_TTYPE     DeviceType,
    IN  ULONG           DeviceNumber,
    OUT PPATH           *DevicePathPointer
    );






BOOLEAN
ComAllocateStuff(
    )

/*++

Routine Description:

    Initializes Data Structures used for COMM processing.

Arguments:

    nonde

Return Value:

    BOOLEAN -   TRUE if global data initialized, FALSE otherwise

Notes:

--*/

{

    return TRUE;

}

BOOLEAN
ComDeAllocateStuff(
    )

/*++

Routine Description:

    Deallocates the stuff allocated by ComAllocateStuff.

Arguments:

    nonde

Return Value:

    BOOLEAN -   TRUE if global data de-initialized, FALSE otherwise

Notes:

--*/

{

    return TRUE;

}

BOOLEAN
ComHandler(
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Handles serial port requests.

Arguments:

    Request -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if request serviced,
                FALSE otherwise.

Notes:

--*/

{


    PPATH   DevicePath;     //  Name of Device
    BOOLEAN Served = TRUE;  //  TRUE if request served OK.

    DebugPtrAssert( Request );
    DebugAssert( Request->DeviceType == DEVICE_TYPE_COM );

    //
    //  Make sure that the device exists, and at the same time get its
    //  name ( For calling APIs ).
    //
    if ( Request->DeviceName ) {

        if (!(DevicePath = NEW PATH)) {
            DisplayMessageAndExit( MODE_ERROR_NO_MEMORY,
                                   NULL,
                                   (ULONG)EXIT_ERROR );
            return FALSE;   // help lint
        }
        DevicePath->Initialize( Request->DeviceName );

    } else {

        if ( !IsAValidCommDevice( Request->DeviceType, Request->DeviceNumber, &DevicePath )) {

            DisplayMessageAndExit( MODE_ERROR_INVALID_DEVICE_NAME,
                                   DevicePath->GetPathString(),
                                   (ULONG)EXIT_ERROR );

        } else if ( !IsAValidDevice( Request->DeviceType, Request->DeviceNumber, NULL  ) ) {

            DisplayMessageAndExit( MODE_ERROR_DEVICE_UNAVAILABLE,
                                   DevicePath->GetPathString(),
                                   (ULONG)EXIT_ERROR );

        }
    }

    //
    //  So the device is valid. Now serve the request
    //
    switch( Request->RequestType ) {

    case REQUEST_TYPE_STATUS:

        //
        //  Display state of COM device
        //
        Served = ComStatus( DevicePath, Request );
        break;

    case REQUEST_TYPE_COM_SET:

        //
        //  Set state of COM device
        //
        Served = ComSetup( DevicePath, Request );
        break;

    default:

        DebugAssert( FALSE );

    }

    DELETE( DevicePath );

    return Served;

}

BOOLEAN
ComStatus(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Displays status if a COM device

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if status displayed successfully,
                FALSE otherwise

Notes:

--*/

{
    DSTRING                 Data;
    COMM_DEVICE             CommDevice;     //  Comm object of the device.
    BOOLEAN                 OpenError;
    BOOLEAN                 Status;

    DebugPtrAssert( DevicePath );
    DebugPtrAssert( Request );

    //
    //  Initialize the Comm object
    //
    Status = CommDevice.Initialize( DevicePath, &OpenError);


    if ( Status ) {

        //
        //  Write the Header
        //
        WriteStatusHeader( DevicePath );


        //
        //  Baud rate
        //
        Data.Initialize( (ULONG)CommDevice.QueryBaudRate() );
        DisplayMessage( MODE_MESSAGE_STATUS_BAUD, &Data );


        //
        //  Parity
        //
        switch ( CommDevice.QueryParity() ) {

        case COMM_PARITY_NONE:
            Data.Initialize( "None" );
            break;

        case COMM_PARITY_ODD:
            Data.Initialize( "Odd" );
            break;

        case COMM_PARITY_EVEN:
            Data.Initialize( "Even" );
            break;

        case COMM_PARITY_MARK:
            Data.Initialize( "Mark" );
            break;

        case COMM_PARITY_SPACE:
            Data.Initialize( "Space" );
            break;

        default:
            DebugAssert( FALSE );
        }

        DisplayMessage( MODE_MESSAGE_STATUS_PARITY, &Data );


        //
        //  Data bits
        //
        Data.Initialize( (ULONG)CommDevice.QueryDataBits() );
        DisplayMessage( MODE_MESSAGE_STATUS_DATA, &Data );


        //
        //  Stop bits
        //
        switch ( CommDevice.QueryStopBits() ) {

        case COMM_STOPBITS_15:
            Data.Initialize( "1.5" );
            break;

        case COMM_STOPBITS_1:
            Data.Initialize( 1 );
            break;

        case COMM_STOPBITS_2:
            Data.Initialize( 2 );
            break;

        default:
            DebugAssert( FALSE );
        }

        DisplayMessage( MODE_MESSAGE_STATUS_STOP, &Data );


        //
        //  TimeOut
        //
        if ( CommDevice.QueryTimeOut() ) {
            //
            //  TRUE means infinite timeout == no timeout
            //
            Data.Initialize( "OFF" );
        } else {
            Data.Initialize( "ON" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_TIMEOUT, &Data );


        //
        //  XON/XOFF
        //
        if ( CommDevice.QueryXon() ) {
            Data.Initialize( "ON" );
        } else {
            Data.Initialize( "OFF" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_XON, &Data );


        //
        //  CTS
        //
        if ( CommDevice.QueryOcts() ) {
            Data.Initialize( "ON" );
        } else {
            Data.Initialize( "OFF" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_OCTS, &Data );

        //
        //  DSR handshaking
        //
        if ( CommDevice.QueryOdsr() ) {
            Data.Initialize( "ON" );
        } else {
            Data.Initialize( "OFF" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_ODSR, &Data );

        //
        //  DSR sensitivity
        //
        if ( CommDevice.QueryIdsr() ) {
            Data.Initialize( "ON" );
        } else {
            Data.Initialize( "OFF" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_IDSR, &Data );

        //
        //  DTR
        //
        switch( CommDevice.QueryDtrControl() ) {

        case DTR_ENABLE:
            Data.Initialize( "ON" );
            break;

        case DTR_DISABLE:
            Data.Initialize( "OFF" );
            break;

        case DTR_HANDSHAKE:
            Data.Initialize( "HANDSHAKE" );
            break;

        default:
            Data.Initialize( "UNKNOWN" );
            break;

        }
        DisplayMessage( MODE_MESSAGE_STATUS_DTR, &Data );


        //
        //  RTS
        //
        switch( CommDevice.QueryRtsControl() ) {

        case RTS_ENABLE:
            Data.Initialize( "ON" );
            break;

        case RTS_DISABLE:
            Data.Initialize( "OFF" );
            break;

        case RTS_HANDSHAKE:
            Data.Initialize( "HANDSHAKE" );
            break;

        case RTS_TOGGLE:
            Data.Initialize( "TOGGLE" );
            break;

        default:
            Data.Initialize( "UNKNOWN" );
            break;

        }
        DisplayMessage( MODE_MESSAGE_STATUS_RTS, &Data );

        Get_Standard_Output_Stream()->WriteChar( '\r' );
        Get_Standard_Output_Stream()->WriteChar( '\n' );

    } else if ( !OpenError ) {

        DisplayMessage( MODE_ERROR_CANNOT_ACCESS_DEVICE,
                        DevicePath->GetPathString() );

        Status = TRUE;
    }

    return Status;
}



BOOLEAN
ComSetup(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Sets the state of a COM port

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if state set successfully,
                FALSE otherwise

Notes:

--*/

{

    PCOMM_DEVICE            CommDevice;     //  Comm object of the device.
    BOOLEAN                 Status = FALSE; //  Indicates success or failure
    PREQUEST_DATA_COM_SET   Data;           //  Request data
    BOOLEAN                 OpenError;
    DSTRING                 Number;

    DebugPtrAssert( DevicePath );
    DebugPtrAssert( Request );

    //
    //  Initialize the Comm object
    //
    CommDevice = NEW COMM_DEVICE;
    if ( !CommDevice ) {
        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
        return FALSE;   // help lint
    }
    Status = CommDevice->Initialize( DevicePath, &OpenError );
    if ( Status ) {

        //
        //  We have the Comm object. Set the state according to
        //  the request.
        //
        Data = &(((PCOM_REQUEST)Request)->Data.Set);

        //
        //  Baud rate
        //
        if ( Data->SetBaud ) {

            CommDevice->SetBaudRate( Data->Baud );

        }

        //
        //  Data Bits
        //
        if ( Data->SetDataBits ) {

            CommDevice->SetDataBits( Data->DataBits );

        } else {

            //
            //  Set default
            //
            if ( CommDevice->QueryDataBits() != DEFAULT_DATA_BITS ) {
                CommDevice->SetDataBits( DEFAULT_DATA_BITS );
                Number.Initialize( DEFAULT_DATA_BITS );
                DisplayMessage( MODE_MESSAGE_USED_DEFAULT_DATA, &Number );
            }
        }

        //
        //  Stop Bits
        //
        if ( Data->SetStopBits ) {

            CommDevice->SetStopBits( Data->StopBits );

        } else {

            //
            //  Set default
            //
            if ( CommDevice->QueryBaudRate() == 110 ) {
                if ( CommDevice->QueryStopBits() != COMM_STOPBITS_2 ) {
                    CommDevice->SetStopBits( COMM_STOPBITS_2 );
                    Number.Initialize( 2 );
                    DisplayMessage( MODE_MESSAGE_USED_DEFAULT_STOP, &Number );
                }
            } else {
                if ( CommDevice->QueryStopBits() != COMM_STOPBITS_1 ) {
                    CommDevice->SetStopBits( COMM_STOPBITS_1 );
                    Number.Initialize( 1 );
                    DisplayMessage( MODE_MESSAGE_USED_DEFAULT_STOP, &Number );
                }
            }
        }

        //
        //  Parity
        //
        if ( Data->SetParity ) {

            CommDevice->SetParity( Data->Parity );

        } else {

            //
            //  Set default
            //
            if ( CommDevice->QueryParity() != DEFAULT_PARITY ) {
                CommDevice->SetParity( DEFAULT_PARITY );
                DisplayMessage( MODE_MESSAGE_USED_DEFAULT_PARITY, NULL );
            }
        }

        //
        //  Timeout
        //
        if ( Data->SetTimeOut ) {

            CommDevice->SetTimeOut( Data->TimeOut );

        }


        //
        //  XON/XOFF
        //
        if ( Data->SetXon) {

            CommDevice->SetXon( Data->Xon );

        }


        //
        //  CTS
        //
        if ( Data->SetOcts ) {

            CommDevice->SetOcts( Data->Octs );
        }

        //
        //  DSR handshaking
        //
        if ( Data->SetOdsr ) {

            CommDevice->SetOdsr( Data->Odsr );
        }

        //
        //  DSR sensitivity
        //
        if ( Data->SetIdsr ) {

            CommDevice->SetIdsr( Data->Idsr );
        }

        //
        //  DTR
        //
        if ( Data->SetDtrControl ) {

            CommDevice->SetDtrControl( Data->DtrControl );
        }

        //
        //  RTS
        //
        if ( Data->SetRtsControl ) {

            CommDevice->SetRtsControl( Data->RtsControl );
        }

        //
        //  Now Commit the changes
        //
        if ( !CommDevice->CommitState() ) {

            DisplayMessage( MODE_ERROR_SERIAL_OPTIONS_NOT_SUPPORTED, NULL );
            DisplayMessageAndExit( MODE_MESSAGE_COM_NO_CHANGE,
                                   NULL,
                                   (ULONG)EXIT_ERROR );
        }

    } else if ( !OpenError ) {

        DisplayMessageAndExit( MODE_ERROR_CANNOT_ACCESS_DEVICE,
                               DevicePath->GetPathString(),
                               (ULONG)EXIT_ERROR );
    }

    DELETE( CommDevice );

    if ( Status ) {
        //
        //  Display the status of the port (as confirmation ).
        //
        ComStatus( DevicePath, Request );

    }

    return Status;
}


LONG
ConvertBaudRate (
    IN  LONG                BaudIn
    )

/*++

Routine Description:

    Validates a baud rate given as an argument to the program, and converts
    it to something that the COMM_DEVICE understands.

Arguments:

    BaudIn      -   Supplies the baud rate given by the user

Return Value:

    LONG    -   The baud rate


--*/

{
    LONG    BaudRate;

    switch ( BaudIn ) {

    case 11:
    case 110:
        BaudRate = 110;
        break;

    case 15:
    case 150:
        BaudRate = 150;
        break;

    case 30:
    case 300:
        BaudRate = 300;
        break;

    case 60:
    case 600:
        BaudRate = 600;
        break;

    case 12:
    case 1200:
        BaudRate = 1200;
        break;

    case 24:
    case 2400:
        BaudRate = 2400;
        break;

    case 48:
    case 4800:
        BaudRate = 4800;
        break;

    case 96:
    case 9600:
        BaudRate = 9600;
        break;

    case 19:
    case 19200:
        BaudRate = 19200;
        break;

    default:
        BaudRate = BaudIn;

    }

    return BaudRate;
}


LONG
ConvertDataBits (
    IN  LONG                DataBitsIn
    )

/*++

Routine Description:

    Validates the number of data bits given as an argument to the program,
    and converts  it to something that the COMM_DEVICE understands.

Arguments:

    DataBitsIn  -   Supplies the number given by the user

Return Value:

    LONG    -   The number of data bits


--*/

{

    if ( ( DataBitsIn != 5 ) &&
         ( DataBitsIn != 6 ) &&
         ( DataBitsIn != 7 ) &&
         ( DataBitsIn != 8 ) ) {

        ParseError();

    }

    return DataBitsIn;

}


STOPBITS
ConvertStopBits (
    IN  LONG                StopBitsIn
    )

/*++

Routine Description:

    Validates a number  of stop bits given as an argument to the program,
    and converts it to something that the COMM_DEVICE understands.

Arguments:

    StopBitsIn  -   Supplies the number given by the user

Return Value:

    STOPBITS    -   The number of stop bits


--*/

{
    STOPBITS    StopBits;

    switch ( StopBitsIn ) {

    case 1:
        StopBits = COMM_STOPBITS_1;
        break;

    case 2:
        StopBits = COMM_STOPBITS_2;
        break;

    default:
        ParseError();

    }

    return StopBits;

}


PARITY
ConvertParity (
    IN  WCHAR   ParityIn
    )

/*++

Routine Description:

    Validates a parity given as an argument to the program, and converts
    it to something that the COMM_DEVICE understands.

Arguments:

    ParityIn    -   Supplies the baud rate given by the user

Return Value:

    PARITY  -   The parity


--*/

{

    DSTRING     ParityString;;
    WCHAR       Par;
    PARITY      Parity;

    //
    //  Get the character that specifies parity. We lowercase it
    //
    ParityString.Initialize( " " );
    ParityString.SetChAt( ParityIn, 0 );

    ParityString.Strlwr();
    Par = ParityString.QueryChAt( 0 );

    //
    //  Set the correct parity value depending on the character.
    //
    switch ( Par ) {

    case 'n':
        Parity = COMM_PARITY_NONE;
        break;

    case 'o':
        Parity = COMM_PARITY_ODD;
        break;

    case 'e':
        Parity = COMM_PARITY_EVEN;
        break;

    case 'm':
        Parity = COMM_PARITY_MARK;
        break;

    case 's':
        Parity = COMM_PARITY_SPACE;
        break;

    default:
        ParseError();

    }

    return Parity;
}


WCHAR
ConvertRetry (
    IN  WCHAR   RetryIn
    )

/*++

Routine Description:

    Validates a retry value given as an argument to the program, and
    converts it to something that the COMM_DEVICE understands.

Arguments:

    RetryIn     -   Supplies the retry  value given by the user

Return Value:

    WCHAR   -   The retry value


--*/

{
    return RetryIn;

}



DTR_CONTROL
ConvertDtrControl (
    IN  PCWSTRING           CmdLine,
    IN  CHNUM               IdxBegin,
    IN  CHNUM               IdxEnd
    )

/*++

Routine Description:

    Validates a DTR control value given as an argument to the
    program, and converts it to something that the COMM_DEVICE
    understands.

Arguments:

    CmdLine     -   Supplies the command line
    IdxBegin    -   Supplies Index of first character
    IdxEnd      -   Supplies Index of last character

Return Value:

    DTR_CONTROL -   The DTR control value


--*/

{
    DSTRING On;
    DSTRING Off;
    DSTRING Hs;


    if ( On.Initialize( "ON" )      &&
         Off.Initialize( "OFF" )    &&
         Hs.Initialize( "HS" ) ) {


        if ( !CmdLine->Stricmp( &On,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                On.QueryChCount() ) ) {

            return DTR_ENABLE;
        }

        if ( !CmdLine->Stricmp( &Off,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Off.QueryChCount() ) ) {

            return DTR_DISABLE;
        }

        if ( !CmdLine->Stricmp( &Hs,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Hs.QueryChCount() ) ) {

            return DTR_HANDSHAKE;
        }
    }

    ParseError();

    return (DTR_CONTROL)-1;
}



RTS_CONTROL
ConvertRtsControl (
    IN  PCWSTRING           CmdLine,
    IN  CHNUM               IdxBegin,
    IN  CHNUM               IdxEnd
    )

/*++

Routine Description:

    Validates a RTS control value given as an argument to the
    program, and converts it to something that the COMM_DEVICE
    understands.

Arguments:

    CmdLine     -   Supplies the command line
    IdxBegin    -   Supplies Index of first character
    IdxEnd      -   Supplies Index of last character

Return Value:

    RTS_CONTROL -   The RTS control value


--*/

{
    DSTRING On;
    DSTRING Off;
    DSTRING Hs;
    DSTRING Tg;


    if ( On.Initialize( "ON" )      &&
         Off.Initialize( "OFF" )    &&
         Hs.Initialize( "HS" )      &&
         Tg.Initialize( "TG" )
       ) {


        if ( !CmdLine->Stricmp( &On,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                On.QueryChCount() ) ) {

            return RTS_ENABLE;
        }

        if ( !CmdLine->Stricmp( &Off,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Off.QueryChCount() ) ) {

            return RTS_DISABLE;
        }

        if ( !CmdLine->Stricmp( &Hs,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Hs.QueryChCount() ) ) {

            return RTS_HANDSHAKE;
        }

        if ( !CmdLine->Stricmp( &Tg,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Tg.QueryChCount() ) ) {

            return RTS_TOGGLE;
        }
    }

    ParseError();

    return (RTS_CONTROL)-1;
}




BOOLEAN
IsAValidCommDevice (
    IN  DEVICE_TTYPE    DeviceType,
    IN  ULONG           DeviceNumber,
    OUT PPATH           *DevicePathPointer
    )

/*++

Routine Description:

    Determines if a certain comm device exists and optionally
    creates a path for it.

Arguments:

    DeviceType      -   Supplies the type of device
    DeviceNumber    -   Supplies the device number
    DeviceName      -   Supplies a pointer to a pointer to the path for
                        the device.

Return Value:

    BOOLEAN -   TRUE if the device exists,
                FALSE otherwise.

Notes:

--*/

{
    DSTRING                 DeviceName;
    DSTRING                 Number;
    BOOLEAN                 Valid = FALSE;
    REGISTRY                Registry;
    DSTRING                 ParentName;
    DSTRING                 KeyName;
    ARRAY                   ValueArray;
    PARRAY_ITERATOR         Iterator;
    ULONG                   ErrorCode;
    PCBYTE                  Data;
    DSTRING                 PortName;
    PREGISTRY_VALUE_ENTRY   Value;


    UNREFERENCED_PARAMETER( DeviceType );


    if ( DeviceName.Initialize( (LPWSTR)L"COM" )&&
         Number.Initialize( DeviceNumber )      &&
         DeviceName.Strcat( &Number )           &&
         ParentName.Initialize( "" )            &&
         KeyName.Initialize( COMM_KEY_NAME )    &&
         ValueArray.Initialize()                &&
         Registry.Initialize()
       ) {


        //
        //  Get the names of all the serial ports
        //
        if ( Registry.QueryValues(
                        PREDEFINED_KEY_LOCAL_MACHINE,
                        &ParentName,
                        &KeyName,
                        &ValueArray,
                        &ErrorCode
                        ) ) {

            //
            //  See if the given name matches any of the serial ports
            //
            if ( Iterator = (PARRAY_ITERATOR)ValueArray.QueryIterator() ) {

                while ( Value = (PREGISTRY_VALUE_ENTRY)(Iterator->GetNext() ) ) {

                    if ( Value->GetData( &Data ) ) {

                        if ( PortName.Initialize( (PWSTR)Data ) ) {

                            if ( !DeviceName.Stricmp( &PortName ) ) {

                                Valid = TRUE;

                                break;
                            }
                        }
                    }
                }

                DELETE( Iterator );
            }
        }

        if ( DevicePathPointer ) {

            if (!(*DevicePathPointer = NEW PATH)) {
                DisplayMessageAndExit( MODE_ERROR_NO_MEMORY,
                                       NULL,
                                       (ULONG)EXIT_ERROR );
                return FALSE;   // help lint
            }
            (*DevicePathPointer)->Initialize( &DeviceName );
        }

    }

    return Valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\argument.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Argument

Abstract:

    Argument processing for the MODE utility.

    The functions in this file:

    1.- Parse the MODE command line.
    2.- Perform some basic argument validation.
    3.- Make a request packet that will be eventually routed to a
        device handler.


Author:

    Ramon Juan San Andres (ramonsa) 26-Jun-1991

Notes:

    Due to the complexity of the MODE command line, and the fact that
    we have to support both the DOS5 syntax (tagged parameters) and
    the old DOS syntax (positional parameters), MODE does not use
    the standard ULIB argument parsing.  MODE does its own parsing
    instead.

    The mode command-line can take any of the following forms:

    MODE [/?]

    MODE [device] [/STATUS]

    MODE device cp PREPARE=string

    MODE device cp REFRESH

    MODE device cp SELECT=codepage

    MODE device cp [/STATUS]

    MODE LPTn[:] [c][,l][,r]]

    MODE LPTn[:] [COLS=c] [LINES=l] [RETRY=r]

    MODE LPTn[:]=COMm[:]

    MODE COMm[:] [b[,p[,d[,s[,r]]]]]

    MODE COMm[:] [BAUD=b] [PARITY=p] [DATA=d] [STOP=s] [RETRY=r]
                 [to=on|off] [xon=on|off] [odsr=on|off] [octs=on|off]

    MODE [c[,l]]

    MODE CON[:] [COLS=c] [LINES=l]

    MODE CON[:] [RATE=r DELAY=d]


    where:


    device  :=  LPTn[:] | COMm[:] | CON[:]
    cp      :=  CP  |   CODEPAGE



    The argument parsing of MODE does a syntax-directed translation of
    the command line into a request packet. The translation is based on
    the following language.  Note that some terminal symbols (in uppercase)
    might be language dependent.


    mode        :=  MODE  { statusline | lptline | comline | conline | videoline }

    statusline  :=  /STA*

    lptline     :=  lptdev { lptredir | lptsetold | lptsetnew | lptcp | lptstatus }
    lptred      :=  =comdev
    lptset      :=  { n[,n][,c] | [COLS=n] [LINES=n] [RETRY=c] }
    lptcp       :=  cpstuff
    lptstatus   :=  { /STA* | }

    comline     :=  comdev { comset |   comstatus }
    comset      :=  { n[,c[,n[,f[,c]]]] |   [BAUD=n] [PARITY=c] [DATA=n] [STOP=f] [RETRY=c] }
                                            [to=on|off] [xon=on|off] [odsr=on|off] [octs=on|off]
    comstatus   :=  { /STA* | }

    conline     :=  condev { conrc  |   contyp  |   concp   |   constatus }
    conrc       :=  [COLS=n] [LINES=n]
    contyp      :=  RATE=n DELAY=n
    concp       :=  cpstuff
    constatus   :=  { /STA* | }

    videoline   :=  n[,n]

    cpstuff     :=  cp  { prepare | refresh | select | cpstatus}
    cp          :=  CP | CODEPAGE
    prepare     :=  PREPARE=*
    refresh     :=  REFRESH
    select      :=  SELECT=n
    cpstatus    :=  { /STA* | }

    comdev      :=  COMn[:]
    lptdev      :=  LPTn[:]
    condev      :=  CON[:]

    n           :=  Integer number
    f           :=  floating point number
    c           :=  character



    The functions in this file parse the language shown above. Most of
    the functions have names that correspond to non-terminal symbols in
    the language.


    There are 3 main functions used for reading the command line:

    Match()     -   This function matches a pattern against whatever
                    is in the command line at the current position.

                    Note that this does not advance our current position
                    within the command line.

                    If the pattern has a magic character, then the
                    variables MatchBegin and MatchEnd delimit the
                    substring of the command line that matched that
                    magic character.


    Advance()   -   This functions advances our current position within
                    the command line. The amount by which the position
                    is advanced is determined by the the last Match().


    EndOfInput()-   Returns TRUE if the command line has been consumed.



    e.g.    If the command line has the string "MODE COM1: 1200"

            This is what the following sequence would do

            Match( "*" );       //  TRUE (matches "MODE")
            Advance();

            //
            //  Note that Match() does not advance our position
            //
            MATCH( "LPT" );     //  FALSE (no match)
            MATCH( "COM#" );    //  TRUE (matches "COM" )
            //
            //  At this point, MatchBegin and MatchEnd delimit the
            //  substring "1"
            //
            MATCH( "FOO" );     //  FALSE (no match)

            MATCH( "C*" );      //  TRUE (matches "COM1:");
            //
            //  At this point, MatchBegin and MatchEnd delimit the
            //  substring "OM1:"
            //
            Advance();

            Match( "#" );       //  TRUE (matches "1200");
            Advance();

            EndOfInput();       //  TRUE



Revision History:


--*/


#include "mode.hxx"
#include "common.hxx"
#include "lpt.hxx"
#include "com.hxx"
#include "cons.hxx"


extern "C" {

    #include <ctype.h>
    #include <string.h>

}


//
//Static data
//
PWSTRING    CmdLine;        //  The command line
CHNUM       CharIndex;      //  Index of current character
CHNUM       AdvanceIndex;   //  Index of next parameter
CHNUM       ParmIndex;      //  Index of current parameter
CHNUM       MatchBegin;     //  First index of match
CHNUM       MatchEnd;       //  Last index of match

//
//  Patterns.
//
//  Most patterns contain terminal symbols. Certain characters in a
//  pattern have a magic meaning:
//
//  '*' Matches everything up to the end of the parameter (parameters are
//      delimited by blank space).
//
//  '#' Matches a sequence of digits
//
//  '@' Matches a single character
//
//  '[' Starts an optional sequence. If the first character in the
//      the sequence matches, then all the sequence should match. If
//      the first character in the sequence does not match, then the
//      sequence is skipped.
//
//  ']' End of optional sequence
//
//


//
//  Prototypoes
//

PREQUEST_HEADER
LptLine (
    );

PREQUEST_HEADER
LptRedir (
    IN  ULONG   DeviceNumber
    );

PREQUEST_HEADER
LptSet (
    IN  ULONG   DeviceNumber
    );

PREQUEST_HEADER
LptCp (
    IN  ULONG   DeviceNumber
    );

PREQUEST_HEADER
ComLine (
    );

PREQUEST_HEADER
ComSet (
    IN  ULONG   DeviceNumber
    );

PREQUEST_HEADER
ConLine (
    );

PREQUEST_HEADER
ConRc (
    );

PREQUEST_HEADER
ConTyp (
    );

PREQUEST_HEADER
ConCp (
    );

PREQUEST_HEADER
VideoLine (
    );

PREQUEST_HEADER
CpStuff (
    IN  DEVICE_TTYPE DeviceType,
    IN  ULONG        DeviceNumber
    );

BOOLEAN
AllocateResource(
    );

VOID
DeallocateResource(
    );

BOOLEAN
Match(
    IN  PCSTR   Pattern
    );

BOOLEAN
Match(
    IN  PCWSTRING   Pattern
    );

VOID
Advance(
    );

BOOLEAN
EndOfInput(
    );

PREQUEST_HEADER
MakeRequest(
    IN  DEVICE_TTYPE    DeviceType,
    IN  LONG            DeviceNumber,
    IN  REQUEST_TYPE    RequestType,
    IN  ULONG           Size
    );

ULONG
GetNumber(
    );




INLINE
BOOLEAN
EndOfInput(
    )

/*++

Routine Description:

    Finds out if we are at the end of the command line.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if at the end of input, FALSE otherwise


--*/

{

    return (CharIndex >= CmdLine->QueryChCount());

}

PREQUEST_HEADER
GetRequest(
    )

/*++

Routine Description:

    Parses the command line and makes a device request.

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    PREQUEST_HEADER Request = NULL;
    DSTRING         Switches;

    //
    //  Allocate strings (i.e. patterns ) from the resource
    //

    //
    //  Get the command line and parse it
    //
    if (Switches.Initialize("/-") &&
        AllocateResource() &&
        CmdLine->Initialize( GetCommandLine() )) {

        //
        //  Before anything else, we look for a help switch somewhere
        //  in the command line. This kind of stinks, but this is how
        //  MODE works under DOS, se let's be compatible...
        //
        CharIndex       = 0;

        while ( TRUE ) {

            //
            //  Look for a switch
            //
            CharIndex = CmdLine->Strcspn( &Switches, CharIndex );

            if ( CharIndex != INVALID_CHNUM ) {

                //
                //  There is a switch, see if it is the help switch
                //
                CharIndex++;

                if ( Match( "?" )) {

                    //
                    //  This is a help switch, Display help
                    //
                    DisplayMessageAndExit( MODE_MESSAGE_HELP, NULL, EXIT_SUCCESS );

                }
            } else {
                break;
            }
        }

        //
        //  No help requested, now we can parse the command line. First we
        //  initialize our indeces.
        //
        ParmIndex       = 0;
        CharIndex       = 0;
        AdvanceIndex    = 0;

        //
        //  Match the program name
        //
        Advance();

        Match( "*" );
        Advance();

        //
        //  If there are no parameters, or the only parameter is the
        //  status switch, then this is a request for the status of
        //  all devices.
        //
        if ( EndOfInput() ) {

            Request = MakeRequest( DEVICE_TYPE_ALL,
                                   ALL_DEVICES,
                                   REQUEST_TYPE_STATUS,
                                   sizeof( REQUEST_HEADER ) );

        } else if ( Match( "/STA*"  ) ) {

            Advance();

            if ( !EndOfInput() ) {

                ParseError();
            }

            Request = MakeRequest( DEVICE_TYPE_ALL,
                                   ALL_DEVICES,
                                   REQUEST_TYPE_STATUS,
                                   sizeof( REQUEST_HEADER ) );


        } else if ( Match( "LPT#[:]" ) ) {

            //
            //  lptline
            //
            Request = LptLine();

        } else if ( Match( "COM#[:]"    ) ) {

            //
            //  comline
            //
            Request = ComLine();

        } else if ( Match( "CON[:]" ) ) {

            //
            //  conline
            //
            Request = ConLine();

        } else if ( Match( "#" ) ) {

            //
            //  videoline
            //
            Request = VideoLine();

        } else {

            //
            //  Parse error
            //
            ParseError();
        }

    } else {

        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );

    }

    //
    //  Deallocate strings from resource
    //
    DeallocateResource();

    //
    //  Return the request
    //
    return Request;

}

PREQUEST_HEADER
LptLine (
    )

/*++

Routine Description:

    Takes care of parsing the lptline non-terminal symbol

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;
    ULONG           DeviceNumber;

    //
    //  Note that at this point we have matched the lpt device.
    //  Get the device number;
    //
    DeviceNumber =  GetNumber();

    Advance();

    if ( EndOfInput() ) {

        //
        //  End redirection
        //
        Request = MakeRequest( DEVICE_TYPE_LPT,
                               DeviceNumber,
                               REQUEST_TYPE_LPT_ENDREDIR,
                               sizeof( REQUEST_HEADER ) );

    } else if ( Match( "/STA*" ) ) {

        //
        //  Status request
        //
        Request = MakeRequest( DEVICE_TYPE_LPT,
                               DeviceNumber,
                               REQUEST_TYPE_STATUS,
                               sizeof( REQUEST_HEADER ) );

    } else if ( Match ( "=" ) ) {

        //
        //  lptredir
        //
        Request = LptRedir( DeviceNumber );

    } else if ( Match( "#" )        || Match( "COLS=#" ) ||
                Match( "LINES=#" )  || Match( "RETRY=@" ) ) {

        //
        //  lptset
        //
        Request = LptSet( DeviceNumber );

    } else if ( Match( "CP" ) || Match( "CODEPAGE" ) ) {

        //
        //  lptcp
        //
        Request = LptCp( DeviceNumber );

    } else {

        //
        //  Error
        //
        ParseError();

    }

    return Request;

}

PREQUEST_HEADER
LptRedir (
    IN  ULONG   DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the lptredir non-terminal symbol

Arguments:

    DeviceNumber    -   Supplies the device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER     Request;
    PLPT_REQUEST        LptRequest;
    ULONG               ComDevice;

    Advance();

    //
    //  Can only redirect to COM devices
    //
    if ( Match( "COM#[:]" ) ) {

        ComDevice = GetNumber();

        Request = MakeRequest( DEVICE_TYPE_LPT,
                               DeviceNumber,
                               REQUEST_TYPE_LPT_REDIRECT,
                               sizeof(LPT_REQUEST ) );

        LptRequest = (PLPT_REQUEST)Request;

        LptRequest->Data.Redirect.DeviceType    = DEVICE_TYPE_COM;
        LptRequest->Data.Redirect.DeviceNumber  = ComDevice;

    } else {

        //
        //  Error
        //
        ParseError();

    }

    return Request;
}

PREQUEST_HEADER
LptSet (
    IN  ULONG   DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the lptset non-terminal symbol

Arguments:

    DeviceNumber    -   Supplies the device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER     Request;
    PLPT_REQUEST        LptRequest;
    BOOLEAN             SetCols     =   FALSE;
    BOOLEAN             SetLines    =   FALSE;
    BOOLEAN             SetRetry    =   FALSE;
    ULONG               Cols;
    ULONG               Lines;
    WCHAR               Retry;


    if ( Match( "#" ) ) {

        //
        //  Old syntax, where parameter are positional and comma-delimited.
        //
        //  We will use the following automata for parsing the input
        //  (eoi = end of input)
        //
        //
        //          eoi
        //  [Cols]------------->[End]
        //    |            ^
        //    |,           |eoi
        //    v            |
        //   [X]-----------+
        //    |            ^
        //    | #          |eoi
        //    +-->[Lines]--+
        //    |     |      ^
        //    |     |,     |
        //    |<----+      |
        //    |            |
        //    |,           |eoi
        //    |            |
        //    v            |
        //   [Y]-----------+
        //    |            ^
        //    | @          |eoi
        //    +-->[Retry]--+
        //
        //

        Cols = GetNumber();
        SetCols = TRUE;
        Advance();

        //
        //  X:
        //
        if ( !Match( "," ) ) {
            goto Eoi;
        }
        Advance();

        if ( Match( "#" ) ) {

            //  n
            //  Lines
            //
            Lines = GetNumber();
            SetLines = TRUE;
            Advance();
        }

        //
        //  Y:
        //
        if ( !Match ( "," ) ) {
            goto Eoi;
        }

        if ( Match( "@" ) ) {

            //
            //  Retry
            //
            Retry = CmdLine->QueryChAt( MatchBegin );
            SetRetry = TRUE;
            Advance();
        }

Eoi:
        if ( !EndOfInput() ) {

            //
            //  Error
            //
            ParseError();

        }

    } else {

        //
        //  New syntax, where parameters are tagged. The language assumes
        //  that all parameters are optional (as long as there is at least
        //  one present). If some is required, it is up to the Device
        //  handler to complain latter on.
        //

        while ( !EndOfInput() ) {

            if ( Match( "COLS=#" ) ) {
                //
                //  COLS=
                //
                Cols = GetNumber();
                SetCols = TRUE;
                Advance();

            } else if ( Match( "LINES=#" ) ) {
                //
                //  LINES=
                //
                Lines = GetNumber();
                SetLines = TRUE;
                Advance();

            } else if ( Match( "RETRY=@" ) ) {
                //
                //  RETRY=
                //
                Retry = CmdLine->QueryChAt( MatchBegin );
                SetRetry = TRUE;
                Advance();

            } else {

                ParseError();
            }
        }

    }


    //
    //  Now that we parsed all the parameters, we make the request
    //  packet.
    //
    Request = MakeRequest( DEVICE_TYPE_LPT,
                           DeviceNumber,
                           REQUEST_TYPE_LPT_SETUP,
                           sizeof(LPT_REQUEST ) );

    LptRequest = (PLPT_REQUEST)Request;

    LptRequest->Data.Setup.SetCol   =   SetCols;
    LptRequest->Data.Setup.SetLines =   SetLines;
    LptRequest->Data.Setup.SetRetry =   SetRetry;
    LptRequest->Data.Setup.Col      =   Cols;
    LptRequest->Data.Setup.Lines    =   Lines;
    LptRequest->Data.Setup.Retry    =   Retry;

    return Request;
}

PREQUEST_HEADER
LptCp (
    IN  ULONG   DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the lptcp non-terminal symbol

Arguments:

    DeviceNumber    -   Supplies the device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    //
    //  Since this is the same for LPT and CON, we use the same
    //  function to handle both.
    //
    return  CpStuff( DEVICE_TYPE_LPT, DeviceNumber );

}

PREQUEST_HEADER
ComLine (
    )

/*++

Routine Description:

    Takes care of parsing the comline non-terminal symbol

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;
    ULONG           DeviceNumber;

    //
    //  Note that we have already matched the COM device.
    //  Get the device number;
    //
    DeviceNumber = GetNumber();

    Advance();

    if ( Match( "/STA*" ) || EndOfInput() ) {

        //
        //  Status request
        //
        Request = MakeRequest( DEVICE_TYPE_COM,
                               DeviceNumber,
                               REQUEST_TYPE_STATUS,
                               sizeof( REQUEST_HEADER ) );


    } else {

        //
        //  comset
        //
        Request = ComSet( DeviceNumber );

    }

    return Request;

}

PREQUEST_HEADER
ComSet (
    IN  ULONG   DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the comset non-terminal symbol

Arguments:

    DeviceNumber    -   Supplies the device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER     Request;
    PCOM_REQUEST        ComRequest;


    BOOLEAN         SetBaud         =   FALSE;
    BOOLEAN         SetDataBits     =   FALSE;
    BOOLEAN         SetStopBits     =   FALSE;
    BOOLEAN         SetParity       =   FALSE;
    BOOLEAN         SetRetry        =   FALSE;
    BOOLEAN         SetTimeOut      =   FALSE;
    BOOLEAN         SetXon          =   FALSE;
    BOOLEAN         SetOdsr         =   FALSE;
    BOOLEAN         SetIdsr         =   FALSE;
    BOOLEAN         SetOcts         =   FALSE;
    BOOLEAN         SetDtrControl   =   FALSE;
    BOOLEAN         SetRtsControl   =   FALSE;

    ULONG           Baud;
    ULONG           DataBits;
    STOPBITS        StopBits;
    PARITY          Parity;
    WCHAR           Retry;
    BOOLEAN         TimeOut;
    BOOLEAN         Xon;
    BOOLEAN         Odsr;
    BOOLEAN         Idsr;
    BOOLEAN         Octs;
    DTR_CONTROL     DtrControl;
    RTS_CONTROL     RtsControl;


    if ( Match( "#" ) ) {

        //
        //  Old syntax, where parameter are positional and comma-delimited.
        //
        //  We will use the following automata for parsing the input
        //  (eoi = end of input):
        //
        //          eoi
        //  [Baud]------------->[End]
        //    |            ^
        //    |,           |eoi
        //    v            |
        //   [a]-----------+
        //    |            ^
        //    | @          |eoi
        //    +-->[Parity]-+
        //    |     |      ^
        //    |     |,     |
        //    |<----+      |
        //    |            |
        //    |,           |eoi
        //    |            |
        //    v            |
        //   [b]-----------+
        //    |            ^
        //    | #          |eoi
        //    +-->[Data]---+
        //    |     |      ^
        //    |     |,     |
        //    |<----+      |
        //    |            |
        //    |,           |eoi
        //    v            |
        //   [c]-----------+
        //    |            ^
        //    | #          |eoi
        //    +-->[Stop]---+
        //

        //
        // Assume xon=off
        //

        SetXon      = TRUE;
        SetOdsr     = TRUE;
        SetOcts     = TRUE;
        SetDtrControl = TRUE;
        SetRtsControl = TRUE;
        Xon         = FALSE;
        Odsr        = FALSE;
        Octs        = FALSE;
        DtrControl  = DTR_ENABLE;
        RtsControl  = RTS_ENABLE;

        Baud = ConvertBaudRate( GetNumber() );
        SetBaud = TRUE;
        Advance();

        //
        //  A:
        //
        if ( !Match( "," ) ) {
            goto Eoi;
        }
        Advance();

        if ( !Match( "," ) && Match( "@" ) ) {

            //
            //  Parity
            //
            Parity = ConvertParity( CmdLine->QueryChAt( MatchBegin ) );
            SetParity = TRUE;
            Advance();
        }

        //
        //  B:
        //
        if ( !Match( "," )) {
            goto Eoi;
        }
        Advance();

        if ( Match( "#" )) {

            //
            //  Data bits
            //
            DataBits = ConvertDataBits( GetNumber() );
            SetDataBits = TRUE;
            Advance();
        }

        //
        //  C:
        //
        if ( !Match( "," )) {
            goto Eoi;
        }
        Advance();

        if ( Match( "1.5" ) ) {
            StopBits =  COMM_STOPBITS_15;
            SetStopBits = TRUE;
            Advance();
        } else if ( Match( "#" ) ) {
            StopBits = ConvertStopBits( GetNumber() );
            SetStopBits = TRUE;
            Advance();
        }

        if (!Match( "," )) {
            goto Eoi;
        }

        Advance();

        if ( Match( "x" )) {

            //
            // XON=ON
            //
            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = TRUE;
            Odsr        = FALSE;
            Octs        = FALSE;
            DtrControl = DTR_ENABLE;
            RtsControl = RTS_ENABLE;
            Advance();

        } else if ( Match( "p" )) {
            
            //
            // Permanent retry - Hardware handshaking
            //

            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = FALSE;
            Odsr        = TRUE;
            Octs        = TRUE;
            DtrControl = DTR_HANDSHAKE;
            RtsControl = RTS_HANDSHAKE;
            Advance();

        } else {

            //
            // XON=OFF
            //
            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = FALSE;
            Odsr        = FALSE;
            Octs        = FALSE;
            DtrControl = DTR_ENABLE;
            RtsControl = RTS_ENABLE;
        }

Eoi:
        if ( !EndOfInput() ) {

            //
            //  Error
            //
            ParseError();

        }

    } else {

        //
        //  New syntax, where parameters are tagged. The language assumes
        //  that all parameters are optional (as long as there is at least
        //  one present). If some is required, it is up to the Device
        //  handler to complain latter on.
        //


        while ( !EndOfInput() ) {

            if ( Match( "BAUD=#" ) ) {
                //
                //  BAUD=
                //
                Baud = ConvertBaudRate( GetNumber() );
                SetBaud = TRUE;
                Advance();

            } else if ( Match( "PARITY=@"   ) ) {
                //
                //  PARITY=
                //
                Parity = ConvertParity( CmdLine->QueryChAt( MatchBegin ) );
                SetParity = TRUE;
                Advance();

            } else if ( Match( "DATA=#" ) ) {
                //
                //  DATA=
                //
                DataBits = ConvertDataBits( GetNumber() );
                SetDataBits = TRUE;
                Advance();

            } else if ( Match( "STOP=1.5" ) ) {
                //
                //  STOP=1.5
                //
                StopBits =  COMM_STOPBITS_15;
                SetStopBits = TRUE;
                Advance();

            } else if ( Match( "STOP=#" ) ) {
                //
                //  STOP=
                //
                StopBits = ConvertStopBits( GetNumber() );
                SetStopBits = TRUE;
                Advance();

            } else if ( Match( "RETRY=@" ) ) {
                //
                //  RETRY=
                //
                Retry = ConvertRetry( CmdLine->QueryChAt( MatchBegin ) );
                SetRetry = TRUE;
                Advance();

            } else if ( Match( "TO=ON" ) ) {
                //
                //  TO=ON
                //
                SetTimeOut = TRUE;
                TimeOut    = FALSE;   // FALSE means finite timeout
                Advance();

            } else if ( Match( "TO=OFF" ) ) {
                //
                //  TO=OFF
                //
                SetTimeOut  = TRUE;
                TimeOut     = TRUE;   // TRUE means infinite timeout
                Advance();

            } else if ( Match( "XON=ON" ) ) {
                //
                //  XON=ON
                //
                SetXon  = TRUE;
                Xon     = TRUE;
                Advance();

            } else if ( Match( "XON=OFF" ) ) {
                //
                //  XON=OFF
                //
                SetXon  = TRUE;
                Xon     = FALSE;
                Advance();

            } else if ( Match( "ODSR=ON" ) ) {
                //
                //  ODSR=ON
                //
                SetOdsr = TRUE;
                Odsr    = TRUE;
                Advance();

            } else if ( Match( "ODSR=OFF" ) ) {
                //
                //  ODSR=OFF
                //
                SetOdsr = TRUE;
                Odsr    = FALSE;
                Advance();

            } else if ( Match( "IDSR=ON" ) ) {
                //
                //  IDSR=ON
                //
                SetIdsr = TRUE;
                Idsr    = TRUE;
                Advance();

            } else if ( Match( "IDSR=OFF" ) ) {
                //
                //  IDSR=OFF
                //
                SetIdsr = TRUE;
                Idsr    = FALSE;
                Advance();

            } else if ( Match( "OCTS=ON" ) ) {
                //
                //  OCS=ON
                //
                SetOcts = TRUE;
                Octs    = TRUE;
                Advance();

            } else if ( Match( "OCTS=OFF" ) ) {
                //
                //  OCS=OFF
                //
                SetOcts = TRUE;
                Octs    = FALSE;
                Advance();

            } else if ( Match( "DTR=*"   ) ) {
                //
                //  DTR=
                //
                DtrControl = ConvertDtrControl( CmdLine, MatchBegin, MatchEnd ) ;
                SetDtrControl = TRUE;
                Advance();

            } else if ( Match( "RTS=*"   ) ) {
                //
                //  RTS=
                //
                RtsControl = ConvertRtsControl( CmdLine, MatchBegin, MatchEnd ) ;
                SetRtsControl = TRUE;
                Advance();

            } else {

                ParseError();
            }
        }
    }

    //
    //  Now that parsing is done, we can make the request packet.
    //
    Request = MakeRequest( DEVICE_TYPE_COM,
                           DeviceNumber,
                           REQUEST_TYPE_COM_SET,
                           sizeof(COM_REQUEST ) );

    ComRequest = (PCOM_REQUEST)Request;

    ComRequest->Data.Set.SetBaud        =   SetBaud;
    ComRequest->Data.Set.SetDataBits    =   SetDataBits;
    ComRequest->Data.Set.SetStopBits    =   SetStopBits;
    ComRequest->Data.Set.SetParity      =   SetParity;
    ComRequest->Data.Set.SetRetry       =   SetRetry;
    ComRequest->Data.Set.SetTimeOut     =   SetTimeOut;
    ComRequest->Data.Set.SetXon         =   SetXon;
    ComRequest->Data.Set.SetOdsr        =   SetOdsr;
    ComRequest->Data.Set.SetIdsr        =   SetIdsr;
    ComRequest->Data.Set.SetOcts        =   SetOcts;
    ComRequest->Data.Set.SetDtrControl  =   SetDtrControl;
    ComRequest->Data.Set.SetRtsControl  =   SetRtsControl;


    ComRequest->Data.Set.Baud           =   Baud;
    ComRequest->Data.Set.DataBits       =   DataBits;
    ComRequest->Data.Set.StopBits       =   StopBits;
    ComRequest->Data.Set.Parity         =   Parity;
    ComRequest->Data.Set.Retry          =   Retry;
    ComRequest->Data.Set.TimeOut        =   TimeOut;
    ComRequest->Data.Set.Xon            =   Xon;
    ComRequest->Data.Set.Odsr           =   Odsr;
    ComRequest->Data.Set.Idsr           =   Idsr;
    ComRequest->Data.Set.Octs           =   Octs;
    ComRequest->Data.Set.DtrControl     =   DtrControl;
    ComRequest->Data.Set.RtsControl     =   RtsControl;

    return Request;

}

PREQUEST_HEADER
ConLine (
    )

/*++

Routine Description:

    Takes care of parsing ConLine

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;

    Advance();

    if ( Match( "/STA*" ) || EndOfInput() ) {

        //
        //  Status request
        //
        Request = MakeRequest( DEVICE_TYPE_CON,
                               0,
                               REQUEST_TYPE_STATUS,
                               sizeof( REQUEST_HEADER ) );


    } else if ( Match( "COLS=#" ) || Match( "LINES=#" ) ) {

        //
        //  conrc
        //
        Request = ConRc();

    } else if ( Match( "RATE=#" ) || Match( "DELAY=#" ) ) {

        //
        //  contyp
        //
        Request = ConTyp();

    } else if ( Match( "CP" ) || Match( "CODEPAGE" ) ) {

        //
        //  concp
        //
        Request = ConCp();

    } else {

        //
        //  Error
        //
        ParseError();

    }

    return Request;

}

PREQUEST_HEADER
ConRc (
    )

/*++

Routine Description:

    Takes care of parsing the conrc non-terminal

Arguments:

    None

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;
    PCON_REQUEST    ConRequest;

    BOOLEAN         SetCol      =   FALSE;
    BOOLEAN         SetLines    =   FALSE;

    ULONG           Col;
    ULONG           Lines;

    while ( !EndOfInput() ) {

        if ( Match( "LINES=#" )) {
            //
            //  LINES=
            //
            Lines = GetNumber();
            SetLines = TRUE;
            Advance();

        } else if ( Match( "COLS=#" )) {
            //
            //  COLS=
            //
            Col = GetNumber();
            SetCol = TRUE;
            Advance();

        } else {

            ParseError();
        }
    }

    //
    //  We are done parsing, we make the request packet.
    //
    Request = MakeRequest( DEVICE_TYPE_CON,
                           0,
                           REQUEST_TYPE_CON_SET_ROWCOL,
                           sizeof(CON_REQUEST ) );

    ConRequest = (PCON_REQUEST)Request;

    ConRequest->Data.RowCol.SetCol      =   SetCol;
    ConRequest->Data.RowCol.SetLines    =   SetLines;
    ConRequest->Data.RowCol.Col         =   Col;
    ConRequest->Data.RowCol.Lines       =   Lines;

    return Request;

}

PREQUEST_HEADER
ConTyp (
    )

/*++

Routine Description:

    Takes care of parsing the contyp non-terminal

Arguments:

    None

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;
    PCON_REQUEST    ConRequest;

    BOOLEAN         SetRate     =   FALSE;
    BOOLEAN         SetDelay    =   FALSE;

    ULONG           Rate;
    ULONG           Delay;


    //
    //  RATE=
    //
    if ( Match( "RATE=#" )) {
        Rate = GetNumber();
        SetRate = TRUE;
        Advance();
    }

    //
    //  DELAY=
    //
    if ( Match( "DELAY=#" )) {
        Delay = GetNumber();
        SetDelay = TRUE;
        Advance();
    }

    if ( !EndOfInput() ) {
        //
        //  Error
        //
        ParseError();
    }

    //
    //  We are don parsing, we make the request packet.
    //
    Request = MakeRequest( DEVICE_TYPE_CON,
                           0,
                           REQUEST_TYPE_CON_SET_TYPEMATIC,
                           sizeof(CON_REQUEST ) );

    ConRequest = (PCON_REQUEST)Request;

    ConRequest->Data.Typematic.SetRate  =   SetRate;
    ConRequest->Data.Typematic.SetDelay =   SetDelay;
    ConRequest->Data.Typematic.Rate     =   Rate;
    ConRequest->Data.Typematic.Delay    =   Delay;

    return Request;

}

PREQUEST_HEADER
ConCp (
    )

/*++

Routine Description:

    Takes care of parsing the concp non-terminal symbol

Arguments:

    None

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    return  CpStuff( DEVICE_TYPE_CON, 0 );

}

PREQUEST_HEADER
VideoLine (
    )

/*++

Routine Description:

    Takes care of parsing the videoline non-terminal symbol

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    PREQUEST_HEADER Request;
    PCON_REQUEST    ConRequest;

    BOOLEAN         SetCol      =   FALSE;
    BOOLEAN         SetLines    =   FALSE;

    ULONG           Col;
    ULONG           Lines;

    //
    //  This is in the old syntax, where parameter are positional
    //  and comma-delimited.
    //
    //  We will use the following automata for parsing the input
    //  (eoi = end of input):
    //
    //          eoi
    //  [Cols]--------->[End]
    //    |         ^
    //    |,        |
    //    v         |
    //   [ ]        |
    //    |         |
    //    |#        |
    //    |         |
    //    v     eoi |
    //  [Lines]-----+
    //


    if ( Match( "#" )) {
        //
        //  Cols
        //
        Col = GetNumber();
        SetCol = TRUE;
        Advance();
    }

    if ( Match( "," ) ) {

        Advance();

        if ( Match( "#" )) {

            Lines = GetNumber();
            SetLines = TRUE;
            Advance();

        } else {

            ParseError();

        }
    }

    if ( !EndOfInput() ) {
        //
        //  Error
        //
        ParseError();
    }


    //
    //  We are done parsing, make the request packet
    //
    Request = MakeRequest( DEVICE_TYPE_CON,
                           0,
                           REQUEST_TYPE_CON_SET_ROWCOL,
                           sizeof(CON_REQUEST ) );

    ConRequest = (PCON_REQUEST)Request;

    ConRequest->Data.RowCol.SetCol      =   SetCol;
    ConRequest->Data.RowCol.SetLines    =   SetLines;
    ConRequest->Data.RowCol.Col         =   Col;
    ConRequest->Data.RowCol.Lines       =   Lines;

    return Request;

}

PREQUEST_HEADER
CpStuff (
    IN  DEVICE_TTYPE DeviceType,
    IN  ULONG        DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the cpstuff non-terminal symbol

Arguments:

    DeviceType      -   Supplies device type
    DeviceNumber    -   Supplies device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    PREQUEST_HEADER Request;
    PCON_REQUEST    ConRequest;

    Advance();

    if ( Match( "PREPARE=*" ) ) {

        //
        //
        //  PREPARE=
        //
        //  This is a No-Op
        //
        Request = MakeRequest( DeviceType,
                               DeviceNumber,
                               REQUEST_TYPE_CODEPAGE_PREPARE,
                               sizeof( REQUEST_HEADER ) );

    } else if ( Match( "SELECT=#" ) ) {

        //
        //
        //  SELECT=
        //
        //  Note that this relies on the fact that codepage requests
        //  are identical for all devices.
        //

        Request = MakeRequest( DeviceType,
                               DeviceNumber,
                               REQUEST_TYPE_CODEPAGE_SELECT,
                               sizeof( CON_REQUEST ) );

        ConRequest = (PCON_REQUEST)Request;

        ConRequest->Data.CpSelect.Codepage = GetNumber();

    } else if ( Match( "/STA*" ) || EndOfInput() ) {

        //
        //  /STATUS
        //
        Request = MakeRequest( DeviceType,
                               DeviceNumber,
                               REQUEST_TYPE_CODEPAGE_STATUS,
                               sizeof( REQUEST_HEADER ) );

    } else if ( Match( "REFRESH" ) ) {

        //
        //
        //  REFRESH
        //
        //  This is a No-Op
        //
        Request = MakeRequest( DeviceType,
                               DeviceNumber,
                               REQUEST_TYPE_CODEPAGE_REFRESH,
                               sizeof( REQUEST_HEADER ) );

    } else {

        ParseError();

    }

    return Request;

}

BOOLEAN
AllocateResource(
    )

/*++

Routine Description:

    Allocate strings from the resource

Arguments:

    None.

Return Value:

    None

Notes:

--*/

{

    CmdLine =   NEW DSTRING;

    return (NULL == CmdLine) ? FALSE : TRUE;

}

VOID
DeallocateResource(
    )

/*++

Routine Description:

    Deallocate strings from the resource

Arguments:

    None.

Return Value:

    None

Notes:

--*/

{

    DELETE( CmdLine );

}

BOOLEAN
Match(
    IN  PCSTR   Pattern
    )

/*++

Routine Description:

    This function matches a pattern against whatever
    is in the command line at the current position.

    Note that this does not advance our current position
    within the command line.

    If the pattern has a magic character, then the
    variables MatchBegin and MatchEnd delimit the
    substring of the command line that matched that
    magic character.

Arguments:

    Pattern -   Supplies pointer to the pattern to match

Return Value:

    BOOLEAN -   TRUE if the pattern matched, FALSE otherwise

Notes:

--*/

{

    DSTRING     PatternString;
    BOOLEAN     StatusOk;

    StatusOk = PatternString.Initialize( Pattern );

    DebugAssert( StatusOk );

    if ( StatusOk ) {

        return Match( &PatternString );

    } else {

        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );

    }
    //NOTREACHED
    return StatusOk;
}

BOOLEAN
Match(
    IN  PCWSTRING   Pattern
    )

/*++

Routine Description:

    This function matches a pattern against whatever
    is in the command line at the current position.

    Note that this does not advance our current position
    within the command line.

    If the pattern has a magic character, then the
    variables MatchBegin and MatchEnd delimit the
    substring of the command line that matched that
    magic character.

Arguments:

    Pattern -   Supplies pointer to the pattern to match

Return Value:

    BOOLEAN -   TRUE if the pattern matched, FALSE otherwise

Notes:

--*/

{

    CHNUM   CmdIndex;       //  Index within command line
    CHNUM   PatternIndex;   //  Index within pattern
    WCHAR   PatternChar;    //  Character in pattern
    WCHAR   CmdChar;        //  Character in command line;

    DebugPtrAssert( Pattern );

    CmdIndex        = CharIndex;
    PatternIndex    = 0;

    while ( (PatternChar = Pattern->QueryChAt( PatternIndex )) != INVALID_CHAR ) {

        switch ( PatternChar ) {

        case '#':

            //
            //  Match a number
            //
            MatchBegin = CmdIndex;
            MatchEnd   = MatchBegin;

            //
            //  Get all consecutive digits
            //
            while ( ((CmdChar = CmdLine->QueryChAt( MatchEnd )) != INVALID_CHAR) &&
                    isdigit( (char)CmdChar ) ) {
                MatchEnd++;
            }
            MatchEnd--;

            if ( MatchBegin > MatchEnd ) {
                //
                //  No number
                //
                return FALSE;
            }

            CmdIndex = MatchEnd + 1;
            PatternIndex++;

            break;


        case '@':

            //
            //  Match one character
            //
            if ( CmdIndex >= CmdLine->QueryChCount() ) {
                return FALSE;
            }

            MatchBegin = MatchEnd = CmdIndex;
            CmdIndex++;
            PatternIndex++;

            break;


        case '*':

            //
            //  Match everything up to next blank (or end of input)
            //
            MatchBegin  = CmdIndex;
            MatchEnd    = MatchBegin;

            while ( ( (CmdChar = CmdLine->QueryChAt( MatchEnd )) != INVALID_CHAR )  &&
                    ( CmdChar !=  (WCHAR)' ' ) ) {

                MatchEnd++;
            }
            MatchEnd--;

            CmdIndex = MatchEnd+1;
            PatternIndex++;

            break;

        case '[':

            //
            //  Optional sequence
            //
            PatternIndex++;

            PatternChar = Pattern->QueryChAt( PatternIndex );
            CmdChar     = CmdLine->QueryChAt( CmdIndex );

            //
            //  If the first charcter in the input does not match the
            //  first character in the optional sequence, we just
            //  skip the optional sequence.
            //
            if ( ( CmdChar == INVALID_CHAR ) ||
                 ( CmdChar == ' ')           ||
                 ( towupper(CmdChar) != towupper(PatternChar) ) ) {

                while ( PatternChar != ']' ) {
                    PatternIndex++;
                    PatternChar = Pattern->QueryChAt( PatternIndex );
                }
                PatternIndex++;

            } else {

                //
                //  Since the first character in the sequence matched, now
                //  everything must match.
                //
                while ( PatternChar != ']' ) {

                    if ( towupper(PatternChar) != towupper(CmdChar) ) {
                        return FALSE;
                    }
                    CmdIndex++;
                    PatternIndex++;
                    CmdChar = CmdLine->QueryChAt( CmdIndex );
                    PatternChar = Pattern->QueryChAt( PatternIndex );
                }

                PatternIndex++;
            }

            break;

        default:

            //
            //  Both characters must match
            //
            CmdChar = CmdLine->QueryChAt( CmdIndex );

            if ( ( CmdChar == INVALID_CHAR ) ||
                 ( towupper(CmdChar) != towupper(PatternChar) ) ) {

                return FALSE;

            }

            CmdIndex++;
            PatternIndex++;

            break;

        }
    }

    AdvanceIndex = CmdIndex;

    return TRUE;

}

VOID
Advance(
    )

/*++

Routine Description:

    Advances our pointers to the beginning of the next lexeme

Arguments:

    None

Return Value:

    None


--*/

{

    CharIndex = AdvanceIndex;

    //
    //  Skip blank space
    //
    if ( CmdLine->QueryChAt( CharIndex ) == ' ' ) {

        while ( CmdLine->QueryChAt( CharIndex ) == ' ' ) {

            CharIndex++;
        }

        ParmIndex = CharIndex;

    }
}

VOID
ParseError(
    )

/*++

Routine Description:

    Display Invalid parameter error message and exits

Arguments:

    None

Return Value:

    None


--*/

{
    DSTRING Parameter;
    CHNUM   ParmEnd;

    //
    //  Look for end of parameter
    //
    ParmEnd = CmdLine->Strchr( ' ', ParmIndex );


    Parameter.Initialize( CmdLine,
                          ParmIndex,
                          (ParmEnd == INVALID_CHNUM) ? TO_END : ParmEnd - ParmIndex );

    DisplayMessageAndExit( MODE_ERROR_INVALID_PARAMETER,
                           &Parameter,
                           (ULONG)EXIT_ERROR );

}

PREQUEST_HEADER
MakeRequest(
    IN  DEVICE_TTYPE    DeviceType,
    IN  LONG            DeviceNumber,
    IN  REQUEST_TYPE    RequestType,
    IN  ULONG           Size
    )

/*++

Routine Description:

    Makes a request and initializes its header.

Arguments:

    DeviceType      -   Supplies the type of device
    DeviceNumber    -   Supplies the device number
    RequestType     -   Supplies the type of request
    Size            -   Supplies size of the request packet

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    PREQUEST_HEADER Request;

    DebugAssert( Size >= sizeof( REQUEST_HEADER )) ;

    Request = (PREQUEST_HEADER)MALLOC( (unsigned int)Size );

    DebugPtrAssert( Request );

    if ( !Request ) {
        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
    }

    Request->DeviceType     =   DeviceType;
    Request->DeviceNumber   =   DeviceNumber;
    Request->DeviceName     =   NULL;
    Request->RequestType    =   RequestType;

    return Request;

}

ULONG
GetNumber(
    )

/*++

Routine Description:

    Converts the substring delimited by MatchBegin and MatchEnd into
    a number.

Arguments:

    None

Return Value:

    ULONG   -   The matched string converted to a number


--*/

{
    LONG    Number;


    DebugAssert( MatchEnd >= MatchBegin );

    if ( !CmdLine->QueryNumber( &Number, MatchBegin, (MatchEnd-MatchBegin)+1 ) ) {
        ParseError();
    }

    return (ULONG)Number;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\label\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1
TARGETNAME=label
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\label.cxx ..\label.rc

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
       ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
       $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\label\label.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    LABEL

Abstract:

    Label is a DOS-5 compatible volume label changing utility

Author:

        Norbert Kluster (norbertk) 18-Apr-1991

Notes:


Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"
#include "substrng.hxx"
#include "system.hxx"
#include "ifssys.hxx"
#include "ulibcl.hxx"

extern "C" {
    #include "ntioapi.h"
}

CONST   MaxLabelLength = 1024;

VOID
DisplayLabelUsage(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine displays the usage for the dos 5 label program.

Arguments:

    Message - Supplies an outlet for the messages.

Return Value:

    None.

--*/
{
    Message->Set(MSG_LBL_INFO);
    Message->Display("");
    Message->Set(MSG_LBL_USAGE);
    Message->Display("");
}


BOOLEAN
OpenDrive(
    IN  PCWSTRING   Drive,
    OUT PHANDLE     Handle,
    OUT PNTSTATUS   Status
    )
/*++

Routine Description:

    This routine opens an NT handle to for the given dos drive name.

Arguments:

    Drive   - Supplies a dos drive name.
    Handle  - Returns an NT handle to the drive.
    Status  - Receives the status code if the function returns FALSE

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING             ntdrive;
    UNICODE_STRING      string;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     status_block;

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(Drive, &ntdrive)) {

        *Status = STATUS_NO_MEMORY;
        return FALSE;
    }

    if (!(string.Buffer = ntdrive.QueryWSTR())) {

        *Status = STATUS_NO_MEMORY;
        return FALSE;
    }

    string.Length = (USHORT) (ntdrive.QueryChCount()*sizeof(WCHAR));
    string.MaximumLength = string.Length;

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    *Status = NtOpenFile(Handle,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &oa, &status_block,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT | FILE_WRITE_THROUGH);

    return (BOOLEAN) NT_SUCCESS(*Status);
}


BOOLEAN
OpenReadOnlyDrive(
    IN  PCWSTRING   Drive,
    OUT PHANDLE     Handle
    )
/*++

Routine Description:

    This routine opens an NT handle to for the given dos drive name.

Arguments:

    Drive   - Supplies a dos drive name.
        Handle  - Returns an NT handle to the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING             ntdrive;
    UNICODE_STRING      string;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     status_block;
    DSTRING             backslash;
    NTSTATUS            Status;


    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(Drive, &ntdrive) ||
        !backslash.Initialize("\\") ||
        !ntdrive.Strcat(&backslash)) {

        return FALSE;
    }

    if (!(string.Buffer = ntdrive.QueryWSTR())) {

        return FALSE;
    }

    string.Length = (USHORT) (ntdrive.QueryChCount()*sizeof(WCHAR));
    string.MaximumLength = string.Length;

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    Status = NtOpenFile(Handle,
                        SYNCHRONIZE | FILE_READ_DATA,
                        &oa, &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    return (BOOLEAN) NT_SUCCESS(Status);
}


BOOLEAN
GetLabelInput(
    IN      PCWSTRING   DisplayDriveName,
    IN      PCWSTRING   Drive,
    OUT     PBOOLEAN    LabelExists,
    OUT     PWSTRING    Label,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine prints the current label, if any, and the current serial
    number.  Then a new label is queried from the user.

Arguments:

    DisplayDriveName
                - The dos stype name to be displayed to the user
    Drive       - The dos style drive name.
    LabelExists - Returns whether or not a label currently exists on
                    the volume.
    Label       - Returns the inputted label.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   length = sizeof(FILE_FS_VOLUME_INFORMATION) + MaxLabelLength;
    CONST   max_fsname = 40;

    // The buffer for FileFsVolumeInformation must be quadword-aligned.

    LONGLONG                        info_buf[length/sizeof(LONGLONG) + 1];
    PFILE_FS_VOLUME_INFORMATION     info;

    IO_STATUS_BLOCK                 status_block;
    PUSHORT                         p;
    DSTRING                         current_label;
    HANDLE                          Handle;
    WCHAR                           file_system[max_fsname];
    MSGID                           label_prompt_msg;
    DSTRING                         root_dir;
    DSTRING                         slash;
    PWSTR                           proot_dir;
    DSTRING                         fsname;
    DSTRING                         ntfs;

    if (!OpenReadOnlyDrive(Drive, &Handle)) {

        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display();
        return FALSE;
    }


    info = (PFILE_FS_VOLUME_INFORMATION) info_buf;

    if (!NT_SUCCESS(NtQueryVolumeInformationFile(Handle, &status_block,
                    info, length, FileFsVolumeInformation))) {

        NtClose(Handle);
        return FALSE;
    }

    NtClose(Handle);

    info->VolumeLabel[info->VolumeLabelLength/sizeof(WCHAR)] = 0;

    if (!current_label.Initialize(info->VolumeLabel)) {
        return FALSE;
    }

    if (info->VolumeLabelLength) {
        Message->Set(MSG_LBL_THE_LABEL);
        Message->Display("%W%W", DisplayDriveName, &current_label);
        *LabelExists = TRUE;
    } else {
        Message->Set(MSG_LBL_NO_LABEL);
        Message->Display("%W", DisplayDriveName);
        *LabelExists = FALSE;
    }

    p = (PUSHORT) &info->VolumeSerialNumber;

    if (p[1] || p[0]) {
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", p[1], p[0]);
    }

    // Figure out which label prompt message to use.

    label_prompt_msg = MSG_VOLUME_LABEL_PROMPT;

    if (slash.Initialize("\\") &&
        root_dir.Initialize(Drive) &&
        root_dir.Strcat(&slash) &&
        ntfs.Initialize("NTFS") &&
        (proot_dir = root_dir.QueryWSTR())) {

        if (GetVolumeInformation(proot_dir, NULL, 0, NULL, NULL,
                                 NULL, file_system, max_fsname) &&
            fsname.Initialize(file_system) &&
            !fsname.Stricmp(&ntfs)) {

            label_prompt_msg = MSG_VOLUME_LABEL_NO_MAX;
        }

        DELETE(proot_dir);
    }

    Message->Set(label_prompt_msg, ERROR_MESSAGE);
    Message->Display();

    return Message->QueryStringInput(Label);
}


BOOLEAN
SetLabel(
    IN      PCWSTRING   Drive,
    IN      PCWSTRING   Label,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine sets the supplied label on the supplied drive.

Arguments:

    Drive   - Supplies the dos drive name.
    Label   - Supplies a label.
    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   length  = sizeof(FILE_FS_LABEL_INFORMATION) + MaxLabelLength;

    PFILE_FS_LABEL_INFORMATION  info;
    STR                         info_buf[length];
    IO_STATUS_BLOCK             status_block;
    NTSTATUS                    nts;
    DSTRING                     uppercase_label;
    HANDLE                      Handle;
    NTSTATUS                    status;


    if (!OpenDrive(Drive, &Handle, &status)) {

        if( status == STATUS_ACCESS_DENIED ) {

            Message->Set(MSG_DASD_ACCESS_DENIED);
            Message->Display("");

        } else {

            Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
            Message->Display("");
        }

        return FALSE;
    }


    if (!uppercase_label.Initialize(Label)) {
        return FALSE;
    }

    info = (PFILE_FS_LABEL_INFORMATION) info_buf;

    if (!uppercase_label.QueryWSTR(0, TO_END, info->VolumeLabel,
                                   (length - sizeof(ULONG))/sizeof(WCHAR))) {

        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display();
        return FALSE;
    }

    info->VolumeLabelLength = uppercase_label.QueryChCount()*sizeof(WCHAR);

    nts = NtSetVolumeInformationFile(Handle, &status_block, info,
                                     length, FileFsLabelInformation);

    if (!NT_SUCCESS(nts)) {

        switch (nts) {
        case STATUS_ACCESS_DENIED:

            Message->Set(MSG_DASD_ACCESS_DENIED);
            Message->Display();
            break;

        case STATUS_INVALID_VOLUME_LABEL:

            Message->Set(MSG_INVALID_LABEL);
            Message->Display();
            break;

          case STATUS_NOT_SUPPORTED:
          case STATUS_INVALID_DEVICE_REQUEST:

            Message->Set(MSG_LBL_NOT_SUPPORTED);
            Message->Display();
            break;

          case STATUS_DISK_FULL:

            Message->Set(MSG_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            break;

          case STATUS_MEDIA_WRITE_PROTECTED:

            Message->Set(MSG_LBL_WRITE_PROTECTED_MEDIA);
            Message->Display();
            break;

          case STATUS_CANNOT_MAKE:

            Message->Set(MSG_LBL_ROOT_DIRECTORY_FULL);
            Message->Display();
            break;

          case STATUS_REQUEST_ABORTED:

            Message->Set(MSG_LBL_CHANGE_CANCEL);
            Message->Display();
            break;

          default:

            Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
            Message->Display();
            break;

        }

        return FALSE;
    }

    return TRUE;
}


INT __cdecl
main(
    )
/*++

Routine Description:

    This routine emulates the dos 5 label command for NT.

Arguments:

    None.

Return Value:

    1   - An error occured.
    0   - Success.

--*/
{
    STREAM_MESSAGE          msg;
    ARGUMENT_LEXEMIZER      arglex;
    ARRAY                   lex_array;
    ARRAY                   arg_array;
    STRING_ARGUMENT         progname;
    REST_OF_LINE_ARGUMENT   other_arg;
    FLAG_ARGUMENT           help_arg;
    FLAG_ARGUMENT           mp_arg;
    DSTRING                 label_string;
    DSTRING                 drive_string;
    BOOLEAN                 label_exists;
    PWSTRING                p;
    PATH                    path;
    PATH                    fullpath;
    DSTRING                 drive_path_string;
    CHNUM                   position;
    PATH_ANALYZE_CODE       rst;
    DSTRING                 DisplayDriveName;

    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream(),
                        Get_Standard_Error_Stream())) {
        return 1;
    }

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 1;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 1;
    }

    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 1;
    }

    if (!progname.Initialize("*") ||
        !help_arg.Initialize("/?") ||
        !mp_arg.Initialize("/MP") ||
        !other_arg.Initialize()) {
        return 1;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&help_arg) ||
        !arg_array.Put(&mp_arg) ||
        !arg_array.Put(&other_arg)) {
        return 1;
    }

    if (!arglex.DoParsing(&arg_array)) {
        msg.Set(MSG_INVALID_PARAMETER);
        msg.Display("%W", p = arglex.QueryInvalidArgument());
        return 1;
    }

    if (help_arg.QueryFlag()) {
        DisplayLabelUsage(&msg);
        return 0;
    }

    //
    // Figure out what kind of combination of drive and label
    //

    if (!label_string.Initialize())
        return 1;

    if (other_arg.IsValueSet()) {
        if (!drive_string.Initialize(other_arg.GetRestOfLine()) ||
            !path.Initialize(other_arg.GetRestOfLine())) {
            return 1;
        }
        if (mp_arg.IsValueSet()) {
            // treat like 'label /mp [<mount point or guid volume name>] [label]'
            // note that