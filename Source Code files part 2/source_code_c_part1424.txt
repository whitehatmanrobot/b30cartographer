ign bit for value.
		unsigned	m_iVal : 23;			// Value or offset into stream.

		enum								// class constants.
		{
			VALUE_MASK = 0x007fffff,		// Mask the same size as the value field.
			SIGN_MASK  = 0xff800000			// Mask the same size as the missing bits.
		};

		// Set the value.  (Note: arg is signed so we get sign extension)
		void Set(long l)
		{
			ULONG ul = static_cast<ULONG>(l);
			m_iSign = ul >> (sizeof(ul)*8-1);
			m_iVal = ul;
		}
		long Get()
		{
			return (m_iSign ? SIGN_MASK : 0) | m_iVal;
		}
		int operator==(const StgVariant &v) const
		{	return *reinterpret_cast<const long*>(this) == *reinterpret_cast<const long*>(&v); }

	};
	typedef CDynArray<StgVariant> StgVariantArray;
	

	// Member variables.
	StgBlobPool *m_pBlobPool;				// Pool to keep Blobs in.
	StgStringPool *m_pStringPool;			// Pool to keep strings in.

	StgVariantArray	m_rVariants;			// The variants.

	ULONGARRAY	m_Remap;					// Remap array or organizing.

	CIfacePtr<IStream> m_pIStream;			// For variable size data.

private:
	// Organized information.
	ULONG		m_cbOrganizedSize;			// Size of the Organized pool.
	ULONG		m_cOrganizedVariants;		// Count of variants in Organized pool.
	int			m_cbOrganizedCookieSize;	// Size of a cookie in the Organized pool.

};

//*****************************************************************************
// This pool is for storing Codes, Byte or Native.  This pool is different
// from the blob pool: 1) clients may obtain pointers to data which are
// guaranteed to remain valid, and 2) we attempt no duplicate folding.
// The non-movability leads to a different organization -- instead of a single
// block that grows as required, the data is stored in a linked list of
// blocks.
//*****************************************************************************
class StgCodePool : public StgBlobPool
{
public:
	StgCodePool() :
		StgBlobPool(DFT_CODE_HEAP_SIZE)
	{
	}


//*****************************************************************************
// Add the given Code to the pool.
//*****************************************************************************
	HRESULT AddCode(						// Return code.
		const void	*pVal,					// The value to store.
		ULONG		iLen,					// Count of bytes to store.
		ULONG		*piOffset)				// The offset of the new item.
	{
		return (AddBlob(iLen, pVal, piOffset));
	}

//*****************************************************************************
// Lookup the logical Code and return a copy to the caller.
//*****************************************************************************
	HRESULT GetCode(						// Return code.
		ULONG		iOffset,				// Offset of the item to get.
		const void	**ppVal,				// Put pointer to Code here.
        ULONG		*piLen)					// Put length of code here.
	{
		*ppVal = GetBlob(iOffset, piLen);
		return (S_OK);
	}

};

#pragma warning (default : 4355)



//*****************************************************************************
// This method creates an IStream which will work directly on top of the 
// memory range given.
//*****************************************************************************
HRESULT CreateStreamOnMemory(           // Return code.
    void        *pMem,                  // Memory to create stream on.
    ULONG       cbSize,                 // Size of data.
    IStream     **ppIStream);           // Return stream object here.


#endif // __StgPool_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgopentable.h ===
//*****************************************************************************
// StgOpenTable.h
//
// This module contains the open table pointer code used by StgDatabase to
// track open tables in the database.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once

#include "UtilCode.h"					// Hash table helper.
#include "StgRecordManager.h"			// Table manager code.

// Forwards.
class StgDatabase;


//*****************************************************************************
// This struct tracks one open table.  The address of this struct is guaranteed
// not to move, and cannot since each TableSet needs a pointer to it for
// record I/O.  The core set of tables that make up the component library
// have a guaranteed location in the open table array.  All other tables are
// appended after that location.
//*****************************************************************************
class STGOPENTABLE
{
public:
	STGOPENTABLE() : szTableName(0) { }

	LPSTR		szTableName;			// Name of this table.
	StgRecordManager RecordMgr;			// The record manager for the table.
	STGOPENTABLE *pNext;				// Next open table.
};



//*****************************************************************************
// This class manages a heap of STGOPENTABLE objects, each of which represents
// an open table in the database.  Having a fixed size heap allows for one
// memory allocation per database making table open overhead small.  This class
// adds the ability to track used entries so you can do FindFirst/FindNext.
// This is required to do heap cleanup on shut down and scans for dirty tables.
//*****************************************************************************
class COpenTableHeap
{
public:
	COpenTableHeap() : m_pHead(0)
	{ }

	STGOPENTABLE *AddOpenTable();

	void DelOpenTable(STGOPENTABLE *p);

	// HRESULT ReserveRange(StgDatabase *pDB, int iCount);

	void Clear();

	STGOPENTABLE *GetAt(int i)
	{ return (m_Heap.GetAt(i)); }

	STGOPENTABLE *GetHead()
	{
		return (m_pHead); 
	}

	STGOPENTABLE *GetNext(STGOPENTABLE *p)
	{
		return (p->pNext);
	}

	LPSTR GetNameBuffer(int i)
	{
		return ((LPSTR) m_rgNames.GetChunk(i));
	}

	void FreeNameBuffer(LPCSTR p, int i)
	{
		m_rgNames.DelChunk((BYTE *) p, i);
	}

private:
	TItemHeap<STGOPENTABLE, 48, unsigned char> m_Heap;
 	STGOPENTABLE *m_pHead;				// Head of allocated list.
	CMemChunk	m_rgNames;				// Small heap of names.
};


//*****************************************************************************
// This hash table is used to map a table name to an open table structure by
// its index (aka TABLEID).  The actual open table structs are managed by the
// OPENTABLEPTRLIST.  This allows the internal code to simply index the tables
// by known TABLEID, or use this generic hashing method to find them by name.
// Access to non core tables is always through this hash table.
//*****************************************************************************
struct STGOPENTABLEHASH
{
	STGOPENTABLE *pOpenTable;			// The table for this item.
};

class COpenTablePtrHash : public CClosedHash<STGOPENTABLEHASH>
{
public:
	COpenTablePtrHash(
		int			iBuckets=61) :
		CClosedHash<STGOPENTABLEHASH>(iBuckets, false)
	{ }

	bool IsUsed(							// true if in use.
		STGOPENTABLEHASH	*pElement)		// The item to check.
	{ return ((INT_PTR) pElement->pOpenTable != FREE && (INT_PTR) pElement->pOpenTable != DELETED); }

	virtual unsigned long Hash(				// The key value.
		void const	*pData)					// Raw data to hash.
	{
		return (HashStringA((LPCSTR) pData));
	}

	virtual unsigned long Compare(			// 0, -1, or 1.
		void const	*pData,					// Raw key data on lookup.
		BYTE		*pElement)				// The element to compare data against.
	{
		_ASSERTE((INT_PTR) ((STGOPENTABLEHASH *) pElement)->pOpenTable != FREE &&
					(INT_PTR) ((STGOPENTABLEHASH *) pElement)->pOpenTable != DELETED);
		STGOPENTABLE *p = ((STGOPENTABLEHASH *) pElement)->pOpenTable; 
		return (SchemaNameCmp((LPCSTR) pData, p->szTableName));
	}

	virtual ELEMENTSTATUS Status(			// The status of the entry.
		BYTE		*pElement)				// The element to check.
	{
		if ((INT_PTR) ((STGOPENTABLEHASH *) pElement)->pOpenTable == FREE)
			return (CClosedHash<STGOPENTABLEHASH>::FREE);
		else if ((INT_PTR) ((STGOPENTABLEHASH *) pElement)->pOpenTable == DELETED)
			return (CClosedHash<STGOPENTABLEHASH>::DELETED);
		return (CClosedHash<STGOPENTABLEHASH>::USED);
	}

	virtual void SetStatus(
		BYTE		*pElement,				// The element to set status for.
		ELEMENTSTATUS eStatus)				// New status.
	{
		if (eStatus == CClosedHash<STGOPENTABLEHASH>::FREE)
			((STGOPENTABLEHASH *) pElement)->pOpenTable = (STGOPENTABLE *) FREE;
		else if (eStatus == CClosedHash<STGOPENTABLEHASH>::DELETED)
			((STGOPENTABLEHASH *) pElement)->pOpenTable = (STGOPENTABLE *) DELETED;
		DEBUG_STMT(else _ASSERTE(0));
	}

	virtual void *GetKey(					// The data to hash on.
		BYTE		*pElement)				// The element to return data ptr for.
	{	
		STGOPENTABLE *p = ((STGOPENTABLEHASH *) pElement)->pOpenTable; 
		return ((void *) p->szTableName); 
	}

private:
	enum
	{
		FREE			= 0xffffffff,
		DELETED			= 0xfffffffe
	};
};



//*****************************************************************************
// This helper is designed to find places where a tableid might have been
// incorrectly cast with a 0xffff style flag which would fail 64-bit.
//*****************************************************************************
inline bool IsValidTableID(TABLEID tableid)
{
#ifndef _WIN64
    if (tableid == 0x0000ffff)
        return false;
#else
    if (tableid == 0x00000000ffffffff)
        return false;
#endif
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgpoolreadonly.cpp ===
//*****************************************************************************
// StgPoolReadOnly.cpp
//
// Read only pools are used to reduce the amount of data actually required in the database.
// 
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Standard include.
#include "StgPool.h"                    // Our interface definitions.
#include "CompLib.h"                    // Extended VT types.
#include "Errors.h"                     // Error handling.
#include "basetsd.h"					// For UINT_PTR typedef

//
//
// StgPoolReadOnly
//
//


const BYTE StgPoolReadOnly::m_zeros[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};


//*****************************************************************************
// Free any memory we allocated.
//*****************************************************************************
StgPoolReadOnly::~StgPoolReadOnly()
{
}


//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
HRESULT StgPoolReadOnly::InitOnMemReadOnly(// Return code.
        void        *pData,             // Predefined data.
        ULONG       iSize)              // Size of data.
{
    // Make sure we aren't stomping anything and are properly initialized.
    _ASSERTE(m_pSegData == 0);

    // Create case requires no further action.
    if (!pData)
        return (E_INVALIDARG);

    m_pSegData = reinterpret_cast<BYTE*>(pData);
    m_cbSegSize = iSize;
    m_cbSegNext = iSize;
    return (S_OK);
}

//*****************************************************************************
// Prepare to shut down or reinitialize.
//*****************************************************************************
void StgPoolReadOnly::UnInit()
{
	m_pSegData = 0;
	m_pNextSeg = 0;
}


//*****************************************************************************
// Copy a UNICODE string into the caller's buffer.
//*****************************************************************************
HRESULT StgPoolReadOnly::GetStringW(      // Return code.
    ULONG       iOffset,                // Offset of string in pool.
    LPWSTR      szOut,                  // Output buffer for string.
    int         cchBuffer)              // Size of output buffer.
{
    LPCWSTR      pString;              
    int         iChars;
    pString = GetString(iOffset);
    
	if ( (ULONG)cchBuffer < wcslen( pString ) + 1 )
		return ( HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) );
	else
		wcscpy( szOut, pString );
    return (S_OK);
}


//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
GUID *StgPoolReadOnly::GetGuid(			// Pointer to guid in pool.
	ULONG		iIndex)					// 1-based index of Guid in pool.
{
    if (iIndex == 0)
        return (reinterpret_cast<GUID*>(const_cast<BYTE*>(m_zeros)));

	// Convert to 0-based internal form, defer to implementation.
	return (GetGuidi(iIndex-1));
}


//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
GUID *StgPoolReadOnly::GetGuidi(		// Pointer to guid in pool.
	ULONG		iIndex)					// 0-based index of Guid in pool.
{
	ULONG iOffset = iIndex * sizeof(GUID);
    _ASSERTE(IsValidOffset(iOffset));
    return (reinterpret_cast<GUID*>(GetData(iOffset)));
}


//*****************************************************************************
// Return a pointer to a null terminated blob given an offset previously
// handed out by Addblob or Findblob.
//*****************************************************************************
void *StgPoolReadOnly::GetBlob(             // Pointer to blob's bytes.
    ULONG       iOffset,                // Offset of blob in pool.
    ULONG       *piSize)                // Return size of blob.
{
    void const  *pData;                 // Pointer to blob's bytes.

    if (iOffset == 0)
    {
        *piSize = 0;
        return (const_cast<BYTE*>(m_zeros));
    }

    // Is the offset within this heap?
    _ASSERTE(IsValidOffset(iOffset));

    // Get size of the blob (and pointer to data).
    *piSize = CPackedLen::GetLength(GetData(iOffset), &pData);

	// @todo: meichint
	// Do we need to perform alignment check here??
	// I don't want to introduce IsAligned to just for debug checking.
	// Sanity check the return alignment.
	// _ASSERTE(!IsAligned() || (((UINT_PTR)(pData) % sizeof(DWORD)) == 0));

    // Return pointer to data.
    return (const_cast<void*>(pData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgpooli.cpp ===
//*****************************************************************************
// StgPool.cpp
//
// Pools are used to reduce the amount of data actually required in the database.
// This allows for duplicate string and binary values to be folded into one
// copy shared by the rest of the database.  Strings are tracked in a hash
// table when insert/changing data to find duplicates quickly.  The strings
// are then persisted consecutively in a stream in the database format.
//
// Copyright (c) 1996-1998, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard include.
#include "StgPool.h"					// Our interface definitions.

int CStringPoolHash::Cmp(
	const void	*pData, 				// A string.
	void		*pItem)					// A hash item which refers to a string.
{
	LPCWSTR p1 = reinterpret_cast<LPCWSTR>(pData);
    LPCWSTR p2 = m_Pool->GetString(reinterpret_cast<STRINGHASH*>(pItem)->iOffset);
	return (wcscmp(p1, p2));
}


int CBlobPoolHash::Cmp(
	const void *pData,					// A blob.
	void		*pItem)					// A hash item which refers to a blob.
{
	ULONG		ul1;
	ULONG		ul2;
	void		*pData2;

	// Get size of first item.
	ul1 = CPackedLen::GetLength(pData);
	// Adjust size to include the length of size field.
	ul1 += CPackedLen::Size(ul1);

	// Get the second item.
	pData2 = m_Pool->GetData(reinterpret_cast<BLOBHASH*>(pItem)->iOffset);

	// Get and adjust size of second item.
	ul2 = CPackedLen::GetLength(pData2);
	ul2 += CPackedLen::Size(ul2);

	if (ul1 < ul2)
		return (-1);
	else if (ul1 > ul2)
		return (1);
	return (memcmp(pData, pData2, ul1));
}

int CGuidPoolHash::Cmp(const void *pData, void *pItem)
{
    GUID *p2 = m_Pool->GetGuid(reinterpret_cast<GUIDHASH*>(pItem)->iIndex);
    return (memcmp(pData, p2, sizeof(GUID)));
}

//
//
// CPackedLen
//
//


//*****************************************************************************
// Parse a length, return the length, pointer to actual bytes.
//*****************************************************************************
ULONG CPackedLen::GetLength(			// Length or -1 on error.
	void const	*pData, 				// First byte of length.
	void const	**ppCode)				// Put pointer to bytes here, if not 0.
{
	BYTE const	*pBytes = reinterpret_cast<BYTE const*>(pData);

	if ((*pBytes & 0x80) == 0x00)		// 0??? ????
	{
		if (ppCode) *ppCode = pBytes + 1;
		return (*pBytes & 0x7f);
	}

	if ((*pBytes & 0xC0) == 0x80)		// 10?? ????
	{
		if (ppCode) *ppCode = pBytes + 2;
		return ((*pBytes & 0x3f) << 8 | *(pBytes+1));
	}

	if ((*pBytes & 0xE0) == 0xC0)		// 110? ????
	{
		if (ppCode) *ppCode = pBytes + 4;
		return ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));
	}

	return -1;
}

//*****************************************************************************
// Parse a length, return the length, size of the length.
//*****************************************************************************
ULONG CPackedLen::GetLength(			// Length or -1 on error.
	void const	*pData, 				// First byte of length.
	int			*pSizeLen)				// Put size of length here, if not 0.
{
	BYTE const	*pBytes = reinterpret_cast<BYTE const*>(pData);

	if ((*pBytes & 0x80) == 0x00)		// 0??? ????
	{
		if (pSizeLen) *pSizeLen = 1;
		return (*pBytes & 0x7f);
	}

	if ((*pBytes & 0xC0) == 0x80)		// 10?? ????
	{
		if (pSizeLen) *pSizeLen = 2;
		return ((*pBytes & 0x3f) << 8 | *(pBytes+1));
	}

	if ((*pBytes & 0xE0) == 0xC0)		// 110? ????
	{
		if (pSizeLen) *pSizeLen = 4;
		return ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));
	}

	return -1;
}

//*****************************************************************************
// Encode a length.
//*****************************************************************************
#pragma warning(disable:4244) // conversion from unsigned long to unsigned char
void* CPackedLen::PutLength(			// First byte past length.
	void		*pData, 				// Pack the length here.
	ULONG		iLen)					// The length.
{
	BYTE		*pBytes = reinterpret_cast<BYTE*>(pData);

	if (iLen <= 0x7F)
	{
		*pBytes = iLen;
		return pBytes + 1;
	}

	if (iLen <= 0x3FFF)
	{
		*pBytes = (iLen >> 8) | 0x80;
		*(pBytes+1) = iLen & 0xFF;
		return pBytes + 2;
	}

	_ASSERTE(iLen <= 0x1FFFFFFF);
	*pBytes = (iLen >> 24) | 0xC0;
	*(pBytes+1) = (iLen >> 16) & 0xFF;
	*(pBytes+2) = (iLen >> 8)  & 0xFF;
	*(pBytes+3) = iLen & 0xFF;
	return pBytes + 4;
}
#pragma warning(default:4244) // conversion from unsigned long to unsigned char
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgrecordmanager.h ===
//*****************************************************************************
// StgRecordManager.h
//
// The record manager is responsible for managing user data inside of a table.
// Tables are implemented as records stored inside of pages managed by the
// page manager (in whatever form is used).  Records are fixed sized as
// described by their schema definition.  String and other variable data is
// stored in the string or blob pool managed by the database.
//
// The record manager also owns the indexes for the table.  When changes are
// made to the table (such as inserts, updates, and deletes), the record
// manager is in charge of notifying all of the indexes to update themselves.
// In addition, when doing an indexed lookup, one goes through the record
// manager which picks the best index for the job.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once

#include "StgDef.h"						// Storage defines.
#include "VMStructArray.h"				// Record array code.
#include "StgRecordManageri.h"			// Internal helpers for records.
#include "StgIndexManagerBase.h"		// Index descriptions.
#include "StgApi.h"						// RECORDLIST.
#include "Tigger.h"						// OLE DB helpers.


const ULONG NULL_OFFSET = 0xffffffff;

// For indexed lookups, use a scan for less than 8 records because the overhead
// of a binary search outweighs the scan speed.
const int MINBSEARCHVAL = 8;

// Default conversion size of data when totally unknown input.
const ULONG DEFAULT_CVT_SIZE = 64;
const ULONG DFTRECORDS = 10;




//*****************************************************************************
// These structures are used to direct QueryRowsExecute how to run a query.
// Describe any indexes you might want to utilize by filling out a
// QUERYINDEX struct for each one, on a per fitler record basis.  
//
// For QI_RID and QI_PK, only the first binding is considered (meaning 
// single column) and pIIndex must be set to NULL.
//
// If you have a multi-column primary key, or a normal hashed index, then
// pass in the instantiated index object.
//
// The count of bindings must match the number of binding structs given to
// the funcion.
//*****************************************************************************

enum QUERYINDEXTYPE
{
	QI_RID,								// Index specifies rid lookup.
	QI_PK,								// Index describes primary key.
	QI_HASH,							// Index is a hashed index.
	QI_SORTED							// Sorted Array Index.
};

struct QUERYINDEX
{
	QUERYINDEXTYPE iType;				// What type of index is this.
	IStgIndex	*pIIndex;				// Index if there is one.
};

enum
{
	DIRECTION_FORWARD	= 0x00,			// direction of scan.
	DIRECTION_REVERSE	= 0x01,			// -- "" --
};


//*****************************************************************************
// This is the set of data structures you must have in order to optimize and
// save a record list to disk.  If you invoke GetSaveSize, this data is created
// and then used on a subsequent call to SaveToStream.  If you don't cache it
// away, then SaveToStream creates one long enough to do the save and then
// throws it away.
//*****************************************************************************
struct SAVERECORDS
{
	// Optimize struct.
	STGRECORDHDR **rgRows;				// Array of row pointers to copy in primary key order.
	long		*rgRid;					// used for the rid map. (to map original _rids to 
										// adjusted values). -1 indicates record discarded.
	void		*pNewData;				// Data for new records.
	STGINDEXLIST rgIndexes;				// Indexes for the new format.
	ULONG		iRecords;				// Records actually saved.

	STGTABLEDEF *pNewTable;				// Table to tune.
	RECORDHEAP	RecordHeap;				// Storage for records to disk.
	STGINDEXDEF **rgIndexDefs;			// Return array of indexes for pNewTable.
 	int			iPersistIndexes;		// How many do we persist.
	unsigned	bFreeTable : 1;			// True to free the table.
	unsigned	bFreeStruct : 1;		// True to free this struct.
#ifdef _DEBUG
	ULONG		cbSaveSize;				// Remember save size in debug.
#endif

	void Clear()
	{
		rgRows = 0;
		rgRid = 0;
		pNewData = 0;
		rgIndexes.Clear();
		iRecords = 0;

		pNewTable = 0;
		rgIndexDefs = 0;
		iPersistIndexes = 0;
		bFreeTable = false;
		bFreeStruct = false;
		DEBUG_STMT(cbSaveSize = 0);
	}
};


enum
{
	SRM_READ			= 0x01,			// Open table for read.
	SRM_WRITE			= 0x02,			// Open table for write.
	SRM_CREATE			= 0x04,			// Creates a new table.
};


// Forwards.
struct SCHEMADEFS;
class StgDatabase;
class PageDump;


class StgRecordManager
{
friend StgDatabase;
friend PageDump;
public:
	StgRecordManager();
	~StgRecordManager();

	inline void SetDB(StgDatabase *pDB)
	{ m_pDB = pDB; }

//*****************************************************************************
// The table name given is opened for the correct mode.  If SRM_CREATE is
// specified, then pData and iDataSize is ignored and an empty table is
// created.  If SRM_READ is specified, then pData must be given and must point
// to the same data saved with SaveToStream in a previous step.  If SRM_WRITE
// is added to SRM_READ, then the initial data is read from pData, and the
// table is set up to handle new changes.
//*****************************************************************************
	virtual HRESULT Open(					// Return code.
		SCHEMADEFS	*pSchema,				// Schema for this table.
		ULONG		iTableDef,				// Which table in the schema.
		int			fFlags,					// SRM_xxx flags.
		void		*pData,					// Data for table for read mode.
		ULONG		cbDataSize,				// Size of pData if given.
		SCHEMADEFS	*pDiskSchema=0,			// Schema for import data.
		STGTABLEDEF	*pTableDefDisk=0,		// For import of data from disk.
		ULONG		InitialRecords=0);		// Initial records to preallocate for
											//	new open of empty table.

//*****************************************************************************
// Close the given table.
//*****************************************************************************
	virtual void CloseTable();

//*****************************************************************************
// Figure out how big an optimized version of this table would be.  Add up
// the size of all records, indexes, and headers we will write in SaveToStream
// and return this value in *pcbSaveSize.  The value returned must match the
// bytes that will be written to SaveToStream.
//*****************************************************************************
	virtual HRESULT GetSaveSize(			// Return code.
		ULONG		*pcbSaveSize,			// Return save size of table.
		STGTABLEDEF	**ppTableDefSave);		// Return pointer to save def.

//*****************************************************************************
// This step will mark the pooled data which are still live in the database.
//  This is in preparation for saving to disk.  (Pooled data types are
//  strings, guids, blobs, and variants.)
//*****************************************************************************
	HRESULT MarkLivePoolData();				// Return code.

//*****************************************************************************
// Saves an entire copy of the table into the given stream.
//*****************************************************************************
	virtual HRESULT SaveToStream(			// Return code.
		IStream		*pIStream,				// Where to save copy of table to.
		STGTABLEDEF	*pNewTable,				// Return new table def.
		INTARRAY	&rgVariants,			// New variant offsets for rewrite.
		SCHEMADEFS	*pSchema,				// Schema for save.
		bool		bSaveIndexes=true);		// true if index data is taken too.

//*****************************************************************************
// Import the data from an on disk schema (identified by pSchemaDefDisk and
// pTableDefDisk) into an in memory copy that is in full read/write format.
// This requires changing offsets from 2 to 4 bytes, and other changes to
// the physical record layout.  The record are automatically allocated in a 
// new record heap.
//*****************************************************************************
	virtual HRESULT LoadFromStream(			// Return code.
		STGTABLEHDR	*pTableHdr,				// Header for stream.
		void		*pData,					// The data from the file.
		ULONG		cbData,					// Size of the data.
		SCHEMADEFS	*pSchemaDefDisk,		// Schema for on disk format.
		STGTABLEDEF	*pTableDefDisk);		// The on disk format.

//*****************************************************************************
// Called whenever the schema this object belongs to changes.  This gives the
// object an opportunity to sync up its state.
//*****************************************************************************
	virtual void OnSchemaChange();

//*****************************************************************************
// Called to do a binary search on the primary key column.  The binary search
// code is inlined here for efficiency.
//*****************************************************************************
	virtual HRESULT SearchPrimaryKey(		//Return code.
		STGCOLUMNDEF *pColDef,				// The column to search.
		CFetchRecords *pFetchedRecords,		// Return list of records here.
		DBBINDING	*pBinding,				// Binding data.
		void		*pData);				// User data for comparisons.

//*****************************************************************************
// Retrieve the record ID for a given key.  The key data must match the
// primary index of this table.
//*****************************************************************************
	virtual HRESULT GetRow(					// Return code.
		CFetchRecords *pFetchRecords,		// Return list of records here.
		DBBINDING	rgBinding[],			// Binding data.
		ULONG		cStartKeyColumns,		// How many key columns to subset on.
		void		*pStartData,			// User data for comparisons.
		ULONG		cEndKeyColumns,			// How many end key columns.
		void		*pEndData,				// Data for end comparsion.
		DBRANGE		dwRangeOptions);		// Matching options.

//*****************************************************************************
// Insert a new record at the tail of the record heap.  If there is not room
// in the current heap, a new heap is chained in and used.  No data values
// are actually set for the new records.  All columns are set to their default
// values (0 offsets, 0 data values), and all nullable columns are marked
// as such.  No primary key or unique index enforcement is done by this function.
//*****************************************************************************
	virtual HRESULT InsertRecord(			// Return code.
		RECORDID	*psNewID,				// New record ID, 0 valid.
		ULONG		*pLocalRecordIndex,		// Index in tail heap of new record.
		STGRECORDHDR **ppRecord,			// Return record if desired.
		STGRECORDFLAGS fFlags);             // optional flag argument to indicate
											// temporary record.

//*****************************************************************************
// Inserts a new row into the data store.  If there is a unique index, then 
// the uniqueness of the key is validated.
//*****************************************************************************
	virtual HRESULT InsertRow(				// Return code.
		RECORDID	*psNewID,				// New record ID, 0 valid.
		BYTE		*pData,					// User's data.
		ULONG		iColumns,				// How many columns to insert.
		DBBINDING	rgBindings[],			// Array of column data.
		STGRECORDHDR **ppRecord = 0,		// Return record if desired.
        STGRECORDFLAGS fFlags = 0,         // optional flag argument.
		int			bSignalIndexes = true);	// true if indexes should be built.

//*****************************************************************************
// Deletes a record from the table.  This will only mark the record deleted,
// the record is actually removed from the table at save time.
//*****************************************************************************
	virtual HRESULT DeleteRow(				// Return code.
		STGRECORDHDR *psRecord,				// The record to delete.
		DBROWSTATUS	*pRowStatus);			// Return status if desired.

//
// Query code.
//


//*****************************************************************************
// Adds all (non-deleted) records to the given cursor, no filters.
//*****************************************************************************
	virtual HRESULT QueryAllRecords(		// Return code.
		RECORDLIST	&records);				// List to build.

//*****************************************************************************
// Build a list of records which meet the filter criteria passed in.  This
// code implements the low level specification documented by 
// IViewFilter::SetFilter.  The query is specified using several arrays.  A
// set of bindings identify which columns are being compared and the location
// of the user data.  An array of user data filter records are given to find
// the actualy bytes described by the accessor.  Another array contains the
// comparison operators for each column to data.  For each filter record, a
// candidate row must meet all of the criteria (that is, each column comparison
// is ANDed with each other).  Rows which meet any filter record will go into
// the final cursor (that is, each filter record is ORed with each other record).
//
// This is the main entry point for an OLE DB customer.  This code will work
// on building the "access plan" for execution.  This means that each filter
// record is scanned for indexes that might speed execution.  All user data
// values are converted to compatible types as required for easy comparison.
// Once all of this work is done, control is delegated to QueryRowsExecute
// which will actually go scan indexes and records looking for the final
// results.
//
// If you already know the indexes you want to search on, and can guarantee
// that your comaprison data is compatible, then you may call QueryRowsExecute 
// directly and avoid a lot of extra work.
//*****************************************************************************
	virtual HRESULT QueryRows(				// Return code.
		CFetchRecords *pFetchRecords,		// Return list of records here.
		ULONG		cBindings,				// How many bindings for user data.
		DBBINDING	rgBinding[],			// Binding data.
		ULONG		cFilters,				// How many filter rows.
		DBCOMPAREOP	rgfCompare[],			// Comparison operator.
		void		*pbFilterData,			// Data for comparison.
		ULONG		cbFilterSize);			// How big is the filter data row.

//*****************************************************************************
// This function is called with all indexes resolved and all data types for
// comparison converted (as required).  All records are compared to each
// filter record.  Only those records which match all conditions of a filter
// are added.  Records in the cursor need only match one filter.
//*****************************************************************************
	virtual HRESULT QueryRowsExecute(		// Return code.
		CFetchRecords *pFetchRecords,		// Return list of records here.
		ULONG		cBindings,				// How many bindings for user data.
		DBBINDING	rgBinding[],			// Binding data.
		ULONG		cFilters,				// How many filter rows.
		DBCOMPAREOP	rgfCompare[],			// Comparison operator.
		void		*pbFilterData,			// Data for comparison.
		ULONG		cbFilterSize,			// How big is the filter data row.
		QUERYINDEX	*rgIndex[]);			// Indexes per filter row, may be 0.

//*****************************************************************************
// Given a RID from the user, find the corresponding row.  A RID is simply the
// array offset of the record in the table.  A RID can have a preset base so
// the user value must be adjusted accordingly.
//*****************************************************************************
	virtual HRESULT QueryRowByRid(			// Return code.
		DBBINDING	*pBinding,				// Bindings for user data to comapre.
		void		*pbData,				// User data for compare.
		STGRECORDHDR **ppRecord);			// Return record here if found.

//*****************************************************************************
// Compare a record against a set of comparison operators.  If the record meets
// all of the criteria given, then the function returns S_OK.  If the record
// does not match all criteria, then the function returns S_FALSE.
//*****************************************************************************
	virtual HRESULT QueryFilter(			// S_OK record is match, S_FALSE it isn't.
		STGRECORDHDR *pRecord,				// Record to check against filter.
		ULONG		cBindings,				// How many bindings to check.
		DBBINDING	rgBindings[],			// Bindings to use for compare.
		void		*pbData,				// User data for comparison.
		DBCOMPAREOP	rgfCompares[]);			// Comparison operator.

//*****************************************************************************
// Scan all (non-deleted) records in the table looking for matches.  If there
// are already records in the cursor, they are skipped by this code to avoid
// extra comparisons.  All data types must match the table definition.
//
// If iMaxRecords is not -1, then the scan quits after iMaxRecords new records
// have been found.  This is useful for the case where a unique index exists but
// is not persisted; if you find one row in this case, there won't be more so
// don't bother looking for them.  It can also be used to implement 
//*****************************************************************************
	virtual HRESULT QueryTableScan(			// Return code.
		CFetchRecords *pFetchRecords,		// Return list of records here.
		ULONG		cBindings=0,			// How many bindings for user data.
		DBBINDING	rgBinding[]=0,			// Binding data.
		void		*pbData=0,				// User data for bindings.
		DBCOMPAREOP	rgfCompare[]=0,			// Comparison operators.
		long		iMaxRecords=-1);		// Max rows to add, -1 to do all.

//*****************************************************************************
// This function fills in a CFetchRecord structure based on the bit vector provided.
// The function is intentionally expanded for the 2 cases: read-only and 0-deleted records (to
// be added yet) and read-write case (with possibly deleted records).
// The function checks to see if the record is deleted in the read-write case.
//*****************************************************************************
	HRESULT GetRecordsFromBits(
		CDynBitVector	*pBitVector,
		CFetchRecords	*pFetchRecords);

//*****************************************************************************
// Return the logical record id for a record, offset by user's start value.
//*****************************************************************************
	inline int IsValidRecordPtr(const STGRECORDHDR *psRecord)
	{ 
		return (m_RecordHeap.IndexForRecord(psRecord) != ~0); }
	
	inline ULONG GetRecordID(STGRECORDHDR *psRecord)
	{ _ASSERTE(IsValidRecordPtr(psRecord));
		return (m_RecordHeap.IndexForRecord(psRecord) + m_pTableDef->iRecordStart); }

	inline ULONG IndexForRecordPtr(STGRECORDHDR *psRecord)
	{ _ASSERTE(IsValidRecordPtr(psRecord));
		return (m_RecordHeap.IndexForRecord(psRecord)); }

	inline ULONG IndexForRecordID(RECORDID RecordID)
	{ _ASSERTE(RecordID >= m_pTableDef->iRecordStart);
		_ASSERTE(RecordID - m_pTableDef->iRecordStart < m_RecordHeap.Count());
		return (RecordID - m_pTableDef->iRecordStart); }


//*****************************************************************************
// Update the data for the given record according to the binding data.  It is
// illegal to update the keys of a record.
//*****************************************************************************
	virtual HRESULT SetData(				// Return code.
		STGRECORDHDR *psRecord,				// The record to work on.
		BYTE		*pData,					// User's data.
		ULONG		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[],			// Column accessors.
		int			*piPKSets,				// How many primary key columns set.
		bool		bNotifyIndexes);		// true for Update, false for Insert.

	HRESULT SetData(						// Return code.
		RECORDID	RecordID,				// Record to update.
		BYTE		*pData,					// User's data.
		ULONG		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[],			// Column accessors.
		bool		bNotifyIndexes)			// true for Update, false for Insert.
	{
		STGRECORDHDR *psRecord;				// The real record once we find it.
		VERIFY(psRecord = GetRecord(&RecordID));
		return (SetData(psRecord, pData, iColumns, rgBindings, 0, bNotifyIndexes));
	}


//*****************************************************************************
// Insert a brand new row with all of the initial data supplied.  This will add
// a new record to the record heap, set all of the data for the record, and 
// then update all of the indexes for the table.  If any failures occur, the
// data is rolled back along with any index updates that have been made.
//
// Note that any data added to heaps is not rolled back at this time because
// there is no way to know if that data is being shared with a different
// record somewhere else in the database.  If the data is not required, it
// will get purged at Save time.
//*****************************************************************************
	HRESULT InsertRowWithData(				// Return code.
		STGRECORDFLAGS fFlags,              // optional flag argument to indicate
											// temporary record.
		RECORDID	*psNewID,				// New record ID, 0 valid.
		STGRECORDHDR **ppRecord,			// Return record pointer.
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		const ULONG cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
		const ULONG *rgFieldMask);			// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns

//*****************************************************************************
// Update data for a record.  This will save off a backup copy of the record,
// apply the updates to the record, and if successful, update the indexes
// which are on the table.  If there is a failure, then the updates to any
// indexes are backed out, and the original data is restored to the record.
// There is no attempt to remove newly added data in the heaps, this is caught
// on a compressing save (there is no way to know if we added the data or
// if it was already there).
//*****************************************************************************
	HRESULT SetData(						// Return code.
		STGRECORDHDR *pRecord,				// The record to work on.
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		const ULONG cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
		const ULONG *rgFieldMask);			// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns

//*****************************************************************************
// Compare two records by their key values as per the index definition.
//*****************************************************************************
	int CompareKeys(						// -1, 0, 1
		STGINDEXDEF	*pIndexDef,				// The definition to use.
		RECORDID	RecordID1,				// First record.
		RECORDID	RecordID2);				// Second record.

//*****************************************************************************
// Compare a record to key data.
//*****************************************************************************
	int CompareKeys(						// -1, 0, 1
		STGINDEXDEF	*pIndexDef,				// The definition to use.
		STGRECORDHDR *psRecord,				// Record to compare.
		BYTE		*pData,					// User data.
		ULONG		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		DBCOMPAREOP rgfCompare[]=NULL);		// compare operator.

//*****************************************************************************
// Compare the data for two records and return the relationship.
//*****************************************************************************
	int CompareRecords(						// -1, 0, 1
		STGCOLUMNDEF *pColDef,				// Where to find key data.
		STGRECORDHDR *pRecord1,				// First record.
		STGRECORDHDR *pRecord2);			// Second record.

//*****************************************************************************
// Compare a record to the key data value given by caller.
//*****************************************************************************
	int CompareRecordToKey(					// -1, 0, 1
		STGCOLUMNDEF *pColDef,				// Column description.
		STGRECORDHDR *pRecord,				// Record to compare to key.
		DBBINDING	*pBinding,				// Binding for column.
		BYTE		*pData,					// User data.
		DBCOMPAREOP	fCompare=DBCOMPAREOPS_EQ); // Comparison operator.

//*****************************************************************************
// Create a set of bindings for the given record and columns.  This is a
// convient way to bind to an existing record.
//*****************************************************************************
	HRESULT GetBindingsForColumns(			// Return code.
		STGTABLEDEF	*pTableDef,				// The table definition.
		STGRECORDHDR *psRecord,				// Record to use for binding.
		int			iColumns,				// How many columns.
		BYTE		rColumns[],				// Column numbers.
		DBBINDING	rBindings[],			// Array to fill out.
		PROVIDERDATA rgData[]);				// Data pointer.

//*****************************************************************************
// Create a set of bindings that match the input values, but convert any
// data that doesn't match the stored type.  This allows the record compare
// code to do natural comparisons.
//*****************************************************************************
	HRESULT GetBindingsForLookup(			// Return code.
		ULONG		iColumns,				// How many columns.
		const DBBINDING	rgBinding[],		// The from bindings.
		const void *pUserData,				// User's data.
		DBBINDING	rgOutBinding[],			// Return bindings here.
		PROVIDERDATA rgData[],				// Setup byref data here.
		void		*rgFree[]);				// Record to-be-freed here.

//*****************************************************************************
// Indicates if changed data has been saved or not.
//*****************************************************************************
	int IsDirty()							// true if unsaved information.
	{ return (m_bIsDirty); }

	void SetDirty(bool bDirty=true)
	{
		_ASSERTE(m_fFlags & SRM_WRITE);
		m_bIsDirty = bDirty; }

	HRESULT RequiresWriteMode()
	{
		if ((m_fFlags & SRM_WRITE) == 0)
			return (PostError(CLDB_E_READONLY));
		return (S_OK);
	}

	int IsSuppressSave()
	{ return (m_bSuppressSave); }

	void SetSuppressSave(bool bSuppress=true)
	{ m_bSuppressSave = bSuppress; }

	int Flags()
	{ return (m_fFlags); }

	int IsOpen()
	{ return (m_fFlags != 0); }

	StgDatabase	*GetDB()
	{ return (m_pDB); }

//*****************************************************************************
// Return table information.
//*****************************************************************************

	LPCWSTR TableName();

	virtual STGTABLEDEF	*GetTableDef();
	virtual SCHEMADEFS *GetSchema()
	{ return (m_pSchema); }

	ULONG Records(int bCountDeleted=true);

//*****************************************************************************
// Retrieve the status of a record.  Normal status is 0.
//*****************************************************************************
	virtual BYTE GetRecordFlags(				
		RECORDID	 RecordID)					// ID of record to ask about.
	{
		return (m_rgRecordFlags.GetFlags(RecordID));
	}

//*****************************************************************************
// Returns the given record to the caller.
//*****************************************************************************
	STGRECORDHDR *GetRecord(				// The record.
		RECORDID	*pRecordID)				// The ID to get.
	{	_ASSERTE(pRecordID && *pRecordID < (RECORDID) m_RecordHeap.Count());
		return (m_RecordHeap.GetRecordByIndex(*pRecordID)); }


//*****************************************************************************
// Returns a pointer to the data for all types, including strings and blobs.
// Since string data is always stored as ANSI, both DBTYPE_STR and DBTYPE_WSTR
// will come back in that format.  The caller must convert to WCHAR if desired.
//*****************************************************************************
	BYTE *GetColCellData(					// Pointer to data.
		STGCOLUMNDEF *pColDef,				// Column to find in record.
		STGRECORDHDR *psRecord,				// Record to use.
		ULONG		*pcbSrcLength);			// Return length of item.

protected:
	RECORDHEAP *GetRecordHeap()
	{ return (&m_RecordHeap); }


//
//
// Query helpers.
//
//

//*****************************************************************************
// Search a primary key index for the record in question.  This function can
// only be called in read only mode because it relies on the records being
// sorted by primary key order.  In read/write mode, this cannot be guaranteed
// and therefore a dynamic hashed index is automatically created on behalf of
// the user.
// @future: This is a little too restrictive.  In the case where you open r/w
// and never modify the records, the sort order is still valid and this code
// could be used.  IsDirty is not sufficient to decide, however, since one can
// change, commit, then try to query.
//*****************************************************************************
	HRESULT QueryRowByPrimaryKey(			// CLDB_E_RECORD_NOTFOUND or return code.
		STGCOLUMNDEF *pColDef,				// For single column pk.
		IStgIndex	*pIndex,				// For multiple column pk.
		DBCOMPAREOP	fCompare,				// Comparison operator.
		DBBINDING	rgBindings[],			// Bindings for user data to comapre.
		ULONG		cBindings,				// How many bindings are there.
		void		*pbData,				// User data for compare.
		STGRECORDHDR **ppRecord);			// Return record here if found.


//
//
// Index handling.
//
//

//*****************************************************************************
// Finds a good index to look for the given columns.
//*****************************************************************************
	IStgIndex *ChooseIndex(					// The index to best answer the question.
		USHORT		iKeyColumns,			// How many columns.
		DBBINDING	rgKeys[],				// The data for the key.
		bool		*pbIsUIndexed);			// true if there is a unique index.

//*****************************************************************************
// For each index described in the header, create an index for each.
//*****************************************************************************
	HRESULT LoadIndexes();					// Return code.

//*****************************************************************************
// This version will create an index only for those items that were persisted
// in the stream.  Others are not even loaded.
//*****************************************************************************
	HRESULT LoadIndexes(					// Return code.
		STGTABLEDEF	*pTableDef,				// The table definition we're loading.
		ULONG		iRecords,				// How many records are there.
		int			iIndexes,				// How many saved to disk.
		STGINDEXHDR	*pIndexHdr);			// The first index for the table.

//*****************************************************************************
// Return the loaded index for a definition if there is one.
//*****************************************************************************
	IStgIndex *GetLoadedIndex(				// Loaded index, if there is one.
		STGINDEXDEF *pIndexDef);			// Which one do you want.

//*****************************************************************************
// Look through the index definitions in this table and find the given name.
//*****************************************************************************
	STGINDEXDEF *GetIndexDefByName(			// The def if found.
		LPCWSTR		szIndex);				// Name to find.


//
//
//  Record handling.
//
//


//*****************************************************************************
// SaveToStream is called on the unoptimized table.  The record format and 
// indexes are optimized for space based on several parameters.  Then a
// completely optimized version of the data is created in a second record
// manager and the data is saved via this function.
//*****************************************************************************
	HRESULT SaveRecordsToStream(			// Return code.
		IStream		*pIStream);				// Where to save copy of table to.


//*****************************************************************************
// Set the given column cell by setting the correct bit in the record null bitmask.
//*****************************************************************************
	void SetCellNull(
		STGRECORDHDR *psRecord,				// Record to update.
		int			iColumn,				// 0-based col number, -1 means all.
		bool		bNull);					// true for NULL.

//*****************************************************************************
// Return the NULL status for the given column number.
//*****************************************************************************
	bool GetCellNull(						// true if NULL.
		STGRECORDHDR *psRecord,				// Record to update.
		int			iColumn,				// 0-based col number.
		STGTABLEDEF *pTableDef=0);			// Which table def, 0 means default.

//*****************************************************************************
// Sets the given cell to the new value as described by the user data.  The
// caller must be sure to make sure there is room for the data at the given
// record location.  So, for example, if you update a record to a size greater
// than what it used to be, watch for overwrite.
//*****************************************************************************
	HRESULT SetCellValue(					// Return code.
		STGCOLUMNDEF *pColDef,				// The column definition.
		STGRECORDHDR *psRecord,				// Record to update.
		BYTE		*pData,					// User's data.
		DBBINDING	*psBinding);			// Binding information.


//*****************************************************************************
// Always returns the address of the cell for the given column.  For fixed
// data, this is the actual data.  For variable, it is the ULONG that contains
// the offset of the data in the pool.
//*****************************************************************************
	static BYTE *FindColCellOffset(
		STGCOLUMNDEF *pColDef,				// Column to find in record.
		STGRECORDHDR *psRecord)				// Record to use.
	{
		return ((BYTE *) psRecord + pColDef->iOffset);
	}

//*****************************************************************************
// Return the offset value for a column in a record.  This function will handle
// the variable sized natures of offsets (2 or 4 bytes).
//*****************************************************************************
	static ULONG GetOffsetForColumn(		// Pointer to offset.
		STGCOLUMNDEF *pColDef,				// Column to find.
		STGRECORDHDR *psRecord)				// Record to use.
	{ 
		if (pColDef->iSize == sizeof(USHORT))
		{
			ULONG		l;
			l = *(USHORT *) FindColCellOffset(pColDef, psRecord);
			return (l);
		}
		else
			return (*(ULONG *) FindColCellOffset(pColDef, psRecord));
	}

//*****************************************************************************
// Sets the data for a given column in the given record.  This will update heap 
// data values and intrinsic values.  It will also remove any null bitflag
// values on a column previously marked as such.
//
// Note that truncation of data values for variable sized data types is an
// error according to the OLE DB specification.  I personally dislike this
// notion, but need to keep it consistent.
//*****************************************************************************
	HRESULT SetColumnData(					// Return code.
		STGRECORDHDR	*pRecord,			// The record to update.
		STGCOLUMNDEF	*pColDef,			// column def pointer
		ULONG			ColumnOrdinal,		// column, 1-based,
		BYTE			*pbSourceData,		// Data for the update.
		ULONG			cbSourceData,		// Size of input data.
		DBTYPE			dbType);			// Data type for data.

//*****************************************************************************
// This function is called with a candidate record to see if it meets the
// criteria set forth.  If it does, then it will be added to the set.
//*****************************************************************************
	bool RecordIsMatch(						// true if record meets criteria.
		STGRECORDHDR *psRecord,				// Record to compare to.
		DBBINDING	rgBinding[],			// Binding data.
		ULONG		cStartKeyColumns,		// How many key columns to subset on.
		void		*pStartData,			// User data for comparisons.
		ULONG		cEndKeyColumns,			// How many end key columns.
		void		*pEndData,				// Data for end comparsion.
		DBRANGE		dwRangeOptions);		// Matching options.

//*****************************************************************************
// This step will create the otpimized record format.  This requires tuning
// indexes to see which will get persisted.
//*****************************************************************************
	HRESULT SaveOptimize(					// Return code.
		SAVERECORDS	*pSaveRecords);			// Optimize this data.

//*****************************************************************************
// Sort the given set of records by their primary key, if there is one.  If
// no primary key is given, then nothing is changed.  Note that this includes
// the case where there is a compound primary key.
//*****************************************************************************
	void SortByPrimaryKey(
		STGTABLEDEF	*pTableDef,				// Definition of table to use.
		STGRECORDHDR *rgRows[],				// Array of records to sort.
		long		iCount);				// How many are there.

//*****************************************************************************
// Clean up the optimized data we might have allocated.
//*****************************************************************************
	void ClearOptimizedData();


//
//
// Event signalers.
//
//

//*****************************************************************************
// Tell every index that an insert has taken place.
//*****************************************************************************
	HRESULT SignalAfterInsert(				// Return status.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// The record that was inserted.
		CIndexList	*pIndexList,			// List of indexes to modify.
		int			bCheckDupes);			// true to enforce duplicates.

//*****************************************************************************
// Called after a row is deleted from a table.  The index must update itself
// to reflect the fact that the row is gone.
//*****************************************************************************
	HRESULT SignalAfterDelete(				// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// The record to delete.
		CIndexList	*pIndexList);			// List of indexes to modify.

//*****************************************************************************
// Called before an update is applied to a row.  The data for the change is
// included.  The index must update itself if and only if the change in data
// affects the order of the index.
//*****************************************************************************
	HRESULT SignalBeforeUpdate(				// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record to be changed.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

	HRESULT SignalBeforeUpdate(				// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		USHORT		iRecords,				// number of records for bulk operation.
		void		*rgpRecordPtr[],		// The record we inserted.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

//*****************************************************************************
// Called after a row has been updated.  This is our chance to update the
// index with the new column data.
//*****************************************************************************
	HRESULT SignalAfterUpdate(				// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record to be changed.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

	HRESULT SignalAfterUpdate(				// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		USHORT		iRecords,				// number of records for bulk operation.
		void		*rgpRecordPtr[],		// The record we inserted.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

private:
	StgDatabase	*m_pDB;					// Parent database.
	SCHEMADEFS	*m_pSchema;				// Schema that owns us.
	STGTABLEDEF	*m_pTableDef;			// Cached pointer to table def.
	RECORDHEAP	*m_pTailHeap;			// Last heap for inserts
	SAVERECORDS *m_pSaveRecords;		// Cached save info.
	ULONG		m_iTableDef;			// Which table are we in the schema.
	STGINDEXLIST m_rpIndexes;			// Array of loaded indexes.
	RECORDHEAP	m_RecordHeap;			// Heap for record data.
	ULONG		m_iGrowInc;				// How many records per grow.
	CStgRecordFlags	m_rgRecordFlags;	// Status flags for records.
	int			m_fFlags;				// Flags used on open.
	bool		m_bIsDirty;				// true if changes have been made.
	bool		m_bSignalIndexes;		// true if indexes are to be updated.
	bool		m_bSuppressSave;		// true if table shouldn't be saved (because compressed).
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgrecordmanager.cpp ===
//*****************************************************************************
// StgRecordManager.cpp
//
// The record manager is responsible for managing user data inside of a table.
// Tables are implemented as records stored inside of pages managed by the
// page manager (in whatever form is used).  Records are fixed sized as
// described by their schema definition.  String and other variable data is
// stored in the string or blob pool managed by the database.
//
// The record manager also owns the indexes for the table.  When changes are
// made to the table (such as inserts, updates, and deletes), the record
// manager is in charge of notifying all of the indexes to update themselves.
// In addition, when doing an indexed lookup, one goes through the record
// manager which picks the best index for the job.
//
// In addition to this module, code for the record manager can be found in:
//		StgRecordManagerData.cpp		- Data get/set, conversions.
//		StgRecordManagerQry.cpp			- Index and query code.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard include.
#include <mbstring.h>					// MBCS support for data conversion.
#include "Services.h"					// For data conversion.
#include "OleDBUtil.h"					// OLE DB Helpers.
#include "StgDatabase.h"				// Parent database.
#include "StgRecordManager.h"			// Record manager interface.
#include "StgIndexManager.h"			// Index code.


//********** Types. ***********************************************************



//********** Code. ************************************************************

// ctor
StgRecordManager::StgRecordManager() :
	m_pDB(0),
	m_pTableDef(0),
	m_pSchema(0),
	m_iTableDef(0),
	m_fFlags(0),
	m_iGrowInc(DFTRECORDS),
	m_bIsDirty(false),
	m_bSuppressSave(false),
	m_bSignalIndexes(true),
	m_pSaveRecords(0)
{
	m_pTailHeap = &m_RecordHeap;
}


// dtor
StgRecordManager::~StgRecordManager()
{
	ClearOptimizedData();
}


//*****************************************************************************
// The table name given is opened for the correct mode.  If SRM_CREATE is
// specified, then pData and cbDataSize is ignored and an empty table is
// created.  If SRM_READ is specified, then pData must be given and must point
// to the same data saved with SaveToStream in a previous step.  If SRM_WRITE
// is added to SRM_READ, then the initial data is read from pData, and the
// table is set up to handle new changes.
//*****************************************************************************
HRESULT StgRecordManager::Open(			// Return code.
	SCHEMADEFS	*pSchema,				// Schema for this table.
	ULONG		iTableDef,				// Which table in the schema.
	int			fFlags,					// SRM_xxx flags.
	void		*pData,					// Data for table for read mode.
	ULONG		cbDataSize,				// Size of pData if given.
	SCHEMADEFS	*pDiskSchema,			// Table definition we are opening.
	STGTABLEDEF	*pTableDefDisk,			// For import of data from disk.
	ULONG		InitialRecords)			// Initial records to preallocate for
										//	new open of empty table.
{
	HRESULT		hr = S_OK;

	// Don't reopen me.
	_ASSERTE(!IsOpen());

	// Save off the schema and table information.
	m_pSchema = pSchema;
	m_iTableDef = iTableDef;
	VERIFY(m_pTableDef = GetTableDef());
	m_fFlags = fFlags;

	// If there is data for us to use, then import it.
	if ((fFlags & SRM_CREATE) == 0 && pData)
	{
		_ASSERTE(cbDataSize);

		// Retrieve header data from the blob.
		STGTABLEHDR	*pTableHdr;
		pTableHdr = (STGTABLEHDR *)pData;

		// This is the update case, import the data.
		if (fFlags & SRM_WRITE)
		{
			// Load the indexes for this table, then load the data.
			if (FAILED(hr = LoadIndexes()) ||
				FAILED(hr = LoadFromStream(pTableHdr, pData, cbDataSize, pDiskSchema, pTableDefDisk)))
			{
				CloseTable();
				return (hr);
			}
		}
		// For read case, init the array for lookup on top of our data.
		else
		{
			_ASSERTE(pTableHdr->cbRecordSize == m_pTableDef->iRecordSize);

			// Find the first index header, after the records.
			STGINDEXHDR *pIndexHdr;
			
			if (pTableHdr->iIndexes)
			{
				pIndexHdr = (STGINDEXHDR *)((UINT_PTR) pData + ALIGN4BYTE(sizeof(STGTABLEHDR) + (pTableHdr->iRecords * pTableHdr->cbRecordSize)));
			}
			else
				pIndexHdr = 0;

			// Load the indexes.
			if (FAILED(hr = LoadIndexes(m_pTableDef, pTableHdr->iRecords, 
					pTableHdr->iIndexes, pIndexHdr)))
			{
				CloseTable();
				return (hr);
			}

			// Init the record manager on top of this memory.
			m_RecordHeap.VMArray.InitOnMem(
					(void *) ((UINT_PTR) pData + sizeof(STGTABLEHDR)),
					m_pTableDef->iRecordSize * pTableHdr->iRecords,
					pTableHdr->iRecords,
					m_pTableDef->iRecordSize);
		}
	}
	// For create case, init everything to empty.
	else
	{
		RECORDHEAP *pRecordHeap = &m_RecordHeap;

		// If caller gave us a hint as to how many initial records to use,
		// then try that many instead of default growth size.
		if (InitialRecords != 0)
			m_iGrowInc = InitialRecords;

		// Allocate the initial record heap.
		if (FAILED(hr = m_pDB->GetRecordHeap(m_iGrowInc, m_pTableDef->iRecordSize, 0, 
						false, &pRecordHeap, &m_iGrowInc)) ||
			FAILED(hr = LoadIndexes()))
		{
			CloseTable();
			return (hr);
		}
	}
	return (S_OK);
}


//*****************************************************************************
// Close the given table.
//*****************************************************************************
void StgRecordManager::CloseTable()
{
	// Delete each index in the array.
	for (int i=0;  i<m_rpIndexes.Count();  i++)
		if (m_rpIndexes[i])
		{
			m_rpIndexes[i]->Close();
			m_rpIndexes[i]->Release();
			m_rpIndexes[i] = 0;
		}
	m_rpIndexes.Clear();

	// Free the table data allocated.
	m_pDB->FreeRecordHeap(m_RecordHeap.pNextHeap);
	m_pDB->FreeHeapData(&m_RecordHeap);
}


//*****************************************************************************
// Insert a new record at the tail of the record heap.  If there is not room
// in the current heap, a new heap is chained in and used.  No data values
// are actually set for the new records.  All columns are set to their default
// values (0 offsets, 0 data values), and all nullable columns are marked
// as such.  No primary key or unique index enforcement is done by this function.
//*****************************************************************************
HRESULT StgRecordManager::InsertRecord(	// Return code.
	RECORDID	*psNewID,				// New record ID, 0 valid.
	ULONG		*pLocalRecordIndex,		// Index in tail heap of new record.
	STGRECORDHDR **ppRecord,			// Return record.
    STGRECORDFLAGS fFlags)              // optional flag argument to indicate
                                        // temporary record.
{
	RECORDHEAP	*pRecordHeap;			// New record heap on overflow.
	RECORDID	RecordIndex=0xffffffff; // 0 based index of record.
	int			iPKSets = 0;			// Count primary key updates.
	HRESULT		hr = S_OK;

	// Avoid any confusion.
	*ppRecord = 0;

	// Don't let updates happen in read only mode.
	if (FAILED(hr = RequiresWriteMode()))
		return (hr);

	// Allocate a new record starting with the tail heap.  If the tail heap
	// is full, a new one may be required.
	while (true)
	{
		if ((*ppRecord = (STGRECORDHDR *) m_pTailHeap->VMArray.Append()))
			break;

		// Figure out how many records to allocate.  This needs to be
		// scalable so we can figure out when we are doing lots of bulk
		// operations and not waste too much time on small stuff.  This code
		// will do 3 grows at the same value, then double the grow size.
		if (m_RecordHeap.Count() / m_iGrowInc >= 3)
			m_iGrowInc *= 2;

		// There was no room, so allocate a new heap.
		if (FAILED(hr = m_pDB->GetRecordHeap(m_iGrowInc, m_pTableDef->iRecordSize, 
					0, true, &pRecordHeap, &m_iGrowInc)))
			return (hr);

		// Link in the heap to the tail.
		m_pTailHeap->pNextHeap = pRecordHeap;
		m_pTailHeap = pRecordHeap;
	}

	// Init the new record.
	memset(*ppRecord, 0, m_pTableDef->iRecordSize);
	if (psNewID)
		*psNewID = GetRecordID(*ppRecord);

	// Save off the local index, which can be used for deletes.
	_ASSERTE(pLocalRecordIndex);
	*pLocalRecordIndex = m_pTailHeap->VMArray.ItemIndex(*ppRecord);

	// Set all cell's for the record to NULL as a default.
	SetCellNull(*ppRecord, -1, true);
	return (S_OK);
}


//*****************************************************************************
// Inserts a new row into the data store.  If there is a unique index, then 
// the uniqueness of the key is validated.
//@todo: check for any outstanding row references; if there are any, then we
// cannot do an insert because the array might grow and relocate in memory.
//*****************************************************************************
HRESULT StgRecordManager::InsertRow(	// Return code.
	RECORDID	*psNewID,				// New record ID, 0 valid.
	BYTE		*pData,					// User's data.
	ULONG		iColumns,				// How many columns to insert.
	DBBINDING	rgBindings[],			// Array of column data.
	STGRECORDHDR **ppRecord,			// Return record pointer.
    STGRECORDFLAGS fFlags,              // optional flag argument to indicate
                                        // temporary record.
	int			bSignalIndexes)			// true if indexes should be built.
{
	RECORDID	RecordIndex=0xffffffff; // 0 based index of record.
	ULONG		LocalRecordIndex;		// 0 based index in current heap.
	int			iPKSets = 0;			// Count primary key updates.
	int			bIndexesUpdated = false;// true after indexes are built.
	HRESULT		hr = S_OK;

	// Validate assumptions.
	_ASSERTE(ppRecord);

	// Insert a new record into the table.
	if (FAILED(hr = InsertRecord(psNewID, &LocalRecordIndex, ppRecord, fFlags)))
		goto ErrExit;

	// Delegate actual column sets to the update routine.
	if (FAILED(hr = SetData(*ppRecord, pData, iColumns, rgBindings, &iPKSets, false)))
		return (hr);

	// If the table has a primary key column, and a value for that column
	// was not given, then it is an error.
	if (iPKSets == 0 && m_pTableDef->HasPrimaryKeyColumn())
	{
		hr = PostError(CLDB_E_RECORD_PKREQUIRED);
		goto ErrExit;
	}

	// Calculate record index only if required (requires heap scan).
	if (iColumns || (fFlags & RECORDF_TEMP))
		RecordIndex = m_RecordHeap.IndexForRecord(*ppRecord);

	// Check for failure on data copies, then signal indexes to update.
	if (iColumns && bSignalIndexes)
	{ 
		_ASSERTE(RecordIndex != 0xffffffff);

		if (SUCCEEDED(hr))
			hr = SignalAfterInsert(RecordIndex, *ppRecord, 0, true);

		if (FAILED(hr))
			goto ErrExit;
		bIndexesUpdated = true;
	}

    // finally set the temp flag is this function was called for a temporary
    // record.
    if (fFlags & RECORDF_TEMP)
    {
		_ASSERTE(RecordIndex != 0xffffffff);

        hr = m_rgRecordFlags.SetFlags(RecordIndex, fFlags);
        if (FAILED(hr))        
        {
            // undo all the change because SetFlags failed.
            // we don't need to get the return code since we're bailing out 
            // with another error anyways.
			goto ErrExit;
        }
    }

	// We are now dirty.
	SetDirty();

ErrExit:
	// Check for failures and abort the record.
	if (FAILED(hr))
	{
		// Undo indexes if they were built.
        if (bSignalIndexes && bIndexesUpdated)
			VERIFY(SignalAfterDelete(m_pTableDef, RecordIndex, *ppRecord, 0) == S_OK); 

		// Abort the record.
		m_pTailHeap->VMArray.Delete(LocalRecordIndex);
	}
	return (hr);
}


//*****************************************************************************
// Deletes a record from the table.  This will only mark the record deleted,
// the record is actually removed from the table at save time.  Also need to
// remove the record from indexes so it is not found in future queries.
//*****************************************************************************
HRESULT StgRecordManager::DeleteRow(	// Return code.
	STGRECORDHDR *psRecord,				// The record to delete.
	DBROWSTATUS	*pRowStatus)			// Return status if desired.
{
	RECORDHEAP	*pRecordHeap = &m_RecordHeap; // Start heap for search.
	ULONG		RecordIndex;			// 0 based index of record through all heaps.
	HRESULT		hr = S_OK;

	// Don't let updates happen in read only mode.
	if (FAILED(hr = RequiresWriteMode()))
		return (hr);

	// Get the index of the row to delete, check for errors.
	RecordIndex = m_RecordHeap.GetHeapForRecord(psRecord, pRecordHeap);
	if (RecordIndex == ~0)
	{
		if (pRowStatus)
			*pRowStatus = DBROWSTATUS_E_INVALID;
		return (PostError(DB_E_ERRORSOCCURRED));
	}

	// Don't call this function on already deleted records.  It probably points
	// to a case in your code that wasn't paying attention to what it did
	// with the record pointer.
	_ASSERTE((m_rgRecordFlags.GetFlags(RecordIndex) & RECORDF_DEL) == 0);

	// Mark the record deleted.
	hr = m_rgRecordFlags.SetFlags(RecordIndex, RECORDF_DEL);

	// If successful, mark us dirty and touch indexes.
	if (SUCCEEDED(hr))
	{
		SetDirty();
		VERIFY(SignalAfterDelete(m_pTableDef, RecordIndex, psRecord, 0) == S_OK); 
	}

	// Set return status for caller.
	if (pRowStatus)
	{
		if (FAILED(hr))
			*pRowStatus = DBROWSTATUS_E_OUTOFMEMORY;
		else
			*pRowStatus = DBROWSTATUS_S_OK;
	}
	return (hr);
}

//*****************************************************************************
// Return table information.
//*****************************************************************************

LPCWSTR StgRecordManager::TableName()
{ 
	return (m_pSchema->pNameHeap->GetString(m_pTableDef->Name)); 
}

STGTABLEDEF	*StgRecordManager::GetTableDef()
{	
	_ASSERTE(m_pSchema);
	return (m_pSchema->pSchema->GetTableDef(m_iTableDef)); 
}


//*****************************************************************************
// Count the records in the table.
//@future: If we had a count of deleted, Records() wouldn't have to scan
// at all.
//*****************************************************************************
ULONG StgRecordManager::Records(		// Return the count.
	int			bCountDeleted)			// True to count deleted records.
{
	ULONG		i, iCount, iDeleted;
	
	// Need the total count of records in all heaps.  m_rgRecordFlags
	// is sparse; it doesn't have to have an element for every record.
	iCount = m_RecordHeap.Count();

	// If there are record flags, then it could mean deleted items which
	// we cannot count.  Have to scan the list.
	if (m_rgRecordFlags.HasFlags() && bCountDeleted)
	{
		for (i=0, iDeleted=0;  i<(ULONG) m_rgRecordFlags.Count();  i++)
		{
			if (m_rgRecordFlags.GetFlags(i) & RECORDF_DEL)
				++iDeleted;
		}
		iCount -= iDeleted;
	}
	return (iCount);
}


//
//
// CAlignColumns
//
//

int CAlignColumns::Compare(				// -1, 0, or 1
	ALIGNCOLS	*psFirst,				// First item to compare.
	ALIGNCOLS	*psSecond)				// Second item to compare.
{
	// Sort by type first.
	if (psFirst->iType < psSecond->iType)
		return (-1);
	else if (psFirst->iType > psSecond->iType)
		return (1);

	// Sort fixed size columns in descending order by size, leaving smaller
	// items at the end of the fixed columns.
	if (psFirst->iType == ITEMTYPE_FIXCOL)
	{
		if (psFirst->iSize > psSecond->iSize)
			return (-1);
		else if (psFirst->iSize < psSecond->iSize)
			return (1);
		
		// If the two columns have the same size, order by column number.
		return (CMPVALS(psFirst->uData.pColDef->iColumn, psSecond->uData.pColDef->iColumn));
	}
	// Sort heaped columns in ascending order by size, putting smaller items
	// adjacent to smaller fixed sized columns, more alignment opportunity here.
	else if (psFirst->iType == ITEMTYPE_HEAPCOL)
	{
		if (psFirst->iSize < psSecond->iSize)
			return (-1);
		else if (psFirst->iSize > psSecond->iSize)
			return (1);

		// All things equal, sort by column id.
		return (CMPVALS(psFirst->uData.pColDef->iColumn, psSecond->uData.pColDef->iColumn));
	}
	// Sort indexes by index number.
	else
	{
		_ASSERTE(psFirst->iSize == psSecond->iSize);
		_ASSERTE(psFirst->uData.pIndexDef->iIndexNum != psSecond->uData.pIndexDef->iIndexNum);
		return (CMPVALS(psFirst->uData.pIndexDef->iIndexNum, psSecond->uData.pIndexDef->iIndexNum));
	}
}


void CAlignColumns::AddColumns(
	ALIGNCOLS	*rgAlignData,			// The array to fill out.
	STGTABLEDEF *pTableDef,				// The table definition to work on.
	int			*piColumns)				// Count columns we store.
{
	int			i;
	// Add the columns to the array.
	for (i=0, *piColumns=0;  i<pTableDef->iColumns;  i++)
	{
		VERIFY(rgAlignData[*piColumns].uData.pColDef = pTableDef->GetColDesc(i));
		if (rgAlignData[*piColumns].uData.pColDef->IsRecordID())
			continue;

		rgAlignData[*piColumns].iSize = rgAlignData[*piColumns].uData.pColDef->iSize;
		if (IsPooledType(rgAlignData[*piColumns].uData.pColDef->iType))
			rgAlignData[*piColumns].iType = ITEMTYPE_HEAPCOL;
		else
			rgAlignData[*piColumns].iType = ITEMTYPE_FIXCOL;

		++(*piColumns);
	}
}


void CAlignColumns::AddIndexes(
	ALIGNCOLS	*rgAlignData,			// The array to fill out.
	STGTABLEDEF *pTableDef,				// The table definition to work on.
	int			iIndexSize)				// How big is an index item.
{
	STGINDEXDEF	*pIndexDef;				// Working pointer.

	for (int i=0, j=0;  i<pTableDef->iIndexes;  i++)
	{
		VERIFY(pIndexDef = pTableDef->GetIndexDesc(i));
		
		if ((pIndexDef->fFlags & DEXF_INCOMPLETE) == 0)
		{
			rgAlignData[j].uData.pIndexDef = pIndexDef;
			rgAlignData[j].iType = ITEMTYPE_INDEX;
			rgAlignData[j].iSize = iIndexSize;
			++j;
		}
	}
}




//
//
// CIndexList
//
//

//*****************************************************************************
// When indexes are updated, one can collect the precise list of those indexes
// to use later.  For example, one might want the list of indexes which were
// modified during an update of a record, so that if the update fails, those
// same indexes may be re-indexed later.  Note that the pointers to the index
// objects are cached, but no ref counting is done.  If this is a requirement,
// the caller must do this.   This is a performance optimization because it
// is expected that the list is maintained within an outer scope.
//*****************************************************************************

CIndexList::CIndexList()
{
	Init();
}

CIndexList::~CIndexList()
{
	Clear();
}


//*****************************************************************************
// Zero out all pointers in our local array, then put the dyn array on top of
// that memory.
//*****************************************************************************
void CIndexList::Init()
{
	m_rgList.Clear();
	m_rgList.InitOnMem(sizeof(IStgIndex *), &m_rgIndexList[0], 
			0, SMALLDEXLISTSIZE);
}


//*****************************************************************************
// Add a new item to the list.  Note that the dynarray will handle overflow of 
// the local array automatically.  No Addref is done.
//*****************************************************************************
HRESULT CIndexList::Add(				// Return code.
	IStgIndex	*pIIndex)				// Index object to place in array.
{
	IStgIndex	**ppIIndex;
	ppIIndex = m_rgList.Append();
	if (!ppIIndex)
		return (PostError(OutOfMemory()));

	*ppIIndex = pIIndex;
	return (S_OK);
}


//*****************************************************************************
// Clear the list of items.  No release is done on the contained pointers.
//*****************************************************************************
void CIndexList::Clear()
{
	m_rgList.Clear();
	Init();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgpooli.h ===
//*****************************************************************************
// StgPooli.h
//
// This is helper code for the string and blob pools.  It is here because it is
// secondary to the pooling interface and reduces clutter in the main file.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgPooli_h__
#define __StgPooli_h__

#include "UtilCode.h"					// Base hashing code.



//
//
// CPackedLen
//
//

//*****************************************************************************
// Helper class to pack and unpack lengths.
//*****************************************************************************
struct CPackedLen
{
	enum {MAX_LEN = 0x1fffffff};
	static int Size(ULONG len)
	{
		// Smallest.
		if (len <= 0x7F)
			return 1;
		// Medium.
		if (len <= 0x3FFF)
			return 2;
		// Large (too large?).
		_ASSERTE(len <= MAX_LEN);
		return 4;
	}

	// Get the length value encoded at *pData.  Update ppData to point past data.
	static ULONG GetLength(void const *pData, void const **ppData=0);
	// Get the length value encoded at *pData, and the size of that encoded value.
	static ULONG GetLength(void const *pData, int *pSizeOfLength);
	// Pack a length at *pData; return a pointer to the next byte.
	static void* PutLength(void *pData, ULONG len);
};


class StgPoolReadOnly;

//*****************************************************************************
// This hash class will handle strings inside of a chunk of the pool.
//*****************************************************************************
struct STRINGHASH : HASHLINK
{
	ULONG		iOffset;				// Offset of this item.
};

class CStringPoolHash : public CChainedHash<STRINGHASH>
{
public:
	CStringPoolHash(StgPoolReadOnly *pool) : m_Pool(pool) {}

	virtual bool InUse(STRINGHASH *pItem)
	{ return (pItem->iOffset != 0xffffffff); }

	virtual void SetFree(STRINGHASH *pItem)
	{ pItem->iOffset = 0xffffffff; }

	virtual ULONG Hash(const void *pData)
	{ return (HashString(reinterpret_cast<LPCWSTR>(pData))); }

	virtual int Cmp(const void *pData, void *pItem);

private:
	StgPoolReadOnly *m_Pool;				// String pool which this hashes.
};


//*****************************************************************************
// This version is for byte streams with a 2 byte WORD giving the lenght of
// the data.
//*****************************************************************************
typedef STRINGHASH BLOBHASH;

class CBlobPoolHash : public CChainedHash<STRINGHASH>
{
public:
    CBlobPoolHash(StgPoolReadOnly *pool) : m_Pool(pool) {}

    virtual bool InUse(BLOBHASH *pItem)
	{ return (pItem->iOffset != 0xffffffff); }

    virtual void SetFree(BLOBHASH *pItem)
	{ pItem->iOffset = 0xffffffff; }

	virtual ULONG Hash(const void *pData)
	{
		ULONG		ulSize;
		ulSize = CPackedLen::GetLength(pData);
		ulSize += CPackedLen::Size(ulSize);
		return (HashBytes(reinterpret_cast<BYTE const *>(pData), ulSize));
	}

	virtual int Cmp(const void *pData, void *pItem);

private:
    StgPoolReadOnly *m_Pool;                // Blob pool which this hashes.
};

//*****************************************************************************
// This hash class will handle guids inside of a chunk of the pool.
//*****************************************************************************
struct GUIDHASH : HASHLINK
{
	ULONG		iIndex;					// Index of this item.
};

class CGuidPoolHash : public CChainedHash<GUIDHASH>
{
public:
    CGuidPoolHash(StgPoolReadOnly *pool) : m_Pool(pool) {}

	virtual bool InUse(GUIDHASH *pItem)
	{ return (pItem->iIndex != 0xffffffff); }

	virtual void SetFree(GUIDHASH *pItem)
	{ pItem->iIndex = 0xffffffff; }

	virtual ULONG Hash(const void *pData)
	{ return (HashBytes(reinterpret_cast<BYTE const *>(pData), sizeof(GUID))); }

    virtual int Cmp(const void *pData, void *pItem);

private:
    StgPoolReadOnly *m_Pool;                // The GUID pool which this hashes.
};


#endif // __StgPooli_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgrecordmanagerdata.cpp ===
//*****************************************************************************
// StgRecordManagerData.cpp
//
// This module contains implementation code for StgRecordManager related to
// individual data values.	This includes public functions like:
//		GetSaveSize
//		SaveToStream
//		LoadFromStream
//		Set/GetData
//		Set/GetCellNull
// and major helper code like:
//		Set/GetCellValue
//
// Any code that deals with read/writing records, getting/setting values for
// data cells, and any data conversion issues should be in this module.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h" 					// Standard include.
#include <mbstring.h>					// MBCS support for data conversion.
#include "Services.h"					// For data conversion.
#include "OleDBUtil.h"					// OLE DB Helpers.
#include "StgDatabase.h"				// Parent database.
#include "StgRecordManager.h"			// Record manager interface.
#include "StgIndexManager.h"			// Index code.
#include "StgSortedIndex.h" 			// sorted index code.
#ifdef _DEBUG
#include "StgTiggerStream.h"			// Need to check GetSaveSize.
#endif


//********** Macros and stuff. ************************************************
#define SCHEMA_NAME_TYPE L"%S"


// Locals.
int CheckTruncation(BYTE *pData, DBBINDING *pBinding, ULONG cbDataLen);
int StrCharLen(LPCSTR szStr, int iLen);
int StrBytesForCharLen(LPCSTR szStr, int iChars);
int Utf8BytesForCharLen(LPCSTR szStr, int iChars);




class CMySortPKRecords : public CQuickSort<STGRECORDHDR *>
{
	CMySortPKRecords() : CQuickSort<STGRECORDHDR *>(0, 0) { };
public:
	CMySortPKRecords(STGCOLUMNDEF *pColDef, StgRecordManager *pRecordMgr, 
					STGRECORDHDR *pBase[], int iCount) :
		CQuickSort<STGRECORDHDR *>(pBase, iCount),
		m_pColDef(pColDef),
		m_pRecordMgr(pRecordMgr)
	{ }

	virtual int Compare(STGRECORDHDR **p1, STGRECORDHDR **p2)
	{
		return (m_pRecordMgr->CompareRecords(m_pColDef, *p1, *p2));
	}

	STGCOLUMNDEF *m_pColDef; 
	StgRecordManager *m_pRecordMgr;
};


//
//
// StgRecordManager
//
//




//*****************************************************************************
// Figure out how big an optimized version of this table would be.	Add up
// the size of all records, indexes, and headers we will write in SaveToStream
// and return this value in *pcbSaveSize.  The value returned must match the
// bytes that will be written to SaveToStream.
//*****************************************************************************
HRESULT StgRecordManager::GetSaveSize(	// Return code.
	ULONG		*pcbSaveSize,			// Return save size of table.
	STGTABLEDEF **ppTableDefSave)		// Return pointer to save def.
{
	ULONG		cbSaveSize = 0; 		// Track running total.
	ULONG		iIndexSize; 			// How big is a hash entry.
	int 		j, k;					// Loop control.
	HRESULT 	hr;

	// Don't let updates happen in read only mode.
	if (FAILED(hr = RequiresWriteMode()))
		return (hr);

	// Disallow more than one call.  You must call SaveToStream next.
	_ASSERTE(!m_pSaveRecords);

	// Allocate a save struct to cache optimized record layouts.
	if ((m_pSaveRecords = new SAVERECORDS) == 0)
		return (PostError(OutOfMemory()));

	// Init the struct for optimization.
	m_pSaveRecords->Clear();
	m_pSaveRecords->bFreeStruct = true;
	m_pSaveRecords->pNewTable = (STGTABLEDEF *) malloc(m_pTableDef->iSize);
	if (!m_pSaveRecords->pNewTable)
	{
		hr = PostError(OutOfMemory());
		goto ErrExit;
	}
	m_pSaveRecords->bFreeTable = true;

	// Copy the table format into the modifiable copy.
	memcpy(m_pSaveRecords->pNewTable, m_pTableDef, m_pTableDef->iSize);

	// Optimize the record layouts.
	if (FAILED(hr = SaveOptimize(m_pSaveRecords)))
		goto ErrExit;

	// Figure out how big a hash link is based on record count.
	if (m_pSaveRecords->iRecords < USHRT_MAX)
		iIndexSize = sizeof(USHORT);
	else
		iIndexSize = sizeof(ULONG);

	// Init with the size of the header.
	cbSaveSize = sizeof(STGTABLEHDR);

	// Add up the size of all records in the table in optimized format.
	cbSaveSize += m_pSaveRecords->iRecords * m_pSaveRecords->pNewTable->iRecordSize;
	cbSaveSize = ALIGN4BYTE(cbSaveSize);

	// Add the bucket size for each persistent index.
	for (j=0, k=0; j<m_pSaveRecords->pNewTable->iIndexes;  j++)
	{
		if ((m_pSaveRecords->rgIndexDefs[j]->fFlags & DEXF_INCOMPLETE) == 0)
		{
			ULONG		cbSize;
			VERIFY(m_pSaveRecords->rgIndexes[k]->GetSaveSize(
						iIndexSize, &cbSize, m_pSaveRecords->iRecords) == S_OK);
			cbSaveSize += cbSize;
			++k;
		}
	}

	// Add the size of this stream to the caller's running total.
	*pcbSaveSize += cbSaveSize;
	hr = S_OK;
	DEBUG_STMT(m_pSaveRecords->cbSaveSize = cbSaveSize);

	// Return optimized table def.
	if (ppTableDefSave)
		*ppTableDefSave = m_pSaveRecords->pNewTable;

	// Clean up any memory allocated on failure.
ErrExit:
	if (FAILED(hr))
		ClearOptimizedData();
	return (hr);
}


//*****************************************************************************
// This step will mark the pooled data which are still live in the database.
//	This is in preparation for saving to disk.	(Pooled data types are
//	strings, guids, blobs, and variants.)
//*****************************************************************************
HRESULT StgRecordManager::MarkLivePoolData()	// Return code.
{
	int 		iColumn;				// Loop control.
	ULONG		RecordIndex;			// 0 based index through all heaps.
	ULONG		LocalRecordIndex;		// 0 based index per heap.
	RECORDHEAP	*pRecordHeap;			// Current heap for row scan.
	STGRECORDHDR *pRow; 				// Pointer to a row.
	STGCOLUMNDEF *pRowCol;				// A column definition.
	ULONG		ulCookie;				// An index or offset.
	BYTE		fFlags; 				// record flag.
	HRESULT 	hr;

	// No point in this in read-only mode.
	if (FAILED(hr = RequiresWriteMode()))
		return (hr);

	// Walk through every record and mark all live pooled data.
	for (RecordIndex=0, pRecordHeap = &m_RecordHeap;  pRecordHeap;
						pRecordHeap = pRecordHeap->pNextHeap)
	{
		// Loop through all records in the current heap.
		for (LocalRecordIndex=0;  LocalRecordIndex<pRecordHeap->VMArray.Count();
					LocalRecordIndex++, RecordIndex++)
		{
			// If the row is deleted, skip it.
			fFlags = m_rgRecordFlags.GetFlags(RecordIndex);
			if ((fFlags & (RECORDF_DEL | RECORDF_TEMP)) != 0)
				continue;
			VERIFY(pRow = (STGRECORDHDR *) pRecordHeap->VMArray.Get(LocalRecordIndex));
			if (pRow == 0)
				continue;

			// Examine each column, looking for pooled data.
			for (iColumn=0;  iColumn<m_pTableDef->iColumns;  iColumn++)
			{
				// Get the column description.
				VERIFY(pRowCol = m_pTableDef->GetColDesc(iColumn));

				// This column is derived not persistent.
				if (pRowCol->IsRecordID())
					continue;

				// Determine the type and mark the data.
				switch (pRowCol->iType)
				{
				case DBTYPE_VARIANT:
					ulCookie = *(ULONG *) FindColCellOffset(pRowCol, pRow);
					if (FAILED(hr = m_pSchema->GetVariantPool()->OrganizeMark(ulCookie)))
						goto ErrExit;
					break;

				case DBTYPE_STR:
				case DBTYPE_WSTR:
					ulCookie = *(ULONG *) FindColCellOffset(pRowCol, pRow);
					if (FAILED(hr = m_pSchema->GetStringPool()->OrganizeMark(ulCookie)))
						goto ErrExit;
					break;

				case DBTYPE_GUID:
					ulCookie = *(ULONG *) FindColCellOffset(pRowCol, pRow);
					if (FAILED(hr = m_pSchema->GetGuidPool()->OrganizeMark(ulCookie)))
						goto ErrExit;
					break;

				case DBTYPE_BYTES:
					ulCookie = *(ULONG *) FindColCellOffset(pRowCol, pRow);
					if (FAILED(hr = m_pSchema->GetBlobPool()->OrganizeMark(ulCookie)))
						goto ErrExit;
					break;

				default:
					break;
				} // switch (pRowCol->iType)
			} // for (iColumn
		} // for records in this heap
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Saves an entire copy of the table into the given stream.
//*****************************************************************************
HRESULT StgRecordManager::SaveToStream( // Return code.
	IStream 	*pIStream,				// Where to save copy of table to.
	STGTABLEDEF *pNewTable, 			// Return new table def here.
	INTARRAY	&rgVariants,			// New variant offsets for rewrite.
	SCHEMADEFS	*pSchema,				// Schema for save.
	bool		bSaveIndexes)			// true if index data is taken too.
{
	SCHEMADEFS	*pSchemaCopy=0; 		// Track the original schema.
	STGTABLEHDR sTableHdr;				// Header for stream.
	RECORDID	iRecord;				// Loop control on record list.
	ULONG		cbWrite;				// Values for data writes.
	int 		bFree = false;			// Assume caller gives us optimize struct.
	int 		j, k;					// Loop control.
	HRESULT 	hr;

	// Don't let updates happen in read only mode.
	if (FAILED(hr = RequiresWriteMode()))
		return (hr);

	// Make a backup copy of the real schema.
	pSchemaCopy = m_pSchema;

	// Use for case where optimization was not already done during GetSaveSize.
	SAVERECORDS sSaveRecords;

	// If record format has not already been optimized, then setup for the save.
	if (!m_pSaveRecords)
	{
		m_pSaveRecords = &sSaveRecords;
		m_pSaveRecords->Clear();
		m_pSaveRecords->pNewTable = pNewTable;

		// Copy the current table definition into the working version that
		// will get optimized.
		memcpy(pNewTable, m_pTableDef, m_pTableDef->iSize);

		// Optimize the record layouts.
		if (FAILED(hr = SaveOptimize(m_pSaveRecords)))
			goto ErrExit;
	}
	// Give caller a copy of our tuned schema.	The database save code
	// needs this to flush the #Schema stream.
	else
	{
		memcpy(pNewTable, m_pSaveRecords->pNewTable, m_pTableDef->iSize);
	}

	// Allocate memory for the data we intend to use.
	if ((m_pSaveRecords->pNewData = malloc(pNewTable->iRecordSize * m_pSaveRecords->iRecords)) == 0)
	{
		ClearOptimizedData();
		hr = PostError(OutOfMemory());
		goto ErrExit;
	}

	// Init a struct array on top of the memory that will hold the copy.
	m_pSaveRecords->RecordHeap.VMArray.InitOnMem(m_pSaveRecords->pNewData,
		m_pSaveRecords->iRecords * pNewTable->iRecordSize,
		m_pSaveRecords->iRecords, pNewTable->iRecordSize);

	// Walk through every record and copy it.
	for (iRecord=0;  iRecord<(RECORDID) m_pSaveRecords->iRecords;  iRecord++)
	{
		// Get pointers to the rows.
		STGRECORDHDR	*pFrom, *pTo;
		STGCOLUMNDEF	*pFromCol, *pToCol;
		VERIFY(pTo = (STGRECORDHDR *) m_pSaveRecords->RecordHeap.VMArray.Get(iRecord));
		pFrom = m_pSaveRecords->rgRows[iRecord];

		// If the from record is deleted, then skip it.
		if (pFrom == 0)
			continue;

		// Clear the null bitmask.
		if (pNewTable->iNullBitmaskCols)
			memset(pNewTable->NullBitmask(pTo), 0,
					(pNewTable->iNullBitmaskCols / 8) + ((pNewTable->iNullBitmaskCols % 8) ? 1 : 0));

		// Copy the data from the source row to the new row.
		for (j=0;  j<m_pTableDef->iColumns;  j++)
		{
			// Get the column descriptions for the copy.
			VERIFY(pFromCol = m_pTableDef->GetColDesc(j));
			VERIFY(pToCol = pNewTable->GetColDesc(pFromCol->iColumn - 1));
			_ASSERTE(pFromCol->iColumn == pToCol->iColumn);

			// This column is derived not persistent.
			if (pFromCol->IsRecordID())
				continue;

			// Check null for fixed columns; variable columns get the whole
			// value copied regardless.
			if (IsNonPooledType(pFromCol->iType) && (pFromCol->fFlags & CTF_NULLABLE) &&
				GetCellNull(pFrom, pFromCol->iColumn - 1))
			{
				SetBit((BYTE *) pNewTable->NullBitmask(pTo),
						pToCol->iNullBit, true);
			}

			// Determine the type and copy the data.
			switch (pFromCol->iType)
			{
				case DBTYPE_VARIANT:
				{
					ULONG		cbOffset;
					cbOffset = *(ULONG *) FindColCellOffset(pFromCol, pFrom);

					// Map index.
					if (FAILED(hr = m_pSchema->GetVariantPool()->OrganizeRemap(cbOffset, &cbOffset)))
						goto ErrExit;

					// Set target cell based on size.
					if (pToCol->iSize == sizeof(USHORT))
						*(USHORT *) FindColCellOffset(pToCol, pTo) = (USHORT) cbOffset;
					else
						*(ULONG *) FindColCellOffset(pToCol, pTo) = cbOffset;
				}
				break;

				case DBTYPE_STR:
				case DBTYPE_WSTR:
				{
					ULONG	cbOffset;
					cbOffset = *(ULONG *) FindColCellOffset(pFromCol, pFrom);
					if (FAILED(hr = m_pSchema->GetStringPool()->OrganizeRemap(cbOffset, &cbOffset)))
						goto ErrExit;

					if (pToCol->iSize == sizeof(ULONG))
						*(ULONG *) FindColCellOffset(pToCol, pTo) = cbOffset;
					else
						*(USHORT *) FindColCellOffset(pToCol, pTo) = static_cast<USHORT>(cbOffset);
				}
				break;

				case DBTYPE_GUID:
				{
					ULONG	cbOffset;
					cbOffset = *(ULONG *) FindColCellOffset(pFromCol, pFrom);
					if (FAILED(hr = m_pSchema->GetGuidPool()->OrganizeRemap(cbOffset, &cbOffset)))
						goto ErrExit;

					if (pToCol->iSize == sizeof(ULONG))
						*(ULONG *) FindColCellOffset(pToCol, pTo) = cbOffset;
					else
						*(USHORT *) FindColCellOffset(pToCol, pTo) = static_cast<USHORT>(cbOffset);
				}
				break;

				case DBTYPE_BYTES:
				{
					ULONG	cbOffset;
					cbOffset = *(ULONG *) FindColCellOffset(pFromCol, pFrom);
					if (FAILED(hr = m_pSchema->GetBlobPool()->OrganizeRemap(cbOffset, &cbOffset)))
						goto ErrExit;

					if (pToCol->iSize == sizeof(ULONG))
						*(ULONG *) FindColCellOffset(pToCol, pTo) = cbOffset;
					else
						*(USHORT *) FindColCellOffset(pToCol, pTo) = static_cast<USHORT>(cbOffset);
				}
				break;

				case DBTYPE_OID:
				if (pToCol->iSize == sizeof(ULONG))
					*(ULONG *) FindColCellOffset(pToCol, pTo) =
						*(ULONG *) FindColCellOffset(pFromCol, pFrom);
				else
					*(USHORT *) FindColCellOffset(pToCol, pTo) =
						(USHORT) *(ULONG *) FindColCellOffset(pFromCol, pFrom);
				break;

				default:
				_ASSERTE(pToCol->iSize == pFromCol->iSize);
				memcpy(FindColCellOffset(pToCol, pTo),
					FindColCellOffset(pFromCol, pFrom),
					pToCol->iSize);
				break;
			}
		}

		// Walk the indexes and tell them about the new row.
		if (m_pSaveRecords->iPersistIndexes)
		{
			// Point the schema to the newly formatted data.
			m_pSchema = pSchema;

			for (j=0, k=0; j<pNewTable->iIndexes;  j++)
			{
				// Incomplete Indexes and Sorted Array Indexes do not need to be informed of the
				// insertion.
				if ((m_pSaveRecords->rgIndexDefs[j]->fFlags & DEXF_INCOMPLETE) == 0)
				{
					// If it needs save notification, then tell it now.
					if (m_pSaveRecords->rgIndexDefs[j]->NeedsSaveNotify())
					{
						if (FAILED(hr = m_pSaveRecords->rgIndexes[k]->
										AfterInsert(pNewTable, iRecord, pTo, false)))
							break;
					}

					// Got to next complete index.
					++k;
				}
			}

			// Reset the schema back to the real one for offset copies.
			m_pSchema = pSchemaCopy;
		}
	}

	// Save the record count which will determine how big the data part is.
	memset(&sTableHdr, 0, sizeof(STGTABLEHDR));
	sTableHdr.iRecords = m_pSaveRecords->iRecords;
	sTableHdr.cbRecordSize = pNewTable->iRecordSize;
	sTableHdr.iIndexes = m_pSaveRecords->iPersistIndexes;

	// Check for error and write the header for the table.
	if (FAILED(hr) ||
		FAILED(hr = pIStream->Write(&sTableHdr, sizeof(STGTABLEHDR), 0)))
	{
		goto ErrExit;
	}

	// Write out the records if there are any.
	cbWrite = pNewTable->iRecordSize * m_pSaveRecords->RecordHeap.VMArray.Count();
	if (cbWrite && FAILED(hr = pIStream->Write(m_pSaveRecords->RecordHeap.VMArray.Ptr(), cbWrite, 0)))
	{
		goto ErrExit;
	}

	// Pad the record data to a 4 byte alignment.
	if (cbWrite % 4 != 0)
	{
		ULONG		cbPad = 0;
		if (FAILED(hr = pIStream->Write(&cbPad, ALIGN4BYTE(cbWrite) - cbWrite, 0)))
			goto ErrExit;
	}

	// Next walk each index and tell them to save their buckets to disk.
	if (m_pSaveRecords->iPersistIndexes)
	{
		for (j=0, k=0;	j<pNewTable->iIndexes;	j++)
		{
			if ((m_pSaveRecords->rgIndexDefs[j]->fFlags & DEXF_INCOMPLETE) == 0)
			{
				if (FAILED(hr = m_pSaveRecords->rgIndexes[k]->SaveToStream(pIStream,
						m_pSaveRecords->rgRid, m_pSaveRecords->iRecords)))
				{
					break;
				}
				++k;
			}
		}
	}

	// Done with new record data.
ErrExit:
	if (m_pSaveRecords)
	{
		// If this fires, it means that the estimated size we gave on
		// GetSaveSize was not correct.  This is a severe error.
		_ASSERTE(m_pSaveRecords->bFreeStruct == false || ((TiggerStream *) pIStream)->GetStreamSize() == m_pSaveRecords->cbSaveSize);

		// Clean up allocated memory.
		ClearOptimizedData();
	}

	if (FAILED(hr))
		return (hr);
	return (S_OK);
}


//*****************************************************************************
// Import the data from an on disk schema (identified by pSchemaDefDisk and
// pTableDefDisk) into an in memory copy that is in full read/write format.
// This requires changing offsets from 2 to 4 bytes, and other changes to
// the physical record layout.	The record are automatically allocated in a
// new record heap.
//*****************************************************************************
HRESULT StgRecordManager::LoadFromStream(// Return code.
	STGTABLEHDR *pTableHdr, 			// Header for stream.
	void		*pData, 				// The data from the file.
	ULONG		cbData, 				// Size of the data.
	SCHEMADEFS	*pSchemaDefDisk,		// Schema for on disk format.
	STGTABLEDEF *pTableDefDisk) 		// The on disk format.
{
	RECORDHEAP	*pRecordHeap = &m_RecordHeap; // For allocating new records.
	ULONG		iOffset;				// For copying long data.
	int 		j;						// Loop control.
	HRESULT 	hr;

	// If there was no import definition, then use the in-memory version.
	if (!pSchemaDefDisk)
	{
		_ASSERTE(!pTableDefDisk);
		pSchemaDefDisk = m_pSchema;
		pTableDefDisk = m_pTableDef;
	}

	// Allocate enough room for the records we want.  Force a set of records
	// to be pre-allocated, we'll fill them on the import.
	if (FAILED(hr = m_pDB->GetRecordHeap(pTableHdr->iRecords,
			m_pTableDef->iRecordSize, pTableHdr->iRecords, false, &pRecordHeap,
			&m_iGrowInc)))
	{
		return (hr);
	}
	m_pTailHeap = &m_RecordHeap;

//@todo: If we can determine that the table def has not changed, then we
// could simply memcpy everything.

	// Set up two pointers for records.
	STGRECORDHDR	*pFrom, *pTo;
	pFrom = (STGRECORDHDR *) (pTableHdr + 1);
	pTo = (STGRECORDHDR *) m_RecordHeap.VMArray.Get(0);

	// Copy each record from disk.
	for (RECORDID iRecord=0;  iRecord<(RECORDID) pTableHdr->iRecords;  iRecord++)
	{
		STGCOLUMNDEF	*pFromCol, *pToCol;

		// Clear the null bitmask.
		if (m_pTableDef->iNullBitmaskCols)
			memset(m_pTableDef->NullBitmask(pTo), 0,
					(m_pTableDef->iNullBitmaskCols / 8) + ((m_pTableDef->iNullBitmaskCols % 8) ? 1 : 0));

		// Copy the data from the source row to the new row.
		for (j=0;  j<pTableDefDisk->iColumns;  j++)
		{
			// Get the column descriptions for the copy.
			VERIFY(pFromCol = pTableDefDisk->GetColDesc(j));
			VERIFY(pToCol = m_pTableDef->GetColDesc(pFromCol->iColumn - 1));
			_ASSERTE(pFromCol->iColumn == pToCol->iColumn);
			_ASSERTE(pFromCol->iType == pToCol->iType);

			// This column is derived not persistent.
			if (pFromCol->IsRecordID())
				continue;

			// Check null for fixed columns; variable columns get the whole
			// value copied regardless.
			if (IsNonPooledType(pFromCol->iType) && (pFromCol->fFlags & CTF_NULLABLE) &&
				GetCellNull(pFrom, pFromCol->iColumn - 1, pTableDefDisk))
			{
				SetBit((BYTE *) m_pTableDef->NullBitmask(pTo),
						pToCol->iNullBit, true);
			}

			// Determine the type and copy the data.
			switch (pFromCol->iType)
			{
				case DBTYPE_VARIANT:
				case DBTYPE_GUID:
				case DBTYPE_BYTES:
				case DBTYPE_STR:
				case DBTYPE_WSTR:
				case DBTYPE_OID:
				if (pFromCol->iSize == sizeof(ULONG))
					iOffset = *(ULONG *) FindColCellOffset(pFromCol, pFrom);
				else
				{
					iOffset = *(USHORT *) FindColCellOffset(pFromCol, pFrom);

					// Check for a null value, which when extended won't propagate the whole thing.
					if (iOffset == 0x0000ffff)
						iOffset = 0xffffffff;
				}
				*(ULONG *) FindColCellOffset(pToCol, pTo) = iOffset;

#ifdef _DEBUG
				// In debug, validate the heap offset is ok.
				if (pFromCol->iType == DBTYPE_STR || pFromCol->iType == DBTYPE_WSTR)
					_ASSERTE(iOffset == 0xffffffff || pSchemaDefDisk->pStringPool->IsValidCookie(iOffset));
				else if (pFromCol->iType == DBTYPE_BYTES)
					_ASSERTE(iOffset == 0xffffffff || pSchemaDefDisk->pBlobPool->IsValidCookie(iOffset));
				else if (pFromCol->iType == DBTYPE_GUID)
					_ASSERTE(iOffset == 0xffffffff || pSchemaDefDisk->pGuidPool->IsValidCookie(iOffset));
				else if (pFromCol->iType == DBTYPE_VARIANT)
					_ASSERTE(iOffset == 0xffffffff || pSchemaDefDisk->pVariantPool->IsValidCookie(iOffset));
#endif
				break;

				default:
				_ASSERTE(pToCol->iSize == pFromCol->iSize);
				memcpy(FindColCellOffset(pToCol, pTo),
					FindColCellOffset(pFromCol, pFrom),
					pToCol->iSize);
				break;
			}
		}

//@todo: This only needs to be done if the bucket ratios are changing.
// otherwise everything is just going to rehash to the same place anyway,
// so why go through the work?
		// Walk the indexes and tell them about the new row.
		for (j=0;  j<m_rpIndexes.Count();  j++)
			if (FAILED(hr = m_rpIndexes[j]->AfterInsert(m_pTableDef, iRecord, pTo, false)))
				return (hr); //@todo: clean up stream?

		// Find next record in from list.
		pFrom = (STGRECORDHDR *) ((UINT_PTR) pFrom + pTableDefDisk->iRecordSize);
		pTo = (STGRECORDHDR *) ((UINT_PTR) pTo + m_pTableDef->iRecordSize);
	}
	return (S_OK);
}


//*****************************************************************************
// Called whenever the schema this object belongs to changes.  This gives the
// object an opportunity to sync up its state.
//*****************************************************************************
void StgRecordManager::OnSchemaChange()
{
	VERIFY(m_pTableDef = GetTableDef());
}



//*****************************************************************************
// Update the data for the given record according to the binding data.	It is
// illegal to update the keys of a record.
//*****************************************************************************
HRESULT StgRecordManager::SetData(		// Return code.
	STGRECORDHDR *psRecord, 			// The record to work on.
	BYTE		*pData, 				// User's data.
	ULONG		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[],			// Column accessors.
	int 		*piPKSets,				// How many primary key columns set.
	bool		bNotifyIndexes) 		// true for Update, false for Insert.
{
	STGCOLUMNDEF *pColDef;				// Column definition.
	RECORDID	RecordIndex;			// The id of the record.
	ULONG		i;						// Loop control.
	ULONG		iGood = 0;				// Look for warnings & errors.
	bool		bColIndex;				// true if a column index update required.
	HRESULT 	hr = S_OK;

	// Don't let updates happen in read only mode.
	_ASSERTE(m_fFlags & SRM_WRITE);

	// Get the record id for this record.
	RecordIndex = m_RecordHeap.IndexForRecord(psRecord);

	// Reject update on deleted row.
	if (m_rgRecordFlags.GetFlags(RecordIndex) & RECORDF_DEL)
		return (PostError(DB_E_DELETEDROW));

	// Fill the data for each column.
	for (i=0;  i<iColumns;	i++)
	{
		// Load the column definition for this given column.
		VERIFY(pColDef = m_pTableDef->GetColDesc((int)(rgBindings[i].iOrdinal - 1)));

		// Cannot update a read only column.
		if (pColDef->IsRecordID())
			return (PostError(CLDB_E_COLUMN_READONLY, pColDef->iColumn, L"@todo"));
		
		// If the column is null, then set that row status.
		if ((rgBindings[i].dwPart & DBPART_STATUS) != 0 &&
			StatusPart(pData, &rgBindings[i]) == DBSTATUS_S_ISNULL)
		{
			//@todo: What if the column doesn't allow nulls, you should get
			// back an error?
			_ASSERTE(pColDef->fFlags & CTF_NULLABLE);

			SetCellNull(psRecord, pColDef->iColumn - 1, true);
			continue;
		}

		// An index update for the column is required if the caller wants one,
		// and either the column is indexed or it is a primary key.  A primary
		// key requires the update because we are in read mode (SetData is update)
		// and therefore a transient hash index is in place.
		bColIndex = bNotifyIndexes && (pColDef->fFlags & (CTF_INDEXED | CTF_PRIMARYKEY));

		// Let index remove the item for the change.
		if (bColIndex)
		{
			if (FAILED(hr = SignalBeforeUpdate(m_pTableDef, RecordIndex,
					psRecord, (USHORT) iColumns, rgBindings)))
				break;
		}

		// Set the value for this cell.
		if (FAILED(hr = SetCellValue(pColDef, psRecord, pData, &rgBindings[i])))
		{
			// Ignore status warnings, we'll map at end.
			if (hr == DB_S_ERRORSOCCURRED)
				hr = S_OK;
			else
			{
				//@todo: Code to undo "BeforeUpdate" goes here.
				_ASSERTE(!"NOTIMPL:  Code to undo BeforeUpdate");
				break;
			}
		}
		else
			++iGood;

		if (bColIndex)
		{
			// Give the index a chance to re-index data.
			if (FAILED(hr = SignalAfterUpdate(m_pTableDef, RecordIndex, 
					psRecord, (USHORT) iColumns, rgBindings)))
				break;
		}

		// Remove the null bit for the column, since there is data.
		SetCellNull(psRecord, (int) (rgBindings[i].iOrdinal - 1), false);

		// Count primary key updates.
		if (piPKSets && pColDef->IsPrimaryKey())
			++(*piPKSets);
	}

	// We are now dirty.
	SetDirty();

	// Figure out return code.
	if (FAILED(hr))
		return (hr);
	else if (iGood == iColumns)
		return (S_OK);
	else if (iGood > 0)
		return (DB_S_ERRORSOCCURRED);
	else
		return (PostError(DB_E_ERRORSOCCURRED));
}




//
//
//	Record handling.
//
//


//*****************************************************************************
// Set the given column cell by setting the correct bit in the record null bitmask.
//*****************************************************************************
void StgRecordManager::SetCellNull(
	STGRECORDHDR *psRecord, 			// Record to update.
	int 		iColumn,				// 0-based col number, -1 means all.
	bool		bNull)					// true for NULL.
{
	STGCOLUMNDEF *pColDef;				// Column definition.
	int 		i, iStart, iStop;		// Loop control.

	_ASSERTE(psRecord != 0);
	_ASSERTE(iColumn >= -1 && iColumn < m_pTableDef->iColumns);

	// Setup loop around each entry.
	if (iColumn == -1)
	{
		iStart = 0;
		iStop = m_pTableDef->iColumns;
	}
	else
	{
		iStart = iColumn;
		iStop = iColumn + 1;
	}

	// Set each cell null according to its rules.
	for (i=iStart;	i<iStop;  i++)
	{
		// Get the column description. If it canot be nullabe, nothing to do.
		VERIFY(pColDef = m_pTableDef->GetColDesc(i));
		if ((pColDef->fFlags & CTF_NULLABLE) == 0)
			continue;
		_ASSERTE(pColDef->IsRecordID() == false);

		// For fixed type data, then bit is in the description.
		if (IsNonPooledType(pColDef->iType))
			SetBit((BYTE *) m_pTableDef->NullBitmask(psRecord),
					pColDef->iNullBit, bNull);
		// For variable data, set the offset value to null.
		else if (bNull)
		{
			if (pColDef->iSize == sizeof(ULONG))
			{
				ULONG * p = (ULONG *) FindColCellOffset(pColDef, psRecord);
				*p = NULL_OFFSET;
			}
			else
			{
				USHORT * p = (USHORT *) FindColCellOffset(pColDef, psRecord);
				*p = 0xffff;
			}
		}
	}
}


//*****************************************************************************
// Return the NULL status for the given column number.
//*****************************************************************************
bool StgRecordManager::GetCellNull( 	// true if NULL.
	STGRECORDHDR *psRecord, 			// Record to update.
	int 		iColumn,				// 0-based col number.
	STGTABLEDEF *pTableDef) 			// Which table def, 0 means default.
{
	STGCOLUMNDEF *pColDef;				// Column definitions.

	// Which table def to use.
	if (pTableDef == 0)
		pTableDef = m_pTableDef;

	_ASSERTE(psRecord != 0);
	_ASSERTE(iColumn >= 0 && iColumn < m_pTableDef->iColumns);

	// Get the column description. If it canot be nullabe, nothing to do.
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn));
	if ((pColDef->fFlags & CTF_NULLABLE) == 0)
		return (false);

	// For fixed type data, then bit is in the description.
	if (IsNonPooledType(pColDef->iType))
	{
		// If you get this, the columns nullable flag was set incorrectly.
		_ASSERTE(pTableDef->NullBitmask(psRecord) != 0);

		// Check the bit in the bitmask.
		return (GetBit((BYTE *) pTableDef->NullBitmask(psRecord),
				pColDef->iNullBit) != 0);
	}
	// For variable data, use the offset to tell.
	else
	{
		if (pColDef->iSize == sizeof(USHORT))
			return (*(USHORT *) FindColCellOffset(pColDef, psRecord) == 0xffff);
		else
			return (*(ULONG *) FindColCellOffset(pColDef, psRecord) == 0xffffffff);
	}
}


//*****************************************************************************
// Sets the given cell to the new value as described by the user data.	The
// caller must be sure to make sure there is room for the data at the given
// record location.  So, for example, if you update a record to a size greater
// than what it used to be, watch for overwrite.
//*****************************************************************************
HRESULT StgRecordManager::SetCellValue( // Return code.
	STGCOLUMNDEF *pColDef,				// The column definition.
	STGRECORDHDR *psRecord, 			// Record to update.
	BYTE		*pData, 				// User's data.
	DBBINDING	*psBinding) 			// Binding information.
{
	ULONG		iLen;					// For variable sized data.
	int 		bTruncated = false; 	// Assume no truncation.
	DBSTATUS	dbStatus=DBSTATUS_S_OK; // Assume it works.
	HRESULT 	hr=S_OK;

	_ASSERTE(pColDef->IsRecordID() == false);

	if (// If data types match exactly, or
		pColDef->iType == (psBinding->wType & ~DBTYPE_BYREF) ||
		// Source/target is string data type (STR to WSTR, WSTR to STR, etc...)
		( ( (psBinding->wType & ~DBTYPE_BYREF) == DBTYPE_STR  ||
			(psBinding->wType & ~DBTYPE_BYREF) == DBTYPE_WSTR ||
			(psBinding->wType & ~DBTYPE_BYREF) == DBTYPE_UTF8 ) 	&&
		  (pColDef->iType == DBTYPE_STR || pColDef->iType == DBTYPE_WSTR))	||
		 ( ( (psBinding->wType & ~DBTYPE_BYREF) == DBTYPE_VARIANT_BLOB) &&
			 pColDef->iType == DBTYPE_VARIANT) )
	{
		switch (psBinding->wType &~ DBTYPE_BYREF)
		{
			// Fixed data is easy, just copy it.
			case DBTYPE_I2:
			case DBTYPE_I4:
			case DBTYPE_R4:
			case DBTYPE_R8:
			case DBTYPE_CY:
			case DBTYPE_DATE:
			case DBTYPE_BOOL:
			case DBTYPE_UI1:
			case DBTYPE_I1:
			case DBTYPE_UI2:
			case DBTYPE_UI4:
			case DBTYPE_I8:
			case DBTYPE_UI8:
			case DBTYPE_DBDATE:
			case DBTYPE_DBTIME:
			case DBTYPE_DBTIMESTAMP:
			case DBTYPE_OID:
			memcpy(FindColCellOffset(pColDef, psRecord), DataPart(pData, psBinding),
				pColDef->iSize);
			break;

			case DBTYPE_BYTES:
			{
				// Must provide the length for a binary field.
				if ((psBinding->dwPart & DBPART_LENGTH) == 0)
				{
					dbStatus = DBSTATUS_E_BADACCESSOR;
					break;
				}
				iLen = LengthPart(pData, psBinding);

				// Check for truncation of the value based on user schema.
				if (iLen > pColDef->iMaxSize && pColDef->iMaxSize != USHRT_MAX)
				{
					dbStatus = DBSTATUS_E_DATAOVERFLOW;
					break;
				}

				// Add the value to the pool.
				hr = m_pSchema->GetBlobPool()->AddBlob(
							iLen,
							DataPart(pData, psBinding),
							(ULONG *) FindColCellOffset(pColDef, psRecord));
			}
			break;

			
			// Handle ANSI string as source.  The target column can be either
			// STR or WSTR.
			case DBTYPE_STR:
			{
				int 		iChars; 		// How many characters in string.

				// Get the length of the value based on the binding.
				if ((psBinding->dwPart & DBPART_LENGTH) != 0)
				{
					iLen = LengthPart(pData, psBinding);
					iChars = StrCharLen((LPCSTR) DataPart(pData, psBinding), iLen);
				}
				// If not given, then we treat as null terminated.
				else
				{
					iLen = (ULONG) strlen((LPCSTR) DataPart(pData, psBinding));
					iChars = MultiByteToWideChar(CP_ACP, 0, 
							(const char *) DataPart(pData, psBinding), -1, 
							NULL, 0);
				}

				// Check truncation of data.  iMaxSize is in characters per OLE DB spec.
				if (iChars > pColDef->iMaxSize && pColDef->iMaxSize != USHRT_MAX)
				{
					dbStatus = DBSTATUS_E_DATAOVERFLOW;
					break;
				}

				// Add with check for high-bit characters and conversion to UTF8 if necessary.
				hr = m_pSchema->GetStringPool()->AddStringA(
							(LPCSTR) DataPart(pData, psBinding),
							(ULONG *) FindColCellOffset(pColDef, psRecord),
							static_cast<USHORT>(iLen));
			}
			break;

			// Handle UNICODE string as input.	Target can be either STR or WSTR.
			case DBTYPE_WSTR:
			{
				int 	iChars; 		// How many characters in string.

				// Get the length of the value based on the binding.
				if ((psBinding->dwPart & DBPART_LENGTH) != 0)
				{
					iLen = LengthPart(pData, psBinding);
					iChars = iLen / sizeof(WCHAR);
				}
				// If not given, then we treat as null terminated.
				else
				{
					iChars = lstrlenW((LPCWSTR) DataPart(pData, psBinding));
					iLen = iChars * sizeof(WCHAR);
				}

				// Check for truncation.
				if (iChars > pColDef->iMaxSize && pColDef->iMaxSize != USHRT_MAX)
				{
					dbStatus = DBSTATUS_E_DATAOVERFLOW;
					break;
				}

				// Add with conversion from Unicode to UTF8.
				hr = m_pSchema->GetStringPool()->AddStringW(
							(LPCWSTR) DataPart(pData, psBinding),
							(ULONG *) FindColCellOffset(pColDef, psRecord),
							iChars);
			}
			break;

			case DBTYPE_VARIANT:
			return (m_pSchema->GetVariantPool()->AddVariant(
						(VARIANT *) DataPart(pData, psBinding),
						(ULONG *) FindColCellOffset(pColDef, psRecord)));

			case DBTYPE_VARIANT_BLOB:
			{
				int 	iBytes; 		// How many bytes in blob?

				// Get the length of the value based on the binding.
				if ((psBinding->dwPart & DBPART_LENGTH) != 0)
					iBytes = LengthPart(pData, psBinding);
				else
					iBytes = (int) psBinding->cbMaxLen;
				return (m_pSchema->GetVariantPool()->AddVariant(
							iBytes,
							(void *) DataPart(pData, psBinding),
							(ULONG *) FindColCellOffset(pColDef, psRecord)));
			}

			case DBTYPE_GUID:
			return (m_pSchema->GetGuidPool()->AddGuid(
						*(GUID *) DataPart(pData, psBinding),
						(ULONG *) FindColCellOffset(pColDef, psRecord)));

			default:
			_ASSERTE(!"Unknown data type!");
			return (BadError(PostError(E_FAIL)));
		}

		// Set the status value if requested.
		if ((psBinding->dwPart & DBPART_STATUS) != 0)
			*StatusPartPtr(pData, psBinding) = dbStatus;
	}
	// We need a conversion for this to work, so let OLE/DB do the work.
	else
	{
		//@todo:
		_ASSERTE(!"Data type conversion not supported.");
	}

	// Map any status changes to an error for caller.
	if (dbStatus != DBSTATUS_S_OK)
		return (PostError(DB_E_ERRORSOCCURRED));
	return (S_OK);
}

#if _MSC_VER < 1200
#ifndef _WIN64
typedef ULONG   DBBYTEOFFSET;
#endif
#endif


//*****************************************************************************
// Returns a pointer to the data for all types, including strings and blobs.
// Since string data is always stored as ANSI, both DBTYPE_STR and DBTYPE_WSTR
// will come back in that format.  The caller must convert to WCHAR if desired.
//*****************************************************************************
BYTE *StgRecordManager::GetColCellData( // Pointer to data.
	STGCOLUMNDEF *pColDef,				// Column to find in record.
	STGRECORDHDR *psRecord, 			// Record to use.
	ULONG		*pcbSrcLength)			// Return length of item.
{
	ULONG		iOffset;				// Offset for var data.
	BYTE		*pCellData;

	// Sanity check input.
	_ASSERTE(pColDef && psRecord && pcbSrcLength);
	_ASSERTE(IsValidRecordPtr(psRecord));

	// Cannot hand out a reference to a variant, because it is decomposed in
	// storage.
	_ASSERTE(pColDef->iType != DBTYPE_VARIANT);

	// There is no persistent state for a record id column.
	_ASSERTE(pColDef->IsRecordID() == false);

	// Setup the length value for input.
	if (IsNonPooledType(pColDef->iType))
	{
		*pcbSrcLength = pColDef->iSize;
		pCellData = FindColCellOffset(pColDef, psRecord);
	}
	else
	{
		// Find the offset which can be either a short or long.
		iOffset = GetOffsetForColumn(pColDef, psRecord);
		if (pColDef->iSize == sizeof(USHORT) && iOffset == 0xffff)
			iOffset = 0xffffffff;

		// Sanity check for null.
		if (iOffset == 0xffffffff)
			return (0);

		// Now just go get the data.
		if (pColDef->iType == DBTYPE_BYTES)
		{
			VERIFY(pCellData = (BYTE *) m_pSchema->GetBlobPool()->GetBlob(
					iOffset, pcbSrcLength));
		}
		else 
		if (pColDef->iType == DBTYPE_GUID)
		{
			VERIFY(pCellData = (BYTE*)m_pSchema->GetGuidPool()->GetGuid(iOffset));
			*pcbSrcLength = sizeof(GUID);
		}
		else
		{
			VERIFY(pCellData = (BYTE *) m_pSchema->GetStringPool()->GetString(
					iOffset));
			*pcbSrcLength = (ULONG) wcslen((LPCWSTR) pCellData)*sizeof(WCHAR);
		}
	}
	return (pCellData);
}



//*****************************************************************************
// This step will create the otpimized record format.  This requires tuning
// indexes to see which will get persisted.
//*****************************************************************************
HRESULT StgRecordManager::SaveOptimize( // Return code.
	SAVERECORDS *pSaveRecords)			// Optimize this data.
{
	STGINDEXDEF *pIndexDef; 			// Working pointer for indexes.
	STGCOLUMNDEF *pColDef;				// Working pointer for columns.
	ULONG		iRecords = 0;			// How many records will we save.
	IStgIndex	**ppIndex;				// For adding to array.
	int 		i;						// Loop control.
	BYTE		fFlags; 				// record flag.
	ULONG		iRecCount;
	HRESULT 	hr;

	//
	// Tune the indexes.
	//

	// Count only undeleted records.
	iRecords = Records();

	// Make sure that we're going to ask for more than 0 bytes before we
	// allocate and attempt to manipulate malloc'd memory.
	if (pSaveRecords->pNewTable->iIndexes > 0)
	{
		// Allocate an array of cached index pointers.
		pSaveRecords->rgIndexDefs = (STGINDEXDEF **) malloc(sizeof(STGINDEXDEF *) * pSaveRecords->pNewTable->iIndexes);
		if (!pSaveRecords->rgIndexDefs)
			return (PostError(OutOfMemory()));

		// Cache an array of index defs to avoid so many lookups.
		for (i=0;  i<pSaveRecords->pNewTable->iIndexes;  i++)
			pSaveRecords->rgIndexDefs[i] = pSaveRecords->pNewTable->GetIndexDesc(i);

		// For each index, set the bucket size.
		for (i=0, pSaveRecords->iPersistIndexes=0;	
				i<pSaveRecords->pNewTable->iIndexes;  i++)
		{
			// Get the definition for the current index.
			VERIFY(pIndexDef = pSaveRecords->rgIndexDefs[i]);
			
			// Assume we won't use this index.
			pIndexDef->fFlags |= DEXF_INCOMPLETE;

			// If it was dynamic and not meant for persistence, don't bother.
			if (pIndexDef->fFlags & DEXF_DYNAMIC)
				continue;

			// If there are not enough records to save this index, don't bother.
			if (pIndexDef->iRowThreshold != 0xff &&
					iRecords < pIndexDef->iRowThreshold)
				continue;

			// If a ratio is given, then use it.
			if ((pIndexDef->fIndexType != IT_SORTED) && pIndexDef->HASHDATA.iMaxCollisions != 0xff)
			{
				USHORT iBuckets = (USHORT)(iRecords / ((pIndexDef->HASHDATA.iMaxCollisions != 0) ? pIndexDef->HASHDATA.iMaxCollisions : 1));

				// Use ratio to reduce index size.
				pIndexDef->HASHDATA.iBuckets = (BYTE) GetPrimeNumber(iBuckets > 0xff ? 0xff : iBuckets );

			}
			
			// One more index to save.
			++pSaveRecords->iPersistIndexes;
			pIndexDef->fFlags &= ~DEXF_INCOMPLETE;
		}
	}
	else // instead of malloc'ing 0 bytes, just init pointer to 0.
		pSaveRecords->rgIndexDefs = 0;

	//
	// Optimize the record format.
	//

	// Clean out the struct to avoid confusion.
	pSaveRecords->rgRows = 0;
	pSaveRecords->pNewData = 0;

	iRecCount = m_RecordHeap.Count();

	// Allocate memory for an array of row pointers that we can sort by
	// primary key.
	if ((pSaveRecords->rgRows = (STGRECORDHDR **)malloc(sizeof(STGRECORDHDR) * iRecCount)) == 0)
		return (PostError(OutOfMemory()));
	// Copy the list of records into an array we can use.
	
	// Make sure there are discardable records before allocating.
	if (m_rgRecordFlags.HasFlags() && !pSaveRecords->rgRid)
	{
		// first allocate the chunk of memory.
		pSaveRecords->rgRid = (long *) malloc(sizeof(long)*iRecCount);
		if (!pSaveRecords->rgRid)
			return (PostError(OutOfMemory()));

		// that way untouched records will be treated as having value -1.
		memset(pSaveRecords->rgRid, 0xff, sizeof(long)*iRecCount);
	}

	// Walk all heaps collecting all non-deleted and non-temporary records that
	// need to be saved.  Update the RID mapping table as well, if there is one.
	// This mapping table is used by sorted index to rebuild quicker.
	//
	// NOTE:  the primary key sorting code relies on the fact that this loop
	//	collects records *in order*.  If this ever changes for non-dirty tables,
	//	the records could get sorted incorrectly causing lookup failures.
	RECORDHEAP	*pRecordHeap;
	ULONG		RecordIndex, LocalRecordIndex;
	RecordIndex = 0;
	pSaveRecords->iRecords = 0;

	for (pRecordHeap=&m_RecordHeap;  pRecordHeap;  pRecordHeap=pRecordHeap->pNextHeap)
	{
		for (LocalRecordIndex=0;  LocalRecordIndex<pRecordHeap->VMArray.Count();  
				LocalRecordIndex++, RecordIndex++)
		{
			// If the row is not deleted, save it.
			fFlags = m_rgRecordFlags.GetFlags(RecordIndex);
			if ((fFlags & (RECORDF_DEL | RECORDF_TEMP)) == 0)
			{
				pSaveRecords->rgRows[pSaveRecords->iRecords] = (STGRECORDHDR *) pRecordHeap->VMArray.Get(LocalRecordIndex);

				// update the mapping table if it has been allocated.
				if (pSaveRecords->rgRid)
				{
					pSaveRecords->rgRid[RecordIndex] = (long) pSaveRecords->iRecords;
				}
				++pSaveRecords->iRecords;
			}
		} // Loop through records in current heap.
	} // Loop through all record heaps.

	// Sort by the primary key.
	if (IsDirty())
		SortByPrimaryKey(m_pTableDef, pSaveRecords->rgRows, pSaveRecords->iRecords);

	// Walk each index and create one for it.
	for (i=0;  i<pSaveRecords->pNewTable->iIndexes;  i++)
	{
		// Get the index description.
		VERIFY((pIndexDef = pSaveRecords->pNewTable->GetIndexDesc(i)) != 0);

		// Don't use indexes we don't want.
		if (pIndexDef->fFlags & DEXF_INCOMPLETE)
			continue;

		// Find room for the new index pointer.
		if ((ppIndex = pSaveRecords->rgIndexes.Append()) == 0)
			return (PostError(OutOfMemory()));

		// Create a new index object and open it.
		if (IT_SORTED == pIndexDef->fIndexType)
		{
			// in case of Sorted Index, there is no need to re-create the index since the index will not
			// change.

			// @todo: make sure 'i' is properly updated in case we want to add deferred index creation.
			// DEXF_DEFERCREATE
			*ppIndex = m_rpIndexes[i];
			(*ppIndex)->AddRef();
		}
		else 
		{
			*ppIndex = new StgHashedIndex;
			if (0 == *ppIndex)
				return (PostError(OutOfMemory()));

			(*ppIndex)->AddRef();

			// Open the new index.
			if (FAILED(hr = (*ppIndex)->Open(((UINT_PTR) pIndexDef - (UINT_PTR) m_pTableDef), 
					this, &pSaveRecords->RecordHeap, 
					pSaveRecords->iRecords, 0, 0)))
				return (hr);
		}
	}

	// Now for the interesting part...	This section of code will optimize the
	// format which includes the following steps:
	//	1. Change offset sizes for data types that use pools, either a 2 or
	//		4 byte offset will be used based on total data present.
	//	2. Decide if indexes are persisted, and save room in the record for
	//		each one.  2 or 4 byte size based on count of records.
	//	3. Align all of the data by data type size yeilding a 4 byte alignment.
	//		Pad as required to make it 4 byte aligned.
	//	4. Find room for the null bitmask if it is required.  Try first to use
	//		padded room from 4 byte alignment, then add space as required.
	//@todo: this code is drawn out right now.	We can combine some of the loops
	//	together and quit refetching definitions so much.
	
	//
	// Step 1: Change size of pooled entries.
	//
	USHORT		iBlobPool, iStringPool, iOidSize, iVariantPool, iGuidPool;

	iOidSize = GetOidSizeBasedOnValue(m_pDB->GetNextOidValue());

	iBlobPool = m_pSchema->GetBlobPool()->OffsetSize();
	iStringPool = m_pSchema->GetStringPool()->OffsetSize();
	iVariantPool = m_pSchema->GetVariantPool()->OffsetSize();
	iGuidPool = m_pSchema->GetGuidPool()->OffsetSize();

	for (i=0;  i<pSaveRecords->pNewTable->iColumns;  i++)
	{
		VERIFY(pColDef = pSaveRecords->pNewTable->GetColDesc(i));

		switch (pColDef->iType)
		{
			case DBTYPE_VARIANT:
			pColDef->iSize = iVariantPool;
			break;

			case DBTYPE_BYTES:
			pColDef->iSize = iBlobPool;
			break;

			case DBTYPE_STR:
			case DBTYPE_WSTR:
			pColDef->iSize = iStringPool;
			break;

			case DBTYPE_OID:
			pColDef->iSize = iOidSize;
			break;

			case DBTYPE_GUID:
			pColDef->iSize = iGuidPool;
			break;
		}
	}


	//
	// Step 2/3: Align everything on 4 byte boundary, include room for indexes.
	//
	USHORT		iOffset;				// Moving offset for columns.
	USHORT		iSize;					// Working value for alignment.
	USHORT		iIndexSize; 			// Size of an index entry.
	ALIGNCOLS	*rgAlignData;			// Used for alignment.
	int 		iColumns;				// How many columns in table.

	// How big will indexes be, based on records.
	if (pSaveRecords->iRecords < (USHORT) -1)
		iIndexSize = sizeof(USHORT);
	else
		iIndexSize = sizeof(ULONG);

	// Allocate alignment structs and init them.
	VERIFY(rgAlignData = (ALIGNCOLS *) _alloca(sizeof(ALIGNCOLS) * (pSaveRecords->pNewTable->iColumns + pSaveRecords->iPersistIndexes)));

	CAlignColumns::AddColumns(rgAlignData, pSaveRecords->pNewTable, &iColumns); 

	// Add all indexes we want to persist.
	if (pSaveRecords->iPersistIndexes)
		CAlignColumns::AddIndexes(&rgAlignData[iColumns], pSaveRecords->pNewTable, iIndexSize);

	// Sort the data by the data type and the size required.
	CAlignColumns	sAlign(rgAlignData, iColumns + pSaveRecords->iPersistIndexes);
	sAlign.Sort();

	// Walk the sorted list applying padding as required.
	pSaveRecords->pNewTable->iNullOffset = 0xffff;
	iOffset = 0;
	for (i=0;  i<iColumns + pSaveRecords->iPersistIndexes;	i++)
	{
		// For all data types 8 bytes and under, expect natural alignment
		// based on size of the data type itself.
		if (rgAlignData[i].iSize <= sizeof(__int64))
			iSize = rgAlignData[i].iSize;
		// Otherwise everything is 4 byte padded.
		else
			iSize = sizeof(ULONG);

		// If the access would be unaligned, then pad.
		if (iOffset % iSize != 0)
		{
			_ASSERTE(iSize > 1);

			// Figure out a new offset that would be properly aligned.
			USHORT iNewOffset = (iOffset + iSize - 1) & ~(iSize - 1);

			// Give some feedback during debug, this is bad in any internal
			// table if you can help it.
			DEBUG_STMT(DbgWriteEx(L"WARNING: Record alignment on '" SCHEMA_NAME_TYPE L"', wasted %d bytes.\n",
					TableName(), iNewOffset - iOffset));

			// If we need to have a null bitmask and the space we wasted
			// has enough room, then use it.
			if (pSaveRecords->pNewTable->iNullBitmaskCols && pSaveRecords->pNewTable->iNullOffset == 0xffff &&
				iNewOffset - iOffset > pSaveRecords->pNewTable->iNullBitmaskCols)
				pSaveRecords->pNewTable->iNullOffset = iOffset;

			// Save the new offset for the piece of data.
			iOffset = iNewOffset;
		}

		// Reset the data for this item.
		if (rgAlignData[i].iType != ITEMTYPE_INDEX)
			rgAlignData[i].uData.pColDef->iOffset = iOffset;
		else	
			rgAlignData[i].uData.pIndexDef->HASHDATA.iNextOffset = iOffset;

		// Move the offset to the next chunk of data.
		// sorted indexes do not need space in the record.
		if ((rgAlignData[i].iType != ITEMTYPE_INDEX) || (rgAlignData[i].uData.pIndexDef->fIndexType != IT_SORTED))
			iOffset += rgAlignData[i].iSize;
	}

	
	//
	// Step 4: If we still need a null bitmask, then make room for it.
	//
	if (pSaveRecords->pNewTable->iNullBitmaskCols && pSaveRecords->pNewTable->iNullOffset == 0xffff)
	{
		pSaveRecords->pNewTable->iNullOffset = iOffset;
		iOffset += BytesForColumns(pSaveRecords->pNewTable->iNullBitmaskCols);
	}

	// Save the record size which must be 4 byte aligned, with the exception of
	// the case where two records back to back are properly aligned.
	bool		bAligned = false;
	if (iOffset % 4 != 0)
	{
		// Search for the column at offset zero, and if it's size is alignment
		// compatible with the record size, then don't bother with 4 byte pad.
		for (i=0;  i<iColumns + pSaveRecords->iPersistIndexes;	i++)
		{
			if (rgAlignData[i].iType != ITEMTYPE_INDEX &&
				rgAlignData[i].uData.pColDef->iOffset == 0)
			{
				if (iOffset % rgAlignData[i].iSize == 0)
					bAligned = true;
				break;
			}
		}
		
		if (bAligned == false)
		{
#ifdef _DEBUG
			if (ALIGN4BYTE(iOffset) - iOffset)
				DbgWriteEx(L"WARNING: '" SCHEMA_NAME_TYPE L"' padded %d byte(s) for 4 byte alignment.\n",
					TableName(), ALIGN4BYTE(iOffset) - iOffset);
#endif
			pSaveRecords->pNewTable->iRecordSize = ALIGN4BYTE(iOffset);
		}
		else
			pSaveRecords->pNewTable->iRecordSize = iOffset;
	}
	else
		pSaveRecords->pNewTable->iRecordSize = iOffset;
	return (S_OK);	
}


//*****************************************************************************
// Clean up the optimized data we might have allocated.
//*****************************************************************************
void StgRecordManager::ClearOptimizedData()
{
	// If the user calls GetSaveSize successfully, but never calls SaveToStream
	// which clears the cached data, catch any memory leaks.
	if (m_pSaveRecords)
	{
		// Free the new table array if allocated.
		if (m_pSaveRecords->bFreeTable && m_pSaveRecords->pNewTable)
			free(m_pSaveRecords->pNewTable);

		// Free the short cut array.
		if (m_pSaveRecords->rgIndexDefs)
			free(m_pSaveRecords->rgIndexDefs);

		// Free all row data.
		if (m_pSaveRecords->rgRows)
			free(m_pSaveRecords->rgRows);
		if (m_pSaveRecords->rgRid)
			free(m_pSaveRecords->rgRid);
		if (m_pSaveRecords->pNewData)
			free(m_pSaveRecords->pNewData);

		// Delete each index in the array.
		for (int i=0;  i<m_pSaveRecords->rgIndexes.Count();  i++)
			if (m_pSaveRecords->rgIndexes[i])
			{
				m_pSaveRecords->rgIndexes[i]->Close();
				m_pSaveRecords->rgIndexes[i]->Release();
			}

		// Finally, if we allocated this memory, free it.
		if (m_pSaveRecords->bFreeStruct)
			delete m_pSaveRecords;
		m_pSaveRecords = 0;
	}
}


//
//
// Internal helpers.
//
//




//*****************************************************************************
// Count the number of characters in a string up to iLen.  If iLen would truncate
// a DBCS character, then that lead byte is not counted.  If you have a null
// terminated string, you should be using _mbslen.
//*****************************************************************************
int StrCharLen( 						// Count of characters (not bytes).
	LPCSTR		szStr,					// String to count.
	int 		iLen)					// Bytes to count.
{
	int 		iCount;

	for (iCount=0;	iLen>0;  iCount++)
	{
		if (!IsDBCSLeadByte(*szStr))
		{
			--iLen;
			++szStr;
		}
		else
		{
			// Check for truncation of lead byte and don't count it.
			if ((iLen -= 2) < 0)
				break;
			szStr += 2;
		}
	}
	return (iCount);
}


//*****************************************************************************
// Given a mixed string, return the count of bytes that make up n characters.
// For example, if you had a mixed string with 3 characters, two DBCS chars
// and 1 SBCS char, the return would be 5.
//*****************************************************************************
int StrBytesForCharLen( 				// Count of bytes that make up n chars.
	LPCSTR		szStr,					// String to measure.
	int 		iChars) 				// How many characters to count.
{
	int 		iCount;

	for (iCount=0;	iChars>0 && *szStr;  iChars--)
	{
		if (!IsDBCSLeadByte(*szStr))
		{
			iCount += 1;
			szStr++;
		}
		else
		{
			iCount += 2;
			szStr += 2;
		}
	}
	return (iCount);
}

//*****************************************************************************
// Given a UTF8 string, return the number of bytes that make up iChars 
//	characters.
// This is derived from the Utf8ToWideChar conversion function.
//*****************************************************************************
int Utf8BytesForCharLen(				// Count of bytes that make up n chars.
	LPCSTR		pUTF8,					// String to measure.
	int 		iChars) 				// How many characters to count.
{
	int 		iCount=0;				// # of UTF8 bytes consumed.
	int 		nTB = 0;				// # trail bytes to follow
	int 		cchWC = 0;				// # of Unicode code points generated


	while (*pUTF8 && iChars>0)
	{
		//	See if there are any trail bytes.
		if ((*pUTF8 & 0x80) == 0)
		{	//	Found ASCII.
			--iChars;
		}
		else if ((*pUTF8 & 0x40) == 0)
		{	//	Found a trail byte.
			//	Note : Ignore the trail byte if there was no lead byte.
			if (nTB != 0)
			{
				//	Decrement the trail byte counter.
				--nTB;

				//	If end of sequence, advance the output counter.
				if (nTB == 0)
					--iChars;
			}
		}
		else
		{	//	Found a lead byte.
			if (nTB > 0)
			{	//	Error - previous sequence not finished.
				nTB = 0;
				--iChars;
			}
			else
			{	//	Calculate the number of bytes to follow.
				//	Look for the first 0 from left to right.
				char UTF8 = *pUTF8;
				while ((UTF8 & 0x80) != 0)
				{
					UTF8 <<= 1;
					nTB++;
				}
				// This byte is one of the bytes indicated.
				nTB--;
			}
		}

		++iCount;
		++pUTF8;
	}

	return (iCount);
}


//*****************************************************************************
// Sort the given set of records by their primary key, if there is one.  If
// no primary key is given, then nothing is changed.  Note that this includes
// the case where there is a compound primary key.
//*****************************************************************************
void StgRecordManager::SortByPrimaryKey(
	STGTABLEDEF *pTableDef, 			// Definition of table to use.
	STGRECORDHDR *rgRows[], 			// Array of records to sort.
	long		iCount) 				// How many are there.
{
	STGCOLUMNDEF *pColDef;				// Column definitions.
	int 		i;						// Loop control.

	// Look for the primary key column for this table.
	for (i=0;  i<pTableDef->iColumns;  i++)
	{
		VERIFY(pColDef = pTableDef->GetColDesc(i));
		if (pColDef->IsPrimaryKey())
			goto fullsort;
	}
	return;

fullsort:
	{
		CMySortPKRecords sort(pColDef, this, rgRows, iCount);
		sort.Sort();
	}
}






//*****************************************************************************
// Helper function to handle OLE/DB truncation issues on fetch.
//*****************************************************************************
int CheckTruncation(					// true if truncated.
	BYTE		*pData, 				// The user's data.
	DBBINDING	*pBinding,				// The binding for the user's data.
	ULONG		cbDataLen)				// Length of the user's data.
{
	// If there is truncation, need to change some stuff.
	if (pBinding->cbMaxLen < cbDataLen)
	{
		// Reset the caller's max length
		if ((pBinding->dwPart & DBPART_LENGTH) != 0)
			*LengthPartPtr(pData, pBinding) = cbDataLen;
		return (true);
	}
	
	// For normal full copy, nothing to do.
	if ((pBinding->dwPart & DBPART_LENGTH) != 0)
	{
		if (pBinding->wType == DBTYPE_WSTR)
			*LengthPartPtr(pData, pBinding) = cbDataLen - sizeof(WCHAR);
		else if (pBinding->wType == DBTYPE_STR)
			*LengthPartPtr(pData, pBinding) = cbDataLen - sizeof(char);
		else
			*LengthPartPtr(pData, pBinding) = cbDataLen;
	}
	return (false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgrecordmanageri.h ===
//*****************************************************************************
// StgRecordManageri.h
//
// This module contains some internal helpers for the record manager.  They are
// here because they aren't the most important part of the code, and it leads
// to less clutter of the main interface.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgRecordManageri_h__
#define __StgRecordManageri_h__

#include "Errors.h"						// Error handling.
#include "UtilCode.h"					// Hashing base classes.
#include "StgPool.h"					// For name access in hash classes.



//*****************************************************************************
// This section of code handles alignment of columns in a table according to
// their size and attributes.  Columns are divided into two sections; first the
// fixed size data types and then the variable sized types.  Variable types
// include all data types that are stored in heaps (since offsets can be 2 or
// 4 bytes large) and OID's which can scale down to 2 bytes.
//
// Within a section, columns are sorted by their intrinsic size, which fixed
// types descending and variable sizes ascending.  This puts the smallest data
// types from each section adjacent to each other leading to potentially better
// packing.
//*****************************************************************************

enum
{
	ITEMTYPE_FIXCOL,					// Fixed column.
	ITEMTYPE_HEAPCOL,					// Heap column.
	ITEMTYPE_INDEX						// Index value.
};

struct ALIGNCOLS
{
	short		iType;					
	USHORT		iSize;					// Size of this data item.
	union 
	{
		STGCOLUMNDEF *pColDef;			// The column if bColumn.
		STGINDEXDEF *pIndexDef;			// The index if !bColumn.
	} uData;
};

#define CMPVALS(v1, v2) ((v1) < (v2) ? (-1) : (v1) > (v2) ? (1) : 0)

class CAlignColumns : public CQuickSort<ALIGNCOLS>
{
public:
	CAlignColumns(ALIGNCOLS *pBase, int iCount) :
		CQuickSort<ALIGNCOLS>(pBase, iCount)
	{ }

	virtual int Compare(					// -1, 0, or 1
		ALIGNCOLS	*psFirst,				// First item to compare.
		ALIGNCOLS	*psSecond);				// Second item to compare.

	static void AddColumns(
		ALIGNCOLS	*rgAlignData,			// The array to fill out.
		STGTABLEDEF *pTableDef,				// The table definition to work on.
		int			*piColumns);			// Count columns we store.

	static void AddIndexes(
		ALIGNCOLS	*rgAlignData,			// The array to fill out.
		STGTABLEDEF *pTableDef,				// The table definition to work on.
		int			iIndexSize);			// How big is an index item.
};


//*****************************************************************************
// The rowset is essentially just an array of these.
//*****************************************************************************
struct RECORD
{
	RECORDID	RecordID;				// The ID of the record for the row.
	ULONG		iRefCnt;				// Ref count for the row.
	bool		bReference;				// true if this record holds a record reference.
};


//*****************************************************************************
// This class manages records that make up a rowset.
//@todo: this version won't scale to large data sets well.
//*****************************************************************************
class CRecordList : public CDynArray<RECORD>
{
public:
//*****************************************************************************
// Add a new record to the list of records.
//*****************************************************************************
	inline HRESULT AddRecordToRowset(		// Return code.
		RECORDID	*pRecordID,				// Record to add.
		RECORD		*&pRecord)				// Return the row handle.
	{
		// Add a new slot at the end and add the record.
		if ((pRecord = Append()) == 0)
			return (PostError(OutOfMemory()));
		pRecord->RecordID = *pRecordID;
		pRecord->iRefCnt = 0;
		pRecord->bReference = false;
		return (S_OK);
	}
	
};


//*****************************************************************************
// This class has two ways to store records, either through a CRecordList or
// a fixed size array of records.  The former gives you greater flexibility in
// that you can fetch an arbitrarily huge number of records.  The latter doesn't
// allow for references or ref counting, but doesn't require any extra memory
// allocation.
//*****************************************************************************
class CFetchRecords
{
	// Must supply memory to start.
	CFetchRecords() { };

public:
	CFetchRecords(
		CRecordList *pRecordList) :			// A record list.
		m_pRecordList(pRecordList) 
	{ }

	CFetchRecords(
		STGRECORDHDR **rgRecords,			// Return array of records here.
		ULONG		iMaxRecords) :			// Max that will fit in rgRecords.
		m_pRecordList(0),
		m_rgRecords(rgRecords),
		m_iMaxRecords(iMaxRecords),
		m_iFetched(0)
	{ }

	CFetchRecords(
		CRecordList *pRecordList,			// A record list.
		STGRECORDHDR **rgRecords,			// Return array of records here.
		ULONG		iMaxRecords) :			// Max that will fit in rgRecords.
		m_pRecordList(pRecordList),
		m_rgRecords(rgRecords),
		m_iMaxRecords(iMaxRecords),
		m_iFetched(0)
	{ }

//*****************************************************************************
// Add a record to the rowset based on the type of cursor storage.
//*****************************************************************************
	HRESULT AddRecordToRowset(				// Return code.
		STGRECORDHDR *psRecord,				// The actual record pointer.
		RECORDID	*pRecordID,				// Record to add.
		RECORD		*&pRecord);				// Return the row handle.

//*****************************************************************************
// Search for the given record in the existing rowset.  Return the index of
// the item if found.
//*****************************************************************************
	ULONG FindRecord(						// Index if found, -1 if not.
		STGRECORDHDR *psRecord,				// Return to search for.
		RECORDID	RecordID);				// ID of the record.

	inline ULONG Count()
	{
		if (m_pRecordList)
			return (m_pRecordList->Count());
		return (m_iFetched);
	}

private:
	CRecordList	*m_pRecordList;			// For dynamically large records.
	STGRECORDHDR **m_rgRecords;			// Return array of records here.
	ULONG		m_iMaxRecords;			// Max that will fit in rgRecords.
	ULONG		m_iFetched;				// How many do we have so far.
};



//*****************************************************************************
// When indexes are updated, one can collect the precise list of those indexes
// to use later.  For example, one might want the list of indexes which were
// modified during an update of a record, so that if the update fails, those
// same indexes may be re-indexed later.  Note that the pointers to the index
// objects are cached, but no ref counting is done.  If this is a requirement,
// the caller must do this.   This is a performance optimization because it
// is expected that the list is maintained within an outer scope.
//*****************************************************************************
#define SMALLDEXLISTSIZE	8
class IStgIndex;
class CIndexList
{
public:
	CIndexList();
	~CIndexList();

	void Init();

	HRESULT Add(							// Return code.
		IStgIndex	*pIIndex);				// Index object to place in array.

	void Clear();

	int Count()
	{
		return (m_rgList.Count());
	}

	IStgIndex *Get(int i)
	{
		_ASSERTE(i < Count());
		return (m_rgList[i]);
	}

private:
	IStgIndex	*m_rgIndexList[SMALLDEXLISTSIZE]; // Common enough list for most cases.
	CDynArray<IStgIndex *> m_rgList;	// List of pointers to indexes.
};


#endif // __StgRecordManageri_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgschema.h ===
//*****************************************************************************
// StgSchema.h
//
// This module contains the hard coded schema for the core information model.
// By having one const version, we avoid saving the schema definitions again
// in each .clb file.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once

#include "StgDef.h"						// Base storage definitions.
#include "StgPool.h"					// Heap definitions.
#include "StgRecordManager.h"


//*****************************************************************************
// Helper functions for dealing with formatted TABLEID's.
//*****************************************************************************

enum
{
	SCHEMADEFSF_FREEDATA	= 0x00000001,	// Free allocated data.
	SCHEMADEFSF_DIRTY		= 0x00000002	// Free allocated data.
};


#define SCHEMADEFS_COOKIE	0x686F6F50

//*****************************************************************************
// A schema is a combination of meta data about how tables and indexes are
// layed out, along with the heaps which store this data.  This struct contains
// a pointer to the heaps to use.  A separate string heap is used for the
// textual portion of the meta data (table, column, and index names) so that
// it need not be included in the user data heap.  For example, the hard coded
// COM+ schema will use a heap living in .rdata for this purpose.
//*****************************************************************************
struct SCHEMADEFS
{
	// Note: the following is a humungous hack I'm adding to "solve" a stress
	// failure we've seen only 4 times in the last 9 months.  Each time the
	// crash occurs, we wind up with a SCHEMADEFS which has been prematurely
	// freed and then either decommited or re-used by another tool.  This causes
	// the StgDatabase::Close code to fail horribly.  We've not been able to find
	// a reliable repro, other than it always appears in the same part of the
	// cleanup code.  I've grepped the entire source for all deletes of the
	// struct type and haven't found the culprit.  This change at least makes
	// us tolerant to the failure.  Basically we'll track a magic cookie in
	// the structure and make sure it is valid when we free.
	DWORD		Cookie;					// Sanity check validity.

	GUID		sid;					// The Schema ID.
	ULONG		Version;				// What version of the schema.
	STGSCHEMA	*pSchema;				// Meta data for table layouts.
	USHORT		fFlags;					// Flags about this schema.
	USHORT		pad;
	StgStringPool *pNameHeap;			// Strings for the schema defs.

	// Heaps and persistent data structures.
	StgStringPool *pStringPool;			// Pool of strings for this database.
	StgBlobPool	*pBlobPool;				// Pool of blobs for this database.
	StgVariantPool *pVariantPool;		// A collection of variants.
	StgGuidPool    *pGuidPool;			// A collection of Guids.


	SCHEMADEFS() :
		Cookie(SCHEMADEFS_COOKIE)
	{ 
		Clear();
	}
	~SCHEMADEFS();
	
	void Clear()
	{
		memset(&sid, 0, sizeof(SCHEMADEFS) - sizeof(DWORD));
	}

	static void SafeFreeSchema(SCHEMADEFS *pSchemaDefs);
	
	static bool IsValidPtr(SCHEMADEFS *pSchemaDefs);

	bool IsValid()
	{
		return (IsValidPtr(this));
	}

	// Helpers.	
	StgStringPool *GetStringPool()
	{ 
		_ASSERTE(IsValid());
		_ASSERTE(pStringPool);
		return (pStringPool); 
	}

	StgBlobPool	*GetBlobPool()
	{ 
		_ASSERTE(IsValid());
		_ASSERTE(pBlobPool);
		return (pBlobPool); 
	}

	StgVariantPool *GetVariantPool()
	{ 
		_ASSERTE(IsValid());
		_ASSERTE(pVariantPool);
		return (pVariantPool); 
	}

	StgGuidPool *GetGuidPool()
	{ 
		_ASSERTE(IsValid());
		_ASSERTE(pGuidPool);
		return (pGuidPool); 
	}

	void SetSchemaDirty(int bDirty)
	{
		_ASSERTE(IsValid());
		if (bDirty)
			fFlags |= SCHEMADEFSF_DIRTY;
		else
			fFlags &= ~SCHEMADEFSF_DIRTY;
	}

	void SetDirty(int bDirty)
	{
		_ASSERTE(IsValid());
		pNameHeap->SetDirty(bDirty);
		pStringPool->SetDirty(bDirty);
		pBlobPool->SetDirty(bDirty);
		pVariantPool->SetDirty(bDirty);
		pGuidPool->SetDirty(bDirty);
		SetSchemaDirty(bDirty);
	}

	int IsDirty()
	{
		_ASSERTE(IsValid());
		if (pNameHeap->IsDirty() || pStringPool->IsDirty() || 
				pBlobPool->IsDirty() || pVariantPool->IsDirty() ||
				pGuidPool->IsDirty())
			return (true);

		if (fFlags & SCHEMADEFSF_DIRTY)
			return (true);
		return (false);
	}
};


// This version forces allocation of a heap to take place and redirects
// the pointers from SCHEMADEFS to these heaps.  This is convienent for those
// schemas that will have their own data (temp and user).
class SCHEMADEFSDATA : public SCHEMADEFS
{
public:
	SCHEMADEFSDATA()
	{ 
		sid = GUID_NULL;
		Version = 0;
		pSchema = 0;
		fFlags = 0;
		pNameHeap = &StringPool;
		pStringPool = &StringPool;
		pBlobPool = &BlobPool;
		pVariantPool = &VariantPool;
		pGuidPool = &GuidPool;
	}

	StgStringPool StringPool;			// Pool of strings for this database.
	StgBlobPool	BlobPool;				// Pool of blobs for this database.
	StgVariantPool VariantPool;			// A collection of variants.
	StgGuidPool	   GuidPool;			// A collection of guids.
};

enum SCHEMAS
{
	SCHEMA_USER,						// User defined and COM+ overrides.
	SCHEMA_CORE,						// COM+ core schema definitions.
	SCHEMA_TEMP,						// Temporary table space.
	SCHEMA_EXTERNALSTART,				// Start of external references.
	SCHEMA_ALL = 0xffffffff				// Look in all schemas.
};

#define MAXSCHEMAS 6


//*****************************************************************************
// This class manages a list of schemas.  This version is very skinny and could
// have been inlined in the database code.  It is put into a class to make it
// easier to expand on later.  Given how small the code is, it won'd cause
// bloat or growth in working set.
//@todo: make this grow to a huge max count.
//*****************************************************************************
class CSchemaList
{
public:
	CSchemaList()
	{ Clear(); }

	void AddSchema(SCHEMADEFS *pSchema, SCHEMAS eType)
	{ 
		_ASSERTE(pSchema->IsValid());
		_ASSERTE((ULONG) eType < MAXSCHEMAS);	
		m_rgpSchemas[eType] = pSchema; 
	}

	HRESULT Append(SCHEMADEFS *pSchema)
	{
		_ASSERTE(pSchema->IsValid());
		if (Count() >= MAXSCHEMAS)
			return (OutOfMemory());
		m_rgpSchemas[m_iCount++] = pSchema;
		return (S_OK);
	}

	SCHEMADEFS *Get(int iDex)
	{ 
		_ASSERTE(m_rgpSchemas[iDex] == 0 || m_rgpSchemas[iDex]->IsValid());
		_ASSERTE(iDex < MAXSCHEMAS);
		return (m_rgpSchemas[iDex]); 
	}

	void Del(int iDex)
	{ 
		_ASSERTE(iDex < Count() && iDex >= SCHEMA_EXTERNALSTART);
		--m_iCount;
		memcpy(&m_rgpSchemas[iDex], &m_rgpSchemas[iDex + 1], 
				(m_iCount - iDex) * sizeof(SCHEMADEFS *));
	}

	void Clear()
	{ 
		m_iCount = SCHEMA_EXTERNALSTART;
		memset(m_rgpSchemas, 0, sizeof(void *) * MAXSCHEMAS); 
	}

	int Count() const
	{ return (m_iCount); }

	int ExternalCount() const
	{ return (m_iCount - SCHEMA_EXTERNALSTART); }

private:
	SCHEMADEFS	*m_rgpSchemas[MAXSCHEMAS];// Active schema list.
	int			m_iCount;				// How many present.
};

// Load core schema modes.
enum LCSMODE
{
	LCS_WRITE,							// Load the writable version.
	LCS_READONLY,						// Load the read only version.
	LCS_DEEPCOPY	= 0x1000			// Make a deep copy of the data.
};

inline int SafeLcsType(int fFlags)
{ return (fFlags & ~LCS_DEEPCOPY); }



//********** Debug support.

#ifdef _DEBUG

typedef int (_cdecl *PFNDUMPFUNC)(LPCWSTR szFmt, ...);
HRESULT DumpSchema(SCHEMADEFS *pSchemaDefs, PFNDUMPFUNC	pfnDump);
HRESULT DumpSchemaTable(SCHEMADEFS *pSchemaDefs, STGTABLEDEF *pTableDef,
	PFNDUMPFUNC	pfnDump);

#else

#define DumpSchema(p1, p2)
#define DumpSchemaTable(p1, p2, p3)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgrecordmanagerwrite.cpp ===
//*****************************************************************************
// StgRecordManagerWrite.cpp
//
// This module contains the code to write data values to a table using the
// StgRecordManager class.  This code can be factored out of the engine
// for read only builds.  The public entry points in this module include:
//		SetData
//
// Any code that deals with writing data values should be in this module.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Standard include.
#include "StgDatabase.h"                // Parent database.
#include "StgRecordManager.h"           // Record manager interface.


//********** Macros and stuff. ************************************************

//********** Local Prototypes. ************************************************
HRESULT _BackupRecordData(STGTABLEDEF *pTableDef, CQuickBytes *pbData, STGRECORDHDR *pRecord);
HRESULT _RestoreRecordData(STGTABLEDEF *pTableDef, void *pbData, STGRECORDHDR *pRecord);


//********** Code. ************************************************************




//*****************************************************************************
// Insert a brand new row with all of the initial data supplied.  This will add
// a new record to the record heap, set all of the data for the record, and 
// then update all of the indexes for the table.  If any failures occur, the
// data is rolled back along with any index updates that have been made.
//
// Note that any data added to heaps is not rolled back at this time because
// there is no way to know if that data is being shared with a different
// record somewhere else in the database.  If the data is not required, it
// will get purged at Save time.
//*****************************************************************************
HRESULT StgRecordManager::InsertRowWithData( // Return code.
    STGRECORDFLAGS fFlags,              // optional flag argument to indicate
                                        // temporary record.
	RECORDID	*psNewID,				// New record ID, 0 valid.
	STGRECORDHDR **ppRecord,			// Return record pointer.
	int 		iCols,					// number of columns
	const DBTYPE rgiType[], 			// data types of the columns.
	const void	*rgpbBuf[], 			// pointers to where the data will be stored.
	const ULONG cbBuf[],				// sizes of the data buffers.
	ULONG		pcbBuf[],				// size of data available to be returned.
	HRESULT 	rgResult[], 			// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
	const ULONG *rgFieldMask)			// IsOrdinalList(iCols) 
										//	? an array of 1 based ordinals
										//	: a bitmask of columns
{
	RECORDID	RecordIndex=0xffffffff; // 0 based index of record.
	ULONG		LocalRecordIndex;		// 0 based index in current heap.
	int			iPKSets = 0;			// Count primary key updates.
	int			bIndexesUpdated = false;// true after indexes are built.
	HRESULT		hr = S_OK;

	// Validate assumptions.
	_ASSERTE(ppRecord);

	// Insert a new record into the table.
	*ppRecord = 0;
	if (FAILED(hr = InsertRecord(psNewID, &LocalRecordIndex, ppRecord, fFlags)))
		goto ErrExit;

	// Delegate actual column sets to the update routine.
	if (FAILED(hr = SetData(*ppRecord, iCols, rgiType, rgpbBuf, cbBuf, pcbBuf,
				rgResult, rgFieldMask)))
		goto ErrExit;
	bIndexesUpdated = true;
    
	// Finally set the temp flag is this function was called for a temporary
    // record.
    if (fFlags & RECORDF_TEMP)
    {
		_ASSERTE(RecordIndex != 0xffffffff);

        hr = m_rgRecordFlags.SetFlags(RecordIndex, fFlags);
        if (FAILED(hr))        
        {
            // undo all the change because SetFlags failed.
            // we don't need to get the return code since we're bailing out 
            // with another error anyways.
			goto ErrExit;
        }
    }

	// We are now dirty.
	SetDirty();

ErrExit:
	// Check for failures and abort the record.
	if (FAILED(hr))
	{
		// Undo indexes if they were built.
        if (bIndexesUpdated)
			VERIFY(SignalAfterDelete(m_pTableDef, RecordIndex, *ppRecord, 0) == S_OK); 

		// Abort the record.
		if (*ppRecord)
		{
			_ASSERTE(LocalRecordIndex == m_pTailHeap->IndexForRecord(*ppRecord));
			m_pTailHeap->VMArray.Delete(LocalRecordIndex);
		}
	}
	return (hr);
}


//*****************************************************************************
// Update data for a record.  This will save off a backup copy of the record,
// apply the updates to the record, and if successful, update the indexes
// which are on the table.  If there is a failure, then the updates to any
// indexes are backed out, and the original data is restored to the record.
// There is no attempt to remove newly added data in the heaps, this is caught
// on a compressing save (there is no way to know if we added the data or
// if it was already there).
//*****************************************************************************
HRESULT StgRecordManager::SetData(		// Return code.
    STGRECORDHDR *pRecord,				// The record to work on.
	int 		iCols,					// number of columns
	const DBTYPE rgiType[], 			// data types of the columns.
	const void	*rgpbBuf[], 			// pointers to where the data will be stored.
	const ULONG cbBuf[],				// sizes of the data buffers.
	ULONG		pcbBuf[],				// size of data available to be returned.
	HRESULT 	rgResult[], 			// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
	const ULONG *rgFieldMask)			// IsOrdinalList(iCols) 
										//	? an array of 1 based ordinals
										//	: a bitmask of columns
{
	STGCOLUMNDEF *pColDef;				// Definition of a column.
	CQuickBytes	qbRecordData;			// backup for the original record data.
	RECORDID	RecordIndex;			// Index of the record to work with.
	int			bColumnList;			// true if column list in rgFieldMask.
	int			iColumnIndex;			// Current 0 based index for arrays.
	ULONG		ColumnOrdinal;			// 1 based column ordinal.
	CIndexList	RollbackList;			// List of original affected indexes.
	HRESULT		hr;

	// Good database row?
	_ASSERTE(IsValidRecordPtr(pRecord));

	// Figure out if we have a bit mask or a column list.
	bColumnList = IsOrdinalList(iCols);
	iCols = iCols & ~COLUMN_ORDINAL_MASK;

	// Quit early when nothing to do.
	if (iCols == 0)
		return (S_OK);

	// Backup the data for the record.
	if (FAILED(hr = _BackupRecordData(m_pTableDef, &qbRecordData, pRecord)))
		goto ErrExit;

	// Get the logical record index, so the Indexes can update themselves.
	RecordIndex = m_RecordHeap.IndexForRecord(pRecord);
	
	// Remove any index entries that are pointing to this record.
	//@todo: Work in a call to IStgIndex::UpdatesRelevent in here some place
	//	so we don't waste time on columns we don't plan to change.
	if (FAILED(hr = SignalAfterDelete(m_pTableDef, RecordIndex, 
				pRecord, &RollbackList)))
		goto Rollback;

	// Loop through every value specified by the caller.
	for (iColumnIndex=0, ColumnOrdinal=0;  iColumnIndex<iCols;  )
	{
		// Get the current ordinal value.
		if (bColumnList)
		{
			if ( rgFieldMask )
				ColumnOrdinal = rgFieldMask[iColumnIndex];
			else
				ColumnOrdinal = iColumnIndex + 1;
		}
		else
		{
			++ColumnOrdinal;
			if (!CheckColumnBit(*rgFieldMask, ColumnOrdinal))
				continue;
		}

		// Get the description of the given column.
		VERIFY(pColDef = m_pTableDef->GetColDesc(ColumnOrdinal - 1));

		// If the column allows nulls, and the caller wants this one to be null, do it.
		if (pColDef->IsNullable() && rgResult && 
				(rgResult[iColumnIndex] == DBSTATUS_S_ISNULL))
		{
			SetCellNull(pRecord, ColumnOrdinal - 1, true);
			hr = S_OK;
		}
		// Else there is an actual data value to set for this column.
		else
		{
			//For not nullable columns, the data pointer should never be null.
			if (NULL == rgpbBuf[iColumnIndex])
			{
				hr = CLDB_E_NOTNULLABLE;
			}
			else
			{
				hr = SetColumnData(pRecord, pColDef, ColumnOrdinal, 
							(BYTE *) rgpbBuf[iColumnIndex], 
							cbBuf[iColumnIndex], rgiType[iColumnIndex]);
			}
		}
		
		// Return status for this column's value.
		if (rgResult)
			rgResult[iColumnIndex]= hr;

		// Once we've processed an entry, move on to the next one.
		++iColumnIndex;
	}

	// Now all of the data has been successfully set.  Need to update any indexes
	// that were previously un-indexed.
	hr = SignalAfterInsert(RecordIndex, pRecord, 0, true);

	// If there were errors updating indexes to the new data, which could happen,
	// for example, if a data value broke a primary key or unique index constraint,
	// then we need to rollback all items that were successfully re-indexed.
	if (FAILED(hr))
		VERIFY(SignalAfterDelete(m_pTableDef, RecordIndex, pRecord, 0) >= S_OK);
	

// If this label is reached in error, then the data for the
// record needs to be rolled back to the orginal state.
Rollback:
	if (FAILED(hr))
	{
		// Restore the original data from the backup.
		VERIFY(_RestoreRecordData(m_pTableDef, qbRecordData.Ptr(), pRecord) == S_OK);

		// Now rebuild any indexes that were originally on the data.
		VERIFY(SignalAfterInsert(RecordIndex, pRecord, &RollbackList, false) == S_OK);
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Sets the data for a given column in the given record.  This will update heap 
// data values and intrinsic values.  It will also remove any null bitflag
// values on a column previously marked as such.
//
// Note that truncation of data values for variable sized data types is an
// error according to the OLE DB specification.  I personally dislike this
// notion, but need to keep it consistent.
//*****************************************************************************
HRESULT StgRecordManager::SetColumnData(// Return code.
	STGRECORDHDR	*pRecord,			// The record to update.
	STGCOLUMNDEF	*pColDef,			// column def pointer
	ULONG			ColumnOrdinal,		// column, 1-based,
	BYTE			*pbSourceData,		// Data for the update.
	ULONG			cbSourceData,		// Size of input data.
	DBTYPE			dbType)				// Data type for data.
{
	HRESULT			hr = S_OK;

	_ASSERTE((dbType & DBTYPE_BYREF) == 0);

	// Can't set a RID column since it doesn't really exist.
	_ASSERTE(pColDef->IsRecordID() == false);
	if (pColDef->IsRecordID())
		return (PostError(BadError(E_INVALIDARG)));

	// Based on the target type, figure out how to set the data.
	switch (pColDef->iType)
	{
		// Variant will updated the variant heap.
		case DBTYPE_VARIANT:
		{
			_ASSERTE(dbType == DBTYPE_VARIANT);
			hr = m_pSchema->GetVariantPool()->AddVariant(
						(VARIANT *) pbSourceData,
						(ULONG *) FindColCellOffset(pColDef, pRecord));
		}
		break;

		// Bytes go into the blob pool.
		case DBTYPE_BYTES:
		{
			_ASSERTE(dbType == DBTYPE_BYTES);

			// Check for truncation.
			if (cbSourceData > pColDef->iMaxSize && pColDef->iMaxSize != COL_NO_DATA_LIMIT)
			{
				hr = CLDB_E_TRUNCATION;
				break;
			}

			// Get the length of the value based on the binding.
			hr = m_pSchema->GetBlobPool()->AddBlob(
						cbSourceData,
						(void *) pbSourceData,
						(ULONG *) FindColCellOffset(pColDef, pRecord));
		}
		break;

		// GUID pool updates.
		case DBTYPE_GUID:
		{
			_ASSERTE(dbType == DBTYPE_GUID);
			hr = m_pSchema->GetGuidPool()->AddGuid(
							*(GUID *) pbSourceData,
							(ULONG *) FindColCellOffset(pColDef, pRecord));
		}
		break;

		// All string data goes into the same heap.
		case DBTYPE_STR:
		case DBTYPE_WSTR:
		case DBTYPE_UTF8:
		{
			switch (dbType)
			{
				// ANSI string goes in the string heap.
				case DBTYPE_STR:
				{
					int		iChars;

					_ASSERTE(dbType == DBTYPE_STR);
					
					// Figure out how many characters there are in the given string.
					iChars = WszMultiByteToWideChar(CP_ACP, 0, (LPCSTR) pbSourceData, cbSourceData, 0, 0);

					// Check for truncation.
					if (iChars > pColDef->iMaxSize && pColDef->iMaxSize != COL_NO_DATA_LIMIT)
					{
						hr = CLDB_E_TRUNCATION;
						break;
					}

					hr = m_pSchema->GetStringPool()->AddStringA(
									(LPCSTR) pbSourceData,
									(ULONG *) FindColCellOffset(pColDef, pRecord),
									(int) cbSourceData);
				}
				break;

				// UNICODE data goes in string heap.
				case DBTYPE_WSTR:
				{
					int		iChars;

					_ASSERTE(dbType == DBTYPE_WSTR);
					
					// Figure out how many characters there are in the given string.
					if (cbSourceData == ~0)
						iChars = (int) wcslen((LPCWSTR) pbSourceData);
					else
						iChars = cbSourceData / sizeof(WCHAR);

					// Check for truncation.
					if (iChars > pColDef->iMaxSize && pColDef->iMaxSize != COL_NO_DATA_LIMIT)
					{
						hr = CLDB_E_TRUNCATION;
						break;
					}

					hr = m_pSchema->GetStringPool()->AddStringW(
									(LPCWSTR) pbSourceData,
									(ULONG *) FindColCellOffset(pColDef, pRecord),
									(int) iChars);
				}
				break;

			
				// User gave us something we don't support.
				default:
				hr = PostError(BadError(E_INVALIDARG));
				break;
			}
		}
		break;

		// Fixed size column values get reset.
		default:
		{
			// If this assert fires, it means you tried to update a column where 
			// potential data type conversion was required.  This is not allowed.
			_ASSERTE(cbSourceData == pColDef->iMaxSize);

// @todo: Aren, we need to clean up the callers to make sure they match data types.
//		Simply renable this assert and find the callers.
//			_ASSERTE(dbType == pColDef->iType);

			// Remove any current null bit turned on for this column, since we are
			// going to give it a valid data value.
			if (pColDef->IsNullable())
				SetCellNull(pRecord, ColumnOrdinal - 1, false);
			memcpy(FindColCellOffset(pColDef, pRecord),
						pbSourceData, cbSourceData);
		}
		break;
	}
	return (hr);
}



//
//
// Internal helpers.
//
//


//*****************************************************************************
// Make a backup copy of a record by simply doing a bitwise copy of the data.
// This will save off heap offets and null values.  Since none of these are
// allowed to change, this should be fine.  Note that the caller is responsible
// for handling changes made to hash index chains.
//*****************************************************************************
HRESULT _BackupRecordData(				// Return code.
	STGTABLEDEF	*pTableDef,				// Definition of the table.
	CQuickBytes	*pbData,				// Where to put backup.
	STGRECORDHDR *pRecord)				// Record with data to backup.
{
	STGRECORDHDR *pRecordTmp;
	
	// Allocate room for the record.
	pRecordTmp = (STGRECORDHDR *) pbData->Alloc(pTableDef->iRecordSize);
	if (!pRecordTmp)
		return (PostError(OutOfMemory()));

	// Make a copy and return.
	memcpy(pRecordTmp, pRecord, pTableDef->iRecordSize);
	return (S_OK);
}


//*****************************************************************************
// Take the data created by _BackupRecordData and restore it over the given
// record's data.
//*****************************************************************************
HRESULT _RestoreRecordData(				// Return code.
	STGTABLEDEF	*pTableDef,				// Definition of the table.
	void		*pbData,				// The backup to restore from.
	STGRECORDHDR *pRecord)				// Where the backup goes.
{
	// Make a copy and return.
	memcpy(pRecord, pbData, pTableDef->iRecordSize);
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgrecordmanagerqry.cpp ===
//*****************************************************************************
// StgRecordManagerQry.cpp
//
// This module contains code for the query processing portion of 
// StgRecordManager.  This includes support for index lookups, table scans,
// query expressions (for View objects), and anything else used to index and
// retrieve data.  The main functions of interest are:
//		GetRow
//		TableScan
//		ChooseIndex
//		LoadIndexes
//		Signal* (for index updates)
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard include.
#include <mbstring.h>					// MBCS support for data conversion.
#include "Services.h"					// For data conversion.
#include "OleDBUtil.h"					// OLE DB Helpers.
#include "StgDatabase.h"				// Parent database.
#include "StgRecordManager.h"			// Record manager interface.
#include "StgIndexManager.h"			// Hashed index code.
#include "StgSortedIndex.h"				// sorted index code.


//*****************************************************************************
// Adds all (non-deleted) records to the given cursor, no filters.
//*****************************************************************************
HRESULT StgRecordManager::QueryAllRecords( // Return code.
	RECORDLIST	&records)				// List to build.
{
	RECORDHEAP	*pHeap;					// For walking the heaps.
	STGRECORDHDR *pRecord = 0;	    	// Record to compare to.
	RECORDID	LocalRecordIndex;		// Loop control.
	RECORDID	iCount;					// How many items.
	RECORDID	RecordIndex=0;			// 0 based record index.
	void		**ppRecord=0;				// For each new record.
	HRESULT		hr = S_OK;

	// Pre allocate a cursor that is big enough for all non-deleted records.
	// Note that we do then turn around and scan the heaps again for the 
	// actual values, but scanning is quicker than hitting the heap multiple
	// times for the realloc case.
	iCount = Records();
	if (iCount)
	{
		// Pre allocate the return array because we know cardinality.
		if (!records.AllocateBlock(iCount))
			return (PostError(OutOfMemory()));
		VERIFY(ppRecord = records.Ptr());
	}

	// Loop first through all heaps with records.
	for (pHeap=&m_RecordHeap;  pHeap;  pHeap=pHeap->pNextHeap)
	{
		// Get the first record.
		VERIFY(pRecord = (STGRECORDHDR *) pHeap->VMArray.Get(0));

		// Get each row.
		for (LocalRecordIndex=0;  LocalRecordIndex<pHeap->VMArray.Count();  LocalRecordIndex++, RecordIndex++)
		{
			// Check for deleted records and discard them.
			if ((m_rgRecordFlags.GetFlags(RecordIndex) & RECORDF_DEL) == 0)
			{
				*ppRecord = pRecord;
				++ppRecord;
			}

			// Move to next record.
			pRecord = (STGRECORDHDR *) ((UINT_PTR) pRecord + m_pTableDef->iRecordSize);
		}
	}
	return (S_OK);
}


//*****************************************************************************
// Build a list of records which meet the filter criteria passed in.  This
// code implements the low level specification documented by 
// IViewFilter::SetFilter.  The query is specified using several arrays.  A
// set of bindings identify which columns are being compared and the location
// of the user data.  An array of user data filter records are given to find
// the actualy bytes described by the accessor.  Another array contains the
// comparison operators for each column to data.  For each filter record, a
// candidate row must meet all of the criteria (that is, each column comparison
// is ANDed with each other).  Rows which meet any filter record will go into
// the final cursor (that is, each filter record is ORed with each other record).
//
// This is the main entry point for an OLE DB customer.  This code will work
// on building the "access plan" for execution.  This means that each filter
// record is scanned for indexes that might speed execution.  All user data
// values are converted to compatible types as required for easy comparison.
// Once all of this work is done, control is delegated to QueryRowsExecute
// which will actually go scan indexes and records looking for the final
// results.
//
// If you already know the indexes you want to search on, and can guarantee
// that your comaprison data is compatible, then you may call QueryRowsExecute 
// directly and avoid a lot of extra work.
//*****************************************************************************
HRESULT StgRecordManager::QueryRows(	// Return code.
	CFetchRecords *pFetchRecords,		// Return list of records here.
	ULONG		cBindings,				// How many bindings for user data.
	DBBINDING	rgBinding[],			// Binding data.
	ULONG		cFilters,				// How many filter rows.
	DBCOMPAREOP	rgfCompare[],			// Comparison operator.
	void		*pbFilterData,			// Data for comparison.
	ULONG		cbFilterSize)			// How big is the filter data row.
{
#if 0
	STGCOLUMNDEF *pColDef;				// Column description.
	STGINDEXDEF	*pIndexDef;				// Index definition object.
	ULONG		iRIDCol, iPKCol;		// Column IDs.
	ULONG		*rgColumns;				// List of columns to filter by.
	DBCOMPAREOP	rgfComp[];				// Working array of compare ops.
	DBBINDING	*rgQryBinding=0;		// Temporary array for shuffling bindings.
	DBBINDING	
	QUERYINDEX	*rgQryIndex=0;			// Hint for query execution.
	QUERYINDEX	**ppQryHint=0;			// Used for hints.
	int			bEquality;				// true if there are equality conditions.
	int			iSpecialCols;			// How many RID and PK columns.
	ULONG		i, j;					// Loop control.
	HRESULT		hr;

	//
	// Step 1 - Look for equality filter conditions that can be matched up
	//		to index or special columns, making lookup very fast.
	//

	// Allocate an array of column ID's to use for lookup.
	rgColumns = (ULONG *) _alloca(sizeof(ULONG) * m_pTableDef->iColumns);

	// Init values for scan.
	iRIDCol = iPKCol = (ULONG) -1;

	// Look for any equality conditions which we may be able to service with
	// an index if there is any.
	for (i=0;  i<cBindings;  i++)
	{
		if (SafeCompareOp(rgfCompare[i]) == DBCOMPAREOPS_EQ)
		{
			bEquality = true;
			break;
		}
	}

	// Count the special columns for scanning.
	iSpecialCols = 0;
	if (m_pTableDef->HasRIDColumn())
		++iSpecialCols;
	if (m_pTableDef->HasPrimaryKeyColumn())
		++iSpecialCols;

	// If there are equality conditions, scan for key columns.
	if (bEquality && iSpecialCols)
	{
		for (i=0;  i<m_pTableDef->iColumns && iSpecialCols;  i++)
		{
			VERIFY(pColDef = m_pTableDef->GetColDesc(i));

			if (pColDef->IsRecordID())
			{
				iRIDCol = i;
				--iSpecialCols;
			}
			else if (pColDef->IsPrimaryKey())
			{
				iPKCol = i;
				--iSpecialCols;
			}
		}
	}

	//
	// Step 2 - For each filter record, choose an access plan.  This involves 
	//		looking for RID, PK, unique hash, and hashed indexes in that order.
	//		When one of these is found, then the bindings are shuffled (as required)
	//		with the index value first followed by the rest of the criteria.
	//

	rgfComp = rgfCompare;
	for (i=0;  i<cFilters;  i++)
	{
		// Clear the column array for this filter.
		memset(rgColumns, 0xff, sizeof(ULONG) * m_pTableDef->iColumns);

		// Record every column that is doing equality and is elligible to
		// be found via a special column or index.
		for (j=0;  j<cBindings;  j++)
		{
			if (SafeCompareOp(rgfComp[j]) == DBCOMPAREOPS_EQ)
			{
				// If this fires, then the caller wants to filter with equality on
				// the same column.  Given the AND between columns, the only way this
				// will find records is if both conditions contain the same value in
				// which case why did you need both?  It is not strictly an error
				// to do this, and we could add code to smartly reject it, but
				// I'm going to have it be a warning to avoid that complexity.
				_ASSERTE(rgColumns[rgBinding[j].iOrdinal - 1] == 0xffffffff && "USER ERROR: multiple equality of same column.");

				// Save the binding which corresponds to this column.
				rgColumns[rgBinding[j].iOrdinal - 1] = j;
			}
		}

		// If there is a RID column, and the user is doing EQ on it, use it.
		if (iRIDCol != (ULONG) -1 && rgColumns[iRIDCol])
		{
			hr = QueryShuffleBindings(1, &rgColumns[iRIDCol],
					cBindings, rgBinding, pbFilterData,
					rgfComp, rgQryBinding, rgfQryComp);

			if (FAILED(hr))
				goto ErrExit;
		}
		// No RID, but same test for PK column, next best search time.
		else if (iPKCol != (ULONG) -1 && rgColumns[iPKCol])
		{
		}

HRESULT StgRecordManager::QueryShuffleBindings( // Return code.
	ULONG		iCols,					// How many columns to shuffle.
	ULONG		rgCols[],				// Array of those columns to shuffle.
	ULONG		cBindings,				// How many bindings for user data.
	DBBINDING	rgBinding[],			// Binding data.
	void		*pbFilterData,			// Data for comparison.
	DBCOMPAREOP	rgfCompare[],			// Comparison operator.
	DBBINDING	**prgQryBinding,		// If non-null on input, array of bindings of
										//	size cBindings we can overwrite. Otherwise new array.
	DBCOMPAREOP	**prgfCompare)			// Return new compare structs if needed.

		// Move to the next set of comparisons.
		rgfComp = &rgfComp[cBindings];
	}


	//
	// Step 2 - Create an alternate set of bindings that convert data types
	//		to match the column type exactly.
	//

	ppQryHint = &rgQryIndex;

	hr = QueryRowExecute(pFetchRecords, cBindings, rgBinding, 
				cFilter, rgfCompare, pbFilterData, cbFilterSize, ppQryHint);
#endif
	return (S_OK);
}


//*****************************************************************************
// This function is called with all indexes resolved and all data types for
// comparison converted (as required).  All records are compared to each
// filter record.  Only those records which match all conditions of a filter
// are added.  Records in the cursor need only match one filter.
//*****************************************************************************
HRESULT StgRecordManager::QueryRowsExecute(	// Return code.
	CFetchRecords *pFetchRecords,		// Return list of records here.
	ULONG		cBindings,				// How many bindings for user data.
	DBBINDING	rgBinding[],			// Binding data.
	ULONG		cFilters,				// How many filter rows.
	DBCOMPAREOP	rgfCompare[],			// Comparison operator.
	void		*pbFilterData,			// Data for comparison.
	ULONG		cbFilterSize,			// How big is the filter data row.
	QUERYINDEX	*rgpIndex[])			// Indexes per filter row, may be 0.
{
	STGRECORDHDR *pRecord;				// For single record lookups.
	DBCOMPAREOP *rgfComp;				// Current set of compare ops.
	ULONG		iFilter;				// Loop control.
	ULONG		iDexBindings;			// How many of the bindings are index related.
	RECORD		*pNewRecord;			// For list update.
	RECORDID	RecordID;				// For list updates.
	QUERYINDEX	*pIndex;				// For list of indexes.
	QUERYINDEX	sIndex;					// For dynamic substitution.
	void		*pbData;				// User data.
	int			bTableScan;				// Should table scan be used.
	HRESULT		hr = S_OK;

//@todo: handle deleted rows.


	// Set pointer to first filter record.
	pbData = pbFilterData;

	// Set comparison ops to current filter record.
	rgfComp = rgfCompare;

	// For filter row, find the records that meet the criteria.
	for (iFilter=0;  iFilter<cFilters;  iFilter++)
	{
		// Init defaults for the loop.
		bTableScan = false;
		hr = S_OK;

		// Get a pointer to our query descriptor.
		pIndex = (rgpIndex) ? rgpIndex[iFilter] : 0;

		// Make sure record manager is always the same as db.
		_ASSERTE(!(m_pDB->IsReadOnly() && (m_fFlags & SRM_WRITE)));

		// In write mode, primary key searches by row order cannot be guarnateed
		// because of deletes and updates.  A temporary hashed index is automatically
		// built for the user.  Instead of requiring the caller to know this,
		// check the case and get the loaded index right now.
		if (pIndex && pIndex->iType == QI_PK && (m_fFlags & SRM_WRITE))
		{
			STGINDEXDEF	*pIndexDef;
			WCHAR		rcDex[MAXINDEXNAME];

			// Get the name of the unique index, then the definition.
			StgDatabase::GetUniqueTempIndexNameW(rcDex, sizeof(rcDex), TableName());
			pIndexDef = GetIndexDefByName(rcDex);

			// If one is found, then try to make it the hint.
			if (pIndexDef)
			{
				// Fill out the rest of the hint.
				pIndex = &sIndex;					
#if 1
				// @todo: PRIMARYKEY_SORTEDINDEX
					sIndex.iType = QI_HASH;
#else
					sIndex.iType = QI_SORTED;
#endif
				sIndex.pIIndex = GetLoadedIndex(pIndexDef);

				// If there isn't a loaded index for some reason, then just let the
				// rest of the code scan for records.
				if (!sIndex.pIIndex)
				{
					pIndex = 0;
					//DEBUG_STMT(DbgWrite(L"Warning: primary key query changed to table scan.\n"));
				}
			}
		}

		// If there is an index that can be used to look up rows, then use it.
		if (pIndex)
		{
			// Both RID and PK lookups can find only one row.  Do a lookup for
			// that row and if found, further filter with other data.
			if (pIndex->iType == QI_RID || pIndex->iType == QI_PK)
			{
				// In this case, the first binding must always refer to the RID or PK column.
				iDexBindings = 1;

				// Retrieve the row for this RID.
				if (pIndex->iType == QI_RID)
				{
					// Has to be equality to be a valid hint.  Any other operator on
					// a RID must not use a hint but rather a scan.
					_ASSERTE(SafeCompareOp(rgfComp[0]) == DBCOMPAREOPS_EQ);

					// You can't query for a NULL RID value, that doesn't make any sense.
					_ASSERTE(!(rgBinding[0].dwPart & DBPART_STATUS) || StatusPart((BYTE *) pbData, &rgBinding[0]) == S_OK);

					hr = QueryRowByRid(&rgBinding[0], pbData, &pRecord);
				}
				// Retrieve the row by primary key search.
				else
				{
					// Comparison on primary key hint has to be equality or begins with,
					// both of which can be done with a b-search.  Anything else must
					// not give a hint and use a scan.
					_ASSERTE(SafeCompareOp(rgfComp[0]) == DBCOMPAREOPS_EQ || SafeCompareOp(rgfComp[0]) == DBCOMPAREOPS_BEGINSWITH);

					// You can't have a NULL primary key value in this system.  If this
					// fires, fix the query code path that allowed us to get here.
					_ASSERTE(!(rgBinding[0].dwPart & DBPART_STATUS) || StatusPart((BYTE *) pbData, &rgBinding[0]) == S_OK);

					// Get the primary key column.
					STGCOLUMNDEF *pColDef;
					VERIFY(pColDef = m_pTableDef->GetColDesc((int) (rgBinding[0].iOrdinal - 1)));

					// Find the row for this primary key.
					hr = QueryRowByPrimaryKey(pColDef, 0, rgfComp[0], &rgBinding[0], 
							iDexBindings, pbData, &pRecord);
				}
				
				// Check for failure.				
				if (FAILED(hr) && hr != CLDB_E_RECORD_NOTFOUND)
					goto ErrExit;

				// If no record was found, then there is nothing left to check.
				if (!pRecord)
				{
					// Don't let record not found get returned as an error.
					hr = S_OK;
					continue;
				}

				// If the record is already in the final cursor, then there
				// is nothing left to check.  Only do this for multiple filter
				// records since the first pass won't add dupes.
				if (iFilter && pFetchRecords->FindRecord(pRecord, GetRecordID(pRecord)) != 0xffffffff)
				{
					continue;
				}

				// If there are additional filters to apply to the record before
				// adding it to the list, then apply them now.
				if (cBindings > iDexBindings)
				{
					hr = QueryFilter(pRecord, cBindings - iDexBindings,
							&rgBinding[iDexBindings], pbData, &rgfComp[iDexBindings]);
				}
				
				// If the record is still a match, add it to the list.
				if (hr == S_OK)
				{
					_ASSERTE(pRecord);
					RecordID = GetRecordID(pRecord);
					hr = pFetchRecords->AddRecordToRowset(pRecord, &RecordID, pNewRecord);
				}	
			}
			// A hashed index can find many potential rows.  Let the index
			// manager search the index for matches and send along the rest
			// of the filter as well.  Only rows that meet both the index
			// values and the rest of the filter are added to the cursor.
			else if (pIndex->iType == QI_HASH)
			{
				// Count the bindings in the index.
				iDexBindings = pIndex->pIIndex->GetIndexDef()->iKeys;

				// Now scan and possibly filter.
				hr = pIndex->pIIndex->FindRecord(
						(BYTE *) pbData, iDexBindings, rgBinding, rgfComp,
						pFetchRecords, (BYTE *) pbData, cBindings - iDexBindings,
						&rgBinding[iDexBindings], &rgfComp[iDexBindings]);

				// If the index can't answer the question, then revert to a table scan.
				if (hr == CLDB_S_INDEX_TABLESCANREQUIRED)
				{
					hr = S_OK;
					bTableScan = true;
				}
			}
			// If the index type is sorted, then need to use the sorted index to
			// retrieve the records.
			else if (pIndex->iType == QI_SORTED)
			{
				long iRecordCount = m_RecordHeap.Count();
				CDynBitVector BitVector;	

				// BitVector needs to be explicitly initialized.
				hr = BitVector.Init(iRecordCount);
				if (FAILED(hr))
					goto ErrExit;

				iDexBindings = pIndex->pIIndex->GetIndexDef()->iKeys;
				
				// The premise for the check here is to figure out whether b-search or linear scan would
				// be the better query plan. If the first comparator is not "NE", then simply use b-search.
				// else If the first comparator is "NE" and there is only 1 filter, then the "NE" can be 
				// treated as an "EQ" and invert the result. to get the required set of rows. If the 
				// first comparator is "NE", but there are more than 1 filters, then a linear scan would be better.
				if (rgfComp[0] == DBCOMPAREOPS_NE)
				{
					if (cBindings > 1)
					{
						// since you're going to touch all the records anyways, a table scan 
						// is better for this case.
						bTableScan = true;
					}
				}

				if (!bTableScan)
				{
					hr = pIndex->pIIndex->FindRecord((BYTE *) pbData, iDexBindings, cBindings, rgBinding, 
													rgfComp, &BitVector, 0);

					// If the index can't answer the question, then revert to a table scan.
					if (hr == CLDB_S_INDEX_TABLESCANREQUIRED)
					{
						hr = S_OK;
						bTableScan = true;
					}
					// Or hard error.
					else if (FAILED(hr))
						goto ErrExit;
					// Finally we can use the results.
					else
						hr = GetRecordsFromBits(&BitVector, pFetchRecords);
				}
			
			} // sorted index lookup
		}
		// When there is no index, a table scan is required.  Walk every
		// record using the filter criteria for matching.  Pass along all
		// rows already found so that they don't need to be re-scanned.
		else
			bTableScan = true;


		// If an optimized lookup could not be performed, then do a table scan.
		if (SUCCEEDED(hr) && bTableScan)
		{
			hr = QueryTableScan(pFetchRecords, cBindings, rgBinding,
					pbData, rgfComp);
		}

		// Check for errors.
		if (FAILED(hr))
			goto ErrExit;
	
		// Advance filter record data and comparison ops.
		pbData = (void *) ((UINT_PTR) pbData + cbFilterSize);
		rgfComp = &rgfComp[cBindings];
	}

	// If there are no filters at all, it means grab all records.
	if (cFilters == 0)
	{
		hr = QueryTableScan(pFetchRecords, 0, 0, 0, 0);
	}

ErrExit:
	return (hr);
}



//*************************************************************************************
// This function fills in a CFetchRecord structure based on the bit vector provided.
// The function is intentionally expanded for the 2 cases: read-only and 0-deleted records (to
// be added yet) and read-write case (with possibly deleted records).
// The function checks to see if the record is deleted in the read-write case.
//*************************************************************************************
HRESULT StgRecordManager::GetRecordsFromBits(
	CDynBitVector *pBitVector,
	CFetchRecords *pFetchRecords)
{
	BYTE		*pBytes;				
	BYTE		*pLastByte;
    BYTE        fFlags;                 // record flag.
	RECORDID	RecordIndex = 0;
	STGRECORDHDR *psRecord;
	RECORD		*pRecord;
	int			iBitsSet;				// keep a track of the set bits to break out earlier.
	RECORDHEAP	*pRecordHeap;			// Track the record heap.
	RECORDID	HeapTotal;				// Total count up until now.
	HRESULT		hr = S_OK;

	_ASSERTE(pBitVector != NULL);
	_ASSERTE(pFetchRecords != NULL);

	// Get loop control variables.
	pBytes = pBitVector->Ptr();
	pLastByte = pBytes + pBitVector->Size();
	iBitsSet = pBitVector->BitsSet();

	// Track the current record heap to make record scans faster.
	pRecordHeap = &m_RecordHeap;
	HeapTotal = 0;	

	// Walk the bit vector a byte at a time, which allows us to skip over
	// whole bytes that have no bits set.  This is probably pretty common
	// and therefore faster than scanning each bit.
	for ( ;pBytes <= pLastByte && iBitsSet; pBytes++)
	{
		if (*pBytes == (BYTE) 0)
		{
			RecordIndex += 8;
		}
		else 
		{
			// There is at least 1 bit set in this byte, scan them all.
			for (int i=0; i<8; i++)
			{
				if (!pBitVector->GetBit(RecordIndex))
				{
					RecordIndex++;
					continue;
				}

				// Check for and ignore deleted records.				
				fFlags = m_rgRecordFlags.GetFlags(RecordIndex);
				if (fFlags & RECORDF_DEL)
				{
					RecordIndex++;
					continue;
				}

				// Make sure we're in the correct record heap.
				while (RecordIndex >= HeapTotal + pRecordHeap->VMArray.Count())
				{
					HeapTotal += pRecordHeap->VMArray.Count();
					VERIFY(pRecordHeap = pRecordHeap->pNextHeap);
				}

				psRecord = (STGRECORDHDR *) pRecordHeap->VMArray.Get(RecordIndex - HeapTotal);
				_ASSERTE(psRecord != NULL);
				
				// This one matched, so add it to the user's array.
				if (FAILED(hr = pFetchRecords->AddRecordToRowset(psRecord, &RecordIndex, pRecord)))
					goto ErrExit;
				
				RecordIndex++;
				iBitsSet--;
			} // for each bit in byte.
		}
	} // for each byte in bit vector.

ErrExit:
	return (hr);
}


//*****************************************************************************
// Given a RID from the user, find the corresponding row.  A RID is simply the
// array offset of the record in the table.  A RID can have a preset base so
// the user value must be adjusted accordingly.
//*****************************************************************************
HRESULT StgRecordManager::QueryRowByRid( // Return code.
	DBBINDING	*pBinding,				// Bindings for user data to comapre.
	void		*pbData,				// User data for compare.
	STGRECORDHDR **ppRecord)			// Return record here if found.
{
	RECORDID	RecordID;				// Converted value to do lookup on.
	ULONG		RecordIndex;			// 0 based index.

	// Validate input.
	_ASSERTE(pBinding && pbData && ppRecord);

	// Avoid confusion.
	*ppRecord = 0;

	// Get the record id from the user data, doing simple conversion as required.
	switch (pBinding->wType & ~DBTYPE_BYREF)
	{
		case DBTYPE_I2:
		case DBTYPE_UI2:
		RecordID = *(USHORT *) DataPart((BYTE *) pbData, pBinding);
		break;

		case DBTYPE_I4:
		case DBTYPE_UI4:
		case DBTYPE_OID:
		RecordID = *(ULONG *) DataPart((BYTE *) pbData, pBinding);
		break;

		default:
		if ((pBinding->dwPart & DBPART_STATUS) != 0)
			*StatusPartPtr((BYTE *) pbData, pBinding) = DB_E_UNSUPPORTEDCONVERSION;
		return (PostError(DB_E_ERRORSOCCURRED));
	}

	// Adjust the record by start value.
	RecordIndex = IndexForRecordID(RecordID);
	if (RecordIndex  < 0 || RecordIndex  >= m_RecordHeap.Count())
		return (PostError(DISP_E_BADINDEX));

	// Check for deleted records and discard them.
	if (m_rgRecordFlags.GetFlags(RecordIndex) & RECORDF_DEL)
		return (PostError(CLDB_E_RECORD_DELETED));
		
	// Get the pointer for this item and return it to the caller.
	*ppRecord = GetRecord(&RecordID);
	return (S_OK);
}


//*****************************************************************************
// Retrieve the record ID for a given key.  The key data must match the
// primary index of this table.
//@todo: rewrite this on top of the Query* functions.
//*****************************************************************************
HRESULT StgRecordManager::GetRow(		// Return code.
	CFetchRecords *pFetchRecords,		// Return list of records here.
	DBBINDING	rgBinding[],			// Binding data.
	ULONG		cStartKeyColumns,		// How many key columns to subset on.
	void		*pStartData,			// User data for comparisons.
	ULONG		cEndKeyColumns,			// How many end key columns.
	void		*pEndData,				// Data for end comparsion.
	DBRANGE		dwRangeOptions)			// Matching options.
{
	DBBINDING	*rgBindingConvert=0;	// Converted bindings.
	PROVIDERDATA *rgData=0;				// For byref lookup on data type conversion.
	STGCOLUMNDEF *pColDef=0;			// For column lookups.
	IStgIndex	*pIndex;				// The index object with data.
	bool		bRowIdLookup = false;	// true for row lookup.
	bool		bPKLookup = false;		// true for a primary key lookup.
	bool		bIsIndexed = false;		// true if there is a unique index.
	long		iMaxRows;				// For table scan setting.
	ULONG		i;						// Loop control.
	void		*rgFree[16] = {0};		// To track to-be-freed.
	HRESULT		hr;

	// Check the values given for keys against the values actually stored.
	for (i=0;  i<cStartKeyColumns;  i++)
	{
		// Get the definition of this column.
		VERIFY(pColDef = m_pTableDef->GetColDesc((int) (rgBinding[i].iOrdinal - 1)));

		// If there is only one column and it is a match, check for special
		// quick lookup features.
		if (cStartKeyColumns == 1 && dwRangeOptions == DBRANGE_MATCH)
		{
			// Check for special case of row id hash.
			if (pColDef->IsRecordID())
				bRowIdLookup = true;
			// Check for a primary key lookup.
			else if (pColDef->IsPrimaryKey())
			{
				//@todo: fault in hash pk index if need be.
				if ((m_fFlags & SRM_WRITE) == 0)
					bPKLookup = true;
			}
		}

		// If there needs to be a conversion, then do one.
		if ((rgBinding[i].wType & ~DBTYPE_BYREF) != pColDef->iType ||
			(rgBinding[i].wType & ~DBTYPE_BYREF) == DBTYPE_WSTR)
		{
			//@todo: This only handles one conversion.  Needs to handle all possible
			// converted values.  Also, just keep a bit around to indicate when
			// memory was allocated so free code below is less contrived.
			
			// Allocate some space for new bindings.
			VERIFY(rgBindingConvert = (DBBINDING *) _alloca(sizeof(DBBINDING) * cStartKeyColumns));
			VERIFY(rgData = (PROVIDERDATA *) _alloca(sizeof(PROVIDERDATA) * cStartKeyColumns));

			// Turn each binding into a new properly converted comparison.
			if (FAILED(hr = GetBindingsForLookup(cStartKeyColumns, rgBinding,
					pStartData, rgBindingConvert, rgData, rgFree)))
				return (hr);

			// Redirect rest of code through converted bindings.
			rgBinding = rgBindingConvert;
			pStartData = &rgData[0];
			break;
		}
	}

	// The caller is doing a lookup by record id, which we can answer right now.
	if (bRowIdLookup)
	{
		RECORDID	RecordID;
		RECORD		*pRecord;

		// Pull the record ID from the user.
		switch (rgBinding[0].wType & ~DBTYPE_BYREF)
		{
			case DBTYPE_I2:
			case DBTYPE_UI2:
			RecordID = *(USHORT *) DataPart((BYTE *) pStartData, &rgBinding[0]);
			break;

			case DBTYPE_I4:
			case DBTYPE_UI4:
			case DBTYPE_OID:
			RecordID = *(ULONG *) DataPart((BYTE *) pStartData, &rgBinding[0]);
			break;

			default:
			if ((rgBinding[0].dwPart & DBPART_STATUS) != 0)
				*StatusPartPtr((BYTE *) pStartData, &rgBinding[0]) = DB_E_UNSUPPORTEDCONVERSION;
			return (PostError(DB_E_ERRORSOCCURRED));
		}

		// Adjust the record by start value.
		RecordID = IndexForRecordID(RecordID);
		if (RecordID < 0 || RecordID >= m_RecordHeap.Count())
			return (PostError(DISP_E_BADINDEX));

		// Add the record to the list.
		hr = pFetchRecords->AddRecordToRowset(GetRecord(&RecordID), 
				&RecordID, pRecord);
	}
	// If this is a primary key lookup, then an index isn't actually kept.
	// Instead records are stored sorted by primary key and a b-search is done.
	// Note that if there are too few records, let a table scan do the work.
	else if (bPKLookup && m_RecordHeap.Count() > MINBSEARCHVAL)
	{
		hr = SearchPrimaryKey(pColDef, pFetchRecords, rgBinding, pStartData);
	}
	// Look for an index, and if one is found, do a hash lookup.
	else if (dwRangeOptions == DBRANGE_MATCH && cStartKeyColumns &&
			(pIndex = ChooseIndex((USHORT) cStartKeyColumns, rgBinding, &bIsIndexed)) != 0)
	{
		// Ask the index to find all matches.
		hr = pIndex->FindRecord((BYTE *) pStartData, (USHORT) cStartKeyColumns, 
			rgBinding, NULL, pFetchRecords, 0, 0, 0, 0);
	}
	// There is nothing left to do but a full table scan at this point.
	else 
	{
		// If there is a unique index, we can make the table scan faster by
		// looking for only the first match.
		//@todo: think about this and deferred indexes; if we never built the
		// index we never enforced uniqueness!
		if (bIsIndexed || bPKLookup)
			iMaxRows = 1;
		else
			iMaxRows = -1;

		// Hard code comparison operation to equals.
		DBCOMPAREOP *rgfCompare = (DBCOMPAREOP *) _alloca(sizeof(DBCOMPAREOP) * cStartKeyColumns);
		for (ULONG i=0;  i<cStartKeyColumns;  i++)
			rgfCompare[i] = DBCOMPAREOPS_EQ;

		// Scan for the rows we care about.
		hr = QueryTableScan(pFetchRecords, cStartKeyColumns, rgBinding,
					pStartData, rgfCompare, iMaxRows);
	}

	// Clean up any conversion data.
	for (i=0;  i<cStartKeyColumns;  i++)
	{
		if (rgFree[i])
			free(rgFree[i]);
	}
	return (hr);
}


//*****************************************************************************
// Called to do a binary search on the primary key column.  The binary search
// code is inlined here for efficiency.
//*****************************************************************************
HRESULT StgRecordManager::SearchPrimaryKey(//Return code.
	STGCOLUMNDEF *pColDef,				// The column to search.
	CFetchRecords *pFetchedRecords,		// Return list of records here.
	DBBINDING	*pBinding,				// Binding data.
	void		*pData)					// User data for comparisons.
{
	STGRECORDHDR *pRecord;				// The record to compare against.
	RECORD		*pRcd;					// Wasted space.
	RECORDID	i=0;					// Loop control.
	int			iCmp;					// Comparison of record to key.
	int			iFirst, iLast, iMid;	// Loop control.
	
	_ASSERTE(pColDef->IsPrimaryKey());
	
	// Set up boundaries for search.
	iFirst = 0;
	iLast = m_RecordHeap.Count() - 1;

	DBCOMPAREOP fCompare = DBCOMPAREOPS_EQ;
	if((pColDef->fFlags & CTF_CASEINSENSITIVE)  && DBTYPE_WSTR==pColDef->GetSafeType())
		fCompare |= DBCOMPAREOPS_CASEINSENSITIVE; 

	// Scan the list in halfs.
	while (iFirst <= iLast)
	{
		iMid = (iLast + iFirst) / 2;
		
		VERIFY(pRecord = (STGRECORDHDR *) m_RecordHeap.GetRecordByIndex(iMid));
		iCmp = CompareRecordToKey(pColDef, pRecord, pBinding, (BYTE *) pData, fCompare);

		_ASSERTE(m_RecordHeap.IndexForRecord(pRecord) != ~0);

		// If the record comes before the value, we need to go to the right.
		if (iCmp > 0)
			iLast = iMid - 1;
		// If the record comes after the value, we go left.
		else if (iCmp < 0)
			iFirst = iMid + 1;
		// Otherwise we found it.
		else
        {
            i = iMid;
			return (pFetchedRecords->AddRecordToRowset(pRecord, &i, pRcd));
        }
	}

	// Didn't find the record, so tell caller.
	return (CLDB_E_RECORD_NOTFOUND);
}




//*****************************************************************************
// Compare two records by their key values as per the index definition.
//*****************************************************************************
int StgRecordManager::CompareKeys(		// -1, 0, 1
	STGINDEXDEF	*pIndexDef,				// The definition to use.
	RECORDID	RecordID1,				// First record.
	RECORDID	RecordID2)				// Second record.
{
	STGCOLUMNDEF *pColDef;				// Column definition.
	STGRECORDHDR *psRecord1;			// First record.
	STGRECORDHDR *psRecord2;			// Second record.
	BYTE		*piKey;					// List of keys.
	int			i;						// Loop control.
	int			iCmp = 0;				// Compare info.

	// Load each of the pages.
	VERIFY(psRecord1 = GetRecord(&RecordID1));
	VERIFY(psRecord2 = GetRecord(&RecordID2));

	// Walk the index.
	piKey = &pIndexDef->rgKeys[0];
	for (i=0;  i<pIndexDef->iKeys;  i++, piKey++)
	{
		// Load the column definition.
		VERIFY(pColDef = m_pTableDef->GetColDesc(*piKey));
		
		// Shouldn't have null values in an index.
		_ASSERTE(GetCellNull(psRecord1, (*piKey) - 1) == false && GetCellNull(psRecord2, (*piKey) - 1) == false);

		// Compare these two records.
		iCmp = CompareRecords(pColDef, psRecord1, psRecord2);

		// If errors, then we're done comparing.
		if (iCmp != 0)
			break;
	}
	return (iCmp);
}


//*****************************************************************************
// Compare a record to key data.
//*****************************************************************************
int StgRecordManager::CompareKeys(		// -1, 0, 1
	STGINDEXDEF	*pIndexDef,				// The definition to use.
	STGRECORDHDR *psRecord,				// Record to compare.
	BYTE		*pData,					// User data.
	ULONG		iColumns,				// How many columns.
	DBBINDING	rgBindings[],			// Column accessors.
	DBCOMPAREOP rgfCompare[])
{
	STGCOLUMNDEF *pColDef;				// Column definition.
	BYTE		*piKey;					// List of keys.
	ULONG		i;						// Loop control.
	int			iCmp = 0;				// Compare info.
	DBCOMPAREOP fCompare;

	// Load each of the pages.
	_ASSERTE(iColumns <= pIndexDef->iKeys);

	// Walk the index.
	piKey = &pIndexDef->rgKeys[0];
	for (i=0;  i<iColumns;  i++, piKey++)
	{
		// Load the column definition.
		VERIFY(pColDef = m_pTableDef->GetColDesc(*piKey - 1));

		fCompare = (rgfCompare ? rgfCompare[i] : DBCOMPAREOPS_EQ);
		if((pColDef->fFlags & CTF_CASEINSENSITIVE)  && DBTYPE_WSTR==pColDef->GetSafeType())
			fCompare |= DBCOMPAREOPS_CASEINSENSITIVE; 

		// If the column does not allow the null value, then just compare data.
		if (!pColDef->IsNullable())
		{
			iCmp = CompareRecordToKey(pColDef, psRecord, &rgBindings[i], pData, fCompare);
		}
		// Else check the null status of the column and the user data.
		else 
		{
			bool bColNull = GetCellNull(psRecord, (*piKey) - 1);
			bool bDataNull = (((rgBindings[i].dwPart & DBPART_STATUS) != 0) && StatusPart(pData, &rgBindings[i]) & DBSTATUS_S_ISNULL);
			
			// If both are null, then they are equivalent.
			if ((bColNull == true) && (bDataNull == true))
				iCmp = 0;
			// Else if either is null but the other is not, then sort nulls to the front.
			else if (bColNull != bDataNull)
			{
				if (bColNull == false)
					iCmp = -1;
				else // if (bDataNull == 0)
					iCmp = +1;
			}
			// Finally, both are non-null, so need to compare data values to see where they go.
			else 
			{
				_ASSERTE(bColNull == false && bColNull == bDataNull);
				iCmp = CompareRecordToKey(pColDef, psRecord, &rgBindings[i], pData, fCompare);
			}
		}

		// If errors, then we're done comparing.
		if (iCmp != 0)
			break;
	}
	return (iCmp);
}


//*****************************************************************************
// Compare the data for two records and return the relationship.
//*****************************************************************************
int StgRecordManager::CompareRecords(	// -1, 0, 1
	STGCOLUMNDEF *pColDef,				// Where to find key data.
	STGRECORDHDR *pRecord1,				// First record.
	STGRECORDHDR *pRecord2)				// Second record.
{
	ULONG		iLen1;					// Length of first record.
	ULONG		iLen2;					// Length of second record.
	BYTE		*pData1;				// Working pointer for data.
	BYTE		*pData2;				// Working pointer for data.
	int			iCmp;					// Comparison value.

	// Get the pointer to the data for each column.
	VERIFY(pData1 = GetColCellData(pColDef, pRecord1, &iLen1));
	VERIFY(pData2 = GetColCellData(pColDef, pRecord2, &iLen2));

	// For fixed data, simply compare it.
	if (IsFixedType(pColDef->iType) || pColDef->iType == DBTYPE_OID)
	{
		iCmp = CmpData(pColDef->GetSafeType(), pData1, pData2);
	}
	// For variable data, more work is involved.
	else
	{
		// If the lengths do not match, then it is clearly not the same.
		//@todo: is this right?  it would sort "z" before "abc" only based
		// on length.  Plus we are not doing collating sequence here.
		if (iLen1 < iLen2)
			iCmp = -1;
		else if (iLen1 > iLen2)
			iCmp = 1;
		else
			iCmp = memcmp(pData1, pData2, iLen1);
	}
	return (iCmp);
}


//*****************************************************************************
// Compare a record to the key data value given by caller.
//*****************************************************************************
int StgRecordManager::CompareRecordToKey( // -1, 0, 1
	STGCOLUMNDEF *pColDef,				// Column description.
	STGRECORDHDR *pRecord,				// Record to compare to key.
	DBBINDING	*pBinding,				// Binding for column.
	BYTE		*pData,					// User data.
	DBCOMPAREOP	fCompare)				// Comparison operator.
{
	ULONG		iLen;					// Length for variable data.
	BYTE		*pRecordData;			// Working pointer for data.
	int			iCmp;					// Compare value.

	// This code only supports equality and prefix searches.  Not that it 
	// couldn't do more, but other types against an index are a little weird
	// since we don't have a b-tree index.
	_ASSERTE(SafeCompareOp(fCompare) != DBCOMPAREOPS_IGNORE || SafeCompareOp(fCompare) != DBCOMPAREOPS_NE);

	// Special case OID for really fast comparison.  This means making fewer
	// function calls with less total cycles.  Very common scenario.
	if (fCompare == DBCOMPAREOPS_EQ && pColDef->iType == DBTYPE_OID)
	{
		// Retrieve the column data from the record and the user's buffer.
		void *pbCell = FindColCellOffset(pColDef, pRecord);
		void *pbUser = DataPart(pData, pBinding);

		// Compare the two items.
		if (pColDef->iSize == sizeof(USHORT))
			iCmp = CompareNumbersEq(*(USHORT *) pbCell, *(USHORT *) pbUser);
		else
			iCmp = CompareNumbersEq(*(ULONG *) FindColCellOffset(pColDef, pRecord), 
					*(ULONG *) pbUser);
		goto ErrExit;
	}

	// Get the pointer to the data for each column.
	VERIFY(pRecordData = GetColCellData(pColDef, pRecord, &iLen));

	// Equality compares are very easy.
	if (SafeCompareOp(fCompare) == DBCOMPAREOPS_EQ )
	{
		if ( fCompare & DBCOMPAREOPS_CASEINSENSITIVE )
		{	//special case for case insensitive string compare
			_ASSERTE( pColDef->GetSafeType() == DBTYPE_WSTR );
			iCmp = Wszlstrcmpi( (LPCWSTR)pRecordData, (LPCWSTR)DataPart(pData, pBinding) );
		}
		else
		{
			// For fixed data, simply compare it.
			if (IsFixedType(pColDef->GetSafeType()))
				iCmp = CmpData(pColDef->GetSafeType(), pRecordData, 
					DataPart(pData, pBinding)); 
			// For variable data, lengths are required.
			else
				iCmp = CmpData(pColDef->iType, pRecordData, 
						DataPart(pData, pBinding), 
						iLen, 
						LengthPart(pData, pBinding));
		}
	}
	// Begins with require the expression filter code.
	else
	{
		// Need to get the correct type of data.  Map WSTR into the heap type.
		DBTYPE		iType = pColDef->GetSafeType();

		// Do the expression.
		// 0 means compare result is true, 1 means false.
		if (CompareData(iType, pRecordData, iLen, pBinding, pData, fCompare))
			iCmp = 0;
		else
			iCmp = 1;
	}

ErrExit:
	return (iCmp);
}

#if _MSC_VER < 1200
#ifndef _WIN64
typedef ULONG   DBBYTEOFFSET;
#endif
#endif

//*****************************************************************************
// Create a set of bindings for the given record and columns.  This is a
// convient way to bind to an existing record.
//*****************************************************************************
HRESULT StgRecordManager::GetBindingsForColumns(// Return code.
	STGTABLEDEF	*pTableDef,				// The table definition.
	STGRECORDHDR *psRecord,				// Record to use for binding.
	int			iColumns,				// How many columns.
	BYTE		rColumns[],				// Column numbers.
	DBBINDING	rgBindings[],			// Array to fill out.
	PROVIDERDATA rgData[])				// Data pointer.
{
	STGCOLUMNDEF *pColDef;				// Column definition.
	DBBINDING	*pBinding;				// Walk list of items.
	PROVIDERDATA *pData;				// Walk list of data.
	int			i;						// Loop control.

	// Clear out any bogus data.
	memset(&rgBindings[0], 0, sizeof(DBBINDING) * iColumns);
	DEBUG_STMT(memset(&rgData[0], 0xcd, sizeof(PROVIDERDATA) * iColumns));

	// Walk each key column and set up a binding to that data.
	for (i=0, pBinding=&rgBindings[0], pData=&rgData[0];  
			i<iColumns;  i++, pBinding++, pData++)
	{
		// Load the column definition for this key.
		VERIFY(pColDef = pTableDef->GetColDesc(rColumns[i] - 1));

		// Binding to a variant is tricky business which we don't do.
		_ASSERTE(pColDef->iType != DBTYPE_VARIANT);

		// Fill out default data.
		pBinding->iOrdinal = pColDef->iColumn;		
		pBinding->wType = pColDef->iType | DBTYPE_BYREF;
	
		pBinding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		pBinding->eParamIO = DBPARAMIO_NOTPARAM;

		pBinding->obValue = (DBBYTEOFFSET)((UINT_PTR) &pData->pData - (UINT_PTR) &rgData[0]);	
		pBinding->obLength = (DBBYTEOFFSET)((UINT_PTR) &pData->iLength - (UINT_PTR) &rgData[0]);
		pBinding->obStatus = (DBBYTEOFFSET)((UINT_PTR) &pData->iStatus - (UINT_PTR) &rgData[0]);
		pBinding->cbMaxLen = pColDef->iSize;

		pBinding->dwPart = DBPART_VALUE | DBPART_STATUS;

		// Fixed types only use the data value.
		if (IsNonPooledType(pColDef->iType))
		{
			// If the column has the null value, no data.
			if (pColDef->IsNullable() && 
					GetCellNull(psRecord, pColDef->iColumn - 1, pTableDef))
				pData->iStatus = DBSTATUS_S_ISNULL;
			// Else get the data for the column.
			else
			{
				pData->pData = FindColCellOffset(pColDef, psRecord);
				pData->iStatus = S_OK;
			}
			pData->iLength = 0;
		}
		// Variable values need to be retrieve through their pool.
		else
		{
			ULONG		iOffset;

			pBinding->dwPart |= DBPART_LENGTH;
			pData->iStatus = S_OK;

			// Get the offset of the string data, check for null.
			iOffset = GetOffsetForColumn(pColDef, psRecord);
			if (pColDef->iSize == sizeof(USHORT) && iOffset == 0xffff)
				iOffset = 0xffffffff;

			// If the value is null, set status.
			if (iOffset == 0xffffffff)
			{
				pData->pData = 0;
				pData->iLength = 0;
				pData->iStatus = DBSTATUS_S_ISNULL;
			}
			// For string, get pointer and length.
			else if ((pBinding->wType & ~DBTYPE_BYREF) == DBTYPE_WSTR)
			{
				if ((pData->pData = (void *) m_pSchema->GetStringPool()->GetString(
						iOffset)) == 0)
					return (PostError(E_UNEXPECTED));
				pData->iLength = (ULONG) wcslen((LPCWSTR) pData->pData)*sizeof(WCHAR);
			}
			// GUID code comes from that pool.
			else if ((pBinding->wType & ~DBTYPE_BYREF) == DBTYPE_GUID)
			{
				if ((pData->pData = (void *) m_pSchema->GetGuidPool()->GetGuid(
						iOffset)) == 0)
					return (PostError(E_UNEXPECTED));
				pData->iLength = sizeof(GUID);
			}
			// Blob has length encoded.
			else
			{
				ULONG		iLen;
				if ((pData->pData = m_pSchema->GetBlobPool()->GetBlob(
						iOffset, &iLen)) == 0)
					return (PostError(E_UNEXPECTED));
				pData->iLength = iLen;
			}
		}
	}
	return (S_OK);
}


//*****************************************************************************
// Create a set of bindings that match the input values, but convert any
// data that doesn't match the stored type.  This allows the record compare
// code to do natural comparisons.
//*****************************************************************************
HRESULT StgRecordManager::GetBindingsForLookup( // Return code.
	ULONG		iColumns,				// How many columns.
	const DBBINDING	rgBinding[],		// The from bindings.
	const void *pUserData,				// User's data.
	DBBINDING	rgOutBinding[],			// Return bindings here.
	PROVIDERDATA rgData[],				// Setup byref data here.
	void		*rgFree[])				// Record to-be-freed here.
{
	STGCOLUMNDEF *pColDef;				// Definition of each column.
	DBBINDING	*pBinding;				// Ptr lookup.
	PROVIDERDATA *pData;				// Ptr lookup.
	ULONG		i;						// Loop control.

	// Convert each item.
	for (i=0, pBinding=&rgOutBinding[0], pData=&rgData[0];  i<iColumns;  
			i++, pBinding++, pData++)
	{
		// Copy all parts of the binding.
		*pBinding = rgBinding[i];

		// Load the column definition for this key.
		VERIFY(pColDef = m_pTableDef->GetColDesc((int) (rgBinding[i].iOrdinal - 1)));

		// Fill out default data.
		if (pColDef->iType != DBTYPE_WSTR)

			pBinding->wType = pColDef->iType | DBTYPE_BYREF;
		else
			pBinding->wType = DBTYPE_STR | DBTYPE_BYREF;
		pBinding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		pBinding->eParamIO = DBPARAMIO_NOTPARAM;

		pBinding->obValue = (DBBYTEOFFSET)((UINT_PTR) &pData->pData - (UINT_PTR) &rgData[0]);
		pBinding->obLength = (DBBYTEOFFSET)((UINT_PTR) &pData->iLength - (UINT_PTR) &rgData[0]);
		pBinding->obStatus = (DBBYTEOFFSET)((UINT_PTR) &pData->iStatus - (UINT_PTR) &rgData[0]);
		pBinding->cbMaxLen = pColDef->iSize;

		// If the given value matches already, just use the data.
		if ((rgBinding[i].wType & ~DBTYPE_BYREF) == (pBinding->wType & ~DBTYPE_BYREF))
		{
			// We always want a byref copy of your data.
			if (rgBinding[i].wType & DBTYPE_BYREF)
				pData->pData = DataPart((BYTE *) pUserData, &rgBinding[i]);
			else
				pData->pData = *(void **) DataPart((BYTE *) pUserData, &rgBinding[i]);

			// Copy the length and status if there.
			if (rgBinding[i].dwPart & DBPART_LENGTH)
				pData->iLength = LengthPart((BYTE *) pUserData, &rgBinding[i]);
			if (rgBinding[i].dwPart & DBPART_STATUS)
				pData->iStatus = StatusPart((BYTE *) pUserData, &rgBinding[i]);
		}
		// A conversion is needed.
		else
		{
			ULONG			cbSrcLength;
			void			*pDstData;
			HRESULT			hr;

			// What type do we want after conversion.
			switch (pBinding->wType & ~DBTYPE_BYREF)
			{
				// These types will fit into a 4 byte pointer, so double team 
				// the memory.
				case DBTYPE_I2:
				case DBTYPE_I4:
				case DBTYPE_R4:
				case DBTYPE_CY:
				case DBTYPE_DATE:
				case DBTYPE_BOOL:
				case DBTYPE_UI1:
				case DBTYPE_I1:
				case DBTYPE_UI2:
				case DBTYPE_UI4:
				case DBTYPE_OID:
				pDstData = &pData->pData;
				pBinding->wType &= ~DBTYPE_BYREF;
				break;

				// These fixed types are too big and will require memory
				// to be allocated.
				case DBTYPE_R8:
				case DBTYPE_I8:
				case DBTYPE_UI8:
				case DBTYPE_GUID:
				case DBTYPE_DBDATE:
				case DBTYPE_DBTIME:
				case DBTYPE_DBTIMESTAMP:
				if ((pData->pData = rgFree[i] = malloc(pBinding->cbMaxLen)) == 0)
					return (PostError(OutOfMemory()));
				pDstData = pData->pData;
				break;

				// These variable types are too big and will require memory.
				case DBTYPE_BYTES:
				case DBTYPE_STR:
				if ((rgBinding[i].wType & ~DBTYPE_BYREF) != DBTYPE_STR &&
					(rgBinding[i].wType & ~DBTYPE_BYREF) != DBTYPE_BYTES)
				{
					pBinding->cbMaxLen = LengthPart((BYTE *) pUserData, &rgBinding[i]) + 1;
					pBinding->cbMaxLen = ALIGN4BYTE(pBinding->cbMaxLen);
				}
				else
					pBinding->cbMaxLen = DEFAULT_CVT_SIZE;
				if ((pData->pData = rgFree[i] = malloc(pBinding->cbMaxLen)) == 0)
					return (PostError(OutOfMemory()));
				pDstData = pData->pData;
				break;

				case DBTYPE_WSTR:
				default:
				_ASSERTE(0);
				return (PostError(DB_E_CANTCONVERTVALUE, pBinding->iOrdinal));
			}

			// Get length of source data.
			if (rgBinding[i].dwPart & DBPART_LENGTH)
				cbSrcLength = LengthPart((BYTE *) pUserData, &rgBinding[i]);
			else
				cbSrcLength = pColDef->iSize;

			// Now let them do the real conversion for us.
			if (FAILED(hr = DataConvert(
					rgBinding[i].wType & ~DBTYPE_BYREF, pBinding->wType & ~DBTYPE_BYREF, 
					cbSrcLength, &pData->iLength,
					DataPart((BYTE *) pUserData, &rgBinding[i]), pDstData, 
					(ULONG)pBinding->cbMaxLen,
					S_OK, &pData->iStatus, 
					0, 0, DBDATACONVERT_DEFAULT)))
				return (hr);
		}
	}
	return (S_OK);
}



//
//
// Query handlers.
//
//


//*****************************************************************************
// Search a primary key index for the record in question.  This function can
// only be called in read only mode because it relies on the records being
// sorted by primary key order.  In read/write mode, this cannot be guaranteed
// and therefore a dynamic hashed index is automatically created on behalf of
// the user.
//*****************************************************************************
HRESULT StgRecordManager::QueryRowByPrimaryKey(	// CLDB_E_RECORD_NOTFOUND or return code.
	STGCOLUMNDEF *pColDef,				// For single column pk.
	IStgIndex	*pIndex,				// For multiple column pk.
	DBCOMPAREOP	fCompare,				// Comparison operator.
	DBBINDING	rgBindings[],			// Bindings for user data to comapre.
	ULONG		cBindings,				// How many bindings are there.
	void		*pbData,				// User data for compare.
	STGRECORDHDR **ppRecord)			// Return record here if found.
{
	STGRECORDHDR *pRecord;				// The record to compare against.
	int			iCmp;					// Comparison of record to key.
	int			iFirst, iLast, iMid;	// Loop control.

	// Verify read only mode, see header.
	_ASSERTE(m_pDB->IsReadOnly());

	// Must have either column def or index for pk, but not both.
	_ASSERTE(pColDef || pIndex);
	_ASSERTE(!(pColDef && pIndex));

	// Only equality and begins with can appear in a pk search.
	_ASSERTE(SafeCompareOp(fCompare) == DBCOMPAREOPS_EQ || SafeCompareOp(fCompare) == DBCOMPAREOPS_BEGINSWITH);

	// The assumption is that one can only do a pk search on records when
	// in read mode, because in write mode you need a separate transient
	// index to track the records.  Because of this there can only be
	// one heap to bin search and therefore much faster seeking to records.
	_ASSERTE(m_RecordHeap.pNextHeap == 0);

	// Avoid confusion.
	*ppRecord = 0;

	// Set up boundaries for search.
	iFirst = 0;
	iLast = m_RecordHeap.Count() - 1;

	// If it is a single column query, then the comparison is much simpler.
	if (pColDef)
	{
		_ASSERTE(pColDef->IsPrimaryKey());

		if((pColDef->fFlags & CTF_CASEINSENSITIVE) && DBTYPE_WSTR==pColDef->GetSafeType())
			fCompare |= DBCOMPAREOPS_CASEINSENSITIVE; 

		// Scan the list in halfs.
		while (iFirst <= iLast)
		{
			iMid = (iLast + iFirst) / 2;
			
			VERIFY(pRecord = (STGRECORDHDR *) m_RecordHeap.VMArray.Get(iMid));
			iCmp = CompareRecordToKey(pColDef, pRecord, &rgBindings[0], 
					(BYTE *) pbData, fCompare);

			// If the record comes before the value, we need to go to the right.
			if (iCmp > 0)
				iLast = iMid - 1;
			// If the record comes after the value, we go left.
			else if (iCmp < 0)
				iFirst = iMid + 1;
			// Otherwise we found it.
			else
			{
				// Delete records are taken out of indexes and therefore should
				// never be seen in this code path.
				_ASSERTE((m_rgRecordFlags.GetFlags(IndexForRecordPtr(pRecord)) & RECORDF_DEL) == 0);

				// Return the record to the caller.
				*ppRecord = pRecord;
				return (S_OK);
			}
		}
	}
	// Else the search has to consider all columns in the data.
	else
	{
		//@future:  Hook up b-search on records with multiple keys.  version 1
		// uses a unique hashed index instead.
		_ASSERTE(!"Multi-column b-search is not in '98");
	}

	// Didn't find the record, so tell caller.
	return (CLDB_E_RECORD_NOTFOUND);

}


//*****************************************************************************
// Compare a record against a set of comparison operators.  If the record meets
// all of the criteria given, then the function returns S_OK.  If the record
// does not match all criteria, then the function returns S_FALSE.
//*****************************************************************************
HRESULT StgRecordManager::QueryFilter(	// S_OK record is match, S_FALSE it isn't.
	STGRECORDHDR *pRecord,				// Record to check against filter.
	ULONG		cBindings,				// How many bindings to check.
	DBBINDING	rgBindings[],			// Bindings to use for compare.
	void		*pbData,				// User data for comparison.
	DBCOMPAREOP	rgfCompares[])			// Comparison operator.
{
	STGCOLUMNDEF *pColDef;				// Column definition.
	DBSTATUS	dbStatus;				// Status for column.
	RECORDID	RecordID;				// For RID column compares.
	BYTE		*pCellData;				// Data for a given column.
	OID			oidcmp;					// OID for filter lookups.
	ULONG		cbLen;					// Length of source data.
	ULONG		i;						// Loop control.
	DBTYPE		iType;					// Data type for compare.
	DBCOMPAREOP	fCompare;

	// Verify the input.
	_ASSERTE(pRecord && cBindings > 0 && rgBindings && pbData && rgfCompares);

	// Do not call QueryFilter on a deleted record, it will not check for this.
	_ASSERTE((m_rgRecordFlags.GetFlags(IndexForRecordPtr(pRecord)) & RECORDF_DEL) == 0);

	// Never work on a record that isn't in the heap.
	_ASSERTE(m_RecordHeap.IndexForRecord(pRecord) != ~0);

	// Check each value given by the caller for equality.
	for (i=0;  i<cBindings;  i++)
	{
		// Skip filters marked as ignore.
		if (rgfCompares[i] == DBCOMPAREOPS_IGNORE)
			continue;

		// Load the column definition.
		VERIFY(pColDef = m_pTableDef->GetColDesc((int) (rgBindings[i].iOrdinal - 1)));

		// Get the status value, if bound.
		if (rgBindings[i].dwPart & DBPART_STATUS)
		{
			dbStatus = StatusPart((BYTE *) pbData, &rgBindings[i]);

			// Don't scan for nulls on a non-nullable column.
			_ASSERTE(!(dbStatus == DBSTATUS_S_ISNULL && !pColDef->IsNullable()));
		}
		else
			dbStatus = S_OK;

		// If the column is nullable, and the caller bound a status value to check for,
		// then see if the record is a match for that criteria.
		if (dbStatus == DBSTATUS_S_ISNULL)
		{
			bool bIsNull = GetCellNull(pRecord, (int) (rgBindings[i].iOrdinal - 1));

			// "c1 is null", for this to be true, both values must match.
			if (rgfCompares[i] == DBCOMPAREOPS_EQ)
			{
				if (!bIsNull)
					return (S_FALSE);
			}
			// "c1 not null", if both are the same, it doesn't match.
			else if (rgfCompares[i] == DBCOMPAREOPS_NE)
			{
				if (bIsNull)
					return (S_FALSE);
			}
			// No other comparison operators make sense on the null value.
			else
			{
				_ASSERTE(!"Invalid null comparison query value!");
				return (E_INVALIDARG);
			}

			// A NULL check is all we can do to check this criteria.
			continue;
		}

		// Checking for null status.  If the cell is null, it can't match unless the comparison operator
		// is NE.
		if (pColDef->IsNullable() && GetCellNull(pRecord, (int) (rgBindings[i].iOrdinal -1)))
		{	//Fix for bug 11390
			if ( rgfCompares[i] != DBCOMPAREOPS_NE)
				return (S_FALSE);
			
			continue;
		}

		// Get the data for the given cell.
		if (!pColDef->IsRecordID())
        {
			VERIFY(pCellData = GetColCellData(pColDef, pRecord, &cbLen));
        }// For a record id, need to convert into a real value with storage.
		else
		{
			RecordID = GetRecordID(pRecord);
			pCellData = (BYTE *) &RecordID;
			cbLen = sizeof(RECORDID);
		}

		fCompare = rgfCompares[i];
		// Get the data type.  
		switch (pColDef->iType)
		{	//For Case Insensitive WSTR column, add DBCOMPAREOPS_CASEINSENSITIVE modifier
			case DBTYPE_WSTR:
			iType = DBTYPE_WSTR;
			if (pColDef->fFlags & CTF_CASEINSENSITIVE )
				fCompare |= DBCOMPAREOPS_CASEINSENSITIVE;
			break;

			// Change an OID into a 4 byte ULONG to make comparisons the same always.
			case DBTYPE_OID:
			if (pColDef->iSize == sizeof(short))
				oidcmp = (ULONG) *(USHORT *) pCellData;
			else
				oidcmp = *(ULONG *) pCellData;
			pCellData = (BYTE *) &oidcmp;
			cbLen = sizeof(ULONG);
			iType = DBTYPE_UI4;
			break;

			default:
			iType = pColDef->GetSafeType();
		}

		// For fixed type equality, just memcmp which is way faster.
		if (fCompare == DBCOMPAREOPS_EQ && IsNonPooledType(pColDef->iType))
		{
			if (memcmp(pCellData, DataPart((BYTE *) pbData, &rgBindings[i]), 
						cbLen) != 0)
				return (S_FALSE);
		}
		// If the data does not compare successfully, then check no other values.
		else if (!CompareData(iType, pCellData, cbLen,
				&rgBindings[i], (BYTE *) pbData, fCompare))
		{
			return (S_FALSE);
		}
	}

	// If all filter values have been checked, then it is a match.
	return (S_OK);
}


//*****************************************************************************
// Scan all (non-deleted) records in the table looking for matches.  If there
// are already records in the cursor, they are skipped by this code to avoid
// extra comparisons.  All data types must match the table definition.
//
// If iMaxRecords is not -1, then the scan quits after iMaxRecords new records
// have been found.  This is useful for the case where a unique index exists but
// is not persisted; if you find one row in this case, there won't be more so
// don't bother looking for them.  It can also be used to implement 
//*****************************************************************************
HRESULT StgRecordManager::QueryTableScan( // Return code.
	CFetchRecords *pFetchRecords,		// Return list of records here.
	ULONG		cBindings,				// How many bindings for user data.
	DBBINDING	rgBinding[],			// Binding data.
	void		*pbData,				// User data for bindings.
	DBCOMPAREOP	rgfCompare[],			// Comparison operators.
	long		iMaxRecords)			// Max rows to add, -1 to do all.
{
	RECORDHEAP	*pHeap;					// Heap pointer.
	ULONG		RecordIndex=0;			// 0 based index through all heaps.
	ULONG		LocalRecordIndex;		// 0 based index in current heap.
	STGRECORDHDR *pRecord;				// Record to compare to.
	RECORD		*pNewRecord;			// Wasted space.
	ULONG		iFetched;				// How many items already in cursor.
	HRESULT		hr = S_OK;

	// Remember how many records there are to begin with.  If there are none,
	// then there is not reason to look for duplicates.
	iFetched = pFetchRecords->Count();

	// Walk through each record heap.
	for (pHeap=&m_RecordHeap;  pHeap;  pHeap=pHeap->pNextHeap)
	{
		// Get first record in this heap.
		VERIFY(pRecord = (STGRECORDHDR *) pHeap->VMArray.Get(0));

		// Scan each record in the current heap.
		for (LocalRecordIndex=0;  LocalRecordIndex<pHeap->VMArray.Count();  
					LocalRecordIndex++, RecordIndex++)
		{
			_ASSERTE(pHeap->IndexForRecord(pRecord) != ~0);

			// Check for deleted records and discard them.
			if (m_rgRecordFlags.GetFlags(RecordIndex) & RECORDF_DEL)
				goto NextRecord;

			// Only work on the record if it is not already in the cursor.
			if (iFetched && pFetchRecords->FindRecord(pRecord, RecordIndex) != 0xffffffff)
				goto NextRecord;

			// If we are filtering, check the record to see if it is a match.
			if (cBindings)
			{
				hr = QueryFilter(pRecord, cBindings, rgBinding, pbData, rgfCompare);
				if (hr != S_OK)
					goto NextRecord;
			}

			// Add the record to the list.
			if (FAILED(hr = pFetchRecords->AddRecordToRowset(pRecord, &RecordIndex, pNewRecord)))
				break;

			// If we got enough records, we can leave.
			if (iMaxRecords != -1 && pFetchRecords->Count() >= (ULONG) iMaxRecords)
				break;

			// Move to next record.
NextRecord:
			pRecord = (STGRECORDHDR *) ((UINT_PTR) pRecord + m_pTableDef->iRecordSize);
		} // Loop through records in the current heap.
	} // Loop through the heaps.

	// Make sure to change false into success.
	if (hr == S_FALSE)
		hr = S_OK;
	return (hr);
}




//
//
// Index handling.
//
//

//*****************************************************************************
// Finds a good index to look for the given columns.
//*****************************************************************************
IStgIndex *StgRecordManager::ChooseIndex(// The index to best answer the question.
	USHORT		iKeyColumns,			// How many columns.
	DBBINDING	rgKeys[],				// The data for the key.
	bool		*pbIsUIndexed)			// true if there is a unique index.
{
	STGINDEXDEF	*pIndexDef;				// Index descriptions.
	BYTE		*piKey;					// List of keys for this index.
	bool		bMatch;					// Loop control.
	int			i, j, k;				// Loop control.

	// Don't call if you don't have a filter.
	_ASSERTE(iKeyColumns > 0);

	// Avoid confusion.
	if (pbIsUIndexed)
		*pbIsUIndexed = false;

	// Walk the list of indexes looking for one that can handle this request.
	for (i=0, k=0;  i<m_pTableDef->iIndexes;  i++)
	{
		// Get the index description.
		VERIFY(pIndexDef = m_pTableDef->GetIndexDesc(i));

		// If the index is not whole, then we can never use it.
		if (IsDirty() && (pIndexDef->fFlags & DEXF_DEFERCREATE))
			continue;

		// Figure out if a table scan is required.
		piKey = &pIndexDef->rgKeys[0];
		for (j=0, bMatch=true;  j<iKeyColumns;  j++)
		{
			if (*piKey++ != rgKeys[j].iOrdinal)
			{
				bMatch = false;
				break;
			}
		}

		// If we never built this index, then don't try to use it.
		if (bMatch && (pIndexDef->fFlags & DEXF_INCOMPLETE))
		{
			// If the index is unique, then tell caller who might want
			// to optimize a scan if a real index is not found.
			//@todo: Make unique check a bit flag, to handle new unique index types in future.
			if (pbIsUIndexed && (pIndexDef->fFlags & DEXF_UNIQUE))
				*pbIsUIndexed = true;

			// This index is incomplete and therefore cannot be used.
			bMatch = false;
			continue;
		}

		// When we get a match, we're done.		
		if (bMatch)
			return (m_rpIndexes[k]);
		
		// Only count an index which is built.
		if (m_rpIndexes.Count() > k && 
				pIndexDef->iIndexNum == m_rpIndexes[k]->GetIndexDef()->iIndexNum)
			++k;
	}
	return (0); 
}


//*****************************************************************************
// For each index described in the header, create an index for each.
//*****************************************************************************
HRESULT StgRecordManager::LoadIndexes()	// Return code.
{
	STGINDEXDEF	*psIndexDef;			// Index descriptions.
	IStgIndex	**ppIndex;				// For adding to array.
	int			i=0;					// Loop control.
	HRESULT		hr=S_OK;

	// Check for case where there are none.
	if (m_pTableDef->iIndexes == 0)
		return (S_OK);

	// Walk each index and create one for it.
	for (;  i<m_pTableDef->iIndexes;  i++)
	{
		// Get the index description.
		VERIFY((psIndexDef = m_pTableDef->GetIndexDesc(i)) != 0);
		_ASSERTE((BYTE *) psIndexDef > (BYTE *) m_pTableDef);

		// Find room for the new index pointer.
		if ((ppIndex = m_rpIndexes.Append()) == 0)
		{
			hr = PostError(OutOfMemory());
			goto ErrExit;
		}

		// Create a new index object and open it.
		if (IT_SORTED == psIndexDef->fIndexType)
		{
			*ppIndex = new StgSortedIndex;
		}
		// The only other option is IT_HASHED
		else 
		{
			*ppIndex = new StgHashedIndex;
		}

		if (!*ppIndex)
		{
			hr = PostError(OutOfMemory());
			goto ErrExit;
		}
		(*ppIndex)->AddRef();

		if (FAILED(hr = (*ppIndex)->Open(((UINT_PTR) psIndexDef - (UINT_PTR) m_pTableDef), 
					this, &m_RecordHeap, 0xffffffff, 0, 0)))
		{
			goto ErrExit;
		}
	}

ErrExit:
	// Cleanup any allocated objects on an error.
	if (FAILED(hr))
	{
		for (i=0;  i<m_rpIndexes.Count();  i++)
		{
			if (m_rpIndexes[i])
				m_rpIndexes[i]->Release();
		}
		m_rpIndexes.Clear();
	}
	return (hr);
}


//*****************************************************************************
// This version will create an index only for those items that were persisted
// in the stream.  Others are not even loaded.
//*****************************************************************************
HRESULT StgRecordManager::LoadIndexes(	// Return code.
	STGTABLEDEF	*pTableDef,				// The table definition we're loading.
	ULONG		iRecords,				// How many records are there.
	int			iIndexes,				// How many saved to disk.
	STGINDEXHDR	*pIndexHdr)				// The first index for the table.
{
	STGINDEXDEF	*pIndexDef;				// Index descriptions.
	IStgIndex	**ppIndex;				// For adding to array.
	ULONG		cbIndexSize;			// Size of each index while searching.
	HRESULT		hr;

	// Walk each index and create one for it.
	for (int i=0;  i<pTableDef->iIndexes;  i++)
	{
		_ASSERTE(!pIndexHdr || pIndexHdr->rcPad[0] == MAGIC_INDEX);

		// Get the index description.
		VERIFY((pIndexDef = pTableDef->GetIndexDesc(i)) != 0);

		// Check for read only user schema, which we don't touch.
		if ((m_fFlags & SRM_WRITE) == 0 && !pTableDef->IsCoreTable())
			continue;

		// If the index was not persisted, update flags.
		if ((((m_fFlags & SRM_WRITE) == 0) && !iIndexes) || 
				!pIndexHdr || 
				pIndexDef->iIndexNum != pIndexHdr->iIndexNum)
		{
			pIndexDef->fFlags |= DEXF_INCOMPLETE;
			continue;
		}

		// Overwrite the configurable settings based on persisted data.
		if (pIndexHdr)
			pIndexDef->fFlags = pIndexHdr->fFlags;
		
		// Find room for the new index pointer.
		if ((ppIndex = m_rpIndexes.Append()) == 0)
			return (PostError(OutOfMemory()));

		// Create a new index object and open it.
		if (IT_SORTED == pIndexDef->fIndexType)
			*ppIndex = new StgSortedIndex;
		else 
		{
			// for the moment only other type available is IT_HASHED
			if (pIndexHdr)
				pIndexDef->HASHDATA.iBuckets = pIndexHdr->iBuckets;
			*ppIndex = new StgHashedIndex;
		}

		if (0 == *ppIndex)
			return (PostError(OutOfMemory()));
		(*ppIndex)->AddRef();

		if (FAILED(hr = (*ppIndex)->Open(((UINT_PTR) pIndexDef - (UINT_PTR) pTableDef), 
				this, &m_RecordHeap, iRecords, pIndexHdr, &cbIndexSize)))
			return (hr);

		// The next index will be at cbIndexSize bytes past the current header,
		// if there is one.
		if (pIndexHdr && pIndexDef->iIndexNum == pIndexHdr->iIndexNum && --iIndexes)
		{
			pIndexHdr = (STGINDEXHDR *) ((BYTE *) pIndexHdr + cbIndexSize);
		}

		if (!iIndexes)
		{
			// to stop the loop
			pIndexHdr = NULL;		
		}
	
	}
	return (S_OK);
}	


//*****************************************************************************
// Return the loaded index for a definition if there is one.
//*****************************************************************************
IStgIndex *StgRecordManager::GetLoadedIndex( // Loaded index, if there is one.
	STGINDEXDEF *pIndexDef)				// Which one do you want.
{
	for (int i=0;  i<m_rpIndexes.Count();  i++)
	{
		if (m_rpIndexes[i]->GetIndexDef()->iIndexNum == pIndexDef->iIndexNum)
			return (m_rpIndexes[i]);
	}
	return (0);
}


//*****************************************************************************
// Look through the index definitions in this table and find the given name.
//*****************************************************************************
STGINDEXDEF *StgRecordManager::GetIndexDefByName( // The def if found.
	LPCWSTR		szIndex)				// Name to find.
{
	STGINDEXDEF	*pIndexDef;				// Each definition.
	int			i;						// Loop control.
	LPCWSTR		szName;					// Heap lookups.

	// Don't waste any time if there aren't any.
	if (!m_pTableDef->iIndexes)
		return (0);

	// Walk each index.
	pIndexDef = m_pTableDef->GetIndexDesc(0);
	for (i=m_pTableDef->iIndexes;  i;  )
	{
		// Get the name from the heap, no copy required.
		szName = m_pSchema->pNameHeap->GetString(pIndexDef->Name);
		_ASSERTE(szName && wcslen(szName) < MAXINDEXNAME);
		
		// If the names are the same, we've found it.
		if (SchemaNameCmp(szName, szIndex) == 0)
			return (pIndexDef);

		// Go get the next one.
		if (--i)
			pIndexDef = pIndexDef->NextIndexDef();
	}
	return (0);
}





//
//
// Event signalers.
//
//

//*****************************************************************************
// Tell every index that an insert has taken place.
//*****************************************************************************
HRESULT StgRecordManager::SignalAfterInsert(// Return status.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// The record that was inserted.
	CIndexList	*pIndexList,			// List of indexes to modify.
	int			bCheckDupes)			// true to enforce duplicates.
{
	HRESULT		hr;

	// If we are not building indexes, then don't bother.
	if (m_bSignalIndexes == false)
		return (S_OK);

	if (!pIndexList)
	{
		for (int i=0;  i<m_rpIndexes.Count();  i++)
			if (FAILED(hr = m_rpIndexes[i]->AfterInsert(
						m_pTableDef, RecordID, psRecord, bCheckDupes)))
				return (hr);
	}
	else
	{
		for (int i=0;  i<pIndexList->Count();  i++)
			if (FAILED(hr = pIndexList->Get(i)->AfterInsert(
						m_pTableDef, RecordID, psRecord, bCheckDupes)))
				return (hr);
	}
	return (S_OK);
}


//*****************************************************************************
// Called after a row is deleted from a table.  The index must update itself
// to reflect the fact that the row is gone.
//*****************************************************************************
HRESULT StgRecordManager::SignalAfterDelete(// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// The record to delete.
	CIndexList	*pIndexList)			// List of indexes to modify.
{
	HRESULT		hr = S_OK;

	// If we are not building indexes, then don't bother.
	if (m_bSignalIndexes == false)
		return (S_OK);

	for (int i=0;  i<m_rpIndexes.Count();  i++)
	{
		hr = m_rpIndexes[i]->AfterDelete(pTableDef, RecordID, psRecord);
		
		if (SUCCEEDED(hr))
		{
			if (hr == S_OK && pIndexList && FAILED(hr = pIndexList->Add(m_rpIndexes[i])))
				break;
		}
		else
			break;
	}	
	return (hr);
}


//*****************************************************************************
// Called before an update is applied to a row.  The data for the change is
// included.  The index must update itself if and only if the change in data
// affects the order of the index.
//*****************************************************************************
HRESULT StgRecordManager::SignalBeforeUpdate(// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// Record to be changed.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	HRESULT		hr;

	// If we are not building indexes, then don't bother.
	if (m_bSignalIndexes == false)
		return (S_OK);

	for (int i=0;  i<m_rpIndexes.Count();  i++)
		if (FAILED(hr = m_rpIndexes[i]->BeforeUpdate(pTableDef, RecordID,
				psRecord, iColumns, rgBindings)))
			return (hr);
	return (S_OK);
}

HRESULT StgRecordManager::SignalBeforeUpdate(// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	USHORT		iRecords,				// for bulk operations.
	void		*rgpRecordPtr[],		// The record we inserted.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	HRESULT		hr;
	RECORDID	RecordIndex;

	// If we are not building indexes, then don't bother.
	if (m_bSignalIndexes == false)
		return (S_OK);

	for(int j=0; j<iRecords; j++)
	{
		RecordIndex = m_RecordHeap.IndexForRecord((STGRECORDHDR *)rgpRecordPtr[j]);

		for (int i=0;  i<m_rpIndexes.Count();  i++)
		{
			// BeforeUpdate() in the StgIndexManager already checks to see if that 
			// index needs to be updated.
			if (FAILED(hr = m_rpIndexes[i]->BeforeUpdate(pTableDef, RecordIndex,
				(STGRECORDHDR *) rgpRecordPtr[j], iColumns, rgBindings)))
				return (hr);
		}
	}
	return (S_OK);
}

//*****************************************************************************
// Called after a row has been updated.  This is our chance to update the
// index with the new column data.
//*****************************************************************************
HRESULT StgRecordManager::SignalAfterUpdate(// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// Record to be changed.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	HRESULT		hr;

	// If we are not building indexes, then don't bother.
	if (m_bSignalIndexes == false)
		return (S_OK);

	for (int i=0;  i<m_rpIndexes.Count();  i++)
		if (FAILED(hr = m_rpIndexes[i]->AfterUpdate(pTableDef, RecordID, psRecord,
				iColumns, rgBindings)))
			return (hr);
	return (S_OK);
}

HRESULT StgRecordManager::SignalAfterUpdate(// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	USHORT		iRecords,				// number of records for bulk operations.
	void		*rgpRecordPtr[],		// The record we inserted.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	HRESULT		hr;
	RECORDID	RecordIndex;

	// If we are not building indexes, then don't bother.
	if (m_bSignalIndexes == false)
		return (S_OK);

	for (int j=0; j<iRecords;j++)
	{
		RecordIndex = m_RecordHeap.IndexForRecord((STGRECORDHDR *)rgpRecordPtr[j]);

		for (int i=0;  i<m_rpIndexes.Count();  i++)
		{
			// BeforeUpdate() in the StgIndexManager already checks to see if that 
			// index needs to be updated.
			if (FAILED(hr = m_rpIndexes[i]->AfterUpdate(pTableDef, RecordIndex, 
					(STGRECORDHDR *) rgpRecordPtr[j], iColumns, rgBindings)))
				return (hr);
		}
	}
	return (S_OK);
}


//
//
// Record code.
//
//


//*****************************************************************************
// This function is called with a candidate record to see if it meets the
// criteria set forth.  If it does, then it will be added to the set.
//*****************************************************************************
bool StgRecordManager::RecordIsMatch(	// true if record meets criteria.
	STGRECORDHDR *psRecord,				// Record to compare to.
	DBBINDING	rgBinding[],			// Binding data.
	ULONG		cStartKeyColumns,		// How many key columns to subset on.
	void		*pStartData,			// User data for comparisons.
	ULONG		cEndKeyColumns,			// How many end key columns.
	void		*pEndData,				// Data for end comparsion.
	DBRANGE		dwRangeOptions)			// Matching options.
{
	//@todo: Write this for real, it only handles matches right now, and
	// it doesn't handle data type conversions for comparsion (like ask for WSTR and
	// we only store ANSI str.
	
	STGCOLUMNDEF *pColDef;				// Column definition.
	ULONG		iLen;					// Length of first record.
	ULONG		i;						// Loop control.
	void		*pData;					// Variable sized data.
	int			iCmp;					// Memory compares.

	// Check each value given by the caller for equality.
	for (i=0;  i<cStartKeyColumns;  i++)
	{
		// Load the column definition.
		VERIFY(pColDef = m_pTableDef->GetColDesc((int) (rgBinding[i].iOrdinal - 1)));

		// Check for NULL/not null match.
		if (pColDef->fFlags & CTF_NULLABLE)
		{
			bool bIsNull = GetCellNull(psRecord, (int) (rgBinding[i].iOrdinal - 1));
			if (rgBinding[i].dwPart & DBPART_STATUS)
			{
				if ((StatusPart((BYTE *) pStartData, &rgBinding[i]) == DBSTATUS_S_ISNULL) != bIsNull)
					return (false);
			}
			// No status given and our record is null, can never match.
			else if (bIsNull)
				return (false);
		}

		// Fixed type data is a simple compare.
		if (IsNonPooledType(pColDef->iType))
		{
			ULONG		cb;

			//@todo: what about OID type which is 2 or 4 bytes?
			if (!pColDef->IsRecordID())
				iCmp = memcmp(GetColCellData(pColDef, psRecord, &cb),
					DataPart((BYTE *) pStartData, &rgBinding[i]), pColDef->iSize);
			else
			{
				ULONG		iRecord = GetRecordID(psRecord);
				iCmp = memcmp(&iRecord,
					DataPart((BYTE *) pStartData, &rgBinding[i]), pColDef->iSize);
			}
		}
		// Variable sized data requires more thought.
		//@consider: GUID compare could be a faster special case.
		else
		{
			// Find data and length.
			pData = GetColCellData(pColDef, psRecord, &iLen);

			// Compare the lengths of the two data values.
			if (iLen != LengthPart((BYTE *) pStartData, &rgBinding[i]))
				return (false);
			// If they match, then the values.
			else
				iCmp = memcmp(pData, DataPart((BYTE *) pStartData, &rgBinding[i]), iLen);
		}

		// Check for miscompare on fixed or variable data.
		if (iCmp != 0)
			return (false);
	}
	return (true);
}




//
//
// CFetchRecords
//
//


//*****************************************************************************
// Add a record to the rowset based on the type of cursor storage.
//*****************************************************************************
HRESULT CFetchRecords::AddRecordToRowset( // Return code.
	STGRECORDHDR *psRecord,				// The actual record pointer.
	RECORDID	*pRecordID,				// Record to add.
	RECORD		*&pRecord)				// Return the row handle.
{
	// Delegate for record list case.
	if (m_pRecordList)
		return (m_pRecordList->AddRecordToRowset(pRecordID, pRecord));

	// Don't keep fetching if you run out of room.
	if (m_iFetched + 1 > m_iMaxRecords)
		return (PostError(CLDB_E_RECORD_OVERFLOW));
	m_rgRecords[m_iFetched++] = psRecord;
	return (S_OK);
}


//*****************************************************************************
// Search for the given record in the existing rowset.  Return the index of
// the item if found.
//*****************************************************************************
ULONG CFetchRecords::FindRecord(		// Index if found, -1 if not.
	STGRECORDHDR *psRecord,				// Return to search for.
	RECORDID	RecordID)				// ID of the record.
{
//@todo: Add records to list in sorted order, then b-search here.

	if (m_pRecordList)
	{
		for (int i=0;  i<m_pRecordList->Count();  i++)
		{
			if (RecordID == (*m_pRecordList)[i].RecordID)
				return (i);
		}
	}
	else
	{
		for (ULONG i=0;  i<m_iFetched;  i++)
		{
			if (psRecord == m_rgRecords[i])
				return (i);
		}
	}
	return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgschema.cpp ===
//*****************************************************************************
// StgSchema.cpp
//
// This module contains the hard coded schema for the core information model.
// By having one const version, we avoid saving the schema definitions again
// in each .clb file.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h" 					// Precompiled header.
#include "StgDatabase.h"				// Database header.
#include "StgTiggerStorage.h"			// Storage system.
#include "CoreSchemaExtern.h"			// Extern defines for core schema.




//********** Locals. **********************************************************


//********** Code. ************************************************************



//*****************************************************************************
//
//********** File and schema functions.
//
//*****************************************************************************


//*****************************************************************************
// Add a refernece to the given schema to the database we have open right now
// You must have the database opened for write for this to work.  If this
// schema extends another schema, then that schema must have been added first
// or an error will occur.	It is not an error to add a schema when it was
// already in the database.
//
// Adding a new version of a schema to the current file is not supported in the
// '98 product.  In the future this ability will be added and will invovle a
// forced migration of the current file into the new format.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::SchemaAdd( // Return code.
	const COMPLIBSCHEMABLOB *pUserSchema) // The schema to add.
{
// This is a temporary version to get the schema override code working.
#if 1
	SCHEMADEFS	*pSchemaDef;			// Working pointer.
	int 		iIndex; 				// Index of schema in database.
	int 		bAddToList; 			// true to add to schema list.
	HRESULT 	hr;

	// Verify that arguments are valid, we're in write mode, and the default
	// schemas have already been installed.
	_ASSERTE(pUserSchema);
	_ASSERTE(m_Schemas.Count());

	// Assume failure.
	hr = E_OUTOFMEMORY;

	// Check for a duplicate.
	pSchemaDef = _SchemaFind(pUserSchema->pSchemaID, &iIndex);

	// If the item was found, keep checking.
	if (pSchemaDef)
	{
		// Check for migration path.
		if (pSchemaDef->Version != pUserSchema->pSchemaID->Version)
		{
		//	_ASSERTE(!"Upgrading schemas not supported yet.");
			return (PostError(CLDB_E_SCHEMA_VERMISMATCH));
		}

		// Adding a reference to a schema that is already here is harmless.
		if (pSchemaDef->pSchema)
			return (S_OK);
		bAddToList = false;

		// Allocate a deep copy of the schema so we can add overrides.
		if (IsReadOnly())
		{
			pSchemaDef->pSchema = (STGSCHEMA *) malloc(pUserSchema->cbReadOnly);
			if (pSchemaDef->pSchema)
			{
				memcpy(pSchemaDef->pSchema, pUserSchema->pbReadOnly, pUserSchema->cbReadOnly);

				// Add any core overrides, which includes things like column sizes
				// and layouts that are different than hard coded.
				AddCoreOverrides(pSchemaDef, &m_UserSchema, iIndex, 
						m_iSchemas, m_rgSchemaList);
			}
		}
		else
		{
			pSchemaDef->pSchema = (STGSCHEMA *) malloc(pUserSchema->cbReadWrite);
			if (pSchemaDef->pSchema)
				memcpy(pSchemaDef->pSchema, pUserSchema->pbReadWrite, pUserSchema->cbReadWrite);
		}
		if (!pSchemaDef->pSchema)
			goto ErrExit;

		// Fill the rest of the data in.
		pSchemaDef->fFlags = pUserSchema->fFlags | SCHEMADEFSF_FREEDATA;
	}
	// The schema is a new reference, so add it.
	else
	{
		// Need to create a schema def structure.
		pSchemaDef = new SCHEMADEFS;
		if (!pSchemaDef)
			goto ErrExit;

		// Item must be appended to master list.
		bAddToList = true;
		pSchemaDef->pSchema = (STGSCHEMA *) pUserSchema->pbReadWrite;

		// Fill the rest of the data in.
		pSchemaDef->fFlags = pUserSchema->fFlags;
	}

	// Add id.
	pSchemaDef->sid = *pUserSchema->pSchemaID->psid;
	pSchemaDef->Version = pUserSchema->pSchemaID->Version;

	// Init a name heap.
	pSchemaDef->pNameHeap = new StgStringPool;
	if (pSchemaDef->pNameHeap)
	{
		VERIFY(pSchemaDef->pNameHeap->InitOnMem((void*)pUserSchema->pbNames, 
				pUserSchema->cbNames, true) == S_OK);
	}
	else
		goto ErrExit;

	// Rest of the heaps can use the database.
	pSchemaDef->pStringPool = &m_UserSchema.StringPool;
	pSchemaDef->pBlobPool = &m_UserSchema.BlobPool;
	pSchemaDef->pVariantPool = &m_UserSchema.VariantPool;
	pSchemaDef->pGuidPool = &m_UserSchema.GuidPool;

	// Finally, append the item to the array.
	if (bAddToList && FAILED(hr = m_Schemas.Append(pSchemaDef)))
		goto ErrExit;

	hr = S_OK;


#else // @todo: this is the final version of the code for immutable schemas
	SCHEMADEFS	*pSchemaDef;			// Working pointer.
	int 		i;						// Loop control.
	int 		bAddToList; 			// true to add to schema list.
	HRESULT 	hr;

	// Verify that arguments are valid, we're in write mode, and the default
	// schemas have already been installed.
	_ASSERTE(pUserSchema);
	_ASSERTE(m_Schemas.Count());

	// Assume failure.
	hr = E_OUTOFMEMORY;

	// Check for a duplicate.
	pSchemaDef = _SchemaFind(pUserSchema->pSchemaID);

	// If the item was found, keep checking.
	if (pSchemaDef)
	{
		// Check for migration path.
		if (pSchemaDef->Version != pUserSchema->pSchemaID->Version)
		{
			_ASSERTE(!"Upgrading schemas not supported yet.");
			return (PostError(E_FAIL));
		}

		// Adding a reference to a schema that is already here is harmless.
		if (pSchemaDef->pSchema)
			return (S_OK);
		bAddToList = false;
	}
	// The schema is a new reference, so add it.
	else
	{
		// Item must be appended to master list.
		bAddToList = true;

		// Need to create a schema def structure.
		pSchemaDef = new SCHEMADEFS;
		if (!pSchemaDef)
			goto ErrExit;
		pSchemaDef->sid = *pUserSchema->pSchemaID->psid;
		pSchemaDef->Version = pUserSchema->pSchemaID->Version;
	}

	// Fill the rest of the data in.
	pSchemaDef->pSchema = (STGSCHEMA *) pUserSchema->pbReadWrite;
	pSchemaDef->fFlags = pUserSchema->fFlags;

	// Init a name heap.
	pSchemaDef->pNameHeap = new StgStringPool;
	if (pSchemaDef->pNameHeap)
	{
		VERIFY(pSchemaDef->pNameHeap->InitNew((void *) pUserSchema->pbNames, 
				pUserSchema->cbNames, false) == S_OK);
	}
	else
		goto ErrExit;

	// Rest of the heaps can use the database.
	pSchemaDef->pStringPool = &m_UserSchema.StringPool;
	pSchemaDef->pBlobPool = &m_UserSchema.BlobPool;
	pSchemaDef->pVariantPool = &m_UserSchema.VariantPool;

	// Finally, append the item to the array.
	if (bAddToList && FAILED(hr = m_Schemas.Append(pSchemaDef)))
		goto ErrExit;

	hr = S_OK;
#endif

ErrExit:
	// Clean up if error.
	if (FAILED(hr))
	{
		if (pSchemaDef)
		{
			if (pSchemaDef->pNameHeap)
				delete pSchemaDef->pNameHeap;
			SCHEMADEFS::SafeFreeSchema(pSchemaDef);
		}
		return (PostError(hr));
	}
	return (S_OK);
}


//*****************************************************************************
// Deletes a reference to a schema from the database.  You must have opened the
// database in write mode for this to work.  An error is returned if another
// schema still exists in the file which extends the schema you are trying to
// remove.	To fix this problem remove any schemas which extend you first.
// All of the table data associated with this schema will be purged from the
// database on Save, so use this function very carefully.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::SchemaDelete( // Return code.
	const COMPLIBSCHEMABLOB *pSchema)	// The schema to add.
{
	_ASSERTE(pSchema);
	_ASSERTE(!IsReadOnly());

	_ASSERTE(!"@todo: SchemaDelete not yet supported");
	return (E_FAIL);
}


//*****************************************************************************
// Returns the list of schema references in the current database.  Only
// iMaxSchemas can be returned to the caller.  *piTotal tells how many were
// actually copied.  If all references schemas were returned in the space
// given, then S_OK is returned.  If there were more to return, S_FALSE is
// returned and *piTotal contains the total number of entries the database has.
// The caller may then make the array of that size and call the function again
// to get all of the entries.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::SchemaGetList( // S_OK, S_FALSE, or error.
	int 		iMaxSchemas,			// How many can rgSchema handle.
	int 		*piTotal,				// Return how many we found.
	COMPLIBSCHEMADESC rgSchema[])		// Return list here.
{
	CSchemaList *pSchemaList;			//Pointer to Schema List
	SCHEMADEFS	*pSchemaDef;			//Working Schema deffinition
	int 		iCount; 				//Number of schemas in pSchemaList
	int 		iSchemaCount;			//Total number of Non-null schemas
	
	iSchemaCount = 0;

	//Get the schema list
	VERIFY(pSchemaList = GetSchemaList());
	iCount = pSchemaList->Count();

	for (int i = 0; i< iCount; i++)
	{
		pSchemaDef = pSchemaList->Get(i);

		if (pSchemaDef)
		{
			if (iSchemaCount < iMaxSchemas)
			{
				rgSchema[iSchemaCount].sid = pSchemaDef->sid;
				rgSchema[iSchemaCount].Version = pSchemaDef->Version;
				
				// @todo:  there is no schema catalog, so if something like
				// corview opens a file, it doesn't have all of the schema data
				// to answer this question.  One could hard code well known schemas
				// like debugging/regdb, but when the catalog is here you'd take
				// that out anyway.   Workarond is to call SchemaAdd before
				// calling this method to get accurate table count.
				if (pSchemaDef->pSchema)
					rgSchema[iSchemaCount].iTables = pSchemaDef->pSchema->iTables;
				else
					rgSchema[iSchemaCount].iTables = -1;
			}
			iSchemaCount++;
		}
	}

	//Return the total if asked for
	if (piTotal)
		*piTotal = iSchemaCount;

	return (S_OK);
}

//*****************************************************************************
// Before you can work with a table, you must retrieve its TABLEID.  The
// TABLEID changes for each open of the database.  The ID should be retrieved
// only once per open, there is no check for a double open of a table.
// Doing multiple opens will cause unpredictable results.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::OpenTable( // Return code.
	const COMPLIBSCHEMA *pSchema,		// Schema identifier.
	ULONG		iTableNum,				// Table number to open.
	TABLEID 	*pTableID)				// Return ID on successful open.
{
	STGOPENTABLE *pOpenTable;			// Pointer we'll dump.
	SCHEMADEFS	*pSchemaDefs;			// Working pointer for lookup.
	STGTABLEDEF *pTableDef; 			// Table definition.
	WCHAR		rcwTable[MAXTABLENAME]; // Name of table for lookup.
	int 		iIndex; 				// Index of schema in database.
	HRESULT		hr;

	_ASSERTE(pTableID);
	*pTableID = 0;
	
	if (pSchema)
	{
		// Go find the schema definitions in this database.
		pSchemaDefs = _SchemaFind(pSchema, &iIndex);
		if (!pSchemaDefs)
		{
			_ASSERTE(!"Schema not found");
			return (E_FAIL);
		}

		// Verify the table is in the list.
		_ASSERTE(pSchemaDefs->pSchema);
		_ASSERTE(iTableNum < pSchemaDefs->pSchema->iTables);

		// Get the table definition from the schema.
		VERIFY(pTableDef = pSchemaDefs->pSchema->GetTableDef(iTableNum));

		// Retrieve the table name for the open.
		VERIFY(pSchemaDefs->pNameHeap->GetStringW(pTableDef->Name, rcwTable, NumItems(rcwTable)) == S_OK);

		// Defer to the database open table which does all the real work.
		return (OpenTable(rcwTable, pOpenTable, -1, 
					pSchemaDefs, iIndex, pTableDef, iTableNum, pTableID));
	}

	// If pSchema is NULL, we are looking up the STGOPENTABLE for default schemas
	hr = OpenTable(NULL, pOpenTable, iTableNum);
	*pTableID = (TABLEID) pOpenTable;
	return hr;
}


//*****************************************************************************
// This is primarily called by the page dump code.
//*****************************************************************************
SCHEMADEFS *StgDatabase::GetSchema(SCHEMAS eSchema)
{
	return (m_Schemas.Get(eSchema));
}


//*****************************************************************************
// This function is called on a new database object that does not know what
// schemas it is to use yet.  There are three calling scenarios:
//
//	Create:  This scenario will optionally pull in the COM+ schema and add
//			the user schema to the list.
//
//	Open r/w:  This scenario will pull in the COM+ schema if need be and apply
//			any overrides that were saved on a previous run.  Next the user
//			schema is added to the list.
//
//	Open r/o:  This scenario will pull in the COM+ schema, apply overrides,
//			and select in the user schema.
//
// After this function succeeds, the database is prepared to handle all
// table related operations.
//*****************************************************************************
HRESULT StgDatabase::InitSchemaLoad(	// Return code.
	long		fFlags, 				// What mode are we in.
	STGSCHEMA	*pstgSchema,			// Header for schema storage.
	int 		bReadOnly,				// true if read only open.
	int 		bLoadCoreSchema,		// true if the COM+ schema is loaded.
	int 		iSchemas,				// How many schemas there were.
	BYTE		rgSchemaList[]) 		// For overrides, corresponding schema dex.
{
	HRESULT 	hr = S_OK;

	// Always add the user schema to the list.
	m_Schemas.AddSchema(&m_UserSchema, SCHEMA_USER);
	m_UserSchema.sid = SCHEMA_User;
	m_UserSchema.Version = 0;

	// We no longer support CORE schema
	_ASSERTE( !bLoadCoreSchema );

	// Open case.
	if ((fFlags & DBPROP_TMODEF_CREATE) == 0)
	{
		// For read only case, point directly at on disk schema to avoid copies.
		if (bReadOnly)
		{
			m_UserSchema.pSchema = pstgSchema;

		}
		// Else the schema needs to be expanded back into memory.
		else
		{
			// Remember on disk formats.
			m_TableDefDisk.pSchema = pstgSchema;
			m_TableDefDisk.fFlags = 0;

			// On disk schema needs access to the heaps.  Note that this is
			// a little fragile in that it requires that the heaps do not change
			// when copied into memory.
			//@Todo: I don't think it is safe to assume heaps don't change.
			//	Quicker, but not safe.	Need to review scenarios.
			m_TableDefDisk.pNameHeap = m_UserSchema.pNameHeap;
			m_TableDefDisk.pStringPool = m_UserSchema.pStringPool;
			m_TableDefDisk.pBlobPool = m_UserSchema.pBlobPool;
			m_TableDefDisk.pVariantPool = m_UserSchema.pVariantPool;
			m_TableDefDisk.pGuidPool = m_UserSchema.pGuidPool;

			// Load schema defs into memory.
			if (pstgSchema && FAILED(hr = LoadSchemaFromDisk(&m_UserSchema, &m_TableDefDisk)))
			{
				goto ErrExit;
			}
		}
	}
	// Create case.
	else
	{
		// Init all of the data heaps to their empty states, read for new data.
		if (FAILED(hr = m_UserSchema.StringPool.InitNew()) ||
			FAILED(hr = m_UserSchema.BlobPool.InitNew()) ||
			FAILED(hr = m_UserSchema.VariantPool.InitNew(&m_UserSchema.BlobPool, &m_UserSchema.StringPool)) ||
			FAILED(hr = m_UserSchema.GuidPool.InitNew()))
		{
			goto ErrExit;
		}
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// It has been determined that there is data that needs to be imported from disk.
// This code will find the schema and table definitions that describe the on
// disk data so it can be imported.  szTable and tableid are mutually exclusive.
//*****************************************************************************
HRESULT StgDatabase::GetOnDiskSchema(	// S_OK, S_FALSE, or error.
	LPCWSTR		szTable,				// Table name if tableid == -1
	TABLEID 	tableid,				// Tableid or -1 if name.
	SCHEMADEFS	**ppSchemaDefs, 		// Return schema here, 0 not found.
	STGTABLEDEF **ppTableDef)			// Return table def, 0 not found.
{
	SCHEMADEFS	*pDiskSchema;			// Schema for on disk.
	SCHEMADEFS	*pSchemaNames;			// Name schema to use.
	STGTABLEDEF *pTableDefDisk; 		// Working pointer.
	HRESULT 	hr = S_OK;				// Assume success.

	// Must give one of the following.	Ptr's are required.
	_ASSERTE(!(!szTable && tableid == -1));
	_ASSERTE(ppSchemaDefs && *ppSchemaDefs && ppTableDef);
		
	// Get a pointer to the on disk schema we can scan.
	pDiskSchema = &m_TableDefDisk;

	// If there are no overrides on disk at all, then you cannot scan.
	if (!pDiskSchema || !pDiskSchema->pSchema)
	{
		*ppSchemaDefs = 0;
		*ppTableDef = 0;
		hr = S_FALSE;
	}
	// Check core tables first.
	else if (tableid != -1)
	{
		_ASSERTE( 0 );
	}
	// Opens by name required scanning the user schema.
	else
	{
		// Check each table by name.
		for (int i=0, iSchema=0;  i<pDiskSchema->pSchema->iTables;	i++)
		{
			VERIFY(pTableDefDisk = pDiskSchema->pSchema->GetTableDef(i));

			// If this is an override, need to point to the real schema definition
			// name heap to get a correct comparison.
			if (pTableDefDisk->IsCoreTable())
			{
				_ASSERTE(iSchema < m_iSchemas);
				pSchemaNames = m_Schemas.Get(m_rgSchemaList[iSchema]);
				++iSchema;
			}
			// For normal tables, simply use the data heap.
			else	
				pSchemaNames = pDiskSchema;

			// Check for an equivalent name.
			if (SchemaNameCmp(pSchemaNames->pNameHeap->GetString(pTableDefDisk->Name), szTable) == 0)
			{
//				_ASSERTE(!pTableDefDisk->IsCoreTable());
				*ppSchemaDefs = pDiskSchema;
				*ppTableDef = pTableDefDisk;
				goto FoundIt;
			}
		}

		// Wasn't found.
		*ppSchemaDefs = 0;
		*ppTableDef = 0;
		hr = S_FALSE;
	}

FoundIt:
	return (hr);
}


//*****************************************************************************
// Given a persisted set of tables from an existing database, recreate the
// original table definitions in memory with fully expanded columns.
//*****************************************************************************
HRESULT StgDatabase::LoadSchemaFromDisk( // Return code.
	SCHEMADEFS	*pTo,					// Load the data into here.
	const SCHEMADEFS *pFrom)			// Take data from here.
{
	STGTABLEDEF *pTableDef; 			// Table defintion for new item.
	STGCOLUMNDEF *pColDef;				// Working pointer for copying.
	STGINDEXDEF *pIndexDef = 0; 		// The indexes for a given table.
	int 		i, iTbl;				// Loop control.
	HRESULT 	hr = S_OK;

	// Allocate room for the schema data.
	if ((pTo->pSchema = (STGSCHEMA *) malloc(pFrom->pSchema->cbSchemaSize)) == 0)
		return (PostError(OutOfMemory()));
	pTo->fFlags |= SCHEMADEFSF_FREEDATA;

	// Copy the entire stream into the new memory, we'll make changes there.
	memcpy(pTo->pSchema, pFrom->pSchema, pFrom->pSchema->cbSchemaSize);

	// Walk each schema definition and change it to match a full table def.
	for (iTbl=0;  iTbl<pFrom->pSchema->iTables;  iTbl++)
	{
		// Get the current table def.
		pTableDef = pTo->pSchema->GetTableDef(iTbl);

		// Sanity check status.
		_ASSERTE(pTableDef->IsTempTable() == false);

		// Walk each column to reset sizes.
		pColDef = pTableDef->GetColDesc(0);
		for (i=0;  i<pTableDef->iColumns;  i++, pColDef++)
		{
			if (IsPooledType(pColDef->iType))
			{
				pColDef->iSize = sizeof(ULONG);
				pColDef->iNullBit = 0xff;
			}
		}

		// Align the columns of the table for safe access.
		if (FAILED(hr = AlignTable(pTableDef)))
			goto ErrExit;
	
		// Add each index to the table.
		if (pTableDef->iIndexes)
			pIndexDef = pTableDef->GetIndexDesc(0);
		for (i=pTableDef->iIndexes;  i;  )
		{
			// Reset flags to let the index build for updates.
			pIndexDef->fFlags &= ~DEXF_INCOMPLETE;

			// Add room for this index to the record.
			if ((pIndexDef->fFlags & DEXF_DEFERCREATE) == 0)
			{
				pIndexDef->HASHDATA.iNextOffset = pTableDef->iRecordSize;
				pTableDef->iRecordSize += sizeof(ULONG);
			}

			// If there are any left to fetch, load them.
			if (--i)
				VERIFY(pIndexDef = pIndexDef->NextIndexDef());
		}
	}

ErrExit:
	// On error, free any allocated memory.
	if (FAILED(hr))
	{
		free(pTo->pSchema);
		pTo->pSchema = 0;
	}
	return (hr);
}

//*****************************************************************************
// Look for core table overrides (change in column size, indexes stored or not)
// then make the in memory definition match it.
//*****************************************************************************
void StgDatabase::AddCoreOverrides(
	SCHEMADEFS	*pCoreSchema,			// Core schema definitions to overwrite.
	const SCHEMADEFS *pUserSchema,		// Where the overrides live.
	int 		iSchemaDex, 			// Index of pCoreSchema.
	int 		iSchemas,				// How many schemas there were.
	BYTE		rgSchemaList[]) 		// The list of schemas for overrides.
{
	const STGTABLEDEF *pFromTbl;		// From table with override.
	STGTABLEDEF *pToTbl;				// Where does override get writen.
	
	// For case when there are no overrides from user.
	if (!pUserSchema || !pUserSchema->pSchema)
		return;

	// Check each user table define for a core override.
	for (int i=0, j=0;	i<pUserSchema->pSchema->iTables;  i++)
	{
		// Ignore all non-core table definitions.
		VERIFY(pFromTbl = pUserSchema->pSchema->GetTableDef(i));
		if (!pFromTbl->IsCoreTable())
			continue;
		
		// If this override is not for the given schema, ignore it.
		if (rgSchemaList && j < iSchemas && rgSchemaList[j++] != iSchemaDex)
			continue;

		// Get a pointer to the base core schema def.
		VERIFY(pToTbl = pCoreSchema->pSchema->GetTableDef(pFromTbl->tableid));

		//@todo: this code assumes that you never add or delete columns or
		// otherwise change the size.  This will not be true with full
		// extensibility added in.
		_ASSERTE(pToTbl->tableid == pFromTbl->tableid);
		_ASSERTE(pToTbl->iSize == pFromTbl->iSize);
		_ASSERTE(memcmp(pToTbl, pFromTbl, pFromTbl->iSize) != 0);
		memcpy(pToTbl, pFromTbl, pFromTbl->iSize);
	}
}


//*****************************************************************************
// Find a table def override in the given schema.  Because overrides are not
// indexed by tableid, this does require a scan of each table def.
//*****************************************************************************
STGTABLEDEF *StgDatabase::FindCoreTableOverride( // Table def override if found.
	SCHEMADEFS	*pUserSchema,			// Schema which might have overrides.
	TABLEID 	tableid)				// Which table do you want.
{
	STGTABLEDEF *pTableDef; 			// Tabledef for lookup.
	
	// Check the user schema to see if there could be overrides.
	if (pUserSchema && pUserSchema->pSchema && 
				(pUserSchema->pSchema->fFlags & STGSCHEMAF_CORETABLE))
	{
		// Core table overrides are not indexed by tableid, so a 
		// scan is required.
		for (int i=0;  i<pUserSchema->pSchema->iTables;  i++)
		{
			VERIFY(pTableDef = pUserSchema->pSchema->GetTableDef(i));
			if (pTableDef->IsCoreTable() && pTableDef->tableid == tableid)
				return (pTableDef);
		}
	}
	
	// Not found.
	return (0);
}


//*****************************************************************************
// Examines the given table definition against the compact r/o version.  If
// there are any overrides that are too big, then return true so that the
// caller knows an override must be stored in the database file.
//*****************************************************************************
int StgDatabase::IsCoreTableOverride(	// true if it is.
	SCHEMADEFS	*pSchemaDef,			// The schema which owns the table.
	STGTABLEDEF *pTableDef) 			// The table def to compare.
{
	STGINDEXDEF *pIndexDef1, *pIndexDef2;// Index definition.
	STGTABLEDEF *pCoreTableDef; 		// The core table equivalent.
	int 		i;

	// Get the core version for read only.
	VERIFY(pCoreTableDef = pSchemaDef->pSchema->GetTableDef(pTableDef->tableid));

	// Check the table def first.
	if (memcmp(pTableDef, pCoreTableDef, sizeof(STGTABLEDEF)) != 0)
		return (true);

	// Columns must match exactly.
	if (memcmp(pTableDef->GetColDesc(0), pCoreTableDef->GetColDesc(0),
			sizeof(STGCOLUMNDEF) * pTableDef->iColumns) != 0)
		return (true);

	// Indexes are harder to compare because we allow heuristic data to be
	// stored with table itself.
	if (pTableDef->iIndexes)
	{
		// Walk each one.
		for (i=0;  i<pTableDef->iIndexes;  i++)
		{
			// Front load for quicker scan.
			VERIFY(pIndexDef1 = pTableDef->GetIndexDesc(i));
			VERIFY(pIndexDef2 = pCoreTableDef->GetIndexDesc(i));

			// Skip certain fields.
			if (pIndexDef1->fFlags != pIndexDef2->fFlags ||
				pIndexDef1->iRowThreshold != pIndexDef2->iRowThreshold ||
				pIndexDef1->HASHDATA.iMaxCollisions != pIndexDef2->HASHDATA.iMaxCollisions ||
				pIndexDef1->HASHDATA.iNextOffset != pIndexDef2->HASHDATA.iNextOffset ||
				pIndexDef1->iIndexNum != pIndexDef2->iIndexNum ||
				pIndexDef1->iKeys != pIndexDef2->iKeys)
			{
				return (true);
			}
		}
	}
	return (false);
}


//*****************************************************************************
// Open a table in the database.  The fastest way to open a table is by its
// id if it is part of the COM+ schema.  Otherwise a name may be given for
// any table.  Open tables are tracked using a heap of STGOPENTABLE structs,
// indexed by tableid.	An additional string hash is kept to do lookups by
// name quickly.  This hash table is not loaded until an open is done using
// a string name.  This keeps working set size down for a COR only scenario.
// Once a table is opened, it remains in the open table list until CloseTable
// is called.  If a table becomes dirty, it cannot be closed until after it
// is saved to disk.
//*****************************************************************************
HRESULT StgDatabase::OpenTable( 		// Return code.
	LPCWSTR 	szTableName,			// The name of the table.
	STGOPENTABLE *&pOpenTable,			// Return opened table struct here.
	TABLEID 	tableid,				// Index for the table if known.
	SCHEMADEFS	*pSchemaDefs,			// Schema where table lives.
	int 		iSchemaIndex,			// Index of the schemadef if given.
	STGTABLEDEF *pTableDef, 			// The definition of the table for open.
	ULONG		iTableDef,				// Which table definition is it.
	TABLEID 	*pNewTableID,			// Return if new entry added.
	ULONG		InitialRecords) 		// How many initial records to preallocate for
										//	new open of empty table, hint only.
{
	SCHEMADEFS	*pDiskSchema=0; 		// For import case.
	STGTABLEDEF *pTableDefDisk=0;		// For disk imports.
	SCHEMADEFS	CoreRO; 				// Required for import in r/w scenario.
	char		rcTable[MAXTABLENAME];	// Name of table converted.
	WCHAR		rcName[16]; 			// Buffer for tableid open.
	void		*pData=0;				// Data from existing stream.
	ULONG		cbDataSize=0;			// Existing data size.
	int 		fFlags = 0; 			// Flags for record manager open.
	HRESULT 	hr = S_OK;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Avoid confusion.
	pOpenTable = 0;

	// Serialize access to the open table list.  In general ICR doesn't do any
	// locking, but this turns out to help the RegDB and EE scenarios where tables
	// are lazily faulted in.
	CLock sLock(GetLock());

	// If the tableid is known, then just seek to it.
	if (tableid != -1)
	{
		// Do a quick sanity check on the tableid passed in.  If it can't
		// possibly be a valid pointer, give an error to the caller.  Note
		// that this check breaks on an OS which can allocate user memory
		// below 64kb.
		_ASSERTE(tableid > USHRT_MAX);

		
		VERIFY(pOpenTable = (STGOPENTABLE *) tableid);
		
		// If it is already loaded, then you can use it.
		if (pOpenTable->RecordMgr.IsOpen())
			return (S_OK);
	}
	// For user defined table (by name), do a lookup.
	else
	{
		// Convert the name if required for lookup.
		VERIFY(Wsz_wcstombs(rcTable, szTableName, sizeof(rcTable)));

		// If the table isn't already open, then we need to open it.
		if ((pOpenTable = TableListFind(rcTable)) != 0 && pOpenTable->RecordMgr.IsOpen())
		{
			if (pNewTableID)
				*pNewTableID = (TABLEID) pOpenTable;
			return (S_OK);
		}
	}

	CIfacePtr<IStream> pIStream;

	// Look for the table in the schemas.  If not found, then it can't be used.
	if (!pSchemaDefs && !pTableDef)
	{
		if (FAILED(hr = GetTableDef(szTableName, tableid, &pSchemaDefs, &pTableDef, 
					&iTableDef, &iSchemaIndex)))
		{
			hr = PostError(hr, szTableName);
			goto ErrExit;
		}
	}

	// Look for an existing stream to load from.
	if (IsExistingFile() && !pTableDef->IsTempTable() && !IsClassFile())
	{
		// Hard coded schemas use a short name based on schema index and
		// table id.
		if (pSchemaDefs->sid != SCHEMA_User && pSchemaDefs->sid != SCHEMA_Temp)
		{
			// Core tables are stored with a small name to minimize the
			// stream overhead.
			if (pSchemaDefs->sid == SCHEMA_SymbolTable)
			{
				GetCoreTableStreamName(SCHEMA_CORE, pTableDef->tableid, rcName, sizeof(rcName));
				szTableName = rcName;
			}
			// It is a user hard coded schema.
			else
			{
				// Format the name.
				GetCoreTableStreamName(iSchemaIndex, (USHORT) iTableDef, rcName, sizeof(rcName));
				szTableName = rcName;
			}
		}

		// Get a pointer to the actual stream data.
		hr = m_pStorage->OpenStream(szTableName, &cbDataSize, &pData);
		if (FAILED(hr) && hr != STG_E_FILENOTFOUND)
			return (hr);
	}

	// If there simply is no struct yet, create one.
	if (pOpenTable == 0)
	{
		_ASSERTE(tableid == -1 && *rcTable);

		// Get a new entry open table struct to use.
		if (FAILED(hr = TableListAdd(rcTable, pOpenTable)))
			return (hr);

		// If caller wants the ID, give it to them.
		if (pNewTableID)
			*pNewTableID = (TABLEID) pOpenTable;
	}

	// Set modes.
	if (IsReadOnly() && !pTableDef->IsTempTable())
		fFlags = SRM_READ;
	else
	{
		fFlags = SRM_WRITE;
		if (!pData)
			fFlags |= SRM_CREATE;
	}

	// If there is existing data on disk, and we are in read/write mode, then
	// it needs to get loaded into memory as a deep copy.
	if (pData && IsExistingFile() && !IsReadOnly() && !pTableDef->IsTempTable())
	{
		LPCWSTR		szATable = pSchemaDefs->pNameHeap->GetString(pTableDef->Name);

		// Have to give a blank schema in case it winds up being the
		// version in memory.
		pDiskSchema = &CoreRO;

		// Look for an on disk schema definition for the import.
		// Call guarantees that pDiskSchema and pTableDefDisk come back
		// as NULL if there is no import.
		if (FAILED(hr = GetOnDiskSchema(szATable, tableid, &pDiskSchema, &pTableDefDisk)))
			return (hr);
	}

	// Open the record manager for this table.	If there is data on disk,
	// then this will force an import into the in memory format.
	if (FAILED(hr = pOpenTable->RecordMgr.Open(pSchemaDefs, iTableDef, fFlags, 
			pData, cbDataSize, pDiskSchema, pTableDefDisk, InitialRecords)))
	{
		TableListDel(pOpenTable);
		goto ErrExit;
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Close the given table.
//@todo: this should essentially throw away the working set size for a non-dirty
// table.
//*****************************************************************************
void StgDatabase::CloseTable(
	LPCSTR		szTable)				// Table to close.
{
	STGOPENTABLE *pTable;				// Working pointer.

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Find the table struct.
	if ((pTable = TableListFind(szTable)) == 0)
	{
		_ASSERTE(0);
		return;
	}
}



//*****************************************************************************
// Use these functions to walk the table list.	Note that you must lock down
// the database for schema changes so the pointers and counts remain valid.
// This code will not do that synchronization for you.
//*****************************************************************************
STGTABLEDEF *StgDatabase::GetFirstTable( // Return first found table.
	SCHEMASRCH	&sSrch, 				// Search structure.
	int 		fFlags) 				// Flags for the search.
{
	sSrch.iIndex = 0;
	sSrch.iSchema = 0;
	sSrch.fFlags = fFlags;
	sSrch.pSchemaDef = 0;
	return (GetNextTable(sSrch));
}

STGTABLEDEF *StgDatabase::GetNextTable(
	SCHEMASRCH	&sSrch) 				// Search structure.
{
	STGTABLEDEF *pTable = 0;

//@todo: puh-lease, this is way to much crap.  Thune this sucker and
// reduce cycles here.
	do
	{
		if (sSrch.pSchemaDef && sSrch.iIndex >= sSrch.pSchemaDef->pSchema->iTables)
			sSrch.pSchemaDef = 0;

		for (;	(!sSrch.pSchemaDef || !sSrch.pSchemaDef->pSchema) && sSrch.iSchema <= m_Schemas.Count();  
				++sSrch.iSchema)
		{
			// Get the next schema
			sSrch.pSchemaDef = m_Schemas.Get(sSrch.iSchema);
			if (!sSrch.pSchemaDef || !sSrch.pSchemaDef->pSchema)
				continue;

			// If this schema is flagged not to be searched, skip it.
			if ((1 << sSrch.iSchema) & sSrch.fFlags)
				continue;
		
			// Reset the table index.
			sSrch.iIndex = 0;
		}

		// If there are no more schemas to look at, we're done.
		if (sSrch.iSchema > m_Schemas.Count())
			return (0);

		// Search this schema for tables.
		if (sSrch.iIndex < sSrch.pSchemaDef->pSchema->iTables)
			pTable = sSrch.pSchemaDef->pSchema->GetTableDef(sSrch.iIndex++);
	
		// Skip overrides which are already loaded.
		if (m_bEnforceDeleteOnEmpty && sSrch.iSchema - 1 == SCHEMA_USER && pTable->IsCoreTable())
		{
			pTable = 0;
			continue;
		}
	} while (!pTable);

	return (pTable);
}


//*****************************************************************************
// Look for a table definition and the schema it lives in.	This will use
// the current schema list of this database from top to bottom.  Lookups by
// tableid are very fast, so give one if possible.
//
// NOTE: This function does *not* post an error, just returns a failure code.
// This allows the caller to decide if this state is fatal or not without
// faulting in the resource dll.
//*****************************************************************************
HRESULT StgDatabase::GetTableDef(		// S_OK or DB_E_NOTABLE, never posts.
	LPCWSTR		szTable,				// Name of table to find.
	TABLEID 	tableid,				// ID of table, -1 if not known.
	SCHEMADEFS	**ppSchema, 			// Return owning schema here.
	STGTABLEDEF **ppTableDef,			// Return table def in schema if found.
	ULONG		*piTableDef,			// Logical offset of table def.
	int 		*piSchemaDef,			// Index of schema def in list.
	int 		bSkipOverrides) 		// true to skip core overrides (default).
{
	SCHEMADEFS	*pSchemaDefs;			// Working pointer.
	STGTABLEDEF *pTableDef; 			// Working pointer.
	int 		i;						// Loop control.

	// Knowing the tableid allows us to find the table much faster.
	if (tableid != -1)
	{
		_ASSERTE(ppSchema && ppTableDef && piTableDef);
        _ASSERTE(IsValidTableID(tableid));

		// Get the definition from the core schema.
		VERIFY(*ppSchema = m_Schemas.Get(SCHEMA_CORE));
		if (*ppSchema && (*ppTableDef = (*ppSchema)->pSchema->GetTableDef((int)tableid)) != 0)
		{
			if (piTableDef) *piTableDef = (ULONG)tableid;
			if (piSchemaDef) *piSchemaDef = SCHEMA_CORE;
			return (S_OK);
		}

		// A tableid must be found in the core schema or something is out
		// of sync.  This code is designed to handle this gracefully.
		_ASSERTE(0);
		if (!szTable)
			szTable = L"<tableid>";
		goto ErrExit;
	}

	_ASSERTE(szTable && *szTable);

	// Walk each schema and look for the one we want.
	for (i=0;  i<m_Schemas.Count();  i++)
	{
		pSchemaDefs = m_Schemas.Get(i);

		// If there isn't a schema in this slot, or it has not definitions, skip.
		if (!pSchemaDefs || !pSchemaDefs->pSchema)
			continue;

		// Walk each table in this schema looking for the match.
		for (USHORT j=0;  j<pSchemaDefs->pSchema->iTables;	j++)
		{
			VERIFY(pTableDef = pSchemaDefs->pSchema->GetTableDef(j));

			// Skip any user overrides which are already in the other schema.
			if (bSkipOverrides && pTableDef->IsCoreTable() && i == SCHEMA_USER)
				continue;

			// See if this table is a match.
			if (SchemaNameCmp(pSchemaDefs->pNameHeap->GetString(pTableDef->Name), szTable) == 0)
			{
				if (ppSchema) *ppSchema = pSchemaDefs;
				if (ppTableDef) *ppTableDef = pTableDef;
				if (piTableDef) *piTableDef = j;
				if (piSchemaDef) *piSchemaDef = i;
				return (S_OK);
			}
		}
	}

ErrExit:
	// Not found.
	if (ppSchema) *ppSchema = 0;
	if (ppTableDef) *ppTableDef = 0;
	return (DB_E_NOTABLE);
}


//*****************************************************************************
// This lookup is by name and requires the hash table to work.	This hash table
// is faulted in on the first call to this function, since lookups by names
// is not done by a COR only client (they use tableid).
//*****************************************************************************
STGOPENTABLE *StgDatabase::TableListFind(// Found table or 0.
	LPCSTR		szTable)				// Table to find.
{
	STGOPENTABLEHASH *p;				// Working pointer.
	HRESULT 	hr;

	// Need the hash table to find tables.
	if (FAILED(hr = TableListHashCreate()))
		return (0);

	// Return a pointer to the open table we find.
	if ((p = m_pTableHash->Find((void *) szTable)) != 0)
		return (p->pOpenTable);
	return (0);
}


//*****************************************************************************
// We want to open a table we currently do not have open.  Allocate all of the
// correct data structures to do so.
//*****************************************************************************
HRESULT StgDatabase::TableListAdd(		// Return code.
	LPCSTR		szTableName,			// The new table to open.
	STGOPENTABLE *&pTable)				// Return new pointer on success.
{
	STGOPENTABLEHASH *pHash;			// For hash table updating.
	HRESULT 	hr = S_OK;

	_ASSERTE(szTableName && *szTableName);

	// Avoid confusion.
	pTable = 0;

	// Need to have the hash table if a new table is being added.
	if (FAILED(hr = TableListHashCreate()))
		return (hr);
	_ASSERTE(m_pTableHash);

	// Allocate an opentable item.
	pTable = m_TableHeap.AddOpenTable();
	if (!pTable)
		return (PostError(OutOfMemory()));
	pTable->RecordMgr.SetDB(this);

	// Store a pointer to the name for the hash table.
	pTable->szTableName = m_TableHeap.GetNameBuffer((int) strlen(szTableName) + 1);
	if (!pTable->szTableName)
	{
		hr = PostError(OutOfMemory());
		goto ErrExit;
	}
	strcpy(pTable->szTableName, szTableName);

	// Add the item to the hash table.
	pHash = m_pTableHash->Add((void *) szTableName);
	if (!pHash)
	{
		hr = PostError(OutOfMemory());
		goto ErrExit;
	}
	pHash->pOpenTable = pTable;

ErrExit:
	// Clean up on error.
	if (FAILED(hr))
	{
		if (pTable->szTableName)
			m_TableHeap.FreeNameBuffer(pTable->szTableName, (int) strlen(szTableName) + 1);
		m_TableHeap.DelOpenTable(pTable);
		pTable = 0;
	}
	return (hr);
}


//*****************************************************************************
// Last reference on open table is gone, clean it up.
//*****************************************************************************
void StgDatabase::TableListDel(
	STGOPENTABLE *pOpenTable)			// Table to clean up.
{
	// Enforce thread safety for database.
	AUTO_CRIT_LOCK(GetLock());

	// Free the record manager, but leave everything else in tact.
	if (pOpenTable->RecordMgr.IsOpen())
		pOpenTable->RecordMgr.CloseTable();
}


//*****************************************************************************
// Faults in the table list hash table which makes table name lookups much
// faster.	This is not created by default because COM+ uses tableid's instead
// of names.
//*****************************************************************************
HRESULT StgDatabase::TableListHashCreate()
{
	STGOPENTABLEHASH *p;				// Working pointer for hash entries.
	STGOPENTABLE *pOpenTable;			// Open table pointer.

	// If the hash table is already created, there is no work to do.
	if (m_pTableHash)
		return (S_OK);

	// Fault in the hash table if it does not already exist.
	if (!m_pTableHash)
	{
		// Allocate room for it.
		m_pTableHash = new COpenTablePtrHash;
		if (!m_pTableHash)
			return (PostError(OutOfMemory()));

		// Walk the list of open tables and add each one.
		for (pOpenTable=m_TableHeap.GetHead();	pOpenTable;
					pOpenTable=m_TableHeap.GetNext(pOpenTable))
		{
			_ASSERTE(pOpenTable->szTableName);

			// Allocate a hash entry.
			p = m_pTableHash->Add(pOpenTable->szTableName);
			if (!p)
				goto ErrCleanup;
			p->pOpenTable = pOpenTable;
		}
	}
	return (S_OK);

ErrCleanup:
	delete m_pTableHash;
	m_pTableHash = 0;
	return (PostError(OutOfMemory()));
}





//*****************************************************************************
// Looks for a schema reference in the current database.
//*****************************************************************************
SCHEMADEFS *StgDatabase::_SchemaFind(	// Pointer to item if found.
	const COMPLIBSCHEMA *pSchema,		// Schema identifier.
	int 		*piIndex)				// Return index of item if found.
{
	SCHEMADEFS	*pSchemaDef;			// Working pointer.
	int 		i;						// Loop control.

	_ASSERTE(pSchema);

	// Do a scan for it.
	for (i=0;  i<m_Schemas.Count();  i++)
	{
		pSchemaDef = m_Schemas.Get(i);
		if (!pSchemaDef)
		{
			_ASSERTE(i < SCHEMA_EXTERNALSTART);
			continue;
		}

		if (pSchemaDef->sid == *pSchema->psid)
		{
			if (piIndex)
				*piIndex = i;
			return (pSchemaDef);
		}
	}
	return (0);
}


//*****************************************************************************
// Given the header data which contains schema references, add the reference
// to the loaded instance of the database.	There will be no attempt to fix
// up the definition pointer yet.  The caller may provide this value by calling
// SchemaAdd(), or if we need it we can fault it in by looking it up in the
// schema catalog.
//*****************************************************************************
HRESULT StgDatabase::AddSchemasRefsFromFile( // Return code.
	STGEXTRA	*pExtra)				// Extra header data.
{
	HRESULT 	hr = S_OK;

	// Add each schema to the list of loaded schemas.
	for (int i=0;  i< (int) pExtra->iSchemas;  i++)
	{
		SCHEMADEFS *pDefs = new SCHEMADEFS;
		if (!pDefs)
		{
			hr = PostError(OutOfMemory());
			goto ErrExit;
		}

		// Fill only the id for now.  User can add the blob by
		// calling SchemaAdd(), or we can fault it in from the
		// catalog if we have to.
		pDefs->sid = pExtra->rgSchemas[i].sid;
		pDefs->Version = pExtra->rgSchemas[i].Version;
		pDefs->fFlags = SCHEMADEFSF_FREEDATA;
		if (FAILED(hr = m_Schemas.Append(pDefs)))
		{
			SCHEMADEFS::SafeFreeSchema(pDefs);
			goto ErrExit;
		}

		// Stream names contain the schema and tableid, so schemas
		// have to be added in the same order they were saved.	If
		// this fires, then the stream names won't match causing
		// data corruption.
		_ASSERTE(m_Schemas.ExternalCount() == i + 1);
	}

ErrExit:
	// Do clean up on failure.
	if (FAILED(hr))
	{
		SCHEMADEFS	*pDefs;
		int 		iDex;

		// For each externally added item, go in and delete it.
		while (m_Schemas.ExternalCount())
		{
			iDex = m_Schemas.Count() - 1;
			pDefs = m_Schemas.Get(iDex);
			if (pDefs)
				SCHEMADEFS::SafeFreeSchema(pDefs);
			m_Schemas.Del(iDex);
		}
	}
	return (hr);
}


//
// Protection for freeing schema defs.  This is the code for safe protecting
// the deletion of a schemadef.  Please see the header definition for details.
//

SCHEMADEFS::~SCHEMADEFS()
{
	_ASSERTE(IsValid());
	Cookie = 0xdddddddd;
}


bool SCHEMADEFS::IsValidPtr(SCHEMADEFS *pSchemaDefs)
{
	// Now make that a part of the retail check to avoid a crash.
	if (pSchemaDefs && 
			!IsBadWritePtr(pSchemaDefs, sizeof(SCHEMADEFS))
			&& pSchemaDefs->Cookie == SCHEMADEFS_COOKIE)
	{
		return (true);
	}

	_ASSERTE(0 && "SCHEMADEFS is invalid but still being used, possible stress failure repro case!!");
	return (false);
}


void SCHEMADEFS::SafeFreeSchema(SCHEMADEFS *pSchemaDefs)
{
	bool bValid = IsValidPtr(pSchemaDefs);
	_ASSERTE(bValid);
	if (bValid)
		delete pSchemaDefs;
}



#ifdef _DEBUG

//*****************************************************************************
// This function displays the meta data descriptions for all tables and 
// indexes in a schema.  This can be useful to determine layouts when debugging
// schema work.
//*****************************************************************************
HRESULT DumpSchema( 					// Return code.
	SCHEMADEFS	*pSchemaDefs,			// The schema definitions to dump.
	PFNDUMPFUNC pfnDump)				// Function to use when dumping.
{
	STGTABLEDEF *pTableDef;
	WCHAR		rcwGuid[64];
	int 		i;
	(*pfnDump)(L"\n********** Schema Dump **********\n");

	// First the top level values.
	StringFromGUID2(pSchemaDefs->sid, rcwGuid, sizeof(rcwGuid));
	(*pfnDump)(L"sid:               %s\n", rcwGuid);
	(*pfnDump)(L"Version:           %u\n", pSchemaDefs->Version);
	(*pfnDump)(L"pSchema:           0x%08x\n", pSchemaDefs->pSchema);
	(*pfnDump)(L"Flags:             0x%04x\n", pSchemaDefs->fFlags);
	(*pfnDump)(L"pNameHeap:         0x%08x\n", pSchemaDefs->pNameHeap);
	(*pfnDump)(L"pStringPool:       0x%08x\n", pSchemaDefs->pStringPool);
	(*pfnDump)(L"pBlobPool:         0x%08x\n", pSchemaDefs->pBlobPool);
	(*pfnDump)(L"pVariantPool:      0x%08x\n\n", pSchemaDefs->pVariantPool);

	// Dump the schema data next.
	(*pfnDump)(L"STGSCHEMA:\n");
	(*pfnDump)(L"\tiTables            %d\n", (int) pSchemaDefs->pSchema->iTables);
	(*pfnDump)(L"\tfFlags             0x%04x\n", pSchemaDefs->pSchema->fFlags);
	(*pfnDump)(L"\tcbSchemaSize       %d\n", (int) pSchemaDefs->pSchema->cbSchemaSize);
	for (i=0;  i<pSchemaDefs->pSchema->iTables;  i++)
		(*pfnDump)(L"\trgTableOffset[%02d]: %03d\n", i, (int) pSchemaDefs->pSchema->rgTableOffset[i]);
	
	// Now for each table definition.
	for (i=0;  i<pSchemaDefs->pSchema->iTables;  i++)
	{
		VERIFY(pTableDef = pSchemaDefs->pSchema->GetTableDef(i));
		DumpSchemaTable(pSchemaDefs, pTableDef, pfnDump);
	}

	return (S_OK);
}


//*****************************************************************************
// Display the contents of a table definition, including the columns, indexes
// and any other data for the table.
//*****************************************************************************
HRESULT DumpSchemaTable(				// Return code.
	SCHEMADEFS	*pSchemaDefs,			// The schema definitions to dump.
	STGTABLEDEF *pTableDef, 			// Table definition to dump.
	PFNDUMPFUNC pfnDump)				// Function to use when dumping.
{
	STGCOLUMNDEF *pColDef;
	STGINDEXDEF *pIndexDef;
	WCHAR		rcwName[128];
	int 		j, k;

	(*pfnDump)(L"\n\tTable %d:\n", (int) pTableDef->tableid);
	VERIFY(S_OK == pSchemaDefs->pNameHeap->GetStringW(pTableDef->Name, rcwName, NumItems(rcwName)));
	(*pfnDump)(L"\t\tName:              %s\n", rcwName);
	(*pfnDump)(L"\t\ttableid:           %d\n", (int) pTableDef->tableid);
	(*pfnDump)(L"\t\tiIndexes:          %d\n", (int) pTableDef->iIndexes);
	(*pfnDump)(L"\t\tfFlags:            0x%02x\n", pTableDef->fFlags);
	(*pfnDump)(L"\t\tiColumns:          %d\n", (int) pTableDef->iColumns);
	(*pfnDump)(L"\t\tiNullableCols:     %d\n", (int) pTableDef->iNullableCols);
	(*pfnDump)(L"\t\tiNullBitmaskCols:  %d\n", (int) pTableDef->iNullBitmaskCols);
	(*pfnDump)(L"\t\tiRecordStart:      %d\n", (int) pTableDef->iRecordStart);
	(*pfnDump)(L"\t\tiNullOffset:       %d\n", (int) pTableDef->iNullOffset);
	(*pfnDump)(L"\t\tiRecordSize:       %d\n", (int) pTableDef->iRecordSize);
	(*pfnDump)(L"\t\tiSize:             %d\n\n", (int) pTableDef->iSize);

	for (j=0;  j<pTableDef->iColumns;  j++)
	{
		VERIFY(pColDef = pTableDef->GetColDesc(j));
		(*pfnDump)(L"\t\tColumn %d\n", j);
		VERIFY(S_OK == pSchemaDefs->pNameHeap->GetStringW(pColDef->Name, rcwName, NumItems(rcwName)));
		(*pfnDump)(L"\t\t\tName:              %s\n", rcwName);
		(*pfnDump)(L"\t\t\tiColumn:           %d\n", (int) pColDef->iColumn);
		(*pfnDump)(L"\t\t\tfFlags:            0x%02x\n", pColDef->fFlags);
		(*pfnDump)(L"\t\t\tiType:             %d\n", (int) pColDef->iType);
		(*pfnDump)(L"\t\t\tiOffset:           %d\n", (int) pColDef->iOffset);
		(*pfnDump)(L"\t\t\tiSize:             %d\n", (int) pColDef->iSize);
		(*pfnDump)(L"\t\t\tiMaxSize:          %d\n", (int) pColDef->iMaxSize);
		(*pfnDump)(L"\t\t\tiNullBit:          %d\n", (int) pColDef->iNullBit);
		(*pfnDump)(L"\t\t\tiColumn:           %d\n", (int) pColDef->iColumn);
	}

	for (j=0;  j<pTableDef->iIndexes;  j++)
	{
		VERIFY(pIndexDef = pTableDef->GetIndexDesc(j));
		(*pfnDump)(L"\n\t\tIndex %d\n", j);
		VERIFY(S_OK == pSchemaDefs->pNameHeap->GetStringW(pIndexDef->Name, rcwName, NumItems(rcwName)));
		(*pfnDump)(L"\t\t\tName:              %s\n", rcwName);
		(*pfnDump)(L"\t\t\tfFlags:            0x%02x\n", pIndexDef->fFlags);
		(*pfnDump)(L"\t\t\tiRowThreshold:     %d\n", (int) pIndexDef->iRowThreshold);
		(*pfnDump)(L"\t\t\tiIndexNum:         %d\n", (int) pIndexDef->iIndexNum);
		(*pfnDump)(L"\t\t\tfIndexType:        %d\n", (int) pIndexDef->fIndexType);
		if (pIndexDef->fIndexType == IT_HASHED)
		{
			(*pfnDump)(L"\t\t\tiBuckets:          %d\n", (int) pIndexDef->HASHDATA.iBuckets);
			(*pfnDump)(L"\t\t\tiMaxCollisions:    %d\n", (int) pIndexDef->HASHDATA.iMaxCollisions);
			(*pfnDump)(L"\t\t\tiNextOffset:       %d\n", (int) pIndexDef->HASHDATA.iNextOffset);
		}
		else
		{
			(*pfnDump)(L"\t\t\tfOrder:            %d\n", (int) pIndexDef->SORTDATA.fOrder);
		}

		(*pfnDump)(L"\t\t\tiKeys:             %d\n", (int) pIndexDef->iKeys);
		for (k=0;  k<pIndexDef->iKeys;	k++)
		{
			(*pfnDump)(L"\t\t\trgKeys[%02d]:        %02d\n", k, (int) pIndexDef->rgKeys[k]);	
		}
	}

	return (S_OK);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgsortedindex.cpp ===
//*****************************************************************************
// StgSortedIndex.cpp
// 
// This module contains StgSortedIndex Class. This class provides alternate index
// types to the previously provided hashed index type. The index enables multiple
// column keys and queries. The order of the data can be ascending or descending.
// This index also allows unique data entries.
//
// The format of a sorted index stream is as follows:
//	+-----------------------------------------------+
//	| STGINDEXHDR									|
//	| Unsigned compressed int count of rids			|
//	| 1, 2, or 4 byte array of RID entries			|
//	+-----------------------------------------------+
// The RID list contains the record ids sorted in order by the index criteria.
// The size of a RID can be 1, 2, or 4 bytes based on the highest valued RID
// that occured during save.  Note that the count of rid entries may not match
// the cardinality of the table.  This will happen when null values occur in the
// user data.  Nulls records are never stored in the index.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard includes.
#include "Errors.h"						// Error handling.
#include "StgSortedIndex.h"				// Our definitions.
#include "StgRecordManager.h"			// The record manager interface.
#include "StgSchema.h"					// Access to schema data.
#include "StgConstantData.h"			// Well known constant values.


//********** Locals. **********************************************************
int _BindingsContainNullValue(ULONG iColumns, DBBINDING rgBinding[], const BYTE *pData);
int _UpdatesRelevent(STGINDEXDEF *pIndexDef, USHORT iColumns, DBBINDING rgBindings[]);

#ifdef _DEBUG
HRESULT _DbgCheckIndexForNulls(STGTABLEDEF *pTableDef, USHORT iColumns,
			DBBINDING rgBinding[]);
#endif


//********** Code. ************************************************************


//*****************************************************************************
// Opens the index on top of the given table.
//*****************************************************************************
HRESULT StgSortedIndex::Open(			// Return status.
	UINT_PTR	iIndexDef,				// The definition of the index.
	StgRecordManager *pRecordMgr,		// The record manager that owns us.
	RECORDHEAP	*pRecordHeap,			// The first heap for this table.
	ULONG		iRecords,				// If -1, unknown.
	STGINDEXHDR	*pIndexHdr,				// persisted index header data.
	ULONG		*pcbSize)				// Return size of index data.
{
	const void	*pbData;
	HRESULT		hr = S_OK;

	m_pRecordHeap = pRecordHeap;
	m_cbIndexDef = iIndexDef;
	m_pRecordMgr = pRecordMgr;

	m_Data.SetIndexData(pRecordHeap, pRecordMgr, (ULONG) iIndexDef);
	
	if (pcbSize)
		*pcbSize = sizeof(STGINDEXHDR);

	// if we've provided pIndexHdr, initialize the cache using that.
	if (pIndexHdr && iRecords != 0xffffffff)
	{
		// First read the compressed count from the stream.
		iRecords = CPackedLen::GetLength(pIndexHdr + 1, &pbData);
	
		// Now init the heap on top of the actual data.
		m_Data.InitOnMem(iRecords, (BYTE *) pbData);
	
		// Return to caller the size of this index data.
		if (pcbSize)
		{
			*pcbSize += CPackedLen::Size(iRecords);
			*pcbSize += iRecords * m_Data.GetElemSize();
			*pcbSize = ALIGN4BYTE(*pcbSize);
		}
	}

	return (hr);
}

//*****************************************************************************
// Close the index and free any run-time state.
//*****************************************************************************
void StgSortedIndex::Close()
{
}


//*****************************************************************************
// Returns the save size of this index object based on current data.
//*****************************************************************************
HRESULT StgSortedIndex::GetSaveSize(	// Return status.
	ULONG		iIndexSize,				// Size of an index offset.
	ULONG		*pcbSave,				// Return save size here.
	ULONG		RecordCount)			// Total records to save, excluding deleted.
{
	*pcbSave = m_Data.GetSaveSize(RecordCount);
	*pcbSave += sizeof(STGINDEXHDR);
	*pcbSave += CPackedLen::Size(m_Data.Count());
	*pcbSave = ALIGN4BYTE(*pcbSave);

	DEBUG_STMT(m_cbDebugSaveSize = *pcbSave);
	return (S_OK);
}


//*****************************************************************************
// Persist the index data into the stream.
//*****************************************************************************
HRESULT StgSortedIndex::SaveToStream(	// Return status.
	IStream		*pIStream,				// Stream to save to.
	long		*pMappingTable,			// rid mapping table.
	ULONG		RecordCount)			// Total records to save, excluding deleted.
{
	STGINDEXHDR	sHeader;				// Header for the index.
	ULONG		iCount = 0;				// The count of records for rid list.
	int			cbLenSize;				// How big is each rid in saved data.
	HRESULT		hr;

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// Init the header with the bucket count for this definition.
	memset(&sHeader, 0, sizeof(STGINDEXHDR));
	sHeader.iBuckets = 0xff;		
	sHeader.fFlags = pThisIndexDef->fFlags;
	sHeader.iIndexNum = pThisIndexDef->iIndexNum;
	sHeader.rcPad[0] = MAGIC_INDEX;

	// Write the header.
	if (FAILED(hr = pIStream->Write(&sHeader, sizeof(STGINDEXHDR), 0)))
		goto ErrExit;

	// Now write the true save count, which is the number of rids in our list.
	cbLenSize = (int)((BYTE *) CPackedLen::PutLength(&iCount, m_Data.Count()) - (BYTE *) &iCount);
	if (FAILED(hr = pIStream->Write(&iCount, cbLenSize, 0)))
		goto ErrExit;
	_ASSERTE((cbLenSize % CSortedIndexHelper::GetSizeForCount(RecordCount)) == 0);

	// Now save the actual rid data.
	hr = m_Data.SaveToStream(pIStream, pMappingTable, RecordCount, cbLenSize);

ErrExit:
	return (hr);
}


//*****************************************************************************
// Called by the record manager's Save() method before it tells the page
// manager to flush all changed pages to disk.  The index should perform any
// changes it needs before this event.
//*****************************************************************************
HRESULT StgSortedIndex::BeforeSave()
{
	HRESULT		hr = E_NOTIMPL;

	return (hr);
}


//*****************************************************************************
// Called after a new row has been inserted into the table.  The index should
// update itself to reflect the new row.
//*****************************************************************************
HRESULT StgSortedIndex::AfterInsert(	// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// Record after insert.
	int			bCheckDupes)			// true to enforce duplicates.
{
	DBBINDING	*rgColBindings;			// Our internal bindings.
	PROVIDERDATA *rgData;				// Pointers to data.
	STGINDEXDEF *pIndexDef = GetIndexDef();
	int			bNulls;					// true if null values present.
	HRESULT		hr;

	_ASSERTE(pIndexDef != NULL);

	//
	// Step 1:  Check state, see if there is anything to do.
	//

	// If we are deferring create of the index, then return right now.
	if (pIndexDef->fFlags & DEXF_DEFERCREATE)
	{
		hr = S_OK;
		goto ErrExit;
	}


	//
	// Step 2:  Check for null value compatibility.
	//

	// Set up binding descriptions for this record type.	
	VERIFY(rgColBindings = (DBBINDING *) _alloca(pIndexDef->iKeys * sizeof(DBBINDING)));
	VERIFY(rgData = (PROVIDERDATA *) _alloca(pIndexDef->iKeys * sizeof(PROVIDERDATA)));

	// Get binding values for this record for the hash code to use.
	if (FAILED(hr = m_pRecordMgr->GetBindingsForColumns(pTableDef, psRecord,
			pIndexDef->iKeys, &pIndexDef->rgKeys[0], rgColBindings, rgData)))
		goto ErrExit;

	// Scan for null values in the user data.
	bNulls = _BindingsContainNullValue(pIndexDef->iKeys, rgColBindings, 
				(const BYTE *) &rgData[0]);

	// Disallow any null values in primary key, unique indexes.
	if (bNulls && (pIndexDef->IsUnique() || pIndexDef->IsPrimaryKey()))
	{
		hr = PostError(CLDB_E_INDEX_NONULLKEYS);
		goto ErrExit;
	}

	// If there are nulls, they don't go in the index.
	if (bNulls)
	{
		hr = S_OK;
		goto ErrExit;
	}



	//
	// Step 3:  Check for duplicate key violation.
	//

	// Check to see if there is a duplicate record error.
	if (FAILED(hr = IsDuplicateRecord(pIndexDef, (BYTE *) &rgData[0], 
				pIndexDef->iKeys, rgColBindings)))
		goto ErrExit;

	
	//
	// Step 4:  Need to update the index.
	//

	// finally insert the entry.
	hr = m_Data.InsertIndexEntry(RecordID, (BYTE *)rgData, 
				pIndexDef->iKeys, rgColBindings);

ErrExit:
	return (hr);
}


//*****************************************************************************
// Called after a row is deleted from a table.  The index must update itself
// to reflect the fact that the row is gone.
//*****************************************************************************
HRESULT StgSortedIndex::AfterDelete(	// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord)				// The record to delete.
{
	HRESULT		hr;
	
	// If we are deferring create of the index, then return right now.
	if (GetIndexDef()->fFlags & DEXF_DEFERCREATE)
		hr = S_OK;
	// else update the index by removing the rid from the list, if found.
	else
		hr = m_Data.RemoveIndexEntry(RecordID, TRUE);
	return (hr);
}


//*****************************************************************************
// Called before an update is applied to a row.  The data for the change is
// included.  The index must update itself if and only if the change in data
// affects the order of the index.
//*****************************************************************************
HRESULT StgSortedIndex::BeforeUpdate(	// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// Record to be changed.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	STGINDEXDEF *pIndexDef = GetIndexDef();
	HRESULT		hr = E_NOTIMPL;

	_ASSERTE(pIndexDef != NULL);
	
	// If we are deferring create of the index, then return right now.
	if (pIndexDef->fFlags & DEXF_DEFERCREATE)
	{
		hr = S_OK;
		goto ErrExit;
	}

	// Ignore this index if it doesn't afect us.
	if (_UpdatesRelevent(pIndexDef, iColumns, rgBindings) == false)
		return (S_OK);

	// Finally try to remove the record if found in the rid list.
	hr = m_Data.RemoveIndexEntry(RecordID, false);
	if (FAILED(hr))
		goto ErrExit;

ErrExit:
	return (hr);
}


//*****************************************************************************
// Called after a row has been updated.  This is our chance to update the
// index with the new column data.
//*****************************************************************************
HRESULT StgSortedIndex::AfterUpdate(	// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// Record to be changed.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	DBBINDING	*rgColBindings;			// Our internal bindings.
	PROVIDERDATA *rgData;				// Pointers to data.
	STGINDEXDEF *pIndexDef = GetIndexDef();
	int			bNulls;					// true if null values present.
	HRESULT		hr;

	_ASSERTE(pIndexDef != NULL);

	//
	// Step 1:  Check state, see if there is anything to do.
	//

	// If we are deferring create of the index, then return right now.
	if (pIndexDef->fFlags & DEXF_DEFERCREATE)
	{
		hr = S_OK;
		goto ErrExit;
	}

	// Ignore this index if it doesn't afect us.
	if (_UpdatesRelevent(pIndexDef, iColumns, rgBindings) == false)
	{
		hr = S_OK;
		goto ErrExit;
	}


	//
	// Step 2:  Check for null value compatibility.
	//

	// Set up binding descriptions for this record type.	
	VERIFY(rgColBindings = (DBBINDING *) _alloca(pIndexDef->iKeys * sizeof(DBBINDING)));
	VERIFY(rgData = (PROVIDERDATA *) _alloca(pIndexDef->iKeys * sizeof(PROVIDERDATA)));

	// Get binding values for this record for the hash code to use.
	if (FAILED(hr = m_pRecordMgr->GetBindingsForColumns(pTableDef, psRecord,
			pIndexDef->iKeys, &pIndexDef->rgKeys[0], rgColBindings, rgData)))
		goto ErrExit;

	// Scan for null values in the user data.
	bNulls = _BindingsContainNullValue(pIndexDef->iKeys, rgColBindings, 
				(const BYTE *) &rgData[0]);

	// Disallow any null values in primary key, unique indexes.
	if (bNulls && (pIndexDef->IsUnique() || pIndexDef->IsPrimaryKey()))
	{
		hr = PostError(CLDB_E_INDEX_NONULLKEYS);
		goto ErrExit;
	}

	// If there are nulls, they don't go in the index.
	if (bNulls)
	{
		hr = S_OK;
		goto ErrExit;
	}


	//
	// Step 3:  Check for duplicate key violation.
	//

	// Check to see if there is a duplicate record error.
	if (FAILED(hr = IsDuplicateRecord(pIndexDef, (BYTE *) psRecord, 
				pIndexDef->iKeys, rgColBindings)))
		goto ErrExit;

	
	//
	// Step 4:  Need to update the index.
	//

	// finally insert the entry.
	hr = m_Data.InsertIndexEntry(RecordID, (BYTE *)rgData, pIndexDef->iKeys, rgColBindings);

ErrExit:
	return (hr);
}


//*****************************************************************************
// Looks up the given record given the column information.  The user data must
// match the data types of the indexed data exactly, no conversions are done.
// The order of the user columns must match the index definition exactly, no
// attempt to sort the columns is made.
// NOTE: This function must be used in cases where the expected number of rows
// is small and overhead of using the bitVector like in the overloaded findRecord()
// function is unnecessary. This choice is left for the caller.
//*****************************************************************************
HRESULT StgSortedIndex::FindRecord(		// Return code.
	BYTE		*pData,					// User data.
	ULONG		iColumns,				// How many columns.
	DBBINDING	rgBindings[],			// Column accessors.
	DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the key columns.
	CFetchRecords *pFetchRecords,		// Return list of records here.
	BYTE		*pbFilterData,			// Filter data.
	ULONG		iFilterColumns,			// How many additional filter columns.
	DBBINDING	rgFilterBindings[],		// Bindings for filter data.
	DBCOMPAREOP	rgfCompare[])			// Filter comparison operators.
{
	long		recordIndex;
	RECORDID	RecordID;
	STGRECORDHDR *psRecord;
	RECORD		*pRecord;
	ULONG		iFetched = 0;			// Track how many we add.
	STGINDEXDEF *pIndexDef = GetIndexDef();
	int			iRecCount = m_Data.Count();
	HRESULT		hr = CLDB_E_RECORD_NOTFOUND;


	//
	// Step 1:  Look for a record that meets the critera using a b-search.
	//
	
	// Use the rid array to find the data in the index.
	recordIndex = m_Data.FindFirst(pData, iColumns, rgBindings, rgfBindingCompare);

	// If there were null values in the user's data for the index, we will never
	// find them because nulls are not stored in an index.
	//
	// @future:  There are some smarter things we can do besides a table scan here.
	// for example, if the expression is "c == null", then the answer can be formulated
	// by or'ing in all rids from the index and negating the results.  The bits left
	// by definition are non-null (or deleted, which is handled by the caller), since
	// the index never stores null value records.  Another case is the expression
	// "c != null", which is is all records in the index.  I didn't feel that these
	// two optimization were sufficiently interesting to invest the dev and test time
	// at this point.  If there is time in the future, or these queries turn out to
	// be common, we can add this optimization later.
	//
	if (recordIndex == SORT_NULL_VALUES)
		return (CLDB_S_INDEX_TABLESCANREQUIRED);


	//
	// Step 2:  There may duplicate records that come before the record we landed on,
	//			search for them.
	//

	for (int i = recordIndex; i<iRecCount; i++)
	{
		RecordID = m_Data.Get(i);
		psRecord = m_pRecordHeap->GetRecordByIndex(RecordID);
			
		if (m_pRecordMgr->CompareKeys(pIndexDef, psRecord,
					pData, iColumns, rgBindings, rgfBindingCompare) != 0)
		{
			break;						// If CompareKeys() fails, then we can break out
										// out of the loop since the array is sorted.
		}

		if (iFilterColumns && 
				m_pRecordMgr->QueryFilter(psRecord, iFilterColumns,
					rgFilterBindings, pbFilterData, rgfCompare) != 0)
		{
			continue;					// continue since there might be other records 
										// meeting the user's criteria.
		}

		// This one matched, so add it to the user's array.
		if (FAILED(hr = pFetchRecords->AddRecordToRowset(psRecord,
			&RecordID, pRecord)))
			break;
		++iFetched;		
	}


	//
	// Step 3:  There may duplicate records that come after the record we landed on,
	//			search for them.
	//

	for (int j = recordIndex; j >= 0; j--)
	{
		RecordID = m_Data.Get(j);
		psRecord = m_pRecordHeap->GetRecordByIndex(RecordID);
			
		if (m_pRecordMgr->CompareKeys(pIndexDef, psRecord,
					pData, iColumns, rgBindings, rgfBindingCompare) != 0)
		{
			break;						// If CompareKeys() fails, then we can break out
										// out of the loop since the array is sorted.
		}

		if (iFilterColumns && 
				m_pRecordMgr->QueryFilter(psRecord, iFilterColumns,
					rgFilterBindings, pbFilterData, rgfCompare) != 0)
		{
			continue;					// continue since there might be other records 
										// meeting the user's criteria.
		}

		// This one matched, so add it to the user's array.
		if (FAILED(hr = pFetchRecords->AddRecordToRowset(psRecord,
			&RecordID, pRecord)))
			break;
		++iFetched;		
	}

	return (hr);
}

//*****************************************************************************
// Looks up the given record given the column information.  The user data must
// match the data types of the indexed data exactly, no conversions are done.
// The order of the user columns must match the index definition exactly, no
// attempt to sort the columns is made.
// This function fills the bitVector, which is externally used to fill a cursor 
// (typically)
// NOTE: This function expects that when it has been called, either the first column
// comparator is not "NE" or if it is, then there is only one provided filter. The 
// reason for this is that in case of multiple column searches with "NE", the
// the function touches all the records in the table anyway. Since this is the
// case, might as well switch to a table scan with the appropriate filters.
//*****************************************************************************
HRESULT StgSortedIndex::FindRecord(		// Return code.
	BYTE		*pData,					// User data.
	ULONG		iKeyColumns,			// key columns of binding arrays.
	ULONG		iColumns,				// How many columns. (total including keys)
	DBBINDING	rgBindings[],			// Column accessors.
	DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the key columns.
	CDynBitVector *pBits,				// bit vector for matching records.
	int			iLevel)					// level of the query. 0 - highest.
{
	long		recordIndex;
	bool		bNECol = FALSE;
	HRESULT		hr;

	if (rgfBindingCompare[0] == DBCOMPAREOPS_NE)
	{
		// temporarily change the operator to EQ. This will be undone further on.
		bNECol = TRUE;
		rgfBindingCompare[0] = DBCOMPAREOPS_EQ;
	}

	// using the key columns, first narrow down the search.
	recordIndex = m_Data.FindFirst(pData, iKeyColumns, rgBindings, rgfBindingCompare);

	if (recordIndex >= 0)
		hr = S_OK;
	else 
	{
		hr = CLDB_E_RECORD_NOTFOUND;
		goto ErrExit;
	}
	
	if (!bNECol)
	{
		// call the RangeScan Function in the forward and reverse directions.
		RangeScan(pData, iKeyColumns, iColumns, rgBindings, 
			rgfBindingCompare, 0, recordIndex - 1, DIRECTION_REVERSE, pBits);
				
		RangeScan(pData, iKeyColumns, iColumns, rgBindings, 
				rgfBindingCompare, recordIndex, m_Data.Count() - 1, DIRECTION_FORWARD, pBits);
	}
	else
	{
		// we search for a range where the equality condition is met and then not that vector.
		RangeScan(pData, iKeyColumns, iKeyColumns, rgBindings, 
				rgfBindingCompare, 0, recordIndex - 1, DIRECTION_REVERSE, pBits);
				
		RangeScan(pData, iKeyColumns, iKeyColumns, rgBindings, 
				rgfBindingCompare, recordIndex, m_Data.Count() - 1, DIRECTION_FORWARD, pBits);

		// since our search was based on equality, flip all the bits turned on to get
		// what we were really interested in.
		pBits->NotBits();

		// set it back to what the caller sent in.
		rgfBindingCompare[0] = DBCOMPAREOPS_NE;
	}

ErrExit:
	return (hr);
}



//*****************************************************************************
// RangeScan:
//		This function scans starting from either iFirst or iLast depending upon
//		the given direction.  The function checks to see if the key columns and 
//		remaining filter criteria match.  It stops looping when the only the 
//		key columns no longer match.
//*****************************************************************************
HRESULT StgSortedIndex::RangeScan(
	BYTE		*pData,					// User data.
	ULONG		iKeyColumns,			// key colummns
	ULONG		iColumns,				// How many columns.
	DBBINDING	rgBindings[],			// Column accessors.
	DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the key columns.
	int			iFirst,					// start of range.
	int			iLast,					// end of range.
	BYTE		fDirection,				// forward or reverse.
	CDynBitVector *pBits)				// Bit Vector.
{
	RECORDID	RecordID;
	STGRECORDHDR *psRecord;
	ULONG		iDexBindings = iColumns - iKeyColumns;
	int			iCount;
	int			iLoop;
	int			i;
	
	_ASSERTE(pBits != NULL);

	iCount = iLast - iFirst + 1;
	if (fDirection == DIRECTION_FORWARD)
	{
		iLoop = +1;
		i = iFirst;
	}
	else
	{
		// assume reverse direction.
		iLoop = -1;
		i = iLast;
	}

	for (; iCount--; i += iLoop)
	{
		RecordID = m_Data.Get(i);
		psRecord = m_pRecordHeap->GetRecordByIndex(RecordID);	
		
		// first check to see if the keys columns match. 
		// The premise here is that since the key data is sorted, once that match fails,
		// we can safely terminate the loop.Alternatively, if the remaining filter information
		// fails, continue checking the remaining records with matching key columns.
		if (m_pRecordMgr->QueryFilter(psRecord, iKeyColumns, rgBindings, 
			pData, rgfBindingCompare) == 0)
		{
			if (iDexBindings && 
				m_pRecordMgr->QueryFilter(psRecord, iDexBindings,
				&rgBindings[iKeyColumns], pData, 
				&rgfBindingCompare[iKeyColumns]) != 0)
			{
				continue;					// continue since there might be other records 
											// meeting the user's criteria.
			}
		}
		else
		{
			break;
		}

		// set the appropriate bit.
		pBits->SetBit(RecordID, TRUE);
	}

	return (S_OK);
}


//*****************************************************************************
// Returns the indentifier for this index type.
//*****************************************************************************
BYTE StgSortedIndex::GetIndexType()
{
	STGINDEXDEF * pIndexDef = GetIndexDef();
	return ((BYTE) pIndexDef->fIndexType);
}


//*****************************************************************************
// Return the index definition for this item.
//*****************************************************************************
STGINDEXDEF * StgSortedIndex::GetIndexDef()	// The definition of the index.
{
	_ASSERTE(m_pRecordMgr && m_cbIndexDef > sizeof(STGTABLEDEF));
	
	// Find the index in the table definition.
	STGTABLEDEF *pTbl = m_pRecordMgr->GetTableDef();
	STGINDEXDEF *pDex = (STGINDEXDEF *) ((UINT_PTR) pTbl + m_cbIndexDef);

	// In debug, validate that either we have too many keys to have the magic
	// byte, or that it is there.
	_ASSERTE(pDex->iKeys >= DFTKEYS || pDex->rgKeys[DFTKEYS - 1] == MAGIC_INDEX);
	return (pDex);
}


//*****************************************************************************
// Get the name of this index into a buffer suitable for things like errors.
//*****************************************************************************
HRESULT StgSortedIndex::GetIndexName(	// Return code.
	LPWSTR		szName,					// Name buffer.
	int			cchName)				// Max name.
{
	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	return (m_pRecordMgr->GetSchema()->pNameHeap->GetStringW(
			pThisIndexDef->Name, szName, cchName));	
}


//*****************************************************************************
// If the index is unique or a primary key, then guarantee that this update
// does not cause a duplicate record.  Return an error if it does.
//*****************************************************************************
HRESULT StgSortedIndex::IsDuplicateRecord( // Return code.
	STGINDEXDEF *pIndexDef,				// Index definition.
	BYTE		*pData,					// User data.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	long		recordIndex;			// Index for record if found.
	HRESULT		hr = S_OK;

	// If this is a unique index, look for duplicates first.
	if (pIndexDef->IsUnique() || pIndexDef->IsPrimaryKey()) 
	{
		// Don't allow null value in unique/pk indexes.
		_ASSERTE(_DbgCheckIndexForNulls(m_pRecordMgr->GetTableDef(), iColumns, rgBindings) == S_OK);

		// Lookup the record.  If not found, that's good.
		recordIndex = m_Data.FindFirst(pData, iColumns, rgBindings, (ULONG *) g_rgCompareEq);
		if (recordIndex < 0)
			hr = S_OK;
		// Else the user attempted to insert a duplicate record which cannot
		// be allowed.  Give back an error in this case.
		else
		{
			WCHAR	rcwName[MAXINDEXNAME];
			GetIndexName(rcwName, MAXINDEXNAME);
			hr = PostError(CLDB_E_INDEX_DUPLICATE, rcwName);
		}
	}
	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgsave.cpp ===
//*****************************************************************************
// StgSave.cpp
//
// This module contains the Save code for the database storage system.  This
// includes the code to persist each table into a stream, determine what
// gets saved, and figure out the save size for a persistent implementation.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Standard header.

#include "StgSchema.h"                  // Core schema defs.
#include "StgDatabase.h"                // Database definitions.
#include "StgRecordManager.h"           // Record api.
#include "StgIO.h"                      // Raw Input/output.
#include "StgTiggerStorage.h"           // Storage based i/o.

#if defined(UNDER_CE)

HRESULT StgDatabase::SetSaveFile(LPCWSTR szDatabase)
	{ return E_NOTIMPL; }
HRESULT STDMETHODCALLTYPE StgDatabase::GetSaveSize(CorSaveSize fSave, DWORD *pdwSaveSize)
	{ return E_NOTIMPL; }
HRESULT StgDatabase::Save(IStream *pIStream)
	{ return E_NOTIMPL; }

#else // defined(UNDER_CE)
//********** Types. ***********************************************************

// Comment this out to disable the automatic exception handling code used
// on save to ensure better durability.  This should always be defined in
// retail mode, but is useful for catching errors in debug mode.
#ifndef _DEBUG
#define _CATCH_COMMIT_EXCEPTIONS_
#endif


//********** Locals. **********************************************************
HRESULT _PrepareSaveSchema(SCHEMADEFS *pTo, SCHEMADEFS *pFrom);
void _DestroySaveSchema(SCHEMADEFS *pSchema);
HRESULT _AddStreamToList(STORAGESTREAMLST *pStreamList, ULONG cbSize, const WCHAR *szName);




//********** Code. ************************************************************


//*****************************************************************************
// Allow deferred setting of save path.
//*****************************************************************************
HRESULT StgDatabase::SetSaveFile(       // Return code.
    LPCWSTR     szDatabase)             // Name of file.
{
    TiggerStorage *pStorage=0;          // IStorage object.
    StgIO       *pStgIO=0;              // Backing storage.
    HRESULT     hr = S_OK;

    // Allow for same name, case of multiple saves during session.
    if (_wcsicmp(szDatabase, m_rcDatabase) == 0)
        return (S_OK);
    // Changing the name on a scope which is already opened is not allowed.
    // There isn't enough context to allow this, since it could mean
    // format conversion and other issues.  To do this with the IMetaData*
    // interfaces, open the file you want to Save As and merge it to another
    // emit scope.
    else if (*m_rcDatabase)
    {
        _ASSERTE(!"Not allowed to rename current scope!");
        return (E_INVALIDARG);
    }

    // Sanity check the name.
    if (lstrlenW(szDatabase) >= _MAX_PATH)
        return (PostError(E_INVALIDARG));

//@todo: This path and save to stream need a output type value.  Technically
// we can't always know by path what it is.
    {
        WCHAR       rcExt[_MAX_PATH];

        // Otherwise get the path type and compare.
        SplitPath(szDatabase, 0, 0, 0, rcExt);
        if (_wcsicmp(rcExt, L".class") == 0)
            m_eFileType = FILETYPE_CLASS;
        else
            m_eFileType = FILETYPE_CLB;
    }

    // Delegate the open to the correct place.
    if (m_eFileType == FILETYPE_CLB)
    {
        // Allocate a new storage object.
        if ((pStgIO = new StgIO) == 0)
        {
            hr = PostError(OutOfMemory());
            goto ErrExit;
        }

        // Create the output file.
        if (FAILED(hr = pStgIO->Open(szDatabase, DBPROP_TMODEF_DFTWRITEMASK)))
            goto ErrExit;

        // Allocate an IStorage object to use.
        if ((pStorage = new TiggerStorage) == 0)
        {
            hr = PostError(OutOfMemory());
            goto ErrExit;
        }

        // Init the storage object on the i/o system.
        if (FAILED(hr = pStorage->Init(pStgIO)))
            goto ErrExit;

        // Save the storage pointer.
        m_pStorage = pStorage;
    }

ErrExit:
    if (pStgIO)
        pStgIO->Release();
    if (FAILED(hr))
        delete pStorage;
    else
        wcscpy(m_rcDatabase, szDatabase);
    return (hr);
}


//*****************************************************************************
// Figures out how big the persisted version of the current scope would be.
// This is used by the linker to save room in the PE file format.  After
// calling this function, you may only call the SaveToStream or Save method.
// Any other function will product unpredictable results.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::GetSaveSize( // Return code.
    CorSaveSize fSave,                  // cssQuick or cssAccurate.
    DWORD       *pdwSaveSize)           // Return size of saved item.
{
    STGOPENTABLE *pTablePtr;            // Walking list of tables.
    STGTABLEDEF *pTableDef;             // Working pointer for table defs.
    STGTABLEDEF *pTableDefSave;         // Optimized format.
    SCHEMASRCH  sSrch;                  // Search structure for walking tables.
    WCHAR       rcTable[MAXTABLENAME];  // Wide name of table.
    TABLEID     tableid;                // For fast opens.
    ULONG       cbSchemaSize;           // Grand total for schema definitions.
    ULONG       cbSaveSize = 0;         // Running total for size.
	ULONG		cbHeapSize;				// Size of heap.
    int         iTables = 0;            // How many tables get saved.
    int         iCoreTable = 0;         // How many core tables.
    HASHFIND    sMapSrch;               // For iterating over UserSection map.
    TStringMap<IUserSection*>::TItemType *pIT; // Pointer to a UserSection map item.
    ULONG       cbSize;                 // An individual size.
    SAVETRACE(ULONG cbDebugPool=0);     // Track debug size of pools.
    HRESULT     hr;

    // Debug code will do some additional sanity checking for mistakes.
    DEBUG_STMT(m_dbgcbSaveSize = 0);

    // Avoid confusion.
    *pdwSaveSize = cbSaveSize;

    // Assume no schema stream to begin with.
    cbSchemaSize = 0;

	// Allocate stream list if not already done.
	if (!m_pStreamList)
	{
		m_pStreamList = new STORAGESTREAMLST;
		if (!m_pStreamList)
		{
			hr = PostError(OutOfMemory());
			goto error;
		}
	}
	else
		m_pStreamList->Clear();

    // Organize the pools so that we can get the offset sizes.
    if (FAILED(hr = SaveOrganizePools()))
        goto error;

    // Look for tables that were written to memory and now need to be persisted.
    for (pTableDef=GetFirstTable(sSrch, SCHEMASRCH_NOTEMP);
            pTableDef;  pTableDef=GetNextTable(sSrch))
    {
        ULONG       cbTableSize = 0;
        StgRecordManager *pRecordMgr;
        pTablePtr = 0;
        tableid = -1;

        // Temp tables are skipped by search.
        _ASSERTE(!pTableDef->IsTempTable());

        // Get the tableid and open table ptr if valid.  This routine will look
        // for core tables that have never been opened and will not be saved.
        if (sSrch.GetCurSchemaDex() == SCHEMA_CORE && 
                SkipSaveTable(pTableDef, pTablePtr, &tableid))
            continue;

        // Get the text name of the table.
        if (FAILED(hr = sSrch.pSchemaDef->pNameHeap->GetStringW(pTableDef->Name, rcTable, NumItems(rcTable))))
            goto error;

        // Get an open table pointer for this item.
        if (!pTablePtr && FAILED(hr = OpenTable(rcTable, pTablePtr, tableid)))
            goto error;

        // Get the record manager for this table.
        _ASSERTE(pTablePtr);
        VERIFY(pRecordMgr = &pTablePtr->RecordMgr);

        // If the table is marked delete on empty or it is a core table with
        // no records, then it is not saved.
        if (m_bEnforceDeleteOnEmpty && pRecordMgr->Records() == 0 &&
            (pTableDef->IsDeleteOnEmpty() || pTableDef->IsCoreTable()))
        {
            continue;
        }

		// If the data in the table has already been saved in a compressed stream, 
		//  don't save it again.
		if (pRecordMgr->IsSuppressSave())
			continue;

        // Ask the stream it's size.  This is the size of the optimized records
        // including any indexes, the index overhead, and any other header data
        // the SaveToStream code will generate.
        hr = pRecordMgr->GetSaveSize(&cbTableSize, &pTableDefSave);
        if (FAILED(hr))
            goto error;

        // Add the size of this schema definition into the overall size for #Schema.
        if (!pTableDef->IsCoreTable() || IsCoreTableOverride(sSrch.pSchemaDef, pTableDefSave))
        {
            cbSchemaSize += pTableDef->iSize;
            ++iTables;

            if (pTableDef->IsCoreTable())
                ++iCoreTable;
        }

        // At this point we're done with the table and record manager.
        pRecordMgr = 0;
        pTablePtr = 0;

        // Core tables are stored with a small name to minimize the
        // stream overhead.  Get that name so the stream will know the
        // size.
        if (pTableDef->IsCoreTable())
        {
            GetCoreTableStreamName(sSrch.GetCurSchemaDex(), pTableDef->tableid, 
                        rcTable, sizeof(rcTable));
        }

		// This stream will get saved, so remember it on our list.  cbTableSize contains
		// only the size of the table stream at this point, which is the correct total.
		hr = _AddStreamToList(m_pStreamList, cbTableSize, rcTable);
		if (FAILED(hr))
			goto error;

        // Ask the storage/stream implmentation to add it's overhead for this
        // table.  This is the header space and alignment it adds.
        SAVETRACE(DbgWriteEx(L"GSS:  Table %s, data size %d\n", rcTable, cbTableSize); cbDebugPool=cbTableSize);
        if (FAILED(hr = TiggerStorage::GetStreamSaveSize(rcTable, cbTableSize, &cbTableSize)))
            goto error;
        SAVETRACE(DbgWriteEx(L"GSS:  Table %s header size %d\n", rcTable, cbTableSize - cbDebugPool));

        // Let everyone know how big this table was.

        // Roll the overhead for this table into the grand total.  
        // cbTableSize contains the size of the entire table stream for this table.
        cbSaveSize = cbSaveSize + cbTableSize;
    }

    // If any schema is to be saved, add it's stream size.
    if (cbSchemaSize)
    {
        // Add room for header and 1 offset per table.
        cbSchemaSize += sizeof(STGSCHEMA) - sizeof(ULONG);
        cbSchemaSize += iTables * sizeof(ULONG);

        // Add room for core table override schema list.
        cbSchemaSize += sizeof(ULONG);
        cbSchemaSize += ALIGN4BYTE(iCoreTable);

		// Add this entry to the stream list.
		hr = _AddStreamToList(m_pStreamList, cbSchemaSize, SCHEMA_STREAM);
		if (FAILED(hr))
			goto error;

        // cbSchemaSize contains the count of bytes that go into #Schema on save.
        // Ask the storage code to add its overhead and alignment for the stream.
	    SAVETRACE(DbgWriteEx(L"GSS:  Pool %s, data size %d\n", SCHEMA_STREAM, cbSchemaSize);cbDebugPool=cbSchemaSize);
        if (FAILED(hr = TiggerStorage::GetStreamSaveSize(SCHEMA_STREAM, cbSchemaSize, &cbSchemaSize)))
            goto error;
	    SAVETRACE(DbgWriteEx(L"GSS:  Pool %s header size %d\n", SCHEMA_STREAM, cbSchemaSize-cbDebugPool));
    }

    // Now add the total #Schema overhead into the overall save size.
    cbSaveSize += cbSchemaSize;

    // Add the heaps to the total.
    if (FAILED(hr = GetPoolSaveSize(STRING_POOL_STREAM, m_UserSchema.GetStringPool(), &cbHeapSize)))
        goto error;
	cbSaveSize += cbHeapSize;

    if (FAILED(hr = GetPoolSaveSize(BLOB_POOL_STREAM, m_UserSchema.GetBlobPool(), &cbHeapSize)))
        goto error;
	cbSaveSize += cbHeapSize;

    if (FAILED(hr = GetPoolSaveSize(VARIANT_POOL_STREAM, m_UserSchema.GetVariantPool(), &cbHeapSize)))
        goto error;
	cbSaveSize += cbHeapSize;

    if (FAILED(hr = GetPoolSaveSize(GUID_POOL_STREAM, m_UserSchema.GetGuidPool(), &cbHeapSize)))
        goto error;
	cbSaveSize += cbHeapSize;


    // Ask any User Sections what their sizes will be.
    pIT = m_UserSectionMap.FindFirstEntry(&sMapSrch);
    while (pIT)
    {
        ULONG   bEmpty;
        if (FAILED(hr = pIT->m_value->IsEmpty(&bEmpty)))
            goto error;

        // Skip empty user sections.
        if (!bEmpty)
        {        
			// Get raw save size.
            pIT->m_value->GetSaveSize(&cbSize);

			// Ask the storage/stream implmentation to add it's overhead for this
			// section.  This is the header space and alignment it adds.
			if (FAILED(hr = TiggerStorage::GetStreamSaveSize(pIT->m_szString, cbSize, &cbSize)) ||
				FAILED(hr = hr = _AddStreamToList(m_pStreamList, cbSize, pIT->m_szString)))
				goto error;

            // Tell user what happened.
			SAVETRACE(DbgWriteEx(L"GSS:  User section '%s', total size %d\n", pIT->m_szString, cbSize));
            cbSaveSize += cbSize;
        }

        // Get next entry.
        pIT = m_UserSectionMap.FindNextEntry(&sMapSrch);
    }

    // Finally, ask the storage system to add fixed overhead it needs for the
    // file format.  The overhead of each stream has already be calculated as
    // part of GetStreamSaveSize.  What's left is the signature and header
    // fixed size overhead.
    SAVETRACE(cbSize = cbSaveSize);
    if (FAILED(hr = TiggerStorage::GetStorageSaveSize(&cbSaveSize, GetExtraDataSaveSize())))
        goto error;
    SAVETRACE(DbgWriteEx(L"GSS:  Storage save size, total size %d\n", cbSaveSize - cbSize));

    // Sanity check our estimates with reality.
    DEBUG_STMT(m_dbgcbSaveSize = cbSaveSize);
    SAVETRACE(DbgWriteEx(L"GSS:  Total size of all data %d\n", m_dbgcbSaveSize));

    // Return value to caller.
    *pdwSaveSize = cbSaveSize;

	// The list of streams that will be saved are now in the stream save list.
	// Next step is to walk that list and fill out the correct offsets.  This is 
	// done here so that the data can be streamed without fixing up the header.
	TiggerStorage::CalcOffsets(m_pStreamList, GetExtraDataSaveSize());

error:
    return (hr);
}


//*****************************************************************************
// Save any changes made to the database.  This involves creating an optimized
// version of each table and index, then writing those tables and special
// heaps into the file format.
//*****************************************************************************
HRESULT StgDatabase::Save(              // Return code.
    IStream     *pIStream)              // Optional override for save location.
{
    TiggerStorage *pStorage=0;          // Storage to wrap stream.
    WCHAR       rcBackup[_MAX_PATH];    // Path of the file.
	LPWSTR		szBackup = rcBackup;	// Pointer for backup.
    ULONG       cbSaveSize = 0;         // Total size of save data.
    HRESULT     hr = S_OK;

#ifdef _CATCH_COMMIT_EXCEPTIONS_
        DWORD   dwCode ;
#endif

    *rcBackup = '\0';

//@todo: We need the notion of schemas that can be dirty but we don't care.
// Temp tables fall into this category.  Right now if you create one you dirty
// the string heap and we try to save on shut down (corview.exe on a .class file).
    _ASSERTE(!IsReadOnly());

    // Have to have some place to save to.
    if (!pIStream && !m_pStorage && !IsClassFile())
        return (PostError(BadError(E_UNEXPECTED)));

    // Enforce thread safety for database.
    GetLock()->Lock();

    // If a caller override was given for save location, then attempt to wrap
    // our storage object around it.
    if (pIStream)
    {
        StgIO       *pStgIO = 0;

        // Allocate a storage subsystem and backing store.
        pStgIO = new StgIO;
        pStorage = new TiggerStorage;

        // Open around this stream for write.
        if (!pStgIO || !pStorage ||
            FAILED(hr = pStgIO->Open(L"", DBPROP_TMODEF_DFTWRITEMASK, 0, 0, pIStream)) ||
            FAILED(hr = pStorage->Init(pStgIO)))
        {
            if (pStgIO)
            {
                pStgIO->Release();
            }
            delete pStorage;
            if (SUCCEEDED(hr))
                hr = PostError(OutOfMemory());
			goto error;
        }

		// The 'new' is worth 1 ref count.  We've given ownership to the pStorage
		// and must now release our ref count for this frame.
		_ASSERTE(pStgIO);
		pStgIO->Release();
    }

	// Must call GetSaveSize to cache the streams up front.
	if (!m_pStreamList)
	{
		ULONG cb;
		if (FAILED(hr = GetSaveSize(cssAccurate, &cb)))
		{
			goto error;
		}
	}

    // Data loss is very possible here if anything should go wrong.  To keep
    // this database more robust, catch any severe problems and automatically
    // abort the changes.
#ifdef _CATCH_COMMIT_EXCEPTIONS_
    __try
#endif
    {
        // Existing file will get overwritten, need to prepare.
        if (IsExistingFile() && !IsClassFile())
        {
			// If no backup file is desired, then don't ask for one.
			if (m_fOpenFlags & DBPROP_TMODEF_NOTXNBACKUPFILE)
				szBackup = 0;

            // Fault in all the heaps, because backing storage is going away.
            //  The heaps may already have done this, to avoid handing out
            //  pointers which could change; but they may have deferred.
            if (FAILED(hr = m_UserSchema.GetStringPool()->TakeOwnershipOfInitMem()) ||
                FAILED(hr = m_UserSchema.GetBlobPool()->TakeOwnershipOfInitMem()) ||
                FAILED(hr = m_UserSchema.GetVariantPool()->TakeOwnershipOfInitMem()) ||
                FAILED(hr = m_UserSchema.GetGuidPool()->TakeOwnershipOfInitMem()))
            {
                goto error;
            }

            // Fault in all unloaded tables because our backing storage is
            // going away.  Then make a backup and truncate the file.
            if (FAILED(hr = SavePreLoadTables())||
				FAILED(hr = m_pStorage->Rewrite(szBackup)))
            {
                goto error;
            }

        }

        // Do the real save work.
        {
            // Save to our location.
            if (!pStorage)
                hr = SaveWork(m_pStorage, &cbSaveSize);
            else
                hr = SaveWork(pStorage, &cbSaveSize);

            // If it worked, reset the backing store since we don't need it.
            if (SUCCEEDED(hr) && m_pStorage && !pStorage)
                m_pStorage->ResetBackingStore();
        }

        // If save was successful, and we gave out a save size on GetSaveSize, then
        // sanity check the value to make sure it was accurate.
        _ASSERTE(FAILED(hr) || m_dbgcbSaveSize == 0xffffffff || m_dbgcbSaveSize == cbSaveSize);
        DEBUG_STMT(m_dbgcbSaveSize = 0xffffffff);
    }
    // Catch all exceptions and treat them as an abort condition.  Need to force
    // a restore of the data immediately.
#ifdef _CATCH_COMMIT_EXCEPTIONS_
    __except((dwCode = GetExceptionCode()) != 0)
    {
        _ASSERTE(0);

        // This is a severe error, so give a message even in retail mode.
        TCHAR       rcMsg[1024];
        _stprintf(rcMsg, L"COMPLIB: Fatal error during Save, backup file: %s\n", rcBackup);
        WszOutputDebugString(rcMsg);

        // Set erturn for caller.
        hr = E_UNEXPECTED;
        goto error;
    }
#endif


error:
    // Try to restore the data the way it was before.
    if (FAILED(hr))
    { 
        if (*rcBackup && !IsClassFile() && m_pStorage)
            VERIFY(m_pStorage->Restore(rcBackup, true) == S_OK);
    }
    // Clean up.
    else
    {
        // No longer have need for the backup.
        if (*rcBackup)
            ::W95DeleteFile(rcBackup);

        // Undirty all tables and pools.
        SetDirty(false);

        // The new file is now considered existing (covers Create case).
        m_fFlags |= SD_EXISTS;
    }

    // Pools can return to normal state.
    SaveOrganizePoolsEnd();

    // Give up our storage pointer if we ever obtained one.
    if (pStorage)
        delete pStorage;

    // Undo crit sec.
    GetLock()->UnLock();
    return (hr);
}


//*****************************************************************************
// This function does the real work of saving the data to disk.  It is called
// by Save() so that the exceptions can be caught without the need for stack
// unwinding.
//*****************************************************************************
HRESULT StgDatabase::SaveWork(          // Return code.
    TiggerStorage *pStorage,            // Where to save a copy of this file.
    ULONG       *pcbSaveSize)           // Optionally return save size of data.
{
    STGOPENTABLE *pTablePtr;            // Walking list of tables.
    STGTABLEDEF *pTableDef;             // Scanning tables to save.
    STGTABLEDEF *pTableDefSave;         // Save format of table def.
    SCHEMASRCH  sSrch;                  // Search structure for walking tables.
    STGSCHEMA   stgSchema;              // Persistent schema data.
    TABLEID     tableid;                // For fast opens.
    WCHAR       rcTable[MAXTABLENAME];  // Wide name of table.
    INTARRAY    rgVariants;             // Variant offsets.
    CMemChunk   rgTableData;            // Store the table data.
    BYTEARRAY   rgSchemas;              // List of schemas.
    ULONG       iSchemas = 0;           // How many schemas used for override.
    ULONG       cbExtra;                // Size of extra header.
    int         i;                      // Loop control.
    HASHFIND    sMapSrch;               // For iterating over UserSection map.
    TStringMap<IUserSection*>::TItemType *pIT; // Pointer to a UserSection map item.
    HRESULT     hr;
    SAVETRACE(ULONG cbDebugSize; ULONG cbDebugSizePrev=0);      

    _ASSERTE(GetFileType() == FILETYPE_CLB);

    // Know when a backup is present.
    *rcTable = '\0';

    // Why are you calling save in read only mode?
    if ((m_fFlags & SD_WRITE) == 0)
    {
        _ASSERTE(0);
        return (S_OK);
    }

    // Must save a copy of the heaps in-memory to use when saving the
    // string heaps to disk.  This is required so that as hash tables rebuild
    // themselves, they will pick up the correct data at the new offsets.
    SCHEMADEFS SaveSchema;
    if (FAILED(hr = _PrepareSaveSchema(&SaveSchema, &m_UserSchema)))
        goto error;

    // Init for disk save.
    memset(&stgSchema, 0, sizeof(STGSCHEMA));
    stgSchema.cbSchemaSize = sizeof(STGSCHEMA) - sizeof(stgSchema.rgTableOffset);


    // Build the extra data for the header.  This includes the next OID value
    // for this database instance, and a list of schemas that have been added
    // to this database.  User, Temp, and SymbolTable are internal schemas and
    // do not need to be saved to disk.
    {
        CQuickBytes sExtra;
        STGEXTRA    *pExtra;
        cbExtra = GetExtraDataSaveSize();
        if ((pExtra = (STGEXTRA *) sExtra.Alloc(cbExtra + sizeof(ULONG))) == 0)
        {
            hr = PostError(OutOfMemory());
            goto error;
        }

        pExtra->fFlags = m_fOpenFlags & (DBPROP_TMODEF_SLOWSAVE | DBPROP_TMODEF_COMPLUS | DBPROP_TMODEF_ALIGNBLOBS);
        pExtra->NextOid = m_iNextOid;
		*(ULONG *) (&pExtra->rgPad[0]) = 0;
		pExtra->iHashFuncIndex = GetPersistHashIndex(m_pfnHash);
        pExtra->iSchemas = m_Schemas.ExternalCount();
        
        // Fill out the schema values.
        for (int i=0;  i<m_Schemas.ExternalCount();  i++)
        {
            pExtra->rgSchemas[i].sid = m_Schemas.Get(i + SCHEMA_EXTERNALSTART)->sid;
            pExtra->rgSchemas[i].Version = m_Schemas.Get(i + SCHEMA_EXTERNALSTART)->Version;
        }

		// Save the header of the data file.
		if (FAILED(hr = pStorage->WriteHeader(m_pStreamList, cbExtra, (BYTE *) sExtra.Ptr())))
			goto error;
	}


    // Don't count file signature.
    SAVETRACE(cbDebugSizePrev = pStorage->GetStgIO()->GetCurrentOffset());


    // Look for tables that were written to memory and now need to be persisted.
    for (pTableDef=GetFirstTable(sSrch, SCHEMASRCH_NOTEMP);
            pTableDef;  pTableDef=GetNextTable(sSrch))
    {
        StgRecordManager *pRecordMgr;
        pTablePtr = 0;
        tableid = -1;

        // Temp tables are skipped by search.
        _ASSERTE(!pTableDef->IsTempTable());

        // Get the tableid and open table ptr if valid.  This routine will look
        // for core tables that have never been opened and will not be saved.
        if (sSrch.GetCurSchemaDex() == SCHEMA_CORE && 
                SkipSaveTable(pTableDef, pTablePtr, &tableid))
            continue;

        // Get the text name of the table.
        if (FAILED(hr = sSrch.pSchemaDef->pNameHeap->GetStringW(pTableDef->Name, rcTable, NumItems(rcTable))))
            goto error;

        // Get an open table pointer for this item.
        if (!pTablePtr && FAILED(hr = OpenTable(rcTable, pTablePtr, tableid)))
            goto error;

        // Get the record manager for this table.
        _ASSERTE(pTablePtr);
        VERIFY(pRecordMgr = &pTablePtr->RecordMgr);

        // If the table is marked delete on empty or it is a core table with
        // no records, then it is not saved.
        if (m_bEnforceDeleteOnEmpty && pRecordMgr->Records() == 0 &&
            (pTableDef->IsDeleteOnEmpty() || pTableDef->IsCoreTable()))
        {
            continue;
        }

		// If the data in the table has already been saved in a compressed stream, 
		//  don't save it again.
		if (pRecordMgr->IsSuppressSave())
			continue;

        CIfacePtr<IStream> pIStream;

        // Sanity check what table pointer we are using.
//@todo: hook this back up
//      _ASSERTE(GetTableDef(pRecordMgr->TableName()) == pTableDef);

        // Add this table to the list.
        pTableDefSave = (STGTABLEDEF *) rgTableData.GetChunk(pTableDef->iSize);
        if (!pTableDefSave)
        {
            hr = PostError(OutOfMemory());
            goto error;
        }

        // Core tables are stored with a small name to minimize the
        // stream overhead.
        if (pTableDef->IsCoreTable())
        {
            GetCoreTableStreamName(sSrch.GetCurSchemaDex(), pTableDef->tableid, 
                        rcTable, sizeof(rcTable));
        }

        // For every new schema found, copy the data from this schema so it matches.
        if (SaveSchema.sid != sSrch.pSchemaDef->sid)
        {
            SaveSchema.sid = sSrch.pSchemaDef->sid;
            SaveSchema.Version = sSrch.pSchemaDef->Version;
            SaveSchema.pSchema = sSrch.pSchemaDef->pSchema;
            SaveSchema.fFlags = sSrch.pSchemaDef->fFlags;
            SaveSchema.pNameHeap = sSrch.pSchemaDef->pNameHeap;
        }

        // Create the new stream to hold this table and save it.
        if (FAILED(hr = pStorage->CreateStream(rcTable, 
                STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                0, 0, &pIStream)) ||
            FAILED(hr = pRecordMgr->SaveToStream(pIStream, pTableDefSave, 
                rgVariants, &SaveSchema)))
        {
            goto error;
        }
        SAVETRACE(cbDebugSize = pStorage->GetStgIO()->GetCurrentOffset());
        SAVETRACE(DbgWriteEx(L"PSS: stream for %s, size %d\n", rcTable, cbDebugSize - cbDebugSizePrev);cbDebugSizePrev = cbDebugSize);

        // Non core tables and core table overrides are added to the #Schema stream.
        if (!m_bEnforceDeleteOnEmpty || !pTableDefSave->IsCoreTable() ||
                IsCoreTableOverride(sSrch.pSchemaDef, pTableDefSave))
        {
            if (pTableDefSave->IsCoreTable())
            {
                pTableDefSave->fFlags |= TABLEDEFF_CORE;
                stgSchema.fFlags |= STGSCHEMAF_CORETABLE;

                // This is a core table override.  Need to know its schema value.
                BYTE *piSchema = rgSchemas.Append();
                if (!piSchema)
                {
                    hr = PostError(OutOfMemory());
                    goto error;
                }
                *piSchema = sSrch.GetCurSchemaDex();
                ++iSchemas;
            }

            // Add this schema to the save list.
            stgSchema.cbSchemaSize += pTableDef->iSize;
            ++stgSchema.iTables;
        }
        else
            rgTableData.DelChunk((BYTE *) pTableDefSave, pTableDef->iSize);
    }

    // Save the schema data to the #Schema stream.
    if (stgSchema.iTables)
    {
        // Create the schema stream.
        CIfacePtr<IStream> pIStream;
        CQuickBytes rgOffsets;
        ULONG       *pcbOffset;
        ULONG       cbOffsetSize;
        ULONG       cbSchemas;

        // Create the new stream to hold this table and save it.
        if (FAILED(hr = pStorage->CreateStream(SCHEMA_STREAM, 
                STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                0, 0, &pIStream)))
            goto error;

        // If there were core table overrides, add the schema.
        if (FAILED(hr = pIStream->Write(&iSchemas, sizeof(ULONG), 0)))
            goto error;
        if (iSchemas && FAILED(hr = pIStream->Write(rgSchemas.Ptr(), rgSchemas.Count(), 0)))
            goto error;
        
        // Align it to a four byte boundary.
        if (ALIGN4BYTE(rgSchemas.Count()) != rgSchemas.Count())
        {
            if (FAILED(hr = pIStream->Write(&cbOffsetSize, 
                    ALIGN4BYTE(rgSchemas.Count()) - rgSchemas.Count(), 0)))
                goto error;
        }
        cbSchemas = sizeof(ULONG) + ALIGN4BYTE(rgSchemas.Count());

        // Allocate room for an array of offsets.
        cbOffsetSize = sizeof(ULONG) * stgSchema.iTables;
        pcbOffset = (ULONG *) rgOffsets.Alloc(cbOffsetSize);
        if (!pcbOffset)
        {
            hr = PostError(OutOfMemory());
            goto error;
        }

        // Fill out the array.
        *pcbOffset = sizeof(STGSCHEMA) - sizeof(stgSchema.rgTableOffset) + cbOffsetSize;
        pTableDef = (STGTABLEDEF *) rgTableData.Ptr();
        for (i=1;  i<stgSchema.iTables;  i++, pcbOffset++)
        {
            *(pcbOffset + 1) = *pcbOffset + pTableDef->iSize;
            pTableDef = pTableDef->NextTable();
        }

        // Write out the header for the schema stream.
        stgSchema.cbSchemaSize = stgSchema.cbSchemaSize + cbOffsetSize;
        if (FAILED(hr = pIStream->Write(&stgSchema, sizeof(STGSCHEMA) - sizeof(stgSchema.rgTableOffset), 0)))
            goto error;

        // Now the offset array.
        if (FAILED(hr = pIStream->Write(rgOffsets.Ptr(), cbOffsetSize, 0)))
            goto error;

        // Finally the actual data.
        if (FAILED(hr = pIStream->Write(rgTableData.Ptr(), rgTableData.Offset(), 0)))
            goto error;

        SAVETRACE(cbDebugSize = pStorage->GetStgIO()->GetCurrentOffset());
        SAVETRACE(DbgWriteEx(L"PSS: SCHEMA size %d\n", cbDebugSize - cbDebugSizePrev);cbDebugSizePrev = cbDebugSize);
    }

	{
        // Save each of the pools to disk.
        if (FAILED(hr = SavePool(STRING_POOL_STREAM, pStorage, SaveSchema.GetStringPool())))
            goto error;
        SAVETRACE(cbDebugSize = pStorage->GetStgIO()->GetCurrentOffset());
        SAVETRACE(DbgWriteEx(L"PSS: String Pool size %d\n", cbDebugSize - cbDebugSizePrev);cbDebugSizePrev = cbDebugSize);

        if (FAILED(hr = SavePool(BLOB_POOL_STREAM, pStorage, SaveSchema.GetBlobPool())))
            goto error;
        SAVETRACE(cbDebugSize = pStorage->GetStgIO()->GetCurrentOffset());
        SAVETRACE(DbgWriteEx(L"PSS: Blob Pool size %d\n", cbDebugSize - cbDebugSizePrev);cbDebugSizePrev = cbDebugSize);

        if (FAILED(hr = SavePool(VARIANT_POOL_STREAM, pStorage, SaveSchema.GetVariantPool())))
            goto error;
        SAVETRACE(cbDebugSize = pStorage->GetStgIO()->GetCurrentOffset());
        SAVETRACE(DbgWriteEx(L"PSS: Variant Pool size %d\n", cbDebugSize - cbDebugSizePrev);cbDebugSizePrev = cbDebugSize);

        if (FAILED(hr = SavePool(GUID_POOL_STREAM, pStorage, SaveSchema.GetGuidPool())))
            goto error;
        SAVETRACE(cbDebugSize = pStorage->GetStgIO()->GetCurrentOffset());
        SAVETRACE(DbgWriteEx(L"PSS: GUID Pool size %d\n", cbDebugSize - cbDebugSizePrev);cbDebugSizePrev = cbDebugSize);

        // Ask any User Sections to save themselves.
        pIT = m_UserSectionMap.FindFirstEntry(&sMapSrch);
        while (pIT)
        {
            if (FAILED(hr = SaveUserSection(pIT->m_szString, pStorage, pIT->m_value)))
                goto error;

			SAVETRACE(cbDebugSize = pStorage->GetStgIO()->GetCurrentOffset());
			SAVETRACE(DbgWriteEx(L"PSS: User section '%s': %d\n", pIT->m_szString, cbDebugSize - cbDebugSizePrev);cbDebugSizePrev = cbDebugSize);
            
			pIT = m_UserSectionMap.FindNextEntry(&sMapSrch);
		}

        // Write the header to disk.
		if (FAILED(hr = pStorage->WriteFinished(m_pStreamList, pcbSaveSize)))
			goto error;
		SAVETRACE(DbgWriteEx(L"PSS: Overall image size %d\n", *pcbSaveSize));
    }


error:
    // Cleanup.
    _DestroySaveSchema(&SaveSchema);
	delete m_pStreamList;
	m_pStreamList = 0;
    return (hr);
}


//*****************************************************************************
// Save a User Section to the database.
//*****************************************************************************
HRESULT StgDatabase::SaveUserSection(   // Return code.
    LPCWSTR     szName,                 // Name of the Section.
    TiggerStorage *pStorage,            // Storage to put data in.
    IUserSection *pISection)            // Section to put into it.
{
    CIfacePtr<IStream> pIStream;        // For writing.
    ULONG       bEmpty;
    HRESULT     hr;

    // If there is no data, then don't bother.
    if (FAILED(hr=pISection->IsEmpty(&bEmpty)))
        return (hr);
    else
    if (bEmpty)
        return (S_OK);

    // Create the new stream to hold this table and save it.
    if (FAILED(hr = pStorage->CreateStream(szName, 
            STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
            0, 0, &pIStream)) ||
        FAILED(hr = pISection->PersistToStream(pIStream)))
        return (hr);
    return (S_OK);
}


//*****************************************************************************
// Organize the pools, so that the live data is known.  This eliminates 
//  deleted and temporary data from the persistent data.  This step also lets
//  the pools give a correct size for their cookies.
// This must be performed before GetSaveSize() or Save() can complete (it is
//  called by them).  After calling this, no add functions are valid until a
//  call to SaveOrganizePoolsFinished().
//*****************************************************************************
HRESULT StgDatabase::SaveOrganizePools()// Return code.
{
    HRESULT     hr;                     // A result.
    STGOPENTABLE *pTablePtr;            // Walking list of tables.
    STGTABLEDEF *pTableDef;             // Working pointer for table defs.
    SCHEMASRCH  sSrch;                  // Search structure for walking tables.
    StgRecordManager *pRecordMgr;       // Record manager for a table.
    WCHAR       rcTable[MAXTABLENAME];  // Wide name of table.
    TABLEID     tableid;                // For fast opens.

    _ASSERTE(!m_bPoolsOrganized);
    m_bPoolsOrganized = true;

    // Tell the pools that a reorg is starting.
    if (FAILED(hr = m_UserSchema.GetStringPool()->OrganizeBegin())  ||
        FAILED(hr = m_UserSchema.GetBlobPool()->OrganizeBegin())    ||
        FAILED(hr = m_UserSchema.GetVariantPool()->OrganizeBegin()) ||
        FAILED(hr = m_UserSchema.GetGuidPool()->OrganizeBegin())    )
        goto ErrExit;

    // Fault in all tables so that we can walk the pooled types for marking.
    if (FAILED(hr = SavePreLoadTables()))
        goto ErrExit;

    // Iterate over all tables, and have them mark their live pooled data.
    for (pTableDef=GetFirstTable(sSrch, SCHEMASRCH_NOTEMP);
            pTableDef;  pTableDef=GetNextTable(sSrch))
    {
        pTablePtr = 0;
        tableid = -1;

        // Temp tables are skipped by search.
        _ASSERTE(!pTableDef->IsTempTable());

        // Get the tableid and open table ptr if valid.  This routine will look
        // for core tables that have never been opened and will not be saved.
        if (sSrch.GetCurSchemaDex() == SCHEMA_CORE && 
                SkipSaveTable(pTableDef, pTablePtr, &tableid))
            continue;

        // Get the text name of the table.
        if (FAILED(hr = sSrch.pSchemaDef->pNameHeap->GetStringW(pTableDef->Name, rcTable, NumItems(rcTable))))
            goto ErrExit;

        // Get an open table pointer for this item.
        if (!pTablePtr && FAILED(hr = OpenTable(rcTable, pTablePtr, tableid)))
            goto ErrExit;

        // Get the record manager for this table.
        _ASSERTE(pTablePtr);
        VERIFY(pRecordMgr = &pTablePtr->RecordMgr);

        // If the table is marked delete on empty or it is a core table with
        // no records, then it is not saved.
        if (m_bEnforceDeleteOnEmpty && pRecordMgr->Records() == 0 &&
                (pTableDef->IsDeleteOnEmpty() || pTableDef->IsCoreTable()))
            continue;

        // Ask the table to mark its live data.
        hr = pRecordMgr->MarkLivePoolData();

        // At this point we're done with the table and record manager.
        pRecordMgr = 0;
        pTablePtr = 0;

        // Check for ErrExits.
        if (FAILED(hr))
            goto ErrExit;
    }

    // All the live pool data has been marked.  Tell the pools to reorg themselves.
    if (FAILED(hr = m_UserSchema.GetStringPool()->OrganizePool())   ||
        FAILED(hr = m_UserSchema.GetBlobPool()->OrganizePool())     ||
        FAILED(hr = m_UserSchema.GetVariantPool()->OrganizePool()) ||
        FAILED(hr = m_UserSchema.GetGuidPool()->OrganizePool()) )
        goto ErrExit;

ErrExit:
    // If something went wrong, clean up.
    if (FAILED(hr))
        SaveOrganizePoolsEnd();

    return (hr);
}

//*****************************************************************************
// Lets the pools know that the persist-to-stream reorganization is done, and
//  that they should return to normal operation.
//*****************************************************************************
HRESULT StgDatabase::SaveOrganizePoolsEnd()// Return code.
{
    HRESULT     hr;                     // A result.

    m_bPoolsOrganized = false;

    // Tell the pools that the reorg is finished (return to writable).
    if (FAILED(hr = m_UserSchema.GetStringPool()->OrganizeEnd())    ||
        FAILED(hr = m_UserSchema.GetBlobPool()->OrganizeEnd())      ||
        FAILED(hr = m_UserSchema.GetVariantPool()->OrganizeEnd())   ||
        FAILED(hr = m_UserSchema.GetGuidPool()->OrganizeEnd())  )
        goto ErrExit;

ErrExit:
    // There is no reason for any of these functions to ever fail.
    _ASSERTE(hr == S_OK);
    return (hr);
}


//*****************************************************************************
// Save a pool of data out to a stream.
//*****************************************************************************
HRESULT StgDatabase::SavePool(          // Return code.
    LPCWSTR     szName,                 // Name of stream on disk.
    TiggerStorage *pStorage,            // The storage to put data in.
    StgPool     *pPool)                 // The pool to save.
{
    CIfacePtr<IStream> pIStream;        // For writing.
    HRESULT     hr;


    // If there is no data, then don't bother.
    if (pPool->IsEmpty())
        return (S_OK);

    // Create the new stream to hold this table and save it.
    if (FAILED(hr = pStorage->CreateStream(szName, 
            STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
            0, 0, &pIStream)) ||
        FAILED(hr = pPool->PersistToStream(pIStream)))
    {
        return (hr);
    }
    return (S_OK);
}


//*****************************************************************************
// Add the size of the pool data and any stream overhead it may occur to the
// value already in *pcbSaveSize.
//*****************************************************************************
HRESULT StgDatabase::GetPoolSaveSize(   // Return code.
    LPCWSTR     szHeap,                 // Name of the heap stream.
    StgPool     *pPool,                 // The pool to save.
    ULONG       *pcbSaveSize)           // Add pool data to this value.
{
    ULONG       cbSize = 0;             // Size of pool data.
	SAVETRACE(ULONG cbDbg=0);
    HRESULT     hr;

	*pcbSaveSize = 0;

    // If there is no data, then don't bother.
    if (pPool->IsEmpty())
        return (S_OK);

    // Ask the pool to size its data.
    if (FAILED(hr = pPool->GetSaveSize(&cbSize)))
        return (hr);

	// Add this item to the save list.
	if (FAILED(hr = _AddStreamToList(m_pStreamList, cbSize, szHeap)))
		return (hr);

    SAVETRACE(DbgWriteEx(L"GSS:  Pool %s, data size %d\n", szHeap, cbSize);cbDbg=cbSize);

    // Ask the storage system to add stream fixed overhead.
    if (FAILED(hr = TiggerStorage::GetStreamSaveSize(szHeap, cbSize, &cbSize)))
        return (hr);
    SAVETRACE(DbgWriteEx(L"GSS:  Pool %s header size %d\n", szHeap, cbSize-cbDbg););

    // Add the size of the pool to the caller's total.  
    *pcbSaveSize = cbSize;
    return (S_OK);
}


//*****************************************************************************
// Artificially load all tables from disk so we have an in memory
// copy to rewrite from.  The backing storage will be invalid for
// the rest of this operation.
//*****************************************************************************
HRESULT StgDatabase::SavePreLoadTables() // Return code.
{
    STGOPENTABLE *pTablePtr;            // Walking list of tables.
    STGTABLEDEF *pTableDef;             // Scanning tables to save.
    SCHEMASRCH  sSrch;                  // Search structure for walking tables.
    TABLEID     tableid;                // The ID for the open.
    WCHAR       rcTable[MAXTABLENAME];  // Wide name of table.
    HRESULT     hr;

//@todo: pluggable schemas means probably less streams than defs, should use
// stream list as control instead of table defs for faster loop.

    // Load every user and core table, temp tables don't get saved anyway.
    for (pTableDef=GetFirstTable(sSrch, SCHEMASRCH_NOTEMP);
            pTableDef;  pTableDef=GetNextTable(sSrch))
    {
        // Temp tables are skipped by search.
        _ASSERTE(!pTableDef->IsTempTable());

        // Assume no name.
        *rcTable = '\0';

        // Core tables use the internal id for faster opens.
        if (sSrch.iSchema == SCHEMA_CORE)
            tableid = pTableDef->tableid;
        // All other tables require a name to be opened.
        else // if (sSrch.iSchema == SCHEMA_USER)
        {
            tableid = -1;
            if (FAILED(hr = sSrch.pSchemaDef->pNameHeap->GetStringW(pTableDef->Name, rcTable, NumItems(rcTable))))
            {
                return (hr);
            }
        }

        // Now open the table forcing its data to be imported.
        if (FAILED(hr = OpenTable(rcTable, pTablePtr, tableid)))
            return (hr);
    }
    return (S_OK);
}


//*****************************************************************************
// This function sets the tableid and finds an exisiting open table struct
// if there is one for a core table.  If the table is a core table and it has
// not been opened, then there is nothing to save and true is returned to
// skip the thing.
//*****************************************************************************
int StgDatabase::SkipSaveTable(         // Return true to skip table def.
    STGTABLEDEF *pTableDef,             // Table to check.
    STGOPENTABLE *&pTablePtr,           // If found, return open table struct.
    TABLEID     *ptableid)              // Return tableid for lookups.
{
    // Use the tableid if there is one because it is the fastest load path.
    if (!m_bEnforceDeleteOnEmpty || pTableDef->tableid == (USHORT) -1)
        *ptableid = -1;
    else
        *ptableid = pTableDef->tableid;

    // Tables marked as delete if empty don't get saved.  Do a short circuit
    // here on core tables which aren't even open and therefore cannot have
    // records.  This avoids loading any record manager data at all.
    if (m_bEnforceDeleteOnEmpty && (pTableDef->IsCoreTable() || pTableDef->IsDeleteOnEmpty()))
    {
        // Retrieve the table from the heap at its index.
        _ASSERTE(IsValidTableID(*ptableid));
        VERIFY(pTablePtr = m_TableHeap.GetAt((int)*ptableid)); 
        if (!pTablePtr->RecordMgr.IsOpen())
            return (true);
    }
    return (false);
}


//*****************************************************************************
// Figure out how much room will be used in the header for extra data for the
// current state of the database.
//*****************************************************************************
ULONG StgDatabase::GetExtraDataSaveSize() // Size of extra data.
{
//@todo: Would be eaiser to work with if iSchemas was save to disk, and then
// only variable array is left.  Move this code to STGEXTRA at that point.
    if (!m_Schemas.ExternalCount())
        return (sizeof(ULONG) + sizeof(OID) + sizeof(ULONG));
    else
        return (sizeof(STGEXTRA) + (sizeof(COMPLIBSCHEMASTG) * m_Schemas.ExternalCount()));
}


//
// Helpers.
//



//*****************************************************************************
// Allocate new heaps for user data, then save a copy of this data.  This is
// used after optimization and during saving of records which will have new
// heap offsets that have to meatch the heap data.
//*****************************************************************************
HRESULT _PrepareSaveSchema(             // Return code.
    SCHEMADEFS  *pTo,                   // Copy heap data to this schema.
    SCHEMADEFS  *pFrom)                 // Copy heap data from this schema.
{
    HRESULT     hr;

    // Allocate new heap objects.
	pTo->Clear();
    pTo->pStringPool = new StgStringPool;
    pTo->pBlobPool = new StgBlobPool;
    pTo->pVariantPool = new StgVariantPool;
    pTo->pGuidPool = new StgGuidPool;
    if (!pTo->pStringPool || !pTo->pBlobPool || !pTo->pVariantPool || !pTo->pGuidPool)
    {
        hr = OutOfMemory();
        goto ErrExit;
    }

    // For each heap, save a copy of the optimized data.
    if (FAILED(hr = StgPool::SaveCopy(pTo->pStringPool, pFrom->pStringPool)) ||
        FAILED(hr = StgPool::SaveCopy(pTo->pBlobPool, pFrom->pBlobPool)) ||
        FAILED(hr = StgPool::SaveCopy(pTo->pVariantPool, pFrom->pVariantPool, 
                pTo->pBlobPool, pTo->pStringPool)) ||
        FAILED(hr = StgPool::SaveCopy(pTo->pGuidPool, pFrom->pGuidPool)))
    {
        goto ErrExit;
    }

ErrExit:
    return (hr);
}


//*****************************************************************************
// Free up any data allocated for the save heaps.
//*****************************************************************************
void _DestroySaveSchema(
    SCHEMADEFS  *pSchema)               // The schema we are destroying.
{
    if (pSchema->pStringPool)
    { 
        StgPool::FreeCopy(pSchema->pStringPool);
        pSchema->pStringPool->Uninit();
        delete pSchema->pStringPool;
    }
    if (pSchema->pBlobPool)
    { 
        StgPool::FreeCopy(pSchema->pBlobPool);
        pSchema->pBlobPool->Uninit();
        delete pSchema->pBlobPool;
    }
    if (pSchema->pVariantPool)
    { 
        StgPool::FreeCopy(pSchema->pVariantPool);
        pSchema->pVariantPool->Uninit();
        delete pSchema->pVariantPool;
    }
    if (pSchema->pGuidPool)
    { 
        StgPool::FreeCopy(pSchema->pGuidPool);
        pSchema->pGuidPool->Uninit();
        delete pSchema->pGuidPool;
    }
}



//*****************************************************************************
// Add a new item to the storage list for the save operation.  Might have to
// allocate the list object itself if not done already.
//*****************************************************************************
HRESULT _AddStreamToList(				// Return code.
	STORAGESTREAMLST *pStreamList,		// List of streams for header.
	ULONG		cbSize,					// Size of data stream.
	const WCHAR	*szName)				// Name of persisted stream.
{
	STORAGESTREAM *pItem;				// New item to allocate & fill.

	// Add a new item to the end of the list.
	pItem = pStreamList->Append();
	if (!pItem)
		return (PostError(OutOfMemory()));

	// Fill out the data.
	pItem->iOffset = 0;
	pItem->iSize = cbSize;
	VERIFY(WszWideCharToMultiByte(CP_ACP, 0, szName, -1, pItem->rcName, MAXSTREAMNAME, 0, 0) > 0);
	return (S_OK);
}


#if defined( _DEBUG ) && defined( WENJUN )
HRESULT VerifySavedImage(StgIO *pStgIO)
{
	IComponentRecords *pICR = 0;
	HRESULT		hr;
	void		*ptr;
	ULONG		cbData;
	
	hr = pStgIO->_DbgGetCopyOfData(ptr, &cbData);
	if (hr == E_FAIL)
		return (S_OK);
	_ASSERTE(SUCCEEDED(hr));
	hr = OpenComponentLibraryOnMemEx(cbData, ptr, &pICR);
	_ASSERTE(SUCCEEDED(hr) && pICR);
	if (pICR) pICR->Release();
	free(ptr);
	return (hr);
}
#endif

#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgtiggerstorage.cpp ===
//*****************************************************************************
// StgTiggerStorage.cpp
//
// TiggerStorage is a stripped down version of compound doc files.  Doc files
// have some very useful and complex features to them, unfortunately nothing
// comes for free.  Given the incredibly tuned format of existing .tlb files,
// every single byte counts and 10% added by doc files is just too exspensive.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard header.
#include "Errors.h"						// Our error defines.
#include "CompLib.h"					// Common header.
#include "StgIO.h"						// I/O subsystem.
#include "StgTiggerStorage.h"			// Our interface.
#include "StgTiggerStream.h"			// Stream interface.

TiggerStorage::TiggerStorage() :
	m_pStgIO(0),
	m_cRef(1),
	m_pStreamList(0),
	m_pbExtra(0)
{
	memset(&m_StgHdr, 0, sizeof(STORAGEHEADER));
}


TiggerStorage::~TiggerStorage()
{
	if (m_pStgIO)
	{
		m_pStgIO->Release();
		m_pStgIO = 0;
	}
}


//*****************************************************************************
// Init this storage object on top of the given storage unit.
//*****************************************************************************
HRESULT TiggerStorage::Init(		// Return code.
	StgIO		*pStgIO)			// The I/O subsystem.
{
	STORAGESIGNATURE *pSig;			// Signature data for file.
	ULONG		iOffset;			// Offset of header data.
	void		*ptr;				// Signature.
	HRESULT		hr = S_OK;

	// Make sure we always start at the beginning.
	pStgIO->Seek(0, FILE_BEGIN);

	// Save the storage unit.
	m_pStgIO = pStgIO;
	m_pStgIO->AddRef();

	// For cases where the data already exists, verify the signature.
	if ((pStgIO->GetFlags() & DBPROP_TMODEF_CREATE) == 0)
	{
		// Map the contents into memory for easy access.
		if (FAILED(hr = pStgIO->MapFileToMem(ptr, &iOffset)))
			goto ErrExit;

		// Get a pointer to the signature of the file, which is the first part.
		if (FAILED(hr = pStgIO->GetPtrForMem(0, sizeof(STORAGESIGNATURE), ptr)))
			goto ErrExit;

		// Finally, we can check the signature.
		pSig = (STORAGESIGNATURE *) ptr;
		if (FAILED(hr = VerifySignature(pSig)))
			goto ErrExit;

		// Read and verify the header.
		if (pSig->iMajorVer == FILE_VER_MAJOR_v0)
			hr = ReadHeader_v0();
		else
			hr = ReadHeader();
	}
	// For write case, dump the signature into the file up front.
	else
	{
		if (FAILED(hr = WriteSignature()))
			goto ErrExit;
	}

ErrExit:
	if (FAILED(hr) && m_pStgIO)
	{
		m_pStgIO->Release();
		m_pStgIO = 0;
	}
	return (hr);
}


//*****************************************************************************
// Retrieves a the size and a pointer to the extra data that can optionally be
// written in the header of the storage system.  This data is not required to
// be in the file, in which case *pcbExtra will come back as 0 and pbData will
// be set to null.  You must have initialized the storage using Init() before
// calling this function.
//*****************************************************************************
HRESULT TiggerStorage::GetExtraData(	// S_OK if found, S_FALSE, or error.
	ULONG		*pcbExtra,				// Return size of extra data.
	BYTE		*&pbData)				// Return a pointer to extra data.
{
	// Assuming there is extra data, then return the size and a pointer to it.
	if (m_pbExtra)
	{
		_ASSERTE(m_StgHdr.fFlags & STGHDR_EXTRADATA);
		*pcbExtra = *(ULONG *) m_pbExtra;
		pbData = (BYTE *) ((ULONG *) m_pbExtra + 1);
	}
	else
	{
		*pcbExtra = 0;
		pbData = 0;
		return (S_FALSE);
	}
	return (S_OK);
}


//*****************************************************************************
// Called when this stream is going away.
//*****************************************************************************
HRESULT TiggerStorage::WriteHeader(
	STORAGESTREAMLST *pList,			// List of streams.		
	ULONG		cbExtraData,			// Size of extra data, may be 0.
	BYTE		*pbExtraData)			// Pointer to extra data for header.
{
	ULONG		iLen;					// For variable sized data.
	ULONG		cbWritten;				// Track write quantity.
	HRESULT		hr;
	SAVETRACE(ULONG cbDebugSize);		// Track debug size of header.

	SAVETRACE(DbgWriteEx(L"PSS:  Header:\n"));

	// Save the count and set flags.
	m_StgHdr.iStreams = pList->Count();
	if (cbExtraData)
		m_StgHdr.fFlags |= STGHDR_EXTRADATA;

	// Write out the header of the file.
	if (FAILED(hr = m_pStgIO->Write(&m_StgHdr, sizeof(STORAGEHEADER), &cbWritten)))
		return (hr);

	// Write out extra data if there is any.
	if (cbExtraData)
	{
		_ASSERTE(pbExtraData);
		_ASSERTE(cbExtraData % 4 == 0);

		// First write the length value.
		if (FAILED(hr = m_pStgIO->Write(&cbExtraData, sizeof(ULONG), &cbWritten)))
			return (hr);

		// And then the data.
		if (FAILED(hr = m_pStgIO->Write(pbExtraData, cbExtraData, &cbWritten)))
			return (hr);
		SAVETRACE(DbgWriteEx(L"PSS:    extra data size %d\n", m_pStgIO->GetCurrentOffset() - cbDebugSize);cbDebugSize=m_pStgIO->GetCurrentOffset());
	}
	
	// Save off each data stream.
	for (int i=0;  i<pList->Count();  i++)
	{
		STORAGESTREAM *pStream = pList->Get(i);

		// How big is the structure (aligned) for this struct.
		iLen = (ULONG) (sizeof(STORAGESTREAM) - MAXSTREAMNAME + strlen(pStream->rcName) + 1);

		// Write the header including the name to disk.  Does not include
		// full name buffer in struct, just string and null terminator.
		if (FAILED(hr = m_pStgIO->Write(pStream, iLen, &cbWritten)))
			return (hr);

		// Align the data out to 4 bytes.
		if (iLen != ALIGN4BYTE(iLen))
		{
			if (FAILED(hr = m_pStgIO->Write(&hr, ALIGN4BYTE(iLen) - iLen, 0)))
				return (hr);
		}
		SAVETRACE(DbgWriteEx(L"PSS:    Table %hs header size %d\n", pStream->rcName, m_pStgIO->GetCurrentOffset() - cbDebugSize);cbDebugSize=m_pStgIO->GetCurrentOffset());
	}
	SAVETRACE(DbgWriteEx(L"PSS:  Total size of header data %d\n", m_pStgIO->GetCurrentOffset()));
	// Make sure the whole thing is 4 byte aligned.
	_ASSERTE(m_pStgIO->GetCurrentOffset() % 4 == 0);
	return (S_OK);
}


//*****************************************************************************
// Called when all data has been written.  Forces cached data to be flushed
// and stream lists to be validated.
//*****************************************************************************
HRESULT TiggerStorage::WriteFinished(	// Return code.
	STORAGESTREAMLST *pList,			// List of streams.		
	ULONG		*pcbSaveSize)			// Return size of total data.
{
	STORAGESTREAM *pEntry;				// Loop control.
	HRESULT		hr;

	// If caller wants the total size of the file, we are there right now.
	if (pcbSaveSize)
		*pcbSaveSize = m_pStgIO->GetCurrentOffset();

	// Flush our internal write cache to disk.
	if (FAILED(hr = m_pStgIO->FlushCache()))
		return (hr);

	// Force user's data onto disk right now so that Commit() can be
	// more accurate (although not totally up to the D in ACID).
	hr = m_pStgIO->FlushFileBuffers();
	_ASSERTE(SUCCEEDED(hr));


	// Run through all of the streams and validate them against the expected
	// list we wrote out originally.

	// Robustness check: stream counts must match what was written.
	_ASSERTE(pList->Count() == m_Streams.Count());
	if (pList->Count() != m_Streams.Count())
	{
		_ASSERTE(0 && "Mismatch in streams, save would cause corruption.");
		return (PostError(CLDB_E_FILE_CORRUPT));
		
	}

	// Sanity check each saved stream data size and offset.
	for (int i=0;  i<pList->Count();  i++)
	{
		pEntry = pList->Get(i);
		_ASSERTE(pEntry->iOffset == m_Streams[i].iOffset);
		_ASSERTE(pEntry->iSize == m_Streams[i].iSize);
		_ASSERTE(strcmp(pEntry->rcName, m_Streams[i].rcName) == 0);

		// For robustness, check that everything matches expected value,
		// and if it does not, refuse to save the data and force a rollback.
		// The alternative is corruption of the data file.
		if (pEntry->iOffset != m_Streams[i].iOffset ||
			pEntry->iSize != m_Streams[i].iSize ||
			strcmp(pEntry->rcName, m_Streams[i].rcName) != 0)
		{
			_ASSERTE(0 && "Mismatch in streams, save would cause corruption.");
			hr = PostError(CLDB_E_FILE_CORRUPT);
			break;
		}

		//@future: 
		// if iOffset or iSize mismatches, it means a bug in GetSaveSize
		// which we can successfully detect right here.  In that case, we
		// could use the pStgIO and seek back to the header and correct the
		// mistmake.  This will break any client who lives on the GetSaveSize
		// value which came back originally, but would be more robust than
		// simply throwing back an error which will corrupt the file.
	}
	return (hr);
}


//*****************************************************************************
// Tells the storage that we intend to rewrite the contents of this file.  The
// entire file will be truncated and the next write will take place at the
// beginning of the file.
//*****************************************************************************
HRESULT TiggerStorage::Rewrite(			// Return code.
	LPWSTR		szBackup)				// If non-0, backup the file.
{
	HRESULT		hr;

	// Delegate to storage.
	if (FAILED(hr = m_pStgIO->Rewrite(szBackup)))
		return (hr);

	// None of the old streams make any sense any more.  Delete them.
	m_Streams.Clear();

	// Write the signature out.
	if (FAILED(hr = WriteSignature()))
	{
		VERIFY(Restore(szBackup, false) == S_OK);
		return (hr);
	}

	return (S_OK);
}


//*****************************************************************************
// Called after a successful rewrite of an existing file.  The in memory
// backing store is no longer valid because all new data is in memory and
// on disk.  This is essentially the same state as created, so free up some
// working set and remember this state.
//*****************************************************************************
HRESULT TiggerStorage::ResetBackingStore()	// Return code.
{
	return (m_pStgIO->ResetBackingStore());
}


//*****************************************************************************
// Called to restore the original file.  If this operation is successful, then
// the backup file is deleted as requested.  The restore of the file is done
// in write through mode to the disk help ensure the contents are not lost.
// This is not good enough to fulfill ACID props, but it ain't that bad.
//*****************************************************************************
HRESULT TiggerStorage::Restore(			// Return code.
	LPWSTR		szBackup,				// If non-0, backup the file.
	int			bDeleteOnSuccess)		// Delete backup file if successful.
{
	HRESULT		hr;

	// Ask file system to copy bytes from backup into master.
	if (FAILED(hr = m_pStgIO->Restore(szBackup, bDeleteOnSuccess)))
		return (hr);

	// Reset state.  The Init routine will re-read data as required.
	m_pStreamList = 0;
	m_StgHdr.iStreams = 0;

	// Re-init all data structures as though we just opened.
	return (Init(m_pStgIO));
}


//*****************************************************************************
// Given the name of a stream that will be persisted into a stream in this
// storage type, figure out how big that stream would be including the user's
// stream data and the header overhead the file format incurs.  The name is
// stored in ANSI and the header struct is aligned to 4 bytes.
//*****************************************************************************
HRESULT TiggerStorage::GetStreamSaveSize( // Return code.
	LPCWSTR		szStreamName,			// Name of stream.
	ULONG		cbDataSize,				// Size of data to go into stream.
	ULONG		*pcbSaveSize)			// Return data size plus stream overhead.
{
	ULONG		cbTotalSize;			// Add up each element.
	
	// Find out how large the name will be.
	cbTotalSize = ::W95WideCharToMultiByte(CP_ACP, 0, szStreamName, -1, 0, 0, 0, 0);
	_ASSERTE(cbTotalSize);

	// Add the size of the stream header minus the static name array.
	cbTotalSize += sizeof(STORAGESTREAM) - MAXSTREAMNAME;

	// Finally align the header value.
	cbTotalSize = ALIGN4BYTE(cbTotalSize);

	// Return the size of the user data and the header data.
	*pcbSaveSize = cbTotalSize + cbDataSize;
	return (S_OK);
}


//*****************************************************************************
// Return the fixed size overhead for the storage implementation.  This includes
// the signature and fixed header overhead.  The overhead in the header for each
// stream is calculated as part of GetStreamSaveSize because these structs are
// variable sized on the name.
//*****************************************************************************
HRESULT TiggerStorage::GetStorageSaveSize( // Return code.
	ULONG		*pcbSaveSize,			// [in] current size, [out] plus overhead.
	ULONG		cbExtra)				// How much extra data to store in header.
{
	*pcbSaveSize += sizeof(STORAGESIGNATURE) + sizeof(STORAGEHEADER);
	if (cbExtra)
		*pcbSaveSize += sizeof(ULONG) + cbExtra;
	return (S_OK);
}


//*****************************************************************************
// Adjust the offset in each known stream to match where it will wind up after
// a save operation.
//*****************************************************************************
HRESULT TiggerStorage::CalcOffsets(		// Return code.
	STORAGESTREAMLST *pStreamList,		// List of streams for header.
	ULONG		cbExtra)				// Size of variable extra data in header.
{
	STORAGESTREAM *pEntry;				// Each entry in the list.
	ULONG		cbOffset=0;				// Running offset for streams.
	int			i;						// Loop control.

	// Prime offset up front.
	GetStorageSaveSize(&cbOffset, cbExtra);

	// Add on the size of each header entry.
	for (i=0;  i<pStreamList->Count();  i++)
	{
		VERIFY(pEntry = pStreamList->Get(i));
		cbOffset += sizeof(STORAGESTREAM) - MAXSTREAMNAME;
		cbOffset += (ULONG) strlen(pEntry->rcName) + 1;
		cbOffset = ALIGN4BYTE(cbOffset);
	}

	// Go through each stream and reset its expected offset.
	for (i=0;  i<pStreamList->Count();  i++)
	{
		VERIFY(pEntry = pStreamList->Get(i));
		pEntry->iOffset = cbOffset;
		cbOffset += pEntry->iSize;
	}
	return (S_OK);
}	



HRESULT STDMETHODCALLTYPE TiggerStorage::CreateStream( 
	const OLECHAR *pwcsName,
	DWORD		grfMode,
	DWORD		reserved1,
	DWORD		reserved2,
	IStream		**ppstm)
{
	char		rcStream[MAXSTREAMNAME];// For converted name.
	VERIFY(Wsz_wcstombs(rcStream, pwcsName, sizeof(rcStream)));
	return (CreateStream(rcStream, grfMode, reserved1, reserved2, ppstm));
}


HRESULT STDMETHODCALLTYPE TiggerStorage::CreateStream( 
	LPCSTR		szName,
	DWORD		grfMode,
	DWORD		reserved1,
	DWORD		reserved2,
	IStream		**ppstm)
{
	STORAGESTREAM *pStream;				// For lookup.
	HRESULT		hr;

	_ASSERTE(szName && *szName);

	// Check for existing stream, which might be an error or more likely
	// a rewrite of a file.
	if ((pStream = FindStream(szName)) != 0)
	{
		if (pStream->iOffset != 0xffffffff && (grfMode & STGM_FAILIFTHERE))
			return (PostError(STG_E_FILEALREADYEXISTS));
	}
	// Add a control to track this stream.
	else if (!pStream && (pStream = m_Streams.Append()) == 0)
		return (PostError(OutOfMemory()));
	pStream->iOffset = 0xffffffff;
	pStream->iSize = 0;
	strcpy(pStream->rcName, szName);

	// Now create a stream object to allow reading and writing.
	TiggerStream *pNew = new TiggerStream;
	if (!pNew)
		return (PostError(OutOfMemory()));
	*ppstm = (IStream *) pNew;

	// Init the new object.
	if (FAILED(hr = pNew->Init(this, pStream->rcName)))
	{
		delete pNew;
		return (hr);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::OpenStream( 
	const OLECHAR *pwcsName,
	void		*reserved1,
	DWORD		grfMode,
	DWORD		reserved2,
	IStream		**ppstm)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::CreateStorage( 
	const OLECHAR *pwcsName,
	DWORD		grfMode,
	DWORD		dwStgFmt,
	DWORD		reserved2,
	IStorage	**ppstg)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::OpenStorage( 
	const OLECHAR *pwcsName,
	IStorage	*pstgPriority,
	DWORD		grfMode,
	SNB			snbExclude,
	DWORD		reserved,
	IStorage	**ppstg)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::CopyTo( 
	DWORD		ciidExclude,
	const IID	*rgiidExclude,
	SNB			snbExclude,
	IStorage	*pstgDest)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::MoveElementTo( 
	const OLECHAR *pwcsName,
	IStorage	*pstgDest,
	const OLECHAR *pwcsNewName,
	DWORD		grfFlags)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::Commit( 
	DWORD		grfCommitFlags)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::Revert()
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::EnumElements( 
	DWORD		reserved1,
	void		*reserved2,
	DWORD		reserved3,
	IEnumSTATSTG **ppenum)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::DestroyElement( 
	const OLECHAR *pwcsName)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::RenameElement( 
	const OLECHAR *pwcsOldName,
	const OLECHAR *pwcsNewName)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::SetElementTimes( 
	const OLECHAR *pwcsName,
	const FILETIME *pctime,
	const FILETIME *patime,
	const FILETIME *pmtime)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::SetClass( 
	REFCLSID	clsid)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::SetStateBits( 
	DWORD		grfStateBits,
	DWORD		grfMask)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::Stat( 
	STATSTG		*pstatstg,
	DWORD		grfStatFlag)
{
	return (E_NOTIMPL);
}



HRESULT STDMETHODCALLTYPE TiggerStorage::OpenStream( 
	LPCWSTR 	szStream,
	ULONG		*pcbData,
	void		**ppAddress)
{
	STORAGESTREAM *pStream;				// For lookup.
	char		rcName[MAXSTREAMNAME];	// For conversion.
	HRESULT		hr;

	// Convert the name for internal use.
	VERIFY(::W95WideCharToMultiByte(CP_ACP, 0, szStream, -1, rcName, sizeof(rcName), 0, 0));

	// Look for the stream which must be found for this to work.  Note that
	// this error is explcitly not posted as an error object since unfound streams
	// are a common occurence and do not warrant a resource file load.
	if ((pStream = FindStream(rcName)) == 0)
		return (STG_E_FILENOTFOUND);

	// Get the memory for the stream.
	if (FAILED(hr = m_pStgIO->GetPtrForMem(pStream->iOffset, pStream->iSize, *ppAddress)))
		return (hr);
	*pcbData = pStream->iSize;
	return (S_OK);
}



//
// Protected.
//


//*****************************************************************************
// Called by the stream implementation to write data out to disk.
//*****************************************************************************
HRESULT TiggerStorage::Write(		// Return code.
	LPCSTR		szName,				// Name of stream we're writing.
	const void *pData,				// Data to write.
	ULONG		cbData,				// Size of data.
	ULONG		*pcbWritten)		// How much did we write.
{
	STORAGESTREAM *pStream;			// Update size data.
	ULONG		iOffset = 0;		// Offset for write.
	ULONG		cbWritten;			// Handle null case.
	HRESULT		hr;

	// Get the stream descriptor.
	VERIFY(pStream = FindStream(szName));

	// If we need to know the offset, keep it now.
	if (pStream->iOffset == 0xffffffff)
	{
		iOffset = m_pStgIO->GetCurrentOffset();

		// Align the storage on a 4 byte boundary.
		if (iOffset % 4 != 0)
		{
			ULONG		cb;
			ULONG		pad = 0;
			HRESULT		hr;

			if (FAILED(hr = m_pStgIO->Write(&pad, ALIGN4BYTE(iOffset) - iOffset, &cb)))
				return (hr);
			iOffset = m_pStgIO->GetCurrentOffset();
			
			_ASSERTE(iOffset % 4 == 0);
		}
	}

	// Avoid confusion.
	if (pcbWritten == 0)
		pcbWritten = &cbWritten;
	*pcbWritten = 0;

	// Let OS do the write.
	if (SUCCEEDED(hr = m_pStgIO->Write(pData, cbData, pcbWritten)))
	{
		// On success, record the new data.
		if (pStream->iOffset == 0xffffffff)
			pStream->iOffset = iOffset;
		pStream->iSize += *pcbWritten;	
		return (S_OK);
	}
	else
		return (hr);
}


//
// Private
//

STORAGESTREAM *TiggerStorage::FindStream(LPCSTR szName)
{
	int			i;

	// In read mode, just walk the list and return one.
	if (m_pStreamList)
	{
		STORAGESTREAM *p;
		for (i=0, p=m_pStreamList;  i<m_StgHdr.iStreams;  i++)
		{
			if (!_stricmp(p->rcName, szName))
				return (p);
			p = p->NextStream();
		}
	}
	// In write mode, walk the array which is not on disk yet.
	else
	{
		for (int i=0;  i<m_Streams.Count();  i++)
		{
			if (!_stricmp(m_Streams[i].rcName, szName))
				return (&m_Streams[i]);
		}
	}
	return (0);
}


//*****************************************************************************
// Write the signature area of the file format to disk.  This includes the
// "magic" identifier and the version information.
//*****************************************************************************
HRESULT TiggerStorage::WriteSignature()
{
	STORAGESIGNATURE sSig;
	ULONG		cbWritten;

	// Signature belongs at the start of the file.
	_ASSERTE(m_pStgIO->GetCurrentOffset() == 0);

	sSig.lSignature = STORAGE_MAGIC_SIG;
	sSig.iMajorVer = FILE_VER_MAJOR;
	sSig.iMinorVer = FILE_VER_MINOR;
	return (m_pStgIO->Write(&sSig, sizeof(STORAGESIGNATURE), &cbWritten));
}


//*****************************************************************************
// Verify the signature at the front of the file to see what type it is.
// @future: version check for next version.
//*****************************************************************************
HRESULT TiggerStorage::VerifySignature(
	STORAGESIGNATURE *pSig)				// The signature to check.
{
	HRESULT		hr = S_OK;

	// If signature didn't match, you shouldn't be here.
	if (pSig->lSignature != STORAGE_MAGIC_SIG)
		return (PostError(CLDB_E_FILE_CORRUPT));

	// Only a specific version of the 0.x format is supported by this code
	// in order to support the NT 5 beta clients which used this format.
	if (pSig->iMajorVer == FILE_VER_MAJOR_v0)
	{ 
		if (pSig->iMinorVer < FILE_VER_MINOR_v0)
			hr = CLDB_E_FILE_OLDVER;
	}
	// There is currently no code to migrate an old format of the 1.x.  This
	// would be added only under special circumstances.
	else if (pSig->iMajorVer != FILE_VER_MAJOR || pSig->iMinorVer != FILE_VER_MINOR)
		hr = CLDB_E_FILE_OLDVER;

	if (FAILED(hr))
		hr = PostError(hr, (int) pSig->iMajorVer, (int) pSig->iMinorVer);
	return (hr);
}


//*****************************************************************************
// Read the header from disk.  This reads the header for the most recent version
// of the file format which has the header at the front of the data file.
//*****************************************************************************
HRESULT TiggerStorage::ReadHeader() // Return code.
{
	STORAGESTREAM *pAppend, *pStream;// For copy of array.
	void		*ptr;				// Working pointer.
	ULONG		iOffset;			// Offset of header data.
	ULONG		cbExtra;			// Size of extra data.
	ULONG		cbRead;				// For calc of read sizes.
	HRESULT		hr;

	// Header data starts after signature.
	iOffset = sizeof(STORAGESIGNATURE);

	// Read the storage header which has the stream counts.  Throw in the extra
	// count which might not exist, but saves us down stream.
	if (FAILED(hr = m_pStgIO->GetPtrForMem(iOffset, sizeof(STORAGEHEADER) + sizeof(ULONG), ptr)))
		return (hr);
	_ASSERTE(m_pStgIO->IsAlignedPtr((UINT_PTR) ptr, 4));

	// Copy the header into memory and check it.
	memcpy(&m_StgHdr, ptr, sizeof(STORAGEHEADER));
	if (FAILED(hr = VerifyHeader()))
		return (hr);
	ptr = (void *) ((STORAGEHEADER *) ptr + 1);
	iOffset += sizeof(STORAGEHEADER);

	// Save off a pointer to the extra data.
	if (m_StgHdr.fFlags & STGHDR_EXTRADATA)
	{
		m_pbExtra = ptr;
		cbExtra = sizeof(ULONG) + *(ULONG *) ptr;

		// Force the extra data to get faulted in.
		if (FAILED(hr = m_pStgIO->GetPtrForMem(iOffset, cbExtra, ptr)))
			return (hr);
		_ASSERTE(m_pStgIO->IsAlignedPtr((UINT_PTR) ptr, 4));
	}
	else
	{
		m_pbExtra = 0;
		cbExtra = 0;
	}
	iOffset += cbExtra;

	// Force the worst case scenario of bytes to get faulted in for the
	// streams.  This makes the rest of this code very simple.
	cbRead = sizeof(STORAGESTREAM) * m_StgHdr.iStreams;
	if (cbRead)
	{
		cbRead = min(cbRead, m_pStgIO->GetDataSize() - iOffset);
		if (FAILED(hr = m_pStgIO->GetPtrForMem(iOffset, cbRead, ptr)))
			return (hr);
		_ASSERTE(m_pStgIO->IsAlignedPtr((UINT_PTR) ptr, 4));

		// For read only, just access the header data.
		if (m_pStgIO->IsReadOnly())
		{
			// Save a pointer to the current list of streams.
			m_pStreamList = (STORAGESTREAM *) ptr;
		}
		// For writeable, need a copy we can modify.
		else
		{
			pStream = (STORAGESTREAM *) ptr;

			// Copy each of the stream headers.
			for (int i=0;  i<m_StgHdr.iStreams;  i++)
			{
				if ((pAppend = m_Streams.Append()) == 0)
					return (PostError(OutOfMemory()));
				memcpy (pAppend, pStream, pStream->GetStreamSize());
				pStream = pStream->NextStream();
				_ASSERTE(m_pStgIO->IsAlignedPtr((UINT_PTR) pStream, 4));
			}

			// All must be loaded and accounted for.
			_ASSERTE(m_StgHdr.iStreams == m_Streams.Count());
		}
	}
	return (S_OK);
}


//*****************************************************************************
// This piece of code is around to read version 0.x file formats which had the
// offset to the header at the end of the file, and the data for the header
// at the end of the file.  This code path is in here to support the transition
// period before NT 5 RTM, where existing machines have this format.
//@todo: We can take this code out once we are 100% sure that all existing
// data files out there in the world are version 1.x and above.
//*****************************************************************************
HRESULT TiggerStorage::ReadHeader_v0() // Return code.
{
	STORAGESTREAM *pAppend, *pStream;// For copy of array.
	void		*ptr;				// Working pointer.
	ULONG		iOffset;			// Offset of header data.
	ULONG		cbExtra;			// Size of extra data.
	HRESULT		hr;

	// Read offset of header from file.
	if (FAILED(hr = m_pStgIO->GetPtrForMem(m_pStgIO->GetDataSize() - sizeof(ULONG), 
				sizeof(ULONG), ptr)))
		return (hr);
	_ASSERTE(m_pStgIO->IsAlignedPtr((UINT_PTR) ptr, 4));
	iOffset = *(ULONG *) ptr;

	// If offset is out of range, it's not our file.
	if (iOffset > m_pStgIO->GetDataSize() - sizeof(ULONG) - sizeof(STORAGEHEADER))
		return (PostError(CLDB_E_FILE_CORRUPT));

	// Read the header.
	if (FAILED(hr = m_pStgIO->GetPtrForMem(iOffset, 
				m_pStgIO->GetDataSize() - iOffset, ptr)))
		return (hr);
	_ASSERTE(m_pStgIO->IsAlignedPtr((UINT_PTR) ptr, 4));

	// Copy the header into memory and check it.
	memcpy(&m_StgHdr, ptr, sizeof(STORAGEHEADER));
	if (FAILED(hr = VerifyHeader()))
		return (hr);
	ptr = (void *) ((STORAGEHEADER *) ptr + 1);

	// Save off a pointer to the extra data.
	if (m_StgHdr.fFlags & STGHDR_EXTRADATA)
	{
		m_pbExtra = ptr;
		cbExtra = sizeof(ULONG) + *(ULONG *) ptr;
	}
	else
	{
		m_pbExtra = 0;
		cbExtra = 0;
	}

	// Get a pointer to the storage header struct.  Note the header itself has
	// been faulted in, this is just to get a specific pointer.
	ptr = (BYTE *) ptr + cbExtra;
	_ASSERTE(m_pStgIO->IsAlignedPtr((UINT_PTR) ptr, 4));

	// For read only, just access the header data.
	if (m_pStgIO->IsReadOnly())
	{
		// Save a pointer to the current list of streams.
		m_pStreamList = (STORAGESTREAM *) ptr;
	}
	// For writeable, need a copy we can modify.
	else
	{
		pStream = (STORAGESTREAM *) ptr;

		// Copy each of the stream headers.
		for (int i=0;  i<m_StgHdr.iStreams;  i++)
		{
			if ((pAppend = m_Streams.Append()) == 0)
				return (PostError(OutOfMemory()));
            memcpy (pAppend, pStream, pStream->GetStreamSize());
			pStream = pStream->NextStream();
			_ASSERTE(m_pStgIO->IsAlignedPtr((UINT_PTR) pStream, 4));
		}

		// All must be loaded and accounted for.
		_ASSERTE(m_StgHdr.iStreams == m_Streams.Count());
	}
	return (S_OK);
}


//*****************************************************************************
// Verify the header is something this version of the code can support.
//*****************************************************************************
HRESULT TiggerStorage::VerifyHeader()
{

	//@todo: add version check for format.
	return (S_OK);
}

//*****************************************************************************
// Print the sizes of the various streams.
//*****************************************************************************
#if defined(_DEBUG)
ULONG TiggerStorage::PrintSizeInfo(bool verbose)
{
#if !defined(UNDER_CE)
 	ULONG total = 0;

	printf("Storage Header:  %d\n",sizeof(STORAGEHEADER));
	if (m_pStreamList)
	{
		STORAGESTREAM *storStream = m_pStreamList;
		STORAGESTREAM *pNext;
		for (ULONG i = 0; i<m_StgHdr.iStreams; i++)
		{
			pNext = storStream->NextStream();
			printf("Stream #%d (%s) Header: %d, Data: %d\n",i,storStream->rcName, (BYTE*)pNext - (BYTE*)storStream, storStream->iSize);
			total += storStream->iSize;	
			storStream = pNext;
		}
	}
	else
	{
		//todo: Add support for the case where m_Streams exists and m_pStreamList does not
	}

	if (m_pbExtra)
	{
		printf("Extra bytes: %d\n",*(ULONG*)m_pbExtra);
		total += *(ULONG*)m_pbExtra;
	}
	return total;
#else // !UNDER_CE
	return 0;
#endif // UNDER_CE
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgtiggerstream.h ===
//*****************************************************************************
// StgTiggerStream.h
//
// TiggerStream is the companion to the TiggerStorage CoClass.  It handles the
// streams managed inside of the storage and does the direct file i/o.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgTiggerStream_h__
#define __StgTiggerStream_h__



#include "StgTiggerStorage.h"			// Data definitions.

enum
{
	STREAM_DATA_NAME
};


class TiggerStorage;


class TiggerStream : 
	public IStream
{
public:
	TiggerStream() :
		m_pStorage(0),
		m_cRef(1)
	{}

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *pp)
	{ return (BadError(E_NOTIMPL)); }
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{ return (InterlockedIncrement((long *) &m_cRef)); }
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		ULONG	cRef;
		if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
			delete this;
		return (cRef);
	}

// IStream
    virtual HRESULT STDMETHODCALLTYPE Read( 
        void		*pv,
        ULONG		cb,
        ULONG		*pcbRead);
    
    virtual HRESULT STDMETHODCALLTYPE Write( 
        const void	*pv,
        ULONG		cb,
        ULONG		*pcbWritten);

    virtual HRESULT STDMETHODCALLTYPE Seek( 
        LARGE_INTEGER dlibMove,
        DWORD		dwOrigin,
        ULARGE_INTEGER *plibNewPosition);
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        ULARGE_INTEGER libNewSize);
    
    virtual HRESULT STDMETHODCALLTYPE CopyTo( 
        IStream		*pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten);
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        DWORD		grfCommitFlags);
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void);
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD		dwLockType);
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD		dwLockType);
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        STATSTG		*pstatstg,
        DWORD		grfStatFlag);
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        IStream		**ppstm);


	HRESULT Init(							// Return code.
		TiggerStorage *pStorage,			// Parent storage.
		LPCSTR		szStream);				// Stream name.

	ULONG GetStreamSize();

private:
	TiggerStorage	*m_pStorage;		// Our parent storage.
	char			m_rcStream[MAXSTREAMNAME]; // Name of the stream.
	ULONG			m_cRef;				// Ref count.
};

#endif // __StgTiggerStream_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgsortedindex.h ===
//*****************************************************************************
// StgSortedIndex.h
// 
// This module contains StgSortedIndex Class. This class provides alternate index
// types to the previously provided hashed index type. The index enables multiple
// column keys and queries. The order of the data can be ascending or descending.
// This index also allows unique data entries.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __STGSORTEDINDEX_H__
#define __STGSORTEDINDEX_H__

#include "StgDef.h"
#include "StgIndexManageri.h"
#include "StgRecordManager.h"
#include "StgSortedIndexHelper.h"

class StgSortedIndex : public IStgIndex
{
friend StgSortedIndex;
public:

	StgSortedIndex(int iElemSize=sizeof(ULONG)) :
		m_pRecordHeap(0),	
		m_pRecordMgr(0),
		m_cbIndexDef(0),
		m_Data(iElemSize),
		m_cRef(0)
	{
		DEBUG_STMT(m_cbDebugSaveSize = 0);
	}

//*****************************************************************************
// Opens the index on top of the given table.
//*****************************************************************************
	virtual HRESULT Open(					// Return status.
		UINT_PTR	iIndexDef,				// The definition of the index.
		StgRecordManager *pRecordMgr,		// The record manager that owns us.
		RECORDHEAP	*pRecordHeap,			// The first heap for this table.
		ULONG		iRecords,				// If -1, unknown.
		STGINDEXHDR	*pIndexHdr,				// persisted index header data.
		ULONG		*pcbSize);				// Return size of index data.

//*****************************************************************************
// Close the index and free any run-time state.
//*****************************************************************************
	virtual void Close();	

//*****************************************************************************
// Returns the save size of this index object based on current data.
//*****************************************************************************
	virtual HRESULT GetSaveSize(			// Return status.
		ULONG		iIndexSize,				// Size of an index offset.
		ULONG		*pcbSave,				// Return save size here.
		ULONG		RecordCount);			// Total records to save, excluding deleted.

//*****************************************************************************
// Persist the index data into the stream.
//*****************************************************************************
	virtual HRESULT SaveToStream(			// Return status.
		IStream		*pIStream,				// Stream to save to.
		long		*pMappingTable=NULL,	// mapping table to map old rids
											// to new rids (due to deleting 
											// deleted and transient records).
		ULONG		RecordCount=0);			// Total records to save, excluding deleted.

//*****************************************************************************
// Called by the record manager's Save() method before it tells the page
// manager to flush all changed pages to disk.  The index should perform any
// changes it needs before this event.
//*****************************************************************************
	virtual HRESULT BeforeSave();	

//*****************************************************************************
// Called after a new row has been inserted into the table.  The index should
// update itself to reflect the new row.
//*****************************************************************************
	virtual HRESULT AfterInsert(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record after insert.
		int			bCheckDupes);			// true to enforce duplicates.

//*****************************************************************************
// Called after a row is deleted from a table.  The index must update itself
// to reflect the fact that the row is gone.
//*****************************************************************************
	virtual HRESULT AfterDelete(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord);			// The record to delete.

//*****************************************************************************
// Called before an update is applied to a row.  The data for the change is
// included.  The index must update itself if and only if the change in data
// affects the order of the index.
//*****************************************************************************
	virtual HRESULT BeforeUpdate(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record to be changed.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

//*****************************************************************************
// Called after a row has been updated.  This is our chance to update the
// index with the new column data.
//*****************************************************************************
	virtual HRESULT AfterUpdate(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record to be changed.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

//*****************************************************************************
// Looks up the given record given the column information.  The user data must
// match the data types of the indexed data exactly, no conversions are done.
// The order of the user columns must match the index definition exactly, no
// attempt to sort the columns is made.
//*****************************************************************************
	virtual HRESULT FindRecord(				// Return code.
		BYTE		*pData,					// User data.
		ULONG		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		DBCOMPAREOP rgfBindingCompare[],	// compare operators for the key columns.
		CFetchRecords *pFetchRecords,		// Return list of records here.
		BYTE		*pbFilterData,			// Filter data.
		ULONG		iFilterColumns,			// How many additional filter columns.
		DBBINDING	rgFilterBindings[],		// Bindings for filter data.
		DBCOMPAREOP	rgfCompare[]);			// Filter comparison operators.

//*****************************************************************************
// Looks up the given record given the column information.  The user data must
// match the data types of the indexed data exactly, no conversions are done.
// The order of the user columns must match the index definition exactly, no
// attempt to sort the columns is made.
// This function fills the bitVector, which is externally used to fill a cursor 
// (typically)
// NOTE: This function expects that when it has been called, either the first column
// comparator is not "NE" or if it is, then there is only one provided filter. The 
// reason for this is that in case of multiple column searches with "NE", the
// the function touches all the records in the table anyway. Since this is the
// case, might as well switch to a table scan with the appropriate filters.
//*****************************************************************************
	virtual HRESULT FindRecord(				// Return code.
		BYTE		*pData,					// User data.
		ULONG		iKeyColumns,			// key columns.
		ULONG		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the key columns
		CDynBitVector *pBits,				// record index in the array for the given data.
		int			iLevel=0);				// level of the query. 0-highest.

//**********************************************************************************************
// RangeScan:
//		This function scans starting from either iFirst or iLast depending upon the given direction.
//		The function checks to see if the key columns and remaining filter criteria match.
//		It stops looping when the only the key columns no longer match.
//**********************************************************************************************
	virtual HRESULT StgSortedIndex::RangeScan(
		BYTE		*pData,					// User data.
		ULONG		iKeyColumns,			// key columns
		ULONG		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the key columns.
		int			iFirst,					// first position in sub-range.
		int			iLast,					// last position in sub-range.
		BYTE		fDirection,				// direction of scan. forward or reverse.
		CDynBitVector *pBits);


//*****************************************************************************
// Returns the indentifier for this index type.
//*****************************************************************************
	virtual BYTE GetIndexType()	;	

//*****************************************************************************
// Return the index definition for this item.
//*****************************************************************************
	virtual STGINDEXDEF *GetIndexDef();		// The definition of the index.

//*****************************************************************************
// Get the name of this index into a buffer suitable for things like errors.
//*****************************************************************************
	HRESULT GetIndexName(					// Return code.
		LPWSTR		szName,					// Name buffer.
		int			cchName);				// Max name.

//*****************************************************************************
// If the index is unique or a primary key, then guarantee that this update
// does not cause a duplicate record.  Return an error if it does.
//*****************************************************************************
	HRESULT IsDuplicateRecord(				// Return code.
		STGINDEXDEF *pIndexDef,				// Index definition.
		BYTE		*pData,					// User data.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.
	
	int Count()
	{
		return (m_Data.Count());
	}

	virtual ULONG STDMETHODCALLTYPE AddRef()
	{ return (InterlockedIncrement((long *) &m_cRef)); }

	virtual ULONG STDMETHODCALLTYPE Release()
	{
		ULONG	cRef;
		if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
			delete this;
		return (cRef);
	}


private:
	RECORDHEAP	*m_pRecordHeap;
	StgRecordManager *m_pRecordMgr;
	UINT_PTR	m_cbIndexDef;
	CSortedIndexHelper	m_Data;
	ULONG		m_cRef;
#ifdef _DEBUG
	ULONG		m_cbDebugSaveSize;			// GetSaveSize debugging.
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgsortedindexhelper.h ===
//*****************************************************************************
// StgSortedIndexHelper.h
//
//	CSortedIndexHelper class is a used by the Sorted array index to manage
//	its data. This class exclusively controls the data.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once

#include "VMStructArray.h"
#include "StgRecordManager.h"

#define SORT_RECORD_NOT_FOUND		(-1)
#define SORT_NULL_VALUES			(-2)


class CSortedIndexHelper
{
friend CSortedIndexHelper;

public:	
	CSortedIndexHelper(int iElemSize) :
		m_pRecordHeap(0),
		m_pRecordMgr(0),	
		m_iElemSize(iElemSize),
		m_DataArray(iElemSize, 16)
	{
	}

	void SetIndexData(RECORDHEAP *pRecordHeap, StgRecordManager * pRecordMgr, ULONG iIndexDef)
	{ 
		m_pRecordHeap = pRecordHeap;
		m_pRecordMgr = pRecordMgr;
		m_cbIndexDef = iIndexDef;
	}
	
//**************************************************************************
// RemoveIndexEntry:
//		given a RecordID, this function deletes this entry m_DataArray.
//		bCompact option, although not implemented yet, is provided if in 
//		future, this needs to be added. 
//**************************************************************************
	HRESULT	RemoveIndexEntry(					//	return code
		RECORDID	&RecordID,					//	RecordID to search for.
		bool		bCompact);					//	reclaim holes in the array
	
//**************************************************************************
// InsertIndexEntry:
//		Given a chunk of data with bindings etc. applies B-search to 
//		find an appropriate location in the array. 
//**************************************************************************
	HRESULT	InsertIndexEntry(						
		RECORDID	&RecordId,					
		BYTE		*pData,						
		ULONG		iColumns,
		DBBINDING	rgBindings[]);

//**************************************************************************
// SearchByRecordValue:
//		This function uses B-Search find the record matching the criteria.
//		For speed, the function returns the first one it finds, instead of 
//		scanning for the first record in the array matching the criteria.
//		Return -1 if the record is not found. In all other cases, the return 
//		value is >= 0.
//**************************************************************************
	long SearchByRecordValue(
		BYTE		*pData,
		ULONG		iColumns,
		DBBINDING	rgBindings[],
		DBCOMPAREOP rgfCompare[],
		bool		bFindFirst=FALSE);

//**************************************************************************
// FindInsertPosition:
//		This function uses b-search to find an appropriate insert position.
//		pbPresent lets the caller know if there is a duplicate in the array.
//		That way, the onus is on the caller to maintain uniqueness of the
//		index if needed. 
//**************************************************************************
	long FindInsertPosition(
		BYTE		*pData,
		ULONG		iColumns,
		DBBINDING	rgBindings[],
		bool		*pbPresent);

//**************************************************************************
// FindFirst: wrapper around SearchByRecordValue.
//**************************************************************************
	long FindFirst(
		BYTE		*pData,
		ULONG		iColumns,
		DBBINDING	rgBindings[],
		DBCOMPAREOP rgfCompare[])
	{
		return (SearchByRecordValue(pData, iColumns, rgBindings, rgfCompare, TRUE));
	}

//**************************************************************************
// SearchByRecordID:
//		This function uses a linear search to find the record with the given RecordID.
//**************************************************************************
	long SearchByRecordID(
		RECORDID	&RecordID,
		int			iFirst,
		int			iLast);

	void Delete(long iIndex)
	{ m_DataArray.Delete(iIndex); }

	RECORDID Get(long iIndex)
	{ 
		void * pIndexVal = m_DataArray.Get(iIndex); 
		if (m_iElemSize == sizeof(BYTE))
			return (*((BYTE *) pIndexVal));
		else if (m_iElemSize == sizeof(short))
			return (*((USHORT *) pIndexVal));
		else 
			return (*(RECORDID *) pIndexVal);
	}

	int Count()
	{ return (m_DataArray.Count()); }

	STGINDEXDEF * GetIndexDef()	// The definition of the index.
	{
		_ASSERTE(m_pRecordMgr && m_cbIndexDef > sizeof(STGTABLEDEF));
	
		// Find the index in the table definition.
		STGTABLEDEF *pTbl = m_pRecordMgr->GetTableDef();
		STGINDEXDEF *pDex = (STGINDEXDEF *) ((UINT_PTR) pTbl + m_cbIndexDef);

		// In debug, validate that either we have too many keys to have the magic
		// byte, or that it is there.
		_ASSERTE(pDex->iKeys >= DFTKEYS || pDex->rgKeys[DFTKEYS - 1] == MAGIC_INDEX);
		return (pDex);
	}

//**************************************************************************
// InitOnMem:
//		Initialize the internals with the provided information.
//**************************************************************************
	void InitOnMem(ULONG iRecords, BYTE * pData)
	{
		int	elemSize = GetSizeForCount(iRecords);
		m_iElemSize = elemSize;
		m_DataArray.InitOnMem(elemSize, pData, iRecords, iRecords, 16);
	}

	HRESULT	SaveToStream(IStream * pIStream, long * pMappingTable, ULONG RecordCount,
				int cbCountSize);

	ULONG GetSaveSize(ULONG RecordCount);

	int After(STGINDEXDEF * pIndexDef, int iCmp)
	{ 
		_ASSERTE(pIndexDef->SORTDATA.fOrder == DBINDEX_COL_ORDER_ASC || pIndexDef->SORTDATA.fOrder == DBINDEX_COL_ORDER_DESC);
		if (((pIndexDef->SORTDATA.fOrder == DBINDEX_COL_ORDER_ASC) && (iCmp < 0)) ||
			((pIndexDef->SORTDATA.fOrder == DBINDEX_COL_ORDER_DESC) && (iCmp > 0)))
			return (+1);
		return (0);
	}

	int Before(STGINDEXDEF * pIndexDef, int iCmp)
	{ 
		_ASSERTE(pIndexDef->SORTDATA.fOrder == DBINDEX_COL_ORDER_ASC || pIndexDef->SORTDATA.fOrder == DBINDEX_COL_ORDER_DESC);
		if (((pIndexDef->SORTDATA.fOrder == DBINDEX_COL_ORDER_DESC) && (iCmp < 0)) ||
			((pIndexDef->SORTDATA.fOrder == DBINDEX_COL_ORDER_ASC) && (iCmp > 0)))
			return (+1);
		return (0);
	}


//****************************************************************************
// UpdateRid:
//		verify that with the mapping table that the rid is valid. If not, 
//		update it with the value in the mapping table. If pMappingTable is
//		not provided, assumes that there are no changes to the rid.
//****************************************************************************
	int UpdateRid(
		long	*pMappingTable, 
		RECORDID recordId,
		RECORDID *pSaveRecordId)
	{
		bool bRidValid = TRUE;

		if (pMappingTable)
		{
			if (((long *) pMappingTable)[recordId] != -1) 
			{
				*pSaveRecordId = (RECORDID) pMappingTable[recordId];
			}
			else 
				bRidValid = FALSE;
		}
		else
			*pSaveRecordId = recordId;
	
		return (bRidValid);
	}
		

//****************************************************************************
// Returns the size of rid requires given the count of records.  Sorted indexes
// use a 1, 2, or 4 byte value for rid.
//****************************************************************************
	static int GetSizeForCount(ULONG Records)
	{
		int elemSize = sizeof(long);
		if (Records <= 256)
			elemSize = sizeof(BYTE);
		else if (Records <= USHRT_MAX)
			elemSize = sizeof(short);
		return (elemSize);
	}

	int GetElemSize()
	{
		return (m_iElemSize);
	}

private:
	RECORDHEAP	*m_pRecordHeap;			// Records this index is managing.
	StgRecordManager *m_pRecordMgr;		// The table information to index.
	ULONG		m_cbIndexDef;			// Offset to index definition from table.
	int			m_iElemSize;			// Size of an array element.
	CStructArray m_DataArray;			// Data for the index itself.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgtiggerstream.cpp ===
//*****************************************************************************
// StgTiggerStream.h
//
// TiggerStream is the companion to the TiggerStorage CoClass.  It handles the
// streams managed inside of the storage and does the direct file i/o.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"
#include "CompLib.h"
#include "StgTiggerStream.h"
#include "StgTiggerStorage.h"



//
//
// IStream
//
//


HRESULT STDMETHODCALLTYPE TiggerStream::Read( 
    void		*pv,
    ULONG		cb,
    ULONG		*pcbRead)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Write( 
    const void	*pv,
    ULONG		cb,
    ULONG		*pcbWritten)
{
	return (m_pStorage->Write(m_rcStream, pv, cb, pcbWritten));
}


HRESULT STDMETHODCALLTYPE TiggerStream::Seek( 
    LARGE_INTEGER dlibMove,
    DWORD		dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::SetSize( 
    ULARGE_INTEGER libNewSize)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::CopyTo( 
    IStream		*pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Commit( 
    DWORD		grfCommitFlags)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Revert()
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::LockRegion( 
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD		dwLockType)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::UnlockRegion( 
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD		dwLockType)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Stat( 
    STATSTG		*pstatstg,
    DWORD		grfStatFlag)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Clone( 
    IStream		**ppstm)
{
	return (E_NOTIMPL);
}






HRESULT TiggerStream::Init(				// Return code.
	TiggerStorage *pStorage,			// Parent storage.
	LPCSTR		szStream)				// Stream name.
{
	// Save off the parent data source object and stream name.
	m_pStorage = pStorage;
	strcpy(m_rcStream, szStream);
	return (S_OK);
}


ULONG TiggerStream::GetStreamSize()
{
	STORAGESTREAM *pStreamInfo;
	VERIFY(pStreamInfo = m_pStorage->FindStream(m_rcStream));
	return (pStreamInfo->iSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgsortedindexhelper.cpp ===
//*****************************************************************************
// StgSortedIndexHelper.cpp
//
//	CSortedIndexHelper class is a used by the Sorted array index to manage
//	its data. This class exclusively controls the data.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"
#include "stgdef.h"
#include "StgSortedIndexHelper.h"
#include "StgSchema.h"


//********** Locals. **********************************************************
int _BindingsContainNullValue(ULONG iColumns, DBBINDING rgBinding[], const BYTE *pData);


//********** Code. ************************************************************


//*****************************************************************************
// RemoveIndexEntry:
//		given a RecordID, this function deletes this entry m_DataArray.
//		bCompact option, although not implemented yet, is provided if in 
//		future, this needs to be added. 
//*****************************************************************************
HRESULT CSortedIndexHelper::RemoveIndexEntry(	//	return code
	RECORDID	&RecordID,				//	RecordID to search for.
	bool		bCompact)				//	reclaim holes in the array
{
	long		recordIndex;
	HRESULT 	hr;

	recordIndex = SearchByRecordID(RecordID, 0, m_DataArray.Count()-1);
	if (recordIndex >= 0)
	{
		m_DataArray.Delete(recordIndex);
		hr = S_OK;
	}
	else
		hr = S_FALSE;
	return (hr);
}


//*****************************************************************************
// InsertIndexEntry:
//		Given a chunk of data with bindings etc. applies B-search to 
//		find an appropriate location in the array. 
//*****************************************************************************
HRESULT CSortedIndexHelper::InsertIndexEntry( // Return Code.
	RECORDID	&RecordId,				// Record id to be inserted.
	BYTE		*pData, 				// pData to apply the bindings on.
	ULONG		iColumns,				// number of filter columns.
	DBBINDING	rgBindings[])			// bindings.
{
	ULONG		iInsPos;
	RECORDID	*pNewRecordID;
	STGINDEXDEF *pIndexDef = GetIndexDef();
	bool		bPresent;				// to see if the entry is already 
										// in the index.
	LPCWSTR		rgErrorW = L"";			// for formatting the error string.
	HRESULT 	hr = E_FAIL;

	iInsPos = FindInsertPosition(pData, iColumns, rgBindings, &bPresent);
	_ASSERTE(iInsPos >= 0);

	if (bPresent && (pIndexDef->fFlags & DEXF_UNIQUE))
	{
		// there is already an occurence of the record in the index, 
		// but the index is supposed to be unique, so skip inserting it.
		SCHEMADEFS * pSchema = m_pRecordMgr->GetSchema();
		if (pSchema)
		{
			rgErrorW = pSchema->pNameHeap->GetString(pIndexDef->Name);
		}

		hr	= PostError(CLDB_E_INDEX_DUPLICATE, rgErrorW );
		goto ErrExit;
	}

	// The CStructArray() insert function simply appends the memory elem at the
	// given location. It is the users responsibility to copy the reqd data into
	// that location.
	pNewRecordID = (RECORDID *) m_DataArray.Insert(iInsPos);
	if (pNewRecordID)
	{
		hr = S_OK;
		*pNewRecordID = RecordId;
	}
	else
		hr = PostError(OutOfMemory());
	
ErrExit:
	return (hr);
}


//*****************************************************************************
// SearchByRecordID:
//		This function uses a linear search to find the record with the given RecordID.
//*****************************************************************************
long CSortedIndexHelper::SearchByRecordID(
	RECORDID	&RecordID,
	int 		iFirst,
	int 		iLast)
{
	RECORDID	arrayValue;
	long		i;

	// uses linear search.
	for (i=iFirst; i<=iLast; i++)
	{
		arrayValue = Get(i);
		if (arrayValue == RecordID)
			return (i);
	}

	return (-1);
}


//*****************************************************************************
// SearchByRecordValue:
//		This function uses B-Search find the record matching the criteria.
//		For speed, the function returns the first one it finds, instead of 
//		scanning for the first record in the array matching the criteria.
//		Return -1 if the record is not found, or -2 if null values are
//		present (illegal). In all other cases, the return value is >= 0.
//*****************************************************************************
long CSortedIndexHelper::SearchByRecordValue(
	BYTE		*pData,
	ULONG		iColumns,
	DBBINDING	rgBindings[],
	DBCOMPAREOP rgfCompare[],
	bool		bFindFirst)
{
	int iFirst, iLast, iMid;			// loop control
	int iCmp;							// compare result.
	long iRetVal = SORT_RECORD_NOT_FOUND; // if not found.
	STGRECORDHDR *pMidRecord;			
	STGINDEXDEF *pIndexDef = GetIndexDef();

	// Check for null values in the comparison list and given an error if found.
	if (_BindingsContainNullValue(iColumns, rgBindings, pData))
		return (SORT_NULL_VALUES);

	iFirst = 0;
	iLast = m_DataArray.Count() - 1;

	while (iFirst <= iLast) 
	{
		iMid = (iFirst + iLast) / 2;

		VERIFY(pMidRecord = m_pRecordHeap->GetRecordByIndex(Get(iMid)));
		iCmp = m_pRecordMgr->CompareKeys(pIndexDef, pMidRecord, pData, iColumns, rgBindings, rgfCompare);

		if (iCmp == 0)
		{
			// found the first match.
			iRetVal = iMid;
			break;
		}
		else if (After(pIndexDef, iCmp))
		{
			// depending upon the order of the index, the search might have to 
			// continue in the upper or lower half. After() abstracts that for
			// the algorithm
			iFirst = iMid + 1;
		}
		else 
		{	
			iLast = iMid - 1;
		}
	}

	return (iRetVal);
}


//*****************************************************************************
// FindInsertPosition:
//		This function uses b-search to find an appropriate insert position.
//		pbPresent lets the caller know if there is a duplicate in the array.
//		That way, the onus is on the caller to maintain uniqueness of the
//		index if needed. 
//*****************************************************************************
long CSortedIndexHelper::FindInsertPosition(
	BYTE			*pData,
	ULONG			iColumns,
	DBBINDING		rgBindings[],
	bool			*pbPresent)
{
	int iFirst, iLast, iMid;			// loop control.
	int 			iCmp;		
	long			iInsPos = 0;		// if there are no records.
	STGRECORDHDR	*pMidRecord;
	STGINDEXDEF 	*pIndexDef = GetIndexDef();

	_ASSERTE(pbPresent != NULL);

	iMid = 0;
	iFirst = 0;
	iLast = m_DataArray.Count() - 1;
	*pbPresent = false;

	while (iFirst <= iLast)
	{
		iMid = (iFirst + iLast) / 2;

		VERIFY(pMidRecord = m_pRecordHeap->GetRecordByIndex(Get(iMid)));
		iCmp = m_pRecordMgr->CompareKeys(pIndexDef, pMidRecord, pData, iColumns, rgBindings);

		if (iCmp == 0)
		{
			// atleast 1 record matched.
			iInsPos = iMid;
			*pbPresent = TRUE;
			break;
		}
		else if (After(pIndexDef, iCmp))
		{
			if (iFirst == iLast)
			{
				iInsPos = iFirst + 1;
				return (iInsPos);
			}
			iFirst = iMid + 1;
		}
		else
		{
			if (iFirst == iLast)
			{
				iInsPos = iLast;
				return (iInsPos);
			}
			iLast = iMid - 1;
		}
	}
	
	return (iMid);
}


//*****************************************************************************
// SaveToStream:
//		Save the array data to stream. Depending upon the number of records in 
//		the array, the record id is compressed to a 1-byte, 2-byte or uncompressed
//		4-byte value.
//		pMappingTable is an optional parameter which lets this code write out 
//		to stream the correct rid value for the record.
//		The function uses CQuickBytes which inherently uses 512+ bytes on the 
//		stack in addition to, if needed, space on the heap. 
//*****************************************************************************
HRESULT CSortedIndexHelper::SaveToStream( // Return code.
	IStream 	*pIStream,				// The stream to save to.
	long		*pMappingTable, 		// table to map old rids to new rids.
	ULONG		RecordCount,			// Total records to save, excluding deleted.
	int			cbCountSize)			// For alignment.
{
	CQuickBytes rgBuffer;
	void		*pBuffer;
	RECORDID	saveRecordID;
	ULONG		iSaveRecCount;
	int 		i;
	HRESULT 	hr = S_OK;

	int saveElemSize = CSortedIndexHelper::GetSizeForCount(RecordCount);
	
	// Allocate the output buffer.
	pBuffer = rgBuffer.Alloc(ALIGN4BYTE(cbCountSize + (saveElemSize * Count())));
	if (!pBuffer)
		return (BadError(OutOfMemory()));
	
	// Walk the list of rids and save off the final RID value.
	for (i=0, iSaveRecCount=0;  i<Count();  i++)
	{
		// check to see if there's a match
		if (UpdateRid(pMappingTable, Get(i), &saveRecordID))
		{
			if (saveElemSize == sizeof(BYTE))
			{
				_ASSERTE(saveRecordID <= 0xff);
				((BYTE *)pBuffer)[iSaveRecCount] = (BYTE) saveRecordID;
			}
			else if (saveElemSize == sizeof(USHORT))
			{
				_ASSERTE(saveRecordID <= 0xffff);
				((USHORT *)pBuffer)[iSaveRecCount] = (USHORT) saveRecordID;
			}
			else
			{
				((ULONG *)pBuffer)[iSaveRecCount] = (ULONG) saveRecordID;
			}

			iSaveRecCount++;
		}
	}
		
	// write to stream if needed.
	if (iSaveRecCount)
	{	
		_ASSERTE(iSaveRecCount == (ULONG) Count());
		
		// Must write 4 byte aligned when finished, which includes the 
		// count already written and the size of current data.
		ULONG cbWrite = ALIGN4BYTE(cbCountSize + (saveElemSize * iSaveRecCount));

		// But now take out the count, because we wrote that out already.
		cbWrite -= cbCountSize;
		
		// Now we can write the rest of the current data plus padding.
		hr = pIStream->Write(pBuffer, cbWrite, 0);
		if (FAILED(hr))
			goto ErrExit;
	}

	// no need to 4-byte align since we're always writing the 4-byte array.

ErrExit:
	// No need to explicitly free rgBuffer.
	return (hr);
}


//*****************************************************************************
// Return the size of the rid list.
//*****************************************************************************
ULONG CSortedIndexHelper::GetSaveSize(
	ULONG		RecordCount)
{
	ULONG		cbSave;
	cbSave = CSortedIndexHelper::GetSizeForCount(RecordCount) * Count();
	return (cbSave);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgtiggerstorage.h ===
//*****************************************************************************
// StgTiggerStorage.h
//
// TiggerStorage is a stripped down version of compound doc files.  Doc files
// have some very useful and complex features to them, unfortunately nothing
// comes for free.  Given the incredibly tuned format of existing .tlb files,
// every single byte counts and 10% added by doc files is just too exspensive.
//
// The storage itself is made up of a bunch of streams (each aligned to a 4 byte
// value), followed at the end of the file with the header.  The header is
// put at the end so that you can continue to write as many streams as you
// like without thrashing the disk.
//	+-------------------+
//	| Signature			|
//	+-------------------+
//	| Stream 1, 2, []	|
//	+-------------------+
//	| STORAGEHEADER		|
//	|   Extra data      |
//	|   STORAGESTREAM[]	|
//	+-------------------+
//	| offset			|
//	+-------------------+
//
// The STORAGEHEADER contains flags describing the rest of the file, including
// the ability to have extra data stored in the header.  If there is extra
// data, then immediately after the STORAGEHEADER struct is a 4 byte size of
// that data, followed immediately by the extra data.  The length must be
// 4 byte aligned so that the first STORAGESTREAM starts on an aligned
// boundary.  The contents of the extra data is caller defined.
//
// This code handles the signature at the start of the file, and the list of
// streams at the end (kept in the header).  The data in each stream is, of
// course, caller specific.
//
// This code requires the StgIO code to handle the input and output from the
// backing storage, whatever scheme that may be.  There are no consistency
// checks on the data (for example crc's) due to the expense in computation
// required.  There is a signature at the front of the file and in the header.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once

#include "UtilCode.h"					// Helpers.


//*****************************************************************************
// The signature ULONG is the first 4 bytes of the file format.  The second
// signature string starts the header containing the stream list.  It is used
// for an integrity check when reading the header in lieu of a more complicated
// system.
//*****************************************************************************
#define STORAGE_MAGIC_SIG	0x2B4D4F43	// COM+



//*****************************************************************************
// These values get written to the signature at the front of the file.  Changing
// these values should not be done lightly because all old files will no longer
// be supported.  In a future revision if a format change is required, a
// backwards compatible migration path must be provided.
//*****************************************************************************
#define FILE_VER_MAJOR	1
#define FILE_VER_MINOR	0

// These are the last legitimate 0.x version macros.  The file format has 
// sinced move up to 1.x (see macros above).  After COM+ 1.0/NT 5 RTM's, these
// macros should no longer be required or ever seen.
#define FILE_VER_MAJOR_v0	0

#ifdef COMPLUS98
#define FILE_VER_MINOR_v0	17
#else
#define FILE_VER_MINOR_v0	19
#endif


#define MAXSTREAMNAME	32

enum
{
	STGHDR_NORMAL			= 0x00,		// Normal default flags.
	STGHDR_EXTRADATA		= 0x01,		// Additional data exists after header.
};


//*****************************************************************************
// This is the formal signature area at the front of the file.
//*****************************************************************************
struct STORAGESIGNATURE
{
	ULONG		lSignature;				// "Magic" signature.
	USHORT		iMajorVer;				// Major file version.
	USHORT		iMinorVer;				// Minor file version.
};


//*****************************************************************************
// The header of the storage format.
//*****************************************************************************
struct STORAGEHEADER
{
	BYTE		fFlags;					// STGHDR_xxx flags.
	BYTE		pad;
	USHORT		iStreams;				// How many streams are there.
};


//*****************************************************************************
// Each stream is described by this struct, which includes the offset and size
// of the data.  The name is stored in ANSI null terminated.
//@todo: I don't like the way this gets used in a CDynArray, it would be better
// to have a linked list then you can pass the pointer to the stream and save
// some stupid lookups.
//*****************************************************************************
struct STORAGESTREAM
{
	ULONG		iOffset;				// Offset in file for this stream.
	ULONG		iSize;					// Size of the file.
	char		rcName[MAXSTREAMNAME];	// Start of name, null terminated.

	inline STORAGESTREAM *NextStream()
	{
		int			iLen = (int) strlen(rcName) + 1;
		iLen = ALIGN4BYTE(iLen);
		return ((STORAGESTREAM *) ((UINT_PTR) this + (sizeof(ULONG) * 2) + iLen));
	}

    inline ULONG GetStreamSize()
    {
        return (ULONG) (strlen(rcName) + 1 + (sizeof(STORAGESTREAM) - sizeof(rcName)));
    }

	inline LPCWSTR GetName(LPWSTR szName, int iMaxSize)
	{
		VERIFY(::W95MultiByteToWideChar(CP_ACP, 0, rcName, -1, szName, iMaxSize));
		return (szName);
	}
};
typedef CDynArray<STORAGESTREAM> STORAGESTREAMLST;


// Forwards.
class TiggerStream;
class StgIO;



class TiggerStorage : 
	public IStorage
{
friend TiggerStream;
public:
	TiggerStorage();
	~TiggerStorage();

// IUnknown so you can ref count this thing.
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *pp)
	{ return (BadError(E_NOTIMPL)); }
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{ return (InterlockedIncrement((long *) &m_cRef)); }
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		ULONG	cRef;
		if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
			delete this;
		return (cRef);
	}


//*****************************************************************************
// Init this storage object on top of the given storage unit.
//*****************************************************************************
	HRESULT Init(							// Return code.
		StgIO		*pStgIO);				// The I/O subsystem.

//*****************************************************************************
// Retrieves a the size and a pointer to the extra data that can optionally be
// written in the header of the storage system.  This data is not required to
// be in the file, in which case *pcbExtra will come back as 0 and pbData will
// be set to null.  You must have initialized the storage using Init() before
// calling this function.
//*****************************************************************************
	HRESULT GetExtraData(					// Return code.
		ULONG		*pcbExtra,				// Return size of extra data.
		BYTE		*&pbData);				// Return a pointer to extra data.

//*****************************************************************************
// Flushes the header to disk.
//*****************************************************************************
	HRESULT WriteHeader(					// Return code.
		STORAGESTREAMLST *pList,			// List of streams.		
		ULONG		cbExtraData,			// Size of extra data, may be 0.
		BYTE		*pbExtraData);			// Pointer to extra data for header.

//*****************************************************************************
// Called when all data has been written.  Forces cached data to be flushed
// and stream lists to be validated.
//*****************************************************************************
	HRESULT WriteFinished(					// Return code.
		STORAGESTREAMLST *pList,			// List of streams.		
		ULONG		*pcbSaveSize);			// Return size of total data.

//*****************************************************************************
// Tells the storage that we intend to rewrite the contents of this file.  The
// entire file will be truncated and the next write will take place at the
// beginning of the file.
//*****************************************************************************
	HRESULT Rewrite(						// Return code.
		LPWSTR		szBackup);				// If non-0, backup the file.

//*****************************************************************************
// Called after a successful rewrite of an existing file.  The in memory
// backing store is no longer valid because all new data is in memory and
// on disk.  This is essentially the same state as created, so free up some
// working set and remember this state.
//*****************************************************************************
	HRESULT ResetBackingStore();		// Return code.

//*****************************************************************************
// Called to restore the original file.  If this operation is successful, then
// the backup file is deleted as requested.  The restore of the file is done
// in write through mode to the disk help ensure the contents are not lost.
// This is not good enough to fulfill ACID props, but it ain't that bad.
//*****************************************************************************
	HRESULT Restore(						// Return code.
		LPWSTR		szBackup,				// If non-0, backup the file.
		int			bDeleteOnSuccess);		// Delete backup file if successful.

//*****************************************************************************
// Given the name of a stream that will be persisted into a stream in this
// storage type, figure out how big that stream would be including the user's
// stream data and the header overhead the file format incurs.  The name is
// stored in ANSI and the header struct is aligned to 4 bytes.
//*****************************************************************************
	static HRESULT GetStreamSaveSize(		// Return code.
		LPCWSTR		szStreamName,			// Name of stream.
		ULONG		cbDataSize,				// Size of data to go into stream.
		ULONG		*pcbSaveSize);			// Return data size plus stream overhead.

//*****************************************************************************
// Return the fixed size overhead for the storage implementation.  This includes
// the signature and fixed header overhead.  The overhead in the header for each
// stream is calculated as part of GetStreamSaveSize because these structs are
// variable sized on the name.
//*****************************************************************************
	static HRESULT GetStorageSaveSize(		// Return code.
		ULONG		*pcbSaveSize,			// [in] current size, [out] plus overhead.
		ULONG		cbExtra);				// How much extra data to store in header.

//*****************************************************************************
// Adjust the offset in each known stream to match where it will wind up after
// a save operation.
//*****************************************************************************
	static HRESULT CalcOffsets(				// Return code.
		STORAGESTREAMLST *pStreamList,		// List of streams for header.
		ULONG		cbExtra);				// Size of variable extra data in header.

// IStorage
	virtual HRESULT STDMETHODCALLTYPE CreateStream( 
		const OLECHAR *pwcsName,
		DWORD		grfMode,
		DWORD		reserved1,
		DWORD		reserved2,
		IStream 	**ppstm);

	virtual HRESULT STDMETHODCALLTYPE CreateStream( 
		LPCSTR		szName,
		DWORD		grfMode,
		DWORD		reserved1,
		DWORD		reserved2,
		IStream 	**ppstm);
	
	virtual HRESULT STDMETHODCALLTYPE OpenStream( 
		const OLECHAR *pwcsName,
		void		*reserved1,
		DWORD		grfMode,
		DWORD		reserved2,
		IStream 	**ppstm);
	
	virtual HRESULT STDMETHODCALLTYPE CreateStorage( 
		const OLECHAR *pwcsName,
		DWORD		grfMode,
		DWORD		dwStgFmt,
		DWORD		reserved2,
		IStorage	**ppstg);
	
	virtual HRESULT STDMETHODCALLTYPE OpenStorage( 
		const OLECHAR *pwcsName,
		IStorage	*pstgPriority,
		DWORD		grfMode,
		SNB 		snbExclude,
		DWORD		reserved,
		IStorage	**ppstg);
	
	virtual HRESULT STDMETHODCALLTYPE CopyTo( 
		DWORD		ciidExclude,
		const IID	*rgiidExclude,
		SNB 		snbExclude,
		IStorage	*pstgDest);
	
	virtual HRESULT STDMETHODCALLTYPE MoveElementTo( 
		const OLECHAR *pwcsName,
		IStorage	*pstgDest,
		const OLECHAR *pwcsNewName,
		DWORD		grfFlags);
	
	virtual HRESULT STDMETHODCALLTYPE Commit( 
		DWORD		grfCommitFlags);
	
	virtual HRESULT STDMETHODCALLTYPE Revert();
	
	virtual HRESULT STDMETHODCALLTYPE EnumElements( 
		DWORD		reserved1,
		void		*reserved2,
		DWORD		reserved3,
		IEnumSTATSTG **ppenum);
	
	virtual HRESULT STDMETHODCALLTYPE DestroyElement( 
		const OLECHAR *pwcsName);
	
	virtual HRESULT STDMETHODCALLTYPE RenameElement( 
		const OLECHAR *pwcsOldName,
		const OLECHAR *pwcsNewName);
	
	virtual HRESULT STDMETHODCALLTYPE SetElementTimes( 
		const OLECHAR *pwcsName,
		const FILETIME *pctime,
		const FILETIME *patime,
		const FILETIME *pmtime);
	
	virtual HRESULT STDMETHODCALLTYPE SetClass( 
		REFCLSID	clsid);
	
	virtual HRESULT STDMETHODCALLTYPE SetStateBits( 
		DWORD		grfStateBits,
		DWORD		grfMask);
	
	virtual HRESULT STDMETHODCALLTYPE Stat( 
		STATSTG 	*pstatstg,
		DWORD		grfStatFlag);

	virtual HRESULT STDMETHODCALLTYPE OpenStream( 
		LPCWSTR 	szStream,
		ULONG		*pcbData,
		void		**ppAddress);

	// Access storage object.
	StgIO *GetStgIO()
	{ return (m_pStgIO); }

#if defined(_DEBUG)
	ULONG PrintSizeInfo(				// Size of streams.
		bool verbose);					// Be verbose?
#endif

protected:
	HRESULT Write(						// Return code.
		LPCSTR		szName, 			// Name of stream we're writing.
		const void *pData,				// Data to write.
		ULONG		cbData, 			// Size of data.
		ULONG		*pcbWritten);		// How much did we write.

private:
	STORAGESTREAM *FindStream(LPCSTR szName);
	HRESULT WriteSignature();
	HRESULT VerifySignature(STORAGESIGNATURE *pSig);
	HRESULT ReadHeader();
	HRESULT ReadHeader_v0();
	HRESULT VerifyHeader();

private:
	// State data.
	StgIO		*m_pStgIO;				// Storage subsystem.
	ULONG		m_cRef;					// Ref count for COM.

	// Header data.
	STORAGEHEADER m_StgHdr;				// Header for storage.
	STORAGESTREAMLST m_Streams;			// List of streams in the storage.
	STORAGESTREAM *m_pStreamList;		// For read mode.
	void		*m_pbExtra;				// Pointer to extra data if on disk.
};


//*****************************************************************************
// Debugging helpers.  #define __SAVESIZE_TRACE__ to enable.
//*****************************************************************************

// #define __SAVESIZE_TRACE__
#ifdef __SAVESIZE_TRACE__
#define SAVETRACE(func) DEBUG_STMT(func)
#else
#define SAVETRACE(func)
#endif // __SAVESIZE_TRACE__




// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgtsicr.cpp ===
//*****************************************************************************
// StgTSICR.cpp
//
// This version of the ICR interfaces are thread safe wrappers on the regular
// interface.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h" 					// Standard header.
#include "StgSchema.h"					// Core schema defs.
#include "StgDatabase.h"				// Database definitions.
#include "StgRecordManager.h"			// Record api.
#include "StgIO.h"						// Storage api.
#include "StgTiggerStorage.h"			// Storage subsystem.
#include "OleDBUtil.h"					// Binding helpers.
#include "DBSchema.h"					// Default schema and bindings.



//********** Types. ***********************************************************

//
// Read/Write version of the locking interface.
//
class StgTSICRReadWrite : public IComponentRecords, public IComponentRecordsSchema
{
public:
	StgTSICRReadWrite(IComponentRecords *pICR) :
		m_pICR(pICR),
		m_cRef(1)
	{ 
		_ASSERTE(pICR);
		pICR->AddRef();
	}

	~StgTSICRReadWrite()
	{
		if (m_pICR)
			m_pICR->Release();
		m_pICR = 0;
	}


//
// IUnknown
//
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *pp)
	{
		HRESULT 	hr = S_OK;

		*pp = 0;

		// Check for the desired interface.
		if (riid == IID_IUnknown)
			*pp = (IUnknown *) (IComponentRecords *) this;
		else if (riid == IID_ITSComponentRecords)
			*pp = (IComponentRecords *) this;
		else if (riid == IID_ITSComponentRecordsSchema)
			*pp = (IComponentRecordsSchema *) this;
		else
		{
			_ASSERTE(!"Unknown iid");
			hr = E_NOINTERFACE;
		}
		if (SUCCEEDED(hr))
			AddRef();
		return (hr);
	}

	virtual ULONG STDMETHODCALLTYPE AddRef()
	{ return (InterlockedIncrement((long *) &m_cRef)); }

	virtual ULONG STDMETHODCALLTYPE Release()
	{
		ULONG	cRef;
		if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
			delete this;
		return (cRef);
	}

//
// IComponentRecords
//


	virtual HRESULT STDMETHODCALLTYPE NewRecord(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		void		**ppData,				// Return new record here.
		OID 		_oid,					// ID of the record.
		ULONG		iOidColumn, 			// Ordinal of OID column.
		ULONG		*pRecordID) 			// Optionally return the record id.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->NewRecord(tableid, ppData, _oid, iOidColumn, pRecordID));
	}

	virtual HRESULT STDMETHODCALLTYPE NewTempRecord(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		void		**ppData,				// Return new record here.
		OID 		_oid,					// ID of the record.
		ULONG		iOidColumn, 			// Ordinal of OID column.
		ULONG		*pRecordID) 			// Optionally return the record id.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->NewTempRecord(tableid, ppData, _oid, iOidColumn, pRecordID));
	}

	virtual HRESULT STDMETHODCALLTYPE NewRecordAndData( // Return code.
		TABLEID		tableid,				// Which table to work on.
		void		**ppData,				// Return new record here.
		ULONG		*pRecordID,				// Optionally return the record id.
		int			fFlags,					// ICR_RECORD_xxx value, 0 default.
		int			iCols,					// number of columns
		const DBTYPE rgiType[],				// data types of the columns.
		const void	*rgpbBuf[],				// pointers to where the data will be stored.
		const ULONG	cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT		rgResult[],				// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
		const ULONG	*rgFieldMask)			// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->NewRecordAndData(tableid, ppData, pRecordID, fFlags, iCols,
				rgiType, rgpbBuf, cbBuf, pcbBuf, rgResult, rgFieldMask));
	}

	virtual HRESULT STDMETHODCALLTYPE GetStruct(	//Return Code
		TABLEID 	tableid,				// Which table to work on.
		int 		iRows,					// number of rows for bulk fetch.
		void		*rgpRowPtr[],			// pointer to array of row pointers.
		int 		cbRowStruct,			// size of <table name>_RS structure.
		void		*rgpbBuf,				// pointer to the chunk of memory where the
											// retrieved data will be placed.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask) 			// mask to specify a subset of fields.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetStruct(tableid, iRows, rgpRowPtr, cbRowStruct, 
				rgpbBuf, rgResult, fFieldMask));
	}

	virtual HRESULT STDMETHODCALLTYPE SetStruct(	// Return Code
		TABLEID 	tableid,				// table to work on.
		int 		iRows,					// number of Rows for bulk set.
		void		*rgpRowPtr[],			// pointer to array of row pointers.
		int 		cbRowStruct,			// size of <table name>_RS struct.
		void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask, 			// mask to specify a subset of the fields.
		ULONG		fNullFieldMask) 		// fields which need to be set to NULL.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SetStruct(tableid, iRows, rgpRowPtr, cbRowStruct,
					rgpbBuf, rgResult, fFieldMask, fNullFieldMask));
	}

	virtual HRESULT STDMETHODCALLTYPE InsertStruct( // Return Code
		TABLEID 	tableid,				// table to work on.
		int 		iRows,					// number of Rows for bulk set.
		void		*rgpRowPtr[],			// Return pointer to new values.
		int 		cbRowStruct,			// size of <table name>_RS struct.
		void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask, 			// mask to specify a subset of the fields.
		ULONG		fNullFieldMask) 		// fields which need to be set to null.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->InsertStruct(tableid, iRows, rgpRowPtr, cbRowStruct,
				rgpbBuf, rgResult, fFieldMask, fNullFieldMask));
	}
	
	virtual HRESULT STDMETHODCALLTYPE GetColumns(	// Return code.
		TABLEID 	tableid,				// table to work on.
		const void	*pRowPtr,				// row pointer
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		ULONG		cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// array of HRESULT for iCols.
		const ULONG	*rgFieldMask)			// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetColumns(tableid, pRowPtr, iCols, rgiType, rgpbBuf,
				cbBuf, pcbBuf, rgResult, rgFieldMask));
	}

	virtual HRESULT STDMETHODCALLTYPE SetColumns(	// Return code.
		TABLEID 	tableid,				// table to work on.
		void		*pRowPtr,				// row pointer
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		const ULONG cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// array of HRESULT for iCols.
		const ULONG	*rgFieldMask)			// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SetColumns(tableid, pRowPtr, iCols, rgiType,
				rgpbBuf, cbBuf, pcbBuf, rgResult, rgFieldMask));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRecordCount(// Return code.
		TABLEID 	tableid,				// Which table to work on.
		ULONG		*piCount)				// Not including deletes.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetRecordCount(tableid, piCount));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRowByOid(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		OID 		_oid,					// Value for keyed lookup.
		ULONG		iColumn,				// 1 based column number (logical).
		void		**ppStruct) 			// Return pointer to record.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetRowByOid(tableid, _oid, iColumn, ppStruct));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRowByRID(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		rid,					// Record id.
		void		**ppStruct) 			// Return pointer to record.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetRowByRID(tableid, rid, ppStruct));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRIDForRow(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		const void	*pRecord,				// The record we want RID for.
		ULONG		*pirid) 				// Return the RID for the given row.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetRIDForRow(tableid, pRecord, pirid));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRowByColumn( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pData, 				// User data.
		ULONG		cbData, 				// Size of data (blobs)
		DBTYPE		iType,					// What type of data given.
		void		*rgRecords[],			// Return array of records here.
		int 		iMaxRecords,			// Max that will fit in rgRecords.
		RECORDLIST	*pRecords,				// If variable rows desired.
		int 		*piFetched) 			// How many records were fetched.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetRowByColumn(tableid, iColumn, pData, cbData,
				iType, rgRecords, iMaxRecords, pRecords, piFetched));
	}

	virtual HRESULT STDMETHODCALLTYPE QueryByColumns( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
		TABLEID 	tableid,				// Which table to work with.
		const QUERYHINT *pQryHint,			// What index to use, NULL valid.
		int 		iColumns,				// How many columns to query on.
		const ULONG rgiColumn[],			// 1 based column numbers.
		const DBCOMPAREOP rgfCompare[], 	// Comparison operators, NULL means ==.
		const void	*rgpbData[],			// User data.
		const ULONG rgcbData[], 			// Size of data (blobs)
		const DBTYPE rgiType[], 			// What type of data given.
		void		*rgRecords[],			// Return array of records here.
		int 		iMaxRecords,			// Max that will fit in rgRecords.
		CRCURSOR	*psCursor,				// Buffer for the cursor handle.
		int 		*piFetched) 			// How many records were fetched.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->QueryByColumns(tableid, pQryHint, iColumns, rgiColumn,
				rgfCompare, rgpbData, rgcbData, rgiType, rgRecords,
				iMaxRecords, psCursor, piFetched));
	}

	virtual HRESULT STDMETHODCALLTYPE OpenCursorByColumn(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pData, 				// User data.
		ULONG		cbData, 				// Size of data (blobs)
		DBTYPE		iType,					// What type of data given.
		CRCURSOR	*psCursor)				// Buffer for the cursor handle.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->OpenCursorByColumn(tableid, iColumn, pData, cbData,
				iType, psCursor));
	}

	virtual HRESULT STDMETHODCALLTYPE ReadCursor(// Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		void		*rgRecords[],			// Return array of records here.
		int 		*piRecords) 			// Max that will fit in rgRecords.
	{
		CLock		sLock(GetThisLock());
		_ASSERTE(m_pICR);
		return (m_pICR->ReadCursor(psCursor, rgRecords, piRecords));
	}

	virtual HRESULT STDMETHODCALLTYPE MoveTo( // Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		ULONG		iIndex) 				// New index.
	{
		CLock		sLock(GetThisLock());
		_ASSERTE(m_pICR);
		return (m_pICR->MoveTo(psCursor, iIndex));
	}

	virtual HRESULT STDMETHODCALLTYPE GetCount( // Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		ULONG		*piCount)				// Return the count.
	{
		CLock		sLock(GetThisLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetCount(psCursor, piCount));
	}

	virtual HRESULT STDMETHODCALLTYPE CloseCursor(// Return code.
		CRCURSOR	*psCursor)				// The cursor handle.
	{
		CLock		sLock(GetThisLock());
		_ASSERTE(m_pICR);
		return (m_pICR->CloseCursor(psCursor));
	}

	virtual HRESULT STDMETHODCALLTYPE GetStringUtf8( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPCSTR		*pszOutBuffer)			// Where to put string pointer.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetStringUtf8(tableid, iColumn, pRecord, pszOutBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE GetStringA( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPSTR		szOutBuffer,			// Where to write string.
		int 		cchOutBuffer,			// Max size, including room for \0.
		int 		*pchString) 			// Size of string is put here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetStringA(tableid, iColumn, pRecord,
				szOutBuffer, cchOutBuffer, pchString));
	}

	virtual HRESULT STDMETHODCALLTYPE GetStringW( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPWSTR		szOutBuffer,			// Where to write string.
		int 		cchOutBuffer,			// Max size, including room for \0.
		int 		*pchString) 			// Size of string is put here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetStringW(tableid, iColumn, pRecord,
				szOutBuffer, cchOutBuffer, pchString));
	}

	virtual HRESULT STDMETHODCALLTYPE GetBstr( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		BSTR		*pBstr) 				// Output for bstring on success.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetBstr(tableid, iColumn, pRecord, pBstr));
	}

	virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		BYTE		*pOutBuffer,			// Where to write blob.
		ULONG		cbOutBuffer,			// Size of output buffer.
		ULONG		*pcbOutBuffer)			// Return amount of data available.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetBlob(tableid, iColumn, pRecord,
				pOutBuffer, cbOutBuffer, pcbOutBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
		TABLEID		tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		const BYTE	**ppBlob,				// Pointer to blob.
		ULONG		*pcbSize) 				// Size of blob.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetBlob(tableid, iColumn, pRecord, ppBlob, pcbSize));
	}

	virtual HRESULT STDMETHODCALLTYPE GetOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		OID 		*poid)					// Return id here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetOid(tableid, iColumn, pRecord, poid));
	}

	virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		VARIANT 	*pValue)				// Put the variant here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetVARIANT(tableid, iColumn, pRecord, pValue));
	}

	virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		const void	**ppBlob,				// Put Pointer to blob here.
		ULONG		*pcbSize)				// Put Size of blob here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetVARIANT(tableid, iColumn, pRecord, ppBlob, pcbSize));
	}

	virtual HRESULT STDMETHODCALLTYPE GetVARIANTType( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		VARTYPE 	*pType) 				// Put VARTEPE here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetVARIANTType(tableid, iColumn, pRecord, pType));
	}

	virtual HRESULT STDMETHODCALLTYPE GetGuid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		GUID		*pGuid) 				// Return guid here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetGuid(tableid, iColumn, pRecord, pGuid));
	}

	virtual HRESULT STDMETHODCALLTYPE IsNull( // S_OK yes, S_FALSE no.
		TABLEID 	tableid,				// Which table to work with.
		const void	*pRecord,				// Record with data.
		ULONG		iColumn)				// 1 based column number (logical).
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->IsNull(tableid, pRecord, iColumn));
	}

	virtual HRESULT STDMETHODCALLTYPE PutStringUtf8( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCSTR		szString,				// String we are writing.
		int 		cbBuffer)				// Bytes in string, -1 null terminated.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutStringUtf8(tableid, iColumn, pRecord, szString, cbBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE PutStringA( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCSTR		szString,				// String we are writing.
		int 		cbBuffer)				// Bytes in string, -1 null terminated.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutStringA(tableid, iColumn, pRecord, szString, cbBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE PutStringW( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCWSTR 	szString,				// String we are writing.
		int 		cbBuffer)				// Bytes (not characters) in string, -1 null terminated.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutStringW(tableid, iColumn, pRecord, szString, cbBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE PutBlob( // Return code.
		TABLEID		tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const BYTE	*pBuffer,				// User data.
		ULONG		cbBuffer) 				// Size of buffer.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutBlob(tableid, iColumn, pRecord, pBuffer, cbBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE PutOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		OID 		oid)					// Return id here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutOid(tableid, iColumn, pRecord, oid));
	}

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const VARIANT *pValue)				// The variant to write.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutVARIANT(tableid, iColumn, pRecord, pValue));
	}

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const void	*pBuffer,				// User data to write as a variant.
		ULONG		cbBuffer)				// Size of buffer.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutVARIANT(tableid, iColumn, pRecord, pBuffer, cbBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		VARTYPE 	vt, 					// Type of data.
		const void	*pValue)				// The actual data.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutVARIANT(tableid, iColumn, pRecord, vt, pValue));
	}

	virtual HRESULT STDMETHODCALLTYPE PutGuid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		REFGUID 	guid)					// Guid to put.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->PutGuid(tableid, iColumn, pRecord, guid));
	}

	virtual void STDMETHODCALLTYPE SetNull(
		TABLEID 	tableid,				// Which table to work with.
		void		*pRecord,				// Record with data.
		ULONG		iColumn)				// 1 based column number (logical).
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		m_pICR->SetNull(tableid, pRecord, iColumn);
	}

	virtual HRESULT STDMETHODCALLTYPE DeleteRowByRID(
		TABLEID 	tableid,				// Which table to work with.
		ULONG		rid)					// Record id.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->DeleteRowByRID(tableid, rid));
	}

	virtual HRESULT STDMETHODCALLTYPE GetCPVARIANT( // Return code.
		USHORT		ixCP,					// 1 based Constant Pool index.
		VARIANT 	*pValue)				// Put the data here.
	{
		return (E_NOTIMPL);
	}

	virtual HRESULT STDMETHODCALLTYPE AddCPVARIANT( // Return code.
		VARIANT 	*pValue,				// The variant to write.
		ULONG		*pixCP) 				// Put 1 based Constant Pool index here.
	{
		return (E_NOTIMPL);
	}


//*****************************************************************************
//
//********** File and schema functions.
//
//*****************************************************************************


	virtual HRESULT STDMETHODCALLTYPE SchemaAdd( // Return code.
		const COMPLIBSCHEMABLOB *pSchema)	// The schema to add.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SchemaAdd(pSchema));
	}
	
	virtual HRESULT STDMETHODCALLTYPE SchemaDelete( // Return code.
		const COMPLIBSCHEMABLOB *pSchema)	// The schema to add.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SchemaDelete(pSchema));
	}

	virtual HRESULT STDMETHODCALLTYPE SchemaGetList( // Return code.
		int 		iMaxSchemas,			// How many can rgSchema handle.
		int 		*piTotal,				// Return how many we found.
		COMPLIBSCHEMADESC rgSchema[])		// Return list here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SchemaGetList(iMaxSchemas, piTotal, rgSchema));
	}

	virtual HRESULT STDMETHODCALLTYPE OpenTable( // Return code.
		const COMPLIBSCHEMA *pSchema,		// Schema identifier.
		ULONG		iTableNum,				// Table number to open.
		TABLEID 	*pTableID)				// Return ID on successful open.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->OpenTable(pSchema, iTableNum, pTableID));
	}

	virtual HRESULT STDMETHODCALLTYPE GetSaveSize(
		CorSaveSize fSave,					// cssQuick or cssAccurate.
		DWORD		*pdwSaveSize)			// Return size of saved item.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetSaveSize(fSave, pdwSaveSize));
	}

	virtual HRESULT STDMETHODCALLTYPE SaveToStream(// Return code.
		IStream 	*pIStream)				// Where to save the data.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SaveToStream(pIStream));
	}

	virtual HRESULT STDMETHODCALLTYPE Save( 
		LPCWSTR szFile) 
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->Save(szFile));
	}

	virtual HRESULT STDMETHODCALLTYPE GetDBSize( // Return code.
		ULONG		*pcbSize)				// Return size on success.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetDBSize(pcbSize));
	}

	virtual HRESULT STDMETHODCALLTYPE LightWeightOpen() 
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->LightWeightOpen());
	}

	virtual HRESULT STDMETHODCALLTYPE LightWeightClose() 
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->LightWeightClose());
	}

	
	virtual HRESULT STDMETHODCALLTYPE NewOid( 
		OID *poid) 
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->NewOid(poid));
	}

	virtual HRESULT STDMETHODCALLTYPE GetObjectCount( 
		ULONG		*piCount) 
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetObjectCount(piCount));
	}
	
	virtual HRESULT STDMETHODCALLTYPE OpenSection(
		LPCWSTR 	szName, 				// Name of the stream.
		DWORD		dwFlags,				// Open flags.
		REFIID		riid,					// Interface to the stream.
		IUnknown	**ppUnk)				// Put the interface here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->OpenSection(szName, dwFlags, riid, ppUnk));
	}

	virtual HRESULT STDMETHODCALLTYPE GetOpenFlags(
		DWORD		*pdwFlags) 
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->GetOpenFlags(pdwFlags));
	}

	virtual HRESULT STDMETHODCALLTYPE SetHandler(
		IUnknown	*pHandler)				// The handler.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SetHandler(pHandler));
	}

//
// IComponentRecordsSchema
//

	virtual HRESULT GetTableDefinition( 	// Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		ICRSCHEMA_TABLE *pTableDef) 		// Return table definition data.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetTableDefinition(TableID, pTableDef));
	}

	virtual HRESULT GetColumnDefinitions(	// Return code.
		ICRCOLUMN_GET GetType,				// How to retrieve the columns.
		TABLEID 	TableID,				// Return ID on successful open.
		ICRSCHEMA_COLUMN rgColumns[],		// Return array of columns.
		int 		ColCount)				// Size of the rgColumns array, which
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetColumnDefinitions(GetType, TableID, rgColumns, ColCount));
	}

	virtual HRESULT GetIndexDefinition( 	// Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		LPCWSTR 	szIndex,				// Name of the index to retrieve.
		ICRSCHEMA_INDEX *pIndex)			// Return index description here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetIndexDefinition(TableID, szIndex, pIndex));
	}

	virtual HRESULT GetIndexDefinitionByNum( // Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		int 		IndexNum,				// Index to return.
		ICRSCHEMA_INDEX *pIndex)			// Return index description here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetIndexDefinitionByNum(TableID, IndexNum, pIndex));
	}

	virtual HRESULT  CreateTableEx(			// Return code.
		LPCWSTR		szTableName,			// Name of new table to create.
		int			iColumns,				// Columns to put in table.
		ICRSCHEMA_COLUMN	rColumnDefs[],	// Array of column definitions.
		USHORT		usFlags, 				// Create values for flags.
		USHORT		iRecordStart,			// Start point for records.
		TABLEID		tableid,				// Hard coded ID if there is one.
		BOOL		bMultiPK)				// The table has multi-column PK.
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->CreateTableEx(szTableName,iColumns,rColumnDefs,usFlags,iRecordStart,tableid,bMultiPK));
	}

	virtual HRESULT CreateIndexEx(			// Return code.
		LPCWSTR		szTableName,			// Name of table to put index on.
		ICRSCHEMA_INDEX	*pInIndexDef,		// Index description.
		const DBINDEXCOLUMNDESC rgInKeys[] )// Which columns make up key.
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->CreateIndexEx(szTableName,pInIndexDef, rgInKeys));
	}

	virtual HRESULT GetSchemaBlob(			//Return code.
		ULONG* cbSchemaSize,				//schema blob size
		BYTE**  pSchema,					//schema blob
		ULONG* cbNameHeap,					//name heap size
		HGLOBAL*  phNameHeap)				//name heap blob
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetSchemaBlob(cbSchemaSize,pSchema,cbNameHeap,phNameHeap));
	}

	RTSemExclusive *GetLock()
	{ return (((StgDatabase *) m_pICR)->GetLock()); }

	RTSemExclusive *GetThisLock()
	{ return (&m_Lock); }

private:
	IComponentRecords *m_pICR;				// Delegate pointer.
	RTSemExclusive m_Lock;					// For locking at this level.
	ULONG		m_cRef; 					// Ref counting.
};  // StgTSICRReadWrite



//
// Read Only version of the interface.
//
class StgTSICRReadOnly : public IComponentRecords, public IComponentRecordsSchema
{
public:
	StgTSICRReadOnly(IComponentRecords *pICR) :
		m_pICR(pICR),
		m_cRef(1)
	{ 
		_ASSERTE(pICR);
		pICR->AddRef();
	}

	~StgTSICRReadOnly()
	{
		if (m_pICR)
			m_pICR->Release();
		m_pICR = 0;
	}


//
// IUnknown
//
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *pp)
	{
		HRESULT 	hr = S_OK;

		*pp = 0;

		// Check for the desired interface.
		if (riid == IID_IUnknown)
			*pp = (IUnknown *) (IComponentRecords *) this;
		else if (riid == IID_ITSComponentRecords)
			*pp = (IComponentRecords *) this;
		else if (riid == IID_ITSComponentRecordsSchema)
			*pp = (IComponentRecordsSchema *) this;
		else
		{
			_ASSERTE(!"Unknown iid");
			hr = E_NOINTERFACE;
		}
		if (SUCCEEDED(hr))
			AddRef();
		return (hr);
	}

	virtual ULONG STDMETHODCALLTYPE AddRef()
	{ return (InterlockedIncrement((long *) &m_cRef)); }

	virtual ULONG STDMETHODCALLTYPE Release()
	{
		ULONG	cRef;
		if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
			delete this;
		return (cRef);
	}

//
// IComponentRecords
//


	virtual HRESULT STDMETHODCALLTYPE NewRecord(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		void		**ppData,				// Return new record here.
		OID 		_oid,					// ID of the record.
		ULONG		iOidColumn, 			// Ordinal of OID column.
		ULONG		*pRecordID) 			// Optionally return the record id.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE NewTempRecord(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		void		**ppData,				// Return new record here.
		OID 		_oid,					// ID of the record.
		ULONG		iOidColumn, 			// Ordinal of OID column.
		ULONG		*pRecordID) 			// Optionally return the record id.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE NewRecordAndData( // Return code.
		TABLEID		tableid,				// Which table to work on.
		void		**ppData,				// Return new record here.
		ULONG		*pRecordID,				// Optionally return the record id.
		int			fFlags,					// ICR_RECORD_xxx value, 0 default.
		int			iCols,					// number of columns
		const DBTYPE rgiType[],				// data types of the columns.
		const void	*rgpbBuf[],				// pointers to where the data will be stored.
		const ULONG	cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT		rgResult[],				// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
		const ULONG	*rgFieldMask)			// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE GetStruct(	//Return Code
		TABLEID 	tableid,				// Which table to work on.
		int 		iRows,					// number of rows for bulk fetch.
		void		*rgpRowPtr[],			// pointer to array of row pointers.
		int 		cbRowStruct,			// size of <table name>_RS structure.
		void		*rgpbBuf,				// pointer to the chunk of memory where the
											// retrieved data will be placed.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask) 			// mask to specify a subset of fields.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetStruct(tableid, iRows, rgpRowPtr, cbRowStruct, 
				rgpbBuf, rgResult, fFieldMask));
	}

	virtual HRESULT STDMETHODCALLTYPE SetStruct(	// Return Code
		TABLEID 	tableid,				// table to work on.
		int 		iRows,					// number of Rows for bulk set.
		void		*rgpRowPtr[],			// pointer to array of row pointers.
		int 		cbRowStruct,			// size of <table name>_RS struct.
		void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask, 			// mask to specify a subset of the fields.
		ULONG		fNullFieldMask) 		// fields which need to be set to NULL.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE InsertStruct( // Return Code
		TABLEID 	tableid,				// table to work on.
		int 		iRows,					// number of Rows for bulk set.
		void		*rgpRowPtr[],			// Return pointer to new values.
		int 		cbRowStruct,			// size of <table name>_RS struct.
		void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask, 			// mask to specify a subset of the fields.
		ULONG		fNullFieldMask) 		// fields which need to be set to null.
	{
		return (PostError(CLDB_E_READONLY));
	}
	
	virtual HRESULT STDMETHODCALLTYPE GetColumns(	// Return code.
		TABLEID 	tableid,				// table to work on.
		const void	*pRowPtr,				// row pointer
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		ULONG		cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// array of HRESULT for iCols.
		const ULONG	*rgFieldMask)			// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetColumns(tableid, pRowPtr, iCols, rgiType, rgpbBuf,
				cbBuf, pcbBuf, rgResult, rgFieldMask));
	}

	virtual HRESULT STDMETHODCALLTYPE SetColumns(	// Return code.
		TABLEID 	tableid,				// table to work on.
		void		*pRowPtr,				// row pointer
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		const ULONG cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// array of HRESULT for iCols.
		const ULONG	*rgFieldMask)			// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRecordCount(// Return code.
		TABLEID 	tableid,				// Which table to work on.
		ULONG		*piCount)				// Not including deletes.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetRecordCount(tableid, piCount));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRowByOid(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		OID 		_oid,					// Value for keyed lookup.
		ULONG		iColumn,				// 1 based column number (logical).
		void		**ppStruct) 			// Return pointer to record.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetRowByOid(tableid, _oid, iColumn, ppStruct));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRowByRID(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		rid,					// Record id.
		void		**ppStruct) 			// Return pointer to record.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetRowByRID(tableid, rid, ppStruct));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRIDForRow(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		const void	*pRecord,				// The record we want RID for.
		ULONG		*pirid) 				// Return the RID for the given row.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetRIDForRow(tableid, pRecord, pirid));
	}

	virtual HRESULT STDMETHODCALLTYPE GetRowByColumn( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pData, 				// User data.
		ULONG		cbData, 				// Size of data (blobs)
		DBTYPE		iType,					// What type of data given.
		void		*rgRecords[],			// Return array of records here.
		int 		iMaxRecords,			// Max that will fit in rgRecords.
		RECORDLIST	*pRecords,				// If variable rows desired.
		int 		*piFetched) 			// How many records were fetched.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetRowByColumn(tableid, iColumn, pData, cbData,
				iType, rgRecords, iMaxRecords, pRecords, piFetched));
	}

	virtual HRESULT STDMETHODCALLTYPE QueryByColumns( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
		TABLEID 	tableid,				// Which table to work with.
		const QUERYHINT *pQryHint,			// What index to use, NULL valid.
		int 		iColumns,				// How many columns to query on.
		const ULONG rgiColumn[],			// 1 based column numbers.
		const DBCOMPAREOP rgfCompare[], 	// Comparison operators, NULL means ==.
		const void	*rgpbData[],			// User data.
		const ULONG rgcbData[], 			// Size of data (blobs)
		const DBTYPE rgiType[], 			// What type of data given.
		void		*rgRecords[],			// Return array of records here.
		int 		iMaxRecords,			// Max that will fit in rgRecords.
		CRCURSOR	*psCursor,				// Buffer for the cursor handle.
		int 		*piFetched) 			// How many records were fetched.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->QueryByColumns(tableid, pQryHint, iColumns, rgiColumn,
				rgfCompare, rgpbData, rgcbData, rgiType, rgRecords,
				iMaxRecords, psCursor, piFetched));
	}

	virtual HRESULT STDMETHODCALLTYPE OpenCursorByColumn(// Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pData, 				// User data.
		ULONG		cbData, 				// Size of data (blobs)
		DBTYPE		iType,					// What type of data given.
		CRCURSOR	*psCursor)				// Buffer for the cursor handle.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->OpenCursorByColumn(tableid, iColumn, pData, cbData,
				iType, psCursor));
	}

	virtual HRESULT STDMETHODCALLTYPE ReadCursor(// Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		void		*rgRecords[],			// Return array of records here.
		int 		*piRecords) 			// Max that will fit in rgRecords.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->ReadCursor(psCursor, rgRecords, piRecords));
	}

	virtual HRESULT STDMETHODCALLTYPE MoveTo( // Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		ULONG		iIndex) 				// New index.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->MoveTo(psCursor, iIndex));
	}

	virtual HRESULT STDMETHODCALLTYPE GetCount( // Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		ULONG		*piCount)				// Return the count.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetCount(psCursor, piCount));
	}

	virtual HRESULT STDMETHODCALLTYPE CloseCursor(// Return code.
		CRCURSOR	*psCursor)				// The cursor handle.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->CloseCursor(psCursor));
	}

	virtual HRESULT STDMETHODCALLTYPE GetStringUtf8( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPCSTR		*pszOutBuffer)			// Where to put string pointer.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetStringUtf8(tableid, iColumn, pRecord, pszOutBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE GetStringA( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPSTR		szOutBuffer,			// Where to write string.
		int 		cchOutBuffer,			// Max size, including room for \0.
		int 		*pchString) 			// Size of string is put here.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetStringA(tableid, iColumn, pRecord,
				szOutBuffer, cchOutBuffer, pchString));
	}

	virtual HRESULT STDMETHODCALLTYPE GetStringW( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPWSTR		szOutBuffer,			// Where to write string.
		int 		cchOutBuffer,			// Max size, including room for \0.
		int 		*pchString) 			// Size of string is put here.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetStringW(tableid, iColumn, pRecord,
				szOutBuffer, cchOutBuffer, pchString));
	}

	virtual HRESULT STDMETHODCALLTYPE GetBstr( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		BSTR		*pBstr) 				// Output for bstring on success.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetBstr(tableid, iColumn, pRecord, pBstr));
	}

	virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		BYTE		*pOutBuffer,			// Where to write blob.
		ULONG		cbOutBuffer,			// Size of output buffer.
		ULONG		*pcbOutBuffer)			// Return amount of data available.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetBlob(tableid, iColumn, pRecord,
				pOutBuffer, cbOutBuffer, pcbOutBuffer));
	}

	virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
		TABLEID		tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		const BYTE	**ppBlob,				// Pointer to blob.
		ULONG		*pcbSize) 				// Size of blob.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetBlob(tableid, iColumn, pRecord, ppBlob, pcbSize));
	}

	virtual HRESULT STDMETHODCALLTYPE GetOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		OID 		*poid)					// Return id here.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetOid(tableid, iColumn, pRecord, poid));
	}

	virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		VARIANT 	*pValue)				// Put the variant here.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetVARIANT(tableid, iColumn, pRecord, pValue));
	}

	virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		const void	**ppBlob,				// Put Pointer to blob here.
		ULONG		*pcbSize)				// Put Size of blob here.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetVARIANT(tableid, iColumn, pRecord, ppBlob, pcbSize));
	}

	virtual HRESULT STDMETHODCALLTYPE GetVARIANTType( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		VARTYPE 	*pType) 				// Put VARTEPE here.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetVARIANTType(tableid, iColumn, pRecord, pType));
	}

	virtual HRESULT STDMETHODCALLTYPE GetGuid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		GUID		*pGuid) 				// Return guid here.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetGuid(tableid, iColumn, pRecord, pGuid));
	}

	virtual HRESULT STDMETHODCALLTYPE IsNull( // S_OK yes, S_FALSE no.
		TABLEID 	tableid,				// Which table to work with.
		const void	*pRecord,				// Record with data.
		ULONG		iColumn)				// 1 based column number (logical).
	{
		_ASSERTE(m_pICR);
		return (m_pICR->IsNull(tableid, pRecord, iColumn));
	}

	virtual HRESULT STDMETHODCALLTYPE PutStringUtf8( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCSTR		szString,				// String we are writing.
		int 		cbBuffer)				// Bytes in string, -1 null terminated.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE PutStringA( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCSTR		szString,				// String we are writing.
		int 		cbBuffer)				// Bytes in string, -1 null terminated.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE PutStringW( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCWSTR 	szString,				// String we are writing.
		int 		cbBuffer)				// Bytes (not characters) in string, -1 null terminated.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE PutBlob( // Return code.
		TABLEID		tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const BYTE	*pBuffer,				// User data.
		ULONG		cbBuffer) 				// Size of buffer.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE PutOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		OID 		oid)					// Return id here.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const VARIANT *pValue)				// The variant to write.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const void	*pBuffer,				// User data to write as a variant.
		ULONG		cbBuffer)				// Size of buffer.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		VARTYPE 	vt, 					// Type of data.
		const void	*pValue)				// The actual data.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE PutGuid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		REFGUID 	guid)					// Guid to put.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual void STDMETHODCALLTYPE SetNull(
		TABLEID 	tableid,				// Which table to work with.
		void		*pRecord,				// Record with data.
		ULONG		iColumn)				// 1 based column number (logical).
	{
		
	}

	virtual HRESULT STDMETHODCALLTYPE DeleteRowByRID(
		TABLEID 	tableid,				// Which table to work with.
		ULONG		rid)					// Record id.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE GetCPVARIANT( // Return code.
		USHORT		ixCP,					// 1 based Constant Pool index.
		VARIANT 	*pValue)				// Put the data here.
	{
		return (E_NOTIMPL);
	}

	virtual HRESULT STDMETHODCALLTYPE AddCPVARIANT( // Return code.
		VARIANT 	*pValue,				// The variant to write.
		ULONG		*pixCP) 				// Put 1 based Constant Pool index here.
	{
		return (E_NOTIMPL);
	}


//*****************************************************************************
//
//********** File and schema functions.
//
//*****************************************************************************


	virtual HRESULT STDMETHODCALLTYPE SchemaAdd( // Return code.
		const COMPLIBSCHEMABLOB *pSchema)	// The schema to add.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SchemaAdd(pSchema));
	}
	
	virtual HRESULT STDMETHODCALLTYPE SchemaDelete( // Return code.
		const COMPLIBSCHEMABLOB *pSchema)	// The schema to add.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE SchemaGetList( // Return code.
		int 		iMaxSchemas,			// How many can rgSchema handle.
		int 		*piTotal,				// Return how many we found.
		COMPLIBSCHEMADESC rgSchema[])		// Return list here.
	{
		CLock		sLock(GetLock());
		_ASSERTE(m_pICR);
		return (m_pICR->SchemaGetList(iMaxSchemas, piTotal, rgSchema));
	}

	virtual HRESULT STDMETHODCALLTYPE OpenTable( // Return code.
		const COMPLIBSCHEMA *pSchema,		// Schema identifier.
		ULONG		iTableNum,				// Table number to open.
		TABLEID 	*pTableID)				// Return ID on successful open.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->OpenTable(pSchema, iTableNum, pTableID));
	}

	virtual HRESULT STDMETHODCALLTYPE GetSaveSize(
		CorSaveSize fSave,					// cssQuick or cssAccurate.
		DWORD		*pdwSaveSize)			// Return size of saved item.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE SaveToStream(// Return code.
		IStream 	*pIStream)				// Where to save the data.
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE Save( 
		LPCWSTR szFile) 
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE GetDBSize( // Return code.
		ULONG		*pcbSize)				// Return size on success.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetDBSize(pcbSize));
	}

	virtual HRESULT STDMETHODCALLTYPE LightWeightOpen() 
	{
		return (E_NOTIMPL);
	}

	virtual HRESULT STDMETHODCALLTYPE LightWeightClose() 
	{
		return (E_NOTIMPL);
	}

	
	virtual HRESULT STDMETHODCALLTYPE NewOid( 
		OID *poid) 
	{
		return (PostError(CLDB_E_READONLY));
	}

	virtual HRESULT STDMETHODCALLTYPE GetObjectCount( 
		ULONG		*piCount) 
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetObjectCount(piCount));
	}
	
	virtual HRESULT STDMETHODCALLTYPE OpenSection(
		LPCWSTR 	szName, 				// Name of the stream.
		DWORD		dwFlags,				// Open flags.
		REFIID		riid,					// Interface to the stream.
		IUnknown	**ppUnk)				// Put the interface here.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->OpenSection(szName, dwFlags, riid, ppUnk));
	}

	virtual HRESULT STDMETHODCALLTYPE GetOpenFlags(
		DWORD		*pdwFlags) 
	{
		_ASSERTE(m_pICR);
		return (m_pICR->GetOpenFlags(pdwFlags));
	}

	virtual HRESULT STDMETHODCALLTYPE SetHandler(
		IUnknown	*pHandler)				// The handler.
	{
		_ASSERTE(m_pICR);
		return (m_pICR->SetHandler(pHandler));
	}

//
// IComponentRecordsSchema
//

	virtual HRESULT GetTableDefinition( 	// Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		ICRSCHEMA_TABLE *pTableDef) 		// Return table definition data.
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetTableDefinition(TableID, pTableDef));
	}

	virtual HRESULT GetColumnDefinitions(	// Return code.
		ICRCOLUMN_GET GetType,				// How to retrieve the columns.
		TABLEID 	TableID,				// Return ID on successful open.
		ICRSCHEMA_COLUMN rgColumns[],		// Return array of columns.
		int 		ColCount)				// Size of the rgColumns array, which
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetColumnDefinitions(GetType, TableID, rgColumns, ColCount));
	}

	virtual HRESULT GetIndexDefinition( 	// Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		LPCWSTR 	szIndex,				// Name of the index to retrieve.
		ICRSCHEMA_INDEX *pIndex)			// Return index description here.
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetIndexDefinition(TableID, szIndex, pIndex));
	}

	virtual HRESULT GetIndexDefinitionByNum( // Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		int 		IndexNum,				// Index to return.
		ICRSCHEMA_INDEX *pIndex)			// Return index description here.
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetIndexDefinitionByNum(TableID, IndexNum, pIndex));
	}

	virtual HRESULT  CreateTableEx(			// Return code.
		LPCWSTR		szTableName,			// Name of new table to create.
		int			iColumns,				// Columns to put in table.
		ICRSCHEMA_COLUMN	rColumnDefs[],	// Array of column definitions.
		USHORT		usFlags, 				// Create values for flags.
		USHORT		iRecordStart,			// Start point for records.
		TABLEID		tableid,				// Hard coded ID if there is one.
		BOOL		bMultiPK)				// The table has multi-column PK.
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->CreateTableEx(szTableName,iColumns,rColumnDefs,usFlags,iRecordStart,tableid,bMultiPK));
	}

	virtual HRESULT CreateIndexEx(			// Return code.
		LPCWSTR		szTableName,			// Name of table to put index on.
		ICRSCHEMA_INDEX	*pInIndexDef,		// Index description.
		const DBINDEXCOLUMNDESC rgInKeys[] )// Which columns make up key.
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->CreateIndexEx(szTableName,pInIndexDef, rgInKeys));
	}

	virtual HRESULT GetSchemaBlob(			//Return code.
		ULONG* cbSchemaSize,				//schema blob size
		BYTE** pSchema,						//schema blob
		ULONG* cbNameHeap,					//name heap size
		HGLOBAL*  phNameHeap)				//name heap blob
	{
		_ASSERTE(m_pICR);
		return (((IComponentRecordsSchema *) (StgDatabase *) m_pICR)->GetSchemaBlob(cbSchemaSize,pSchema,cbNameHeap,phNameHeap));
	}



	RTSemExclusive *GetLock()
	{ return (((StgDatabase *) m_pICR)->GetLock()); }

	RTSemExclusive *GetThisLock()
	{ return (&m_Lock); }

private:
	IComponentRecords *m_pICR;				// Delegate pointer.
	RTSemExclusive m_Lock;					// For locking at this level.
	ULONG		m_cRef; 					// Ref counting.
};  // StgTSICRReadOnly





//*****************************************************************************
// Allocate a delegate wrapper that does thread safety.  There is a read/write
// and a read/only version of the wrapper.  The read/only minimized locks
// based on the fact that methods cannot change data.
//*****************************************************************************
HRESULT GetThreadSafeICR(				// Return code.
	int			bReadOnly,				// true for read only.
	IComponentRecords *pICR,			// The parent object.
	REFIID		riid,					// The IID desired.
	PVOID		*ppIface)				// Return interface if known.
{
	IUnknown	*pUnk = 0;
	HRESULT 	hr=S_OK;

	// Avoid confusion.
	_ASSERTE(pICR);
	_ASSERTE(ppIface);
	*ppIface = 0;

	// Allocate a new delegate.
	if (bReadOnly)
	{
		StgTSICRReadOnly *p = new StgTSICRReadOnly(pICR);
		if (p)
			pUnk = (IUnknown *) (IComponentRecords *) p;
	}
	else
	{
		StgTSICRReadWrite *p = new StgTSICRReadWrite(pICR);
		if (p)
			pUnk = (IUnknown *) (IComponentRecords *) p;
	}

	// Check for out of memory error.
	if (!pUnk)
	{
		hr = OutOfMemory();
		goto ErrExit;
	}

	// Defer to the parent interface.
	hr = pUnk->QueryInterface(riid, ppIface);

ErrExit:
	// Release the local reference.
	if (pUnk)
		pUnk->Release();
	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\internaldebug.cpp ===
//*****************************************************************************
// InternalDebug.cpp
//
// This is internal code for debug mode which will turn on memory dump checking
// and other settings.  Call the api's according to:
//		_DbgInit		On startup to init the system.
//		_DbgRecord		Call this when you are sure you want dump checking.
//		_DbgUninit		Call at process shutdown to force the dump.
//
// The reason not to enable dumping under all circumstance is one might want
// to pre-empt the dump when you hit Ctrl+C or otherwise terminate the process.
// This is actually pretty common while unit testing code, and seeing a dump
// when you obviously did not free resources is annoying.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard header.
#include "utilcode.h"

#ifdef _DEBUG


//********** Forwards. ********************************************************
// These are here to avoid pulling in <crtdbg.h> for which we've defined a
// bunch of alternative functions.
typedef void *_HFILE; /* file handle pointer */
extern "C" 
{
_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );
_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );
_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );
_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );
_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );
}
#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)


//********** Globals. *********************************************************
int				g_bDumpMemoryLeaks = false; // Set to true to get a dump.


//********** Code. ************************************************************

void _DbgInit(HINSTANCE hInstance)
{
	// Set break alloc flags based on memory key if found.
	if (REGUTIL::GetLong(L"CheckMem", FALSE))
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_CHECK_ALWAYS_DF|_CRTDBG_LEAK_CHECK_DF);

	// Check to see if a break alloc has been set.  If you get memory leaks, you
	// can set this registry key in order to see the call stack for the allocation
	// number which caused the leak.
	DWORD dwBreakAlloc;
	if (dwBreakAlloc=REGUTIL::GetLong(L"BreakAlloc", 0))
		_CrtSetBreakAlloc(dwBreakAlloc);
}


void _DbgRecord()
{
	g_bDumpMemoryLeaks = true;
}


void _DbgUninit()
{
	WCHAR		rcDump[512];
	bool		bDump = false;

	if (WszGetEnvironmentVariable(L"DONT_DUMP_LEAKS", rcDump, NumItems(rcDump)))
		bDump = false;
	else if (WszGetEnvironmentVariable(L"DUMP_CRT_LEAKS", rcDump, NumItems(rcDump)) != 0)
	{
		bDump = (*rcDump == 'Y' || *rcDump == 'y' || *rcDump == '1');
	}

	//@todo: short term hack: don't show dumps from jvc.exe which leaks like
	// a sieve.  They aren't going to fix this for a while and it is slowing
	// down compiles for a bunch of people.
	{
	WCHAR rcFile[_MAX_PATH];
	WszGetModuleFileName(NULL, rcDump, NumItems(rcDump));
	SplitPath(rcDump, NULL, NULL, rcFile, NULL);
	if (_wcsicmp(rcFile, L"JVC") == 0)
		bDump = false;
	}

	if (g_bDumpMemoryLeaks && bDump)
	{
		_CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF);
		_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);
		_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
	}
}




#endif _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\debug.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// Debug.cpp
//
// Helper code for debugging.
//*****************************************************************************
#include "stdafx.h"
#include "utilcode.h"

#ifdef _DEBUG

// On windows, we need to set the MB_SERVICE_NOTIFICATION bit on message
//  boxes, but that bit isn't defined under windows CE.	 This bit of code
//  will provide '0' for the value, and if the value ever is defined, will
//  pick it up automatically.
#if defined(MB_SERVICE_NOTIFICATION)
 # define COMPLUS_MB_SERVICE_NOTIFICATION MB_SERVICE_NOTIFICATION
#else
 # define COMPLUS_MB_SERVICE_NOTIFICATION 0
#endif


//*****************************************************************************
// This struct tracks the asserts we want to ignore in the rest of this
// run of the application.
//*****************************************************************************
struct _DBGIGNOREDATA
{
    char        rcFile[_MAX_PATH];
    long        iLine;
    bool        bIgnore;
};

typedef CDynArray<_DBGIGNOREDATA> DBGIGNORE;
DBGIGNORE       grIgnore;



//*****************************************************************************
// This function is called in order to ultimately return an out of memory
// failed hresult.  But this guy will check what environment you are running
// in and give an assert for running in a debug build environment.  Usually
// out of memory on a dev machine is a bogus alloction, and this allows you
// to catch such errors.  But when run in a stress envrionment where you are
// trying to get out of memory, assert behavior stops the tests.
//*****************************************************************************
HRESULT _OutOfMemory(LPCSTR szFile, int iLine)
{
	DbgWriteEx(L"WARNING:  Out of memory condition being issued from: %hs, line %d\n",
			szFile, iLine);
    return (E_OUTOFMEMORY);
}


//*****************************************************************************
// This function will handle ignore codes and tell the user what is happening.
//*****************************************************************************
int _DbgBreakCheck(
    LPCSTR      szFile, 
    int         iLine, 
    LPCSTR      szExpr)
{
    TCHAR       rcBuff[1024];
    _DBGIGNOREDATA *psData;
    long        i;

    // Check for ignore all.
    for (i=0, psData = grIgnore.Ptr();  i<grIgnore.Count();  i++, psData++)
    {
        if (psData->iLine == iLine && _stricmp(psData->rcFile, szFile) == 0 && 
            psData->bIgnore == true)
            return (false);
    }

    // Give assert in output for easy access.
    swprintf(rcBuff, L"Assert failure: %hs, Line: %d\n", szFile, iLine);
    WszOutputDebugString(rcBuff);

    // Change format for message box.
    swprintf(rcBuff, L"%hs\n\n%hs, Line: %d\n\nAbort - Kill program\nRetry - Debug\nIgnore - Keep running\n",
        szExpr, szFile, iLine);

    // Tell user there was an error.
    switch (WszMessageBox(NULL, rcBuff, L"Assert Failure", 
            MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION | COMPLUS_MB_SERVICE_NOTIFICATION))
    {
        // For abort, just quit the app.
        case IDABORT:
          TerminateProcess(GetCurrentProcess(), 1);
//        WszFatalAppExit(0, L"Shutting down");
        break;

        // Tell caller to break at the correct loction.
        case IDRETRY:
        return (true);

        // If we want to ignore the assert, find out if this is forever.
        case IDIGNORE:
        swprintf(rcBuff, L"Ignore the assert for the rest of this run?\nYes - Assert will never fire again.\nNo - Assert will continue to fire.\n\n%hs\nLine: %d\n",
            szFile, iLine);
        if (WszMessageBox(NULL, rcBuff, L"Ignore Assert Forever?", MB_ICONQUESTION | MB_YESNO | COMPLUS_MB_SERVICE_NOTIFICATION) != IDYES)
            break;

        if ((psData = grIgnore.Append()) == 0)
            return (false);
        psData->bIgnore = true;
        psData->iLine = iLine;
        strcpy(psData->rcFile, szFile);
        break;
    }

    return (false);
}

// // //  
// // //  The following function
// // //  computes the binomial distribution, with which to compare 
// // //  hash-table statistics.  If a hash function perfectly randomizes
// // //  its input, one would expect to see F chains of length K, in a
// // //  table with N buckets and M elements, where F is
// // //
// // //    F(K,M,N) = N * (M choose K) * (1 - 1/N)^(M-K) * (1/N)^K.  
// // //
// // //  Don't call this with a K larger than 159.
// // //

#if !defined(NO_CRT) && ( defined(DEBUG) || defined(_DEBUG) )

#include <math.h>

#define MAX_BUCKETS_MATH 160

double Binomial (DWORD K, DWORD M, DWORD N)
{
    if (K >= MAX_BUCKETS_MATH)
        return -1 ;

    static double rgKFact [MAX_BUCKETS_MATH] ;
    DWORD i ;

    if (rgKFact[0] == 0)
    {
        rgKFact[0] = 1 ;
        for (i=1; i<MAX_BUCKETS_MATH; i++)
            rgKFact[i] = rgKFact[i-1] * i ;
    }

    double MchooseK = 1 ;

    for (i = 0; i < K; i++)
        MchooseK *= (M - i) ;

    MchooseK /= rgKFact[K] ;

    double OneOverNToTheK = pow (1./N, K) ;

    double QToTheMMinusK = pow (1.-1./N, M-K) ;

    double P = MchooseK * OneOverNToTheK * QToTheMMinusK ;

    return N * P ;
}

#endif // _DEBUG

#if _DEBUG
// Called from within the IfFail...() macros.  Set a breakpoint here to break on
// errors.
VOID DebBreak() {
  static int i = 0;  // add some code here so that we'll be able to set a BP
  i++;
}
#endif // _DEBUG


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\vmstructarray.cpp ===
//*****************************************************************************
// VMStructArray.cpp
//
// This code manages an array of fixed size structs built on top of virtual
// memory.  Features/requirements:
//	o  Fixed size records.
//	o  Records are contiguous (no gaps due to delete or insert).
//	o  Caller memory may be given as base for array (for example to base array
//		on memory mapped file with pre-built records).
//
// If this code handles memory allocation, then a fixed amount of memory is
// reserved up front and committed in pages as required.  If the entire array
// fills up, then a new piece of memory is allocated and all records are
// copied to this location.  This is very exspensive; try not to let it happen.
//
// The record array may be persisted to disk using IStream.  The data is
// stored on a 4 byte alignment if this option is used.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard include.
#include "VMStructArray.h"				// Array code.
#include "UtilCode.h"					// Helper code.
#include "Errors.h"						// For posting errors.


int	VMStructArray::m_iPageSize=0;		// Size of an OS page.


//*****************************************************************************
// Init this instance of the array.
//*****************************************************************************
VMStructArray::VMStructArray() :
	m_pMem(0),
	m_iCount(0),
	m_fFlags(0)
{ 
}


//*****************************************************************************
// Free any memory we have allocated.
//*****************************************************************************
VMStructArray::~VMStructArray()
{
	// Free the memory if we had any.
	if (m_pMem && (m_fFlags & VMSA_CALLEROWNED) == 0)
	{
		VERIFY(VirtualFree(m_pMem, m_iCommittedPages * m_iPageSize, MEM_DECOMMIT));
		VERIFY(VirtualFree(m_pMem, 0, MEM_RELEASE));
	}
}


//*****************************************************************************
// Call this init function to create a brand new array read to have new
// records.  The array will be set up to handle iMaxItems (memory permitted).
// If you exceed this maximum, and VMSA_NOMEMMOVE is specified, you will get
// an error.  If VMSA_NOMEMMOVE is not specified, then an attempt to allocate
// a new array at 1.5*iMaxItems is attempted.
//*****************************************************************************
HRESULT VMStructArray::InitNew(			// Return code.
	ULONG		iMaxItems,				// How many items max to manage.
	int			iElemSize,				// Size of an element.
	ULONG		iInitial,				// How many structs to allocate up front.
	ULONG		fFlags)					// VMSA_xxx flags.
{
	SYSTEM_INFO	sInfo;					// Some O/S information.
	ULONG		iMaxSize;				// How much memory to allocate.
	ULONG		iPages;					// How many pages to commit right away.

	// Sanity checks.
	_ASSERTE(m_pMem == 0);
	_ASSERTE(iElemSize > 0);
	_ASSERTE((fFlags & ~(VMSA_CALLEROWNED | VMSA_NOMEMMOVE)) == 0);
	_ASSERTE((fFlags & VMSA_CALLEROWNED) == 0);

	// Save off some data.
	m_iElemSize = iElemSize;
	m_fFlags = fFlags;

	// If the system page size has not been queried, do so now.
	if (m_iPageSize == 0)
	{
		// Query the system page size.
		GetSystemInfo(&sInfo);
		m_iPageSize = sInfo.dwPageSize;
	}

	// Figure out how much memory to allocate.  Max items will be a multiple
	// of the page size and may not exactly match caller's value.
	iMaxSize = iMaxItems * iElemSize;
	iMaxSize = (((iMaxSize - 1) & ~(m_iPageSize - 1)) + m_iPageSize);
	_ASSERTE(iMaxSize % m_iPageSize == 0 && iMaxSize != 0);

	// See how many structs user wants right away.
	if (iInitial == 0)
		iPages = 1;
	else
	{
		iPages = (iInitial * m_iElemSize) / m_iPageSize;
		if ((iInitial * m_iElemSize) % m_iPageSize)
			iPages++;
	}

	// Allocate space for the cached records.
	if ((m_pMem = VirtualAlloc(0, iMaxSize,
									MEM_RESERVE, PAGE_NOACCESS)) == 0 ||
		VirtualAlloc(m_pMem, m_iPageSize * iPages, MEM_COMMIT, PAGE_READWRITE) == 0)
		return (PostError(OutOfMemory()));
	
	// Success, set rest of state data.
	m_iReservedPages = iMaxSize / m_iPageSize;
	m_iCommittedPages = iPages;
	m_iMaxItems = (m_iPageSize * m_iCommittedPages) / m_iElemSize;
	m_iCount = iInitial;
	return (S_OK);
}


//*****************************************************************************
// This function initializes the Virtual Memory array on top of a piece of caller owned
// memory.  Whether or not that memory can be further suballocated is
// determined by the bReadOnly flag.  If the memory can be suballocated,
// then all memory must be committed and writable up front.
//*****************************************************************************
HRESULT VMStructArray::InitOnMem(		// Return code.
	void		*pMem,					// Caller memory with structs.
	ULONG		cbMem,					// Total size of pMem.
	ULONG		iCount,					// How many elements to manage.
	int			iElemSize,				// Size of an element.
	int			bReadOnly)				// true if memory is read only.
{
	// Sanity checks.
	_ASSERTE(m_pMem == 0);

	// Simply save everything off and return.
	m_pMem = pMem;
	m_iCount = iCount;
	m_iElemSize = iElemSize;
	m_iMaxItems = cbMem / iElemSize;
	m_fFlags = VMSA_CALLEROWNED | VMSA_NOMEMMOVE;
	if (bReadOnly)
		m_fFlags |= VMSA_READONLY;
	return (S_OK);
}


//*****************************************************************************
// New item is inserted at the 0 based index location.
//*****************************************************************************
void *VMStructArray::Insert(
	ULONG		iIndex)
{
	// Cannot modify read only caller memory.
	_ASSERTE((m_fFlags & VMSA_READONLY) == 0);

	// We can not insert an element further than the end of the array.
	if (iIndex > m_iCount)
		return (0);
	
	// The array should grow, if we can't fit one more element into the array.
	if (Grow(1) == false)
		return (0);

	// The pointer to be returned.
	char *pcList = ((char *) m_pMem) + (iIndex * m_iElemSize);

	// See if we need to slide anything down.
	if (iIndex < m_iCount)
		memmove(pcList + m_iElemSize, pcList, (m_iCount - iIndex) * m_iElemSize);
	++m_iCount;
	return (pcList);
}


//*****************************************************************************
// Allocate a new element at the end of the dynamic array and return a pointer
// to it.
//*****************************************************************************
void *VMStructArray::Append()
{
	// Cannot modify read only caller memory.
	_ASSERTE((m_fFlags & VMSA_READONLY) == 0);

	// The array should grow, if we can't fit one more element into the array.
	if (Grow(1) == false)
		return (0);

	return (((char *) m_pMem) + m_iCount++ * m_iElemSize);
}


//*****************************************************************************
// Deletes the specified element from the array.
//*****************************************************************************
void VMStructArray::Delete(
	ULONG		iIndex)
{
	// Cannot modify read only caller memory.
	_ASSERTE((m_fFlags & VMSA_READONLY) == 0);

	// See if we need to slide anything down.
	if (iIndex < --m_iCount)
	{
		char *pcList = ((char *) m_pMem) + iIndex * m_iElemSize;
		memmove(pcList, pcList + m_iElemSize, (m_iCount - iIndex) * m_iElemSize);
	}
}


//*****************************************************************************
// Grow the array if it is not possible to fit iCount number of new elements.
//*****************************************************************************
int VMStructArray::Grow(				// true or false
	ULONG		iCount)					// How many required elements.
{
	// If there isn't enough room for the new items, make room.
	if (m_iMaxItems < m_iCount+iCount)
	{
		// Caller owned memory can never be resized, so you're dead right now.
		if (m_fFlags & VMSA_CALLEROWNED)
			return (false);

		// If there are more pages we can commit, do so.
		if (m_iCommittedPages < m_iReservedPages)
		{
			// Try to commit the next page.
			if (VirtualAlloc(
					(void *) ((UINT_PTR) m_pMem + (m_iCommittedPages * m_iPageSize)), 
					m_iPageSize, MEM_COMMIT, PAGE_READWRITE) == 0)
				return (false);
			
			// Count the new page and change max items.
			++m_iCommittedPages;
			m_iMaxItems += m_iPageSize / m_iElemSize;
		}
		// We are out of room.
		else
		{
			DWORD		iMaxSize;
			void		*pMem;

			// If we are not allowed to move memory, then this is fatal.
			if (m_fFlags & VMSA_NOMEMMOVE)
				return (false);

			// Figure out how much memory to allocate.
			iMaxSize = (m_iReservedPages + (m_iReservedPages / 2)) * m_iPageSize;

			// Allocate the new memory range, and commit enough pages for old
			// data and one more.
			if ((pMem = VirtualAlloc(0, iMaxSize, MEM_RESERVE, PAGE_NOACCESS)) == 0 ||
				VirtualAlloc(pMem, m_iPageSize * (m_iCommittedPages + 1), 
					MEM_COMMIT, PAGE_READWRITE) == 0)
				return (false);
			
			// Copy the data to a new location.
			memcpy(pMem, m_pMem, m_iCount * m_iElemSize);

			// Free old data.
			VERIFY(VirtualFree(m_pMem, m_iCommittedPages * m_iPageSize, MEM_DECOMMIT));
			VERIFY(VirtualFree(m_pMem, 0, MEM_RELEASE));

			// Reset all state data.
			m_pMem = pMem;
			m_iReservedPages = iMaxSize / m_iPageSize;
			++m_iCommittedPages;
			m_iMaxItems += m_iPageSize / m_iElemSize;
		}
	}
	return (true);
}


//*****************************************************************************
// Free the memory for this item.
//*****************************************************************************
void VMStructArray::Clear()
{
	// Decommit all but one page.
	if ((m_fFlags & VMSA_CALLEROWNED) == 0 && m_pMem != 0)
	{
		if (m_iCommittedPages > 1)
			VERIFY(VirtualFree((void *) ((UINT_PTR) m_pMem + m_iPageSize), 
				(m_iCommittedPages - 1) * m_iPageSize, MEM_DECOMMIT));

		// Reset state data to one page.
		m_iCommittedPages = 1;
		m_iMaxItems = m_iPageSize / m_iElemSize;
	}
	// Avoid confusion, there is no memory for us to managed any longer.
	else
		m_pMem = 0;

	// Clear count of items.
	m_iCount = 0;
}


//*****************************************************************************
// Returns the maximum number of elements that could be stored in this array if
// all memory were committed.  There is no guarantee that one can actually
// read this maximum, for example a commit request for a page could fail even
// if enough address space were reserved.
//*****************************************************************************
ULONG VMStructArray::GetCapacity()		// Total elements possible.
{
	if (m_fFlags & VMSA_CALLEROWNED)
		return (m_iMaxItems);
	else
		return ((m_iReservedPages * m_iPageSize) / m_iElemSize);
}


//*****************************************************************************
// Determine the index of the given item.  If it is not in the heap, return
// -1.  If it is in the range for the heap, but is not on an element boundary,
// then return -2.
//*****************************************************************************
int VMStructArray::ValidItemIndex(		// Return index, -1 not in heap, -2 unalgined.
	void		*p)						// Poiner to check.
{ 
	ULONG		RecordOffset;

	if ((BYTE *) p >= (BYTE *) Ptr() && 
		(BYTE *) p < (BYTE *) Ptr() + m_iMaxItems * m_iElemSize)
	{
		_ASSERTE(((BYTE *) p - (BYTE *) Ptr()) < ULONG_MAX);
		RecordOffset = (ULONG)((BYTE *) p - (BYTE *) Ptr());
		if (RecordOffset % m_iElemSize == 0)
			return (RecordOffset / m_iElemSize); 
		else
		{
			// While not strictly an error, this probably means you've used
			// a pointer to something that was not intended.
			_ASSERTE(!"Unaligned element access.");
			return (-2);
		}
	}
	return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgusersection.cpp ===
//*****************************************************************************
// StgUserSection.cpp
//
// Applications may need to store their own sections in the PE file. This
// allows them to do so.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************

#include "stdafx.h"						// Standard include.
#include "StgPool.h"					// Our interface definitions.
#include "CompLib.h"					// Extended VT types.
#include "Errors.h"						// Error handling.
#include "StgDatabase.h"				// Database definitions.
#include "StgTiggerStorage.h"			// Storage implementation.



//*****************************************************************************
// Allow the user to create a stream that is independent of the database.
//*****************************************************************************
HRESULT StgDatabase::OpenSection(
	LPCWSTR		szName,					// Name of the stream.
	DWORD		dwFlags,				// Open flags.
	REFIID		riid,					// Interface to the stream.
	IUnknown	**ppUnk)				// Put the interface here.
{
	HRESULT		hr=S_OK;				// A result.

	// Do we know the interface?
#if 0 // left to show an example implemenation of the user section
	if (riid == IID_ICallDescrSection)
		hr = OpenCallDescrSection(szName, dwFlags, ppUnk);
	else
#endif
		hr = E_NOINTERFACE;

	return hr;
}

#if 0 // left to show an example implementation of the user section

//*****************************************************************************
// Open a specific section type:  code bytes.
//*****************************************************************************
HRESULT StgDatabase::OpenCallDescrSection(
	LPCWSTR		szName,					// Name of the stream.
	DWORD		dwFlags,				// Open flags.
	IUnknown	**ppUnk)				// Put the interface here.
{
#if !defined(COMPLUS98)
	HRESULT		hr;						// A result.
	void		*pbData;				// Pointer for loaded stream.
	ULONG		cbData;					// Size of stream.
	StgDescrSection *pSect;				// New section.
	IUserSection *pIS;					// For mapping user sections.
	IUserSection **ppIS;				// For mapping...

	// Avoid confusion.
	*ppUnk = 0;

	//@todo: map dwFlags with database open mode.

	// Has the section already been opened?
	ppIS = m_UserSectionMap.GetItem(szName);
	if (ppIS)
	{	// Yes, return it to caller.
		hr = (*ppIS)->QueryInterface(IID_ICallDescrSection, reinterpret_cast<void**>(ppUnk));
		return hr;
	}

	// Assume that the call will succeed, and pre-allocate the manager.
	pSect = new StgDescrSection;
	if (pSect == 0)
	{
		hr = E_OUTOFMEMORY;
		goto ErrExit;
	}

	// If the stream doesn't exist, create a new one
	if (m_pStorage == 0 || 
		(hr=m_pStorage->OpenStream(szName, &cbData, &pbData)) == STG_E_FILENOTFOUND)
	{
		hr = pSect->InitNew();
	}
	else // We tried to open it.  Did we?
	if (FAILED(hr))
		goto ErrExit;
	else
	{	// Successfully opened stream.  Init manager on it.
		hr = pSect->InitOnMem(pbData, cbData, dwFlags);
	}
	if (FAILED(hr))
		goto ErrExit;

	// Give back to user.
	*ppUnk = static_cast<ICallDescrSection*>(pSect);
	pSect->AddRef(); // no QI, so manually AR.

	// Track this, for save time.
	pIS = static_cast<IUserSection*>(pSect);
	m_UserSectionMap.AddItem(szName, pIS);
	pSect->AddRef();

	// Done with local pointer.
	pSect = 0;

ErrExit:
	// Clean up.
	if (FAILED(hr) && pSect)
		delete pSect;
	return hr;
#else
	return E_NOTIMPL;
#endif
}

#if !defined(COMPLUS98)
//*****************************************************************************
//*****************************************************************************
StgDescrSection::StgDescrSection()
 :	m_cRef(0)
{
	memset(m_rGroups, 0, sizeof(m_rGroups));
}

//*****************************************************************************
//*****************************************************************************
StgDescrSection::~StgDescrSection()
{
}

//*****************************************************************************
//*****************************************************************************
HRESULT StgDescrSection::QueryInterface(
	REFIID		riid, 
	PVOID		*pp)
{
	HRESULT		hr = S_OK;				// Return code.

	*pp = 0;

	if (riid == IID_IUserSection)
		*pp = static_cast<IUserSection*>(this);
	else
	if (riid == IID_ICallDescrSection)
		*pp = static_cast<ICallDescrSection*>(this);
	else
	if (riid == IID_IUnknown)
		*pp = static_cast<IUnknown*>(static_cast<ICallDescrSection*>(this));
	else
		return (E_NOINTERFACE);

	AddRef();
	return hr;		
}

//*****************************************************************************
// Helper function to convert a group-relative index into an absolute index.
//*****************************************************************************
HRESULT StgDescrSection::AdjustDescrIndex(
    ULONG       ixDescr,
    ULONG       ulGroup,
    ULONG       *pIx)
{
	ULONG		i;						// Loop control.

	// Valid group?
	_ASSERTE(ulGroup <= DESCR_GROUP_METHODIMPL);

	// Adjust offset within group to offset within array.
	for (i=0; i<ulGroup; ++i)
		ixDescr += m_rGroups[i];

    *pIx = ixDescr;

    return (S_OK);
}

//*****************************************************************************
// Insert one or more empty DESCRs into a group.
//*****************************************************************************
HRESULT StgDescrSection::InsertCallDescr(
	ULONG		ixDescr,				// Index of Descr.
	ULONG		ulGroup,				// Which group is Descr in?
	ULONG		cDescr,					// Count of descrs to insert.
	COR_CALLDESCR   **ppDescr)			// Put pointer to first one here.
{
    HRESULT     hr;                     // A result.
    ULONG       ix;                     // Adjusted index.
    ULONG       i;                      // Loop control.

	if (FAILED(hr = AdjustDescrIndex(ixDescr, ulGroup, &ix)))
		return (hr);

    //@todo: implement Insert(ix, count)
    for (i=0; i<cDescr; ++i)
    {
        if (!m_rDescrs.Insert(ix))
            return (OutOfMemory());
    }
    m_rGroups[ulGroup] += cDescr;

    *ppDescr = m_rDescrs.Get(ix);

    return (S_OK);
}

//*****************************************************************************
// Append one or more new DESCRs to the end of a group.
//*****************************************************************************
HRESULT StgDescrSection::AppendCallDescr(
    ULONG		ulGroup,				// Which group is Descr in?
	ULONG		*pulDescr,				// Put relative index of first one here.
	_COR_CALLDESCR  **ppDescr)			// Put pointer to first one here.
{
    HRESULT     hr;                     // A result.
    ULONG       ix;                     // Adjusted index.

	// Get index of start of the group.
	if (FAILED(hr = AdjustDescrIndex(0, ulGroup, &ix)))
		return (hr);
	// Slide to end of the group.
	ix += m_rGroups[ulGroup];

	// Insert the Descr; return a pointer to it.
    if (!(*ppDescr = m_rDescrs.Insert(ix)))
        return (OutOfMemory());

	// Count this entry; return its index within group.
	*pulDescr = m_rGroups[ulGroup];
    m_rGroups[ulGroup] += 1;

    return (S_OK);
}

//*****************************************************************************
// Retrieve a pointer to a given DESCR within a group.
//*****************************************************************************
HRESULT StgDescrSection::GetCallDescr(
	ULONG		ixDescr,				// Index of Descr.
	ULONG		ulGroup,				// Which group is Descr in?
	COR_CALLDESCR   **ppDescr)			// Put pointer here.
{
    HRESULT     hr;                     // A result.
    ULONG       ix;                     // Adjusted index.

    if (FAILED(hr = AdjustDescrIndex(ixDescr, ulGroup, &ix)))
        return (hr);

    *ppDescr = m_rDescrs.Get(ix);

    return (S_OK);
}

//*****************************************************************************
// Return the count of groups, and the sizes of the groups.
//*****************************************************************************
HRESULT StgDescrSection::GetCallDescrGroups(
	ULONG		*pcGroups,				// How many groups?
	ULONG		**pprGroups)    		// Count in each group.
{
    *pcGroups = DESCR_GROUP_METHODIMPL+1;
    *pprGroups = m_rGroups;

    return (S_OK);
}

//*****************************************************************************
// Add a CallSig to the call sig pool.  Return the offset of the sig itself.
//*****************************************************************************
HRESULT StgDescrSection::AddCallSig(
	const void	*pVal,					// The value to store.
	ULONG		iLen,					// Count of bytes to store.
	ULONG		*piOffset)				// The offset of the new item.
{
	HRESULT		hr;						// Return code.
	ULONG		iOffset;				// Internal offset.

	hr = m_pool.AddBlob(iLen, pVal, &iOffset);
	// Convert offset to external form.
	if (SUCCEEDED(hr))
		*piOffset = iOffset+1;

	return hr;
}

//*****************************************************************************
// Given the offset of a sig, return it, and its length.
//*****************************************************************************
HRESULT StgDescrSection::GetCallSig(
	ULONG		iOffset,				// Offset of the item to get.
	const void	**ppVal,				// Put pointer to Code here.
	ULONG		*piLen)					// Put length of code here.
{
	ULONG		iLen;					// Dummy for length.

	// If caller doesn't want length, point to own buffer.
	if (piLen == 0)
		piLen = &iLen;

	// Convert offset to internal form.
	--iOffset;
	*ppVal = m_pool.GetBlob(iOffset, piLen);

	return (S_OK);
}

//*****************************************************************************
// Get the buffer of all call sigs.  Then, given a sig offset, it is possible
//  to directly access a sig.
//*****************************************************************************
HRESULT StgDescrSection::GetCallSigBuf(
	const void	**ppVal)				// Put pointer to Code here.
{

	*ppVal = m_pool.GetBuffer();

	return (S_OK);
}

//*****************************************************************************
// Init a new, empty, DESCR manager.
//*****************************************************************************
HRESULT StgDescrSection::InitNew()
{
	HRESULT		hr;						// Return code.

	hr = m_pool.InitNew();

	return hr;
}

//*****************************************************************************
// Init a DESCR manager from memory previously persisted.
//*****************************************************************************
HRESULT StgDescrSection::InitOnMem(
	void		*pvData,				// Pointer to the data.
	ULONG		cbBytes,				// Length of the data.
	DWORD		dwFlags)				// Open flags.
{
	HRESULT		hr;						// Return code.
    int         i;                      // Loop control.
    ULONG       ulCount;                // Count of groups or descrs.
    BYTE        *pbData = reinterpret_cast<BYTE*>(pvData);

	// Get Descr section counts.
	memcpy(m_rGroups, pbData, (DESCR_GROUP_METHODIMPL+1)*sizeof(ULONG));
    pbData += (DESCR_GROUP_METHODIMPL+1) * sizeof(ULONG);

	// Get Descrs.
    ulCount = 0;
    for (i=0; i<=DESCR_GROUP_METHODIMPL; ++i)
        ulCount += m_rGroups[i];
    m_rDescrs.InitOnMem(sizeof(COR_CALLDESCR), pbData, ulCount, ulCount, 16);
    pbData += ulCount * sizeof(COR_CALLDESCR);

	// Get CallSigs.
    cbBytes -= pbData - reinterpret_cast<BYTE*>(pvData);
	hr = m_pool.InitOnMem(pbData, cbBytes, false/*@todo: read-only?*/);

	return hr;
}

//*****************************************************************************
// Write our data to a stream.
//*****************************************************************************
HRESULT StgDescrSection::PersistToStream(
	IStream		*pIStream)				// Stream to which to save.
{
	HRESULT		hr;						// Return code.
	  
	// Put Descr section counts.
    if (FAILED(hr = pIStream->Write(m_rGroups, (DESCR_GROUP_METHODIMPL+1) * sizeof(ULONG), 0)))
        return (hr);

    // Put Descrs.
#if _DEBUG
    int         i;                      // Loop control.
    ULONG       ulCount;                // Count of Groups.
    ulCount = 0;
    for (i=0; i<=DESCR_GROUP_METHODIMPL; ++i)
        ulCount += m_rGroups[i];
	_ASSERTE(ulCount == (ULONG)m_rDescrs.Count());
#endif
    if (FAILED(hr = pIStream->Write(m_rDescrs.Ptr(), m_rDescrs.Count() * sizeof(COR_CALLDESCR), 0)))
        return (hr);

	// Put CallSigs.
	hr = m_pool.PersistToStream(pIStream);

	return hr;
}

//*****************************************************************************
// Compute the space required to store current DESCRs and Sigs.
//*****************************************************************************
HRESULT StgDescrSection::GetSaveSize(
	ULONG		*pcbSize)				// Put the size here.
{
    HRESULT     hr;                     // A result.
    ULONG       cbSize;                 // Size of saved data.

	// Size of signatures.
	hr = m_pool.GetSaveSize(&cbSize);

    // Size of Groups.
    cbSize += (DESCR_GROUP_METHODIMPL+1) * sizeof(ULONG);

    // Size of Descrs.
    cbSize += m_rDescrs.Count() * sizeof(COR_CALLDESCR);

    *pcbSize = cbSize;

	return hr;
}

//*****************************************************************************
// Has anything been stored in this DESCR manager?
//*****************************************************************************
HRESULT StgDescrSection::IsEmpty(
	ULONG		*pbEmpty)				// Put TRUE or FALSE here.
{
	*pbEmpty = m_pool.IsEmpty() && m_rDescrs.Count() == 0;

	return (S_OK);
}
#endif
#endif
// - E O F - ==================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgusersection.h ===
//*****************************************************************************
// StgUserSection.h
//
// Applications may need to store their own sections in the PE file. This
// allows them to do so.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgUserSection_h__
#define __StgUserSection_h__

#if !defined(COMPLUS98)
 #include "StgPool.h"
 #include <cor.h>
 #include <utilcode.h>
#endif

extern const GUID __declspec(selectany) IID_IUserSection = 
{ 0x2b137008, 0xf02d, 0x11d1, { 0x8c, 0xe3, 0x0, 0xa0, 0xc9, 0xb0, 0xa0, 0x63 } };

interface IUserSection : public IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE InitNew() = 0;

	virtual HRESULT STDMETHODCALLTYPE InitOnMem(
		void		*pBytes,				// Pointer to the data.
		ULONG		cbBytes,				// Length of the data.
		DWORD		dwFlags) = 0;			// Open flags.

	virtual HRESULT STDMETHODCALLTYPE PersistToStream(
		IStream		*pIStream) = 0;			// Stream to which to save.

	virtual HRESULT STDMETHODCALLTYPE GetSaveSize(
		ULONG		*pcbSize) = 0;			// Put the size here.

	virtual HRESULT STDMETHODCALLTYPE IsEmpty(
		ULONG		*pbEmpty) = 0;			// Put TRUE or FALSE here.

};

#if 0 // left to show example of user section implementation
class StgDescrSection : public ICallDescrSection, public IUserSection
{  
public:
	StgDescrSection();
	~StgDescrSection();
	
// IUnknown:
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *pp);

	virtual ULONG STDMETHODCALLTYPE AddRef()
	{ return (InterlockedIncrement((long *) &m_cRef)); }

	virtual ULONG STDMETHODCALLTYPE Release()
	{
		ULONG	cRef;
		if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
			delete this;
		return (cRef);
	}

// ICallDescrSection	
    virtual HRESULT STDMETHODCALLTYPE InsertCallDescr(
		ULONG		ixDescr,				// Index of Descr.
		ULONG		ulGroup,				// Which group is Descr in?
		ULONG		cDescr,					// Count of descrs to insert.
		COR_CALLDESCR   **ppDescr);			// Put pointer to first one here.

    virtual HRESULT STDMETHODCALLTYPE AppendCallDescr(
    	ULONG		ulGroup,				// Which group is Descr in?
		ULONG		*pulDescr,				// Put relative index of first one here.
		COR_CALLDESCR  **ppDescr);			// Put pointer to first one here.

    virtual HRESULT STDMETHODCALLTYPE GetCallDescr(
		ULONG		ixDescr,				// Index of Descr.
		ULONG		ulGroup,				// Which group is Descr in?
		COR_CALLDESCR   **ppDescr);				// Put pointer here.

    virtual HRESULT STDMETHODCALLTYPE GetCallDescrGroups(
		ULONG		*pcGroups,				// How many groups?
    	ULONG		**pprcGroup);   		// Count in each group.

	virtual HRESULT STDMETHODCALLTYPE AddCallSig(
		const void	*pVal,					// The value to store.
		ULONG		iLen,					// Count of bytes to store.
		ULONG		*piOffset);				// The offset of the new item.

	virtual HRESULT STDMETHODCALLTYPE GetCallSig(
		ULONG		iOffset,				// Offset of the item to get.
		const void	**ppVal,				// Put pointer to signature here.
        ULONG		*piLen);				// Put length of signature here.

    virtual HRESULT STDMETHODCALLTYPE GetCallSigBuf(
        const void  **ppVal);	           // Put pointer to Signatures here.

// IUserSection
	virtual HRESULT STDMETHODCALLTYPE InitNew();

	virtual HRESULT STDMETHODCALLTYPE InitOnMem(
		void		*pBytes,				// Pointer to the data.
		ULONG		cbBytes,				// Length of the data.
		DWORD		dwFlags);				// Open flags.

	virtual HRESULT STDMETHODCALLTYPE PersistToStream(
		IStream		*pIStream);				// Stream to which to save.

	virtual HRESULT STDMETHODCALLTYPE GetSaveSize(
		ULONG		*pcbSize);				// Put the size here.

	virtual HRESULT STDMETHODCALLTYPE IsEmpty(
		ULONG		*pbEmpty);				// Put TRUE or FALSE here.

private:
    HRESULT AdjustDescrIndex(
        ULONG       ixDescr,
        ULONG       ulGroup,
        ULONG       *pIx);

	DWORD		m_cRef;					// Reference counter.
	StgBlobPool m_pool;					// Pool of code segments.
	CDynArray<COR_CALLDESCR>    m_rDescrs;	// Pool of DESCRs.
	ULONG       m_rGroups[DESCR_GROUP_METHODIMPL+1];	// Count of DESCRs in a given group.
};
#endif

#endif // __StgUserSection_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\vmstructarray.h ===
//*****************************************************************************
// VMStructArray.h
//
// This code manages an array of fixed size structs built on top of virtual
// memory.  Features/requirements:
//	o  Fixed size records.
//	o  Records are contiguous (no gaps due to delete or insert).
//	o  Caller memory may be given as base for array (for example to base array
//		on memory mapped file with pre-built records).
//
// If this code handles memory allocation, then a fixed amount of memory is
// reserved up front and committed in pages as required.  If the entire array
// fills up, then a new piece of memory is allocated and all records are
// copied to this location.  This is very exspensive; try not to let it happen.
//
// The record array may be persisted to disk using IStream.  The data is
// stored on a 4 byte alignment if this option is used.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __VMStructArray_h__
#define __VMStructArray_h__

class VMStructArray
{
public:
	VMStructArray();

	~VMStructArray();

//*****************************************************************************
// Call this init function to create a brand new array read to have new
// records.  The array will be set up to handle iMaxItems (memory permitted).
// If you exceed this maximum, and VMSA_NOMEMMOVE is specified, you will get
// an error.  If VMSA_NOMEMMOVE is not specified, then an attempt to allocate
// a new array at 1.5*iMaxItems is attempted.
//*****************************************************************************
	HRESULT InitNew(						// Return code.
		ULONG		iMaxItems,				// How many items max to manage.
		int			iElemSize,				// Size of an element.
		ULONG		iInitial=0,				// How many structs to allocate up front.
		ULONG		fFlags=0);				// VMSA_xxx flags.

//*****************************************************************************
// This function initializes the Virtual Memory array on top of a piece of caller owned
// memory.  Whether or not that memory can be further suballocated is
// determined by the bReadOnly flag.  If the memory can be suballocated,
// then all memory must be committed and writable up front.
//*****************************************************************************
	HRESULT InitOnMem(						// Return code.
		void		*pMem,					// Caller memory with structs.
		ULONG		cbMem,					// Total size of pMem.
		ULONG		iCount,					// How many elements to manage.
		int			iElemSize,				// Size of an element.
		int			bReadOnly=true);		// true if memory is read only.

//*****************************************************************************
// New item is inserted at the 0 based index location.
//*****************************************************************************
	void *Insert(ULONG iIndex);

//*****************************************************************************
// Add new item to the end of the array.
//*****************************************************************************
	void *Append();

//*****************************************************************************
// Delete the item at the given 0 based index.  Any entries that come after
// this index are moved back to keep the array contiguous.
//*****************************************************************************
	void Delete(ULONG iIndex);

//*****************************************************************************
// Clear all elements of the array.  This means that memory is actually freed
// and the count is cleared.
//*****************************************************************************
	void Clear();

//*****************************************************************************
// Returns the maximum number of elements that could be stored in this array if
// all memory were committed.  There is no guarantee that one can actually
// read this maximum, for example a commit request for a page could fail even
// if enough address space were reserved.
//*****************************************************************************
	ULONG GetCapacity();					// Total elements possible.

//*****************************************************************************
// The remaining inlines are useful for a variety of reasons and are self
// explanatory.
//*****************************************************************************

	void *Ptr()
	{ return (m_pMem); }

	void *Get(ULONG iIndex)
	{ return ((void *) ((UINT_PTR) Ptr() + (iIndex * m_iElemSize))); }

	ULONG Count()
	{ return (m_iCount); }

	int ItemIndex(void *p)
	{ return (int)(((UINT_PTR) p - (UINT_PTR) Ptr()) / m_iElemSize); }
    	

	// Return index, -1 not in heap, -2 unalgined.
	int ValidItemIndex(void *p);

	int ElemSize()
	{ return (m_iElemSize); }

private:
	int Grow(								// true or false
		ULONG		iCount);				// How many required elements.


public:
	enum
	{
		VMSA_CALLEROWNED		= 0x0001,	// Caller owns the memory.
		VMSA_NOMEMMOVE			= 0x0002,	// Overflow is an error.
		VMSA_READONLY			= 0x0004	// Data is read only.
	};

private:
	void		*m_pMem;					// Memory we manage.
	int			m_iReservedPages;			// How many pages reserved space.
	int			m_iCommittedPages;			// How many pages are available for use.
	ULONG		m_iCount;					// How many items are there.
	ULONG		m_iMaxItems;				// How many could we have.
	int			m_iElemSize;				// Size of one element.
	ULONG		m_fFlags;					// VMSA_xxx flags.
	static int	m_iPageSize;				// Size of an OS page.
};

#endif // __VMStructArray_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\regutil.cpp ===
//*****************************************************************************
// regutil.h
//
// This module contains a set of functions that can be used to access the
// regsitry.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************


#include "stdafx.h"
#include "utilcode.h"

//#ifndef UNDER_CE

static LPCTSTR	gszKey = L"Software\\Microsoft\\COM+ EE";



//*****************************************************************************
// Open's the given key and returns the value desired.  If the key or value is
// not found, then the default is returned.
//*****************************************************************************
long REGUTIL::GetLong(					// Return value from registry or default.
	LPCTSTR		szName,					// Name of value to get.
	long		iDefault,				// Default value to return if not found.
	LPCTSTR		szKey,					// Name of key, NULL==default.
	HKEY		hKeyVal)				// What key to work on.
{
	long		iValue;					// The value to read.
	DWORD		iType;					// Type of value to get.
	DWORD		iSize;					// Size of buffer.
	HKEY		hKey;					// Key for the registry entry.

	// Open the key if it is there.
	if (ERROR_SUCCESS != W95RegOpenKey(hKeyVal, (szKey) ? szKey : gszKey, &hKey))
		return (iDefault);

	// Read the key value if found.
	iType = REG_DWORD;
	iSize = sizeof(long);
	if (ERROR_SUCCESS != W95RegQueryValueEx(hKey, szName, NULL, 
			&iType, (LPBYTE)&iValue, &iSize) || iType != REG_DWORD)
		iValue = iDefault;

	// We're done with the key now.
	RegCloseKey(hKey);
	return (iValue);
}


//*****************************************************************************
// Open's the given key and returns the value desired.  If the key or value is
// not found, then the default is returned.
//*****************************************************************************
long REGUTIL::SetLong(					// Return value from registry or default.
	LPCTSTR		szName,					// Name of value to get.
	long		iValue,					// Value to set.
	LPCTSTR		szKey,					// Name of key, NULL==default.
	HKEY		hKeyVal)				// What key to work on.
{
	long		lRtn;					// Return code.
	HKEY		hKey;					// Key for the registry entry.

	// Open the key if it is there.
	if (ERROR_SUCCESS != W95RegOpenKey(hKeyVal, (szKey) ? szKey : gszKey, &hKey))
		return (-1);

	// Read the key value if found.
	lRtn = RegSetValueEx(hKey, szName, NULL, REG_DWORD, (const BYTE *) &iValue, sizeof(DWORD));

	// We're done with the key now.
	RegCloseKey(hKey);
	return (lRtn);
}


//*****************************************************************************
// Open's the given key and returns the value desired.  If the value is not
// in the key, or the key does not exist, then the default is copied to the
// output buffer.
//*****************************************************************************
LPCTSTR REGUTIL::GetString(				// Pointer to user's buffer.
	LPCTSTR		szName,					// Name of value to get.
	LPCTSTR		szDefault,				// Default value if not found.
	LPTSTR		szBuff,					// User's buffer to write to.
	ULONG		iMaxBuff,				// Size of user's buffer.
	LPCTSTR		szKey,					// Name of key, NULL=default.
	int			*pbFound,				// Found key in registry?
	HKEY		hKeyVal)				// What key to work on.
{
	HKEY		hKey;					// Key for the registry entry.
	DWORD		iType;					// Type of value to get.
	DWORD		iSize;					// Size of buffer.

	// Open the key if it is there.
	if (ERROR_SUCCESS != W95RegOpenKey(hKeyVal, (szKey) ? szKey : gszKey, &hKey))
	{
		StrNCpy(szBuff, szDefault, (int)min(Wszlstrlen(szDefault), iMaxBuff-1));
		if (pbFound != NULL) *pbFound = FALSE;
		return (szBuff); 
	}

	// Init the found flag.
	if (pbFound != NULL) *pbFound = TRUE;

	// Read the key value if found.
	iType = REG_SZ;
	iSize = iMaxBuff;
	if (ERROR_SUCCESS != W95RegQueryValueEx(hKey, szName, NULL, &iType, 
					(LPBYTE)szBuff, &iSize) ||
		(iType != REG_SZ && iType != REG_EXPAND_SZ))
	{
		if (pbFound != NULL) *pbFound = FALSE;
		StrNCpy(szBuff, szDefault, (int)min(Wszlstrlen(szDefault), iMaxBuff-1));
	}

	// We're done with the key now.
	RegCloseKey(hKey);
	return (szBuff);
}

//*****************************************************************************
// Does standard registration of a CoClass with a progid.
//*****************************************************************************
HRESULT REGUTIL::RegisterCOMClass(		// Return code.
	REFCLSID	rclsid,					// Class ID.
	LPCTSTR		szDesc,					// Description of the class.
	LPCTSTR		szProgIDPrefix,			// Prefix for progid.
	int			iVersion,				// Version # for progid.
	LPCTSTR		szClassProgID,			// Class progid.
	LPCTSTR		szThreadingModel,		// What threading model to use.
	LPCTSTR		szModule)				// Path to class.
{
	TCHAR		rcCLSID[256];			// CLSID\\szID.
	TCHAR		rcInproc[_MAX_PATH+64];	// CLSID\\InprocServer32
	TCHAR		rcProgID[256];			// szProgIDPrefix.szClassProgID
	TCHAR		rcIndProgID[256];		// rcProgID.iVersion
	HRESULT		hr;

	// Format the prog ID values.
	VERIFY(swprintf(rcIndProgID, L"%s.%s", szProgIDPrefix, szClassProgID));
	VERIFY(swprintf(rcProgID, L"%s.%d", rcIndProgID, iVersion));

	// Do the initial portion.
	if (FAILED(hr = RegisterClassBase(rclsid, szDesc, rcProgID, rcIndProgID, rcCLSID)))
		return (hr);

	// Set the server path.
    SetKeyAndValue(rcCLSID, L"InprocServer32", szModule);

	// Add the threading model information.
	VERIFY(swprintf(rcInproc, L"%s\\%s", rcCLSID, L"InprocServer32"));
	SetRegValue(rcInproc, L"ThreadingModel", szThreadingModel);
	return (S_OK);
}


//*****************************************************************************
// Register the basics for a in proc server.
//*****************************************************************************
HRESULT REGUTIL::RegisterClassBase(		// Return code.
	REFCLSID	rclsid,					// Class ID we are registering.
	LPCTSTR		szDesc,					// Class description.
	LPCTSTR		szProgID,				// Class prog ID.
	LPCTSTR		szIndepProgID,			// Class version independant prog ID.
	LPTSTR		szOutCLSID)				// CLSID formatted in character form.
{
	TCHAR		szID[64];				// The class ID to register.

    // Create some base key strings.
#ifdef _UNICODE
    StringFromGUID2(rclsid, szID, NumItems(szID));
#else
	OLECHAR		szWID[64];				// The class ID to register.

    StringFromGUID2(rclsid, szWID, NumItems(szWID));
	WideCharToMultiByte(CP_ACP, 0, szWID, -1, szID, sizeof(szID), NULL, NULL);
#endif
    _tcscpy(szOutCLSID, L"CLSID\\");
    _tcscat(szOutCLSID, szID);

    // Create ProgID keys.
    SetKeyAndValue(szProgID, NULL, szDesc);
    SetKeyAndValue(szProgID, L"CLSID", szID);

    // Create VersionIndependentProgID keys.
    SetKeyAndValue(szIndepProgID, NULL, szDesc);
    SetKeyAndValue(szIndepProgID, L"CurVer", szProgID);
    SetKeyAndValue(szIndepProgID, L"CLSID", szID);

    // Create entries under CLSID.
    SetKeyAndValue(szOutCLSID, NULL, szDesc);
    SetKeyAndValue(szOutCLSID, L"ProgID", szProgID);
    SetKeyAndValue(szOutCLSID, L"VersionIndependentProgID", szIndepProgID);
    SetKeyAndValue(szOutCLSID, L"NotInsertable", NULL);
	return (S_OK);
}



//*****************************************************************************
// Unregister the basic information in the system registry for a given object
// class.
//*****************************************************************************
HRESULT REGUTIL::UnregisterCOMClass(	// Return code.
	REFCLSID	rclsid,					// Class ID we are registering.
	LPCTSTR		szProgIDPrefix,			// Prefix for progid.
	int			iVersion,				// Version # for progid.
	LPCTSTR		szClassProgID)			// Class progid.
{
	TCHAR		rcCLSID[64];			// CLSID\\szID.
	TCHAR		rcProgID[128];			// szProgIDPrefix.szClassProgID
	TCHAR		rcIndProgID[128];		// rcProgID.iVersion

	// Format the prog ID values.
	VERIFY(swprintf(rcProgID, L"%s.%s", szProgIDPrefix, szClassProgID));
	VERIFY(swprintf(rcIndProgID, L"%s.%d", rcProgID, iVersion));

	UnregisterClassBase(rclsid, rcProgID, rcIndProgID, rcCLSID);
	DeleteKey(rcCLSID, L"InprocServer32");
	return (S_OK);
}


//*****************************************************************************
// Delete the basic settings for an inproc server.
//*****************************************************************************
HRESULT REGUTIL::UnregisterClassBase(	// Return code.
	REFCLSID	rclsid,					// Class ID we are registering.
	LPCTSTR		szProgID,				// Class prog ID.
	LPCTSTR		szIndepProgID,			// Class version independant prog ID.
	LPTSTR		szOutCLSID)				// Return formatted class ID here.
{
	TCHAR		szID[64];				// The class ID to register.

	// Create some base key strings.
#ifdef _UNICODE
    StringFromGUID2(rclsid, szID, NumItems(szID));
#else
	OLECHAR		szWID[64];				// The class ID to register.

    StringFromGUID2(rclsid, szWID, NumItems(szWID));
	WideCharToMultiByte(CP_ACP, 0, szWID, -1, szID, sizeof(szID), NULL, NULL);
#endif
	_tcscpy(szOutCLSID, L"CLSID\\");
	_tcscat(szOutCLSID, szID);

	// Delete the version independant prog ID settings.
	DeleteKey(szIndepProgID, L"CurVer");
	DeleteKey(szIndepProgID, L"CLSID");
	W95RegDeleteKey(HKEY_CLASSES_ROOT, szIndepProgID);

	// Delete the prog ID settings.
	DeleteKey(szProgID, L"CLSID");
	W95RegDeleteKey(HKEY_CLASSES_ROOT, szProgID);

	// Delete the class ID settings.
	DeleteKey(szOutCLSID, L"ProgID");
	DeleteKey(szOutCLSID, L"VersionIndependentProgID");
	DeleteKey(szOutCLSID, L"NotInsertable");
	W95RegDeleteKey(HKEY_CLASSES_ROOT, szOutCLSID);
	return (S_OK);
}


//*****************************************************************************
// Register a type library.
//*****************************************************************************
HRESULT REGUTIL::RegisterTypeLib(		// Return code.
	REFGUID		rtlbid,					// TypeLib ID we are registering.
	int			iVersion,				// Typelib version.
	LPCTSTR		szDesc,					// TypeLib description.
	LPCTSTR		szModule)				// Path to the typelib.
{
	TCHAR		szID[64];				// The typelib ID to register.
	TCHAR		szTLBID[256];			// TypeLib\\szID.
	TCHAR		szHelpDir[_MAX_PATH];
	TCHAR		szDrive[_MAX_DRIVE];
	TCHAR		szDir[_MAX_DIR];
	TCHAR		szVersion[64];
	LPTSTR		szTmp;

	// Create some base key strings.
#ifdef _UNICODE
    StringFromGUID2(rtlbid, szID, NumItems(szID));
#else
	OLECHAR		szWID[64];				// The class ID to register.

    StringFromGUID2(rtlbid, szWID, NumItems(szWID));
	WideCharToMultiByte(CP_ACP, 0, szWID, -1, szID, sizeof(szID), NULL, NULL);
#endif
	_tcscpy(szTLBID, L"TypeLib\\");
	_tcscat(szTLBID, szID);

	VERIFY(swprintf(szVersion, L"%d.0", iVersion));

    // Create Typelib keys.
    SetKeyAndValue(szTLBID, NULL, NULL);
    SetKeyAndValue(szTLBID, szVersion, szDesc);
	_tcscat(szTLBID, L"\\");
	_tcscat(szTLBID, szVersion);
    SetKeyAndValue(szTLBID, L"0", NULL);
    SetKeyAndValue(szTLBID, L"0\\win32", szModule);
    SetKeyAndValue(szTLBID, L"FLAGS", L"0");
	SplitPath(szModule, szDrive, szDir, NULL, NULL);
	_tcscpy(szHelpDir, szDrive);
	if ((szTmp = CharPrev(szDir, szDir + Wszlstrlen(szDir))) != NULL)
		*szTmp = '\0';
	_tcscat(szHelpDir, szDir);
    SetKeyAndValue(szTLBID, L"HELPDIR", szHelpDir);
	return (S_OK);
}


//*****************************************************************************
// Remove the registry keys for a type library.
//*****************************************************************************
HRESULT REGUTIL::UnregisterTypeLib(		// Return code.
	REFGUID		rtlbid,					// TypeLib ID we are registering.
	int			iVersion)				// Typelib version.
{
	TCHAR		szID[64];				// The typelib ID to register.
	TCHAR		szTLBID[256];			// TypeLib\\szID.
	TCHAR		szTLBVersion[256];		// TypeLib\\szID\\szVersion
	TCHAR		szVersion[64];

	// Create some base key strings.
#ifdef _UNICODE
    StringFromGUID2(rtlbid, szID, NumItems(szID));
#else
	OLECHAR		szWID[64];				// The class ID to register.

    StringFromGUID2(rtlbid, szWID, NumItems(szWID));
	WideCharToMultiByte(CP_ACP, 0, szWID, -1, szID, sizeof(szID), NULL, NULL);
#endif
	VERIFY(swprintf(szVersion, L"%d.0", iVersion));
	_tcscpy(szTLBID, L"TypeLib\\");
	_tcscat(szTLBID, szID);
	_tcscpy(szTLBVersion, szTLBID);
	_tcscat(szTLBVersion, L"\\");
	_tcscat(szTLBVersion, szVersion);

    // Delete Typelib keys.
    DeleteKey(szTLBVersion, L"HELPDIR");
    DeleteKey(szTLBVersion, L"FLAGS");
    DeleteKey(szTLBVersion, L"0\\win32");
    DeleteKey(szTLBVersion, L"0");
    DeleteKey(szTLBID, szVersion);
    W95RegDeleteKey(HKEY_CLASSES_ROOT, szTLBID);
	return (0);
}


//*****************************************************************************
// Set an entry in the registry of the form:
// HKEY_CLASSES_ROOT\szKey\szSubkey = szValue.  If szSubkey or szValue are
// NULL, omit them from the above expression.
//*****************************************************************************
BOOL REGUTIL::SetKeyAndValue(			// TRUE or FALSE.
	LPCTSTR		szKey,					// Name of the reg key to set.
	LPCTSTR		szSubkey,				// Optional subkey of szKey.
	LPCTSTR		szValue)				// Optional value for szKey\szSubkey.
{
	HKEY		hKey;					// Handle to the new reg key.
	TCHAR		rcKey[128];				// Buffer for the full key name.

	// Init the key with the base key name.
	_tcscpy(rcKey, szKey);

	// Append the subkey name (if there is one).
	if (szSubkey != NULL)
	{
		_tcscat(rcKey, L"\\");
		_tcscat(rcKey, szSubkey);
	}

	// Create the registration key.
	if (W95RegCreateKeyEx(HKEY_CLASSES_ROOT, rcKey, 0, NULL,
						REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
						&hKey, NULL) != ERROR_SUCCESS)
		return(FALSE);

	// Set the value (if there is one).
	if (szValue != NULL)
		W95RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *) szValue,
						((int)Wszlstrlen(szValue)+1) * sizeof(TCHAR));

	RegCloseKey(hKey);
	return(TRUE);
}


//*****************************************************************************
// Delete an entry in the registry of the form:
// HKEY_CLASSES_ROOT\szKey\szSubkey.
//*****************************************************************************
BOOL REGUTIL::DeleteKey(				// TRUE or FALSE.
	LPCTSTR		szKey,					// Name of the reg key to set.
	LPCTSTR		szSubkey)				// Subkey of szKey.
{
	TCHAR		rcKey[128];				// Buffer for the full key name.

	// Init the key with the base key name.
	_tcscpy(rcKey, szKey);

	// Append the subkey name (if there is one).
	if (szSubkey != NULL)
	{
		_tcscat(rcKey, L"\\");
		_tcscat(rcKey, szSubkey);
	}

	// Delete the registration key.
	W95RegDeleteKey(HKEY_CLASSES_ROOT, rcKey);
	return(TRUE);
}


//*****************************************************************************
// Open the key, create a new keyword and value pair under it.
//*****************************************************************************
BOOL REGUTIL::SetRegValue(				// Return status.
	LPCTSTR		szKeyName,				// Name of full key.
	LPCTSTR		szKeyword,				// Name of keyword.
	LPCTSTR		szValue)				// Value of keyword.
{
	HKEY		hKey;					// Handle to the new reg key.

	// Create the registration key.
	if (W95RegCreateKeyEx(HKEY_CLASSES_ROOT, szKeyName, 0, NULL,
						REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
						&hKey, NULL) != ERROR_SUCCESS)
		return (FALSE);

	// Set the value (if there is one).
	if (szValue != NULL)
		W95RegSetValueEx(hKey, szKeyword, 0, REG_SZ, (BYTE *)szValue, ((int)Wszlstrlen(szValue)+1) * sizeof(TCHAR));

	RegCloseKey(hKey);
	return (TRUE);
}

//#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\makepath.cpp ===
/***
*makepath.c - create path name from components
*
*  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       To provide support for creation of full path names from components
*
*******************************************************************************/
#include "stdafx.h"
#include "WinWrap.h"



/***
*void _makepath() - build path name from components
*
*Purpose:
*       create a path name from its individual components
*
*Entry:
*       WCHAR *path  - pointer to buffer for constructed path
*       WCHAR *drive - pointer to drive component, may or may not contain
*                     trailing ':'
*       WCHAR *dir   - pointer to subdirectory component, may or may not include
*                     leading and/or trailing '/' or '\' characters
*       WCHAR *fname - pointer to file base name component
*       WCHAR *ext   - pointer to extension component, may or may not contain
*                     a leading '.'.
*
*Exit:
*       path - pointer to constructed path name
*
*Exceptions:
*
*******************************************************************************/

void MakePath (
        register WCHAR *path,
        const WCHAR *drive,
        const WCHAR *dir,
        const WCHAR *fname,
        const WCHAR *ext
        )
{
        register const WCHAR *p;

        /* we assume that the arguments are in the following form (although we
         * do not diagnose invalid arguments or illegal filenames (such as
         * names longer than 8.3 or with illegal characters in them)
         *
         *  drive:
         *      A           ; or
         *      A:
         *  dir:
         *      \top\next\last\     ; or
         *      /top/next/last/     ; or
         *      either of the above forms with either/both the leading
         *      and trailing / or \ removed.  Mixed use of '/' and '\' is
         *      also tolerated
         *  fname:
         *      any valid file name
         *  ext:
         *      any valid extension (none if empty or null )
         */

        /* copy drive */

        if (drive && *drive) {
                *path++ = *drive;
                *path++ = _T(':');
        }

        /* copy dir */

        if ((p = dir) && *p) {
                do {
                        *path++ = *p++;
                }
                while (*p);
#ifdef _MBCS
                if (*(p=_mbsdec(dir,p)) != _T('/') && *p != _T('\\')) {
#else  /* _MBCS */
                if (*(p-1) != _T('/') && *(p-1) != _T('\\')) {
#endif  /* _MBCS */
                        *path++ = _T('\\');
                }
        }

        /* copy fname */

        if (p = fname) {
                while (*p) {
                        *path++ = *p++;
                }
        }

        /* copy ext, including 0-terminator - check to see if a '.' needs
         * to be inserted.
         */

        if (p = ext) {
                if (*p && *p != _T('.')) {
                        *path++ = _T('.');
                }
                while (*path++ = *p++)
                        ;
        }
        else {
                /* better add the 0-terminator */
                *path = _T('\0');
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\stdafx.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <CrtWrap.h>
#include <WinWrap.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\utf.h ===
/*++

//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.

Module Name:

    utf.h

Abstract:

    This file contains the header information for the UTF module of NLS.

Revision History:

    02-06-96    JulieB    Created.

--*/



//
//  Constant Declarations.
//

#define ASCII             0x007f

#define SHIFT_IN          '+'     // beginning of a shift sequence
#define SHIFT_OUT         '-'     // end       of a shift sequence

#define UTF8_2_MAX        0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2     0xc0    // 110x xxxx
#define UTF8_1ST_OF_3     0xe0    // 1110 xxxx
#define UTF8_TRAIL        0x80    // 10xx xxxx

#define HIGER_6_BIT(u)    ((u) >> 12)
#define MIDDLE_6_BIT(u)   (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)    ((u) & 0x003f)

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)




/////////////////////////
//                     //
//  Unicode -> UTF-7   //
//                     //
/////////////////////////

//
//  Convert one Unicode to 2 2/3 Base64 chars in a shifted sequence.
//  Each char represents a 6-bit portion of the 16-bit Unicode char.
//
CONST char cBase64[] =

  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  // A : 000000 .... 011001  ( 0 - 25)
  "abcdefghijklmnopqrstuvwxyz"  // a : 011010 .... 110011  (26 - 51)
  "0123456789"                  // 0 : 110100 .... 111101  (52 - 61)
  "+/";                         // + : 111110, / : 111111  (62 - 63)

//
//  To determine if an ASCII char needs to be shifted.
//    1 :     to be shifted
//    0 : not to be shifted
//
CONST BOOLEAN fShiftChar[] =
{
  0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1,    // Null, Tab, LF, CR
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,    // Space '() +,-./
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,    // 0123456789:    ?
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  ABCDEFGHIJKLMNO
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,    // PQRSTUVWXYZ
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  abcdefghijklmno
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1     // pqrstuvwxyz
};




/////////////////////////
//                     //
//  UTF-7 -> Unicode   //
//                     //
/////////////////////////

//
//  Convert a Base64 char in a shifted sequence to a 6-bit portion of a
//  Unicode char.
//  -1 means it is not a Base64
//
CONST char nBitBase64[] =
{
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,   //            +   /
  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,   // 0123456789
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,   //  ABCDEFGHIJKLMNO
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,   // PQRSTUVWXYZ
  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,   //  abcdefghijklmno
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1    // pqrstuvwxyz
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\splitpat.cpp ===
/***
*splitpath.c - break down path name into components
*
*  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       To provide support for accessing the individual components of an
*       arbitrary path name
*
*******************************************************************************/
#include "stdafx.h"
#include "WinWrap.h"


/***
*_splitpath() - split a path name into its individual components
*
*Purpose:
*       to split a path name into its individual components
*
*Entry:
*       path  - pointer to path name to be parsed
*       drive - pointer to buffer for drive component, if any
*       dir   - pointer to buffer for subdirectory component, if any
*       fname - pointer to buffer for file base name component, if any
*       ext   - pointer to buffer for file name extension component, if any
*
*Exit:
*       drive - pointer to drive string.  Includes ':' if a drive was given.
*       dir   - pointer to subdirectory string.  Includes leading and trailing
*           '/' or '\', if any.
*       fname - pointer to file base name
*       ext   - pointer to file extension, if any.  Includes leading '.'.
*
*Exceptions:
*
*******************************************************************************/

void SplitPath (
        register const WCHAR *path,
        WCHAR *drive,
        WCHAR *dir,
        WCHAR *fname,
        WCHAR *ext
        )
{
        register WCHAR *p;
        WCHAR *last_slash = NULL, *dot = NULL;
        unsigned len;

        /* we assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *  <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *  0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *  ':'
         *  dir:
         *  0 to _MAX_DIR-1 characters in the form of an absolute path
         *  (leading '/' or '\') or relative path, the last of which, if
         *  any, must be a '/' or '\'.  E.g -
         *  absolute path:
         *      \top\next\last\     ; or
         *      /top/next/last/
         *  relative path:
         *      top\next\last\  ; or
         *      top/next/last/
         *  Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *  0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *  0 to _MAX_EXT-1 characters where, if any, the first must be a
         *  '.'
         *
         */

        /* extract drive letter and :, if any */

        if ((_tcslen(path) >= (_MAX_DRIVE - 2)) && (*(path + _MAX_DRIVE - 2) == _T(':'))) {
            if (drive) {
                _tcsncpy(drive, path, _MAX_DRIVE - 1);
                *(drive + _MAX_DRIVE-1) = _T('\0');
            }
            path += _MAX_DRIVE - 1;
        }
        else if (drive) {
            *drive = _T('\0');
        }

        /* extract path string, if any.  Path now points to the first character
         * of the path, if any, or the filename or extension, if no path was
         * specified.  Scan ahead for the last occurence, if any, of a '/' or
         * '\' path separator character.  If none is found, there is no path.
         * We will also note the last '.' character found, if any, to aid in
         * handling the extension.
         */

        for (last_slash = NULL, p = (WCHAR *)path; *p; p++) {
#ifdef _MBCS
            if (_ISLEADBYTE (*p))
                p++;
            else {
#endif  /* _MBCS */
            if (*p == _T('/') || *p == _T('\\'))
                /* point to one beyond for later copy */
                last_slash = p + 1;
            else if (*p == _T('.'))
                dot = p;
#ifdef _MBCS
            }
#endif  /* _MBCS */
        }

        if (last_slash) {

            /* found a path - copy up through last_slash or max. characters
             * allowed, whichever is smaller
             */

            if (dir) {
                len = (unsigned)__min(((char *)last_slash - (char *)path) / sizeof(WCHAR),
                    (_MAX_DIR - 1));
                _tcsncpy(dir, path, len);
                *(dir + len) = _T('\0');
            }
            path = last_slash;
        }
        else if (dir) {

            /* no path found */

            *dir = _T('\0');
        }

        /* extract file name and extension, if any.  Path now points to the
         * first character of the file name, if any, or the extension if no
         * file name was given.  Dot points to the '.' beginning the extension,
         * if any.
         */

        if (dot && (dot >= path)) {
            /* found the marker for an extension - copy the file name up to
             * the '.'.
             */
            if (fname) {
                len = (unsigned)__min(((char *)dot - (char *)path) / sizeof(WCHAR),
                    (_MAX_FNAME - 1));
                _tcsncpy(fname, path, len);
                *(fname + len) = _T('\0');
            }
            /* now we can get the extension - remember that p still points
             * to the terminating nul character of path.
             */
            if (ext) {
                len = (unsigned)__min(((char *)p - (char *)dot) / sizeof(WCHAR),
                    (_MAX_EXT - 1));
                _tcsncpy(ext, dot, len);
                *(ext + len) = _T('\0');
            }
        }
        else {
            /* found no extension, give empty extension and copy rest of
             * string into fname.
             */
            if (fname) {
                len = (unsigned)__min(((char *)p - (char *)path) / sizeof(WCHAR),
                    (_MAX_FNAME - 1));
                _tcsncpy(fname, path, len);
                *(fname + len) = _T('\0');
            }
            if (ext) {
                *ext = _T('\0');
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\util.cpp ===
//*****************************************************************************
//  util.cpp
//
//  This contains a bunch of C++ utility classes.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Precompiled header key.
#include "utilcode.h"

#include <rotate.h>


//********** Code. ************************************************************



//
//
// CHashTable
//
//

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
HRESULT CHashTable::NewInit(            // Return status.
    BYTE        *pcEntries,             // Array of structs we are managing.
    USHORT      iEntrySize)             // Size of the entries.
{
    _ASSERTE(iEntrySize >= sizeof(FREEHASHENTRY));

    // Allocate the bucket chain array and init it.
    if ((m_piBuckets = new USHORT [m_iBuckets]) == NULL)
        return (OutOfMemory());
    memset(m_piBuckets, 0xff, m_iBuckets * sizeof(USHORT));

    // Save the array of structs we are managing.
    m_pcEntries = pcEntries;
    m_iEntrySize = iEntrySize;
    return (S_OK);
}

//*****************************************************************************
// Add the struct at the specified index in m_pcEntries to the hash chains.
//*****************************************************************************
BYTE *CHashTable::Add(                  // New entry.
    USHORT      iHash,                  // Hash value of entry to add.
    USHORT      iIndex)                 // Index of struct in m_pcEntries.
{
    HASHENTRY   *psEntry;               // The struct we are adding.

    // Get a pointer to the entry we are adding.
    psEntry = EntryPtr(iIndex);

    // Compute the hash value for the entry.
    iHash %= m_iBuckets;

    _ASSERTE(m_piBuckets[iHash] != iIndex &&
        (m_piBuckets[iHash] == 0xffff || EntryPtr(m_piBuckets[iHash])->iPrev != iIndex));

    // Setup this entry.
    psEntry->iPrev = 0xffff;
    psEntry->iNext = m_piBuckets[iHash];

    // Link it into the hash chain.
    if (m_piBuckets[iHash] != 0xffff)
        EntryPtr(m_piBuckets[iHash])->iPrev = iIndex;
    m_piBuckets[iHash] = iIndex;
    return ((BYTE *) psEntry);
}

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
void CHashTable::Delete(
    USHORT      iHash,                  // Hash value of entry to delete.
    USHORT      iIndex)                 // Index of struct in m_pcEntries.
{
    HASHENTRY   *psEntry;               // Struct to delete.
    
    // Get a pointer to the entry we are deleting.
    psEntry = EntryPtr(iIndex);
    Delete(iHash, psEntry);
}

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
void CHashTable::Delete(
    USHORT      iHash,                  // Hash value of entry to delete.
    HASHENTRY   *psEntry)               // The struct to delete.
{
    // Compute the hash value for the entry.
    iHash %= m_iBuckets;

    _ASSERTE(psEntry->iPrev != psEntry->iNext || psEntry->iPrev == 0xffff);

    // Fix the predecessor.
    if (psEntry->iPrev == 0xffff)
        m_piBuckets[iHash] = psEntry->iNext;
    else
        EntryPtr(psEntry->iPrev)->iNext = psEntry->iNext;

    // Fix the successor.
    if (psEntry->iNext != 0xffff)
        EntryPtr(psEntry->iNext)->iPrev = psEntry->iPrev;
}

//*****************************************************************************
// The item at the specified index has been moved, update the previous and
// next item.
//*****************************************************************************
void CHashTable::Move(
    USHORT      iHash,                  // Hash value for the item.
    USHORT      iNew)                   // New location.
{
    HASHENTRY   *psEntry;               // The struct we are deleting.

    psEntry = EntryPtr(iNew);
    _ASSERTE(psEntry->iPrev != iNew && psEntry->iNext != iNew);

    if (psEntry->iPrev != 0xffff)
        EntryPtr(psEntry->iPrev)->iNext = iNew;
    else
        m_piBuckets[iHash % m_iBuckets] = iNew;
    if (psEntry->iNext != 0xffff)
        EntryPtr(psEntry->iNext)->iPrev = iNew;
}

//*****************************************************************************
// Search the hash table for an entry with the specified key value.
//*****************************************************************************
BYTE *CHashTable::Find(                 // Index of struct in m_pcEntries.
    USHORT      iHash,                  // Hash value of the item.
    BYTE        *pcKey)                 // The key to match.
{
    USHORT      iNext;                  // Used to traverse the chains.
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    // Start at the top of the chain.
    iNext = m_piBuckets[iHash % m_iBuckets];

    // Search until we hit the end.
    while (iNext != 0xffff)
    {
        // Compare the keys.
        psEntry = EntryPtr(iNext);
        if (!Cmp(pcKey, psEntry))
            return ((BYTE *) psEntry);

        // Advance to the next item in the chain.
        iNext = psEntry->iNext;
    }

    // We couldn't find it.
    return (0);
}

//*****************************************************************************
// Search the hash table for the next entry with the specified key value.
//*****************************************************************************
USHORT CHashTable::FindNext(            // Index of struct in m_pcEntries.
    BYTE        *pcKey,                 // The key to match.
    USHORT      iIndex)                 // Index of previous match.
{
    USHORT      iNext;                  // Used to traverse the chains.
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    // Start at the next entry in the chain.
    iNext = EntryPtr(iIndex)->iNext;

    // Search until we hit the end.
    while (iNext != 0xffff)
    {
        // Compare the keys.
        psEntry = EntryPtr(iNext);
        if (!Cmp(pcKey, psEntry))
            return (iNext);

        // Advance to the next item in the chain.
        iNext = psEntry->iNext;
    }

    // We couldn't find it.
    return (0xffff);
}

//*****************************************************************************
// Returns the next entry in the list.
//*****************************************************************************
BYTE *CHashTable::FindNextEntry(        // The next entry, or0 for end of list.
    HASHFIND    *psSrch)                // Search object.
{
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    for (;;)
    {
        // See if we already have one to use and if so, use it.
        if (psSrch->iNext != 0xffff)
        {
            psEntry = EntryPtr(psSrch->iNext);
            psSrch->iNext = psEntry->iNext;
            return ((BYTE *) psEntry);
        }

        // Advance to the next bucket.
        if (psSrch->iBucket < m_iBuckets)
            psSrch->iNext = m_piBuckets[psSrch->iBucket++];
        else
            break;
    }

    // There were no more entries to be found.
    return (0);
}


//
//
// CClosedHashBase
//
//

//*****************************************************************************
// Delete the given value.  This will simply mark the entry as deleted (in
// order to keep the collision chain intact).  There is an optimization that
// consecutive deleted entries leading up to a free entry are themselves freed
// to reduce collisions later on.
//*****************************************************************************
void CClosedHashBase::Delete(
    void        *pData)                 // Key value to delete.
{
    BYTE        *ptr;

    // Find the item to delete.
    if ((ptr = Find(pData)) == 0)
    {
        // You deleted something that wasn't there, why?
        _ASSERTE(0);
        return;
    }

    // One less active entry.
    --m_iCount;

    // For a perfect system, there are no collisions so it is free.
    if (m_bPerfect)
    {
        SetStatus(ptr, FREE);
        return;
    }

    // Mark this entry deleted.
    SetStatus(ptr, DELETED);

    // If the next item is free, then we can go backwards freeing
    // deleted entries which are no longer part of a chain.  This isn't
    // 100% great, but it will reduce collisions.
    BYTE        *pnext;
    if ((pnext = ptr + m_iEntrySize) > EntryPtr(m_iSize - 1))
        pnext = &m_rgData[0];
    if (Status(pnext) != FREE)
        return;
    
    // We can now free consecutive entries starting with the one
    // we just deleted, up to the first non-deleted one.
    while (Status(ptr) == DELETED)
    {
        // Free this entry.
        SetStatus(ptr, FREE);

        // Check the one before it, handle wrap around.
        if ((ptr -= m_iEntrySize) < &m_rgData[0])
            ptr = EntryPtr(m_iSize - 1);
    }
}


//*****************************************************************************
// Iterates over all active values, passing each one to pDeleteLoopFunc.
// If pDeleteLoopFunc returns TRUE, the entry is deleted. This is safer
// and faster than using FindNext() and Delete().
//*****************************************************************************
void CClosedHashBase::DeleteLoop(
    DELETELOOPFUNC pDeleteLoopFunc,     // Decides whether to delete item
    void *pCustomizer)                  // Extra value passed to deletefunc.
{
    int i;

    if (m_rgData == 0)
    {
        return;
    }

    for (i = 0; i < m_iSize; i++)
    {
        BYTE *pEntry = EntryPtr(i);
        if (Status(pEntry) == USED)
        {
            if (pDeleteLoopFunc(pEntry, pCustomizer))
            {
                SetStatus(pEntry, m_bPerfect ? FREE : DELETED);
                --m_iCount;  // One less active entry
            }
        }
    }

    if (!m_bPerfect)
    {
        // Now free DELETED entries that are no longer part of a chain.
        for (i = 0; i < m_iSize; i++)
        {
            if (Status(EntryPtr(i)) == FREE)
            {
                break;
            }
        }
        if (i != m_iSize)
        {
            int iFirstFree = i;
    
            do
            {
                if (i-- == 0)
                {
                    i = m_iSize - 1;
                }
                while (Status(EntryPtr(i)) == DELETED)
                {
                    SetStatus(EntryPtr(i), FREE);
                    if (i-- == 0)
                    {
                        i = m_iSize - 1;
                    }
                }
    
                while (Status(EntryPtr(i)) != FREE)
                {
                    if (i-- == 0)
                    {
                        i = m_iSize - 1;
                    }
                }
    
            }
            while (i != iFirstFree);
        }
    }

}

//*****************************************************************************
// Lookup a key value and return a pointer to the element if found.
//*****************************************************************************
BYTE *CClosedHashBase::Find(            // The item if found, 0 if not.
    void        *pData)                 // The key to lookup.
{
    unsigned long iHash;                // Hash value for this data.
    int         iBucket;                // Which bucke to start at.
    int         i;                      // Loop control.

    // Safety check.
    if (!m_rgData || m_iCount == 0)
        return (0);

    // Hash to the bucket.
    iHash = Hash(pData);
    iBucket = iHash % m_iBuckets;

    // For a perfect table, the bucket is the correct one.
    if (m_bPerfect)
    {
        // If the value is there, it is the correct one.
        if (Status(EntryPtr(iBucket)) != FREE)
            return (EntryPtr(iBucket));
        return (0);
    }

    // Walk the bucket list looking for the item.
    for (i=iBucket;  Status(EntryPtr(i)) != FREE;  )
    {
        // Don't look at deleted items.
        if (Status(EntryPtr(i)) == DELETED)
        {
            // Handle wrap around.
            if (++i >= m_iSize)
                i = 0;
            continue;
        }

        // Check this one.
        if (Compare(pData, EntryPtr(i)) == 0)
            return (EntryPtr(i));

        // If we never collided while adding items, then there is
        // no point in scanning any further.
        if (!m_iCollisions)
            return (0);

        // Handle wrap around.
        if (++i >= m_iSize)
            i = 0;
    }
    return (0);
}



//*****************************************************************************
// Look for an item in the table.  If it isn't found, then create a new one and
// return that.
//*****************************************************************************
BYTE *CClosedHashBase::FindOrAdd(       // The item if found, 0 if not.
    void        *pData,                 // The key to lookup.
    bool        &bNew)                  // true if created.
{
    unsigned long iHash;                // Hash value for this data.
    int         iBucket;                // Which bucke to start at.
    int         i;                      // Loop control.

    // If we haven't allocated any memory, or it is too small, fix it.
    if (!m_rgData || ((m_iCount + 1) > (m_iSize * 3 / 4) && !m_bPerfect))
    {
        if (!ReHash())
            return (0);
    }

    // Assume we find it.
    bNew = false;

    // Hash to the bucket.
    iHash = Hash(pData);
    iBucket = iHash % m_iBuckets;

    // For a perfect table, the bucket is the correct one.
    if (m_bPerfect)
    {
        // If the value is there, it is the correct one.
        if (Status(EntryPtr(iBucket)) != FREE)
            return (EntryPtr(iBucket));
        i = iBucket;
    }
    else
    {
        // Walk the bucket list looking for the item.
        for (i=iBucket;  Status(EntryPtr(i)) != FREE;  )
        {
            // Don't look at deleted items.
            if (Status(EntryPtr(i)) == DELETED)
            {
                // Handle wrap around.
                if (++i >= m_iSize)
                    i = 0;
                continue;
            }

            // Check this one.
            if (Compare(pData, EntryPtr(i)) == 0)
                return (EntryPtr(i));

            // One more to count.
            ++m_iCollisions;

            // Handle wrap around.
            if (++i >= m_iSize)
                i = 0;
        }
    }

    // We've found an open slot, use it.
    _ASSERTE(Status(EntryPtr(i)) == FREE);
    bNew = true;
    ++m_iCount;
    return (EntryPtr(i));
}

//*****************************************************************************
// This helper actually does the add for you.
//*****************************************************************************
BYTE *CClosedHashBase::DoAdd(void *pData, BYTE *rgData, int &iBuckets, int iSize, 
            int &iCollisions, int &iCount)
{
    unsigned long iHash;                // Hash value for this data.
    int         iBucket;                // Which bucke to start at.
    int         i;                      // Loop control.

    // Hash to the bucket.
    iHash = Hash(pData);
    iBucket = iHash % iBuckets;

    // For a perfect table, the bucket is free.
    if (m_bPerfect)
    {
        i = iBucket;
        _ASSERTE(Status(EntryPtr(i, rgData)) == FREE);
    }
    // Need to scan.
    else
    {
        // Walk the bucket list looking for a slot.
        for (i=iBucket;  Status(EntryPtr(i, rgData)) != FREE;  )
        {
            // Handle wrap around.
            if (++i >= iSize)
                i = 0;

            // If we made it this far, we collided.
            ++iCollisions;
        }
    }

    // One more item in list.
    ++iCount;

    // Return the new slot for the caller.
    return (EntryPtr(i, rgData));
}

//*****************************************************************************
// This function is called either to init the table in the first place, or
// to rehash the table if we ran out of room.
//*****************************************************************************
bool CClosedHashBase::ReHash()          // true if successful.
{
    // Allocate memory if we don't have any.
    if (!m_rgData)
    {
        if ((m_rgData = new BYTE [m_iSize * m_iEntrySize]) == 0)
            return (false);
        InitFree(&m_rgData[0], m_iSize);
        return (true);
    }

    // We have entries already, allocate a new table.
    BYTE        *rgTemp, *p;
    int         iBuckets = m_iBuckets * 2;
    int         iSize = iBuckets + 7;
    int         iCollisions = 0;
    int         iCount = 0;

    if ((rgTemp = new BYTE [iSize * m_iEntrySize]) == 0)
        return (false);
    InitFree(&rgTemp[0], iSize);
    m_bPerfect = false;

    // Rehash the data.
    for (int i=0;  i<m_iSize;  i++)
    {
        // Only copy used entries.
        if (Status(EntryPtr(i)) != USED)
            continue;
        
        // Add this entry to the list again.
        VERIFY((p = DoAdd(GetKey(EntryPtr(i)), rgTemp, iBuckets, 
                iSize, iCollisions, iCount)) != 0);
        memmove(p, EntryPtr(i), m_iEntrySize);

        // Only count those entries with real data.
        ++iCount;
    }
    
    // Reset internals.
    delete [] m_rgData;
    m_rgData = rgTemp;
    m_iBuckets = iBuckets;
    m_iSize = iSize;
    m_iCollisions = iCollisions;
    m_iCount = iCount;
    return (true);
}


//
//
// CStructArray
//
//


//*****************************************************************************
// Returns a pointer to the (iIndex)th element of the array, shifts the elements 
// in the array if the location is already full. The iIndex cannot exceed the count 
// of elements in the array.
//*****************************************************************************
void *CStructArray::Insert(
    int         iIndex)
{
    _ASSERTE(iIndex >= 0);
    
    // We can not insert an element further than the end of the array.
    if (iIndex > m_iCount)
        return (NULL);
    
    // The array should grow, if we can't fit one more element into the array.
    if (Grow(1) == FALSE)
        return (NULL);

    // The pointer to be returned.
    char *pcList = ((char *) m_pList) + iIndex * m_iElemSize;

    // See if we need to slide anything down.
    if (iIndex < m_iCount)
        memmove(pcList + m_iElemSize, pcList, (m_iCount - iIndex) * m_iElemSize);
    ++m_iCount;
    return(pcList);
}


//*****************************************************************************
// Allocate a new element at the end of the dynamic array and return a pointer
// to it.
//*****************************************************************************
void *CStructArray::Append()
{
    // The array should grow, if we can't fit one more element into the array.
    if (Grow(1) == FALSE)
        return (NULL);

    return (((char *) m_pList) + m_iCount++ * m_iElemSize);
}


//*****************************************************************************
// Allocate enough memory to have at least iCount items.  This is a one shot
// check for a block of items, instead of requiring singleton inserts.  It also
// avoids realloc headaches caused by growth, since you can do the whole block
// in one piece of code.  If the array is already large enough, this is a no-op.
//*****************************************************************************
int CStructArray::AllocateBlock(int iCount)
{
    if (m_iSize < m_iCount+iCount)
    {
        if (!Grow(iCount))
            return (FALSE);
    }
    m_iCount += iCount;
    return (TRUE);
}



//*****************************************************************************
// Deletes the specified element from the array.
//*****************************************************************************
void CStructArray::Delete(
    int         iIndex)
{
    _ASSERTE(iIndex >= 0);

    // See if we need to slide anything down.
    if (iIndex < --m_iCount)
    {
        char *pcList = ((char *) m_pList) + iIndex * m_iElemSize;
        memmove(pcList, pcList + m_iElemSize, (m_iCount - iIndex) * m_iElemSize);
    }
}


//*****************************************************************************
// Grow the array if it is not possible to fit iCount number of new elements.
//*****************************************************************************
int CStructArray::Grow(
    int         iCount)
{
    void        *pTemp;                 // temporary pointer used in realloc.
    int         iGrow;

    if (m_iSize < m_iCount+iCount)
    {
        if (m_pList == NULL)
        {
            iGrow = max(m_iGrowInc, iCount);

            //@todo this is a hack because I don't want to do resize right now.
            if ((m_pList = malloc(iGrow * m_iElemSize)) == NULL)
                return (FALSE);
            m_iSize = iGrow;
            m_bFree = true;
        }
        else
        {
            // Adjust grow size as a ratio to avoid too many reallocs.
            if (m_iSize / m_iGrowInc >= 3)
                m_iGrowInc *= 2;

            iGrow = max(m_iGrowInc, iCount);

            // try to allocate memory for reallocation.
            if (m_bFree)
            {   // We already own memory.
                if((pTemp = realloc(m_pList, (m_iSize+iGrow) * m_iElemSize)) == NULL)
                    return (FALSE);
            }
            else
            {   // We don't own memory; get our own.
                if((pTemp = malloc((m_iSize+iGrow) * m_iElemSize)) == NULL)
                    return (FALSE);
                memcpy(pTemp, m_pList, m_iSize * m_iElemSize);
                m_bFree = true;
            }
            m_pList = pTemp;
            m_iSize += iGrow;
        }
    }
    return (TRUE);
}


//*****************************************************************************
// Free the memory for this item.
//*****************************************************************************
void CStructArray::Clear()
{
    // Free the chunk of memory.
    if (m_bFree && m_pList != NULL)
        free(m_pList);

    m_pList = NULL;
    m_iSize = 0;
    m_iCount = 0;
}



//
//
// CStringSet
//
//

//*****************************************************************************
// Free memory.
//*****************************************************************************
CStringSet::~CStringSet()
{
    if (m_pStrings)
        free(m_pStrings);
}

//*****************************************************************************
// Delete the specified string from the string set.
//*****************************************************************************
int CStringSet::Delete(
    int     iStr)
{
    void        *pTemp = (char *) m_pStrings + iStr;
    int         iDelSize = (int)Wszlstrlen((LPCTSTR) pTemp) + 1;

    if ((char *) pTemp + iDelSize > (char *) m_pStrings + m_iUsed)
        return (-1);

    memmove(pTemp, (char *) pTemp + iDelSize, m_iUsed - (iStr + iDelSize));
    m_iUsed -= iDelSize;
    return (0);
}


//*****************************************************************************
// Save the specified string and return its index in the storage space.
//*****************************************************************************
int CStringSet::Save(
    LPCTSTR     szStr)
{

    void        *pTemp;                 // temporary pointer used in realloc.
    int         iNeeded = (int)Wszlstrlen(szStr) +1; // amount of memory needed in the StringSet.
    
    _ASSERTE(!(m_pStrings == NULL && m_iSize != 0));
    
    if (m_iSize < m_iUsed + iNeeded)
    {
        if (m_pStrings == NULL)
        {
            // Allocate memory for the string set..
            if ((m_pStrings = malloc(m_iGrowInc)) == NULL)

                return (-1);
            m_iSize = m_iGrowInc;
        }
        else
        {
            // try to allocate memory for reallocation. 
            if((pTemp = realloc(m_pStrings, m_iSize + m_iGrowInc)) == NULL)
                return (-1);
            // copy the pointer and update the set size.
            m_iSize += m_iGrowInc;
            m_pStrings = pTemp;
        }
    }

    Wszlstrcpy((TCHAR *) m_pStrings + m_iUsed, szStr);
    int iTmp = m_iUsed;
    m_iUsed += iNeeded;
    return (iTmp);
}

//*****************************************************************************
// Shrink the StringSet so that it does not keep more space than it needs.
//*****************************************************************************
int CStringSet::Shrink()                // return code
{
    void    *pTemp;

    if((pTemp = realloc(m_pStrings, m_iUsed)) == NULL)
        return (-1);

    m_pStrings = pTemp;
    return (0);
}





//*****************************************************************************
// Convert a string of hex digits into a hex value of the specified # of bytes.
//*****************************************************************************
HRESULT GetHex(                         // Return status.
    LPCSTR      szStr,                  // String to convert.
    int         size,                   // # of bytes in pResult.
    void        *pResult)               // Buffer for result.
{
    int         count = size * 2;       // # of bytes to take from string.
    unsigned long Result = 0;           // Result value.
    char          ch;

    _ASSERTE(size == 1 || size == 2 || size == 4);

    while (count-- && (ch = *szStr++) != '\0')
    {
        switch (ch)
        {
            case '0': case '1': case '2': case '3': case '4': 
            case '5': case '6': case '7': case '8': case '9': 
            Result = 16 * Result + (ch - '0');
            break;

            case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
            Result = 16 * Result + 10 + (ch - 'A');
            break;

            case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
            Result = 16 * Result + 10 + (ch - 'a');
            break;

            default:
            return (E_FAIL);
        }
    }

    // Set the output.
    switch (size)
    {
        case 1:
        *((BYTE *) pResult) = (BYTE) Result;
        break;

        case 2:
        *((WORD *) pResult) = (WORD) Result;
        break;

        case 4:
        *((DWORD *) pResult) = Result;
        break;

        default:
        _ASSERTE(0);
        break;
    }
    return (S_OK);
}


//*****************************************************************************
// Convert a pointer to a string into a GUID.
//*****************************************************************************
HRESULT LPCSTRToGuid(                   // Return status.
    LPCSTR      szGuid,                 // String to convert.
    GUID        *psGuid)                // Buffer for converted GUID.
{
    int         i;

    // Verify the surrounding syntax.
    if (strlen(szGuid) != 38 || szGuid[0] != '{' || szGuid[9] != '-' ||
        szGuid[14] != '-' || szGuid[19] != '-' || szGuid[24] != '-' || szGuid[37] != '}')
        return (E_FAIL);

    // Parse the first 3 fields.
    if (FAILED(GetHex(szGuid+1, 4, &psGuid->Data1))) return (E_FAIL);
    if (FAILED(GetHex(szGuid+10, 2, &psGuid->Data2))) return (E_FAIL);
    if (FAILED(GetHex(szGuid+15, 2, &psGuid->Data3))) return (E_FAIL);

    // Get the last two fields (which are byte arrays).
    for (i=0; i < 2; ++i)
        if (FAILED(GetHex(szGuid + 20 + (i * 2), 1, &psGuid->Data4[i])))
            return (E_FAIL);
    for (i=0; i < 6; ++i)
        if (FAILED(GetHex(szGuid + 25 + (i * 2), 1, &psGuid->Data4[i+2])))
            return (E_FAIL);
    return (S_OK);
}


//*****************************************************************************
// Parse a string that is a list of strings separated by the specified
// character.  This eliminates both leading and trailing whitespace.  Two
// important notes: This modifies the supplied buffer and changes the szEnv
// parameter to point to the location to start searching for the next token.
// This also skips empty tokens (e.g. two adjacent separators).  szEnv will be
// set to NULL when no tokens remain.  NULL may also be returned if no tokens
// exist in the string.
//*****************************************************************************
char *StrTok(                           // Returned token.
    char        *&szEnv,                // Location to start searching.
    char        ch)                     // Separator character.
{
    char        *tok;                   // Returned token.
    char        *next;                  // Used to find separator.

    do
    {
        // Handle the case that we have thrown away a bunch of white space.
        if (szEnv == NULL) return(NULL);

        // Skip leading whitespace.
        while (*szEnv == ' ' || *szEnv == '\t') ++szEnv;

        // Parse the next component.
        tok = szEnv;
        if ((next = strchr(szEnv, ch)) == NULL)
            szEnv = NULL;
        else
        {
            szEnv = next+1;

            // Eliminate trailing white space.
            while (--next >= tok && (*next == ' ' || *next == '\t'));
            *++next = '\0';
        }
    }
    while (*tok == '\0');
    return (tok);
}


//
//
// Global utility functions.
//
//



#if 0
// Only write if tracing is allowed.
int _cdecl DbgWrite(LPCTSTR szFmt, ...)
{
    static WCHAR rcBuff[1024];
    static int  bChecked = 0;
    static int  bWrite = 1;
    va_list     marker;

    if (!bChecked)
    {
        bWrite = REGUTIL::GetLong(L"Trace", FALSE);
        bChecked = 1;
    }

    if (!bWrite)
        return (0);

    va_start(marker, szFmt);
    _vsnwprintf(rcBuff, NumItems(rcBuff), szFmt, marker);
    va_end(marker);
    WszOutputDebugString(rcBuff);
    return (lstrlenW(rcBuff));
}

// Always write regardless of registry.
int _cdecl DbgWriteEx(LPCTSTR szFmt, ...)
{
    static WCHAR rcBuff[1024];
    va_list     marker;

    va_start(marker, szFmt);
    _vsnwprintf(rcBuff, NumItems(rcBuff), szFmt, marker);
    va_end(marker);
    WszOutputDebugString(rcBuff);
    return (lstrlenW(rcBuff));
}
#endif


// Writes a wide, formatted string to the standard output.
//@ todo: Is 1024 big enough?  what does printf do?

int _cdecl PrintfStdOut(LPCWSTR szFmt, ...)
{
    WCHAR rcBuff[1024];
	CHAR  sMbsBuff[1024 * sizeof(WCHAR)];
    va_list     marker;
	DWORD		cWritten;
	size_t		cChars;
	

    va_start(marker, szFmt);
    _vsnwprintf(rcBuff, NumItems(rcBuff), szFmt, marker);
    va_end(marker);
	cChars = lstrlenW(rcBuff);
	int cBytes = WszWideCharToMultiByte(GetACP(), 0, rcBuff, -1, sMbsBuff, sizeof(sMbsBuff), NULL, NULL);
	
	WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), sMbsBuff, cBytes, &cWritten, NULL);
    
	return ((int)cChars);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\utsem.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
/******************************************************************************
	FILE : UTSEM.CPP

	Purpose: Part of the utilities library for the VIPER project

	Abstract : Implements the RTSemReadWrite class.
-------------------------------------------------------------------------------
Revision History:

[0]		06/06/97	JimLyon		Created
*******************************************************************************/
#include "stdafx.h"


#include <UTSem.H>




/******************************************************************************
Static Function : VipInitializeCriticalSectionIgnoreSpinCount

Abstract: Just call InitializeCriticalSection. This routine is used on systems
		  that don't support InitializeCriticalSectionAndSpinCount (Win95, or
		  WinNT prior to NT4.0 SP3)
******************************************************************************/
static BOOL VipInitializeCriticalSectionIgnoreSpinCount (CRITICAL_SECTION* cs, unsigned long lcCount)
{
	InitializeCriticalSection (cs);
	return TRUE;
}



/******************************************************************************
Function : UTSemExclusive::UTSemExclusive

Abstract: Constructor.
******************************************************************************/
RTSemExclusive::RTSemExclusive (unsigned long ulcSpinCount)
{
	typedef BOOL (*TpInitCSSpin) (CRITICAL_SECTION* cs, unsigned long lcCount);
							// pointer to function with InitializeCriticalSectionAndSpinCount's signature
	static TpInitCSSpin pInitCSSpin = VipInitializeCriticalSectionIgnoreSpinCount;
							// pointer to InitializeCriticalSectionAndSpinCount, or thunk
	static BOOL fInitialized = FALSE;


	if (!fInitialized)
	{
		// this code may be executed by several threads simultaneously, but it's safe
#if !defined(UNDER_CE) // CE is not NT nor Memphis
		HMODULE hModule;
		FARPROC pProc;

		OSVERSIONINFOA	osVer ;
		osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA) ;
		GetVersionExA(&osVer) ;

		// TODO - enable this for Memphis once 
		// InitializeCriticalSectionAndSpinCount works properly
		if (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			hModule = GetModuleHandleA ("KERNEL32.DLL");
			if (hModule != NULL)
			{
				pProc = GetProcAddress (hModule, "InitializeCriticalSectionAndSpinCount");
				if (pProc != NULL)
					pInitCSSpin = (TpInitCSSpin) pProc;
			}
		}
#endif

		fInitialized = TRUE;
	}

	(*pInitCSSpin) (&m_csx, ulcSpinCount);

	DEBUG_STMT(m_iLocks = 0);
}


#ifndef UNDER_CE


/******************************************************************************
Definitions of the bit fields in RTSemReadWrite::m_dwFlag:

Warning: The code assume that READER_MASK is in the low-order bits of the DWORD.
******************************************************************************/

const unsigned long READERS_MASK      = 0x000003FF;	// field that counts number of readers
const unsigned long READERS_INCR      = 0x00000001;	// amount to add to increment number of readers

// The following field is 2 bits long to make it easier to catch errors.
// (If the number of writers ever exceeds 1, we've got problems.)
const unsigned long WRITERS_MASK      = 0x00000C00;	// field that counts number of writers
const unsigned long WRITERS_INCR      = 0x00000400;	// amount to add to increment number of writers

const unsigned long READWAITERS_MASK  = 0x003FF000;	// field that counts number of threads waiting to read
const unsigned long READWAITERS_INCR  = 0x00001000;	// amount to add to increment number of read waiters

const unsigned long WRITEWAITERS_MASK = 0xFFC00000;	// field that counts number of threads waiting to write
const unsigned long WRITEWAITERS_INCR = 0x00400000;	// amoun to add to increment number of write waiters



/******************************************************************************
Function : RTSemReadWrite::RTSemReadWrite

Abstract: Constructor.
******************************************************************************/
RTSemReadWrite::RTSemReadWrite (unsigned long ulcSpinCount,
		LPCSTR szSemaphoreName, LPCSTR szEventName)
{
	static BOOL fInitialized = FALSE;
	static unsigned long maskMultiProcessor;	// 0 => uniprocessor, all 1 bits => multiprocessor

	if (!fInitialized)
	{
		SYSTEM_INFO SysInfo;

		GetSystemInfo (&SysInfo);
		if (SysInfo.dwNumberOfProcessors > 1)
			maskMultiProcessor = 0xFFFFFFFF;
		else
			maskMultiProcessor = 0;

		fInitialized = TRUE;
	}


	m_ulcSpinCount = ulcSpinCount & maskMultiProcessor;
	m_dwFlag = 0;
	m_hReadWaiterSemaphore = NULL;
	m_hWriteWaiterEvent = NULL;
	m_szSemaphoreName = szSemaphoreName;
	m_szEventName = szEventName;
}


/******************************************************************************
Function : RTSemReadWrite::~RTSemReadWrite

Abstract: Destructor
******************************************************************************/
RTSemReadWrite::~RTSemReadWrite ()
{
	_ASSERTE (m_dwFlag == 0 && "Destroying a RTSemReadWrite while in use");

	if (m_hReadWaiterSemaphore != NULL)
		CloseHandle (m_hReadWaiterSemaphore);

	if (m_hWriteWaiterEvent != NULL)
		CloseHandle (m_hWriteWaiterEvent);
}


/******************************************************************************
Function : RTSemReadWrite::LockRead

Abstract: Obtain a shared lock
******************************************************************************/
void RTSemReadWrite::LockRead ()
{
	unsigned long dwFlag;
	unsigned long ulcLoopCount = 0;


	for (;;)
	{
		dwFlag = m_dwFlag;

		if (dwFlag < READERS_MASK)
		{
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag + READERS_INCR, dwFlag))
				break;
		}

		else if ((dwFlag & READERS_MASK) == READERS_MASK)
			Sleep(1000);

		else if ((dwFlag & READWAITERS_MASK) == READWAITERS_MASK)
			Sleep(1000);

		else if (ulcLoopCount++ < m_ulcSpinCount)
			/* nothing */ ;

		else
		{
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag + READWAITERS_INCR, dwFlag))
			{
				WaitForSingleObject (GetReadWaiterSemaphore(), INFINITE);
				break;
			}
		}
	}

	_ASSERTE ((m_dwFlag & READERS_MASK) != 0 && "reader count is zero after acquiring read lock");
	_ASSERTE ((m_dwFlag & WRITERS_MASK) == 0 && "writer count is nonzero after acquiring write lock");
}



/******************************************************************************
Function : RTSemReadWrite::LockWrite

Abstract: Obtain an exclusive lock
******************************************************************************/
void RTSemReadWrite::LockWrite ()
{
	unsigned long dwFlag;
	unsigned long ulcLoopCount = 0;


	for (;;)
	{
		dwFlag = m_dwFlag;

		if (dwFlag == 0)
		{
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, WRITERS_INCR, dwFlag))
				break;
		}

		else if ((dwFlag & WRITEWAITERS_MASK) == WRITEWAITERS_MASK)
			Sleep(1000);

		else if (ulcLoopCount++ < m_ulcSpinCount)
			/*nothing*/ ;

		else
		{
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag + WRITEWAITERS_INCR, dwFlag))
			{
				WaitForSingleObject (GetWriteWaiterEvent(), INFINITE);
				break;
			}
		}

	}

	_ASSERTE ((m_dwFlag & READERS_MASK) == 0 && "reader count is nonzero after acquiring write lock");
	_ASSERTE ((m_dwFlag & WRITERS_MASK) == WRITERS_INCR && "writer count is not 1 after acquiring write lock");
}



/******************************************************************************
Function : RTSemReadWrite::UnlockRead

Abstract: Release a shared lock
******************************************************************************/
void RTSemReadWrite::UnlockRead ()
{
	unsigned long dwFlag;


	_ASSERTE ((m_dwFlag & READERS_MASK) != 0 && "reader count is zero before releasing read lock");
	_ASSERTE ((m_dwFlag & WRITERS_MASK) == 0 && "writer count is nonzero before releasing read lock");

	for (;;)
	{
		dwFlag = m_dwFlag;

		if (dwFlag == READERS_INCR)
		{		// we're the last reader, and nobody is waiting
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, 0, dwFlag))
				break;
		}

		else if ((dwFlag & READERS_MASK) > READERS_INCR)
		{		// we're not the last reader
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag - READERS_INCR, dwFlag))
				break;
		}

		else
		{
			// here, there should be exactly 1 reader (us), and at least one waiting writer.
			_ASSERTE ((dwFlag & READERS_MASK) == READERS_INCR && "UnlockRead consistency error 1");
			_ASSERTE ((dwFlag & WRITEWAITERS_MASK) != 0 && "UnlockRead consistency error 2");

			// one or more writers is waiting, do one of them next
			// (remove a reader (us), remove a write waiter, add a writer
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag,
					dwFlag - READERS_INCR - WRITEWAITERS_INCR + WRITERS_INCR, dwFlag))
			{
				SetEvent (GetWriteWaiterEvent());
				break;
			}
		}
	}
}


/******************************************************************************
Function : RTSemReadWrite::UnlockWrite

Abstract: Release an exclusive lock
******************************************************************************/
void RTSemReadWrite::UnlockWrite ()
{
	unsigned long dwFlag;
	unsigned long count;


	_ASSERTE ((m_dwFlag & READERS_MASK) == 0 && "reader count is nonzero before releasing write lock");
	_ASSERTE ((m_dwFlag & WRITERS_MASK) == WRITERS_INCR && "writer count is not 1 before releasing write lock");


	for (;;)
	{
		dwFlag = m_dwFlag;

		if (dwFlag == WRITERS_INCR)
		{		// nobody is waiting
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, 0, dwFlag))
				break;
		}

		else if ((dwFlag & READWAITERS_MASK) != 0)
		{		// one or more readers are waiting, do them all next
			count = (dwFlag & READWAITERS_MASK) / READWAITERS_INCR;
			// remove a writer (us), remove all read waiters, turn them into readers
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag,
					dwFlag - WRITERS_INCR - count * READWAITERS_INCR + count * READERS_INCR, dwFlag))
			{
				ReleaseSemaphore (GetReadWaiterSemaphore(), count, NULL);
				break;
			}
		}

		else
		{		// one or more writers is waiting, do one of them next
			_ASSERTE ((dwFlag & WRITEWAITERS_MASK) != 0 && "UnlockWrite consistency error");
				// (remove a writer (us), remove a write waiter, add a writer
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag - WRITEWAITERS_INCR, dwFlag))
			{
				SetEvent (GetWriteWaiterEvent());
				break;
			}
		}
	}
}


/******************************************************************************
Function : RTSemReadWrite::GetReadWaiterSemaphore

Abstract: Return the semaphore to use for read waiters
******************************************************************************/
HANDLE RTSemReadWrite::GetReadWaiterSemaphore()
{
	HANDLE h;

	if (m_hReadWaiterSemaphore == NULL)
	{
		h = CreateSemaphoreA (NULL, 0, MAXLONG, m_szSemaphoreName);
		_ASSERTE (h != NULL && "GetReadWaiterSemaphore can't CreateSemaphore");
		if (NULL != VipInterlockedCompareExchange (&m_hReadWaiterSemaphore, h, NULL))
			CloseHandle (h);
	}

	return m_hReadWaiterSemaphore;
}


/******************************************************************************
Function : RTSemReadWrite::GetWriteWaiterEvent

Abstract: Return the semaphore to use for write waiters
******************************************************************************/
HANDLE RTSemReadWrite::GetWriteWaiterEvent()
{
	HANDLE h;

	if (m_hWriteWaiterEvent == NULL)
	{
		h = CreateEventA (NULL, FALSE, FALSE, m_szEventName);	// auto-reset event
		_ASSERTE (h != NULL && "GetWriteWaiterEvent can't CreateEvent");
		if (NULL != VipInterlockedCompareExchange (&m_hWriteWaiterEvent, h, NULL))
			CloseHandle (h);
	}

	return m_hWriteWaiterEvent;
}

#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\winfix.cpp ===
//*****************************************************************************
// WinWrap.cpp
//
// This file contains wrapper functions for Win32 API's that take strings.
// Support on each platform works as follows:
//      OS          Behavior
//      ---------   -------------------------------------------------------
//      NT          Fully supports both W and A funtions.
//      Win 9x      Supports on A functions, stubs out the W functions but
//                      then fails silently on you with no warning.
//      CE          Only has the W entry points.
//
// COM+ internally uses UNICODE as the internal state and string format.  This
// file will undef the mapping macros so that one cannot mistakingly call a
// method that isn't going to work.  Instead, you have to call the correct
// wrapper API.
//
// Copyright (c) 1997-1998, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Precompiled header key.
#include "WinWrap.h"                    // Header for macros and functions.
#include "utilcode.h"
#include <stdio.h>
#include <wchar.h>
#include <stdarg.h>

//********** Globals. *********************************************************
int				g_bOnUnicodeBox = false;// true if on UNICODE system.


const ULONG DBCS_MAXWID=2;
const ULONG MAX_REGENTRY_LEN=256;

// From UTF.C
    int UTFToUnicode(
        UINT CodePage,
        DWORD dwFlags,
        LPCSTR lpMultiByteStr,
        int cchMultiByte,
        LPWSTR lpWideCharStr,
        int cchWideChar);

    int UnicodeToUTF(
        UINT CodePage,
        DWORD dwFlags,
        LPCWSTR lpWideCharStr,
        int cchWideChar,
        LPSTR lpMultiByteStr,
        int cchMultiByte,
        LPCSTR lpDefaultChar,
        LPBOOL lpUsedDefaultChar);


//-----------------------------------------------------------------------------
// OnUnicodeSystem
//
// @func Determine if the OS that we are on, actually supports the unicode verion
// of the win32 API.  If YES, then g_bOnUnicodeBox == FALSE.
//
// @rdesc True of False
//-----------------------------------------------------------------------------------
BOOL OnUnicodeSystem()
{
    OSVERSIONINFO   sVerInfo;
    HKEY    hkJunk = HKEY_CURRENT_USER;

#ifdef UNDER_CE
	return TRUE;
#else

    g_bOnUnicodeBox = TRUE;

	// NT is always UNICODE.  GetVersionEx is faster than actually doing a
	// RegOpenKeyExW on NT, so figure it out that way and do hard way if you have to.
	sVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (WszGetVersionEx(&sVerInfo) && sVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		goto ErrExit;

    // Check to see if we have win95's broken registry, thus
    // do not have Unicode support in the OS
    if ((RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                     L"SOFTWARE",
                     0,
                     KEY_READ,
                     &hkJunk) == ERROR_SUCCESS) &&
        hkJunk == HKEY_CURRENT_USER)
    {
       // Try the ANSI version
        if ((RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                             "SOFTWARE",
                             0,
                            KEY_READ,
                            &hkJunk) == ERROR_SUCCESS) &&
            (hkJunk != HKEY_CURRENT_USER))

        {
            g_bOnUnicodeBox = FALSE;
        }
    }

	if (hkJunk != HKEY_CURRENT_USER)
		RegCloseKey(hkJunk);

ErrExit:

#if defined( _DEBUG )
	{
	#if defined( _M_IX86 )
		// This little "mutent" forces a user to run ANSI on a UNICODE
		// machine on a regular basis.  Given most people run on NT for dev
		// test cases, they miss wrapper errors they've introduced.  This 
		// gives you an even chance of finding them sooner.
		SYSTEMTIME	tm;
		GetSystemTime(&tm);

		// If this is a UNICODE box, and today is an even day, run ANSI.
		if (g_bOnUnicodeBox && (tm.wDay & 1) == 0)
			g_bOnUnicodeBox = false;

		// In debug mode, allow the user to force the ANSI path.  This is good for
		// cases where you are only running on an NT machine, and you need to
		// test what a Win '9x machine would do.
		WCHAR		rcVar[96];
		if (WszGetEnvironmentVariable(L"WINWRAP_ANSI", rcVar, NumItems(rcVar)))
			g_bOnUnicodeBox = false;
	#endif // _M_IX86 
	}
#endif // _DEBUG

	return g_bOnUnicodeBox;
#endif // else not UNDER_CE
}



#ifndef UNDER_CE
//-----------------------------------------------------------------------------
// WszGetUserName
//
// @func The GetUserName function retrieves the user name of the current thread.
//              This is the name of the user currently logged onto the system. 
//
// @rdesc If the function succeeds, the return value is a nonzero value, and the
//              variable pointed to by nSize contains the number of TCHARs copied
//              to the buffer specified by lpBuffer, including the terminating
//              null character.
//        If the function fails, the return value is zero. To get extended error
//              information, call GetLastError. 
BOOL WszGetUserName(
    LPTSTR lpBuffer,  // name buffer
    LPDWORD lpdwSize     // size of name buffer
    )
{
    DWORD   cchLen = 0;  
    PSTR    pStr = NULL;
    BOOL    bRtn=FALSE;

    if (g_bOnUnicodeBox)
        return  GetUserNameW(lpBuffer, lpdwSize);

    //This will generate an error but we want to make sure LastError is set correctly
    if( 0==lpBuffer || 0==lpdwSize || 0==*lpdwSize)
        return GetUserNameA(reinterpret_cast<char *>(lpBuffer), lpdwSize);

    // Allocate a buffer for the string allowing room for
    // a multibyte string
    pStr = new CHAR[*lpdwSize];
    if( pStr == NULL )
        goto EXIT;

    cchLen = *lpdwSize;
    if(FALSE == (bRtn = GetUserNameA(pStr, &cchLen)))
        goto EXIT;
                                                                      //lpdwSize is an IN OUT param, just like in GetUserName
    if(0==cchLen || FAILED(WszConvertToUnicode(pStr, cchLen, &lpBuffer, lpdwSize, FALSE)))
    {
        *lpdwSize   = 0;
        bRtn        = FALSE;
    }

EXIT:
    delete[] pStr;

    return bRtn;
}


//-----------------------------------------------------------------------------
// WszGetComputerName
//
// @func The GetComputerName function retrieves the NetBIOS name of the local
//              computer. This name is established at system startup, when the
//              system reads it from the registry.
//       If the local computer is a node in a cluster, GetComputerName returns
//              the name of the node. 
//
// @rdesc If the function succeeds, the return value is a nonzero value. 
//
BOOL WszGetComputerName(
    LPTSTR lpBuffer,  // computer name buffer
    LPDWORD lpdwSize     // size of computer name buffer
    )
{
    DWORD   cchLen = 0;  
    PSTR    pStr = NULL;
    BOOL    bRtn=FALSE;

    if (g_bOnUnicodeBox)
        return  GetComputerNameW(lpBuffer, lpdwSize);

    //This will generate an error but we want to make sure LastError is set correctly
    if( 0==lpBuffer || 0==lpdwSize || 0==*lpdwSize)
        return GetComputerNameA(reinterpret_cast<char *>(lpBuffer), lpdwSize);

    // Allocate a buffer for the string allowing room for
    // a multibyte string
    pStr = new CHAR[*lpdwSize];
    if( pStr == NULL )
        goto EXIT;

    cchLen = *lpdwSize;
    if(FALSE == (bRtn = GetComputerNameA(pStr, &cchLen)))
        goto EXIT;
                                                                      //lpdwSize is an IN OUT param, just like in GetComputerName
    if(0==cchLen || FAILED(WszConvertToUnicode(pStr, cchLen, &lpBuffer, lpdwSize, FALSE)))
    {
        *lpdwSize   = 0;
        bRtn        = FALSE;
    }

EXIT:
    delete[] pStr;

    return bRtn;
}


//-----------------------------------------------------------------------------
// WszPeekMessage
//
// @func The PeekMessage function dispatches incoming sent messages, checks the
//              thread message queue for a posted message, and retrieves the
//              message (if any exist). 
//
// @rdesc If a message is available, the return value is nonzero.
BOOL WszPeekMessage(
  LPMSG lpMsg,         // message information
  HWND hWnd,           // handle to window
  UINT wMsgFilterMin,  // first message
  UINT wMsgFilterMax,  // last message
  UINT wRemoveMsg      // removal options
)
{
    if (g_bOnUnicodeBox)
        return PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    _ASSERTE(false && L"WszPeekMessage is not for use on Win9x systems.  This is a place holder so 'atlimpl.cpp' does fail to compile");
    return 0;
}

//-----------------------------------------------------------------------------
// WszCharNext
//
// @func The CharNext function retrieves a pointer to the next character in a string. 
//
// @rdesc The return value is a pointer to the next character in the string, or to
//              the terminating null character if at the end of the string.  If lpsz
//              points to the terminating null character, the return value is equal
//              to lpsz.
//-----------------------------------------------------------------------------------
LPTSTR WszCharNext(
  LPCTSTR lpsz   // current character
)
{
    if (g_bOnUnicodeBox)
        return CharNextW(lpsz);
    _ASSERTE(false && L"WszCharNext is not for use on Win9x systems.  This is a place holder so 'atlimpl.cpp' does fail to compile");
    return 0;
}


//-----------------------------------------------------------------------------
// WszDispatchMessage
//
// @func The DispatchMessage function dispatches a message to a window procedure.
//              It is typically used to dispatch a message retrieved by the
//              GetMessage function. 
//
// @rdesc The return value specifies the value returned by the window procedure.
//              Although its meaning depends on the message being dispatched, the
//              return value generally is ignored. 
//-----------------------------------------------------------------------------------
LRESULT WszDispatchMessage(
  CONST MSG *lpmsg   // message information
)
{
    if (g_bOnUnicodeBox)
        return DispatchMessageW(lpmsg);
    _ASSERTE(false && L"WszDispatchMessage is not for use on Win9x systems.  This is a place holder so 'atlimpl.cpp' does fail to compile");
    return static_cast<LRESULT>(0);
}


//-----------------------------------------------------------------------------
// WszLoadLibraryEx
//
// @func Loads a Dynamic Library
//
// @rdesc Instance Handle
//-----------------------------------------------------------------------------------
HINSTANCE WszLoadLibraryEx(
    LPCWSTR lpLibFileName,      // points to name of executable module
    HANDLE hFile,               // reserved, must be NULL 
    DWORD dwFlags               // entry-point execution flag 
    )
{   
    HINSTANCE   hInst = NULL;
    LPSTR       szLibFileName = NULL;

    _ASSERTE( !hFile );

    if (g_bOnUnicodeBox)
        return  LoadLibraryExW(lpLibFileName, hFile, dwFlags);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpLibFileName,
                      &szLibFileName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hInst = LoadLibraryExA(szLibFileName, hFile, dwFlags);

Exit:
    delete[] szLibFileName;

    return hInst;
}


//-----------------------------------------------------------------------------
// WszLoadString
//
// @func Loads a Resource String and converts it to unicode if
// need be.
//
// @rdesc Length of string (Ansi is cb) (UNICODE is cch)
//-----------------------------------------------------------------------------------
int WszLoadString(
    HINSTANCE hInstance,    // handle of module containing string resource 
    UINT uID,               // resource identifier 
    LPWSTR lpBuffer,        // address of buffer for resource 
    int cchBufferMax        // size of buffer **in characters**
   )
{
    int     cbLen = 0;  
    PSTR    pStr = NULL;

    if (g_bOnUnicodeBox)
        return  LoadStringW(hInstance, uID, lpBuffer, cchBufferMax);


    if( cchBufferMax == 0 )
        goto EXIT;

    // Allocate a buffer for the string allowing room for
    // a multibyte string
    pStr = new CHAR[cchBufferMax * sizeof(WCHAR)];
    if( pStr == NULL )
        goto EXIT;

    cbLen = LoadStringA(hInstance, uID, pStr, (cchBufferMax * sizeof(WCHAR)));

    _ASSERTE( cchBufferMax > 0 );
    if( (cbLen > 0) &&
        SUCCEEDED(WszConvertToUnicode(pStr, (cbLen + sizeof(CHAR)), &lpBuffer, 
        (ULONG*)&cchBufferMax, FALSE)) )
    {
        cbLen = lstrlenW(lpBuffer);
    }
    else
    {
        cbLen = 0;
    }

EXIT:
    delete[] pStr;

    return cbLen;
}



//The following Function WszFormatMessage was copied from GodotFormatMessageW located in Win9xU.c
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    Win9xU.c (Windows 9x Unicode wrapper functions)

Abstract:

    Auto-generated file that contains the thunks.

    WARNING: Do not edit! This file is auto-generated by getthnk.
    See unicows.tpl if you want to make changes.

Revision History:

    7 Nov 2000    v-michka    Created.
    5 Mar 2001    Stephenr    Copied GodotFormatMessageW from Win9xU.c, renamed the function and placed
                              into Winfix.cpp (making all necessary changes to get it to compile an
                              function correctly.  The above copyright and comments came from Win9xU.c.

--*/
// For FormatMessageW:
// We will support a max of 99 arguments, up to 1023 cch per arg
#define MAXINSERTS 99
#define CCHMAXPERINSERT 1023

bool bFirstTimeWszFormatMessageCalled=true;
UINT g_acp=0;         // CP_ACP; it is faster to call with the actual cpg than the CP_ACP const
UINT g_mcs=0;         // The maximum character size (in bytes) of a character on CP_ACP

// _alloca, on certain platforms, returns a raw pointer to the
// stack rather than NULL on allocations of size zero. Since this
// is sub-optimal for code that subsequently calls functions like
// strlen on the allocated block of memory, this wrapper is
// provided for use.
#define _galloca(x) ((x)?(_alloca(x)):NULL)

inline int gatoi(CHAR *sz){return atoi(sz);}
//This is just a wrapper around the VC runtime function atoi.

inline size_t gwcslen(LPWSTR wsz){return wcslen(wsz);}

/*-------------------------------
    CpgFromLocale

    Given a locale, returns the appropriate codepage to use
    for conversions
-------------------------------*/
UINT CpgFromLocale(LCID Locale)
{
    LPSTR lpLCData = reinterpret_cast<LPSTR>(_galloca(6));    // Max of this param, per PSDK docs
    
    if (GetLocaleInfoA(Locale, LOCALE_IDEFAULTANSICODEPAGE, lpLCData, 6))
        return(gatoi(lpLCData));

    return(g_acp);
}
//We use CpgFromLocale for all of our non-CP_ACP cases. The g_acp variable global is used since MC2WC and WC2MB are documented as being faster if you use the actual code page rather than CP_ACP.


// Copy from W to A as if the strings are actually atoms
#define CopyAsAtom(a, w) \
    (LPSTR)(a) = (LPSTR)(ULONG_PTR)(w)
//We use this all over when something is not a string (might be a user atom) but we need to copy it anyway.


// Convert from ANSI to Unicode using g_acp - no alloc
#define GodotToUnicode(src, dst, cch) \
    MultiByteToWideChar(g_acp, 0, (LPSTR)(src), cch*g_mcs, (LPWSTR)(dst), cch)
//g_mcs is our global max number of byte per character (2 on DBCS platforms, 1 on all others). We get it from BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);.


// Is this non null and not a user atom?
#define FValidString(x) ((ULONG_PTR)(x) > 0xffff)

// Convert from Unicode to ANSI using g_acp - includes alloc
// WARNING: Possible data loss on IA64
#define GodotToAnsiAlloc(src, dst, LenVar) \
    LenVar = gwcslen((LPWSTR)(src)) + 1; \
    (LPSTR)dst = (LPSTR)_galloca(LenVar*g_mcs); \
    if(!dst) LenVar=0; \
    WideCharToMultiByte(g_acp, 0, (LPWSTR)(src), (int)(LenVar), (LPSTR)(dst), (int)(LenVar*g_mcs), NULL, NULL)

// Convert from Unicode to ANSI if needed, otherwise copy as if it were an Atom
#define GodotToAnsiAllocSafe(src, dst, LenVar) \
    if (FValidString((LPWSTR)src)) \
    { \
        GodotToAnsiAlloc(src, dst, LenVar); \
    } \
    else \
        CopyAsAtom(dst, src)

// Func Template:FormatMessageW
DWORD __stdcall
WszFormatMessage(
                 DWORD      dwFlags,
                 LPCVOID    lpSource,
                 DWORD      dwMsgId,
                 DWORD      dwLangId,
                 LPWSTR     lpBuffer,
                 DWORD      nSize, 
                 va_list *  Args)
{
    BOOL fArgArray;                 // is Args an argument array?
    BOOL fAllocBuffer;              // does the caller expect the API to LocalAlloc lpBuffer?
    DWORD dwFlagsA;                 // "A" wrapper for dwFlags
    LPSTR lpSourceA;                // "A" wrapper for lpSource
    LPWSTR wzSource;                // "W" wrapper for lpSource that has been converted
    size_t cchSource;               // size needed for the alloc conversion of lpSource->lpSourceA
    va_list * ArgsA;                // "A" wrapper for Args
    DWORD RetVal;                   // the return value
    LPSTR szBuffer;                 // "A" wrapper for lpBuffer
    WCHAR* wzBuffer;                // "W" wrapper for the OS-alloc'ed lpBuffer
    ULONG rgpInserts[MAXINSERTS];   // our own argument array of inserts
    BYTE rgbString[MAXINSERTS];     // shadow array that indicates whether the arg is a string
    LPSTR rgszInserts=0;            // The actual strings rgpInserts points to
    LPWSTR lpszInsert;              // a single insert; the one we are working with at the moment
    UINT cbInsert;                  // bytes in an insert, possibly converted to ANSI
    UINT idxInsert;                 // index of the insert we are working on
    DWORD dwOffset;                 // offset inside of rgszInsert
    UINT cpg;                       // code page for the conversions, if any
    UINT cItems;                    // count of string inserts
    PVOID pBuffer;                  // our own private lpBuffer, used to get the no-insert version
    LPSTR pch;                      // used for character enumeration
    CHAR szNum[2];                  // used to convert insert indexes to numbers
    int iNum;                       // used to hold the converted insert

    if(g_bOnUnicodeBox)
        return  FormatMessageW(dwFlags, lpSource, dwMsgId, dwLangId, lpBuffer, nSize, Args);

#ifdef _WIN64
    _ASSERTE(false && L"g_bOnUnicodeBox should be true on IA64");
    return 0; //indicate failure
#else
    if(bFirstTimeWszFormatMessageCalled)//Win9xU.c did this initialization in DllMain, we'll do it like this since this is the only function
    {                                   //that uses these variables
        g_acp = GetACP();

        CPINFO CPInfo;
        GetCPInfo(g_acp, &CPInfo);
        g_mcs = CPInfo.MaxCharSize;

        bFirstTimeWszFormatMessageCalled = false;
    }

    fArgArray = (dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY);
    fAllocBuffer = (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER);    
    
    // Take care of code page issues, and handle lpSource
    if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
    {
        cpg = g_acp;
        GodotToAnsiAllocSafe(lpSource, lpSourceA, cchSource);
    }
    else
    {
        cpg = CpgFromLocale(dwLangId);
        CopyAsAtom(lpSourceA, lpSource);
    }

    // First lets take care of Args, if we need to
    if((Args == NULL) || (dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS))
    {
        // They passed in no args, so lets give them no Args!
        ArgsA = NULL;
        dwFlagsA = dwFlags;
    }
    else
    {
        // Ok, what we have to do here is call FormatMessage and ignore inserts
        // so we can get the unformatted string. We can use it to get arg counts
        // and find out which args are strings.
        dwFlagsA = (dwFlags | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER);
        pBuffer = NULL;
        RetVal = FormatMessageA(dwFlagsA,
                                lpSourceA,
                                dwMsgId,
                                dwLangId,
                                (char*)&pBuffer,
                                nSize,
                                NULL);
        if(RetVal == 0)
        {
            // We did not even make it THIS far; lets give up
            return(0);
        }

        cItems = 0;
        ZeroMemory(rgbString, (sizeof(BYTE) * (MAXINSERTS)));
        
        // Ok, pBuffer points to the string. Use it, filling rgfString
        // so we know whether each param is a string or not, and also
        // so we know the count
        for (pch = (LPSTR)pBuffer; *pch; pch++)
        {
            if (*pch == L'%')
            {
                pch++;
                // Found an insertion.  Get the digit or two.
                if (*pch == '0')
                    continue;       // "%0" is special

                // Ok, we have an item!
                cItems++;
                szNum[0] = '\0';
                szNum[1] = '\0';
                
                if (*pch < '0' || *pch > '9')
                {
                    // skip % followed by nondigit
                    continue;   
                }
                
                // Move one past the digit we just detected
                pch++;
                if (*pch >= '0' && *pch <= '9')
                {
                    // Move one past the optional second digit we just 
                    // detected and lets make those two digits a number
                    pch++;        
                    memcpy(szNum, pch - 2, (sizeof(CHAR) * 2));
                    iNum = gatoi(szNum);
                }
                else
                {
                    // Make that one string 'digit' a number
                    memcpy(szNum, pch-1, sizeof(CHAR));
                    iNum = gatoi(szNum);
                }
                    
                if (*pch != '!')
                {
                    // No optional type spec, so assume its a string
                    rgbString[iNum - 1]=1;
                    if(*pch == '\0')
                        break;
                    --pch;//This is to allow for "%1%2"
                }
                else
                {
                    // See "printf Type Field Characters" for details on our support here. Note that
                    // e, E, f, G, and g are not supported by FormatMessage, so everything we care about
                    // is either an int, UINT, or string of some type.

                    // Skip the exclamation point we detected
                    pch++;  

                    // We now have an explicit formatting char. 
                    if ((*pch == 'c') || (*pch == 'C') || (*pch == 's') || (*pch == 'S'))
                    {
                        rgbString[iNum - 1]=1;
                    }
                    else
                    {
                        rgbString[iNum - 1]=0;
                    }
                }
            }
        }

        //free the buffer now
        LocalFree(pBuffer);

        rgszInserts = reinterpret_cast<LPSTR>(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (CCHMAXPERINSERT * cItems)));
        if(rgszInserts == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return(0);
        }
        
        dwOffset = 0;

        // Note that we make no call to va_begin or va_end; if we do, then the API will
        // not be pointing to the right place. See Windows bug #307305 for details.

        for (idxInsert=0 ; idxInsert<cItems; idxInsert++)
        {
            // If this is an arg array, than treat Args like an array of LPWSTRs
            // and read the Args one at a time that way. Otherwise, use va_arg to
            // pick off the next item.
            if (fArgArray)
                lpszInsert = (LPWSTR)Args[idxInsert];
            else
                lpszInsert = va_arg(*Args, LPWSTR);

            if(rgbString[idxInsert]==1)
            {
                // Convert strings W->A
                cbInsert = WideCharToMultiByte(cpg, 
                                               0,
                                               lpszInsert, 
                                               -1,
                                               (LPSTR)(rgszInserts + dwOffset), 
                                               CCHMAXPERINSERT,
                                               NULL, 
                                               NULL);
            }
            else
            {
                // Copy the data, directly. No conversion needed 
                // (or even wanted)
                *reinterpret_cast<UINT *>(&rgszInserts + dwOffset) = (UINT)lpszInsert;
                cbInsert = sizeof(UINT);
            }

            if(cbInsert == 0)                                            
            {
                // The string was too long? Something failed.
                SetLastError(ERROR_OUTOFMEMORY);
                if(rgszInserts)
                    HeapFree(GetProcessHeap(), 0, rgszInserts);
                return(0);
            }
            rgpInserts[idxInsert] = (ULONG)(LPSTR)(rgszInserts + dwOffset);
            dwOffset += cbInsert;
        }
        // CONSIDER: Do we want to do a HeapReAlloc here? We currently allocate 
        //           (CCHMAXPERINSERT * cItems) characters worth of space in 
        //           rgszInserts but we only need dwOffset worth of memory. Not 
        //           sure if shrinking the buffer will be beneficial or not. It
        //           should never fail since we are shrinking, not growing.
        //if(dwOffset < CCHMAXPERINSERT)
        //  rgszInserts = (LPSTR)LocalReAlloc(rgszInserts, dwOffset+1, LMEM_MOVEABLE);

        // We are turning this into an argument array list, so set the flags that way
        dwFlagsA = dwFlags | FORMAT_MESSAGE_ARGUMENT_ARRAY;
        ArgsA = (va_list *)rgpInserts;
    }

    if (!fAllocBuffer)
    {
        // Must alloc szBuffer ourselves so we can then copy it to lpBuffer that the
        // caller has allocated
        szBuffer = reinterpret_cast<LPSTR>(_galloca((sizeof(WCHAR) * nSize)));
        RetVal=FormatMessageA(dwFlagsA, lpSourceA, dwMsgId, dwLangId, szBuffer, 
            (sizeof(WCHAR) * nSize), ArgsA);
    }
    else
    {
        // Must pass address of szBuffer so the API can fill it in. We will
        // then copy it to our own LocalAlloc'ed buffer and free the OS one.
        szBuffer = NULL;
        RetVal=FormatMessageA(dwFlagsA, lpSourceA, dwMsgId, dwLangId, (char*)&szBuffer, 
                              (sizeof(WCHAR) * nSize), ArgsA);
    }

    if (RetVal)
    {
        if (fAllocBuffer)
        { 
            // szBuffer contains a LocalAlloc'ed ptr to new string. lpBuffer is a
            // WCHAR** when FORMAT_MESSAGE_ALLOCATE_BUFFER is defined. To act like
            // the API, we LocalAlloc our own buffer for the caller.
            wzBuffer = (WCHAR*)LocalAlloc(NONZEROLPTR, (RetVal + 1) * sizeof(WCHAR));
            if(wzBuffer == NULL)
            {
                // CONSIDER: Return an error here? LocalAlloc should have already
                //           handled the GetLastError value, perhaps thats enough.
                RetVal = 0;
            }
            else
            {
                RetVal = GodotToUnicode(szBuffer, wzBuffer, RetVal+1);
            }

            // free up the buffer the API created, since we created our own for the user.
            LocalFree(szBuffer); 
            if (RetVal)
            {
                lpBuffer = wzBuffer;
                RetVal--;
            }
        }
        else
        { 
            // Just convert
            RetVal = MultiByteToWideChar(cpg, 0, szBuffer, RetVal, lpBuffer, nSize);
        }
        lpBuffer[RetVal] = L'\0';
        
    }
    else if (lpBuffer && 0 < nSize)
        *lpBuffer = L'\0';

    if(rgszInserts)
        HeapFree(GetProcessHeap(), 0, rgszInserts);
    return(RetVal);
#endif   
}

#if 0
//-----------------------------------------------------------------------------
// WszFormatMessage
//
// @func Loads a Resource String and converts it to unicode if
// need be.
//
// @rdesc Length of string (Ansi is cb) (UNICODE is cch)
// (Not including '\0'.)
//-----------------------------------------------------------------------------------
DWORD WszFormatMessage
    (
    DWORD   dwFlags,        // source and processing options 
    LPCVOID lpSource,       // pointer to  message source 
    DWORD   dwMessageId,    // requested message identifier 
    DWORD   dwLanguageId,   // language identifier for requested message 
    LPWSTR  lpBuffer,       // pointer to message buffer 
    DWORD   nSize,          // maximum size of message buffer 
    va_list *Arguments      // address of array of message inserts 
    )
{
    PSTR    pStr = NULL;
    DWORD   cbLen = 0;  
    ULONG   cchOut = 0;

    //@devnote: The only dwFlags supported are the following two
    // combinations
    //      FORMAT_MESSAGE_FROM_HMODULE
    //      FORMAT_MESSAGE_FROM_SYSTEM 
    // NOTE: ALLOCATE_BUFFER does not appear to work on WIN95.. 
//Stephenr - Not sure why then flags were limited in this way; but we need other flags than this; and it appears to work fine on Win98.
//    _ASSERTE( ((dwFlags & ~(FORMAT_MESSAGE_FROM_HMODULE))   == 0) ||
//              ((dwFlags & ~(FORMAT_MESSAGE_FROM_SYSTEM))    == 0) ;

    _ASSERTE( nSize >= 0 );

    if (g_bOnUnicodeBox)
        return  FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId, 
                    lpBuffer, nSize, Arguments);

    pStr = new CHAR[nSize];
    if( pStr )
    {
        cbLen = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId, 
                        (char*)pStr, nSize, Arguments);
        if( cbLen != 0 )
        {
            cbLen++;    //For '\0'

            cchOut = nSize;
            if( FAILED(WszConvertToUnicode(pStr, cbLen, &lpBuffer, 
                &cchOut, FALSE)) )
            {
                cchOut = 0;
            }
            else
                cchOut--;   // Decrement count to exclude '\0'
        }
    }
    delete[] pStr;

    // Return excludes null terminator
    return cchOut;
}
#endif //old WszFormatMessage - Remove this #if 0 before checking it in.

#if 0 // don't need this, use FullPath instead.
//-----------------------------------------------------------------------------
// WszFullPath
//
// @func Retrieves the absolute path from a relative path
//
// @rdesc If the function succeeds, the return value is the length, 
// in characters, of the string copied to the buffer.
//-----------------------------------------------------------------------------------
LPWSTR WszFullPath
    (
    LPWSTR      absPath,    //@parm INOUT | Buffer for absolute path 
    LPCWSTR     relPath,    //@parm IN | Relative path to convert
    ULONG       maxLength   //@parm IN | Maximum length of the absolute path name buffer 
    )
{
    PSTR    pszRel = NULL;
    PSTR    pszAbs = NULL;
    PWSTR   pwszReturn = NULL;

    if( g_bOnUnicodeBox ) 
        return _wfullpath( absPath, relPath, maxLength );

    // No Unicode Support
    pszAbs = new char[maxLength * DBCS_MAXWID];
    if( pszAbs )
    {
        if( FAILED(WszConvertToAnsi(relPath,
                          &pszRel, 0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        if( _fullpath(pszAbs, pszRel, maxLength * DBCS_MAXWID) )
        {
            if( SUCCEEDED(WszConvertToUnicode(pszAbs, -1, &absPath, 
                &maxLength, FALSE)) )
            {
                pwszReturn = absPath;
            }
        }


    }

Exit:
    delete[] pszRel;
    delete[] pszAbs;

    // Return 0 if error, else count of characters in buffer
    return pwszReturn;
}
#endif // 0 -- to knock out FullPath wrapper

DWORD
WszGetFullPathName(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )
{
    if (g_bOnUnicodeBox)
        return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);
    
    DWORD       rtn;
    int         iOffset;
    char        rcFileName[_MAX_PATH];
    LPSTR       szBuffer;
    LPSTR       szFilePart;
    CQuickBytes qbBuffer;

    szBuffer = (LPSTR) qbBuffer.Alloc(nBufferLength * 2);
    if (!szBuffer)
        return (0);
    Wsz_wcstombs(rcFileName, lpFileName, sizeof(rcFileName));
    
    rtn = GetFullPathNameA(rcFileName, nBufferLength * 2, szBuffer, &szFilePart);   
    if (rtn)
    {
        Wsz_mbstowcs(lpBuffer, szBuffer, nBufferLength);

        if (lpFilePart)
        {
            iOffset = MultiByteToWideChar(CP_ACP, 0, szBuffer, (int)(szFilePart - szBuffer),
                    NULL, 0);
            *lpFilePart = &lpBuffer[iOffset];
        }
    }
    else if (lpBuffer && nBufferLength)
        *lpBuffer = 0;
    return (rtn);
}



//-----------------------------------------------------------------------------
// WszSearchPath
//
// @func SearchPath for a given file name
//
// @rdesc If the function succeeds, the value returned is the length, in characters, 
//   of the string copied to the buffer, not including the terminating null character. 
//   If the return value is greater than nBufferLength, the value returned is the size 
//   of the buffer required to hold the path. 
//-----------------------------------------------------------------------------------
DWORD WszSearchPath
    (
    LPWSTR      wzPath,     // @parm IN | address of search path 
    LPWSTR      wzFileName, // @parm IN | address of filename 
    LPWSTR      wzExtension,    // @parm IN | address of extension 
    DWORD       nBufferLength,  // @parm IN | size, in characters, of buffer 
    LPWSTR      wzBuffer,       // @parm IN | address of buffer for found filename 
    LPWSTR      *pwzFilePart    // @parm OUT | address of pointer to file component 
    )
{

    PSTR    szPath = NULL;
    PSTR    szFileName = NULL;
    PSTR    szExtension = NULL;
    PSTR    szBuffer = NULL;
    PSTR    szFilePart = NULL;
    DWORD   dwRet = 0;
    ULONG   cCh, cChConvert;

    if( g_bOnUnicodeBox ) 
        return SearchPathW( wzPath, wzFileName, wzExtension, nBufferLength, wzBuffer, pwzFilePart);

    // No Unicode Support
    if( FAILED(WszConvertToAnsi(wzPath,
                            &szPath,
                            0,
                            NULL,
                            TRUE)) ||
        FAILED(WszConvertToAnsi(wzFileName,
                            &szFileName,
                            0,
                            NULL,
                            TRUE)) ||
        FAILED(WszConvertToAnsi(wzExtension,
                            &szExtension,
                            0,
                            NULL,
                            TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    szBuffer = new char[nBufferLength * DBCS_MAXWID];
	if (szBuffer == 0)
	{
		SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
	}

    dwRet = SearchPathA(szPath, szFileName, szExtension, nBufferLength * DBCS_MAXWID, szBuffer, 
        pwzFilePart ? &szFilePart : NULL);

    if (dwRet == 0) 
    {
        // SearchPathA failed
        goto Exit;
    }
    cCh = 0;
    cChConvert = nBufferLength;

    // to get the count of unicode character into buffer
    if( szFilePart )
    {
        // this won't trigger the conversion sinch cCh == 0
        cCh = (MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                0,                              
                                szBuffer,
                                (int) (szFilePart - szBuffer),
                                NULL,
                                0));
		_ASSERTE(cCh);
    }

    if( FAILED(WszConvertToUnicode(
            szBuffer, 
            dwRet > nBufferLength ? nBufferLength : -1, // if buffer is not big enough, we may not have NULL char
            &wzBuffer, 
            &cChConvert, 
            FALSE)) )
    {
        // fail in converting to Unicode
        dwRet = 0;
    }
    else 
    {
        dwRet = cChConvert;             // return the count of unicode character being converted
        if (pwzFilePart)
            *pwzFilePart = wzBuffer + cCh;  // update the pointer of the file part

    }
Exit:
    delete[] szPath;
    delete[] szFileName;
    delete[] szExtension;
    delete[] szBuffer;

    // Return 0 if error, else count of characters in buffer
    return dwRet;
}

//-----------------------------------------------------------------------------
// WszGetModuleFileName
//
// @func Retrieves the full path and filename for the executable file 
// containing the specified module. 
//
// @rdesc If the function succeeds, the return value is the length, 
// in characters, of the string copied to the buffer.
//-----------------------------------------------------------------------------------
DWORD WszGetModuleFileName
    (
    HMODULE hModule,        //@parm IN    | handle to module to find filename for 
    LPWSTR lpwszFilename,   //@parm INOUT | pointer to buffer for module path 
    DWORD nSize             //@parm IN    | size of buffer, in characters 
    )
{
    DWORD   dwVal = 0;
    PSTR    pszBuffer = NULL;

    if( g_bOnUnicodeBox ) 
        return GetModuleFileNameW(hModule, lpwszFilename, nSize);

    // No Unicode Support
    pszBuffer = new char[nSize * DBCS_MAXWID];
    if( pszBuffer )
    {
        dwVal = GetModuleFileNameA(hModule, pszBuffer, (nSize * DBCS_MAXWID));

        if( FAILED(WszConvertToUnicode(pszBuffer, -1, &lpwszFilename, &nSize, FALSE)) )
        {
            dwVal = 0;
            *lpwszFilename = L'\0';
        }

        delete[] pszBuffer;
    }

    // Return 0 if error, else count of characters in buffer
    return dwVal;
}


//-----------------------------------------------------------------------------
// WszGetPrivateProfileString
//
// @func Retrieve values from a profile file
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from GetPrivateProfileString,
// which is num chars copied, not including '\0'.
//-----------------------------------------------------------------------------------
DWORD WszGetPrivateProfileString
    (
    LPCWSTR     lpwszSection,
    LPCWSTR     lpwszEntry,
    LPCWSTR     lpwszDefault,
    LPWSTR      lpwszRetBuffer,
    DWORD       cchRetBuffer,       
    LPCWSTR     lpwszFile
    )   
{
    if (g_bOnUnicodeBox)
    {
        return GetPrivateProfileStringW(lpwszSection,
                                        lpwszEntry,
                                        lpwszDefault,
                                        lpwszRetBuffer,
                                        cchRetBuffer,
                                        lpwszFile);
    } else if (!lpwszRetBuffer || cchRetBuffer == 0)
    {
        return 0;
    } else
    {
        LPSTR   pszSection = NULL;
        LPSTR   pszEntry = NULL;
        LPSTR   pszDefault = NULL;
        LPWSTR  pwszRetBuffer = NULL;
        LPSTR   pszFile = NULL;
        DWORD   dwRet = 0;

        if( FAILED(WszConvertToAnsi(lpwszSection,
                            &pszSection,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszEntry,
                            &pszEntry,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszDefault,
                            &pszDefault,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszFile,
                            &pszFile,
                            0,
                            NULL,
                            TRUE)) ) 
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        dwRet = GetPrivateProfileStringA(pszSection,
                                    pszEntry,
                                    pszDefault,
                                    (LPSTR) lpwszRetBuffer,
                                    cchRetBuffer,
                                    pszFile);
        if (dwRet == 0)
        {
            *lpwszRetBuffer = L'\0';
        } else if( SUCCEEDED(WszConvertToUnicode((LPSTR) lpwszRetBuffer, 
                            -1, &pwszRetBuffer, &dwRet, TRUE)) )
        {
            // dwRet includes '\0'
            _ASSERTE(!dwRet || ( (LPSTR)lpwszRetBuffer)[dwRet-1] == '\0' );
            memcpy(lpwszRetBuffer, pwszRetBuffer, (dwRet) * sizeof(WCHAR)); 
            // We return count-of-char, not including '\0'.
            if (dwRet)
                dwRet--;
        } else
        {                       
            dwRet = 0;
        }
Exit:
        delete[] pszSection;
        delete[] pszEntry;
        delete[] pszDefault;
        delete[] pwszRetBuffer;
        delete[] pszFile;

        return dwRet;
    }   
}

//-----------------------------------------------------------------------------
// WszWritePrivateProfileString
//
// @func Write values to a profile file
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegSetValueEx
//-----------------------------------------------------------------------------------
BOOL WszWritePrivateProfileString
    (
    LPCWSTR     lpwszSection,
    LPCWSTR     lpwszKey,
    LPCWSTR     lpwszString,
    LPCWSTR     lpwszFile
    )
{
    if (g_bOnUnicodeBox)
    {
        return WritePrivateProfileStringW(lpwszSection,
                                        lpwszKey,
                                        lpwszString,
                                        lpwszFile);
    } else
    {
        LPSTR   pszSection = NULL;
        LPSTR   pszKey = NULL;
        LPSTR   pszString = NULL;
        LPSTR   pszFile = NULL;
        BOOL    fRet = FALSE;

        if( FAILED(WszConvertToAnsi(lpwszSection,
                            &pszSection,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszKey,
                            &pszKey,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszString,
                            &pszString,
                            0,
                            NULL,
                            TRUE)) ||
            FAILED(WszConvertToAnsi(lpwszFile,
                            &pszFile,
                            0,
                            NULL,
                            TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        fRet = WritePrivateProfileStringA(pszSection,
                                    pszKey,
                                    pszString,
                                    pszFile);
Exit:   
        delete[] pszSection;
        delete[] pszKey;
        delete[] pszString;
        delete[] pszFile;
        return fRet;
    }
}


//-----------------------------------------------------------------------------
// WszCreateFile
//
// @func CreateFile
//
// @rdesc File handle.
//-----------------------------------------------------------------------------------
HANDLE WszCreateFile(
    LPCWSTR pwszFileName,   // pointer to name of the file 
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile )  // handle to file with attributes to copy  
{
    LPSTR pszFileName = NULL;
    HANDLE hReturn;

    if ( g_bOnUnicodeBox )
        return CreateFileW( 
            pwszFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDistribution,
            dwFlagsAndAttributes,
            hTemplateFile );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszFileName,
                &pszFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        hReturn = INVALID_HANDLE_VALUE;
    }
    else
    {
        hReturn = CreateFileA( 
            pszFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDistribution,
            dwFlagsAndAttributes,
            hTemplateFile );
    }
    delete [] pszFileName;
    return hReturn;
}

//-----------------------------------------------------------------------------
// WszCopyFile
//
// @func CopyFile
//
// @rdesc TRUE if success
//-----------------------------------------------------------------------------------
BOOL WszCopyFile(
    LPCWSTR pwszExistingFileName,   // pointer to name of an existing file 
    LPCWSTR pwszNewFileName,    // pointer to filename to copy to 
    BOOL bFailIfExists )    // flag for operation if file exists 
{
    LPSTR pszExistingFileName = NULL;
    LPSTR pszNewFileName = NULL;
    BOOL  fReturn;

    if ( g_bOnUnicodeBox )
        return CopyFileW( pwszExistingFileName, pwszNewFileName, bFailIfExists );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszExistingFileName,
                &pszExistingFileName, 
                0, NULL, TRUE))
    ||   FAILED(WszConvertToAnsi( 
                pwszNewFileName,
                &pszNewFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fReturn = FALSE;
    }
    else
    {
        fReturn = CopyFileA( pszExistingFileName, pszNewFileName, bFailIfExists );
    }
    delete [] pszExistingFileName;
    delete [] pszNewFileName;
    return fReturn;
}
 
//-----------------------------------------------------------------------------
// WszMoveFileEx
//
// @func MoveFileEx
//
// @rdesc TRUE if success
//-----------------------------------------------------------------------------------
BOOL WszMoveFileEx(
    LPCWSTR pwszExistingFileName,   // address of name of the existing file  
    LPCWSTR pwszNewFileName,    // address of new name for the file 
    DWORD dwFlags )     // flag to determine how to move file 
{
    LPSTR pszExistingFileName = NULL;
    LPSTR pszNewFileName = NULL;
    BOOL  fReturn;

    // NOTE!  MoveFileExA is not implemented in Win95.
    // And MoveFile does *not* move a file; its function is really rename-a-file.
    // So for Win95 we have to do Copy+Delete.
    _ASSERTE( dwFlags == (MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED ));

    if ( g_bOnUnicodeBox )
        return MoveFileExW( pwszExistingFileName, pwszNewFileName, dwFlags );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszExistingFileName,
                &pszExistingFileName, 
                0, NULL, TRUE))
    ||   FAILED(WszConvertToAnsi( 
                pwszNewFileName,
                &pszNewFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fReturn = FALSE;
    }
    else
    {
        // Copy files, and overwrite existing.
        fReturn = CopyFileA( pszExistingFileName, pszNewFileName, FALSE );
        // Try to delete current one (irrespective of copy failures).
        DeleteFileA( pszExistingFileName );
    }
    delete [] pszExistingFileName;
    delete [] pszNewFileName;
    return fReturn;
}
 
//-----------------------------------------------------------------------------
// WszDeleteFile
//
// @func DeleteFile
//
// @rdesc TRUE if success
//-----------------------------------------------------------------------------------
BOOL WszDeleteFile(
    LPCWSTR pwszFileName )  // address of name of the existing file  
{
    LPSTR pszFileName = NULL;
    BOOL  fReturn;

    if ( g_bOnUnicodeBox )
        return DeleteFileW( pwszFileName );

    // Win95, so convert.
    if ( FAILED(WszConvertToAnsi( 
                pwszFileName,
                &pszFileName, 
                0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fReturn = FALSE;
    }
    else
    {
        fReturn = DeleteFileA( pszFileName );
    }
    delete [] pszFileName;
    return fReturn;
}
 

//-----------------------------------------------------------------------------
// WszRegOpenKeyEx
//
// @func Opens a registry key
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegOpenKeyEx
//-----------------------------------------------------------------------------
LONG WszRegOpenKeyEx
    (
    HKEY    hKey,
    LPCWSTR wszSub,
    DWORD   dwRes,
    REGSAM  sam,
    PHKEY   phkRes
    )
{
    LPSTR   szSub= NULL;
    LONG    lRet;

    if (g_bOnUnicodeBox)
        return  RegOpenKeyExW(hKey,wszSub,dwRes,sam,phkRes);

    if( FAILED(WszConvertToAnsi((LPWSTR)wszSub,
                      &szSub, 0, NULL, TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegOpenKeyExA(hKey,(LPCSTR)szSub,dwRes,sam,phkRes);

Exit:
    delete[] szSub;

    return lRet;
}


//-----------------------------------------------------------------------------
// WszRegEnumKeyEx
//
// @func Opens a registry key
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegOpenKeyEx
//-----------------------------------------------------------------------------------
LONG WszRegEnumKeyEx
    (
    HKEY        hKey,
    DWORD       dwIndex,
    LPWSTR      lpName,
    LPDWORD     lpcbName,
    LPDWORD     lpReserved,
    LPWSTR      lpClass,
    LPDWORD     lpcbClass,
    PFILETIME   lpftLastWriteTime
    )
{
    LONG    lRet = ERROR_NOT_ENOUGH_MEMORY;
    PSTR    szName = NULL, 
            szClass = NULL;

    if (g_bOnUnicodeBox)
        return RegEnumKeyExW(hKey, dwIndex, lpName,
                lpcbName, lpReserved, lpClass,
                lpcbClass, lpftLastWriteTime);
        

    // Sigh, it is win95

    if ((lpcbName) && (*lpcbName  > 0))
    {
        szName = new char[*lpcbName];
        if (!(szName))
        {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }

    }

    if ((lpcbClass) && (*lpcbClass > 0))
    {
        szClass = new char[*lpcbClass];
        if (!(szClass))
        {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }

    }

    lRet = RegEnumKeyExA(
            hKey,
            dwIndex,
            szName,
            lpcbName,
            lpReserved,
            szClass,
            lpcbClass,
            lpftLastWriteTime);


    if (lRet == ERROR_SUCCESS)
    {
        if (szName)
        {
            MultiByteToWideChar(    CP_ACP,     // XXX Consider: make any cp?
                                    0,                              
                                    szName,
                                    *lpcbName + 1,
                                    lpName,
                                    *lpcbName + 1);
        }

        if (szClass)
        {

            MultiByteToWideChar(    CP_ACP,     // XXX Consider: make any cp?
                                    0,                              
                                    szClass,
                                    *lpcbClass + 1,
                                    lpClass,
                                    *lpcbClass + 1);
        }
    }

Exit:
    delete[] szName;
    delete[] szClass;

    return  lRet;
}


//-----------------------------------------------------------------------------
// WszRegDeleteKey
//
// @func Delete a key from the registry
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegDeleteKey
//-----------------------------------------------------------------------------------
LONG WszRegDeleteKey
    (
    HKEY    hKey,
    LPCWSTR lpSubKey
    )
{
    LONG    lRet;
    LPSTR   szSubKey = NULL;

    if( g_bOnUnicodeBox )
        return RegDeleteKeyW(hKey,lpSubKey);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpSubKey,
                      &szSubKey, 0, NULL, TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegDeleteKeyA(hKey,szSubKey);

Exit:
    delete[] szSubKey;

    return lRet;
}



//-----------------------------------------------------------------------------
// WszRegSetValueEx
//
// @func Add a value to a registry key
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegSetValueEx
//-----------------------------------------------------------------------------------
LONG WszRegSetValueEx
    (
    HKEY        hKey,
    LPCWSTR     lpValueName,
    DWORD       dwReserved,
    DWORD       dwType,
    CONST BYTE  *lpData,
    DWORD       cbData
    )
{
    LPSTR   szValueName = NULL;
    LPSTR   szData = NULL;
    LONG    lRet;

    if (g_bOnUnicodeBox)
        return RegSetValueExW(hKey,lpValueName,dwReserved,dwType,lpData,cbData);

    // Win95, now convert

    if( FAILED(WszConvertToAnsi((LPWSTR)lpValueName,
                      &szValueName, 0, NULL, TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    switch (dwType)
    {
        case    REG_EXPAND_SZ:
        case    REG_MULTI_SZ:
        case    REG_SZ:
        {
            if( FAILED(WszConvertToAnsi((LPWSTR)lpData,
                              &szData, 0, NULL, TRUE)) )
            {
                lRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }
            lpData = (const BYTE *)(szData);
            cbData = cbData / sizeof(WCHAR);
        }
    }

    lRet =  RegSetValueExA(hKey,szValueName,dwReserved,dwType,lpData,cbData);

Exit:
    delete[] szValueName;
//@TODO Odbc DM does not free szData
    delete[] szData;

    return  lRet;
}

//-----------------------------------------------------------------------------
// WszRegCreateKeyEx
//
// @func Create a Registry key entry
//
// @rdesc ERROR_NOT_ENOUGH_MEMORY or return value from RegSetValueEx
//-----------------------------------------------------------------------------------
LONG WszRegCreateKeyEx
    (
    HKEY                    hKey,
    LPCWSTR                 lpSubKey,
    DWORD                   dwReserved,
    LPWSTR                  lpClass,
    DWORD                   dwOptions,
    REGSAM                  samDesired,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    PHKEY                   phkResult,
    LPDWORD                 lpdwDisposition
    )
{
    long    lRet = ERROR_NOT_ENOUGH_MEMORY;

    LPSTR   szSubKey = NULL, 
            szClass = NULL;

    if( g_bOnUnicodeBox )
        return RegCreateKeyExW(hKey,lpSubKey,dwReserved,lpClass,
                               dwOptions,samDesired,lpSecurityAttributes,
                               phkResult,lpdwDisposition);

    // Non Win95, now convert
    if( FAILED(WszConvertToAnsi((LPWSTR)lpSubKey,
                      &szSubKey,
                      0,        // max length ignored for alloc
                      NULL,
                      TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    if( FAILED(WszConvertToAnsi((LPWSTR)lpClass,
                      &szClass,
                      0,        // max length ignored for alloc
                      NULL,
                      TRUE)) )
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegCreateKeyExA(hKey,szSubKey,dwReserved,szClass,
                               dwOptions,samDesired,lpSecurityAttributes,
                               phkResult,lpdwDisposition);


Exit:
    delete[] szSubKey;
    delete[] szClass;

    return  lRet;
}


LONG WszRegQueryValue(HKEY hKey, LPCWSTR lpSubKey,
    LPWSTR lpValue, PLONG lpcbValue)
{
    long    lRet = ERROR_NOT_ENOUGH_MEMORY;

    LPSTR   szSubKey = NULL;
    LPSTR   szValue = NULL;

    if( g_bOnUnicodeBox )
        return RegQueryValueW(hKey, lpSubKey, lpValue, lpcbValue);

    if ((lpcbValue) && (*lpcbValue) && 
        ((szValue = new char[*lpcbValue]) == NULL))
        return (ERROR_NOT_ENOUGH_MEMORY);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpSubKey,
                      &szSubKey,
                      0,        // max length ignored for alloc
                      NULL,
                      TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    if ((lRet = RegQueryValueA(hKey, szSubKey, 
                szValue, lpcbValue)) != ERROR_SUCCESS)
        goto Exit;

    // convert output to unicode.
    if ((lpcbValue) && (lpValue) && (szValue))
        VERIFY(MultiByteToWideChar(CP_ACP, 0, szValue, -1, lpValue, *lpcbValue));
    lRet = ERROR_SUCCESS;

Exit:
    delete[] szSubKey;
    delete[] szValue;
    return  lRet;
}

LONG WszRegDeleteValue(HKEY hKey, LPCWSTR lpValueName)
{
    LONG    lRet;
    LPSTR   szValueName = NULL;

    if (g_bOnUnicodeBox)
        return RegDeleteValueW(hKey, lpValueName);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpValueName, &szValueName, 0, NULL, 
        TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegDeleteValueA(hKey, szValueName);

Exit:
    delete[] szValueName;

    return lRet;
}

LONG WszRegLoadKey(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
{
    LONG    lRet;
    LPSTR   szSubKey = NULL;
    LPSTR   szFile = NULL;

    if (g_bOnUnicodeBox)
        return RegLoadKeyW(hKey, lpSubKey, lpFile);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpSubKey, &szSubKey, 0, NULL, TRUE)) || 
        FAILED(WszConvertToAnsi((LPWSTR)lpFile, &szFile, 0, NULL, TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegLoadKeyA(hKey, szSubKey, szFile);

Exit:
    delete[] szSubKey;
    delete[] szFile;

    return lRet;
}

LONG WszRegUnLoadKey(HKEY hKey, LPCWSTR lpSubKey)
{
    LONG    lRet;
    LPSTR   szSubKey = NULL;

    if (g_bOnUnicodeBox)
        return RegUnLoadKeyW(hKey, lpSubKey);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpSubKey, &szSubKey, 0, NULL, TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegUnLoadKeyA(hKey, szSubKey);

Exit:
    delete[] szSubKey;

    return lRet;
}

LONG WszRegRestoreKey(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
{
    LONG    lRet;
    LPSTR   szFile = NULL;

    if (g_bOnUnicodeBox)
        return RegRestoreKeyW(hKey, lpFile, dwFlags);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpFile, &szFile, 0, NULL, TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegRestoreKeyA(hKey, szFile, dwFlags);

Exit:
    delete[] szFile;

    return lRet;
}

LONG WszRegReplaceKey(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile,
    LPCWSTR lpOldFile)
{
    LONG    lRet;
    LPSTR   szSubKey  = NULL;
    LPSTR   szNewFile = NULL;
    LPSTR   szOldFile = NULL;

    if (g_bOnUnicodeBox)
        return RegReplaceKeyW(hKey, lpSubKey, lpNewFile, lpOldFile);

    if (FAILED(WszConvertToAnsi((LPWSTR)lpSubKey,  &szSubKey,  0, NULL, TRUE))||
        FAILED(WszConvertToAnsi((LPWSTR)lpNewFile, &szNewFile, 0, NULL, TRUE))||
        FAILED(WszConvertToAnsi((LPWSTR)lpOldFile, &szOldFile, 0, NULL, TRUE)))
    {
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    lRet = RegReplaceKeyA(hKey, szSubKey, szNewFile, szOldFile);

Exit:
    delete[] szSubKey;
    delete[] szNewFile;
    delete[] szOldFile;

    return lRet;
}

LONG WszRegQueryInfoKey(HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass,
    LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime)
{
    LONG    lRet;
    LPSTR   szClass = NULL;

    if (g_bOnUnicodeBox)
        return RegQueryInfoKeyW(hKey, lpClass, lpcbClass, lpReserved, 
            lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, 
            lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor,
            lpftLastWriteTime);

    if ((lpcbClass) && (*lpcbClass) && 
        ((szClass = new char[*lpcbClass]) == NULL))
        return (ERROR_NOT_ENOUGH_MEMORY);

    if ((lRet = RegQueryInfoKeyA(hKey, szClass, lpcbClass, lpReserved, 
            lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, 
            lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor,
            lpftLastWriteTime)) != ERROR_SUCCESS)
        goto Exit;

    // convert output to unicode.
    if ((lpcbClass) && (lpClass) && (szClass))
        VERIFY(MultiByteToWideChar(CP_ACP, 0, szClass, -1, lpClass, *lpcbClass));
    lRet = ERROR_SUCCESS;

Exit:
    delete[] szClass;

    return lRet;
}

LONG WszRegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName,
    LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
    LPDWORD lpcbData)
{
    LONG    lRet;
    LPSTR   szValueName = NULL;

    if (g_bOnUnicodeBox)
        return RegEnumValueW(hKey, dwIndex, lpValueName, lpcbValueName, 
            lpReserved, lpType, lpData, lpcbData);

    if ((lpcbValueName) && (*lpcbValueName) && 
        ((szValueName = new char[*lpcbValueName]) == NULL))
        return (ERROR_NOT_ENOUGH_MEMORY);

    if ((lRet = RegEnumValueA(hKey, dwIndex, szValueName, lpcbValueName, 
            lpReserved, lpType, lpData, lpcbData)) != ERROR_SUCCESS)
        goto Exit;

    // convert output to unicode.
    if ((lpcbValueName) && (lpValueName) && (szValueName))
        VERIFY(MultiByteToWideChar(CP_ACP, 0, szValueName, -1, lpValueName, *lpcbValueName));
    lRet = ERROR_SUCCESS;

Exit:
    delete[] szValueName;

    return lRet;
}


//
// Helper for RegQueryValueEx. Called when the wrapper (a) knows the contents are a REG_SZ and
// (b) knows the size of the ansi string (passed in as *lpcbData).
//
__inline
LONG _WszRegQueryStringSizeEx(HKEY hKey, LPSTR szValueName, LPDWORD lpReserved, LPDWORD lpcbData)
{
	LONG lRet = ERROR_SUCCESS;

	_ASSERTE(lpcbData != NULL);

#ifdef _RETURN_EXACT_SIZE
	DWORD dwType = REG_SZ;

	// The first buffer was not large enough to contain the ansi.
	// Create another with the exact size.
	LPSTR szValue = (LPSTR)_alloca(*lpcbData);
	if (szValue == NULL)
		goto Exit;
	
	// Try to get the value again. This time it should succeed.
	lRet = RegQueryValueExA(hKey, szValueName, lpReserved, &dwType, (BYTE*)szValue, lpcbData);
	if (lRet != ERROR_SUCCESS)
	{
		_ASSERTE(!"Unexpected failure when accessing registry.");
		return lRet;
	}
	
	// With the ansi version in hand, figure out how many characters are
	// required to convert to unicode.
	DWORD cchRequired = MultiByteToWideChar(CP_ACP, 0, szValue, -1, NULL, 0);
	if (cchRequired == 0)
		return GetLastError();
	
	// Return the number of bytes needed for the unicode string.
	_ASSERTE(lRet == ERROR_SUCCESS);
	_ASSERTE(cchRequired * sizeof(WCHAR) > *lpcbData);
	*lpcbData = cchRequired * sizeof(WCHAR);
#else
	// Return a conservative approximation. In the english case, this value
	// is actually the exact value. In other languages, it might be an over-
	// estimate.
	*lpcbData *= 2;
#endif

	return lRet;
}

//
// Helper for RegQueryValueEx. Called when a null data pointer is passed
// to the wrapper. Returns the buffer size required to hold the contents
// of the registry value.
//
__inline
LONG _WszRegQueryValueSizeEx(HKEY hKey, LPSTR szValueName, LPDWORD lpReserved,
							 LPDWORD lpType, LPDWORD lpcbData)
{
	_ASSERTE(lpType != NULL);

	LONG lRet = RegQueryValueExA(hKey, szValueName, lpReserved, lpType, NULL, lpcbData);
	
	// If the type is not a string or if the value size is 0,
	// then no conversion is necessary. The type and size values are set
	// as required.
	if (*lpType != REG_SZ || lRet != ERROR_SUCCESS || *lpcbData == 0)
		return lRet;
	
#ifdef _RETURN_EXACT_SIZE
	// To return the proper size required for a unicode string,
	// we need to fetch the value and do the conversion ourselves.
	// There is not necessarily a 1:2 mapping of size from Ansi to
	// unicode (e.g. Chinese).
	
	// Allocate a buffer for the ansi string.
	szValue = (LPSTR)_alloca(*lpcbData);
	if (szValue == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;
	
	// Get the ansi string from the registry.
	lRet = RegQueryValueExA(hKey, szValueName, lpReserved, lpType, (BYTE*)szValue, lpcbData);
	if (lRet != ERROR_SUCCESS) // this should pass, but check anyway
	{
		_ASSERTE(!"Unexpected failure when accessing registry.");
		return lRet;
	}
	
	// Get the number of wchars required to convert to unicode.
	DWORD cchRequired = MultiByteToWideChar(CP_ACP, 0, szValue, -1, NULL, 0);
	if (cchRequired == 0)
		return GetLastError();
	
	// Calculate the number of bytes required for unicode.
	*lpcbData = cchRequired * sizeof(WCHAR);
#else
	// Return a conservative approximation. In the english case, this value
	// is actually the exact value. In other languages, it might be an over-
	// estimate.
	*lpcbData *= 2;
#endif

	return lRet;
}

//
// Wrapper for RegQueryValueEx that is optimized for retrieving
// string values. (Less copying of buffers than other wrapper.)
//
LONG WszRegQueryStringValueEx(HKEY hKey, LPCWSTR lpValueName,
						  	  LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
							  LPDWORD lpcbData)
{
	if (g_bOnUnicodeBox)
		return RegQueryValueExW(hKey, lpValueName,
								lpReserved, lpType, lpData, lpcbData);

	LPSTR	szValueName = NULL;
	LPSTR	szValue = NULL;
	DWORD	dwType = 0;
	LONG	lRet = ERROR_NOT_ENOUGH_MEMORY;


	// We care about the type, so if the caller doesn't care, set the
	// type parameter for our purposes.
	if (lpType == NULL)
		lpType = &dwType;

	// Convert the value name.
	if (FAILED(WszConvertToAnsi(lpValueName, &szValueName, 0, NULL, TRUE)))
		goto Exit;

	// Case 1:
	// The data pointer is null, so the caller is querying for size or type only.
	if (lpData == NULL)
	{
		lRet = _WszRegQueryValueSizeEx(hKey, szValueName, lpReserved, lpType, lpcbData);
	}
	// Case 2:
	// The data pointer is not null, so fill the buffer if possible,
	// or return an error condition.
	else
	{
		_ASSERTE(lpcbData != NULL && "Non-null buffer passed with null size pointer.");

		// Create a new buffer on the stack to hold the registry value.
		// The buffer is twice as big as the unicode buffer to guarantee that
		// we can retrieve any ansi string that will fit in the unicode buffer
		// after it is converted.
		DWORD dwValue = *lpcbData * 2;
		szValue = (LPSTR)_alloca(dwValue);
		if (szValue == NULL)
			goto Exit;

		// Get the registry contents.
		lRet = RegQueryValueExA(hKey, szValueName, lpReserved, lpType, (BYTE*)szValue, &dwValue);
		if (lRet != ERROR_SUCCESS)
		{
			if ((*lpType == REG_SZ || *lpType == REG_EXPAND_SZ || *lpType == REG_MULTI_SZ) 
				&& (lRet == ERROR_NOT_ENOUGH_MEMORY || lRet == ERROR_MORE_DATA))
			{
				lRet = _WszRegQueryStringSizeEx(hKey, szValueName, lpReserved, &dwValue);
				if (lRet == ERROR_SUCCESS)
					lRet = ERROR_NOT_ENOUGH_MEMORY;

				*lpcbData = dwValue;
			}

			goto Exit;
		}

		// If the result is not a string, then no conversion is necessary.
		if (*lpType != REG_SZ && *lpType != REG_EXPAND_SZ && *lpType != REG_MULTI_SZ)
		{
			if (dwValue > *lpcbData)
			{
				// Size of data is bigger than the caller's buffer,
				// so return the appropriate error code.
				lRet = ERROR_NOT_ENOUGH_MEMORY;
			}
			else
			{
				// Copy the data from the temporary buffer to the caller's buffer.
				memcpy(lpData, szValue, dwValue);
			}

			// Set the output param for the size of the reg value.
			*lpcbData = dwValue;
			goto Exit;
		}

		// Now convert the ansi string into the unicode buffer.
		DWORD cchConverted = MultiByteToWideChar(CP_ACP, 0, szValue, dwValue, (LPWSTR)lpData, *lpcbData / sizeof(WCHAR));
		if (cchConverted == 0)
		{
#ifdef _RETURN_EXACT_SIZE
			// The retrieved ansi string is too large to convert into the caller's buffer, but we
			// know what the string is, so call conversion again to get exact wchar count required.
			*lpcbData = MultiByteToWideChar(CP_ACP, 0, szValue, dwValue, NULL, 0) * sizeof(WCHAR);
#else
			// Return a conservative estimate of the space required.
			*lpcbData = dwValue * 2;
#endif
			lRet = ERROR_NOT_ENOUGH_MEMORY;
		}
		else
		{
			// Everything converted OK. Set the number of bytes retrieved and return success.
			*lpcbData = cchConverted * sizeof(WCHAR);
			_ASSERTE(lRet == ERROR_SUCCESS);
		}
	}

Exit:
	delete[] szValueName;
	return lRet;
}

//
// Default wrapper for RegQueryValueEx
//
LONG WszRegQueryValueEx(HKEY hKey, LPCWSTR lpValueName,
    LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
    LPDWORD lpcbData)
{
	long	lRet = ERROR_NOT_ENOUGH_MEMORY;
	LPSTR	szValueName = NULL;
	LPSTR	szValue = NULL;
	DWORD	dwType;
	DWORD	dwBufSize;

	if( g_bOnUnicodeBox )
		return RegQueryValueExW(hKey, lpValueName,
				lpReserved, lpType, lpData, lpcbData);

	// Convert the value name.
    if( FAILED(WszConvertToAnsi((LPWSTR)lpValueName,
				                &szValueName,
							    0,        // max length ignored for alloc
								NULL,
								TRUE)) )
        goto Exit;

	// We care about the type, so if the caller doesn't care, set the
	// type parameter for our purposes.
	if (lpType == NULL)
		lpType = &dwType;

	// Case 1:
	// The data pointer is null, so the caller is querying for size or type only.
	if (lpData == NULL)
	{
		lRet = _WszRegQueryValueSizeEx(hKey, szValueName, lpReserved, lpType, lpcbData);
	}
	// Case 2:
	// The data pointer is not null, so fill the buffer if possible,
	// or return an error condition.
	else
	{
		_ASSERTE(lpcbData != NULL && "Non-null buffer passed with null size pointer.");
		dwBufSize = *lpcbData;

		// Try to get the value from the registry.
		lRet = RegQueryValueExA(hKey, szValueName,
			lpReserved, lpType, lpData, lpcbData);
		
		// Check for error conditions...
		if (lRet != ERROR_SUCCESS)
		{
			if ( (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ || *lpType == REG_MULTI_SZ) 
				  && (lRet == ERROR_NOT_ENOUGH_MEMORY || lRet == ERROR_MORE_DATA))
			{
				// The error is that we don't have enough room, even for the ansi
				// version, so call the helper to set the buffer requirements to
				// successfully retrieve the value.
				lRet = _WszRegQueryStringSizeEx(hKey, szValueName, lpReserved, lpcbData);
				if (lRet == ERROR_SUCCESS)
					lRet = ERROR_NOT_ENOUGH_MEMORY;
			}
			goto Exit;
		}
		
		// If the returned value is a string, then we need to do some special handling...
		if (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ || *lpType == REG_MULTI_SZ)
		{
			// First get the size required to convert the ansi string to unicode.
			DWORD dwAnsiSize = *lpcbData;
			DWORD cchRequired = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpData, dwAnsiSize, NULL, 0);
			if (cchRequired == 0)
			{
				lRet = GetLastError();
				goto Exit;
			}
			
			// Set the required size in the output parameter.
			*lpcbData = cchRequired * sizeof(WCHAR);

			if (dwBufSize < *lpcbData)
			{
				// If the caller didn't pass in enough space for the
				// unicode version, then return appropriate error.
				lRet = ERROR_NOT_ENOUGH_MEMORY;
				goto Exit;
			}
			
			// At this point we know that the caller passed in enough
			// memory to hold the unicode version of the string.

			// Allocate buffer in which to copy ansi version.
			szValue = (LPSTR)_alloca(dwAnsiSize);
			if (szValue == NULL)
			{
				lRet = ERROR_NOT_ENOUGH_MEMORY;
				goto Exit;
			}
			
			// Copy the ansi version into a buffer.
			memcpy(szValue, lpData, dwAnsiSize);

			// Convert ansi to unicode.
			VERIFY(MultiByteToWideChar(CP_ACP, 0, szValue, dwAnsiSize, (LPWSTR) lpData, dwBufSize / sizeof(WCHAR)));
		}
		
		lRet = ERROR_SUCCESS;
	}
Exit:
    delete[] szValueName;
    return  lRet;
}

//*****************************************************************************
// Delete a registry key and subkeys.
//*****************************************************************************
DWORD WszRegDeleteKeyAndSubKeys(        // Return code.
    HKEY        hStartKey,              // The key to start with.
    LPCWSTR     wzKeyName)              // Subkey to delete.
{
    DWORD       dwRtn, dwSubKeyLength;      
    CQuickBytes qbSubKey;
    DWORD       dwMaxSize = CQUICKBYTES_BASE_SIZE / sizeof(WCHAR);
    HKEY        hKey;

    qbSubKey.ReSize(dwMaxSize * sizeof(WCHAR));

    // do not allow NULL or empty key name
    if (wzKeyName &&  wzKeyName[0] != '\0')     
    {
        if((dwRtn=WszRegOpenKeyEx(hStartKey, wzKeyName,
             0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey)) == ERROR_SUCCESS)
        {
            while (dwRtn == ERROR_SUCCESS)
            {
                dwSubKeyLength = dwMaxSize;
                dwRtn = WszRegEnumKeyEx(                        
                               hKey,
                               0,       // always index zero
                               (WCHAR *)qbSubKey.Ptr(),
                               &dwSubKeyLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

                // buffer is not big enough
                if (dwRtn == ERROR_SUCCESS && dwSubKeyLength >= dwMaxSize)
                {
                    // make sure there is room for NULL terminating
                    dwMaxSize = dwSubKeyLength + 1;
                    qbSubKey.ReSize(dwMaxSize * sizeof(WCHAR));
                    dwRtn = WszRegEnumKeyEx(                        
                                   hKey,
                                   0,       // always index zero
                                   (WCHAR *)qbSubKey.Ptr(),
                                   &dwSubKeyLength,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
                    _ASSERTE(dwSubKeyLength < dwMaxSize);

                }

                if  (dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = WszRegDeleteKey(hStartKey, wzKeyName);
                    break;
                }
                else if (dwRtn == ERROR_SUCCESS)
                    dwRtn = WszRegDeleteKeyAndSubKeys(hKey, (WCHAR *)qbSubKey.Ptr());
            }
            
            RegCloseKey(hKey);
            // Do not save return code because error
            // has already occurred
        }
    }
    else
        dwRtn = ERROR_BADKEY;
    
    return (dwRtn);
}

//----------------------------------------------------------------------------
//WszExpandEnvironmentStrings
//----------------------------------------------------------------------------
DWORD 
WszExpandEnvironmentStrings( LPCWSTR lpSrc,LPWSTR lpDst, DWORD nSize )
{
	if (g_bOnUnicodeBox)
        return ExpandEnvironmentStringsW( lpSrc, lpDst, nSize );

	LPSTR szSrc = NULL, szDst = NULL;
	DWORD dwRet = 0, cch = nSize;

	if( FAILED(WszConvertToAnsi((LPWSTR)lpSrc,
                      &szSrc, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return 0;
    }

	if ( 0 == nSize || NULL == lpDst )
	{
	// BUGBUG: ExpandEnvironmentStringsA(szSrc, 0, 0) on Win95 does
	// not return reqd size.
		CHAR    szDstStatic[MAX_PATH];
		dwRet = ExpandEnvironmentStringsA( szSrc, szDstStatic, MAX_PATH );
	}
	else
	{
		szDst = new CHAR[nSize];
		if ( szDst )
		{
			dwRet = ExpandEnvironmentStringsA( szSrc, szDst, nSize );
			if ( dwRet && (dwRet <= nSize) && FAILED( WszConvertToUnicode( szDst, dwRet, &lpDst, &cch, FALSE ) ) )
				dwRet = 0;

			delete [] szDst;
		}
	}

	delete [] szSrc;
	return dwRet;
	
}

//----------------------------------------------------------------------------
//WszGetWindowsDirectory
//----------------------------------------------------------------------------
UINT WszGetWindowsDirectory( LPWSTR lpBuffer, UINT uSize )
{
	if (g_bOnUnicodeBox)
		return GetWindowsDirectoryW( lpBuffer, uSize );

	UINT uRet=0;
	LPSTR szBuffer = NULL;
	ULONG cch = (ULONG)uSize;

	szBuffer = new CHAR[uSize];
	if ( szBuffer )
	{
		uRet = GetWindowsDirectoryA( szBuffer, uSize );
		if ( uRet && (uRet <= uSize) && FAILED( WszConvertToUnicode( szBuffer, uSize, &lpBuffer, &cch, FALSE ) ) )
			uRet = 0;

		delete [] szBuffer;
	}

	return uRet;
}

//----------------------------------------------------------------------------
//WszGetSystemDirectory
//----------------------------------------------------------------------------
UINT WszGetSystemDirectory( LPWSTR lpBuffer, UINT uSize )
{
	// GetSystemDirectory uSize parameter should be at least MAX_PATH (see documentation)
	ASSERT (uSize >= MAX_PATH); 

	if (g_bOnUnicodeBox)
		return GetSystemDirectoryW( lpBuffer, uSize );

	UINT uRet=0;
	LPSTR szBuffer = NULL;
	ULONG cch = (ULONG)uSize;

	szBuffer = new CHAR[uSize];
	if ( szBuffer )
	{
		uRet = GetSystemDirectoryA( szBuffer, uSize );
		if ( uRet && (uRet <= uSize) && FAILED( WszConvertToUnicode( szBuffer, uSize, &lpBuffer, &cch, FALSE ) ) )
			uRet = 0;

		delete [] szBuffer;
	}

	return uRet;
}
//----------------------------------------------------------------------------
//WszFindFirstFile
//----------------------------------------------------------------------------
HANDLE
WszFindFirstFile( LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData )
{
	if (g_bOnUnicodeBox)
		return FindFirstFileW( lpFileName, lpFindFileData );

	HANDLE hRet = NULL;
	LPSTR szFileName = NULL;
	WIN32_FIND_DATAA sFileDataA;

	if( FAILED(WszConvertToAnsi((LPWSTR)lpFileName,
                      &szFileName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return INVALID_HANDLE_VALUE;
    }

	hRet = FindFirstFileA( szFileName,&sFileDataA );
	if ( hRet != INVALID_HANDLE_VALUE )
	{
		memcpy ( lpFindFileData, &sFileDataA, offsetof(WIN32_FIND_DATAA, cFileName) );
		ULONG cch1 = MAX_PATH, cch2 = 14;
		LPWSTR wsz1 = lpFindFileData->cFileName, wsz2 = lpFindFileData->cAlternateFileName;
		if ( FAILED( WszConvertToUnicode( sFileDataA.cFileName, -1, &wsz1, &cch1, FALSE ) )|| 
			FAILED( WszConvertToUnicode( sFileDataA.cAlternateFileName, -1, &wsz2, &cch2, FALSE ) ) )
			
			hRet = INVALID_HANDLE_VALUE;
	}

	delete [] szFileName;

	return hRet;
}


//----------------------------------------------------------------------------
//WszFindNextFile
//----------------------------------------------------------------------------
BOOL 
WszFindNextFile( HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData )
{
	if (g_bOnUnicodeBox)
		return FindNextFileW ( hFindFile, lpFindFileData );

	WIN32_FIND_DATAA sFileDataA;

	if ( FindNextFileA( hFindFile, &sFileDataA ) )
	{
		memcpy ( lpFindFileData, &sFileDataA, offsetof(WIN32_FIND_DATAA, cFileName) );
		ULONG cch1 = MAX_PATH, cch2 = 14;
		LPWSTR wsz1 = lpFindFileData->cFileName, wsz2 = lpFindFileData->cAlternateFileName;
		if ( SUCCEEDED( WszConvertToUnicode( sFileDataA.cFileName, -1, &wsz1, &cch1, FALSE ) )|| 
			SUCCEEDED( WszConvertToUnicode( sFileDataA.cAlternateFileName, -1, &wsz2, &cch2, FALSE ) ) )

			return TRUE;
	}
		
	return FALSE;	
}

//----------------------------------------------------------------------------
//Wszlstrcmpi
//----------------------------------------------------------------------------
int Wszlstrcmpi( LPCWSTR lpString1,LPCWSTR lpString2 )
{
	if (g_bOnUnicodeBox)
		return lstrcmpiW( lpString1, lpString2 );

	LPSTR szStr1 = NULL, szStr2 = NULL;
	int iRet = 0;

	if ( FAILED(WszConvertToAnsi((LPWSTR)lpString1, &szStr1, 0, NULL, TRUE)) 
		|| FAILED(WszConvertToAnsi((LPWSTR)lpString2, &szStr2, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return 0;
    }
	
	iRet = lstrcmpiA( szStr1, szStr2 );

	delete [] szStr1;
	delete [] szStr2;
	return iRet;
}

//----------------------------------------------------------------------------
//Wszlstrcmp
//----------------------------------------------------------------------------
int Wszlstrcmp( LPCWSTR lpString1,LPCWSTR lpString2 )
{
	if (g_bOnUnicodeBox)
		return lstrcmpW( lpString1, lpString2 );

	ULONG cch1 = lstrlenW(lpString1)+1;
	ULONG cch2 = lstrlenW(lpString2)+1;

	ULONG cch = cch1 > cch2 ? cch2 : cch1;

	return memcmp(lpString1, lpString2, cch*sizeof(WCHAR));

}

//----------------------------------------------------------------------------
//WszCreateDirectory
//----------------------------------------------------------------------------
BOOL WszCreateDirectory( LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes )
{
	if (g_bOnUnicodeBox)
		return CreateDirectoryW( lpPathName, lpSecurityAttributes );

	LPSTR szPathName = NULL;
	BOOL bRet = FALSE;

	if ( FAILED( WszConvertToAnsi((LPWSTR)lpPathName, &szPathName, 0, NULL, TRUE) ) )
	{
		SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

	bRet = CreateDirectoryA( szPathName, lpSecurityAttributes );

	delete [] szPathName;
	return bRet;
}

//----------------------------------------------------------------------------
//WszMoveFile
//----------------------------------------------------------------------------
BOOL WszMoveFile( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName )
{
	if (g_bOnUnicodeBox)
		return MoveFileW( lpExistingFileName, lpNewFileName );

	LPSTR szExisting = NULL, szNew = NULL;
	BOOL bRet = FALSE;

	if ( FAILED( WszConvertToAnsi((LPWSTR)lpExistingFileName, &szExisting, 0, NULL, TRUE) ) ||
		 FAILED( WszConvertToAnsi((LPWSTR)lpNewFileName, &szNew, 0, NULL, TRUE) ) )
	{
		SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

	bRet = MoveFileA( szExisting, szNew );
	
	delete [] szExisting;
	delete [] szNew;
	
	return bRet;
}

//----------------------------------------------------------------------------
//WszGetFileAttributesEx
//----------------------------------------------------------------------------
BOOL WszGetFileAttributesEx(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
	)
{
	BOOL bRet = FALSE;

	if (g_bOnUnicodeBox)
    {
        typedef BOOL (__stdcall * GETFILEATTRIBUTESEXW)(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
        static GETFILEATTRIBUTESEXW pfnGetFileAttributesExW = 0;

        if(0 == pfnGetFileAttributesExW)
        {
            HINSTANCE hKernel32 = LoadLibraryA("kernel32.dll");
            pfnGetFileAttributesExW = reinterpret_cast<GETFILEATTRIBUTESEXW>(GetProcAddress(hKernel32, "GetFileAttributesExW"));//GetProcAddress tolerates NULL instance handles
            FreeLibrary(hKernel32);

            if(0 == pfnGetFileAttributesExW)
            {
                SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
                return 0;
            }
        }
    	bRet = pfnGetFileAttributesExW( lpFileName, fInfoLevelId, lpFileInformation );
    }
    else
    {
        typedef BOOL (__stdcall * GETFILEATTRIBUTESEXA)(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
        static GETFILEATTRIBUTESEXA pfnGetFileAttributesExA = 0;

        if(0 == pfnGetFileAttributesExA)
        {
            HINSTANCE hKernel32 = LoadLibraryA("kernel32.dll");
            pfnGetFileAttributesExA = reinterpret_cast<GETFILEATTRIBUTESEXA>(GetProcAddress(hKernel32, "GetFileAttributesExA"));//GetProcAddress tolerates NULL instance handles
            FreeLibrary(hKernel32);

            if(0 == pfnGetFileAttributesExA)
            {
                SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
                return 0;
            }
        }

	    LPSTR szFileName = NULL;

	    if ( FAILED( WszConvertToAnsi((LPWSTR)lpFileName, &szFileName, 0, NULL, TRUE) ) )
	    {
		    SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

    	bRet = pfnGetFileAttributesExA( szFileName, fInfoLevelId, lpFileInformation );

    	delete [] szFileName;
    }
	return bRet;
}

//----------------------------------------------------------------------------
//Wszlstrcpy
//----------------------------------------------------------------------------
LPWSTR
Wszlstrcpy( LPWSTR lpString1, LPCWSTR lpString2)
{
	if (g_bOnUnicodeBox)
		return lstrcpyW( lpString1, lpString2 );

	if ( 0 == lpString1 || 0 == lpString2)
		return NULL;

	LPWSTR wszRet = lpString1;

	while (*lpString1++ = *lpString2++);

	return wszRet;
}


//----------------------------------------------------------------------------
//Wszlstrcpyn
//----------------------------------------------------------------------------
LPWSTR
Wszlstrcpyn( LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
{
	if (g_bOnUnicodeBox)
		return lstrcpynW( lpString1, lpString2 , iMaxLength);

	if ( 0 == lpString1 || 0 == lpString2)
		return NULL;

	LPWSTR wszRet = lpString1;

	while ((*lpString1++ = *lpString2++) && iMaxLength--);

	return wszRet;
}


//----------------------------------------------------------------------------
//Wszlstrcat
//----------------------------------------------------------------------------
LPWSTR
Wszlstrcat( LPWSTR lpString1, LPCWSTR lpString2)
{
	if (g_bOnUnicodeBox)
		return lstrcatW( lpString1, lpString2 );

	if ( 0 == lpString1 || 0 == lpString2)
		return NULL;

	LPWSTR wszRet = lpString1;

	while( *lpString1 )
		lpString1++;

	while (*lpString1++ = *lpString2++);

	return wszRet;
}

//----------------------------------------------------------------------------
//WszCreateSemaphore
//----------------------------------------------------------------------------
HANDLE
WszCreateSemaphore(
   LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
   LONG lInitialCount,
   LONG lMaximumCount,
   LPCWSTR lpName
   )
{
	return NULL;	//Will implement when we do need this API.
}

//----------------------------------------------------------------------------
//WszCharUpper
//----------------------------------------------------------------------------
LPWSTR 
WszCharUpper(
	LPWSTR	lpwsz
	)
{
	if (g_bOnUnicodeBox)
		return CharUpperW( lpwsz );

	LPSTR szBuffer = NULL;

	if ( FAILED( WszConvertToAnsi((LPWSTR)lpwsz, &szBuffer, 0, NULL, TRUE) ) )
	{
		SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    szBuffer = CharUpperA(szBuffer);

	ULONG cch = lstrlenW(lpwsz)+1;

	if ( FAILED( WszConvertToUnicode( szBuffer, (lstrlenA(szBuffer)+1), &lpwsz, &cch, FALSE ) ) )
	    return FALSE;

	delete [] szBuffer;

	return lpwsz;

}

#endif // NOT UNDER_CE


// CE doesn't have UTF-* support, but our Wsz MultiByte <-> WideChar
// functions do.  The code in our classlibs know about the 
// UTF-8 codepage, and here is the native wrapper to handle those code
// pages.
#ifdef UNDER_CE
// These constants are defined in WinNLS.h.
#ifndef CP_UTF7  // In case the WinCE team changes their minds...
#define CP_UTF7 65000
#endif
#ifndef CP_UTF8
#define CP_UTF8 65001
#endif
#endif // UNDER_CE


//*****************************************************************************
// Convert an Ansi or UTF string to Unicode.
//
// On NT, or for code pages other than {UTF7|UTF8}, calls through to the
//  system implementation.  On Win95 (or 98), performing UTF translation,
//  calls to some code that was lifted from the NT translation functions.
//*****************************************************************************
int WszMultiByteToWideChar( 
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar)
{
    if (g_bOnUnicodeBox || (CodePage < CP_UTF7) || (CodePage > CP_UTF8))
    {
        return (MultiByteToWideChar(CodePage, 
            dwFlags, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpWideCharStr, 
            cchWideChar));
    }
    else
    {
        return (UTFToUnicode(CodePage, 
            dwFlags, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpWideCharStr, 
            cchWideChar));
    }
}

//*****************************************************************************
// Convert a Unicode string to Ansi or UTF.
//
// On NT, or for code pages other than {UTF7|UTF8}, calls through to the
//  system implementation.  On Win95 (or 98), performing UTF translation,
//  calls to some code that was lifted from the NT translation functions.
//*****************************************************************************
int WszWideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar)
{
    if (g_bOnUnicodeBox || (CodePage < CP_UTF7) || (CodePage > CP_UTF8))
    {
        return (WideCharToMultiByte(CodePage, 
            dwFlags, 
            lpWideCharStr, 
            cchWideChar, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpDefaultChar, 
            lpUsedDefaultChar));
    }
    else
    {
        return (UnicodeToUTF(CodePage, 
            dwFlags, 
            lpWideCharStr, 
            cchWideChar, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpDefaultChar, 
            lpUsedDefaultChar));
    }
}


#ifndef UNDER_CE  // Continuing Larry's hack to get WinCE to build.
BOOL WszGetVersionEx(
    LPOSVERSIONINFOW lpVersionInformation)
{
    if (g_bOnUnicodeBox)
        return GetVersionExW(lpVersionInformation);

    BOOL        bRtn;

	if(sizeof(OSVERSIONINFOEX) == lpVersionInformation->dwOSVersionInfoSize)
	{
	    OSVERSIONINFOEXA VersionInfo;

		memcpy(&VersionInfo, lpVersionInformation, offsetof(OSVERSIONINFOEXA, szCSDVersion));
		VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
		if (bRtn = GetVersionExA((struct _OSVERSIONINFOA *)&VersionInfo))
		{
			// note that we have made lpVersionInformation->dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA)
			((LPOSVERSIONINFOEX)lpVersionInformation)->dwOSVersionInfoSize = VersionInfo.dwOSVersionInfoSize;
			((LPOSVERSIONINFOEX)lpVersionInformation)->dwMajorVersion = VersionInfo.dwMajorVersion;
			((LPOSVERSIONINFOEX)lpVersionInformation)->dwMinorVersion = VersionInfo.dwMinorVersion;
			((LPOSVERSIONINFOEX)lpVersionInformation)->dwBuildNumber  = VersionInfo.dwBuildNumber;
			((LPOSVERSIONINFOEX)lpVersionInformation)->dwPlatformId = VersionInfo.dwPlatformId;
			((LPOSVERSIONINFOEX)lpVersionInformation)->wServicePackMajor = VersionInfo.wServicePackMajor;
			((LPOSVERSIONINFOEX)lpVersionInformation)->wServicePackMinor = VersionInfo.wServicePackMinor;
			((LPOSVERSIONINFOEX)lpVersionInformation)->wSuiteMask = VersionInfo.wSuiteMask;
			((LPOSVERSIONINFOEX)lpVersionInformation)->wProductType = VersionInfo.wProductType;
			((LPOSVERSIONINFOEX)lpVersionInformation)->wReserved = VersionInfo.wReserved;
			VERIFY(Wsz_mbstowcs(lpVersionInformation->szCSDVersion, VersionInfo.szCSDVersion, 128));
		}

	}
	else 
	{
	    OSVERSIONINFOA VersionInfo;

		memcpy(&VersionInfo, lpVersionInformation, offsetof(OSVERSIONINFOA, szCSDVersion));
		VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
		if (bRtn = GetVersionExA(&VersionInfo))
		{
			// note that we have made lpVersionInformation->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA)
			memcpy(lpVersionInformation, &VersionInfo, offsetof(OSVERSIONINFOA, szCSDVersion));
			VERIFY(Wsz_mbstowcs(lpVersionInformation->szCSDVersion, VersionInfo.szCSDVersion, 128));
		}
	}
    
    return (bRtn);
}


void WszOutputDebugString(
    LPCWSTR lpOutputString
    )
{
    if (g_bOnUnicodeBox)
    {
        OutputDebugStringW(lpOutputString);
        return;
    }

    LPSTR szOutput;
    if( FAILED(WszConvertToAnsi((LPWSTR)lpOutputString,
                      &szOutput, 0, NULL, TRUE)) )
    {
        goto Exit;
    }

    OutputDebugStringA(szOutput);

Exit:
    delete[] szOutput;
}


void WszFatalAppExit(
    UINT uAction,
    LPCWSTR lpMessageText
    )
{
    if (g_bOnUnicodeBox)
    {
        FatalAppExitW(uAction, lpMessageText);
        return;
    }

    LPSTR szString;
    if( FAILED(WszConvertToAnsi((LPWSTR)lpMessageText,
                      &szString, 0, NULL, TRUE)) )
    {
        goto Exit;
    }

    FatalAppExitA(uAction, szString);

Exit:
    delete[] szString;
}


int WszMessageBox(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType)
{
    if (g_bOnUnicodeBox)
        return MessageBoxW(hWnd, lpText, lpCaption, uType);

    LPSTR szString=NULL, szString2=NULL;
    int iRtn=0;//per Win32 documentation: "The return value is zero if there is not enough memory to create the message box."

    if( FAILED(WszConvertToAnsi((LPWSTR)lpText,
                      &szString, 0, NULL, TRUE)) ||
        FAILED(WszConvertToAnsi((LPWSTR)lpCaption,
                      &szString2, 0, NULL, TRUE)) )
    {
        goto Exit;
    }

    iRtn = MessageBoxA(hWnd, szString, szString2, uType);

Exit:
    delete [] szString;
    delete [] szString2;
    return iRtn;
}


HANDLE WszCreateMutex(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    )
{
    if (g_bOnUnicodeBox)
        return CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);

    HANDLE h;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = CreateMutexA(lpMutexAttributes, bInitialOwner, szString);

Exit:
    delete[] szString;
    return h;
}


HANDLE WszCreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    if (g_bOnUnicodeBox)
        return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);

    HANDLE h = NULL;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = CreateEventA(lpEventAttributes, bManualReset, bInitialState, szString);

Exit:
    delete[] szString;
    return h;
}


HANDLE WszOpenEvent(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    if (g_bOnUnicodeBox)
        return OpenEventW(dwDesiredAccess, bInheritHandle, lpName);

    HANDLE h;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = OpenEventA(dwDesiredAccess, bInheritHandle, szString);

Exit:
    delete[] szString;
    return h;
}


HMODULE WszGetModuleHandle(
    LPCWSTR lpModuleName
    )
{
    if (g_bOnUnicodeBox)
        return GetModuleHandleW(lpModuleName);

    HMODULE h;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpModuleName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        h = NULL;
        goto Exit;
    }

    h = GetModuleHandleA(szString);

Exit:
    delete[] szString;
    return h;
}


DWORD
WszGetFileAttributes(
    LPCWSTR lpFileName
    )
{
    if (g_bOnUnicodeBox)
        return GetFileAttributesW(lpFileName);

    DWORD rtn;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpFileName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    rtn = GetFileAttributesA(szString);

Exit:
    delete[] szString;
    return rtn;
}



DWORD
WszGetCurrentDirectory(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )
{
    if (g_bOnUnicodeBox)
        return GetCurrentDirectoryW(nBufferLength, lpBuffer);

    DWORD rtn;
	DWORD rtnwcs = 1;
    char *szString;
    CQuickBytes qbBuffer;

	if(NULL == lpBuffer)
		return  GetCurrentDirectoryA(0, NULL);

    szString = (char *) qbBuffer.Alloc(nBufferLength * 2);
    if (!szString)
        return (0);
    
    rtn = GetCurrentDirectoryA(nBufferLength * 2, szString);
	
	if((!rtn) || (rtn > nBufferLength))
		return rtn;

    return Wsz_mbstowcs(lpBuffer, szString, nBufferLength);
}

BOOL
WszSetCurrentDirectory(
  LPWSTR lpPathName  
)
{
    if (g_bOnUnicodeBox)
        return SetCurrentDirectoryW(lpPathName);

    DWORD rtn;
    LPSTR szString;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpPathName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    rtn = SetCurrentDirectoryA(szString);

Exit:
    delete[] szString;
    return rtn;
}
 



DWORD
WszGetTempPath(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )
{
    if (g_bOnUnicodeBox)
        return GetTempPathW(nBufferLength, lpBuffer);

    DWORD       rtn=0;//per Win32 docs: "If the function fails, the return value is zero. To get extended error information, call GetLastError."
    CQuickBytes qbBuffer;
    LPSTR       szOutput;

    szOutput = (LPSTR) qbBuffer.Alloc(nBufferLength * 2);
    if (szOutput)
    {
        rtn = GetTempPathA(nBufferLength * 2, szOutput);
        Wsz_mbstowcs(lpBuffer, szOutput, nBufferLength);
    }
    else
        SetLastError(ERROR_OUTOFMEMORY);

    if (!rtn && nBufferLength && lpBuffer)
        *lpBuffer = 0;

    return (rtn);
}


UINT
WszGetTempFileName(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )
{
    if (g_bOnUnicodeBox)
        return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

    DWORD       rtn;
    char        rcPrefix[64];
    char        rcPathName[_MAX_PATH];
    char        rcTempFile[_MAX_PATH];

    VERIFY(Wsz_wcstombs(rcPathName, lpPathName, sizeof(rcPathName)));
    VERIFY(Wsz_wcstombs(rcPrefix, lpPrefixString, sizeof(rcPrefix)));
    
    rtn = GetTempFileNameA(rcPathName, rcPrefix, uUnique, rcTempFile);

    if (rtn)
        rtn = Wsz_mbstowcs(lpTempFileName, rcTempFile, _MAX_PATH);
    else if (lpTempFileName)
        *lpTempFileName = 0;
    return rtn;
    
}


DWORD
WszGetEnvironmentVariable(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    )
{
    if (g_bOnUnicodeBox)
        return GetEnvironmentVariableW(lpName, lpBuffer, nSize);

    DWORD rtn;
    LPSTR szString, szBuffer;
    CQuickBytes qbBuffer;

    szBuffer = (char *) qbBuffer.Alloc(nSize * 2);
    if (!szBuffer)
        return (0);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    // Get value and convert back for caller.
    rtn = GetEnvironmentVariableA(szString, szBuffer, nSize * 2);
    if (rtn)
        rtn = Wsz_mbstowcs(lpBuffer, szBuffer, nSize);
    else if (lpBuffer && nSize)
        *lpBuffer = 0;

Exit:
    delete[] szString;
    return rtn;
}


BOOL
WszSetEnvironmentVariable(
    LPCWSTR lpName,
    LPCWSTR lpValue
    )
{
    if (g_bOnUnicodeBox)
        return SetEnvironmentVariableW(lpName, lpValue);

    DWORD rtn;
    LPSTR szString = NULL, szValue = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE))  ||
        FAILED(WszConvertToAnsi((LPWSTR)lpValue,
                      &szValue, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    // Get value and convert back for caller.
    rtn = SetEnvironmentVariableA(szString, szValue);

Exit:
    delete[] szString;
    delete[] szValue;
    return rtn;
}

HANDLE
WszCreateFileMapping(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
{
    if (g_bOnUnicodeBox)
        return CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, 
			dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

    HANDLE rtn;
    LPSTR szString = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    // Get value and convert back for caller.
    rtn = CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, 
			dwMaximumSizeHigh, dwMaximumSizeLow, szString);

Exit:
    delete[] szString;
    return rtn;
}

HANDLE
WszOpenFileMapping(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    if (g_bOnUnicodeBox)
        return OpenFileMappingW(dwDesiredAccess, bInheritHandle, lpName);

    HANDLE rtn = NULL;
    LPSTR szString = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szString, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        rtn = NULL;
        goto Exit;
    }

    // Get value and convert back for caller.
    rtn = OpenFileMappingA(dwDesiredAccess, bInheritHandle, szString);

Exit:
    delete[] szString;
    return rtn;
}

BOOL
WszCreateProcess(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (g_bOnUnicodeBox)
        return CreateProcessW(lpApplicationName,
                              lpCommandLine,
                              lpProcessAttributes,
                              lpThreadAttributes,
                              bInheritHandles,
                              dwCreationFlags,
                              lpEnvironment,
                              lpCurrentDirectory,
                              lpStartupInfo,
                              lpProcessInformation);

    BOOL rtn = FALSE;
    LPSTR szAppName = NULL;
    LPSTR szCommandLine = NULL;
    LPSTR szCurrentDir = NULL;
    LPSTR szReserved = NULL;
    LPSTR szDesktop = NULL;
    LPSTR szTitle = NULL;
    STARTUPINFOA infoA = *((LPSTARTUPINFOA)lpStartupInfo);

    if( FAILED(WszConvertToAnsi((LPWSTR)lpApplicationName,
                      &szAppName, 0, NULL, TRUE))  ||
        FAILED(WszConvertToAnsi((LPWSTR)lpCommandLine,
                      &szCommandLine, 0, NULL, TRUE))  ||
        FAILED(WszConvertToAnsi((LPWSTR)lpCurrentDirectory,
                      &szCurrentDir, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    if (lpStartupInfo->lpReserved != NULL)
    {
        if( FAILED(WszConvertToAnsi((LPWSTR)lpStartupInfo->lpReserved,
                      &szReserved, 0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        infoA.lpReserved = szReserved;
    }

    if (lpStartupInfo->lpDesktop != NULL)
    {
        if( FAILED(WszConvertToAnsi((LPWSTR)lpStartupInfo->lpDesktop,
                      &szDesktop, 0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        infoA.lpDesktop = szDesktop;
    }

    if (lpStartupInfo->lpTitle != NULL)
    {
        if( FAILED(WszConvertToAnsi((LPWSTR)lpStartupInfo->lpTitle,
                      &szTitle, 0, NULL, TRUE)) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }

        infoA.lpTitle = szTitle;
    }

    // Get value and convert back for caller.
    rtn = CreateProcessA(szAppName,
                         szCommandLine,
                         lpProcessAttributes,
                         lpThreadAttributes,
                         bInheritHandles,
                         dwCreationFlags,
                         lpEnvironment,
                         szCurrentDir,
                         &infoA,
                         lpProcessInformation);

Exit:
    delete[] szAppName;
    delete[] szCommandLine;
    delete[] szCurrentDir;
    delete[] szReserved;
    delete[] szDesktop;
    delete[] szTitle;
    return rtn;
}


HANDLE WszRegisterEventSource(
  LPCWSTR lpUNCServerName,  // server name for source
  LPCWSTR lpSourceName      // source name for registered handle
)
{
    if (g_bOnUnicodeBox)//If we can just call throught the go for it
        return RegisterEventSourceW(lpUNCServerName, lpSourceName);

    //Otherwise we need to convert the strings to ANSI then call the 'A' version
    HANDLE  rtn             = 0;
    LPSTR   szUNCServerName = 0;
    LPSTR   szSourceName    = 0;

    if(FAILED(WszConvertToAnsi((LPWSTR)lpUNCServerName, &szUNCServerName, 0, NULL, TRUE)) ||
       FAILED(WszConvertToAnsi((LPWSTR)lpSourceName,    &szSourceName,    0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    rtn = RegisterEventSourceA(szUNCServerName, szSourceName);

Exit:
    delete[] szSourceName;
    delete[] szUNCServerName;
    return rtn;
}

int Wszwvsprintf(
  LPTSTR lpOutput,
  LPCTSTR lpFormat,
  va_list arglist
)
{
    return vswprintf(lpOutput, lpFormat, arglist);
}

BOOL WszReportEvent(
  HANDLE    hEventLog,  // handle returned by RegisterEventSource
  WORD      wType,      // event type to log
  WORD      wCategory,  // event category
  DWORD     dwEventID,  // event identifier
  PSID      lpUserSid,  // user security identifier (optional)
  WORD      wNumStrings,// number of strings to merge with message
  DWORD     dwDataSize, // size of binary data, in bytes
  LPCTSTR * lpStrings,  // array of strings to merge with message
  LPVOID    lpRawData   // address of binary data
)
{
    if (g_bOnUnicodeBox)//If we can just call throught the go for it
        return ReportEventW(hEventLog,  
                            wType,      
                            wCategory,  
                            dwEventID,  
                            lpUserSid,  
                            wNumStrings,
                            dwDataSize, 
                            lpStrings,  
                            lpRawData   
                            );

    //Otherwise we need to convert the strings to ANSI then call the 'A' version
    BOOL    rtn             = 0;
    LPSTR  *aszStrings       = wNumStrings ? new LPSTR [wNumStrings] : 0;

    if(wNumStrings && 0==aszStrings)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return 0;
    }
    
    unsigned int iString=0;
    for(iString=0; iString<wNumStrings; ++iString)
    {
        aszStrings[iString] = 0;
        if(lpStrings[iString])
            if(FAILED(WszConvertToAnsi((LPWSTR)lpStrings[iString], &aszStrings[iString], 0, NULL, TRUE)) )
            {
                SetLastError(ERROR_OUTOFMEMORY);
                goto Exit;
            }
    }

    rtn = ReportEventA( hEventLog,  
                        wType,      
                        wCategory,  
                        dwEventID,  
                        lpUserSid,  
                        wNumStrings,
                        dwDataSize, 
                        const_cast<LPCSTR *>(aszStrings),  
                        lpRawData   
                        );

Exit:
    for(iString=0; iString<wNumStrings; ++iString)
        delete [] aszStrings[iString];
    delete [] aszStrings;

    return rtn;
}
 

#endif // NOT UNDER_CE



static void xtow (
        unsigned long val,
        LPWSTR buf,
        unsigned radix,
        int is_neg
        )
{
        WCHAR *p;               /* pointer to traverse string */
        WCHAR *firstdig;        /* pointer to first digit */
        WCHAR temp;             /* temp char */
        unsigned digval;        /* value of digit */

        p = buf;

        if (is_neg) {
            /* negative, so output '-' and negate */
            *p++ = (WCHAR) '-';
            val = (unsigned long)(-(long)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to text and store */
            if (digval > 9)
                *p++ = (WCHAR) (digval - 10 + 'A');  /* a letter */
            else
                *p++ = (WCHAR) (digval + '0');       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = 0;               /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
}

LPWSTR
Wszltow(
    LONG val,
    LPWSTR buf,
    int radix
    )
{
    xtow((unsigned long)val, buf, radix, (radix == 10 && val < 0));
    return buf;
}

LPWSTR
Wszultow(
    ULONG val,
    LPWSTR buf,
    int radix
    )
{
    xtow(val, buf, radix, 0);
    return buf;
}


//-----------------------------------------------------------------------------
// WszConvertToUnicode
//
// @func Convert a string from Ansi to Unicode
//
// @devnote cbIn can be -1 for Null Terminated string
//
// @rdesc HResult indicating status of Conversion
//      @flag S_OK | Converted to Ansi
//      @flag S_FALSE | Truncation occurred
//      @flag E_OUTOFMEMORY | Allocation problem.
//-----------------------------------------------------------------------------------
HRESULT WszConvertToUnicode
    (
    LPCSTR          szIn,       //@parm IN | Ansi String
    LONG            cbIn,       //@parm IN | Length of Ansi String in bytest
    LPWSTR*         lpwszOut,   //@parm INOUT | Unicode Buffer
    ULONG*          lpcchOut,   //@parm INOUT | Length of Unicode String in characters -- including '\0'
    BOOL            fAlloc      //@parm IN | Alloc memory or not
    )
{
    ULONG       cchOut;
    ULONG       cbOutJunk = 0;
//  ULONG       cchIn = szIn ? strlen(szIn) + 1 : 0;
            
//  _ASSERTE(lpwszOut);

    if (!(lpcchOut))
        lpcchOut = &cbOutJunk;

    if ((szIn == NULL) || (cbIn == 0))
    {
        *lpwszOut = NULL;
        if( lpcchOut )
            *lpcchOut = 0;
        return ResultFromScode(S_OK);
    }

    // Allocate memory if requested.   Note that we allocate as
    // much space as in the unicode buffer, since all of the input
    // characters could be double byte...
    if (fAlloc)
    {
        // Determine the number of characters needed 
        cchOut = (MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                0,                              
                                szIn,
                                cbIn,
                                NULL,
                                0));

        // _ASSERTE( cchOut != 0 );
        *lpwszOut = (LPWSTR) new WCHAR[cchOut];
        *lpcchOut = cchOut;     // Includes '\0'.

        if (!(*lpwszOut))
        {
//          TRACE("WszConvertToUnicode failed to allocate memory");
            return ResultFromScode(E_OUTOFMEMORY);
        }

    } 

    if( !(*lpwszOut) )
        return ResultFromScode(S_OK);
//  _ASSERTE(*lpwszOut);

    cchOut = (MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                0,                              
                                szIn,
                                cbIn,
                                *lpwszOut,
                                *lpcchOut));

    if (cchOut)
    {
        *lpcchOut = cchOut;
        return ResultFromScode(S_OK);
    }


//  _ASSERTE(*lpwszOut);
    if( fAlloc )
    {
        delete[] *lpwszOut;
        *lpwszOut = NULL;
    }
/*
    switch (GetLastError())
    {
        case    ERROR_NO_UNICODE_TRANSLATION:
        {
            OutputDebugString(TEXT("ODBC: no unicode translation for installer string"));
            return ResultFromScode(E_FAIL);
        }

        default:


        {
            _ASSERTE("Unexpected unicode error code from GetLastError" == NULL);
            return ResultFromScode(E_FAIL);
        }
    }
*/
    return ResultFromScode(E_FAIL); // NOTREACHED
}


//-----------------------------------------------------------------------------
// WszConvertToAnsi
//
// @func Convert a string from Unicode to Ansi
//
// @rdesc HResult indicating status of Conversion
//      @flag S_OK | Converted to Ansi
//      @flag S_FALSE | Truncation occurred
//      @flag E_OUTOFMEMORY | Allocation problem.
//-----------------------------------------------------------------------------------
HRESULT WszConvertToAnsi
    (
    LPCWSTR         szIn,       //@parm IN | Unicode string
    LPSTR*          lpszOut,    //@parm INOUT | Pointer for buffer for ansi string
    ULONG           cbOutMax,   //@parm IN | Max string length in bytes
    ULONG*          lpcbOut,    //@parm INOUT | Count of bytes for return buffer
    BOOL            fAlloc      //@parm IN | Alloc memory or not
    )
{
    ULONG           cchInActual;
    ULONG           cbOutJunk;
//@TODO the following in ODBC DM is never used
//  BOOL            fNTS = FALSE;
//@TODO check ODBC code for this line being wrong
    ULONG           cchIn = szIn ? lstrlenW (szIn) + 1 : 0;

    if (!(lpcbOut))
        lpcbOut = &cbOutJunk;

    if ((szIn == NULL) || (cchIn == 0))
    {
        *lpszOut = NULL;
        *lpcbOut = 0;
        return ResultFromScode(S_OK);
    }

    // Allocate memory if requested.   Note that we allocate as
    // much space as in the unicode buffer, since all of the input
    // characters could be double byte...
    cchInActual = cchIn;
    if (fAlloc)
    {
        cbOutMax = (WideCharToMultiByte(CP_ACP,     // XXX Consider: make any cp?
                                    0,                              
                                    szIn,
                                    cchInActual,
                                    NULL,
                                    0,
                                    NULL,
                                    FALSE));

        *lpszOut = (LPSTR) new CHAR[cbOutMax];

        if (!(*lpszOut))
        {
//          TRACE("WszConvertToAnsi failed to allocate memory");
            return ResultFromScode(E_OUTOFMEMORY);
        }

    } 

    if (!(*lpszOut))
        return ResultFromScode(S_OK);

//  _ASSERTE(*lpszOut);

    *lpcbOut = (WideCharToMultiByte(CP_ACP,     // XXX Consider: make any cp?
                                    0,                              
                                    szIn,
                                    cchInActual,
                                    *lpszOut,
                                    cbOutMax,
                                    NULL,
                                    FALSE));

    // Overflow on unicode conversion
    if (*lpcbOut > cbOutMax)
    {
        // If we had data truncation before, we have to guess
        // how big the string could be.   Guess large.
        if (cchIn > cbOutMax)
            *lpcbOut = cchIn * DBCS_MAXWID;

        return ResultFromScode(S_FALSE);
    }

    // handle external (driver-done) truncation
    if (cchIn > cbOutMax)
        *lpcbOut = cchIn * DBCS_MAXWID;
//  _ASSERTE(*lpcbOut);

    return ResultFromScode(S_OK);
}


#if defined (UNDER_CE)	// OnUnicodeSystem is always true on CE.
						// GetProcAddress is only Ansi, except on CE
						//   which is only Unicode.
// ***********************************************************
// @TODO - LBS
// This is a real hack and need more error checking and needs to be
// cleaned up.  This is just to get wince to @#$%'ing compile!
FARPROC WszGetProcAddress(HMODULE hMod, LPCSTR szProcName)
{
    LPWSTR          wzProcName;
//  ULONG           pcchOut;
    BOOL            fAlloc;
    ULONG           cbIn;
    ULONG           cchOut;
    ULONG           cbOutJunk;
    FARPROC         address;
    cbIn = strlen(szProcName);

    cchOut = (MultiByteToWideChar(CP_ACP,0,szProcName,cbIn,NULL,0));

    wzProcName = (LPWSTR) new WCHAR[cchOut];

    if (!wzProcName)
        return NULL;

    cchOut = (MultiByteToWideChar(CP_ACP,0,szProcName,cbIn,wzProcName,cchOut));

    address = GetProcAddressW(hMod, wzProcName);

    delete[] wzProcName;
    wzProcName = NULL;
    return address;
}

#ifndef EXTFUN
#define EXTFUN
#endif
#include "mschr.h"
char *  __cdecl strrchr(const char *p, int ch)
{	// init to null in case not found.
	char *q=0;			
	// process entire string.
	while (*p)
	{	// If a match, remember location.
		if (*p == ch)
			q = const_cast<char*>(p);
		MSCHR::Next(p);
	}
	return (q);
}
//char * __cdecl strchr(const char *, int);
int __cdecl _stricmp(const char *p1, const char *p2)
{
	// First check for exact match because code below is slow.
	if (!strcmp(p1, p2))
		return (0);

    while (!MSCHR::CmpI (p1, p2))
    {
        if (*p1 == '\0')
            return (0);
        MSCHR::Next (p1);
        MSCHR::Next (p2);
    }
    return MSCHR::CmpI (p1, p2);
}

//int __cdecl _strnicmp(const char *, const char *, size_t);
 	
#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\utilcode\utf.cpp ===
/*++

//  Copyright (C) 1991-2001 Microsoft Corporation.  All rights reserved.

Module Name:

    utf.c

Abstract:

    This file contains functions that convert UTF strings to Unicode
    strings and Unicode string to UTF strings.

    External Routines found in this file:
      UTFCPInfo
      UTFToUnicode
      UnicodeToUTF

Revision History:

    02-06-96    JulieB    Created.

--*/



//
//  Include Files.
//

#include <ole2.h>
#define NlsStrLenW(x) lstrlenW(x)
#include "utf.h"




//
//  Forward Declarations.
//

int
UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);

int
UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);

int
UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);

int
UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);



#ifndef UNDER_CE

//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTFCPInfo
//
//  Gets the CPInfo for the given UTF code page.
//
//  10-23-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL UTFCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo,
    BOOL fExVer)
{
    int ctr;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - lpCPInfo is NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (lpCPInfo == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            lpCPInfo->MaxCharSize = 5;
            break;
        }
        case ( CP_UTF8 ) :
        {
            lpCPInfo->MaxCharSize = 3;
            break;
        }
    }

    (lpCPInfo->DefaultChar)[0] = '?';
    (lpCPInfo->DefaultChar)[1] = (BYTE)0;

    for (ctr = 0; ctr < MAX_LEADBYTES; ctr++)
    {
        (lpCPInfo->LeadByte)[ctr] = (BYTE)0;
    }

    if (fExVer)
    {
        LPCPINFOEXW lpCPInfoEx = (LPCPINFOEXW)lpCPInfo;

        lpCPInfoEx->UnicodeDefaultChar = L'?';
        lpCPInfoEx->CodePage = CodePage;
    }

    return (TRUE);
}

#endif // UNDER_CE
////////////////////////////////////////////////////////////////////////////
//
//  UTFToUnicode
//
//  Maps a UTF character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTFToUnicode(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of MB string is 0
    //     - wide char buffer size is negative
    //     - MB string is NULL
    //     - length of WC string is NOT zero AND
    //         (WC string is NULL OR src and dest pointers equal)
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cchMultiByte == 0) || (cchWideChar < 0) ||
         (lpMultiByteStr == NULL) ||
         ((cchWideChar != 0) &&
          ((lpWideCharStr == NULL) ||
           (lpMultiByteStr == (LPSTR)lpWideCharStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchMultiByte is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchMultiByte <= -1)
    {
        cchMultiByte = (int)strlen(lpMultiByteStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UTF7ToUnicode( lpMultiByteStr,
                                cchMultiByte,
                                lpWideCharStr,
                                cchWideChar );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UTF8ToUnicode( lpMultiByteStr,
                                cchMultiByte,
                                lpWideCharStr,
                                cchWideChar );
            break;
        }
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF
//
//  Maps a Unicode character string to its UTF string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of WC string is 0
    //     - multibyte buffer size is negative
    //     - WC string is NULL
    //     - length of WC string is NOT zero AND
    //         (MB string is NULL OR src and dest pointers equal)
    //     - lpDefaultChar and lpUsedDefaultChar not NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cchWideChar == 0) || (cchMultiByte < 0) ||
         (lpWideCharStr == NULL) ||
         ((cchMultiByte != 0) &&
          ((lpMultiByteStr == NULL) ||
           (lpWideCharStr == (LPWSTR)lpMultiByteStr))) ||
         (lpDefaultChar != NULL) || (lpUsedDefaultChar != NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchWideChar is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchWideChar <= -1)
    {
        cchWideChar = NlsStrLenW(lpWideCharStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UnicodeToUTF7( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cchMultiByte );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UnicodeToUTF8( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cchMultiByte );
            break;
        }
    }

    return (rc);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTF7ToUnicode
//
//  Maps a UTF-7 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    LPCSTR pUTF7 = lpSrcStr;
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer to hold temporary bits
    int iPos = 0;                 // 6-bit position pointer in the buffer
    int cchWC = 0;                // # of Unicode code points generated


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        if (*pUTF7 > ASCII)
        {
            //
            //  Error - non ASCII char, so zero extend it.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF7;
            }
            cchWC++;
        }
        else if (!fShift)
        {
            //
            //  Not in shifted sequence.
            //
            if (*pUTF7 == SHIFT_IN)
            {
                if (cchSrc && (pUTF7[1] == SHIFT_OUT))
                {
                    //
                    //  "+-" means "+"
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    pUTF7++;
                    cchSrc--;
                    cchWC++;
                }
                else
                {
                    //
                    //  Start a new shift sequence.
                    //
                    fShift = TRUE;
                }
            }
            else
            {
                //
                //  No need to shift.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = (WCHAR)*pUTF7;
                }
                cchWC++;
            }
        }
        else
        {
            //
            //  Already in shifted sequence.
            //
            if (nBitBase64[*pUTF7] == -1)
            {
                //
                //  Any non Base64 char also ends shift state.
                //
                if (*pUTF7 != SHIFT_OUT)
                {
                    //
                    //  Not "-", so write it to the buffer.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    cchWC++;
                }

                //
                //  Reset bits.
                //
                fShift = FALSE;
                dwBit = 0;
                iPos = 0;
            }
            else
            {
                //
                //  Store the bits in the 6-bit buffer and adjust the
                //  position pointer.
                //
                dwBit |= ((DWORD)nBitBase64[*pUTF7]) << (26 - iPos);
                iPos += 6;
            }

            //
            //  Output the 16-bit Unicode value.
            //
            while (iPos >= 16)
            {
                if (cchDest)
                {
                    if (cchWC < cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)(dwBit >> 16);
                    }
                    else
                    {
                        break;
                    }
                }
                cchWC++;

                dwBit <<= 16;
                iPos -= 16;
            }
            if (iPos >= 16)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }

        pUTF7++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    char UTF8;


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                //
                //  Make room for the trail byte and add the trail byte
                //  value.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] <<= 6;
                    lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                }

                if (nTB == 0)
                {
                    //
                    //  End of sequence.  Advance the output counter.
                    //
                    cchWC++;
                }
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF7
//
//  Maps a Unicode character string to its UTF-7 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer
    int iPos = 0;                 // 6-bit position in buffer
    int cchU7 = 0;                // # of UTF7 chars generated


    while ((cchSrc--) && ((cchDest == 0) || (cchU7 < cchDest)))
    {
        if ((*lpWC > ASCII) || (fShiftChar[*lpWC]))
        {
            //
            //  Need shift.  Store 16 bits in buffer.
            //
            dwBit |= ((DWORD)*lpWC) << (16 - iPos);
            iPos += 16;

            if (!fShift)
            {
                //
                //  Not in shift state, so add "+".
                //
                if (cchDest)
                {
                    lpDestStr[cchU7] = SHIFT_IN;
                }
                cchU7++;

                //
                //  Go into shift state.
                //
                fShift = TRUE;
            }

            //
            //  Output 6 bits at a time as Base64 chars.
            //
            while (iPos >= 6)
            {
                if (cchDest)
                {
                    if (cchU7 < cchDest)
                    {
                        //
                        //  26 = 32 - 6
                        //
                        lpDestStr[cchU7] = cBase64[(int)(dwBit >> 26)];
                    }
                    else
                    {
                        break;
                    }
                }

                cchU7++;
                dwBit <<= 6;           // remove from bit buffer
                iPos -= 6;             // adjust position pointer
            }
            if (iPos >= 6)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }
        else
        {
            //
            //  No need to shift.
            //
            if (fShift)
            {
                //
                //  End the shift sequence.
                //
                fShift = FALSE;

                if (iPos != 0)
                {
                    //
                    //  Some bits left in dwBit.
                    //
                    if (cchDest)
                    {
                        if ((cchU7 + 1) < cchDest)
                        {
                            lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                    else
                    {
                        cchU7 += 2;
                    }

                    dwBit = 0;         // reset bit buffer
                    iPos  = 0;         // reset postion pointer
                }
                else
                {
                    //
                    //  Simply end the shift sequence.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchU7++] = SHIFT_OUT;
                    }
                    else
                    {
                        cchU7++;
                    }
                }
            }

            //
            //  Write the character to the buffer.
            //  If the character is "+", then write "+-".
            //
            if (cchDest)
            {
                if (cchU7 < cchDest)
                {
                    lpDestStr[cchU7++] = (char)*lpWC;

                    if (*lpWC == SHIFT_IN)
                    {
                        if (cchU7 < cchDest)
                        {
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU7++;

                if (*lpWC == SHIFT_IN)
                {
                    cchU7++;
                }
            }
        }

        lpWC++;
    }

    //
    //  See if we're still in the shift state.
    //
    if (fShift)
    {
        if (iPos != 0)
        {
            //
            //  Some bits left in dwBit.
            //
            if (cchDest)
            {
                if ((cchU7 + 1) < cchDest)
                {
                    lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                    lpDestStr[cchU7++] = SHIFT_OUT;
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7 += 2;
            }
        }
        else
        {
            //
            //  Simply end the shift sequence.
            //
            if (cchDest)
            {
                lpDestStr[cchU7++] = SHIFT_OUT;
            }
            else
            {
                cchU7++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-7 characters written.
    //
    return (cchU7);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int cchU8 = 0;                // # of UTF8 chars generated


    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        if (*lpWC <= ASCII)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchU8] = (char)*lpWC;
            }
            cchU8++;
        }
        else if (*lpWC <= UTF8_2_MAX)
        {
            //
            //  Found 2 byte sequence if < 0x07ff (11 bits).
            //
            if (cchDest)
            {
                if ((cchU8 + 1) < cchDest)
                {
                    //
                    //  Use upper 5 bits in first byte.
                    //  Use lower 6 bits in second byte.
                    //
                    lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU8 += 2;
            }
        }
        else
        {
            //
            //  Found 3 byte sequence.
            //
            if (cchDest)
            {
                if ((cchU8 + 2) < cchDest)
                {
                    //
                    //  Use upper  4 bits in first byte.
                    //  Use middle 6 bits in second byte.
                    //  Use lower  6 bits in third byte.
                    //
                    lpDestStr[cchU8++] = UTF8_1ST_OF_3 | (*lpWC >> 12);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU8 += 3;
            }
        }

        lpWC++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc\catinproc.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CatInproc.cpp

$Header: $

Abstract:

--**************************************************************************/

// CATALOG DLL exported functions: Search on HOWTO in this file and sources to integrate new interceptors:
#include <atlbase.h>
#include <dbgutil.h>
#include <initguid.h>
#include <iadmw.h>
#include <objbase.h>
#include "CorRegServices.h"								// For MSCORDDR.LIB

// HOWTO: Include your header here:
#include "sdtfst.h"	
#include "..\dispenser\cstdisp.h"						// Table dispenser.
#include "..\..\stores\ErrorTable\ErrorTable.h"         // ErrorTable interceptor.
#include "..\..\stores\xmltable\Metabase_XMLtable.h"    // Metabase XML interceptor.
#include "..\..\Plugins\MetabaseDifferencing\MetabaseDifferencing.h"	// Metabase Differencing Interceptor.
#include "..\..\stores\fixedtable\sdtfxd.h"				// Fixed interceptor.
#include "..\..\stores\fixedschemainterceptor\FixedPackedSchemaInterceptor.h"	// FixedPackedSchemaInterceptor.
#include "..\eventtable\sltevent.h"						// Event interceptor.
#include "..\..\URT\DTWriteIncptr\DTWriteIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTIncptr\DTIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTPlugin\DTPlugin.h"				// Ducttape Logic plugin for CFG tables.
#include "smartpointer.h"

#ifdef URT
#include "..\..\stores\xmltable\sdtxml.h"		        // XML interceptor.
#include "..\..\stores\fixedtable\metamerge.h"			// MetaMerge interceptor.
#include "..\..\stores\mergeinterceptor\interceptor\mergeinterceptor.h"
#include "..\..\Plugins\AddRemoveClear\AddRemoveClearPlugin.h"
#endif

#ifdef APPCENTER
#include "..\..\stores\asaitable\asaitable.h"		        // ASAI interceptor.
#endif

#include "winwrap.h"
#include "Hash.h"
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif

// Debugging stuff
// {76C72796-3D46-4882-A25E-2465A9D877A2}
DEFINE_GUID(CatalogGuid, 
0x76c72796, 0x3d46, 0x4882, 0xa2, 0x5e, 0x24, 0x65, 0xa9, 0xd8, 0x77, 0xa2);
DECLARE_DEBUG_PRINTS_OBJECT();

// Extern functions:
extern HRESULT SdtClbOnProcessAttach();
extern void SdtClbOnProcessDetach();
#ifdef URT
extern void AssemblyPluginOnProcessDetach();
#endif
extern BOOL OnUnicodeSystem();
extern HRESULT GetCLBTableDispenser(REFIID riid, LPVOID* o_ppv);

//This heap really needs to be located on a page boundary for perf and workingset reasons.  The only way in VC5 and VC6 to guarentee this
//is to locate it into its own data segment.  In VC7 we might be able to use '__declspec(align(4096))' tp accomplish the same thing.
#pragma data_seg( "TSHEAP" )
ULONG g_aFixedTableHeap[ CB_FIXED_TABLE_HEAP/sizeof(ULONG)]={kFixedTableHeapSignature0, kFixedTableHeapSignature1, kFixedTableHeapKey, kFixedTableHeapVersion, CB_FIXED_TABLE_HEAP};
#pragma data_seg()

// Global variables:
HMODULE					g_hModule = 0;					// Module handle
TSmartPointer<CSimpleTableDispenser> g_pSimpleTableDispenser; // Table dispenser singleton
CSafeAutoCriticalSection g_csSADispenser;					// Critical section for initializing table dispenser

extern LPWSTR g_wszDefaultProduct;//located in svcerr.cpp

// Get* functions:
// HOWTO: Add your Get* function for your simple object here:

HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeCFGValidationPlugin (REFIID riid, LPVOID* o_ppv);
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv);

#ifdef URT
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv);
#endif

#ifdef APPCENTER
HRESULT GetASAIInterceptor (REFIID riid, LPVOID* o_ppv);
#endif


// ============================================================================
HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// The dispenser is a singleton: Only create one object of this kind:
	if(g_pSimpleTableDispenser == 0)
	{
		HRESULT hr = S_OK;

		CSafeLock dispenserLock (&g_csSADispenser);
		DWORD dwRes = dispenserLock.Lock ();
	    if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

		if(g_pSimpleTableDispenser == 0)
		{
		// Create table dispenser:
			g_pSimpleTableDispenser = new CSimpleTableDispenser(i_wszProduct);
			if(g_pSimpleTableDispenser == 0)
			{
				return E_OUTOFMEMORY;
			}

		// Addref table dispenser so it never releases:
			g_pSimpleTableDispenser->AddRef();
			if(S_OK == hr)
			{
			// Initialize table dispenser:
				hr = g_pSimpleTableDispenser->Init(); // NOTE: Must never throw exceptions here!
			}
		}	
		if(S_OK != hr) return hr;
	}
	return g_pSimpleTableDispenser->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabase_XMLtable*	p = NULL;

	p = new TMetabase_XMLtable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#ifdef IIS
// don't need this for URT
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabaseDifferencing*	p = NULL;

	p = new TMetabaseDifferencing;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSDTFxd*	p = NULL;
	
	p = new CSDTFxd;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CMemoryTable*	p = NULL;
	
	p = new CMemoryTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#ifdef IIS
//Only IIS uses ducttape
// ============================================================================
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTIncptr*	p = NULL;
	
	p = new CDTIncptr;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTWriteInterceptorPlugin*	p = NULL;
	
	p = new CDTWriteInterceptorPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetDucttapeCFGValidationPlugin(REFIID riid, LPVOID* o_ppv)
{
	CDTPlugin*	p = NULL;
	
	p = new CDTPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSLTEvent	*p = NULL;
	
	p = new CSLTEvent;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv)
{
	TFixedPackedSchemaInterceptor*	p = NULL;
	
	p = new TFixedPackedSchemaInterceptor;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv)
{
	ErrorTable*	p = NULL;
	
	p = new ErrorTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================

#ifdef URT
// ============================================================================
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CXmlSDT*	p = NULL;

	p = new CXmlSDT;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyPlugin*	p = NULL;
	//
    //	p = new CAssemblyPlugin;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

// ============================================================================
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyTable*	p = NULL;
	//
	//p = new CAssemblyTable;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CSDTMetaMerge*	p = NULL;
	
	p = new CSDTMetaMerge;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

HRESULT GetMergeInterceptor (REFIID riid, LPVOID *o_ppv)
{
	// merge interceptor is a singleton
	static CMergeInterceptor mergeInterceptor;

	return mergeInterceptor.QueryInterface (riid, o_ppv);
}

HRESULT GetAddRemoveClearPlugin (REFIID riid, LPVOID* o_ppv)
{
	CAddRemoveClearPlugin *	p = new CAddRemoveClearPlugin;
	if(NULL == p) 
		return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

#endif

#ifdef APPCENTER

HRESULT GetASAIInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CAsaiTable*	p = NULL;

	p = new CAsaiTable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#endif

STDAPI DllGetSimpleObject (LPCWSTR /*i_wszObjectName*/, REFIID riid, LPVOID* o_ppv)
{
    return ReallyGetSimpleTableDispenser(riid, o_ppv, g_wszDefaultProduct);
}

// ============================================================================
// DllGetSimpleObject: Get table dispenser, interceptors, plugins, and other simple objects:
// HOWTO: Match your object name here and call your Get* function:
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv)
{
	HRESULT hr; 

// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	switch(i_ObjectID)
	{
		case eSERVERWIRINGMETA_Core_FixedInterceptor:
			hr = GetFixedTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses CLB
		case eSERVERWIRINGMETA_Core_ComplibInterceptor:
			hr = GetCLBTableDispenser(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_XMLInterceptor:
			hr = GetXMLTableInterceptor(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_EventInterceptor:
			hr = GetEventTableInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_MemoryInterceptor:
			hr = GetMemoryTableInterceptor(riid, o_ppv);
		break;
#ifdef URT
		// only IIS uses AssemblyInterceptor
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor:
			hr = GetAssemblyInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor2:
			hr = GetAssemblyInterceptor2(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_FixedPackedInterceptor:
			hr = GetFixedPackedInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_DetailedErrorInterceptor:
			hr = GetErrorTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
// only IIS uses ducttape
		case eSERVERWIRINGMETA_Ducttape_FileNameInterceptor:
			hr = GetDucttapeFileNameInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Ducttape_WriteInterceptor:
			hr = GetDucttapeWriteInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_WebServer_ValidationInterceptor:
			hr = GetDucttapeCFGValidationPlugin(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_TableDispenser:
            //Old Cat.libs use this - new Cat.libs should be calling DllGetSimpleObjectByIDEx below for the TableDispenser
			hr = ReallyGetSimpleTableDispenser(riid, o_ppv, 0);
		break;
		case eSERVERWIRINGMETA_Core_MetabaseInterceptor:
			hr = GetMetabaseXMLTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses metabasedifferencinginterceptor
		case eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor:
			hr = GetMetabaseDifferencingInterceptor(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_MetaMergeInterceptor:
			hr = GetMetaMergeInterceptor(riid, o_ppv);

		break;
		case eSERVERWIRINGMETA_Core_MergeInterceptor:
			hr = GetMergeInterceptor (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearReadPlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearWritePlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;
#endif
#ifdef APPCENTER
		case eSERVERWIRINGMETA_AppCenter_ASAIInterceptor:
			hr = GetASAIInterceptor(riid, o_ppv);
		break;
#endif
		default:
			return CLASS_E_CLASSNOTAVAILABLE;
	}
	return hr;
}


STDAPI DllGetSimpleObjectByIDEx (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	if(eSERVERWIRINGMETA_TableDispenser == i_ObjectID)
		return ReallyGetSimpleTableDispenser(riid, o_ppv,i_wszProduct);
    else
        return DllGetSimpleObjectByID(i_ObjectID, riid, o_ppv);
}


// ============================================================================
// DllMain: Global initialization:
extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID /*lpReserved*/)
{
	HRESULT hr;
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		CREATE_DEBUG_PRINT_OBJECT("Config", CatalogGuid);

		g_hModule = hModule;
		g_wszDefaultProduct = PRODUCT_DEFAULT;

		DisableThreadLibraryCalls(hModule);

		OnUnicodeSystem();

#ifdef IIS
		// Only IIS uses CLB
		hr = SdtClbOnProcessAttach(); // initialize complib engine
		if ( FAILED(hr) )
		  return FALSE;
#endif

		return TRUE;

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef IIS
		// only IIS uses CLB
		SdtClbOnProcessDetach(); //clb data table cleanup
#endif
		// we don't suppor assembly plugin's anymore
//		AssemblyPluginOnProcessDetach(); //assembly plugin cleanup
		DELETE_DEBUG_PRINT_OBJECT();
	}

	return TRUE;    // OK
}

// ============================================================================
// GetModuleInst: For using MSCORDDR.LIB
HINSTANCE GetModuleInst()
{
	return (g_hModule);
}

// ============================================================================
// Classic COM entry points (not currently employed):
STDAPI DllCanUnloadNow(void)
{
	return S_FALSE; // Not supported
}
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return CLASS_E_CLASSNOTAVAILABLE; 	// No com+ components in this dll for now
}
STDAPI DllRegisterServer(void)
{
	return S_OK; // Nothing to do here
}
STDAPI DllUnregisterServer(void)
{
	return S_OK; // Nothing to do here
}

// ============================================================================
// Wrappers for util functions 
void Trace(const wchar_t* szPattern, ...);
int Assert2(const wchar_t * szString, const wchar_t * szStack);

extern "C" void __stdcall ManagedTrace(LPWSTR wszMessage)
{
	Trace(L"%s", wszMessage);
}

extern "C" int __stdcall ManagedAssert(LPWSTR wszMessage, LPWSTR wszStack)
{
	return Assert2(wszMessage, wszStack);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_iiscfg\resource.h ===
#include <StackDlgIds.h>

#define IDS_MSG_APPID					353
#define IDS_MSG_APPNAME					354
#define IDS_MSG_FAILFAST				355
#define IDS_MSG_HRESULT					356
#define IDS_MSG_INTERNALS				357
#define IDS_MSG_LOGSTRING				358
#define IDS_MSG_LOGHRESULT				359
#define IDS_MSG_LOGWINERROR				360
#define IDS_MSG_NOAPPINFO				361
#define IDS_MSG_EXCEPTION				362
#define IDS_MSG_ADDRESS					363
#define IDS_MSG_CALLSTACK				364
#define IDS_MSG_ASSERT					365
#define IDS_MSG_PROGID					366
#define IDS_MSG_METHOD					367
#define IDS_MSG_MODULENAME				368
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc\resource.h ===
#include <StackDlgIds.h>

#define IDS_MSG_APPID					353
#define IDS_MSG_APPNAME					354
#define IDS_MSG_FAILFAST				355
#define IDS_MSG_HRESULT					356
#define IDS_MSG_INTERNALS				357
#define IDS_MSG_LOGSTRING				358
#define IDS_MSG_LOGHRESULT				359
#define IDS_MSG_LOGWINERROR				360
#define IDS_MSG_NOAPPINFO				361
#define IDS_MSG_EXCEPTION				362
#define IDS_MSG_ADDRESS					363
#define IDS_MSG_CALLSTACK				364
#define IDS_MSG_ASSERT					365
#define IDS_MSG_PROGID					366
#define IDS_MSG_METHOD					367
#define IDS_MSG_MODULENAME				368
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_appcenter\resource.h ===
#include <StackDlgIds.h>

#define IDS_MSG_APPID					353
#define IDS_MSG_APPNAME					354
#define IDS_MSG_FAILFAST				355
#define IDS_MSG_HRESULT					356
#define IDS_MSG_INTERNALS				357
#define IDS_MSG_LOGSTRING				358
#define IDS_MSG_LOGHRESULT				359
#define IDS_MSG_LOGWINERROR				360
#define IDS_MSG_NOAPPINFO				361
#define IDS_MSG_EXCEPTION				362
#define IDS_MSG_ADDRESS					363
#define IDS_MSG_CALLSTACK				364
#define IDS_MSG_ASSERT					365
#define IDS_MSG_PROGID					366
#define IDS_MSG_METHOD					367
#define IDS_MSG_MODULENAME				368
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_iiscfg\catinproc.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CatInproc.cpp

$Header: $

Abstract:

--**************************************************************************/

// CATALOG DLL exported functions: Search on HOWTO in this file and sources to integrate new interceptors:
#include <atlbase.h>
#include <dbgutil.h>
#include <initguid.h>
#include <iadmw.h>
#include <objbase.h>
#include "CorRegServices.h"								// For MSCORDDR.LIB

// HOWTO: Include your header here:
#include "sdtfst.h"	
#include "..\dispenser\cstdisp.h"						// Table dispenser.
#include "..\..\stores\ErrorTable\ErrorTable.h"         // ErrorTable interceptor.
#include "..\..\stores\xmltable\Metabase_XMLtable.h"    // Metabase XML interceptor.
#include "..\..\Plugins\MetabaseDifferencing\MetabaseDifferencing.h"	// Metabase Differencing Interceptor.
#include "..\..\stores\fixedtable\sdtfxd.h"				// Fixed interceptor.
#include "..\..\stores\fixedschemainterceptor\FixedPackedSchemaInterceptor.h"	// FixedPackedSchemaInterceptor.
#include "..\eventtable\sltevent.h"						// Event interceptor.
#include "..\..\URT\DTWriteIncptr\DTWriteIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTIncptr\DTIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTPlugin\DTPlugin.h"				// Ducttape Logic plugin for CFG tables.
#include "smartpointer.h"

#ifdef URT
#include "..\..\stores\xmltable\sdtxml.h"		        // XML interceptor.
#include "..\..\stores\fixedtable\metamerge.h"			// MetaMerge interceptor.
#include "..\..\stores\mergeinterceptor\interceptor\mergeinterceptor.h"
#include "..\..\Plugins\AddRemoveClear\AddRemoveClearPlugin.h"
#endif

#ifdef APPCENTER
#include "..\..\stores\asaitable\asaitable.h"		        // ASAI interceptor.
#endif

#include "winwrap.h"
#include "Hash.h"
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif

// Debugging stuff
// {76C72796-3D46-4882-A25E-2465A9D877A2}
DEFINE_GUID(CatalogGuid, 
0x76c72796, 0x3d46, 0x4882, 0xa2, 0x5e, 0x24, 0x65, 0xa9, 0xd8, 0x77, 0xa2);
DECLARE_DEBUG_PRINTS_OBJECT();

// Extern functions:
extern HRESULT SdtClbOnProcessAttach();
extern void SdtClbOnProcessDetach();
#ifdef URT
extern void AssemblyPluginOnProcessDetach();
#endif
extern BOOL OnUnicodeSystem();
extern HRESULT GetCLBTableDispenser(REFIID riid, LPVOID* o_ppv);

//This heap really needs to be located on a page boundary for perf and workingset reasons.  The only way in VC5 and VC6 to guarentee this
//is to locate it into its own data segment.  In VC7 we might be able to use '__declspec(align(4096))' tp accomplish the same thing.
#pragma data_seg( "TSHEAP" )
ULONG g_aFixedTableHeap[ CB_FIXED_TABLE_HEAP/sizeof(ULONG)]={kFixedTableHeapSignature0, kFixedTableHeapSignature1, kFixedTableHeapKey, kFixedTableHeapVersion, CB_FIXED_TABLE_HEAP};
#pragma data_seg()

// Global variables:
HMODULE					g_hModule = 0;					// Module handle
TSmartPointer<CSimpleTableDispenser> g_pSimpleTableDispenser; // Table dispenser singleton
CSafeAutoCriticalSection g_csSADispenser;					// Critical section for initializing table dispenser

extern LPWSTR g_wszDefaultProduct;//located in svcerr.cpp

// Get* functions:
// HOWTO: Add your Get* function for your simple object here:

HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeCFGValidationPlugin (REFIID riid, LPVOID* o_ppv);
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv);

#ifdef URT
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv);
#endif

#ifdef APPCENTER
HRESULT GetASAIInterceptor (REFIID riid, LPVOID* o_ppv);
#endif


// ============================================================================
HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// The dispenser is a singleton: Only create one object of this kind:
	if(g_pSimpleTableDispenser == 0)
	{
		HRESULT hr = S_OK;

		CSafeLock dispenserLock (&g_csSADispenser);
		DWORD dwRes = dispenserLock.Lock ();
	    if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

		if(g_pSimpleTableDispenser == 0)
		{
		// Create table dispenser:
			g_pSimpleTableDispenser = new CSimpleTableDispenser(i_wszProduct);
			if(g_pSimpleTableDispenser == 0)
			{
				return E_OUTOFMEMORY;
			}

		// Addref table dispenser so it never releases:
			g_pSimpleTableDispenser->AddRef();
			if(S_OK == hr)
			{
			// Initialize table dispenser:
				hr = g_pSimpleTableDispenser->Init(); // NOTE: Must never throw exceptions here!
			}
		}	
		if(S_OK != hr) return hr;
	}
	return g_pSimpleTableDispenser->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabase_XMLtable*	p = NULL;

	p = new TMetabase_XMLtable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#ifdef IIS
// don't need this for URT
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabaseDifferencing*	p = NULL;

	p = new TMetabaseDifferencing;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSDTFxd*	p = NULL;
	
	p = new CSDTFxd;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CMemoryTable*	p = NULL;
	
	p = new CMemoryTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#ifdef IIS
//Only IIS uses ducttape
// ============================================================================
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTIncptr*	p = NULL;
	
	p = new CDTIncptr;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTWriteInterceptorPlugin*	p = NULL;
	
	p = new CDTWriteInterceptorPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetDucttapeCFGValidationPlugin(REFIID riid, LPVOID* o_ppv)
{
	CDTPlugin*	p = NULL;
	
	p = new CDTPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSLTEvent	*p = NULL;
	
	p = new CSLTEvent;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv)
{
	TFixedPackedSchemaInterceptor*	p = NULL;
	
	p = new TFixedPackedSchemaInterceptor;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv)
{
	ErrorTable*	p = NULL;
	
	p = new ErrorTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================

#ifdef URT
// ============================================================================
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CXmlSDT*	p = NULL;

	p = new CXmlSDT;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyPlugin*	p = NULL;
	//
    //	p = new CAssemblyPlugin;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

// ============================================================================
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyTable*	p = NULL;
	//
	//p = new CAssemblyTable;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CSDTMetaMerge*	p = NULL;
	
	p = new CSDTMetaMerge;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

HRESULT GetMergeInterceptor (REFIID riid, LPVOID *o_ppv)
{
	// merge interceptor is a singleton
	static CMergeInterceptor mergeInterceptor;

	return mergeInterceptor.QueryInterface (riid, o_ppv);
}

HRESULT GetAddRemoveClearPlugin (REFIID riid, LPVOID* o_ppv)
{
	CAddRemoveClearPlugin *	p = new CAddRemoveClearPlugin;
	if(NULL == p) 
		return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

#endif

#ifdef APPCENTER

HRESULT GetASAIInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CAsaiTable*	p = NULL;

	p = new CAsaiTable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#endif

STDAPI DllGetSimpleObject (LPCWSTR /*i_wszObjectName*/, REFIID riid, LPVOID* o_ppv)
{
    return ReallyGetSimpleTableDispenser(riid, o_ppv, g_wszDefaultProduct);
}

// ============================================================================
// DllGetSimpleObject: Get table dispenser, interceptors, plugins, and other simple objects:
// HOWTO: Match your object name here and call your Get* function:
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv)
{
	HRESULT hr; 

// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	switch(i_ObjectID)
	{
		case eSERVERWIRINGMETA_Core_FixedInterceptor:
			hr = GetFixedTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses CLB
		case eSERVERWIRINGMETA_Core_ComplibInterceptor:
			hr = GetCLBTableDispenser(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_XMLInterceptor:
			hr = GetXMLTableInterceptor(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_EventInterceptor:
			hr = GetEventTableInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_MemoryInterceptor:
			hr = GetMemoryTableInterceptor(riid, o_ppv);
		break;
#ifdef URT
		// only IIS uses AssemblyInterceptor
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor:
			hr = GetAssemblyInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor2:
			hr = GetAssemblyInterceptor2(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_FixedPackedInterceptor:
			hr = GetFixedPackedInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_DetailedErrorInterceptor:
			hr = GetErrorTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
// only IIS uses ducttape
		case eSERVERWIRINGMETA_Ducttape_FileNameInterceptor:
			hr = GetDucttapeFileNameInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Ducttape_WriteInterceptor:
			hr = GetDucttapeWriteInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_WebServer_ValidationInterceptor:
			hr = GetDucttapeCFGValidationPlugin(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_TableDispenser:
            //Old Cat.libs use this - new Cat.libs should be calling DllGetSimpleObjectByIDEx below for the TableDispenser
			hr = ReallyGetSimpleTableDispenser(riid, o_ppv, 0);
		break;
		case eSERVERWIRINGMETA_Core_MetabaseInterceptor:
			hr = GetMetabaseXMLTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses metabasedifferencinginterceptor
		case eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor:
			hr = GetMetabaseDifferencingInterceptor(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_MetaMergeInterceptor:
			hr = GetMetaMergeInterceptor(riid, o_ppv);

		break;
		case eSERVERWIRINGMETA_Core_MergeInterceptor:
			hr = GetMergeInterceptor (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearReadPlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearWritePlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;
#endif
#ifdef APPCENTER
		case eSERVERWIRINGMETA_AppCenter_ASAIInterceptor:
			hr = GetASAIInterceptor(riid, o_ppv);
		break;
#endif
		default:
			return CLASS_E_CLASSNOTAVAILABLE;
	}
	return hr;
}


STDAPI DllGetSimpleObjectByIDEx (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	if(eSERVERWIRINGMETA_TableDispenser == i_ObjectID)
		return ReallyGetSimpleTableDispenser(riid, o_ppv,i_wszProduct);
    else
        return DllGetSimpleObjectByID(i_ObjectID, riid, o_ppv);
}


// ============================================================================
// DllMain: Global initialization:
extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID /*lpReserved*/)
{
	HRESULT hr;
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		CREATE_DEBUG_PRINT_OBJECT("Config", CatalogGuid);

		g_hModule = hModule;
		g_wszDefaultProduct = PRODUCT_DEFAULT;

		DisableThreadLibraryCalls(hModule);

		OnUnicodeSystem();

#ifdef IIS
		// Only IIS uses CLB
		hr = SdtClbOnProcessAttach(); // initialize complib engine
		if ( FAILED(hr) )
		  return FALSE;
#endif

		return TRUE;

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef IIS
		// only IIS uses CLB
		SdtClbOnProcessDetach(); //clb data table cleanup
#endif
		// we don't suppor assembly plugin's anymore
//		AssemblyPluginOnProcessDetach(); //assembly plugin cleanup
		DELETE_DEBUG_PRINT_OBJECT();
	}

	return TRUE;    // OK
}

// ============================================================================
// GetModuleInst: For using MSCORDDR.LIB
HINSTANCE GetModuleInst()
{
	return (g_hModule);
}

// ============================================================================
// Classic COM entry points (not currently employed):
STDAPI DllCanUnloadNow(void)
{
	return S_FALSE; // Not supported
}
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return CLASS_E_CLASSNOTAVAILABLE; 	// No com+ components in this dll for now
}
STDAPI DllRegisterServer(void)
{
	return S_OK; // Nothing to do here
}
STDAPI DllUnregisterServer(void)
{
	return S_OK; // Nothing to do here
}

// ============================================================================
// Wrappers for util functions 
void Trace(const wchar_t* szPattern, ...);
int Assert2(const wchar_t * szString, const wchar_t * szStack);

extern "C" void __stdcall ManagedTrace(LPWSTR wszMessage)
{
	Trace(L"%s", wszMessage);
}

extern "C" int __stdcall ManagedAssert(LPWSTR wszMessage, LPWSTR wszStack)
{
	return Assert2(wszMessage, wszStack);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_testcfg\resource.h ===
#include <StackDlgIds.h>

#define IDS_MSG_APPID					353
#define IDS_MSG_APPNAME					354
#define IDS_MSG_FAILFAST				355
#define IDS_MSG_HRESULT					356
#define IDS_MSG_INTERNALS				357
#define IDS_MSG_LOGSTRING				358
#define IDS_MSG_LOGHRESULT				359
#define IDS_MSG_LOGWINERROR				360
#define IDS_MSG_NOAPPINFO				361
#define IDS_MSG_EXCEPTION				362
#define IDS_MSG_ADDRESS					363
#define IDS_MSG_CALLSTACK				364
#define IDS_MSG_ASSERT					365
#define IDS_MSG_PROGID					366
#define IDS_MSG_METHOD					367
#define IDS_MSG_MODULENAME				368
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_urtcfg\resource.h ===
#include <StackDlgIds.h>

#define IDS_MSG_APPID					353
#define IDS_MSG_APPNAME					354
#define IDS_MSG_FAILFAST				355
#define IDS_MSG_HRESULT					356
#define IDS_MSG_INTERNALS				357
#define IDS_MSG_LOGSTRING				358
#define IDS_MSG_LOGHRESULT				359
#define IDS_MSG_LOGWINERROR				360
#define IDS_MSG_NOAPPINFO				361
#define IDS_MSG_EXCEPTION				362
#define IDS_MSG_ADDRESS					363
#define IDS_MSG_CALLSTACK				364
#define IDS_MSG_ASSERT					365
#define IDS_MSG_PROGID					366
#define IDS_MSG_METHOD					367
#define IDS_MSG_MODULENAME				368
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_appcenter\catinproc.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CatInproc.cpp

$Header: $

Abstract:

--**************************************************************************/

// CATALOG DLL exported functions: Search on HOWTO in this file and sources to integrate new interceptors:
#include <atlbase.h>
#include <dbgutil.h>
#include <initguid.h>
#include <iadmw.h>
#include <objbase.h>
#include "CorRegServices.h"								// For MSCORDDR.LIB

// HOWTO: Include your header here:
#include "sdtfst.h"	
#include "..\dispenser\cstdisp.h"						// Table dispenser.
#include "..\..\stores\ErrorTable\ErrorTable.h"         // ErrorTable interceptor.
#include "..\..\stores\xmltable\Metabase_XMLtable.h"    // Metabase XML interceptor.
#include "..\..\Plugins\MetabaseDifferencing\MetabaseDifferencing.h"	// Metabase Differencing Interceptor.
#include "..\..\stores\fixedtable\sdtfxd.h"				// Fixed interceptor.
#include "..\..\stores\fixedschemainterceptor\FixedPackedSchemaInterceptor.h"	// FixedPackedSchemaInterceptor.
#include "..\eventtable\sltevent.h"						// Event interceptor.
#include "..\..\URT\DTWriteIncptr\DTWriteIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTIncptr\DTIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTPlugin\DTPlugin.h"				// Ducttape Logic plugin for CFG tables.
#include "smartpointer.h"

#ifdef URT
#include "..\..\stores\xmltable\sdtxml.h"		        // XML interceptor.
#include "..\..\stores\fixedtable\metamerge.h"			// MetaMerge interceptor.
#include "..\..\stores\mergeinterceptor\interceptor\mergeinterceptor.h"
#include "..\..\Plugins\AddRemoveClear\AddRemoveClearPlugin.h"
#endif

#ifdef APPCENTER
#include "..\..\stores\asaitable\asaitable.h"		        // ASAI interceptor.
#endif

#include "winwrap.h"
#include "Hash.h"
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif

// Debugging stuff
// {76C72796-3D46-4882-A25E-2465A9D877A2}
DEFINE_GUID(CatalogGuid, 
0x76c72796, 0x3d46, 0x4882, 0xa2, 0x5e, 0x24, 0x65, 0xa9, 0xd8, 0x77, 0xa2);
DECLARE_DEBUG_PRINTS_OBJECT();

// Extern functions:
extern HRESULT SdtClbOnProcessAttach();
extern void SdtClbOnProcessDetach();
#ifdef URT
extern void AssemblyPluginOnProcessDetach();
#endif
extern BOOL OnUnicodeSystem();
extern HRESULT GetCLBTableDispenser(REFIID riid, LPVOID* o_ppv);

//This heap really needs to be located on a page boundary for perf and workingset reasons.  The only way in VC5 and VC6 to guarentee this
//is to locate it into its own data segment.  In VC7 we might be able to use '__declspec(align(4096))' tp accomplish the same thing.
#pragma data_seg( "TSHEAP" )
ULONG g_aFixedTableHeap[ CB_FIXED_TABLE_HEAP/sizeof(ULONG)]={kFixedTableHeapSignature0, kFixedTableHeapSignature1, kFixedTableHeapKey, kFixedTableHeapVersion, CB_FIXED_TABLE_HEAP};
#pragma data_seg()

// Global variables:
HMODULE					g_hModule = 0;					// Module handle
TSmartPointer<CSimpleTableDispenser> g_pSimpleTableDispenser; // Table dispenser singleton
CSafeAutoCriticalSection g_csSADispenser;					// Critical section for initializing table dispenser

extern LPWSTR g_wszDefaultProduct;//located in svcerr.cpp

// Get* functions:
// HOWTO: Add your Get* function for your simple object here:

HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeCFGValidationPlugin (REFIID riid, LPVOID* o_ppv);
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv);

#ifdef URT
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv);
#endif

#ifdef APPCENTER
HRESULT GetASAIInterceptor (REFIID riid, LPVOID* o_ppv);
#endif


// ============================================================================
HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// The dispenser is a singleton: Only create one object of this kind:
	if(g_pSimpleTableDispenser == 0)
	{
		HRESULT hr = S_OK;

		CSafeLock dispenserLock (&g_csSADispenser);
		DWORD dwRes = dispenserLock.Lock ();
	    if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

		if(g_pSimpleTableDispenser == 0)
		{
		// Create table dispenser:
			g_pSimpleTableDispenser = new CSimpleTableDispenser(i_wszProduct);
			if(g_pSimpleTableDispenser == 0)
			{
				return E_OUTOFMEMORY;
			}

		// Addref table dispenser so it never releases:
			g_pSimpleTableDispenser->AddRef();
			if(S_OK == hr)
			{
			// Initialize table dispenser:
				hr = g_pSimpleTableDispenser->Init(); // NOTE: Must never throw exceptions here!
			}
		}	
		if(S_OK != hr) return hr;
	}
	return g_pSimpleTableDispenser->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabase_XMLtable*	p = NULL;

	p = new TMetabase_XMLtable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#ifdef IIS
// don't need this for URT
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabaseDifferencing*	p = NULL;

	p = new TMetabaseDifferencing;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSDTFxd*	p = NULL;
	
	p = new CSDTFxd;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CMemoryTable*	p = NULL;
	
	p = new CMemoryTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#ifdef IIS
//Only IIS uses ducttape
// ============================================================================
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTIncptr*	p = NULL;
	
	p = new CDTIncptr;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTWriteInterceptorPlugin*	p = NULL;
	
	p = new CDTWriteInterceptorPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetDucttapeCFGValidationPlugin(REFIID riid, LPVOID* o_ppv)
{
	CDTPlugin*	p = NULL;
	
	p = new CDTPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSLTEvent	*p = NULL;
	
	p = new CSLTEvent;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv)
{
	TFixedPackedSchemaInterceptor*	p = NULL;
	
	p = new TFixedPackedSchemaInterceptor;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv)
{
	ErrorTable*	p = NULL;
	
	p = new ErrorTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================

#ifdef URT
// ============================================================================
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CXmlSDT*	p = NULL;

	p = new CXmlSDT;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyPlugin*	p = NULL;
	//
    //	p = new CAssemblyPlugin;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

// ============================================================================
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyTable*	p = NULL;
	//
	//p = new CAssemblyTable;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CSDTMetaMerge*	p = NULL;
	
	p = new CSDTMetaMerge;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

HRESULT GetMergeInterceptor (REFIID riid, LPVOID *o_ppv)
{
	// merge interceptor is a singleton
	static CMergeInterceptor mergeInterceptor;

	return mergeInterceptor.QueryInterface (riid, o_ppv);
}

HRESULT GetAddRemoveClearPlugin (REFIID riid, LPVOID* o_ppv)
{
	CAddRemoveClearPlugin *	p = new CAddRemoveClearPlugin;
	if(NULL == p) 
		return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

#endif

#ifdef APPCENTER

HRESULT GetASAIInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CAsaiTable*	p = NULL;

	p = new CAsaiTable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#endif

STDAPI DllGetSimpleObject (LPCWSTR /*i_wszObjectName*/, REFIID riid, LPVOID* o_ppv)
{
    return ReallyGetSimpleTableDispenser(riid, o_ppv, g_wszDefaultProduct);
}

// ============================================================================
// DllGetSimpleObject: Get table dispenser, interceptors, plugins, and other simple objects:
// HOWTO: Match your object name here and call your Get* function:
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv)
{
	HRESULT hr; 

// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	switch(i_ObjectID)
	{
		case eSERVERWIRINGMETA_Core_FixedInterceptor:
			hr = GetFixedTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses CLB
		case eSERVERWIRINGMETA_Core_ComplibInterceptor:
			hr = GetCLBTableDispenser(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_XMLInterceptor:
			hr = GetXMLTableInterceptor(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_EventInterceptor:
			hr = GetEventTableInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_MemoryInterceptor:
			hr = GetMemoryTableInterceptor(riid, o_ppv);
		break;
#ifdef URT
		// only IIS uses AssemblyInterceptor
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor:
			hr = GetAssemblyInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor2:
			hr = GetAssemblyInterceptor2(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_FixedPackedInterceptor:
			hr = GetFixedPackedInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_DetailedErrorInterceptor:
			hr = GetErrorTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
// only IIS uses ducttape
		case eSERVERWIRINGMETA_Ducttape_FileNameInterceptor:
			hr = GetDucttapeFileNameInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Ducttape_WriteInterceptor:
			hr = GetDucttapeWriteInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_WebServer_ValidationInterceptor:
			hr = GetDucttapeCFGValidationPlugin(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_TableDispenser:
            //Old Cat.libs use this - new Cat.libs should be calling DllGetSimpleObjectByIDEx below for the TableDispenser
			hr = ReallyGetSimpleTableDispenser(riid, o_ppv, 0);
		break;
		case eSERVERWIRINGMETA_Core_MetabaseInterceptor:
			hr = GetMetabaseXMLTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses metabasedifferencinginterceptor
		case eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor:
			hr = GetMetabaseDifferencingInterceptor(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_MetaMergeInterceptor:
			hr = GetMetaMergeInterceptor(riid, o_ppv);

		break;
		case eSERVERWIRINGMETA_Core_MergeInterceptor:
			hr = GetMergeInterceptor (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearReadPlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearWritePlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;
#endif
#ifdef APPCENTER
		case eSERVERWIRINGMETA_AppCenter_ASAIInterceptor:
			hr = GetASAIInterceptor(riid, o_ppv);
		break;
#endif
		default:
			return CLASS_E_CLASSNOTAVAILABLE;
	}
	return hr;
}


STDAPI DllGetSimpleObjectByIDEx (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	if(eSERVERWIRINGMETA_TableDispenser == i_ObjectID)
		return ReallyGetSimpleTableDispenser(riid, o_ppv,i_wszProduct);
    else
        return DllGetSimpleObjectByID(i_ObjectID, riid, o_ppv);
}


// ============================================================================
// DllMain: Global initialization:
extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID /*lpReserved*/)
{
	HRESULT hr;
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		CREATE_DEBUG_PRINT_OBJECT("Config", CatalogGuid);

		g_hModule = hModule;
		g_wszDefaultProduct = PRODUCT_DEFAULT;

		DisableThreadLibraryCalls(hModule);

		OnUnicodeSystem();

#ifdef IIS
		// Only IIS uses CLB
		hr = SdtClbOnProcessAttach(); // initialize complib engine
		if ( FAILED(hr) )
		  return FALSE;
#endif

		return TRUE;

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef IIS
		// only IIS uses CLB
		SdtClbOnProcessDetach(); //clb data table cleanup
#endif
		// we don't suppor assembly plugin's anymore
//		AssemblyPluginOnProcessDetach(); //assembly plugin cleanup
		DELETE_DEBUG_PRINT_OBJECT();
	}

	return TRUE;    // OK
}

// ============================================================================
// GetModuleInst: For using MSCORDDR.LIB
HINSTANCE GetModuleInst()
{
	return (g_hModule);
}

// ============================================================================
// Classic COM entry points (not currently employed):
STDAPI DllCanUnloadNow(void)
{
	return S_FALSE; // Not supported
}
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return CLASS_E_CLASSNOTAVAILABLE; 	// No com+ components in this dll for now
}
STDAPI DllRegisterServer(void)
{
	return S_OK; // Nothing to do here
}
STDAPI DllUnregisterServer(void)
{
	return S_OK; // Nothing to do here
}

// ============================================================================
// Wrappers for util functions 
void Trace(const wchar_t* szPattern, ...);
int Assert2(const wchar_t * szString, const wchar_t * szStack);

extern "C" void __stdcall ManagedTrace(LPWSTR wszMessage)
{
	Trace(L"%s", wszMessage);
}

extern "C" int __stdcall ManagedAssert(LPWSTR wszMessage, LPWSTR wszStack)
{
	return Assert2(wszMessage, wszStack);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_urtcfg\urtspecific.cpp ===
// urt specific functions to make program compile

#include "MBListen.h"

STDAPI CookDownIncrementalInternal(WAS_CHANGE_OBJECT* i_aWASChngObj,
				                   ULONG              i_cWASChngObj)
{
		return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_urtcfg\catinproc.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CatInproc.cpp

$Header: $

Abstract:

--**************************************************************************/

// CATALOG DLL exported functions: Search on HOWTO in this file and sources to integrate new interceptors:
#include <atlbase.h>
#include <dbgutil.h>
#include <initguid.h>
#include <iadmw.h>
#include <objbase.h>
#include "CorRegServices.h"								// For MSCORDDR.LIB

// HOWTO: Include your header here:
#include "sdtfst.h"	
#include "..\dispenser\cstdisp.h"						// Table dispenser.
#include "..\..\stores\ErrorTable\ErrorTable.h"         // ErrorTable interceptor.
#include "..\..\stores\xmltable\Metabase_XMLtable.h"    // Metabase XML interceptor.
#include "..\..\Plugins\MetabaseDifferencing\MetabaseDifferencing.h"	// Metabase Differencing Interceptor.
#include "..\..\stores\fixedtable\sdtfxd.h"				// Fixed interceptor.
#include "..\..\stores\fixedschemainterceptor\FixedPackedSchemaInterceptor.h"	// FixedPackedSchemaInterceptor.
#include "..\eventtable\sltevent.h"						// Event interceptor.
#include "..\..\URT\DTWriteIncptr\DTWriteIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTIncptr\DTIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTPlugin\DTPlugin.h"				// Ducttape Logic plugin for CFG tables.
#include "smartpointer.h"

#ifdef URT
#include "..\..\stores\xmltable\sdtxml.h"		        // XML interceptor.
#include "..\..\stores\fixedtable\metamerge.h"			// MetaMerge interceptor.
#include "..\..\stores\mergeinterceptor\interceptor\mergeinterceptor.h"
#include "..\..\Plugins\AddRemoveClear\AddRemoveClearPlugin.h"
#endif

#ifdef APPCENTER
#include "..\..\stores\asaitable\asaitable.h"		        // ASAI interceptor.
#endif

#include "winwrap.h"
#include "Hash.h"
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif

// Debugging stuff
// {76C72796-3D46-4882-A25E-2465A9D877A2}
DEFINE_GUID(CatalogGuid, 
0x76c72796, 0x3d46, 0x4882, 0xa2, 0x5e, 0x24, 0x65, 0xa9, 0xd8, 0x77, 0xa2);
DECLARE_DEBUG_PRINTS_OBJECT();

// Extern functions:
extern HRESULT SdtClbOnProcessAttach();
extern void SdtClbOnProcessDetach();
#ifdef URT
extern void AssemblyPluginOnProcessDetach();
#endif
extern BOOL OnUnicodeSystem();
extern HRESULT GetCLBTableDispenser(REFIID riid, LPVOID* o_ppv);

//This heap really needs to be located on a page boundary for perf and workingset reasons.  The only way in VC5 and VC6 to guarentee this
//is to locate it into its own data segment.  In VC7 we might be able to use '__declspec(align(4096))' tp accomplish the same thing.
#pragma data_seg( "TSHEAP" )
ULONG g_aFixedTableHeap[ CB_FIXED_TABLE_HEAP/sizeof(ULONG)]={kFixedTableHeapSignature0, kFixedTableHeapSignature1, kFixedTableHeapKey, kFixedTableHeapVersion, CB_FIXED_TABLE_HEAP};
#pragma data_seg()

// Global variables:
HMODULE					g_hModule = 0;					// Module handle
TSmartPointer<CSimpleTableDispenser> g_pSimpleTableDispenser; // Table dispenser singleton
CSafeAutoCriticalSection g_csSADispenser;					// Critical section for initializing table dispenser

extern LPWSTR g_wszDefaultProduct;//located in svcerr.cpp

// Get* functions:
// HOWTO: Add your Get* function for your simple object here:

HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeCFGValidationPlugin (REFIID riid, LPVOID* o_ppv);
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv);

#ifdef URT
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv);
#endif

#ifdef APPCENTER
HRESULT GetASAIInterceptor (REFIID riid, LPVOID* o_ppv);
#endif


// ============================================================================
HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// The dispenser is a singleton: Only create one object of this kind:
	if(g_pSimpleTableDispenser == 0)
	{
		HRESULT hr = S_OK;

		CSafeLock dispenserLock (&g_csSADispenser);
		DWORD dwRes = dispenserLock.Lock ();
	    if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

		if(g_pSimpleTableDispenser == 0)
		{
		// Create table dispenser:
			g_pSimpleTableDispenser = new CSimpleTableDispenser(i_wszProduct);
			if(g_pSimpleTableDispenser == 0)
			{
				return E_OUTOFMEMORY;
			}

		// Addref table dispenser so it never releases:
			g_pSimpleTableDispenser->AddRef();
			if(S_OK == hr)
			{
			// Initialize table dispenser:
				hr = g_pSimpleTableDispenser->Init(); // NOTE: Must never throw exceptions here!
			}
		}	
		if(S_OK != hr) return hr;
	}
	return g_pSimpleTableDispenser->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabase_XMLtable*	p = NULL;

	p = new TMetabase_XMLtable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#ifdef IIS
// don't need this for URT
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabaseDifferencing*	p = NULL;

	p = new TMetabaseDifferencing;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSDTFxd*	p = NULL;
	
	p = new CSDTFxd;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CMemoryTable*	p = NULL;
	
	p = new CMemoryTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#ifdef IIS
//Only IIS uses ducttape
// ============================================================================
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTIncptr*	p = NULL;
	
	p = new CDTIncptr;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTWriteInterceptorPlugin*	p = NULL;
	
	p = new CDTWriteInterceptorPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetDucttapeCFGValidationPlugin(REFIID riid, LPVOID* o_ppv)
{
	CDTPlugin*	p = NULL;
	
	p = new CDTPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSLTEvent	*p = NULL;
	
	p = new CSLTEvent;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv)
{
	TFixedPackedSchemaInterceptor*	p = NULL;
	
	p = new TFixedPackedSchemaInterceptor;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv)
{
	ErrorTable*	p = NULL;
	
	p = new ErrorTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================

#ifdef URT
// ============================================================================
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CXmlSDT*	p = NULL;

	p = new CXmlSDT;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyPlugin*	p = NULL;
	//
    //	p = new CAssemblyPlugin;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

// ============================================================================
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyTable*	p = NULL;
	//
	//p = new CAssemblyTable;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CSDTMetaMerge*	p = NULL;
	
	p = new CSDTMetaMerge;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

HRESULT GetMergeInterceptor (REFIID riid, LPVOID *o_ppv)
{
	// merge interceptor is a singleton
	static CMergeInterceptor mergeInterceptor;

	return mergeInterceptor.QueryInterface (riid, o_ppv);
}

HRESULT GetAddRemoveClearPlugin (REFIID riid, LPVOID* o_ppv)
{
	CAddRemoveClearPlugin *	p = new CAddRemoveClearPlugin;
	if(NULL == p) 
		return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

#endif

#ifdef APPCENTER

HRESULT GetASAIInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CAsaiTable*	p = NULL;

	p = new CAsaiTable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#endif

STDAPI DllGetSimpleObject (LPCWSTR /*i_wszObjectName*/, REFIID riid, LPVOID* o_ppv)
{
    return ReallyGetSimpleTableDispenser(riid, o_ppv, g_wszDefaultProduct);
}

// ============================================================================
// DllGetSimpleObject: Get table dispenser, interceptors, plugins, and other simple objects:
// HOWTO: Match your object name here and call your Get* function:
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv)
{
	HRESULT hr; 

// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	switch(i_ObjectID)
	{
		case eSERVERWIRINGMETA_Core_FixedInterceptor:
			hr = GetFixedTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses CLB
		case eSERVERWIRINGMETA_Core_ComplibInterceptor:
			hr = GetCLBTableDispenser(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_XMLInterceptor:
			hr = GetXMLTableInterceptor(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_EventInterceptor:
			hr = GetEventTableInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_MemoryInterceptor:
			hr = GetMemoryTableInterceptor(riid, o_ppv);
		break;
#ifdef URT
		// only IIS uses AssemblyInterceptor
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor:
			hr = GetAssemblyInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor2:
			hr = GetAssemblyInterceptor2(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_FixedPackedInterceptor:
			hr = GetFixedPackedInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_DetailedErrorInterceptor:
			hr = GetErrorTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
// only IIS uses ducttape
		case eSERVERWIRINGMETA_Ducttape_FileNameInterceptor:
			hr = GetDucttapeFileNameInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Ducttape_WriteInterceptor:
			hr = GetDucttapeWriteInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_WebServer_ValidationInterceptor:
			hr = GetDucttapeCFGValidationPlugin(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_TableDispenser:
            //Old Cat.libs use this - new Cat.libs should be calling DllGetSimpleObjectByIDEx below for the TableDispenser
			hr = ReallyGetSimpleTableDispenser(riid, o_ppv, 0);
		break;
		case eSERVERWIRINGMETA_Core_MetabaseInterceptor:
			hr = GetMetabaseXMLTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses metabasedifferencinginterceptor
		case eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor:
			hr = GetMetabaseDifferencingInterceptor(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_MetaMergeInterceptor:
			hr = GetMetaMergeInterceptor(riid, o_ppv);

		break;
		case eSERVERWIRINGMETA_Core_MergeInterceptor:
			hr = GetMergeInterceptor (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearReadPlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearWritePlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;
#endif
#ifdef APPCENTER
		case eSERVERWIRINGMETA_AppCenter_ASAIInterceptor:
			hr = GetASAIInterceptor(riid, o_ppv);
		break;
#endif
		default:
			return CLASS_E_CLASSNOTAVAILABLE;
	}
	return hr;
}


STDAPI DllGetSimpleObjectByIDEx (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	if(eSERVERWIRINGMETA_TableDispenser == i_ObjectID)
		return ReallyGetSimpleTableDispenser(riid, o_ppv,i_wszProduct);
    else
        return DllGetSimpleObjectByID(i_ObjectID, riid, o_ppv);
}


// ============================================================================
// DllMain: Global initialization:
extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID /*lpReserved*/)
{
	HRESULT hr;
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		CREATE_DEBUG_PRINT_OBJECT("Config", CatalogGuid);

		g_hModule = hModule;
		g_wszDefaultProduct = PRODUCT_DEFAULT;

		DisableThreadLibraryCalls(hModule);

		OnUnicodeSystem();

#ifdef IIS
		// Only IIS uses CLB
		hr = SdtClbOnProcessAttach(); // initialize complib engine
		if ( FAILED(hr) )
		  return FALSE;
#endif

		return TRUE;

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef IIS
		// only IIS uses CLB
		SdtClbOnProcessDetach(); //clb data table cleanup
#endif
		// we don't suppor assembly plugin's anymore
//		AssemblyPluginOnProcessDetach(); //assembly plugin cleanup
		DELETE_DEBUG_PRINT_OBJECT();
	}

	return TRUE;    // OK
}

// ============================================================================
// GetModuleInst: For using MSCORDDR.LIB
HINSTANCE GetModuleInst()
{
	return (g_hModule);
}

// ============================================================================
// Classic COM entry points (not currently employed):
STDAPI DllCanUnloadNow(void)
{
	return S_FALSE; // Not supported
}
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return CLASS_E_CLASSNOTAVAILABLE; 	// No com+ components in this dll for now
}
STDAPI DllRegisterServer(void)
{
	return S_OK; // Nothing to do here
}
STDAPI DllUnregisterServer(void)
{
	return S_OK; // Nothing to do here
}

// ============================================================================
// Wrappers for util functions 
void Trace(const wchar_t* szPattern, ...);
int Assert2(const wchar_t * szString, const wchar_t * szStack);

extern "C" void __stdcall ManagedTrace(LPWSTR wszMessage)
{
	Trace(L"%s", wszMessage);
}

extern "C" int __stdcall ManagedAssert(LPWSTR wszMessage, LPWSTR wszStack)
{
	return Assert2(wszMessage, wszStack);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\dispenser\cshell.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    cshell.cpp

$Header: $

--**************************************************************************/

#include "cshell.h"
#include "cstdisp.h"
#include "catmacros.h"
#include "catmeta.h"

#define cmaxCOLUMNMETACOLUMNS	15
#define cmaxCOLUMNMETAROWS		100

// ==================================================================
CSTShell::CSTShell ()
	: m_cRef (0)
	, m_bInitialized (0)
	, m_fLOS (0)
	, m_pWrite (NULL)
	, m_pController (NULL)
	, m_pInterceptorPlugin (NULL)
	, m_pReadPlugin (NULL)
	, m_pWritePlugin (NULL)
{
}

// ==================================================================
CSTShell::~CSTShell ()
{
	if (m_pInterceptorPlugin)
		m_pInterceptorPlugin->Release();

	if (m_pWritePlugin)
		m_pWritePlugin->Release();

	if (m_pReadPlugin)
		m_pReadPlugin->Release();

	if (m_pWrite)
		m_pWrite->Release();

	if (m_pController)
		m_pController->Release();
}

// ------------------------------------
// ISimpleTableInterceptor
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::Initialize
(
	LPCWSTR					i_wszDatabase,
	LPCWSTR 				i_wszTable, 
	ULONG   				i_TableID, 
	LPVOID					i_QueryData,
	LPVOID					i_QueryMeta,
	DWORD					i_eQueryFormat,
	DWORD					i_fLOS,
	IAdvancedTableDispenser* i_pISTDisp,
	LPCWSTR					i_wszLocator,
	LPVOID					i_pv,
	IInterceptorPlugin*		i_pInterceptorPlugin,
	ISimplePlugin*			i_pReadPlugin,
	ISimplePlugin*			i_pWritePlugin,
	LPVOID*					o_ppv
)
{
	HRESULT					hr;
	HRESULT					hrInterceptor = S_OK;

	// At least one plugin needs to be specified
	if(!(i_pInterceptorPlugin || i_pReadPlugin || i_pWritePlugin)) return E_INVALIDARG;

	m_spDispenser = i_pISTDisp;
	// Get the pointer to the undelying cache
	if(i_pInterceptorPlugin)
	{
		hr = i_pInterceptorPlugin->Intercept(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta,
				i_eQueryFormat, i_fLOS, i_pISTDisp, i_wszLocator, i_pv, (LPVOID *)&m_pWrite);
		if( (FAILED(hr)) && (E_ST_OMITLOGIC != hr)) 
			return hr;
		else
			hrInterceptor = hr;
	}
	else
	{	// i.e No interceptor plugin, this means we have to wire ourselfs on top of 
		// the provided table
		if (NULL == i_pv) return E_INVALIDARG;
		m_pWrite = (ISimpleTableWrite2 *)i_pv;
	}

	hr = m_pWrite->QueryInterface(IID_ISimpleTableController, (LPVOID *)&m_pController);		
	if(FAILED(hr)) return hr;
	ASSERT( hr == S_OK );
	// TODO what to do if we have an underlying table that doesn't implement all the interfaces?
	
	// Save the plugins for later use
	m_pInterceptorPlugin = i_pInterceptorPlugin;
	if(m_pInterceptorPlugin) m_pInterceptorPlugin->AddRef(); // the dispenser just passes the plugins in, we need to do an addref

	m_pReadPlugin = i_pReadPlugin;
	if(m_pReadPlugin) m_pReadPlugin->AddRef();

	m_pWritePlugin = i_pWritePlugin;
	if(m_pWritePlugin) m_pWritePlugin->AddRef();

	// Save did and tid and LOS
	m_wszDatabase = i_wszDatabase;
	m_wszTable    = i_wszTable;

    //ToDo:  We might be given a TableID instead of Database and TableName, if so we should get them from TFixedPackedSchemaInterceptor
	m_fLOS        = i_fLOS;

	// Returned a pointer to us since we are a table
	InterlockedIncrement((LONG *)&m_bInitialized);
	*o_ppv = (ISimpleTableWrite2 *)this;
	AddRef();

	return hrInterceptor;
}


// ------------------------------------
// ISimpleTableRead2
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::GetRowIndexByIdentity (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	return m_pWrite->GetRowIndexByIdentity (i_acbSizes, i_apvValues, o_piRow);
}
STDMETHODIMP CSTShell::GetRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	return m_pWrite->GetRowIndexBySearch(i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);
}
STDMETHODIMP CSTShell::GetColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
	return m_pWrite->GetColumnValues (i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
}
STDMETHODIMP CSTShell::GetTableMeta (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG* o_pcRows, ULONG* o_pcColumns )
{
	return m_pWrite->GetTableMeta (o_pcVersion, o_pfTable, o_pcRows, o_pcColumns);
}
STDMETHODIMP CSTShell::GetColumnMetas (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas )
{
	return m_pWrite->GetColumnMetas (i_cColumns, i_aiColumns, o_aColumnMetas);
}

// ------------------------------------
// ISimpleTableWrite2 
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::AddRowForDelete (ULONG i_iReadRow)
{
	return m_pWrite->AddRowForDelete (i_iReadRow);
}
STDMETHODIMP CSTShell::AddRowForInsert (ULONG* o_piWriteRow)
{
	return m_pWrite->AddRowForInsert (o_piWriteRow);
}
STDMETHODIMP CSTShell::AddRowForUpdate (ULONG i_iReadRow, ULONG* o_piWriteRow)
{
	return m_pWrite->AddRowForUpdate (i_iReadRow, o_piWriteRow);
}
STDMETHODIMP CSTShell::SetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues)
{
	return m_pWrite->SetWriteColumnValues (i_iRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues);
}
STDMETHODIMP CSTShell::GetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
	return m_pWrite->GetWriteColumnValues (i_iRow, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes, o_apvValues);
}

STDMETHODIMP CSTShell::GetWriteRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	return m_pWrite->GetWriteRowIndexBySearch(i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);
}

STDMETHODIMP CSTShell::GetErrorTable(DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
{
    return m_pWrite->GetErrorTable(i_fServiceRequests, o_ppvSimpleTable);
}

// ==================================================================
STDMETHODIMP CSTShell::UpdateStore ()
{
	HRESULT hr;
	DWORD eAction;
	ULONG iRow;
	BOOL  fHasDetailedError = FALSE;

	ASSERT(m_bInitialized);

	if(m_pWritePlugin)
	{
		for(iRow = 0; ; iRow++)
		{
			// Get the ro action
			hr = m_pController->GetWriteRowAction(iRow, &eAction);
			if(hr == E_ST_NOMOREROWS)
			{
				hr = S_OK;
				break;
			}

			switch(eAction)
			{	
			// call the appropriate plugin function
			case eST_ROW_INSERT:
				hr = m_pWritePlugin->OnInsert(m_spDispenser, m_wszDatabase, m_wszTable, m_fLOS, iRow, m_pWrite);
			break;
			case eST_ROW_UPDATE:
				hr = m_pWritePlugin->OnUpdate(m_spDispenser, m_wszDatabase, m_wszTable, m_fLOS, iRow, m_pWrite);
			break;
			case eST_ROW_DELETE:
				hr = m_pWritePlugin->OnDelete(m_spDispenser, m_wszDatabase, m_wszTable, m_fLOS, iRow, m_pWrite);
			break;
			default:
				ASSERT (eAction == eST_ROW_IGNORE);
			}

			if (FAILED (hr))
			{	// Add detailed error
				STErr ste;

				ste.iColumn = iST_ERROR_ALLCOLUMNS;
				ste.iRow = iRow;
				ste.hr = hr;

				TRACE (L"Detailed error: hr = 0x%x", hr);

				m_pController->AddDetailedError (&ste);
				fHasDetailedError = TRUE;
			}
		}
		if (fHasDetailedError)
		{
			TRACE (L"Detailed errors found during validation using WritePlugin");
			return E_ST_DETAILEDERRS;
		}
	}



	if(m_pInterceptorPlugin)
	{
		hr = m_pInterceptorPlugin->OnUpdateStore (m_pWrite);
	}
	else 
	{
		hr = m_pWrite->UpdateStore ();
	}

	if (SUCCEEDED(hr) && fHasDetailedError)
	{
		hr = E_ST_DETAILEDERRS ;
	}

	return hr;
}

// ------------------------------------
// ISimpleTableAdvanced:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::PopulateCache()
{
	HRESULT hr;
	ULONG iRow;
	BOOL fHasDetailedError = FALSE;

	ASSERT(m_bInitialized);

	if (m_pInterceptorPlugin)
	{
		hr = m_pInterceptorPlugin->OnPopulateCache (m_pWrite);
		if(FAILED(hr)) return hr;
	}
	else
	{
		hr = m_pController->PopulateCache();
		if(FAILED(hr)) return hr;
	}

	if (m_pReadPlugin)
	{
		ULONG cRows;

		hr = m_pWrite->GetTableMeta(NULL, NULL, &cRows, NULL);
		if(FAILED(hr)) return hr;
		
		hr = m_pController->PrePopulateCache(fST_POPCONTROL_RETAINREAD);
		if(FAILED(hr)) return hr;

		// Iterate the rows in the read cache
		for(iRow = 0; iRow < cRows; iRow++)
		{
			hr = m_pReadPlugin->OnInsert(m_spDispenser, m_wszDatabase, m_wszTable, m_fLOS, iRow, m_pWrite);
			if (FAILED (hr))
			{	// Add detailed error
				STErr ste;

				ste.iColumn = iST_ERROR_ALLCOLUMNS;
				ste.iRow = iRow;
				ste.hr = hr;

				m_pController->AddDetailedError (&ste);
				fHasDetailedError = TRUE;
			}
		}

		hr = m_pController->PostPopulateCache();
	}

	if (SUCCEEDED(hr) && fHasDetailedError)
	{
		hr = E_ST_DETAILEDERRS;
	}

	return hr;
}

// ==================================================================
STDMETHODIMP CSTShell::GetWriteRowIndexByIdentity (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	return m_pWrite->GetWriteRowIndexByIdentity (i_acbSizes, i_apvValues, o_piRow);
}
STDMETHODIMP CSTShell::GetDetailedErrorCount	(ULONG* o_pcErrs)
{
	return m_pController->GetDetailedErrorCount	(o_pcErrs);
}
STDMETHODIMP CSTShell::GetDetailedError (ULONG i_iErr, STErr* o_pSTErr)
{
	return m_pController->GetDetailedError (i_iErr, o_pSTErr);
}

// ------------------------------------
// ISimpleTableController:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::ShapeCache (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
{
	return m_pController->ShapeCache (i_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);
}
STDMETHODIMP CSTShell::PrePopulateCache (DWORD i_fControl)
{
	return m_pController->PrePopulateCache (i_fControl);
}
STDMETHODIMP CSTShell::PostPopulateCache	()
{
	return m_pController->PostPopulateCache();
}
STDMETHODIMP CSTShell::DiscardPendingWrites ()
{
	return m_pController->DiscardPendingWrites ();
}
STDMETHODIMP CSTShell::GetWriteRowAction	(ULONG i_iRow, DWORD* o_peAction)
{
	return m_pController->GetWriteRowAction	(i_iRow, o_peAction);
}
STDMETHODIMP CSTShell::SetWriteRowAction	(ULONG i_iRow, DWORD i_eAction)
{
	return m_pController->SetWriteRowAction	(i_iRow, i_eAction);
}
STDMETHODIMP CSTShell::ChangeWriteColumnStatus (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
{
	return m_pController->ChangeWriteColumnStatus (i_iRow, i_iColumn, i_fStatus);
}
STDMETHODIMP CSTShell::AddDetailedError (STErr* o_pSTErr)
{
	return m_pController->AddDetailedError (o_pSTErr);
}
STDMETHODIMP CSTShell::GetMarshallingInterface (IID * o_piid, LPVOID * o_ppItf)
{
	return m_pController->GetMarshallingInterface (o_piid, o_ppItf);
}

// ==================================================================
// helper function that gets an instance of this object
HRESULT CreateShell(IShellInitialize ** o_pSI)
{
	CSTShell*			p1 = NULL;

	p1 = new CSTShell;
	if(NULL == p1) return E_OUTOFMEMORY;
	return p1->QueryInterface (IID_IShellInitialize, (LPVOID*) o_pSI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\dispenser\cshell.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    cshell.h

$Header: $

--**************************************************************************/

#ifndef __CSHELL_INCLUDE_H_
#define __CSHELL_INCLUDE_H_

#include "catalog.h"
#include "sdtfst.h"
#include <atlbase.h>

class CSTShell:
	public ISimpleTableWrite2,
	public ISimpleTableController,
	public IShellInitialize
{
public:
	// IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release) 		();

	// ISimpleTableShellInitializer
	STDMETHOD (Initialize) (LPCWSTR	i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	i_eQueryFormat,
						DWORD i_fTable, IAdvancedTableDispenser* i_pISTDisp, LPCWSTR i_wszLocator, LPVOID i_pv, IInterceptorPlugin * i_pInterceptorPlugin,
						ISimplePlugin * i_pReadPlugin, ISimplePlugin * i_pWritePlugin, LPVOID * o_ppv);

	// ISimpleTableRead2
	STDMETHOD (GetRowIndexByIdentity) (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
	STDMETHOD (GetColumnValues) (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);
	STDMETHOD (GetTableMeta) (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG* o_pcRows, ULONG* o_pcColumns );
	STDMETHOD (GetColumnMetas)	(ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas );

	// ISimpleTableWrite2 
	STDMETHOD (AddRowForDelete) (ULONG i_iReadRow);
	STDMETHOD (AddRowForInsert) (ULONG* o_piWriteRow);
	STDMETHOD (AddRowForUpdate) (ULONG i_iReadRow, ULONG* o_piWriteRow);
	STDMETHOD (SetWriteColumnValues) (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues);
	STDMETHOD (GetWriteColumnValues) (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, 
										DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);
	STDMETHOD (GetWriteRowIndexByIdentity) (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
	STDMETHOD (GetWriteRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetErrorTable)(DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable);

	STDMETHOD (UpdateStore) ();
	
	// ISimpleTableAdvanced:
	STDMETHOD (PopulateCache) ();
	STDMETHOD (GetDetailedErrorCount) (ULONG* o_pcErrs);
	STDMETHOD (GetDetailedError) (ULONG i_iErr, STErr* o_pSTErr);

	// ISimpleTableController:
	STDMETHOD (ShapeCache) (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes);
	STDMETHOD (PrePopulateCache) (DWORD i_fControl);
	STDMETHOD (PostPopulateCache)	();
	STDMETHOD (DiscardPendingWrites) ();
	STDMETHOD (GetWriteRowAction)	(ULONG i_iRow, DWORD* o_peAction);
	STDMETHOD (SetWriteRowAction)	(ULONG i_iRow, DWORD i_eAction);
	STDMETHOD (ChangeWriteColumnStatus) (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus);
	STDMETHOD (AddDetailedError) (STErr* o_pSTErr);
	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf);

public:
	CSTShell ();
	~CSTShell ();

private:
	ULONG   m_cRef;
	DWORD   m_bInitialized;
	LPCWSTR m_wszDatabase;
	LPCWSTR m_wszTable;
	DWORD	m_fLOS;

	CComPtr<ISimpleTableDispenser2> m_spDispenser;
	ISimpleTableWrite2 *m_pWrite;
	ISimpleTableController *m_pController;
	IInterceptorPlugin *m_pInterceptorPlugin;
	ISimplePlugin *m_pReadPlugin;
	ISimplePlugin *m_pWritePlugin;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\dispenser\cdllmap.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    cdllmap.cpp

$Header: $

--**************************************************************************/

#include "objbase.h"
#include "cstdisp.h"
#include "catmacros.h"
#include "safecs.h"

// the lock used by catalog.dll
extern CSafeAutoCriticalSection g_csSADispenser;

CDllMap::CDllMap()
{
	m_iFree = 0;
	memset(m_awszDllName, 0, CDLLMAPMAXCOUNT*sizeof(LPWSTR));
	memset(m_apfn, 0, CDLLMAPMAXCOUNT*sizeof(PFNDllGetSimpleObjectByID));
}

HRESULT CDllMap::GetProcAddress(LPWSTR wszDllName, PFNDllGetSimpleObjectByID *o_ppfnDllGetSimpleObject)
{
	HRESULT hr;
	ULONG i, iFree;
	
	// Parameter validation
	ASSERT( wszDllName );
	if (!wszDllName) 
		return E_INVALIDARG;

	ASSERT( o_ppfnDllGetSimpleObject );
	if (!o_ppfnDllGetSimpleObject) 
		return E_INVALIDARG;

	// make a copy of m_iFree on the stack
	iFree = m_iFree;

	// First look in the map
	for( i = 0; i<iFree; i++)
	{
		if (0 == ::wcscmp(wszDllName, m_awszDllName[i]))
		{
			*o_ppfnDllGetSimpleObject = m_apfn[i];
			return S_OK;
		}
	}

	// We didn't find the dll in the map - we need to load it
	TRACE (L"%s was not found in the map", wszDllName);
	
	// take a lock
	CSafeLock dispenserLock (&g_csSADispenser);
	DWORD dwRes = dispenserLock.Lock ();
	if(ERROR_SUCCESS != dwRes)
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	if(iFree != m_iFree) 
	{
		// somebody else added the dll's to the map - check again
		for(i = iFree; i<m_iFree; i++)
		{
			if (0 == ::wcscmp(wszDllName, m_awszDllName[i]))
			{
				*o_ppfnDllGetSimpleObject = m_apfn[i];
				
				return S_OK;
			}
		}
	}
	
	// Load the dll in the map
	hr = Load(wszDllName, o_ppfnDllGetSimpleObject);
	
	return hr;
}


HRESULT CDllMap::Load(LPWSTR wszDllName, PFNDllGetSimpleObjectByID *o_ppfnDllGetSimpleObject)
{
	*o_ppfnDllGetSimpleObject = 0;

	// Load the library 
	HINSTANCE handle = LoadLibrary (wszDllName);
	if(NULL == handle)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// get the address of DllGetSimpleObject procedure
	m_apfn[m_iFree] = (PFNDllGetSimpleObjectByID) ::GetProcAddress (handle, "DllGetSimpleObjectByID");
	if(NULL == 	m_apfn[m_iFree])
	{
		FreeLibrary(handle);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// The caller has to hold on to the pointers
	m_awszDllName[m_iFree] = wszDllName;
	*o_ppfnDllGetSimpleObject = m_apfn[m_iFree];

	m_iFree++;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catinproc_testcfg\catinproc.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CatInproc.cpp

$Header: $

Abstract:

--**************************************************************************/

// CATALOG DLL exported functions: Search on HOWTO in this file and sources to integrate new interceptors:
#include <atlbase.h>
#include <dbgutil.h>
#include <initguid.h>
#include <iadmw.h>
#include <objbase.h>
#include "CorRegServices.h"								// For MSCORDDR.LIB

// HOWTO: Include your header here:
#include "sdtfst.h"	
#include "..\dispenser\cstdisp.h"						// Table dispenser.
#include "..\..\stores\ErrorTable\ErrorTable.h"         // ErrorTable interceptor.
#include "..\..\stores\xmltable\Metabase_XMLtable.h"    // Metabase XML interceptor.
#include "..\..\Plugins\MetabaseDifferencing\MetabaseDifferencing.h"	// Metabase Differencing Interceptor.
#include "..\..\stores\fixedtable\sdtfxd.h"				// Fixed interceptor.
#include "..\..\stores\fixedschemainterceptor\FixedPackedSchemaInterceptor.h"	// FixedPackedSchemaInterceptor.
#include "..\eventtable\sltevent.h"						// Event interceptor.
#include "..\..\URT\DTWriteIncptr\DTWriteIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTIncptr\DTIncptr.h"				// Ducttape FileName interceptor.
#include "..\..\URT\DTPlugin\DTPlugin.h"				// Ducttape Logic plugin for CFG tables.
#include "smartpointer.h"

#ifdef URT
#include "..\..\stores\xmltable\sdtxml.h"		        // XML interceptor.
#include "..\..\stores\fixedtable\metamerge.h"			// MetaMerge interceptor.
#include "..\..\stores\mergeinterceptor\interceptor\mergeinterceptor.h"
#include "..\..\Plugins\AddRemoveClear\AddRemoveClearPlugin.h"
#endif

#ifdef APPCENTER
#include "..\..\stores\asaitable\asaitable.h"		        // ASAI interceptor.
#endif

#include "winwrap.h"
#include "Hash.h"
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif

// Debugging stuff
// {76C72796-3D46-4882-A25E-2465A9D877A2}
DEFINE_GUID(CatalogGuid, 
0x76c72796, 0x3d46, 0x4882, 0xa2, 0x5e, 0x24, 0x65, 0xa9, 0xd8, 0x77, 0xa2);
DECLARE_DEBUG_PRINTS_OBJECT();

// Extern functions:
extern HRESULT SdtClbOnProcessAttach();
extern void SdtClbOnProcessDetach();
#ifdef URT
extern void AssemblyPluginOnProcessDetach();
#endif
extern BOOL OnUnicodeSystem();
extern HRESULT GetCLBTableDispenser(REFIID riid, LPVOID* o_ppv);

//This heap really needs to be located on a page boundary for perf and workingset reasons.  The only way in VC5 and VC6 to guarentee this
//is to locate it into its own data segment.  In VC7 we might be able to use '__declspec(align(4096))' tp accomplish the same thing.
#pragma data_seg( "TSHEAP" )
ULONG g_aFixedTableHeap[ CB_FIXED_TABLE_HEAP/sizeof(ULONG)]={kFixedTableHeapSignature0, kFixedTableHeapSignature1, kFixedTableHeapKey, kFixedTableHeapVersion, CB_FIXED_TABLE_HEAP};
#pragma data_seg()

// Global variables:
HMODULE					g_hModule = 0;					// Module handle
TSmartPointer<CSimpleTableDispenser> g_pSimpleTableDispenser; // Table dispenser singleton
CSafeAutoCriticalSection g_csSADispenser;					// Critical section for initializing table dispenser

extern LPWSTR g_wszDefaultProduct;//located in svcerr.cpp

// Get* functions:
// HOWTO: Add your Get* function for your simple object here:

HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetDucttapeCFGValidationPlugin (REFIID riid, LPVOID* o_ppv);
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv);

#ifdef URT
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetMergeInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv);
#endif

#ifdef APPCENTER
HRESULT GetASAIInterceptor (REFIID riid, LPVOID* o_ppv);
#endif


// ============================================================================
HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// The dispenser is a singleton: Only create one object of this kind:
	if(g_pSimpleTableDispenser == 0)
	{
		HRESULT hr = S_OK;

		CSafeLock dispenserLock (&g_csSADispenser);
		DWORD dwRes = dispenserLock.Lock ();
	    if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

		if(g_pSimpleTableDispenser == 0)
		{
		// Create table dispenser:
			g_pSimpleTableDispenser = new CSimpleTableDispenser(i_wszProduct);
			if(g_pSimpleTableDispenser == 0)
			{
				return E_OUTOFMEMORY;
			}

		// Addref table dispenser so it never releases:
			g_pSimpleTableDispenser->AddRef();
			if(S_OK == hr)
			{
			// Initialize table dispenser:
				hr = g_pSimpleTableDispenser->Init(); // NOTE: Must never throw exceptions here!
			}
		}	
		if(S_OK != hr) return hr;
	}
	return g_pSimpleTableDispenser->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabase_XMLtable*	p = NULL;

	p = new TMetabase_XMLtable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#ifdef IIS
// don't need this for URT
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabaseDifferencing*	p = NULL;

	p = new TMetabaseDifferencing;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSDTFxd*	p = NULL;
	
	p = new CSDTFxd;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CMemoryTable*	p = NULL;
	
	p = new CMemoryTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#ifdef IIS
//Only IIS uses ducttape
// ============================================================================
HRESULT GetDucttapeFileNameInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTIncptr*	p = NULL;
	
	p = new CDTIncptr;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetDucttapeWriteInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CDTWriteInterceptorPlugin*	p = NULL;
	
	p = new CDTWriteInterceptorPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetDucttapeCFGValidationPlugin(REFIID riid, LPVOID* o_ppv)
{
	CDTPlugin*	p = NULL;
	
	p = new CDTPlugin;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
#endif
// ============================================================================
HRESULT GetEventTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSLTEvent	*p = NULL;
	
	p = new CSLTEvent;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv)
{
	TFixedPackedSchemaInterceptor*	p = NULL;
	
	p = new TFixedPackedSchemaInterceptor;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv)
{
	ErrorTable*	p = NULL;
	
	p = new ErrorTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================

#ifdef URT
// ============================================================================
HRESULT GetXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CXmlSDT*	p = NULL;

	p = new CXmlSDT;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetAssemblyInterceptor (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyPlugin*	p = NULL;
	//
    //	p = new CAssemblyPlugin;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

// ============================================================================
HRESULT GetAssemblyInterceptor2 (REFIID riid, LPVOID* o_ppv)
{
	//CAssemblyTable*	p = NULL;
	//
	//p = new CAssemblyTable;
	//if(NULL == p) return E_OUTOFMEMORY;
    //
    //	return p->QueryInterface (riid, o_ppv);
	return E_NOTIMPL;
}

HRESULT GetMetaMergeInterceptor (REFIID riid, LPVOID* o_ppv)
{
	CSDTMetaMerge*	p = NULL;
	
	p = new CSDTMetaMerge;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

HRESULT GetMergeInterceptor (REFIID riid, LPVOID *o_ppv)
{
	// merge interceptor is a singleton
	static CMergeInterceptor mergeInterceptor;

	return mergeInterceptor.QueryInterface (riid, o_ppv);
}

HRESULT GetAddRemoveClearPlugin (REFIID riid, LPVOID* o_ppv)
{
	CAddRemoveClearPlugin *	p = new CAddRemoveClearPlugin;
	if(NULL == p) 
		return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

#endif

#ifdef APPCENTER

HRESULT GetASAIInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CAsaiTable*	p = NULL;

	p = new CAsaiTable;
	if(NULL == p) return E_OUTOFMEMORY;
	
	return p->QueryInterface (riid, o_ppv);
}

#endif

STDAPI DllGetSimpleObject (LPCWSTR /*i_wszObjectName*/, REFIID riid, LPVOID* o_ppv)
{
    return ReallyGetSimpleTableDispenser(riid, o_ppv, g_wszDefaultProduct);
}

// ============================================================================
// DllGetSimpleObject: Get table dispenser, interceptors, plugins, and other simple objects:
// HOWTO: Match your object name here and call your Get* function:
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv)
{
	HRESULT hr; 

// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	switch(i_ObjectID)
	{
		case eSERVERWIRINGMETA_Core_FixedInterceptor:
			hr = GetFixedTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses CLB
		case eSERVERWIRINGMETA_Core_ComplibInterceptor:
			hr = GetCLBTableDispenser(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_XMLInterceptor:
			hr = GetXMLTableInterceptor(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_EventInterceptor:
			hr = GetEventTableInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_MemoryInterceptor:
			hr = GetMemoryTableInterceptor(riid, o_ppv);
		break;
#ifdef URT
		// only IIS uses AssemblyInterceptor
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor:
			hr = GetAssemblyInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_AssemblyInterceptor2:
			hr = GetAssemblyInterceptor2(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_Core_FixedPackedInterceptor:
			hr = GetFixedPackedInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Core_DetailedErrorInterceptor:
			hr = GetErrorTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
// only IIS uses ducttape
		case eSERVERWIRINGMETA_Ducttape_FileNameInterceptor:
			hr = GetDucttapeFileNameInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_Ducttape_WriteInterceptor:
			hr = GetDucttapeWriteInterceptor(riid, o_ppv);
		break;
		case eSERVERWIRINGMETA_WebServer_ValidationInterceptor:
			hr = GetDucttapeCFGValidationPlugin(riid, o_ppv);
		break;
#endif
		case eSERVERWIRINGMETA_TableDispenser:
            //Old Cat.libs use this - new Cat.libs should be calling DllGetSimpleObjectByIDEx below for the TableDispenser
			hr = ReallyGetSimpleTableDispenser(riid, o_ppv, 0);
		break;
		case eSERVERWIRINGMETA_Core_MetabaseInterceptor:
			hr = GetMetabaseXMLTableInterceptor(riid, o_ppv);
		break;
#ifdef IIS
		// only IIS uses metabasedifferencinginterceptor
		case eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor:
			hr = GetMetabaseDifferencingInterceptor(riid, o_ppv);
		break;
#endif
#ifdef URT
		case eSERVERWIRINGMETA_Core_MetaMergeInterceptor:
			hr = GetMetaMergeInterceptor(riid, o_ppv);

		break;
		case eSERVERWIRINGMETA_Core_MergeInterceptor:
			hr = GetMergeInterceptor (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearReadPlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_AddRemoveClearWritePlugin:
			hr = GetAddRemoveClearPlugin (riid, o_ppv);
		break;
#endif
#ifdef APPCENTER
		case eSERVERWIRINGMETA_AppCenter_ASAIInterceptor:
			hr = GetASAIInterceptor(riid, o_ppv);
		break;
#endif
		default:
			return CLASS_E_CLASSNOTAVAILABLE;
	}
	return hr;
}


STDAPI DllGetSimpleObjectByIDEx (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

// Get simple object:
	if(eSERVERWIRINGMETA_TableDispenser == i_ObjectID)
		return ReallyGetSimpleTableDispenser(riid, o_ppv,i_wszProduct);
    else
        return DllGetSimpleObjectByID(i_ObjectID, riid, o_ppv);
}


// ============================================================================
// DllMain: Global initialization:
extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID /*lpReserved*/)
{
	HRESULT hr;
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		CREATE_DEBUG_PRINT_OBJECT("Config", CatalogGuid);

		g_hModule = hModule;
		g_wszDefaultProduct = PRODUCT_DEFAULT;

		DisableThreadLibraryCalls(hModule);

		OnUnicodeSystem();

#ifdef IIS
		// Only IIS uses CLB
		hr = SdtClbOnProcessAttach(); // initialize complib engine
		if ( FAILED(hr) )
		  return FALSE;
#endif

		return TRUE;

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef IIS
		// only IIS uses CLB
		SdtClbOnProcessDetach(); //clb data table cleanup
#endif
		// we don't suppor assembly plugin's anymore
//		AssemblyPluginOnProcessDetach(); //assembly plugin cleanup
		DELETE_DEBUG_PRINT_OBJECT();
	}

	return TRUE;    // OK
}

// ============================================================================
// GetModuleInst: For using MSCORDDR.LIB
HINSTANCE GetModuleInst()
{
	return (g_hModule);
}

// ============================================================================
// Classic COM entry points (not currently employed):
STDAPI DllCanUnloadNow(void)
{
	return S_FALSE; // Not supported
}
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return CLASS_E_CLASSNOTAVAILABLE; 	// No com+ components in this dll for now
}
STDAPI DllRegisterServer(void)
{
	return S_OK; // Nothing to do here
}
STDAPI DllUnregisterServer(void)
{
	return S_OK; // Nothing to do here
}

// ============================================================================
// Wrappers for util functions 
void Trace(const wchar_t* szPattern, ...);
int Assert2(const wchar_t * szString, const wchar_t * szStack);

extern "C" void __stdcall ManagedTrace(LPWSTR wszMessage)
{
	Trace(L"%s", wszMessage);
}

extern "C" int __stdcall ManagedAssert(LPWSTR wszMessage, LPWSTR wszStack)
{
	return Assert2(wszMessage, wszStack);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\catutil\main.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
//#define INITGUID
#include "..\schemagen\XMLUtility.h"
#include "Catalog42Ver.h"
#include "__product__.ver"
#include "atlimpl.cpp"
#include <initguid.h>

#include "..\..\stores\FixedSchemaInterceptor\TableSchema.cpp"

// Debugging stuff
// {559943BA-6883-4fab-9AC3-BA50A1D7796E}
DEFINE_GUID(CatutilGuid, 
0x559943ba, 0x6883, 0x4fab, 0x9a, 0xc3, 0xba, 0x50, 0xa1, 0xd7, 0x79, 0x6e);
DECLARE_DEBUG_PRINTS_OBJECT();

class CDebugInit
{
public:
    CDebugInit(LPCSTR szProd, const GUID* pGuid)
    {
        CREATE_DEBUG_PRINT_OBJECT(szProd, *pGuid);
    }
    ~CDebugInit()
    {
        DELETE_DEBUG_PRINT_OBJECT();
    }
};

#pragma warning(disable : 4800)

wchar_t g_szProgramVersion[255];

static wchar_t *szProgramHelp[]={
L"Catalog Utility - Version %d.%02d.%02d Build(%d)",
L"\r\n%s\r\n\r\n",
L"This program has two purposes surrounding XML and the Catalog:                 \r\n",
L"        1)  Validating XML File - This is useful for any XML file whether      \r\n",
L"            related to Catalog or not.                                         \r\n",
L"        2)  Compiling - This refers to the Compiling of Catalog Meta and Wiring\r\n",
L"            into the following files: An Unmanaged C++ Header, The Catalog XML \r\n",
L"            Schema (xms) file and The Catalog Dynamic Link Library.            \r\n",
L"                                                                               \r\n",
L"CatUtil [/?] [Validate] [/Compile] [/meta=[CatMeta.xml]] [/wire=[CatWire.xml]] \r\n",
L"        [/header=[CatMeta.h]] [/schema=[Catalog.xms]] [/dll=[Catalog.dll]]     \r\n",
L"        [/mbmeta=[MBMeta.xml]] [xmlfilename]                                   \r\n",
L"                                                                               \r\n",
L"? - Brings up this help screen.                                                \r\n",
L"                                                                               \r\n",
L"validate - Will indicate whether the given file is 'Valid' according to its DTD\r\n",
L"        or XML Schema.  This requires an 'xmlfilename'.                        \r\n",
L"                                                                               \r\n",
L"xmlfilename - If specified with no other options, the XML file will be checked \r\n",
L"        for 'Well-Formity'.                                                    \r\n",
L"                                                                               \r\n",
L"product - Associates the dll with the given product name.  The Product Name    \r\n",
L"        must be supplied.  This association MUST be done before the Catalog may\r\n",
L"        be used with the given product.                                        \r\n",
L"                                                                               \r\n",
L"compile - Compile of Catalog Meta and Wiring as described above, using deaults \r\n",
L"        where no values are supplied.  To do a partial compile (ie only        \r\n",
L"        generate the Unmanaged C++ Header) do NOT specify the 'Compile' option \r\n",
L"        and only specify the 'meta' and 'header' options.  'Compile' is the    \r\n",
L"        same as '/meta /wire /header /schema /dll' where any of those flags    \r\n",
L"        explicitly specified may override the defaults.                        \r\n",
L"                                                                               \r\n",
L"mbmeta - Specifies the Metabase Meta XML file.  The default is MBMeta.xml.     \r\n",
L"             This is an input only file and will not be modified               \r\n",
L"meta   - Specifies the Catalog Meta XML file.  The default is CatMeta.xml.     \r\n",
L"             This is an input only file and will not be modified               \r\n",
L"wire   - Specifies the Catalog Wiring XML file.  The default is CatWire.xml.   \r\n",
L"             This is an input only file and will not be modified               \r\n",
L"header - Specifies the Unmanaged C++ Header file.  The default is CatMeta.h.   \r\n",
L"             This is an input/output file and will be updated only if changed. \r\n",
L"schema - Specifies the Catalog XML Schema file.  The default is Catalog.xms.   \r\n",
L"             This is an output file and will overwrite a previous version.     \r\n",
L"dll    - Specifies the Catalog DLL file.  The default is Catalog.dll.          \r\n",
L"             This is an input/output file and will update the previous version.\r\n",
L"             Either the 'compile' or 'product' option must be specified along  \r\n",
L"             with the 'dll' option.                                            \r\n",
L"config - Specifies the Machine Config Directory.                               \r\n",
L"             The 'product' option must be specified along with the 'config'    \r\n",
L"             option.                                                           \r\n",
L"verbose - This generates detailed output about the compilation                 \r\n",
L"                                                                               \r\n",
L"\r\n", 0};


enum
{
    iHelp,
    iValidate,
    iCompile,
    iMeta,
    iWire,
    iHeader,
    iSchema,
    iDll,
    iProduct,
    iConfig,
    iMBMeta,
    iVerbose,
    cCommandLineSwitches
};
wchar_t * CommandLineSwitch[cCommandLineSwitches]  ={L"?"  , L"validate", L"compile", L"meta", L"wire", L"header", L"schema", L"dll" , L"product" , L"config", L"mbmeta", L"verbose"};
int       kCommandLineSwitch[cCommandLineSwitches] ={0x8000, 0x01       , 0x7e      , 0x02   , 0x66   , 0x0a     , 0x12     , 0x00   , 0x80       , 0x00     , 0x100    , 0x0200}; 
//Each of the above bits dictates an action.  Which is NOT necessarily a 1 to 1 relation to the command line switch.

const int MinNumCharsInSwitch = 3;//From the command line the user only needs to use the first 3 charaters of the switch
enum
{
    eParseForWellFormedOnly = 0x0000,
    eHelp                   = 0x8000,
    eValidateXMLFile        = 0x0001,
    eValidateMeta           = 0x0002,
    eValidateWiring         = 0x0004,
    eHeaderFromMeta         = 0x0008,
    eSchemaFromMeta         = 0x0010,
    eMetaFixup              = 0x0020,
    eFixedTableFixup        = 0x0040,
    eProduct		        = 0x0080,
    eGenerateMBMetaBin      = 0x0100,
    eVerbose                = 0x0200
};

LPCWSTR wszDefaultOption[cCommandLineSwitches] =
{
    0//no file associated with help
    ,0//no default file associated with validate (the last parameter is considered the XML file; no default)
    ,0//no file associated with compile
    ,L"CatMeta.xml"
    ,L"CatWire.xml"
    ,L"CatMeta.h"
    ,L"Catalog.xms"
    ,L"Catalog.dll"
    ,0
    ,0
    ,L"MBSchema.xml"
    ,0
};

void GetOption(LPCWSTR wszCommandLineSwitch, LPCWSTR &wszOption, LPCWSTR wszDefaultOption)
{
    while(*wszCommandLineSwitch != L'=' && *wszCommandLineSwitch != 0x00)//advance to the '='
        ++wszCommandLineSwitch;
    if(*wszCommandLineSwitch != L'=')//if no '=' then use the dafault
        wszOption = wszDefaultOption;
    else
        wszOption = ++wszCommandLineSwitch;//now point past the '='
}


HRESULT ParseCommandLine(int argc, wchar_t *argv[ ], DWORD &dwCommandLineSwitches, LPCWSTR wszOption[cCommandLineSwitches])
{
    if(argc < 2)//we must have been passed at least the filename
        return E_INVALIDARG;
    if(argc > (cCommandLineSwitches + 2))//we must not be passed more than ALL of the switches
        return E_INVALIDARG;

    dwCommandLineSwitches = 0x00;
    for(int q=0; q<cCommandLineSwitches; q++)
        wszOption[q] = wszDefaultOption[q];//start with all of the default filenames

    for(int n=1;n<argc;n++)
        if(*argv[n] == '/' || *argv[n] == '-')//only acknowledge those command lines that begin with a '/' or a '-'
        {
            for(int i=0; i<cCommandLineSwitches; i++)
                if(0 == wcsncmp(&argv[n][1], CommandLineSwitch[i], MinNumCharsInSwitch))//Compare the first MinNumCharsInSwitch characters
                {
                    dwCommandLineSwitches |= kCommandLineSwitch[i];
                    switch(i)
                    {
                    case iValidate: //This option does not have a '=filename' option but if one is given we will accept it
                    case iMeta:
                    case iWire:
                    case iHeader:
                    case iSchema:
                    case iDll:
                    case iConfig:
                    case iMBMeta:
                        GetOption(argv[n], wszOption[i], wszDefaultOption[i]);
                        break;
                    case iProduct:
                        GetOption(argv[n], wszOption[i], wszDefaultOption[i]);
                        if(0 == wszOption[i])//if a Product is not specified then bail
                            return E_FAIL;
                        break;
                    case iHelp:     //This option does not have a '=filename' option
                    case iCompile:  //We should already be setup for defaults
                    case iVerbose:
                    default:
                        break;
                    }
                    break;
                }
            if(i == cCommandLineSwitches)
                return E_FAIL;//an unknown switch was specified so bail
        }
        else//assume any parameter without a leading '/' or '-' is the XML file name
            wszOption[iValidate] = argv[n];

    //We should have covered this case
    if(eParseForWellFormedOnly == dwCommandLineSwitches && 0 == wszOption[iValidate])
        return E_FAIL;

    return S_OK;
}

HINSTANCE g_hModule=0;

extern "C" int __cdecl wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
{
    CDebugInit dbgInit("Catutil", &CatutilGuid);

    TCom            com;
    TScreenOutput   Screen;
    TDebugOutput    DebugOutput;
    DWORD           dwCommandLineSwitches = 0;
    try
    {
        TOutput *   pOutput = &DebugOutput;
        g_hModule = GetModuleHandle(0);

        int i=0;
        Screen.printf(szProgramHelp[i++], VER_PRODUCTVERSION);
        Screen.printf(szProgramHelp[i++], TEXT(VER_LEGALCOPYRIGHT_STR));

        wsprintf(g_szProgramVersion, szProgramHelp[0], VER_PRODUCTVERSION);
        
        LPCWSTR wszFilename[cCommandLineSwitches] = {0};//Most of the switches can have an '=filename' following, but /regsiter has an '=Product',
        LPCWSTR &wszProduct = wszFilename[iProduct];//This isn't really a filename like the rest.

        if(FAILED(ParseCommandLine(argc, argv, dwCommandLineSwitches, wszFilename)) || dwCommandLineSwitches & eHelp)
        {
            //If fialed to parse OR /? was specified then display help and exit
            while(szProgramHelp[i])
                Screen.printf(szProgramHelp[i++]);
            return 0;
        }

        //Now that we have all of the filenames and other options, we need to expand any environment variables passed in
        WCHAR   Filename[cCommandLineSwitches][MAX_PATH];
        for(i=0;i<cCommandLineSwitches; ++i)
        {
            if(wszFilename[i])//if it's NULL then leave it NULL
            {
                ExpandEnvironmentStrings(wszFilename[i], Filename[i], MAX_PATH);
                wszFilename[i] = Filename[i];
            }
        }
        if(eVerbose & dwCommandLineSwitches)
            pOutput = &Screen;

        if(eParseForWellFormedOnly == dwCommandLineSwitches || eValidateXMLFile & dwCommandLineSwitches)
        {
            TXmlFile xml;
            xml.Parse(wszFilename[iValidate], static_cast<bool>(dwCommandLineSwitches & eValidateXMLFile));
        }

        if(dwCommandLineSwitches & eGenerateMBMetaBin)
        {
            DWORD dwStartingTickCount = GetTickCount();
            TCatalogDLL catalogDll(wszFilename[iDll]);
            const FixedTableHeap *pShippedSchemaHeap = catalogDll.LocateTableSchemaHeap(*pOutput);

            CComPtr<ISimpleTableDispenser2> pISTDispenser;
            XIF(GetSimpleTableDispenser(L"IIS", 0, &pISTDispenser));

            TMetabaseMetaXmlFile mbmeta(pShippedSchemaHeap, wszFilename[iMBMeta], pISTDispenser, *pOutput);
            mbmeta.Dump(TDebugOutput());//Dump the tables before they're inferred

            TMetaInferrence().Compile(mbmeta, *pOutput);
            mbmeta.Dump(TDebugOutput());//Dump the tables after the inferrence

            THashedPKIndexes hashedPKIndexes;
            hashedPKIndexes.Compile(mbmeta, *pOutput);

            THashedUniqueIndexes hashedUniqueIndexes;
            hashedUniqueIndexes.Compile(mbmeta, *pOutput);

            TLateSchemaValidate lateschemavalidate;
            lateschemavalidate.Compile(mbmeta, *pOutput);

            mbmeta.Dump(TDebugOutput());//Dump the tables after the inferrence
            TWriteSchemaBin(L"MBSchema.bin").Compile(mbmeta, *pOutput);

            DWORD dwEndingTickCount = GetTickCount();
            pOutput->printf(L"HeapColumnMeta       %8d bytes\n", mbmeta.GetCountColumnMeta()          * sizeof(ColumnMeta)        );
            pOutput->printf(L"HeapDatabaseMeta     %8d bytes\n", mbmeta.GetCountDatabaseMeta()        * sizeof(DatabaseMeta)      );
            pOutput->printf(L"HeapHashedIndex      %8d bytes\n", mbmeta.GetCountHashedIndex()         * sizeof(HashedIndex)       );
            pOutput->printf(L"HeapIndexMeta        %8d bytes\n", mbmeta.GetCountIndexMeta()           * sizeof(IndexMeta)         );
            pOutput->printf(L"HeapQueryMeta        %8d bytes\n", mbmeta.GetCountQueryMeta()           * sizeof(QueryMeta)         );
            pOutput->printf(L"HeapRelationMeta     %8d bytes\n", mbmeta.GetCountRelationMeta()        * sizeof(RelationMeta)      );
            pOutput->printf(L"HeapServerWiringMeta %8d bytes\n", mbmeta.GetCountServerWiringMeta()    * sizeof(ServerWiringMeta)  );
            pOutput->printf(L"HeapTableMeta        %8d bytes\n", mbmeta.GetCountTableMeta()           * sizeof(TableMeta)         );
            pOutput->printf(L"HeapTagMeta          %8d bytes\n", mbmeta.GetCountTagMeta()             * sizeof(TagMeta)           );
            pOutput->printf(L"HeapULONG            %8d bytes\n", mbmeta.GetCountULONG()               * sizeof(ULONG)             );
            pOutput->printf(L"HeapPooled           %8d bytes\n", mbmeta.GetCountOfBytesPooledData()                               );
            pOutput->printf(L"Total time to build the %s file: %d milliseconds\n", wszFilename[iMBMeta], dwEndingTickCount - dwStartingTickCount);
        }

        if(dwCommandLineSwitches & (eValidateMeta | eValidateWiring | eHeaderFromMeta | eSchemaFromMeta | eMetaFixup | eFixedTableFixup) && !(dwCommandLineSwitches & eProduct))
        {
            TXmlFile xml[0x20];//We don't support more than 0x20 meta files
            int      iXmlFile=0;

            WCHAR    MetaFiles[MAX_PATH * 0x20];
            wcscpy(MetaFiles, wszFilename[iMeta]);
            LPWSTR token = wcstok( MetaFiles, L",");
            while( token != NULL )
            {
                xml[iXmlFile].Parse(token, true);//Parse and validate

                if(!xml[iXmlFile].IsSchemaEqualTo(TComCatMetaXmlFile::m_szComCatMetaSchema))
                {
                    Screen.printf(L"Error! %s is not a valid %s.  This is required for any type of Compilation.", token, TComCatMetaXmlFile::m_szComCatMetaSchema);
                    THROW(ERROR - META XML FILE NOT VALID);
                }
                ++iXmlFile;
                token = wcstok( NULL, L",");
            }

            pOutput->printf(L"Compatible %s file detected\n", TComCatMetaXmlFile::m_szComCatMetaSchema);
        
            TComCatMetaXmlFile ComCatMeta(xml, iXmlFile, *pOutput);
            ComCatMeta.Dump(TDebugOutput());//Dump the tables before they're inferred
            TMetaInferrence().Compile(ComCatMeta, *pOutput);
            ComCatMeta.Dump(TDebugOutput());//Dump the tables after the inferrence

            THashedPKIndexes hashedPKIndexes;
            hashedPKIndexes.Compile(ComCatMeta, *pOutput);

            THashedUniqueIndexes hashedUniqueIndexes;
            hashedUniqueIndexes.Compile(ComCatMeta, *pOutput);

            TPopulateTableSchema populatedTableSchemaHeap;
            populatedTableSchemaHeap.Compile(ComCatMeta, *pOutput);

            TLateSchemaValidate lateschemavalidate;
            lateschemavalidate.Compile(ComCatMeta, *pOutput);

            //Schema generation should come before anything else since other options may be dependant on it
            if(dwCommandLineSwitches & eSchemaFromMeta)
                TSchemaGeneration(wszFilename[iSchema], ComCatMeta, *pOutput);//the construction of this object creates the schema files

            if((dwCommandLineSwitches & eFixedTableFixup) && !(dwCommandLineSwitches & eProduct))
            {
                if(-1 == GetFileAttributes(wszFilename[iWire]))//if GetFileAttributes fails then the file does not exist
                {
                    Screen.printf(L"Information:  File %s does not exist.  Nothing to do.", wszFilename[iWire]);
                }
                else
                {
                    TComCatDataXmlFile ComCatData;//Update the PEFixup structure with these tables
                    ComCatData.Parse(wszFilename[iWire], true);
                    if(!ComCatData.IsSchemaEqualTo(TComCatDataXmlFile::m_szComCatDataSchema))
                        Screen.printf(L"Warning! %s specified, but %s is not a %s file.  Nothing to do.", CommandLineSwitch[iMeta], wszFilename[iWire], TComCatDataXmlFile::m_szComCatDataSchema);
                    else
                    {
                        ComCatData.Compile(ComCatMeta, *pOutput);
                        ComCatData.Dump(TDebugOutput());
                    }
                }
            }
            if(dwCommandLineSwitches & eHeaderFromMeta)
                TTableInfoGeneration(wszFilename[iHeader], ComCatMeta, *pOutput);//the construction of this object creates the TableInfo file
            if(dwCommandLineSwitches & eMetaFixup)
            {
                //The only time we need to to the interceptor compilation plugins is when we're actually planning to update the DLL
                TComplibCompilationPlugin complibPlugin;
                complibPlugin.Compile(ComCatMeta, *pOutput);

                TFixupDLL fixupDll(wszFilename[iDll]);//The construction of this object causes the DLL to be fixed up
                fixupDll.Compile(ComCatMeta, *pOutput);
            }

            {
                ULONG cBytes = ComCatMeta.GetCountDatabaseMeta() * sizeof(DatabaseMeta);         
                cBytes +=      ComCatMeta.GetCountTableMeta()    * sizeof(TableMeta);          
                cBytes +=      ComCatMeta.GetCountColumnMeta()    * sizeof(ColumnMeta);
                cBytes +=      ComCatMeta.GetCountTagMeta()    * sizeof(TagMeta);               
                cBytes +=      ComCatMeta.GetCountIndexMeta()    * sizeof(IndexMeta);              
                cBytes +=      ComCatMeta.GetCountULONG()    * sizeof(ULONG);                        
                cBytes +=      ComCatMeta.GetCountQueryMeta()    * sizeof(QueryMeta);          
                cBytes +=      ComCatMeta.GetCountRelationMeta()    * sizeof(RelationMeta);

                pOutput->printf(L"Number of bytes used to store meta information = %d\n (INCLUDING wiring, NOT including Hash tables and UI4 Pool)\n", cBytes);
            }

        }

        if(dwCommandLineSwitches & eProduct)//do this last since something could have gone wrong in the Compile
        {
            TRegisterProductName(wszProduct, wszFilename[iDll], *pOutput);

			if((NULL != wszFilename[iConfig]) && (0 != *(wszFilename[iConfig])))
			{
	            TRegisterMachineConfigDirectory(wszProduct, wszFilename[iConfig], *pOutput);
			}
        }
    }
    catch(TException &e)
    {
//#ifdef _DEBUG
        e.Dump(Screen);
//#else
//        e.Dump(TDebugOutput());
//#endif
        if(dwCommandLineSwitches & eMetaFixup)
            Screen.printf(L"CatUtil(0) : error : Fixup PE FAILED!\n");//This extra output message is so BUILD will report the error.
        return 1;
    }
    Screen.printf(L"CatUtil finished sucessfully.\n");//This is mostly for the case where 'verbose' is not supplied.
                                                      //It would be nice to know that everything worked.
    return 0;
}

//******************************************************************************************
//Needed by mscorddr.lib
//******************************************************************************************

HINSTANCE GetModuleInst()
{
    return (GetModuleHandle(NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\entrypoint\safecs.cpp ===
#include <unicode.h>
#include <windows.h>
#include "SafeCS.h"


//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.cpp
//
// Contents:    CSafeAutoCriticalSection implementation
//              CSafeLock implementation
//
//------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Class:      CSafeAutoCriticalSection
//
//  Purpose:    Wrapper for initializing critical-sections.
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- initializes the critical section
//				Detructor		- uninitializes the critical section 
//
//  Notes:		This provides a convenient way to ensure that you're
//              you wrap InitializeCriticalSection and 
//              UnInitializeCriticalSection in try catches which is useful 
//              in low-mem conditions
//
//---------------------------------------------------------------------------

//+-------------------------------------------------------------------------- 
// Default constructor - Initializes the critical section and sets the state 
// flag to initialized
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::CSafeAutoCriticalSection()
{
    m_lState = STATE_UNINITIALIZED;
	m_dwError = ERROR_SUCCESS;

    __try
    {
	    LONG  lPreviousState;

        // try to set state flag
        lPreviousState = InterlockedCompareExchange(&m_lState,
                                                    STATE_INITIALIZED,
                                                    STATE_UNINITIALIZED);

        // if this critical section was not initialized
        if(STATE_UNINITIALIZED == lPreviousState)
        {
			//
			// Note we can call InitializeCriticalSectionAndSpinCount here
			// and thereby eliminate the need for a try catch in 
			// EnterCriticalSection. But the docs say that 
			// InitializeCriticalSectionAndSpinCount is valid on NT4.0 SP3
			// onwards and we need to run on plain NT4.0 - hence we call
			// InitializeCriticalSection
			//

			InitializeCriticalSection(&m_cs);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_dwError = _exception_code();
    }

    // failed to initialize - need to reset
    if(ERROR_SUCCESS != m_dwError)
    {
        m_lState = STATE_UNINITIALIZED;
    }

}

//+-------------------------------------------------------------------------- 
// Destructor
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::~CSafeAutoCriticalSection()
{
    LONG                lPreviousState;

    // try to reset the the state to uninitialized
    lPreviousState = InterlockedCompareExchange(&m_lState,
                                                STATE_UNINITIALIZED,
                                                STATE_INITIALIZED);

    // if the object was initialized delete the critical section
    if(STATE_INITIALIZED == lPreviousState)
    {
        DeleteCriticalSection(&m_cs);
    }
}

//+-------------------------------------------------------------------------- 
// Enters critical section, if needed initializes critical section
// before entering
//
// Returns 
//	DWORD -	ERROR_SUCCESS if everything is fine
//			ERROR_OUTOFMEMORY if failed to create or enter critical section
//+-------------------------------------------------------------------------- 

DWORD CSafeAutoCriticalSection::Lock()
{
    DWORD dwError = ERROR_SUCCESS;

    if(!IsInitialized())
    {
        return m_dwError;
    }

    __try
    {
        EnterCriticalSection(&m_cs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
	    dwError = _exception_code();
    }

    return dwError;
}

//+-------------------------------------------------------------------------- 
// Leaves critical section
//+-------------------------------------------------------------------------- 
DWORD CSafeAutoCriticalSection::Unlock()
{
    if(!IsInitialized())
    {
        return m_dwError;
    }

    LeaveCriticalSection(&m_cs);

    return ERROR_SUCCESS;

}

//+--------------------------------------------------------------------------
//
//  Class:      CSafeLock
//
//  Purpose:    Auto-unlocking critical-section services
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- locks the critical section (unless told 
//								  otherwise)
//				Detructor		- unlocks the critical section if its locked
//
//  Notes:		This provides a convenient way to ensure that you're
//              unlocking a CSemExclusive, which is useful if your routine
//              can be left via several returns and/or via exceptions....
//
//---------------------------------------------------------------------------

CSafeLock::CSafeLock(CSafeAutoCriticalSection* val) : 
m_pSem(val),
m_locked(FALSE)
{
}

CSafeLock::CSafeLock(CSafeAutoCriticalSection& val) : 
m_pSem(&val),
m_locked(FALSE)
{
}

CSafeLock::~CSafeLock() 
{	
	if (m_locked) 
	{
		m_pSem->Unlock(); 
	}
}

DWORD CSafeLock::Lock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(!m_locked) 
	{ 
		dwError = m_pSem->Lock(); 

		if(ERROR_SUCCESS == dwError)
		{
			m_locked = TRUE; 
		}
	}

	return dwError;
}


DWORD CSafeLock::Unlock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(m_locked) 
	{ 
		dwError = m_pSem->Unlock(); 
		m_locked = FALSE; 
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\dispenser\cshellqi.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include <objbase.h>
#include "cshell.h"

// -----------------------------------------
// CSTShell: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CSTShell::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_bInitialized) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_IShellInitialize)
		{
			*ppv = (IShellInitialize*) this;
		}
		else if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (IShellInitialize*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableWrite2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableController)
		{
			*ppv = (ISimpleTableController*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
	}
	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}
STDMETHODIMP_(ULONG) CSTShell::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}
STDMETHODIMP_(ULONG) CSTShell::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\dispenser\cstdispqi.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    cstdispqi.cpp

$Header: $

Abstract:

--**************************************************************************/

#include <objbase.h>
#include "cstdisp.h"
#include "catmeta.h"
																			
// -----------------------------------------
// CSimpleTableDispenser: IUnknown 
// -----------------------------------------

// =======================================================================
STDMETHODIMP CSimpleTableDispenser::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableDispenser2*) this;
	}
	if (riid == IID_IAdvancedTableDispenser)
	{
		*ppv = (IAdvancedTableDispenser*) this;
	}	
	else if (riid == IID_ISimpleTableDispenser2)
	{
		*ppv = (ISimpleTableDispenser2*) this;
	}	
	else if (riid == IID_ISimpleTableAdvise)
	{
		*ppv = (ISimpleTableAdvise*) this;
	}
	else if (riid == IID_ISimpleTableEventMgr)
	{
		*ppv = (ISimpleTableEventMgr*) this;
	}
	else if (riid == IID_ISimpleTableFileAdvise)
	{
		*ppv = (ISimpleTableFileAdvise*) this;
	}
	else if (riid == IID_ISnapshotManager)
	{
		*ppv = (ISnapshotManager*) this;
	}
	else if (riid == IID_IMetabaseSchemaCompiler)
	{
//@@@Put this in when the dispenser does the right thing        if(0 == wcsicmp(m_wszProductID, WSZ_PRODUCT_IIS))//This interface is only supported on the IIS catalog
			*ppv = (IMetabaseSchemaCompiler*) this;
	}
	else if (riid == IID_ICatalogErrorLogger)
	{
			*ppv = (ICatalogErrorLogger*) this;
	}
	
	if (NULL != *ppv)
	{
		((ISimpleTableDispenser2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CSimpleTableDispenser::AddRef()
{
	// this is a singleton
	return 1;
}

// =======================================================================
STDMETHODIMP_(ULONG) CSimpleTableDispenser::Release()
{
	// this is a singleton
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\dispenser\cstdisp.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    cstdisp.cpp

$Header: $

Abstract:

--**************************************************************************/



// TO DO tracing
// TO DO ISSUE :the dispenser for sdtfxd should be singleton
// TO DO E_ST_OMITDISPENSER is not used corectly
// TO DO Revisit where the notification support gets hooked


#include "cstdisp.h"
#include "catmacros.h"
#include "cshell.h"
#include "..\..\stores\regdb\regdbapi\clbread.h"
#include "..\..\stores\FixedSchemaInterceptor\FixedPackedSchemaInterceptor.h"
#include "safecs.h"
#include "TextFileLogger.h"
#include "EventLogger.h"

// extern functions
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv);
extern HRESULT CreateShell(IShellInitialize ** o_pSI);

// the lock used by catalog.dll
extern CSafeAutoCriticalSection g_csSADispenser;

#define WIRING_INTERCEPTOR	eSERVERWIRINGMETA_Core_FixedPackedInterceptor
#define META_INTERCEPTOR	eSERVERWIRINGMETA_Core_FixedPackedInterceptor
#define EVENT_INTERCEPTOR	eSERVERWIRINGMETA_Core_EventInterceptor
#define MEMORY_INTERCEPTOR	eSERVERWIRINGMETA_Core_MemoryInterceptor
#define XML_INTERCEPTOR	    eSERVERWIRINGMETA_Core_XMLInterceptor

//Hashing is done on a case insensitive basis, so this ToLower function uses a lookup table to convert a wide char to its lowercase version without
//the need for an 'if' condition.
inline WCHAR ToUpper(WCHAR i_wchar)
{
    //The lower 127 ascii are mapped to their lowercase ascii value.  Note only 0x41('A') - 0x5a('Z') are changed.  And these are mapped to 0x60('a') - 0x7a('z')
    static unsigned char kToUpper[128] = 
    { //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
    /*00*/  0x00,   0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,   0x09,   0x0a,   0x0b,   0x0c,   0x0d,   0x0e,   0x0f,
    /*10*/  0x10,   0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,   0x19,   0x1a,   0x1b,   0x1c,   0x1d,   0x1e,   0x1f,
    /*20*/  0x20,   0x21,   0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f,
    /*30*/  0x30,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3a,   0x3b,   0x3c,   0x3d,   0x3e,   0x3f,
    /*40*/  0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4a,   0x4b,   0x4c,   0x4d,   0x4e,   0x4f,
    /*50*/  0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5a,   0x5b,   0x5c,   0x5d,   0x5e,   0x5f,
    /*60*/  0x60,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4a,   0x4b,   0x4c,   0x4d,   0x4e,   0x4f,
    /*70*/  0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5a,   0x7b,   0x7c,   0x7d,   0x7e,   0x7f,
    };

    return (kToUpper[i_wchar & 0x007f] | (i_wchar & ~0x007f));
}

void ToUpper(LPWSTR o_wsz)
{
    if(0 == o_wsz)
        return;

    while(*o_wsz)
    {
        *o_wsz = ToUpper(*o_wsz);
        ++o_wsz;
    }
}


extern LPWSTR g_wszDefaultProduct;//located in svcerr.cpp

//////////////////////////////////////////////////
// Constructor & destructor
//////////////////////////////////////////////////
CSimpleTableDispenser::CSimpleTableDispenser():
m_pDllMap(NULL),
m_pEventMgr(NULL),
m_pFileChangeMgr(NULL)
{
    wcscpy(m_wszProductID, g_wszDefaultProduct);
}

CSimpleTableDispenser::CSimpleTableDispenser(LPCWSTR wszProductID):
m_pDllMap(NULL),
m_pEventMgr(NULL),
m_pFileChangeMgr(NULL)
{
    if(wszProductID && wcslen(wszProductID)<32)
    {
        wcscpy(m_wszProductID, wszProductID);
        ToUpper(m_wszProductID);
    }
    else
        wcscpy(m_wszProductID, g_wszDefaultProduct);
}

CSimpleTableDispenser::~CSimpleTableDispenser()
{
	delete m_pDllMap;
	m_pDllMap = 0;

	delete m_pEventMgr;
	m_pEventMgr = 0;

	delete m_pFileChangeMgr;
	m_pFileChangeMgr = 0;
}

// Dispenser initialization function, called once per process
// It is protected by a lock in the one place it's called
HRESULT CSimpleTableDispenser::Init()
{
	HRESULT hr;
	CComPtr <ISimpleTableInterceptor> pISTInterceptor;
	CComPtr <ISimpleTableAdvanced> pISTAdvanced;

	// Get the server wiring table
	hr = DllGetSimpleObjectByID(WIRING_INTERCEPTOR, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor));	
	if (FAILED (hr)) return hr;

	hr = pISTInterceptor->Intercept (NULL, NULL, TABLEID_SERVERWIRING_META, NULL, 0, eST_QUERYFORMAT_CELLS, 0, (IAdvancedTableDispenser*) this, NULL, NULL, (LPVOID *)&m_spServerWiring);
	if (FAILED (hr)) return hr;

	hr = m_spServerWiring->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID *)&pISTAdvanced);
	if (FAILED (hr)) return hr;

	hr = pISTAdvanced->PopulateCache();
	if (FAILED (hr)) return hr;

	return hr;
}

// Initialization functions
// All of them take locks inside
HRESULT CSimpleTableDispenser::InitDllMap()
{
	CSafeLock dispenserLock(&g_csSADispenser);
	DWORD dwRes = dispenserLock.Lock();
	if(ERROR_SUCCESS != dwRes)
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	if(!m_pDllMap)
	{
		m_pDllMap = new CDllMap;
		if (m_pDllMap == 0)
		{
			return E_OUTOFMEMORY;
		}
	}
	
	return S_OK;
}

HRESULT CSimpleTableDispenser::InitEventManager()
{
	CSafeLock dispenserLock (&g_csSADispenser);
	DWORD dwRes = dispenserLock.Lock ();
	if(ERROR_SUCCESS != dwRes)
	{
	   return HRESULT_FROM_WIN32(dwRes);
	}

	// Only create the event manager if it hasn't been created.
	if (NULL == m_pEventMgr)
	{
		m_pEventMgr = new CSTEventManager((IAdvancedTableDispenser*) this);
		if(NULL == m_pEventMgr)
		{
			return E_OUTOFMEMORY;
		}
	}

	return S_OK;
}

HRESULT CSimpleTableDispenser::InitFileChangeMgr()
{
	CSafeLock dispenserLock (&g_csSADispenser);
	DWORD dwRes = dispenserLock.Lock ();
	if(ERROR_SUCCESS != dwRes)
	{
	   return HRESULT_FROM_WIN32(dwRes);
	}

	if(!m_pFileChangeMgr)
	{
		m_pFileChangeMgr = new CSTFileChangeManager;
		if(!m_pFileChangeMgr)
			return E_OUTOFMEMORY;
	}
	
	return S_OK;
}

//////////////////////////////////////////////////
// Implementation of ISimpleTableDispenser2
//////////////////////////////////////////////////
 HRESULT CSimpleTableDispenser::GetTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat, 
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST)
{
	ULONG TableID;

	// Validate table and database - rest of the validation is done further down
	if (NULL == i_wszDatabase ) return E_INVALIDARG;
	if (NULL == i_wszTable ) return E_INVALIDARG;
	
	if (o_ppIST == 0)
	{
		TRACE(L"Bad out parameter");
		return E_INVALIDARG;
	}

	*o_ppIST = 0;
	
	if (i_eQueryFormat != 0 && i_eQueryFormat != eST_QUERYFORMAT_CELLS && i_eQueryFormat != eST_QUERYFORMAT_SQL)
		return E_ST_QUERYNOTSUPPORTED;

    if(0 == _wcsicmp(i_wszDatabase, wszDATABASE_META))
    {
        if(i_fServiceRequests & fST_LOS_EXTENDEDSCHEMA) 
        {  
			// we do not support extended schemas anymore
			return E_ST_LOSNOTSUPPORTED;

			//Extended schema always comes from the MetaMerge interceptor (which in turn gets the meta from the Fixed interceptor)
            //return HardCodedIntercept(eSERVERWIRINGMETA_Core_MetaMergeInterceptor, i_wszDatabase, i_wszTable, 0, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, o_ppIST);
        }
        else if((0 == i_QueryMeta || 0 == *reinterpret_cast<ULONG *>(i_QueryMeta)))
        {   //The FixedPackedSchema interceptor handles TableMeta without a query; but ALL other META tables without a query need to be directed to the FixedInterceptor
            if(0==_wcsicmp(i_wszTable, wszTABLE_SERVERWIRINGMETA) || 0==_wcsicmp(i_wszTable, wszTABLE_SERVERWIRING_META))
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, wszDATABASE_META, i_wszTable, 0, NULL, 0, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
            else
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedInterceptor, wszDATABASE_META, i_wszTable, 0, NULL, 0, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
        }
        else if(0 != i_QueryData && (iST_CELL_SPECIAL & reinterpret_cast<STQueryCell *>(i_QueryData)->iCell))
        {   //If the Meta table uses an IndexHint it must come from the FixedInterceptor
            return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedInterceptor, wszDATABASE_META, i_wszTable, 0, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
        }
        else if(0 != i_QueryData && 0 == _wcsicmp(i_wszTable, wszTABLE_TABLEMETA) && iTABLEMETA_Database == reinterpret_cast<STQueryCell *>(i_QueryData)->iCell)
        {
            return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedInterceptor, wszDATABASE_META, i_wszTable, 0, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
        }
        //We need to special case a few tables for perf reasons.  If we don't hard code these tables, we will incur extra page faults.
        //This is because TFixedPackedSchemaInterceptor::GetTableID & InternalGetTable hit the table's schema page to verify the table name
        //and look up the ServerWiring.  By hard coding this information for these tables (which are the core table) we don't hit those pages.
        //This saves up to 4 page faults (2 for ColumnMeta and one each for TableMeta and TagMeta).
        {
            //Remap these META tables to the FixedPackedInterceptor, the other META tables will be handled as usual
            if(0 ==      _wcsicmp(i_wszTable, wszTABLE_COLUMNMETA))
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, wszDATABASE_PACKEDSCHEMA, wszTABLE_PROPERTY_META, TABLEID_PROPERTY_META, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
            else if(0 == _wcsicmp(i_wszTable, wszTABLE_TABLEMETA))
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, wszDATABASE_PACKEDSCHEMA, wszTABLE_COLLECTION_META, TABLEID_COLLECTION_META, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
            else if(0 == _wcsicmp(i_wszTable, wszTABLE_TAGMETA))
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, wszDATABASE_PACKEDSCHEMA, wszTABLE_TAG_META, TABLEID_TAG_META, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
            else
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedInterceptor, wszDATABASE_META, i_wszTable, 0, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
        }
    }
    else if(0 == _wcsicmp(i_wszDatabase, wszDATABASE_PACKEDSCHEMA))//All PACKEDSCHEMA tables come from the FixedPackedInterceptor
        return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, i_wszDatabase, i_wszTable, 0, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);

    //For now we only support tables defined in the FixedPackedSchema.  In the future we'll have to content with tables whose schema
    //is expressed in some other form.  At that time we'll need to handle an error returned from GetTableID and do something different
    //for those tables.
    HRESULT hr = TFixedPackedSchemaInterceptor::GetTableID(i_wszDatabase, i_wszTable, TableID);
    if(SUCCEEDED(hr))
    {
        // This table is described in the meta from this dll
		// We can just call the faster method
        return InternalGetTable(i_wszDatabase, i_wszTable, TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, o_ppIST);
    }
#ifdef EXTENDED_SCHEMA_SUPPORT
	// we do not support extended schemas anymore.
    else
    {   // just get an XML table - this is for schema extensibility - we only support reading from XML files and no logic
        return GetXMLTable(i_wszDatabase, i_wszTable, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, o_ppIST);
    }
#endif

	return hr;
}


HRESULT CSimpleTableDispenser::GetXMLTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat, 
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST)
{
	HRESULT hr;
	tSERVERWIRINGMETARow SWColumns;
    ULONG zero=0;
    ULONG one = 1;
    ULONG metaflags = fSERVERWIRINGMETA_First;
	ULONG interceptor = XML_INTERCEPTOR;
	ISimpleTableAdvanced * pISTAdvanced = NULL;

    if((0==i_wszDatabase || 0==i_wszTable) )
	{
		TRACE(L"GetXMLTable needs Database/TableName");
		return E_INVALIDARG;
	}

	// Validate out pointer
	if (NULL == o_ppIST)
	{
		TRACE(L"Bad out parameter");
		return E_INVALIDARG;
	}
    *o_ppIST = 0;//Our cleanup relies on this being NULL

	// Validate query format
	if(i_eQueryFormat != eST_QUERYFORMAT_CELLS)
	{
		TRACE(L"Query format not supported");
		return E_ST_QUERYNOTSUPPORTED;
	}

	// Check the query data and meta
	if((NULL != i_QueryData) && (NULL == i_QueryMeta))
	{
		TRACE(L"Invalid query");
		return E_INVALIDARG;
	}
/*
	// Scan the query for iST_CELL_COMPUTER or iST_CELL_CLUSTER
	if(i_QueryData)
	{
		STQueryCell * aqCell = (STQueryCell *)i_QueryData;

		for(ULONG iqCell = 0; iqCell<*(ULONG*)i_QueryMeta; iqCell++)
		{
			if ((aqCell[iqCell].iCell == iST_CELL_COMPUTER) || 
				(aqCell[iqCell].iCell == iST_CELL_CLUSTER))
			{
				i_fServiceRequests |= fST_LOS_CONFIGWORK;
				break;
			}
		}
	}
*/
	// We don't support client tables for now
	if(i_fServiceRequests & fST_LOS_CONFIGWORK) return E_ST_LOSNOTSUPPORTED;

    // prepare the structure we pass in CreateTableObjectByID
	SWColumns.pTable				= NULL;//This is the PK so it shouldn't be NULL but I don't know if it matters in this mocked up ServerWiring row (stephenr)
	SWColumns.pOrder				= &one; 
	SWColumns.pReadPlugin			= &zero;
	SWColumns.pWritePlugin			= &zero;
	SWColumns.pInterceptor			= &interceptor;
	SWColumns.pReadPluginDLLName    = NULL; // doesn't really matter
	SWColumns.pWritePluginDLLName	= NULL;
	SWColumns.pInterceptorDLLName	= NULL;
	SWColumns.pMergerDLLName		= NULL;
	SWColumns.pMetaFlags			= &metaflags;
	SWColumns.pLocator				= NULL;
	SWColumns.pMerger				= &zero;

    //fill in SWColumns
	hr = CreateTableObjectByID(i_wszDatabase, i_wszTable, 0, i_QueryData, i_QueryMeta, i_eQueryFormat, 
		i_fServiceRequests, NULL,  &SWColumns, o_ppIST);
    if(FAILED(hr))
    {
		TRACE(L"%x error in the interceptor", hr);
        ASSERT(0 == *o_ppIST);
    	return hr;
    }
		
	// Get the advanced interface
	hr = (*(ISimpleTableWrite2 **)o_ppIST)->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID *)&pISTAdvanced);
	if (FAILED (hr)) goto Cleanup;
	
	// Populate the table
	hr = pISTAdvanced->PopulateCache();

Cleanup:
    if(pISTAdvanced)
	    pISTAdvanced->Release();
    if(FAILED(hr) && *o_ppIST)
    {
		(*(ISimpleTableWrite2 **)o_ppIST)->Release();
		*o_ppIST = 0;
    }

	return hr;
}



HRESULT CSimpleTableDispenser::InternalGetTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat, 
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST)
{
	HRESULT hr;
	ULONG iRow;	// row index in the wiring table
	PKHelper pk; // primary key for the wiring table
	ULONG iOrder; // the order of the interceptors in the wiring table
	tSERVERWIRINGMETARow SWColumns;
	ISimpleTableWrite2 * pUnderTable = NULL;
	ISimpleTableAdvanced * pISTAdvanced = NULL;
	DWORD fNoNext = 0;
    ULONG zero=0;

    if((0==i_wszDatabase || 0==i_wszTable) && 0==i_TableID)
	{
		TRACE(L"GetTable either needs Database/TableName OR TableID.");
		return E_INVALIDARG;
	}

	// Validate out pointer
    *o_ppIST = 0;//Our cleanup relies on this being NULL

	// Validate query format
	if(i_eQueryFormat != eST_QUERYFORMAT_CELLS)
	{
		TRACE(L"Query format not supported");
		return E_ST_QUERYNOTSUPPORTED;
	}

	// Check the query data and meta
	if((NULL != i_QueryData) && (NULL == i_QueryMeta))
	{
		TRACE(L"Invalid query");
		return E_INVALIDARG;
	}

	// Scan the query for iST_CELL_COMPUTER or iST_CELL_CLUSTER
	if(i_QueryData)
	{
		STQueryCell * aqCell = (STQueryCell *)i_QueryData;

		for(ULONG iqCell = 0; iqCell<*(ULONG*)i_QueryMeta; iqCell++)
		{
			if ((aqCell[iqCell].iCell == iST_CELL_COMPUTER) || 
				(aqCell[iqCell].iCell == iST_CELL_CLUSTER))
			{
				i_fServiceRequests |= fST_LOS_CONFIGWORK;
				break;
			}
		}
	}

	// We don't support client tables for now
	if(i_fServiceRequests & fST_LOS_CONFIGWORK) return E_ST_LOSNOTSUPPORTED;

	
	pk.pTableID = &i_TableID;
	pk.porder = &zero;
	hr = m_spServerWiring->GetRowIndexByIdentity(NULL, (LPVOID *)&pk, &iRow);
	if(FAILED (hr))
	{
		TRACE(L"No wiring was found for tid = %d", i_TableID);
		return hr;
	}

	// Try the interceptors from the FIRST group, 
	// one by one, until we find a good one
	for(iOrder = iRow;;)
	{
		hr = m_spServerWiring->GetColumnValues(iOrder, cSERVERWIRING_META_NumberOfColumns, NULL, NULL, (LPVOID *)&SWColumns);
		iOrder++;
		if (E_ST_NOMOREROWS == hr)
			break; // we tried all the interceptors specified in the wiring
		if (FAILED(hr))
		{	//error in getting the wiring
			goto Cleanup;	
		}

		hr = CreateTableObjectByID(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, 
			i_fServiceRequests, NULL,  &SWColumns, o_ppIST);
		if (hr == S_OK) 
			break; // we found a good first interceptor
		else if(hr == E_ST_OMITDISPENSER)
			continue; // try the next one
		else if(hr == E_ST_OMITLOGIC)
		{
			hr = S_OK;
			fNoNext = 1;
			break;
		}
		else
		{	// not S_OK, not E_ST_OMITDISPENSER, not E_ST_OMITLOGIC - error out
			TRACE(L"%x error in the interceptor", hr);
			goto Cleanup;
		}
	}

		
	if (!fNoNext)
	{
		// Hook up the event notification logic table only on writable tables, during cookdown.
		if ((i_fServiceRequests & fST_LOS_READWRITE) && (i_fServiceRequests & fST_LOS_COOKDOWN) && ((hr = IsTableConsumedByID(i_TableID)) == S_OK))
		{
			pUnderTable = *(ISimpleTableWrite2**)o_ppIST ;

			ULONG interceptor = EVENT_INTERCEPTOR;
            ULONG metaflags = fSERVERWIRINGMETA_First;

			// prepare the structure we pass in CreateTableObjectByID
			SWColumns.pTable				= NULL;//This is the PK so it shouldn't be NULL but I don't know if it matters in this mocked up ServerWiring row (stephenr)
			SWColumns.pOrder				= &iOrder; 
			SWColumns.pReadPlugin			= &zero;
			SWColumns.pWritePlugin			= &zero;
			SWColumns.pInterceptor			= &interceptor;
			SWColumns.pReadPluginDLLName    = NULL; // doesn't really matter
			SWColumns.pWritePluginDLLName	= NULL;
			SWColumns.pInterceptorDLLName	= NULL;
			SWColumns.pMergerDLLName		= NULL;
			SWColumns.pMetaFlags			= &metaflags;
			SWColumns.pLocator				= NULL;
			SWColumns.pMerger				= &zero;

			hr = CreateTableObjectByID(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, 
				i_fServiceRequests, (LPVOID)pUnderTable, &SWColumns, o_ppIST);
            if (FAILED (hr))
            {
                ASSERT(0 == *o_ppIST);
                goto Cleanup;
            }

		}
		if (FAILED (hr)) goto Cleanup;

		if(!(i_fServiceRequests & fST_LOS_NOLOGIC))
		{
			// Create and use each interceptor from the NEXT group
			do
			{
				hr = m_spServerWiring->GetColumnValues(iOrder, cSERVERWIRING_META_NumberOfColumns, NULL, NULL, (LPVOID *)&SWColumns);
				iOrder ++;
				if(S_OK == hr)
				{
					if (*SWColumns.pMetaFlags & fSERVERWIRINGMETA_First) continue; // skip the first interceptors
					pUnderTable = *(ISimpleTableWrite2**)o_ppIST ;

					hr = CreateTableObjectByID(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, 
						i_fServiceRequests, (LPVOID)pUnderTable, &SWColumns, o_ppIST);
					if (FAILED (hr))
                    {
                        ASSERT(0 == *o_ppIST);
                        goto Cleanup;
                    }
				}
			}
			while(hr == S_OK);
			if (hr == E_ST_NOMOREROWS) hr = S_OK; // we finished the interceptors
			if (FAILED (hr)) goto Cleanup;
		}
	
		// Get the advanced interface
		hr = (*(ISimpleTableWrite2 **)o_ppIST)->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID *)&pISTAdvanced);
		if (FAILED (hr)) goto Cleanup;
		
		// Populate the table
		hr = pISTAdvanced->PopulateCache();
		if(FAILED (hr)) goto Cleanup;
	}

Cleanup:

    if(pISTAdvanced)
	    pISTAdvanced->Release();
    if(FAILED(hr))
    {
        if(*o_ppIST)
    		(*(ISimpleTableWrite2 **)o_ppIST)->Release();
		*o_ppIST = 0;
    }

	return hr;
}

//////////////////////////////////////////////////
// Implementation of IAdvancedTableDispenser
//////////////////////////////////////////////////
HRESULT CSimpleTableDispenser::GetMemoryTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData,
                                                LPVOID i_QueryMeta, DWORD i_eQueryFormat, DWORD i_fServiceRequests,
                                                ISimpleTableWrite2** o_ppISTWrite)
{
    HRESULT hr;
    STQueryCell           qcellMeta;                  // Query cell for grabbing meta table.
    CComPtr<ISimpleTableRead2> pColumnMeta;
    CComPtr<ISimpleTableRead2> pTableMeta;
    ULONG one = 1;

    if(((0 == i_wszDatabase) || (0 == i_wszTable)) && (0 == i_TableID)) return E_INVALIDARG;

    if(0 == o_ppISTWrite )return E_INVALIDARG;
    
	ASSERT((0 == *o_ppISTWrite) && "Possible memory leak");

    CComPtr<ISimpleTableInterceptor>    pISTInterceptor;
    hr = DllGetSimpleObjectByID(MEMORY_INTERCEPTOR, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor));  
    if (FAILED (hr)) return hr;

	if(i_TableID == 0)
	{	// get the table id based on the table and database name
        hr = TFixedPackedSchemaInterceptor::GetTableID(i_wszDatabase, i_wszTable, i_TableID);
        if(FAILED(hr) && (i_fServiceRequests & fST_LOS_EXTENDEDSCHEMA))
        {
            // Read the meta information from the extended schema
            i_TableID = 0;

            qcellMeta.pData     = (LPVOID)i_wszTable;
            qcellMeta.eOperator = eST_OP_EQUAL;
            qcellMeta.iCell     = iTABLEMETA_InternalName;
            qcellMeta.dbType    = DBTYPE_WSTR;
            qcellMeta.cbSize    = (ULONG)::wcslen(i_wszTable);
            
            // Read Table meta
            hr = HardCodedIntercept (eSERVERWIRINGMETA_Core_MetaMergeInterceptor, wszDATABASE_META, wszTABLE_TABLEMETA, 0,
                    reinterpret_cast<LPVOID>(&qcellMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, i_fServiceRequests & fST_LOS_EXTENDEDSCHEMA,
                    reinterpret_cast<LPVOID *>(&pTableMeta));
            if (FAILED (hr)) return hr;

            qcellMeta.iCell     = iCOLUMNMETA_Table;
            // Read Column meta
            hr = HardCodedIntercept (eSERVERWIRINGMETA_Core_MetaMergeInterceptor, wszDATABASE_META, wszTABLE_COLUMNMETA, 0,
                    reinterpret_cast<LPVOID>(&qcellMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, i_fServiceRequests & fST_LOS_EXTENDEDSCHEMA,
                    reinterpret_cast<LPVOID *>(&pColumnMeta));
            if (FAILED (hr)) return hr;
        }
	}

    if (i_TableID != 0)
    {
        // the meta for this table is hardcoded in out dll
        qcellMeta.pData     = (LPVOID)&i_TableID;
        qcellMeta.eOperator = eST_OP_EQUAL;
        qcellMeta.iCell     = iST_CELL_TABLEID;
        qcellMeta.dbType    = DBTYPE_UI4;
        qcellMeta.cbSize    = 0;
    
        hr = GetMetaTable (TABLEID_COLLECTION_META, reinterpret_cast<LPVOID>(&qcellMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, reinterpret_cast<LPVOID *>(&pTableMeta));
        if (FAILED (hr)) return hr;

        hr = GetMetaTable (TABLEID_PROPERTY_META, reinterpret_cast<LPVOID>(&qcellMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, reinterpret_cast<LPVOID *>(&pColumnMeta));
        if (FAILED (hr)) return hr;
    }

    ASSERT(pColumnMeta.p);
    ASSERT(pTableMeta.p);

    // Determine column count and allocate necessary meta structures:
    ULONG aiColumns = iTABLEMETA_CountOfColumns;
    ULONG *pcColumns;
    hr = pTableMeta->GetColumnValues(0, 1, &aiColumns, 0, reinterpret_cast<LPVOID *>(&pcColumns));
    if (FAILED (hr)) return hr;

    // Allocate the arrays ShapeCache uses
    TSmartPointerArray<SimpleColumnMeta> acolmetas = new SimpleColumnMeta[*pcColumns];
    if(NULL == acolmetas.m_p)return E_OUTOFMEMORY;
	TSmartPointerArray<LPVOID> acoldefaults = new LPVOID[*pcColumns];
    if(NULL == acoldefaults.m_p)return E_OUTOFMEMORY;
	TSmartPointerArray<ULONG> acoldefsizes = new ULONG[*pcColumns];
    if(NULL == acoldefsizes.m_p)return E_OUTOFMEMORY;

    for (unsigned int iColumn = 0; iColumn < *pcColumns; iColumn++)  
        acolmetas[iColumn].cbSize = 0;

    // Examine meta and setup self
    LPVOID  pvValues[iCOLUMNMETA_DefaultValue+1];//This is the last column in the ColumnMeta that we care about right now.
    ULONG	aulSizes[iCOLUMNMETA_DefaultValue+1];

    for (iColumn = 0;; iColumn++)   
    {
        if(E_ST_NOMOREROWS == (hr = pColumnMeta->GetColumnValues(iColumn, iCOLUMNMETA_DefaultValue+1, 0, aulSizes, pvValues)))// Next row:
        {
            ASSERT(*pcColumns == iColumn);
            if(*pcColumns != iColumn)return E_UNEXPECTED; // Assert expected column count.
            break;
        }
        else
        {
            if(FAILED(hr))
            {
                ASSERT(false && "GetColumnValues FAILED with something other than E_ST_NOMOREROWS");
                return hr;
            }
        }

        //Don't care about the iOrder column but we'll get it anyway since it's easier to do.
        acolmetas[iColumn].dbType = *(reinterpret_cast<ULONG *>(pvValues[iCOLUMNMETA_Type]));
        acolmetas[iColumn].cbSize = *(reinterpret_cast<ULONG *>(pvValues[iCOLUMNMETA_Size]));
        acolmetas[iColumn].fMeta  = *(reinterpret_cast<ULONG *>(pvValues[iCOLUMNMETA_MetaFlags]));
		acoldefaults[iColumn] = pvValues[iCOLUMNMETA_DefaultValue];
		acoldefsizes[iColumn] = aulSizes[iCOLUMNMETA_DefaultValue];
    }

    hr = pISTInterceptor->Intercept (i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, (IAdvancedTableDispenser*) this, NULL, NULL, (void**) o_ppISTWrite);
    if (FAILED (hr)) return hr;

    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController>   pISTController = *o_ppISTWrite;ASSERT(0 != pISTController.p);
    if(0 == pISTController.p)return E_UNEXPECTED;

    // Now that the cache is setup, initialize it.
    hr =  pISTController->ShapeCache(i_fServiceRequests, *pcColumns, acolmetas, acoldefaults, acoldefsizes);
    if (FAILED (hr)) return hr;

    //Put the cache into the correct state
    return hr =  pISTController->PopulateCache();
}


HRESULT CSimpleTableDispenser::GetProductID(LPWSTR o_wszProductID, DWORD * io_pcchProductID)
{
    if(0 == io_pcchProductID)
        return E_POINTER;

    DWORD dwSizeNeeded = (DWORD) wcslen(m_wszProductID)+1;

    if(0 == o_wszProductID)//If the user passed in NULL for wszProductID, the we return the size
    {
        *io_pcchProductID = dwSizeNeeded;
        return S_OK;
    }

    if(*io_pcchProductID < dwSizeNeeded)
        return E_ST_SIZENEEDED;

    wcscpy(o_wszProductID, m_wszProductID);
    *io_pcchProductID = dwSizeNeeded;
    return S_OK;
}

//=================================================================================
// Function: GetCatalogErrorLogger
//
// Synopsis: A logger is assocoate with the dispenser,  anybody wanting to log an
//              event should log through this interface.
//
// Arguments: [o_ppErrorLogger] - 
//            
// Return Value: 
//=================================================================================
HRESULT CSimpleTableDispenser::GetCatalogErrorLogger
(
    ICatalogErrorLogger2 **	o_ppErrorLogger
)
{
    if(0 == o_ppErrorLogger)
        return E_INVALIDARG;
    if(0 != *o_ppErrorLogger)
        return E_INVALIDARG;

	CSafeLock dispenserLock(&g_csSADispenser);//guard the spErrorLogger
    HRESULT hr;
    if(0 == m_spErrorLogger.p)
    {
        if(0 == wcscmp(m_wszProductID, WSZ_PRODUCT_IIS))
        {
            TextFileLogger *pLogger = new TextFileLogger(WSZ_PRODUCT_IIS);
            if(0 == pLogger)
                return E_OUTOFMEMORY;

            CComPtr<ICatalogErrorLogger2> spErrorLogger;
            if(FAILED(hr=pLogger->QueryInterface (IID_ICatalogErrorLogger2, reinterpret_cast<void **>(&spErrorLogger))))
                return hr;

            EventLogger *pNTEventLogger = new EventLogger(spErrorLogger);
            if(0 == pNTEventLogger)
                return E_OUTOFMEMORY;
            if(FAILED(hr=pNTEventLogger->QueryInterface (IID_ICatalogErrorLogger2, reinterpret_cast<void **>(&m_spErrorLogger))))
                return hr;
        }
        else //NULL logger
        {
            NULL_Logger *pLogger = new NULL_Logger();
            if(0 == pLogger)
                return E_OUTOFMEMORY;

            if(FAILED(hr=pLogger->QueryInterface (IID_ICatalogErrorLogger2, reinterpret_cast<void **>(&m_spErrorLogger))))
                return hr;

        }
    }

    m_spErrorLogger->AddRef();
    (*o_ppErrorLogger) = m_spErrorLogger.p;
    return S_OK;
}

//=================================================================================
// Function: SetCatalogErrorLogger
//
// Synopsis: A logger is assocoate with the dispenser,  anybody wanting to
//              implement their own logger can associate it with a dispenser by
//              setting it here.
//
// Arguments: [i_pErrorLogger] - 
//            
// Return Value: 
//=================================================================================
HRESULT CSimpleTableDispenser::SetCatalogErrorLogger
(
    ICatalogErrorLogger2 *	i_pErrorLogger
)
{
    if(0 == i_pErrorLogger)
        return E_INVALIDARG;

	CSafeLock dispenserLock(&g_csSADispenser);//guard the spErrorLogger
    m_spErrorLogger->Release();//release the old CatalogErrorLogger

    m_spErrorLogger = i_pErrorLogger;
    return S_OK;
}


extern const FixedTableHeap * g_pFixedTableHeap;
//////////////////////////////////////////////////
// Implementation of IMetabaseSchemaCompiler
//////////////////////////////////////////////////
HRESULT
CSimpleTableDispenser::Compile
(
    LPCWSTR                 i_wszExtensionsXmlFile,
    LPCWSTR                 i_wszResultingOutputXmlFile
)
{
    return m_MBSchemaCompilation.Compile(this, i_wszExtensionsXmlFile, i_wszResultingOutputXmlFile, g_pFixedTableHeap);
}

HRESULT
CSimpleTableDispenser::GetBinFileName
(
    LPWSTR                  o_wszBinFileName,
    ULONG *                 io_pcchSizeBinFileName
)
{
    return m_MBSchemaCompilation.GetBinFileName(o_wszBinFileName, io_pcchSizeBinFileName);
}

HRESULT
CSimpleTableDispenser::SetBinPath
(
    LPCWSTR                 i_wszBinPath
)
{
    return m_MBSchemaCompilation.SetBinPath(i_wszBinPath);
}

HRESULT
CSimpleTableDispenser::ReleaseBinFileName
(
    LPCWSTR                 i_wszBinFileName
)
{
    return m_MBSchemaCompilation.ReleaseBinFileName(i_wszBinFileName);
}

HRESULT
CSimpleTableDispenser::LogError
(
    HRESULT                 i_hrErrorCode,
    ULONG                   i_ulCategory,
    ULONG                   i_ulEvent,
    LPCWSTR                 i_szSource,
    ULONG                   i_ulLineNumber
)
{
    CErrorInterceptor( i_hrErrorCode, i_ulCategory, i_ulEvent).WriteToLog(i_szSource, i_ulLineNumber);
    return S_OK;
}

////////////////////////////////////////////
// Private member functions
////////////////////////////////////////////
HRESULT CSimpleTableDispenser::CreateTableObjectByID(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat, 
				  DWORD	i_fServiceRequests, LPVOID i_pUnderTable, tSERVERWIRINGMETARow * i_pSWColumns, LPVOID * o_ppIST)
{
	HRESULT hr;
	CComPtr <IShellInitialize> spShell;
	CComPtr <IInterceptorPlugin> spIPlugin;
	CComPtr <ISimplePlugin> spReadPlugin;
	CComPtr <ISimplePlugin> spWritePlugin;
	CComPtr <ISimpleTableInterceptor> spInterceptor;


	// A little validation
	ASSERT(i_pSWColumns);
    ASSERT(*i_pSWColumns->pMetaFlags);//MetaFlags should always be First or Next at least.
	
	*o_ppIST = 0;

	// Deal with the interceptor
	if(*i_pSWColumns->pInterceptor)
	{
		if (!(i_fServiceRequests & fST_LOS_READWRITE) && 
			!(*i_pSWColumns->pMetaFlags & fSERVERWIRINGMETA_First) &&
			!(*i_pSWColumns->pMetaFlags & fSERVERWIRINGMETA_WireOnReadWrite))
		{	// We don't need the logic in this case:
			// we are not in a read-write request,
			// we are not creating a first interceptor
			// the wiring doesn't force us to wire the interceptor on readonly requests

			*o_ppIST = i_pUnderTable;
			return S_OK;
		}

		// Create it 
		hr = CreateSimpleObjectByID(*i_pSWColumns->pInterceptor, i_pSWColumns->pInterceptorDLLName, IID_ISimpleTableInterceptor, (LPVOID *)&spInterceptor);
		if (FAILED(hr))
		{
			TRACE(L"Creation of the interceptor failed");
			return hr;
		}

		// Figure out wether it's a full interceptor or a interceptor plugin
		hr = spInterceptor->QueryInterface(IID_IInterceptorPlugin, (LPVOID *)&spIPlugin);
		if (FAILED(hr))
		{
			LPVOID table=0;//Catalog spec says this should be 0 initialized

			// Ok, it's full - we need to call GetTable and return 
			if(*i_pSWColumns->pReadPlugin || *i_pSWColumns->pWritePlugin)
			{
				TRACE(L"Error: Can't have simple plugins with a fully-fledged interceptor");
				return E_ST_INVALIDWIRING;
			}

			hr = spInterceptor->Intercept(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, 
				(IAdvancedTableDispenser*) this, i_pSWColumns->pLocator, i_pUnderTable, &table);

			if ((hr != S_OK) && (hr != E_ST_OMITLOGIC))
			{
				if (hr != E_ST_OMITDISPENSER)
					TRACE(L"Intercept method failed on interceptor number %d", *i_pSWColumns->pInterceptor);
				return hr;
			}
			// Try to get the ISimpleTableWrite
			if (FAILED(((ISimpleTableRead2 *)table)->QueryInterface(IID_ISimpleTableWrite2, o_ppIST)))
			{
				*o_ppIST = table;
			}
			else
			{
				((ISimpleTableRead2 *)table)->Release();
			}
			return hr;

		}
	}

	// The following code doesn't get executed in the "core execution path"
	// We exit the function via the return above

	// Create the read plugin
	if ((!(i_fServiceRequests & fST_LOS_NOLOGIC)) && *i_pSWColumns->pReadPlugin) 
	{
		hr = CreateSimpleObjectByID(*i_pSWColumns->pReadPlugin, i_pSWColumns->pReadPluginDLLName, IID_ISimplePlugin, (LPVOID *)&spReadPlugin);
		if (FAILED(hr)) 
		{
			TRACE(L"Error: Creation of the read plugin failed");
			return hr;
		}
	}

	// Create the write plugin
	if ((!(i_fServiceRequests & fST_LOS_NOLOGIC)) && *i_pSWColumns->pWritePlugin) 
	{
		if(i_fServiceRequests & fST_LOS_READWRITE)
		{
			hr = CreateSimpleObjectByID(*i_pSWColumns->pWritePlugin, i_pSWColumns->pWritePluginDLLName, IID_ISimplePlugin, (LPVOID *)&spWritePlugin);
			if (FAILED(hr)) 
			{
				TRACE(L"Error: Creation of the write plugin failed");
				return hr;
			}
		}
		// else: for readonly requests we don't need the write plugin,
		// even if the wiring specifies wire logic on readonly
	}

// Create an instance of the shell
	hr = CreateShell(&spShell);
	if(FAILED (hr))
	{
		TRACE(L"Error: Creation of the shell failed");
		return hr;
	}

	//TODO add a parameter to initialize in the shell
// Initialize the shell with the plugins we've already created
	hr = spShell->Initialize(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, 
		(IAdvancedTableDispenser*) this, i_pSWColumns->pLocator, i_pUnderTable,
		spIPlugin, spReadPlugin, spWritePlugin, o_ppIST);
	if(FAILED (hr) && (E_ST_OMITDISPENSER != hr) && (E_ST_OMITLOGIC != hr))
	{
		TRACE(L"Error: Initialization of the shell failed");
	}

	return hr;
}


HRESULT CSimpleTableDispenser::CreateSimpleObjectByID(ULONG i_ObjectID, LPWSTR i_wszDllName, REFIID riid, LPVOID* o_ppv)
{
	HRESULT hr;
	PFNDllGetSimpleObjectByID pfnDllGetSimpleObjectByID;

	if(NULL == i_wszDllName)
	{
		// We're in this dll, we don't need to load it
		return DllGetSimpleObjectByID(i_ObjectID, riid, o_ppv);
	}
	else
	{
		if(!m_pDllMap)
		{
			hr = InitDllMap();
			if (FAILED (hr)) return hr;
		}

		// Get the address of the function we need to call from the dll map
		hr = m_pDllMap->GetProcAddress(i_wszDllName, &pfnDllGetSimpleObjectByID);
		if (FAILED (hr)) return hr;

		return (*pfnDllGetSimpleObjectByID)(i_ObjectID, riid, o_ppv);
	}

}

HRESULT CSimpleTableDispenser::GetMetaTable(ULONG TableID, LPVOID QueryData, LPVOID QueryMeta, DWORD eQueryFormat, LPVOID *ppIST)
{
	HRESULT hr;
	CComPtr <ISimpleTableInterceptor> pISTInterceptor;
	CComPtr <ISimpleTableAdvanced> pISTAdvanced;

	// Get the server wiring table
	hr = DllGetSimpleObjectByID(META_INTERCEPTOR, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor));	
	if (FAILED (hr)) return hr;

	hr = pISTInterceptor->Intercept (NULL, NULL, TableID, QueryData, QueryMeta, eQueryFormat, 0, (IAdvancedTableDispenser*) this, NULL, NULL, (LPVOID *)ppIST);
	if (FAILED (hr)) return hr;

	hr = m_spServerWiring->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID *)&pISTAdvanced);
	if (FAILED (hr)) return hr;

	hr = pISTAdvanced->PopulateCache();
	if (FAILED (hr)) return hr;

	pISTAdvanced.Release();
	pISTInterceptor.Release();

	return hr;
}

//This is used when the dispenser knows the interceptor without looking it up in the ServerWiring
HRESULT CSimpleTableDispenser::HardCodedIntercept(eSERVERWIRINGMETA_Interceptor interceptor,
                                                  LPCWSTR   i_wszDatabase,
                                                  LPCWSTR   i_wszTable,
                                                  ULONG     i_TableID,
                                                  LPVOID    i_QueryData,
                                                  LPVOID    i_QueryMeta,
                                                  DWORD     i_eQueryFormat, 
				                                  DWORD     i_fServiceRequests,
                                                  LPVOID *  o_ppIST) const
{
    HRESULT hr;
    CComPtr <ISimpleTableInterceptor>   pISTInterceptor;

    // Get the server wiring table
    hr = DllGetSimpleObjectByID(interceptor, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor)); 
    if (FAILED (hr)) return hr;

    return pISTInterceptor->Intercept (i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, (IAdvancedTableDispenser*) this, NULL, NULL, o_ppIST);
}

HRESULT CSimpleTableDispenser::IsTableConsumedByID(ULONG TableID)
{
	LPCWSTR		wszDatabase;
	LPCWSTR		wszTable;
	HRESULT		hr;
	
    hr = TFixedPackedSchemaInterceptor::GetTableName(TableID, wszTable, wszDatabase);
    if(FAILED(hr))
        return hr;

	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InternalIsTableConsumed(wszDatabase, wszTable);
}


// =======================================================================
//		ISimpleTableAdvise implementations.
// =======================================================================
STDMETHODIMP CSimpleTableDispenser::SimpleTableAdvise(
	ISimpleTableEvent *i_pISTEvent,
	DWORD		i_snid,
	MultiSubscribe *i_ams,
	ULONG		i_cms,
	DWORD		*o_pdwCookie)
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InternalSimpleTableAdvise(i_pISTEvent, i_snid, i_ams, i_cms, o_pdwCookie);
}

// =======================================================================
STDMETHODIMP CSimpleTableDispenser::SimpleTableUnadvise(
	DWORD		i_dwCookie)
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InternalSimpleTableUnadvise(i_dwCookie);
}

// =======================================================================
//		ISimpleTableFileAdvise implementations.
// =======================================================================
STDMETHODIMP CSimpleTableDispenser::SimpleTableFileAdvise(
	ISimpleTableFileChange *i_pISTFile, 
	LPCWSTR		i_wszDirectory, 
	LPCWSTR		i_wszFile, 
	DWORD		i_fFlags, 
	DWORD		*o_pdwCookie)
{
	HRESULT hr;
	if(!m_pFileChangeMgr)
	{
		hr = InitFileChangeMgr();
		if(FAILED(hr)) return hr;
	}

	return m_pFileChangeMgr->InternalListen(i_pISTFile, i_wszDirectory, i_wszFile, i_fFlags, o_pdwCookie);
}

// =======================================================================
STDMETHODIMP CSimpleTableDispenser::SimpleTableFileUnadvise(DWORD i_dwCookie)
{
	HRESULT hr;
	if(!m_pFileChangeMgr)
	{
		hr = InitFileChangeMgr();
		if(FAILED(hr)) return hr;
	}

	return m_pFileChangeMgr->InternalUnlisten(i_dwCookie);
}

// =======================================================================
//		ISimpleTableEventMgr implementations.
// =======================================================================
STDMETHODIMP CSimpleTableDispenser::IsTableConsumed(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable)
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InternalIsTableConsumed(i_wszDatabase, i_wszTable);
}


// =======================================================================
STDMETHODIMP CSimpleTableDispenser::AddUpdateStoreDelta (LPCWSTR i_wszTableName, char* i_pWriteCache, ULONG i_cbWriteCache, ULONG i_cbWriteVarData)
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InternalAddUpdateStoreDelta(i_wszTableName, i_pWriteCache, i_cbWriteCache, i_cbWriteVarData);
}
	
STDMETHODIMP CSimpleTableDispenser::FireEvents(ULONG i_snid)
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InternalFireEvents(i_snid);
}

STDMETHODIMP CSimpleTableDispenser::CancelEvents()
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InternalCancelEvents();
}

STDMETHODIMP CSimpleTableDispenser::RehookNotifications()
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InternalRehookNotifications();
}

STDMETHODIMP CSimpleTableDispenser::InitMetabaseListener()
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->InitMetabaseListener();
}

STDMETHODIMP CSimpleTableDispenser::UninitMetabaseListener()
{
	HRESULT hr;
	if(!m_pEventMgr)
	{
		hr = InitEventManager();
		if(FAILED(hr)) return hr;
	}

	return m_pEventMgr->UninitMetabaseListener();
}

// =======================================================================
//		ISnapshotManager implementations.
// =======================================================================
STDMETHODIMP CSimpleTableDispenser::QueryLatestSnapshot(SNID* o_psnid)
{
	LPWSTR		wszFilePath = NULL;
	HRESULT		hr = S_OK;

	if (o_psnid == NULL)
	{
		return E_INVALIDARG;
	}

	hr = GetFilePath(&wszFilePath);
	if (FAILED(hr)) {	return hr;	}
	hr = InternalGetLatestSnid(wszDATABASE_IIS, wszFilePath, o_psnid);
	if (wszFilePath)
	{
		delete [] wszFilePath;
	}

	return hr;
}

// =======================================================================
STDMETHODIMP CSimpleTableDispenser::AddRefSnapshot(SNID i_snid)
{
	LPWSTR		wszFilePath = NULL;
	HRESULT		hr = S_OK;

	hr = GetFilePath(&wszFilePath);
	if (FAILED(hr)) {	return hr;	}
	hr = InternalAddRefSnid(wszDATABASE_IIS, wszFilePath, i_snid, FALSE);
	if (wszFilePath)
	{
		delete [] wszFilePath;
	}
	return hr;
}

// =======================================================================
STDMETHODIMP CSimpleTableDispenser::ReleaseSnapshot(SNID i_snid)
{
	LPWSTR		wszFilePath = NULL;
	HRESULT		hr = S_OK;

	hr = GetFilePath(&wszFilePath);
	if (FAILED(hr)) {	return hr;	}
	hr = InternalReleaseSnid(wszFilePath, i_snid);
	if (wszFilePath)
	{
		delete [] wszFilePath;
	}

	return hr;
}

// =======================================================================
HRESULT CSimpleTableDispenser::GetFilePath(LPWSTR *o_pwszFilePath)
{
	WCHAR		wszFileName[] = L"WASMB.CLB";

	*o_pwszFilePath = NULL;
	UINT iRes = GetMachineConfigDirectory(WSZ_PRODUCT_IIS, NULL, 0);
	if(!iRes)
		return HRESULT_FROM_WIN32(GetLastError());

	*o_pwszFilePath = new WCHAR[iRes+(lstrlen(wszFileName)) + 2];
	if(NULL == *o_pwszFilePath)
		return E_OUTOFMEMORY;

	iRes = GetMachineConfigDirectory(WSZ_PRODUCT_IIS, *o_pwszFilePath, iRes);

	if(!iRes)
	{
		if (*o_pwszFilePath)
		{
			delete [] *o_pwszFilePath;
			*o_pwszFilePath = NULL;
		}
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if((*o_pwszFilePath)[lstrlen(*o_pwszFilePath)-1] != L'\\')
	{
		Wszlstrcat(*o_pwszFilePath, L"\\");
	}
	Wszlstrcat(*o_pwszFilePath, wszFileName);
	WszCharUpper(*o_pwszFilePath);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\dispenser\cstdisp.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef STDISPENSER_H
#define STDISPENSER_H

#include "catalog.h"
#include "..\eventmgr\stevent.h"
#include "..\FileChng\FileChng.h"
#include "CatMeta.h"
#include <atlbase.h>
#include "SmartPointer.h"
#ifndef __MBSCHEMACOMPILATION_H__
    #include "MBSchemaCompilation.h"
#endif

// Pointer to DllGetSimpleObject kind of functions
typedef HRESULT( __stdcall *PFNDllGetSimpleObjectByID)( ULONG, REFIID, LPVOID);

/*
// WT -wiring type constants 
// these specify wether the object should be wired on read or write scenarios
// Are used in combination with OT constants
#define eST_WT_WRITEONLY		0x00000000 //default
#define eST_WT_READWRITE		0x00000001

// Interceptor types
#define eST_INTERCEPTOR_FIRST	0x00000001
#define eST_INTERCEPTOR_NEXT	0x00000002
*/

// Dumb map between dll names and pointers to their dllgetsimpleobject
// It does not grow, and it does not do hashing
// Add is not thread safe, GetProcAddress is.
// Should be good enough though
#define CDLLMAPMAXCOUNT 10
class CDllMap
{
public:
	CDllMap();
	HRESULT GetProcAddress(LPWSTR wszDllName, PFNDllGetSimpleObjectByID *pfnDllGetSimpleObject);
private:
	HRESULT Load(LPWSTR wszDllName, PFNDllGetSimpleObjectByID *pfnDllGetSimpleObject);
	
	ULONG						m_iFree;
	LPWSTR						m_awszDllName[CDLLMAPMAXCOUNT];
	PFNDllGetSimpleObjectByID	m_apfn[CDLLMAPMAXCOUNT];
};

// Helper structure for passing in the primary key for the server wiring table
typedef struct tagPKHelper
{
	ULONG  *pTableID;
	ULONG  *porder;
} PKHelper;


// The simple table dispenser class
class CSimpleTableDispenser :
    public IAdvancedTableDispenser, 
    public IMetabaseSchemaCompiler,
	public ICatalogErrorLogger,
	public ISimpleTableAdvise, 
	public ISimpleTableEventMgr, 
	public ISimpleTableFileAdvise, 
	public ISnapshotManager
{
//IUnknown
public:
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

// ISimpleTableDispenser2 (IAdvancedTableDispenser derives from ISimpleTableDispenser2)
public:
	STDMETHOD (GetTable)	(
							/*[in]*/ LPCWSTR			i_wszDatabase, 
							/*[in]*/ LPCWSTR			i_wszTable, 
							/*[in]*/ LPVOID				i_QueryData,
							/*[in]*/ LPVOID				i_QueryMeta,
							/*[in]*/  DWORD				i_eQueryFormat,
							/*[in]*/ DWORD				i_fServiceRequests, 
							/*[out]*/ LPVOID*			o_ppIST
							);


//IAdvancedTableDispenser
public:
    STDMETHOD (GetMemoryTable)  (
							/*[in]*/	LPCWSTR					i_wszDatabase,
                            /*[in]*/    LPCWSTR                 i_wszTable, 
							/*[in]*/	ULONG					i_TableID,
                            /*[in]*/    LPVOID                  i_QueryData,
                            /*[in]*/    LPVOID                  i_QueryMeta,
                            /*[in]*/    DWORD                   i_eQueryFormat,
                            /*[in]*/    DWORD                   i_fServiceRequests, 
                            /*[out]*/   ISimpleTableWrite2**    o_ppISTWrite
                            );
    STDMETHOD (GetProductID)   (
                            /*[out]*/       LPWSTR				o_wszProductID,
                            /*[in, out]*/   DWORD * 			io_pcchProductID
                            );
    STDMETHOD (GetCatalogErrorLogger)   (
                            /*[out]*/ ICatalogErrorLogger2 **	o_ppErrorLogger
                            );
    STDMETHOD (SetCatalogErrorLogger)   (
                            /*[in]*/  ICatalogErrorLogger2 *	i_pErrorLogger
                            );

//IMetabaseSchemaCompiler
public:
    STDMETHOD (Compile)     (
                            /*[in]*/ LPCWSTR                 i_wszExtensionsXmlFile,
                            /*[in]*/ LPCWSTR                 i_wszResultingOutputXmlFile
                            );
    STDMETHOD (GetBinFileName)(
                            /*[out]*/ LPWSTR                  o_wszBinFileName,
                            /*[out]*/ ULONG *                 io_pcchSizeBinFileName
                            );
    STDMETHOD (SetBinPath)  (
                            /*[in]*/ LPCWSTR                 i_wszBinPath
                            );
    STDMETHOD (ReleaseBinFileName)(
							/*[in]*/ LPCWSTR                 i_wszBinFileName
							);

//ICatalogErrorLogger
    STDMETHOD (LogError)    (
                            /*[in]*/ HRESULT                 i_hrErrorCode,
                            /*[in]*/ ULONG                   i_ulCategory,
                            /*[in]*/ ULONG                   i_ulEvent,
                            /*[in]*/ LPCWSTR                 i_szSource,
                            /*[in]*/ ULONG                   i_ulLineNumber
                            );

// ISimpleTableAdvise
public:
	STDMETHOD(SimpleTableAdvise)(ISimpleTableEvent	*i_pISTEvent, DWORD i_snid, MultiSubscribe *i_ams, ULONG i_cms, DWORD *o_pdwCookie);
	STDMETHOD(SimpleTableUnadvise)(	DWORD			i_dwCookie);


// ISimpleTableEventMgr
public:

	STDMETHOD(IsTableConsumed)(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable);
	STDMETHOD(AddUpdateStoreDelta) (LPCWSTR i_wszTableName, char* i_pWriteCache, ULONG i_cbWriteCache, ULONG i_cbWriteVarData);
	
	STDMETHOD(FireEvents)(ULONG i_snid);
	STDMETHOD(CancelEvents)();
	STDMETHOD(RehookNotifications)();
	STDMETHOD(InitMetabaseListener)();
	STDMETHOD(UninitMetabaseListener)();

// ISimpleTableFileAdvise
public:
	STDMETHOD(SimpleTableFileAdvise)(ISimpleTableFileChange	*i_pISTFile, LPCWSTR i_wszDirectory, LPCWSTR i_wszFile, DWORD i_fFlags, DWORD *o_pdwCookie);
	STDMETHOD(SimpleTableFileUnadvise)(DWORD i_dwCookie);

// ISnapshotManager
public:
	STDMETHOD(QueryLatestSnapshot)(SNID* o_psnid);
	STDMETHOD(AddRefSnapshot)(SNID i_snid);
	STDMETHOD(ReleaseSnapshot)(SNID i_snid);

// Class methods
public:
    CSimpleTableDispenser();
    CSimpleTableDispenser(LPCWSTR wszProductID);
    ~CSimpleTableDispenser();
	HRESULT Init();
	static HRESULT GetFilePath(LPWSTR *o_pwszFilePath);

private:
	HRESULT CreateSimpleObjectByID(ULONG i_ObjectID, LPWSTR i_wszDllName, REFIID riid, LPVOID* o_ppv);
	HRESULT CreateTableObjectByID(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat, 
				  DWORD	i_fServiceRequests, LPVOID i_pUnderTable, tSERVERWIRINGMETARow * pSWColumns, LPVOID * o_ppIST);
	HRESULT GetMetaTable(ULONG TableID, LPVOID QueryData, LPVOID QueryMeta, DWORD eQueryFormat, LPVOID *ppIST);
    HRESULT GetXMLTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat, DWORD	i_fServiceRequests, LPVOID*	o_ppIST);
    HRESULT HardCodedIntercept(eSERVERWIRINGMETA_Interceptor interceptor, LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat, 
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST) const;
	HRESULT InitDllMap();
	HRESULT InitEventManager();
	HRESULT InitFileChangeMgr();
    HRESULT InternalGetTable( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat, 
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST);
	HRESULT IsTableConsumedByID(ULONG TableID);
	
	CComPtr<ISimpleTableRead2>	m_spClientWiring;
	CComPtr<ISimpleTableRead2>	m_spServerWiring;

	CDllMap				*m_pDllMap;
	
	CSTEventManager		*m_pEventMgr;
	CSTFileChangeManager *m_pFileChangeMgr;

    WCHAR               m_wszProductID[32];//TO DO: We need to document that ProductID must be no longer than 31 characters
    TMBSchemaCompilation m_MBSchemaCompilation;
    CComPtr<ICatalogErrorLogger2> m_spErrorLogger;

	// we are trying to keep the workingset to a minimum. 
	// When possible, don't add member variables to the dispenser

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\eventmgr\delta.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// =======================================================================
// @todo: Do proper locking for thread-safety.
// =======================================================================
#include "delta.h"
#include "catmacros.h"
#include "catmeta.h"

// =======================================================================
HRESULT CDeltaCache::AddUpdateStoreDelta(
	LPCWSTR		i_wszTableName, 
	char*		i_pWriteCache, 
	ULONG		i_cbWriteCache, 
	ULONG		i_cbWriteVarData)
{
	UpdateStoreDelta* pDelta;
	HRESULT		hr = S_OK;

	ASSERT(i_wszTableName && i_pWriteCache);

	//  If this is the first UpdateStoreDelta for this Snapshot, create LatestSnapshotDelta.
	if (m_pLatestSnapshotDelta == NULL)
	{
		m_pLatestSnapshotDelta = new Array<UpdateStoreDelta>;
		if (m_pLatestSnapshotDelta == NULL)  { return E_OUTOFMEMORY; }
	}

	ASSERT(m_pLatestSnapshotDelta != NULL);

	// Alloc room for a new UpdateStoreDelta.
	try
	{
		m_pLatestSnapshotDelta->setSize(m_pLatestSnapshotDelta->size()+1);
	}
	catch(HRESULT e)
	{
		ASSERT(E_OUTOFMEMORY == e);
		return e;//Array should only throw E_OUTOFMEMORY;
	}

	pDelta = &(*m_pLatestSnapshotDelta)[m_pLatestSnapshotDelta->size()-1];
	ZeroMemory(pDelta, sizeof(UpdateStoreDelta));

	// Copy the table name.
	pDelta->wszTableName = new WCHAR[wcslen(i_wszTableName) + 1];
	if (pDelta->wszTableName == NULL) 
	{ 
		hr = E_OUTOFMEMORY; 
		goto Cleanup;
	}
	wcscpy(pDelta->wszTableName, i_wszTableName);

	// Copy delta info.
	pDelta->pWriteCache = i_pWriteCache;
	pDelta->cbWriteCache = i_cbWriteCache;
	pDelta->cbWriteVarData = i_cbWriteVarData;

Cleanup:
	if (FAILED(hr))
	{
		// We don't clean i_pWriteCache, in case of failure it is the caller's
		// responsibilty to clean it up.
		ASSERT(pDelta);
		if (pDelta->wszTableName)
		{
			delete [] pDelta->wszTableName;
		}
		m_pLatestSnapshotDelta->deleteAt(m_pLatestSnapshotDelta->size()-1);
	}

	return hr;
}

// =======================================================================
HRESULT CDeltaCache::CommitLatestSnapshotDelta(
	SNID		i_snid)
{
	// If the current txn, didn't update any of the listened tables, there is no delta to store.
	if (m_pLatestSnapshotDelta == NULL)
	{
		return S_OK;
	}

	// Add a new SnapshotDelta.
	try
	{
		m_aDeltaCache.setSize(m_aDeltaCache.size()+1);
	}
	catch(...)
	{
		return E_OUTOFMEMORY;
		
	}
	m_aDeltaCache[m_aDeltaCache.size()-1].snid = i_snid;
	m_aDeltaCache[m_aDeltaCache.size()-1].paSnapshotDelta = m_pLatestSnapshotDelta;
	m_pLatestSnapshotDelta = NULL;

#ifdef _DEBUG
	dbgValidate();
#endif
	return S_OK;
}

// =======================================================================
HRESULT CDeltaCache::AbortLatestSnapshotDelta()
{
	if (m_pLatestSnapshotDelta != NULL)
	{
		UninitSnapshotDelta(m_pLatestSnapshotDelta);
		delete m_pLatestSnapshotDelta;
		m_pLatestSnapshotDelta = NULL;
	}
	return S_OK;
}

// =======================================================================
void CDeltaCache::DeleteOldSnapshots(
	SNID		i_snid)
{
	LONG		iSnap;

	// Delete the old SnapshotDeltas.
	for (iSnap = m_aDeltaCache.size() - 1; iSnap >= 0; iSnap--)
	{
		if (m_aDeltaCache[iSnap].snid < i_snid)
		{
			ASSERT(m_aDeltaCache[iSnap].paSnapshotDelta);
			UninitSnapshotDelta(m_aDeltaCache[iSnap].paSnapshotDelta);
			delete m_aDeltaCache[iSnap].paSnapshotDelta;
			m_aDeltaCache.deleteAt(iSnap);
		}
	}
}


// =======================================================================
void CDeltaCache::Uninit()
{
	DeleteOldSnapshots();

	// Delete the LatestSnapshotDelta.
	AbortLatestSnapshotDelta();
}

// =======================================================================
void CDeltaCache::UninitSnapshotDelta(
	Array<UpdateStoreDelta>	*i_paSnapshotDelta)
{
	ULONG		iUSDelta;
	
	ASSERT(i_paSnapshotDelta);
	for (iUSDelta = 0; iUSDelta < i_paSnapshotDelta->size(); iUSDelta++)
	{
		UninitUpdateStoreDelta(&(*i_paSnapshotDelta)[iUSDelta]);
	}
}

// =======================================================================
void CDeltaCache::UninitUpdateStoreDelta(
	UpdateStoreDelta* i_pDelta)
{
	if (i_pDelta->wszTableName)
	{
		delete [] i_pDelta->wszTableName;
	}
	if (i_pDelta->pWriteCache)
	{
		delete [] i_pDelta->pWriteCache;
	}
}

#ifdef _DEBUG
void CDeltaCache::dbgValidate()
{
	for (ULONG iDelta = 0; iDelta < m_aDeltaCache.size(); iDelta++)
	{
		ASSERT(m_aDeltaCache[iDelta].paSnapshotDelta != NULL);
		for (ULONG iUSDelta = 0; iUSDelta < m_aDeltaCache[iDelta].paSnapshotDelta->size(); iUSDelta++)
		{
			ASSERT(_CrtIsValidPointer((*m_aDeltaCache[iDelta].paSnapshotDelta)[iUSDelta].wszTableName, sizeof(WCHAR), TRUE));
			ASSERT(_CrtIsValidPointer((*m_aDeltaCache[iDelta].paSnapshotDelta)[iUSDelta].pWriteCache, (*m_aDeltaCache[iDelta].paSnapshotDelta)[iUSDelta].cbWriteCache, TRUE));
		}
	}

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\entrypoint\amap.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    amap.cpp

$Header: $

Abstract:

Revision History:

--**************************************************************************/

#include <objbase.h>
#include "amap.h"

void CATLIBOnWinnt();

extern BOOL g_bOnWinnt;

AMap::AMap()
{
	Initialize();
}

AMap::~AMap ()
{
	for (int idx=0; idx<mIndex; ++idx)
	{
		delete[] mawszDllName[idx];
	}
}

void AMap::Initialize(void)
{
	mIndex = 0;
	CATLIBOnWinnt();//Check if we are running on Winnt so unicode version of WIN32 APIs are supported. 
}

HRESULT AMap::Put(LPWSTR wszProduct, HINSTANCE hDll, PFNDllGetSimpleObjectByID pfn)
{
	HRESULT hr = S_OK;
	int i = mIndex;
	DWORD       dwRes       = ERROR_SUCCESS; 
	CSafeLock   csSafe(mSafeCritSec);

	if(mIndex >= AMAPMAXSIZE) return E_OUTOFMEMORY;

	dwRes = csSafe.Lock();
	
	if(ERROR_SUCCESS != dwRes)
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	if(i != mIndex)
	{
		PFNDllGetSimpleObjectByID pFN = NULL;

		hr = Get(wszProduct,
			     &pFN);

		// somebody added stuff to the map in the mean time
		if ((NULL != pFN) || FAILED(hr))
		{
			csSafe.Unlock();

			return hr ;
		}
	}

	if(mIndex >= AMAPMAXSIZE)
	{	
		// we're over the limit
		csSafe.Unlock();

		return E_OUTOFMEMORY;
	}

	mawszDllName[mIndex] = new WCHAR [(::lstrlen(wszProduct) + 1) * sizeof(WCHAR)];

	if (mawszDllName[mIndex])
	{
		::Mystrcpy(mawszDllName[mIndex], wszProduct);
		mapfn[mIndex] = pfn;
		mahDll[mIndex] = hDll;

		mIndex++; // this is done after the pfn is set, so get will work
	}
	else 
	{
		hr = E_OUTOFMEMORY;
	}

	csSafe.Unlock();

	return hr;
}

HRESULT AMap::Get(LPWSTR                     wszProduct,
				  PFNDllGetSimpleObjectByID* o_pFn)
{
	DWORD       dwRes       = ERROR_SUCCESS; 
	CSafeLock   csSafe(mSafeCritSec);

	*o_pFn = NULL;

	dwRes = csSafe.Lock();

	if(ERROR_SUCCESS != dwRes)
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	for (int i = 0; i<mIndex; i++)
	{
		if( 0 ==  ::Mystrcmp(wszProduct, mawszDllName[i]))
		{
			*o_pFn = mapfn[i];
			break;
		}
	}

	csSafe.Unlock();

	return S_OK;
}

HRESULT 
AMap::Delete (LPWSTR wszProduct)
{
	DWORD       dwRes       = ERROR_SUCCESS; 
	CSafeLock   csSafe(mSafeCritSec);

	dwRes = csSafe.Lock();

	if(ERROR_SUCCESS != dwRes)
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	for (int idx=0; idx<mIndex; ++idx)
	{
		if (0 == ::Mystrcmp (wszProduct, mawszDllName[idx]))
		{
			delete[] mawszDllName[idx];
			if (mahDll[idx] != 0)
			{
				FreeLibrary (mahDll[idx]);
			}

			// mIndex point to the next available slot, so one passed the last
			// used one.
			if (mIndex > 1)
			{
				mawszDllName[idx]		= mawszDllName[mIndex - 1];
				mahDll[idx]				= mahDll[mIndex-1];
				mapfn[idx]				= mapfn[mIndex-1];
			}
			mawszDllName[mIndex]	= 0;
			mahDll[mIndex]			= 0;
			mapfn[mIndex]			= 0;
			mIndex--;
		}
	}
	csSafe.Unlock();

	return S_OK;
}

LPWSTR Mystrcpy( LPWSTR lpString1, LPCWSTR lpString2)
{
	if (g_bOnWinnt)
		return lstrcpyW( lpString1, lpString2 );

	if ( 0 == lpString1 || 0 == lpString2)
		return NULL;

	LPWSTR wszRet = lpString1;

	while (*lpString1++ = *lpString2++);

	return wszRet;
}

// This one return 0 if the string are equal and something else otherwise
int Mystrcmp( LPWSTR lpString1, LPCWSTR lpString2)
{
	if (g_bOnWinnt)
		return lstrcmpW( lpString1, lpString2 );

	if (!lpString1 || !lpString2)
	{
		if ( !lpString1 && !lpString2)
			return 0;  // two null strings are equal
		else
			return 1;
	}
	else
	{
		while (*lpString1 == *lpString2)
		{
			if (!(*lpString1)) 
			{
				return (*lpString2); 
			}
			else if (!(*lpString2)) return 1;

			lpString1++;
			lpString2++;
		};

		return 1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\entrypoint\amap.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    amap.h

$Header: $

Abstract:

Revision History:

--**************************************************************************/

#ifndef __AMAP_H__
#define __AMAP_H__

#pragma once
// Pointer to DllGetSimpleObject kind of functions
typedef HRESULT( __stdcall *PFNDllGetSimpleObjectByID)( ULONG, REFIID, LPVOID);

#define AMAPMAXSIZE 10
#include "SafeCS.h"

class AMap
{
public:
	AMap();
	~AMap();

	void Initialize(void);

	HRESULT Put(LPWSTR wszProduct, HINSTANCE hDll, PFNDllGetSimpleObjectByID pfn);
	HRESULT Get(LPWSTR                     wszProduct,
		        PFNDllGetSimpleObjectByID* o_pFn);
	HRESULT Delete (LPWSTR wszProduct);
	
private:
	int mIndex;
	CSafeAutoCriticalSection mSafeCritSec;

	LPWSTR mawszDllName[AMAPMAXSIZE];
	PFNDllGetSimpleObjectByID mapfn[AMAPMAXSIZE];
	HINSTANCE mahDll[AMAPMAXSIZE];
};

int Mystrcmp( LPWSTR lpString1, LPCWSTR lpString2);
LPWSTR Mystrcpy( LPWSTR lpString1, LPCWSTR lpString2);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\entrypoint\createdispenser.cpp ===
#include <objbase.h>
#include "initguid.h"
#include "catalog.h"
#include "catalog_i.c"

#include "amap.h"
#include "CatMeta.h"

// TODO: Move this to amap.h when maps are supported for this.
typedef HRESULT( __stdcall *PFNCookDownFunctions)(void);
typedef HRESULT( __stdcall *PFNUninitCookDownFunctions)(BOOL);
typedef HRESULT( __stdcall *PFNPostProcessChanges)(ISimpleTableWrite2*);

BOOL g_bOnWinnt = FALSE;

// Forward declaration
UINT GetDispenserDllPath(LPWSTR wszProduct, LPWSTR wszDispenserDLL, ULONG cSize);
HRESULT LoadDispenserDll(LPWSTR wszProduct, HINSTANCE* pHandle);

AMap g_ProductMap;

void CATLIBOnWinnt()
{
	OSVERSIONINFOA	sVer;
	sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	GetVersionExA(&sVer);

	g_bOnWinnt = (sVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

void InitializeSimpleTableDispenser(void)
{
	g_ProductMap.Initialize();
}

HRESULT GetSimpleTableDispenser(LPWSTR wszProduct, DWORD dwReserved, ISimpleTableDispenser2** o_ppISTDisp)
{
	PFNDllGetSimpleObjectByID pDllGetSimpleObject;
	HRESULT hr = S_OK;

	if(wszProduct == NULL)
        return E_INVALIDARG;

	if(dwReserved)
	{
		//TRACE(L"ERROR: The reserved parameter for GetSimpleTableDispenser must be 0");
		return E_INVALIDARG;
	}


	hr = g_ProductMap.Get(wszProduct,
		                  &pDllGetSimpleObject);

	if(FAILED(hr))
	{
		return hr;
	}

	if (NULL == pDllGetSimpleObject)
	{
		// Multiple threads can enter this if, but we're safe if we execute it multiple times
		HRESULT hr;
		HINSTANCE hDispenserDll;

		hr = LoadDispenserDll(wszProduct, &hDispenserDll);
		if(FAILED(hr))
			return hr;

		// get the address of DllGetSimpleObject procedure
		pDllGetSimpleObject = (PFNDllGetSimpleObjectByID) GetProcAddress (hDispenserDll, "DllGetSimpleObjectByID");
		if(NULL == pDllGetSimpleObject)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}

		// Add the pointer to dllgetsimpleobject to the map
		hr = g_ProductMap.Put(wszProduct, hDispenserDll, pDllGetSimpleObject);
		if (FAILED (hr))
		{
			return hr;
		}

        typedef HRESULT( __stdcall *PFNDllGetSimpleObjectByIDEx)( ULONG, REFIID, LPVOID, LPCWSTR);
        //The new function is for getting the dispenser - it requires the wszProduct.  It is used to build the Event Logging 'Source'
    	PFNDllGetSimpleObjectByIDEx pDllGetSimpleObjectEx;
		pDllGetSimpleObjectEx = (PFNDllGetSimpleObjectByIDEx) GetProcAddress (hDispenserDll, "DllGetSimpleObjectByIDEx");
		if(NULL != pDllGetSimpleObjectEx)
        	return (*pDllGetSimpleObjectEx) (eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, o_ppISTDisp, wszProduct);
	}
	
	// Call DllGetSimpleObject asking for the dispenser
	return (*pDllGetSimpleObject) (eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, o_ppISTDisp);
}


UINT GetDispenserDllPath(LPWSTR wszProduct, LPWSTR wszDispenserDLL, ULONG cSize)
{
	HKEY hKey;
	DWORD dwRes = 0;

	if ( g_bOnWinnt )
	{
		WCHAR  wszDispenserDllKey[MAX_PATH];

		lstrcpyW(wszDispenserDllKey, L"Software\\Microsoft\\Catalog42\\");
		if((lstrlenW(wszDispenserDllKey)+lstrlenW(wszProduct)+1) > MAX_PATH)
		{
			SetLastError(ERROR_INSUFFICIENT_BUFFER);
			return 0;
		}
		lstrcatW(wszDispenserDllKey, wszProduct);

		// Try to read the dll path from the registry
		if (ERROR_SUCCESS == RegOpenKeyEx (HKEY_LOCAL_MACHINE, wszDispenserDllKey, 0, KEY_READ, &hKey))
		{
			WCHAR wszRegDispenserDLL[MAX_PATH];
			ULONG cRegSize = MAX_PATH * sizeof(WCHAR);
			WCHAR* wszDispenserDllNamedValue = L"Dll";

			if (ERROR_SUCCESS == RegQueryValueEx (hKey, wszDispenserDllNamedValue, NULL, NULL, (BYTE*)wszRegDispenserDLL, &cRegSize))
			{
				RegCloseKey (hKey);

				// Expand registry key
				dwRes = ExpandEnvironmentStrings(wszRegDispenserDLL, wszDispenserDLL, cSize);
				
				return dwRes;

			}
			else
			{
				RegCloseKey (hKey);
			}
		}

		// Nothing usefull in the registry, just expand "%systemdrive%\Catalog42"
		dwRes = ExpandEnvironmentStrings(L"%systemdrive%\\Catalog42\\catalog.dll", wszDispenserDLL, cSize);

		return dwRes;
	}
	else
	{

		char szProduct[128];
		char szDispenserDllKey[MAX_PATH];
		char szDispenserDLL[MAX_PATH];
		UINT uRet = 0;
		LPSTR pszCurPos;

		dwRes = WideCharToMultiByte(CP_ACP,0,wszProduct,-1,szProduct,128,NULL,NULL);
		if (!dwRes)
			return dwRes; // SetLastError already set. Error if buffer is insufficient.

		lstrcpyA(szDispenserDllKey, "Software\\Microsoft\\Catalog42\\");
		if((lstrlenA(szDispenserDllKey)+lstrlenA(szProduct)+1) > MAX_PATH)
		{
			SetLastError(ERROR_INSUFFICIENT_BUFFER);
			return 0;
		}
		lstrcatA(szDispenserDllKey, szProduct);

		// Try to read the dll path from the registry
		if (ERROR_SUCCESS == RegOpenKeyExA (HKEY_LOCAL_MACHINE, szDispenserDllKey, 0, KEY_READ, &hKey))
		{
			char* szDispenserDllNamedValue = "Dll";
			char szRegDispenserDLL[MAX_PATH];
			ULONG cRegSize = MAX_PATH;

			if (ERROR_SUCCESS == RegQueryValueExA (hKey, szDispenserDllNamedValue, NULL, NULL, (BYTE*)szRegDispenserDLL, &cRegSize))
			{
				RegCloseKey (hKey);

				// Expand registry key
				dwRes = ExpandEnvironmentStringsA(szRegDispenserDLL, szDispenserDLL, MAX_PATH);
				if(!dwRes)
					return dwRes; // SetLastError already set.

				
				dwRes =	MultiByteToWideChar(CP_ACP,0,szDispenserDLL,-1,wszDispenserDLL, cSize);

				return dwRes;

			}
			else
			{
				RegCloseKey (hKey);
			}
		}

		// Nothing usefull in the registry, just expand "%systemdrive%\Catalog42"
		// There's no %systemdrive% on Win9x, to do the equivalent, Get windows directory, and then 
		// remove everything on the right of the first backslash we encounter.
		uRet = GetWindowsDirectoryA( szDispenserDLL, MAX_PATH);
		if ( !uRet )
			return uRet;

		if ( (uRet + lstrlenA("\\Catalog42\\catalog.dll") + 1) > MAX_PATH )
		{
			SetLastError(ERROR_INSUFFICIENT_BUFFER);
			return 0;
		}

		pszCurPos = szDispenserDLL;

		while (*pszCurPos != '\0' && *pszCurPos != '\\')
			pszCurPos++;

		if (*pszCurPos == '\\')
		{
			*pszCurPos = '\0';
		}

		if (!lstrcatA( szDispenserDLL, "\\Catalog42\\catalog.dll") )
			return 0;

		dwRes = MultiByteToWideChar(CP_ACP,0,szDispenserDLL,-1,wszDispenserDLL,cSize);
	
		return dwRes;
	}
	
}

HRESULT GetEntryPoint(LPWSTR                wszProduct,
					  LPSTR                 szFunctionName,
					  PFNCookDownFunctions* ppfn)
{
	HINSTANCE handle;
	HRESULT   hr = S_OK;

	// TODO: Add map support; Fetch from a map

	hr = LoadDispenserDll(wszProduct, &handle);
	if (FAILED (hr))
		return hr;

	// Get the address of DllGetSimpleObject procedure
	*ppfn = (PFNCookDownFunctions) GetProcAddress (handle, szFunctionName);
	if(NULL == *ppfn)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}


HRESULT GetUninitEntryPoint(LPWSTR                      wszProduct,
		 			        LPSTR                       szFunctionName,
					        PFNUninitCookDownFunctions* ppfn)
{
	HINSTANCE handle;
	HRESULT   hr = S_OK;

	// TODO: Add map support; Fetch from a map

	hr = LoadDispenserDll(wszProduct, &handle);
	if (FAILED (hr))
		return hr;

	// Get the address of DllGetSimpleObject procedure
	*ppfn = (PFNUninitCookDownFunctions) GetProcAddress (handle, szFunctionName);
	if(NULL == *ppfn)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}

HRESULT CookDown(LPWSTR wszProduct)
{
	static PFNCookDownFunctions pCookDownFunctionInternal = NULL;
	HRESULT                     hr                        = S_OK;

	if(0 != ::Mystrcmp (wszProduct, WSZ_PRODUCT_IIS))
		return E_INVALIDARG;

	if(NULL == pCookDownFunctionInternal)
	{
		// Multiple threads can enter this if, but we're safe if we execute it multiple times

		hr = GetEntryPoint(wszProduct,
			               "CookDownInternal",
					       &pCookDownFunctionInternal);
		if(FAILED(hr))
			return hr;

	}

	// Call CookDownInternal
	return (*pCookDownFunctionInternal)();
}


HRESULT RecoverFromInetInfoCrash(LPWSTR wszProduct)
{
	static PFNCookDownFunctions pRecoverFromInetInfoCrashInternal = NULL;
	HRESULT                     hr                                = S_OK;

	if(0 != ::Mystrcmp (wszProduct, WSZ_PRODUCT_IIS))
		return E_INVALIDARG;

	if(NULL == pRecoverFromInetInfoCrashInternal)
	{
		// Multiple threads can enter this if, but we're safe if we execute it multiple times

		hr = GetEntryPoint(wszProduct,
			               "RecoverFromInetInfoCrashInternal",
					       &pRecoverFromInetInfoCrashInternal);
		if(FAILED(hr))
			return hr;

	}

	// Call RecoverFromInetInfoCrashInternal
	return (*pRecoverFromInetInfoCrashInternal)();

}


HRESULT UninitCookdown(LPWSTR wszProduct,
					   BOOL   bDoNotTouchMetabase)
{
	static PFNUninitCookDownFunctions pUninitCookdownInternal = NULL;
	HRESULT                     hr                      = S_OK;

	if(0 != ::Mystrcmp (wszProduct, WSZ_PRODUCT_IIS))
		return E_INVALIDARG;

	if(NULL == pUninitCookdownInternal)
	{
		// Multiple threads can enter this if, but we're safe if we execute it multiple times

		hr = GetUninitEntryPoint(wszProduct,
			                     "UninitCookdownInternal",
					             &pUninitCookdownInternal);
		if(FAILED(hr))
			return hr;

	}

	// Call UninitCookdownInternal
	return (*pUninitCookdownInternal)(bDoNotTouchMetabase);

}


HRESULT LoadDispenserDll(LPWSTR wszProduct, HINSTANCE* pHandle)
{
	WCHAR wszDispenserDLL[MAX_PATH];
	UINT iRes=0;

	iRes = GetDispenserDllPath(wszProduct, wszDispenserDLL, MAX_PATH);
	if (!iRes)
		return HRESULT_FROM_WIN32(GetLastError());

	if ( g_bOnWinnt )
	{
		*pHandle = LoadLibrary (wszDispenserDLL);
	}
	else
	{
		char szDispenserDLL[MAX_PATH];
		if ( 0 == WideCharToMultiByte(CP_ACP,0,wszDispenserDLL,-1,szDispenserDLL,MAX_PATH,NULL,NULL) )
			return HRESULT_FROM_WIN32(GetLastError());

		// Load the library in which the dispenser resides
		*pHandle = LoadLibraryA (szDispenserDLL);
	}

	if(NULL == *pHandle)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

STDAPI 
UnloadDispenserDll (LPWSTR wszProduct)
{
	HRESULT hr = S_OK;

	hr = g_ProductMap.Delete (wszProduct);

	return hr;
}

HRESULT PostProcessChanges(ISimpleTableWrite2  *i_pISTWrite)
{
	static PFNPostProcessChanges    pPostProcessChangesInternal = NULL;
	HINSTANCE                       handle;
	HRESULT                         hr                          = S_OK;

	if(NULL == pPostProcessChangesInternal)
	{
	    hr = LoadDispenserDll(WSZ_PRODUCT_IIS, &handle);
	    if (FAILED (hr))
		    return hr;

	    // Get the address of DllGetSimpleObject procedure
	    pPostProcessChangesInternal = (PFNPostProcessChanges) GetProcAddress (handle, "PostProcessChangesInternal");
	    if(NULL == pPostProcessChangesInternal)
	    {
		    return HRESULT_FROM_WIN32(GetLastError());
	    }

	}

	// Call CookDownInternal
	return (*pPostProcessChangesInternal)(i_pISTWrite);
}


UINT GetMachineConfigDirectory(LPWSTR wszProduct, LPWSTR lpBuffer, UINT uSize)
{
	HKEY    hKey;
	HRESULT hr = S_OK;
	DWORD   hRes = 0;

	if ( g_bOnWinnt )
	{
		DWORD  cbRegSize = MAX_PATH * sizeof(WCHAR);
		WCHAR  wszMachineConfigDirectoryKey[MAX_PATH];

		lstrcpyW(wszMachineConfigDirectoryKey, L"Software\\Microsoft\\Catalog42\\");

		if((lstrlenW(wszMachineConfigDirectoryKey)+lstrlenW(wszProduct)+1) > MAX_PATH)
		{
			SetLastError(ERROR_INSUFFICIENT_BUFFER);
			return 0;
		}

		lstrcatW(wszMachineConfigDirectoryKey, wszProduct);

		// Try to read the dll path from the registry

		hRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, wszMachineConfigDirectoryKey, 0, KEY_READ, &hKey);

		if (ERROR_SUCCESS == hRes)
		{
			WCHAR* wszMachineConfigDirectoryNamedValue = L"MachineConfigDirectory";
			WCHAR  wszRegMachineConfigDirectory[MAX_PATH];

			hRes = RegQueryValueEx (hKey, wszMachineConfigDirectoryNamedValue, NULL, NULL, (BYTE*)wszRegMachineConfigDirectory, &cbRegSize);

			if (ERROR_SUCCESS == hRes)
			{
				RegCloseKey (hKey);

				// Expand registry key
				hRes = ExpandEnvironmentStrings(wszRegMachineConfigDirectory, lpBuffer, uSize);

				return hRes;
			}
			else
			{
				RegCloseKey (hKey);

				if(ERROR_MORE_DATA == hRes)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

			}
		}


	}
	else
	{

		char  szProduct[128];
		char  szMachineConfigDirectoryKey[MAX_PATH];
		DWORD cbRegSize = MAX_PATH * sizeof(char);
		LPSTR pszCurPos;

		hRes = WideCharToMultiByte(CP_ACP,0,wszProduct,-1,szProduct,128,NULL,NULL);
		if(!hRes)
			return hRes;

		lstrcpyA(szMachineConfigDirectoryKey, "Software\\Microsoft\\Catalog42\\");
		if((lstrlenA(szMachineConfigDirectoryKey)+lstrlenA(szProduct)+1) > MAX_PATH)
		{
			SetLastError(ERROR_INSUFFICIENT_BUFFER);
			return 0;
		}
		lstrcatA(szMachineConfigDirectoryKey, szProduct);

		// Try to read the dll path from the registry

		hRes = RegOpenKeyExA (HKEY_LOCAL_MACHINE, szMachineConfigDirectoryKey, 0, KEY_READ, &hKey);

		if (ERROR_SUCCESS == hRes)
		{
			char*  szMachineConfigDirectoryNamedValue = "MachineConfigDirectory";
			char   szRegMachineConfigDirectory[MAX_PATH];
			char   szMachineConfigDirectory[MAX_PATH];

			ULONG cRegSize = MAX_PATH;

			hRes = RegQueryValueExA (hKey, szMachineConfigDirectoryNamedValue, NULL, NULL, (BYTE*)szRegMachineConfigDirectory, &cbRegSize);

			if(ERROR_SUCCESS == hRes)
			{
				RegCloseKey (hKey);

				// Expand registry key

				hRes = ExpandEnvironmentStringsA(szRegMachineConfigDirectory, szMachineConfigDirectory, MAX_PATH);

				if(!hRes)
					return hRes;
				
				if (uSize < hRes)
					return hRes;

				if (hRes > MAX_PATH)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				hRes = MultiByteToWideChar(CP_ACP, 0, szMachineConfigDirectory, -1, lpBuffer, uSize);

				return hRes;

			}
			else
			{
				RegCloseKey (hKey);

				if(ERROR_MORE_DATA == hRes)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}
			}
		}

	}

	// Nothing usefull in the registry, assume dispenser dll directory

	hRes = GetDispenserDllPath(wszProduct, lpBuffer, uSize);
	if(!hRes)
		return hRes;

	if(hRes > uSize)
		return hRes;

	WCHAR* wszCatalogDll = lpBuffer + lstrlenW(lpBuffer) - 1;

	while(*(--wszCatalogDll) != L'\\')
		;

	wszCatalogDll++;

	if(NULL != wszCatalogDll)
		*wszCatalogDll = NULL;
	else
	{
		SetLastError(ERROR_INVALID_NAME);
		return 0;
	}

	return lstrlenW(lpBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\eventmgr\delta.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef __DELTA_H__
#define __DELTA_H__

#include "catalog.h"
#include "array_t.h"
#include "limits.h"

// Stores the delta created in a single UpdateStore, not necessarily the snapshot delta.
struct UpdateStoreDelta
{
	LPWSTR	wszTableName;
	char*	pWriteCache;
	ULONG	cbWriteCache;
	ULONG	cbWriteVarData;
};

// An entry in the CDeltaCache contains the snapshot id and the snapshot delta which may
// consist of several UpdateStoreDeltas.
struct DeltaCacheEntry
{
	SNID			snid;
	Array<UpdateStoreDelta>	*paSnapshotDelta;
};


class CDeltaCache
{
public:
	CDeltaCache() : m_pLatestSnapshotDelta(NULL)
	{}

	~CDeltaCache()
	{
		Uninit();
	}

	HRESULT AddUpdateStoreDelta(LPCWSTR i_wszTableName, char* i_pWriteCache, ULONG i_cbWriteCache, ULONG i_cbWriteVarData);
	HRESULT CommitLatestSnapshotDelta(SNID i_snid);
	HRESULT AbortLatestSnapshotDelta();
	ULONG GetLatestSnid()
	{	
		if (m_aDeltaCache.size() > 0)
		{
			return m_aDeltaCache[m_aDeltaCache.size()-1].snid;
		}
		return 0;
	}

	Array<DeltaCacheEntry>* GetDeltaCache()
	{	return &m_aDeltaCache;	}

void DeleteOldSnapshots(SNID i_snid = ULONG_MAX);

#ifdef _DEBUG
	void dbgValidate();
#endif
private:
	void Uninit();
	void UninitSnapshotDelta(Array<UpdateStoreDelta> *i_paSnapshotDelta);
	void UninitUpdateStoreDelta(UpdateStoreDelta* i_pDelta);

	Array<DeltaCacheEntry> m_aDeltaCache;
	Array<UpdateStoreDelta>	*m_pLatestSnapshotDelta;
};

#endif //__DELTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\eventmgr\stevent.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef __STEVENT_H__
#define __STEVENT_H__

#include "catalog.h"
#include "delta.h"
#include "array_t.h"
#include "utsem.h"
#include "mblisten.h"

// Event handles.
const ULONG	g_iHandleDone	= 0;
const ULONG	g_iHandleFire	= 1;
const ULONG	g_cHandles		= 2;

struct EventConsumerInfo
{
	ISimpleTableEvent	*pISTEvent;
	DWORD				snid;
	MultiSubscribe		*ams;
	ULONG				cms;
};

struct EventConsumer
{
	DWORD				dwCookie;
	EventConsumerInfo	*pInfo;
};

struct EventItem
{
	ISimpleTableEvent*		pISTEvent;
	ISimpleTableWrite2**	ppISTWrite;
	ULONG					cms;
	DWORD					dwCookie;
};

class CEventFirer
{
public:
	CEventFirer() 
	{
		for (ULONG i = 0; i < g_cHandles; i++)
		{
			m_aHandles[i] = NULL;
		}

		m_hThread = NULL;
	}

	~CEventFirer()
	{
		for (ULONG i = 0; i < g_cHandles; i++)
		{
			if (m_aHandles[i] != NULL) 
			{ 
				SetEvent(m_aHandles[i]);
				CloseHandle(m_aHandles[i]);
				m_aHandles[i]  = NULL;
			}
		}

		if (m_hThread)
		{
			CloseHandle(m_hThread);
			m_hThread = NULL;
		}
	}

	HRESULT Init();
	HRESULT AddEvent(ISimpleTableEvent* i_pISTEvent, ISimpleTableWrite2** i_ppISTWrite, ULONG i_cms, DWORD i_dwCookie);
	HRESULT Main();
	HRESULT FireEvents();
	HRESULT Done();

private:
	static UINT EventFirerThreadStart(LPVOID i_lpParam);

private:
	HANDLE			m_aHandles[g_cHandles];
	HANDLE			m_hThread;

	CSemExclusive	m_seEventQueueLock;
	Array<EventItem> m_aEventQueue;
};

class CSTEventManager 
{
public:
	CSTEventManager(IAdvancedTableDispenser* pISTDisp)
		: m_dwNextCookie(0), m_pEventFirer(NULL), m_pISTDisp(pISTDisp), m_pMBListener(NULL)
	{
		ASSERT(m_pISTDisp);
		m_pISTDisp->AddRef();
#ifdef _DEBUG
		dbg_cConsumer = 0;
#endif
	}

	~CSTEventManager()
	{
		if (m_pEventFirer)
		{
			delete m_pEventFirer;
		}
		if (m_pISTDisp != NULL)
		{
			m_pISTDisp->Release();
		}
		if (m_pMBListener != NULL)
		{
			m_pMBListener->Release();
		}
	}

// ISimpleTableAdvise
public:
	HRESULT InternalSimpleTableAdvise(ISimpleTableEvent	*i_pISTEvent,
										DWORD		i_snid,
										MultiSubscribe *i_ams,
										ULONG		i_cms,
										DWORD		*o_pdwCookie);

	HRESULT InternalSimpleTableUnadvise(DWORD		i_dwCookie);


// ISimpleTableEventMgr
public:
	HRESULT InternalIsTableConsumed (LPCWSTR i_wszDatabase, LPCWSTR i_wszTable);
	HRESULT InternalAddUpdateStoreDelta (LPCWSTR i_wszTableName, char* i_pWriteCache, ULONG i_cbWriteCache, ULONG i_cbWriteVarData)
	{
		return m_DeltaCache.AddUpdateStoreDelta(i_wszTableName, i_pWriteCache, i_cbWriteCache, i_cbWriteVarData);
	}
	
	HRESULT InternalFireEvents(ULONG i_snid);
	HRESULT InternalCancelEvents();
	HRESULT InternalRehookNotifications();
    HRESULT InitMetabaseListener();
    HRESULT UninitMetabaseListener();


private:
	HRESULT ValidateMultiSubscribe(MultiSubscribe *i_ams, ULONG i_cms);
	HRESULT InitConsumerInfo(EventConsumerInfo *i_pInfo, ISimpleTableEvent *i_pISTEvent, DWORD	i_snid,	MultiSubscribe *i_ams, ULONG i_cms);
	HRESULT UninitConsumerInfo(EventConsumerInfo *i_pInfo);
	HRESULT AddConsumer(EventConsumerInfo *i_pInfo, DWORD	*o_pdwCookie);
	HRESULT CreateWriteTable(LPWSTR i_wszDatabase, LPWSTR i_wszTable, char* i_pWriteCache, ULONG i_cbWriteCache, ULONG i_cbWriteVarData, ISimpleTableWrite2 **o_ppISTWrites);
	HRESULT AppendToWriteTable(char* i_pWriteCache, ULONG i_cbWriteCache, ULONG i_cbWriteVarData, ISimpleTableWrite2 *i_pISTWrites);
	HRESULT StartEventFirer();
	HRESULT StartStopListener(EventConsumerInfo *i_pInfo, BOOL bStart);
	HRESULT AddEvents();

#ifdef _DEBUG
	void	dbgValidateConsumerList();
	ULONG	dbg_cConsumer;
#endif

	DWORD GetNextCookie()
	{
		return ++m_dwNextCookie;
	}

	SNID GetNextSnid(SNID snid)
	{
		// @TODO: Do we need anything smarter than this.
		return ++snid;
	}

	CSemExclusive			m_seConsumerLock;
	Array<EventConsumer>	m_arrayConsumer;
	
	CDeltaCache				m_DeltaCache;
	DWORD					m_dwNextCookie;

	CEventFirer*			m_pEventFirer;
	IAdvancedTableDispenser* m_pISTDisp;

	CMetabaseListener		*m_pMBListener;
};
#endif //__STEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\eventtable\sltevent.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef __SLTEVENT_H__
#define __SLTEVENT_H__

#include "catalog.h"
#include "catmacros.h"

class CSLTEvent:
	public IInterceptorPlugin
{
public:
	CSLTEvent() 
		: m_wszTable(NULL), m_pISTEventMgr(NULL), m_cRef(0)
	{}
	~CSLTEvent() 
	{
		if (m_wszTable)
		{
			delete [] m_wszTable;
		}

		if (m_pISTEventMgr)
		{
			m_pISTEventMgr->Release();
		}
	}
	// IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release) 		();

	// ISimpleTableInterceptor:
	STDMETHOD(Intercept)				(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat, DWORD i_fTable, IAdvancedTableDispenser* i_pISTDisp, LPCWSTR i_wszLocator, LPVOID i_pSimpleTable, LPVOID* o_ppv);
	// IInterceptorPlugin:
	STDMETHOD(OnPopulateCache)		    (ISimpleTableWrite2* i_pISTShell);
	STDMETHOD(OnUpdateStore)		    (ISimpleTableWrite2* i_pISTShell);
private:
	LPWSTR	m_wszTable;
	ISimpleTableEventMgr* m_pISTEventMgr;
	ULONG   m_cRef;
};

#endif	// __SLTEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\eventmgr\undefs.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#ifdef MD_ERROR_READING_SCHEMA_BIN
#undef MD_ERROR_READING_SCHEMA_BIN
#endif

#ifdef MD_ERROR_NO_MATCHING_HISTORY_FILE
#undef MD_ERROR_NO_MATCHING_HISTORY_FILE
#endif

#ifdef MD_ERROR_PROCESSING_TEXT_EDITS
#undef MD_ERROR_PROCESSING_TEXT_EDITS
#endif

#ifdef MD_ERROR_COMPUTING_TEXT_EDITS
#undef MD_ERROR_COMPUTING_TEXT_EDITS
#endif

#ifdef MD_ERROR_READING_TEXT_EDITS
#undef MD_ERROR_READING_TEXT_EDITS
#endif

#ifdef MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE
#undef MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE
#endif

#ifdef MD_ERROR_APPLYING_TEXT_EDITS_TO_HISTORY
#undef MD_ERROR_APPLYING_TEXT_EDITS_TO_HISTORY
#endif

#ifdef MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS
#undef MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS
#endif

#ifdef MD_ERROR_SHARING_VIOLATION
#undef MD_ERROR_SHARING_VIOLATION
#endif

#ifdef MD_ERROR_SAVING_APPLIED_TEXT_EDITS
#undef MD_ERROR_SAVING_APPLIED_TEXT_EDITS
#endif

#ifdef MD_ERROR_COPY_ERROR_FILE
#undef MD_ERROR_COPY_ERROR_FILE
#endif

#ifdef MD_ERROR_UNABLE_TOSAVE_METABASE
#undef MD_ERROR_UNABLE_TOSAVE_METABASE
#endif

#ifdef MD_ERROR_READ_XML_FILE
#undef MD_ERROR_READ_XML_FILE
#endif

#ifdef MD_ERROR_DAFAULTING_MAX_HISTORY_FILES
#undef MD_ERROR_DAFAULTING_MAX_HISTORY_FILES
#endif

#ifdef MD_ERROR_COPYING_EDITED_FILE
#undef MD_ERROR_COPYING_EDITED_FILE
#endif

#ifdef MD_WARNING_RESETTING_READ_ONLY_ATTRIB
#undef MD_WARNING_RESETTING_READ_ONLY_ATTRIB
#endif

#ifdef MD_WARNING_HIGHEST_POSSIBLE_MINOR_FOUND
#undef MD_WARNING_HIGHEST_POSSIBLE_MINOR_FOUND
#endif

#ifdef MD_WARNING_IGNORING_DISCONTINUOUS_NODE
#undef MD_WARNING_IGNORING_DISCONTINUOUS_NODE
#endif

#ifdef MD_ERROR_METABASE_PATH_NOT_FOUND
#undef MD_ERROR_METABASE_PATH_NOT_FOUND
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\eventmgr\stevent.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// =======================================================================
// =======================================================================
#include "stevent.h"
#include "catmacros.h"
#include "catmeta.h"
#include "..\dispenser\cstdisp.h"
#include "..\..\stores\regdb\regdbapi\snmap.h"
#include "undefs.h"
#include "svcmsg.h"
#include <process.h>

#define SNID_LATEST 0

HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv); // TODO: BUGBUG: Remove this private function: use the table dispenser instead!

extern CSNMap g_snapshotMap;

// =======================================================================
//		ISimpleTableAdvise implementations.
// =======================================================================
HRESULT CSTEventManager::InternalSimpleTableAdvise(
	ISimpleTableEvent *i_pISTEvent,
	DWORD		i_snid,
	MultiSubscribe *i_ams,
	ULONG		i_cms,
	DWORD		*o_pdwCookie)
{
	EventConsumerInfo *pInfo = NULL;
	HRESULT		hr = S_OK;

	// Make sure no two threads access the consumer list simultaneously.
	CLock	cLock(m_seConsumerLock);

	// Verify params.
	ASSERT(o_pdwCookie);
	ASSERT(i_pISTEvent);
	ASSERT(i_ams);
	ASSERT(i_cms > 0);

	if (o_pdwCookie == NULL)
	{ 
		return E_INVALIDARG; 
	}

	// Init out param.
	*o_pdwCookie = 0;

	if ((i_pISTEvent == NULL) || (i_ams == NULL) || (i_cms == 0)) 
	{ 
		return E_INVALIDARG; 
	}

	// Validate the MultiSubscribe array.
	hr = ValidateMultiSubscribe(i_ams, i_cms);
	if (FAILED(hr)) return hr;

	pInfo = new EventConsumerInfo;
	if (pInfo == NULL) { return E_OUTOFMEMORY; }

	hr = InitConsumerInfo(pInfo, i_pISTEvent, i_snid, i_ams, i_cms);
	if (FAILED(hr)) { goto Cleanup; }

	// Add consumer to consumer list.
	hr = AddConsumer(pInfo, o_pdwCookie);
	if (FAILED(hr)) { goto Cleanup; }
	
#ifdef _DEBUG
		dbg_cConsumer++;
#endif

	// If this is the first consumer start the event firer thread.
	if (m_arrayConsumer.size() == 1)
	{
		// Start a thread to fire events.
		hr = StartEventFirer();
		if (FAILED(hr)) { goto Cleanup; }
	}

	// If the consumer is interested in any older events, give him what he wants.
	if (i_snid != SNID_LATEST)
	{
		hr = AddEvents();
		if (FAILED(hr)) { goto Cleanup; }
	}

#ifdef _DEBUG
		dbgValidateConsumerList();
#endif
Cleanup:
	if (FAILED(hr))
	{
		if (FAILED(InternalSimpleTableUnadvise(*o_pdwCookie)))
		{
			// Manual cleanup required. The consumer wasn't added to the list.
			UninitConsumerInfo(pInfo);
			delete pInfo;
		}
	}

	return hr;
}

// =======================================================================
// Make sure the data provided in the MultiSubscribe array is meaningfull.
// No NULL database or table names.
// @TODO: Future query validations can go in here as well.
// =======================================================================
HRESULT CSTEventManager::ValidateMultiSubscribe(
	MultiSubscribe *i_ams, 
	ULONG		i_cms)
{
	ULONG		i;

	for (i = 0; i < i_cms; i++)
	{
		if (i_ams[i].wszDatabase == NULL || i_ams[i].wszTable == NULL)
		{
			return E_INVALIDARG;
		}

		if (i_ams[i].pQueryData != NULL || i_ams[i].pQueryMeta != NULL)
		{
			return E_NOTIMPL;
		}

	}

	return S_OK;
}

// =======================================================================
HRESULT CSTEventManager::StartEventFirer()
{
	HRESULT		hr = S_OK;

	// Create a new event firer object.
	ASSERT(m_pEventFirer == NULL);
	m_pEventFirer = new CEventFirer;
	if (m_pEventFirer == NULL)	{	return E_OUTOFMEMORY;	}

	// Initialize it.
	hr = m_pEventFirer->Init();
	if (FAILED(hr)) goto Cleanup;

Cleanup:
	if (FAILED(hr) && (m_pEventFirer != NULL))
	{
		delete m_pEventFirer;
		m_pEventFirer = NULL;
	}

	return hr;
}


// =======================================================================
HRESULT CSTEventManager::InternalSimpleTableUnadvise(
	DWORD		i_dwCookie)
{
	EventConsumerInfo* pTempInfo = NULL;
	DWORD		iConsumer;
	ULONG		cConsumer = 0;			// Consumer count.

	// Make sure no two threads access the consumer list simultaneously.
	CLock	cLock(m_seConsumerLock);

	// Search for the consumer.
	for (iConsumer = 0; iConsumer < m_arrayConsumer.size(); iConsumer++)
	{
		if (m_arrayConsumer[iConsumer].dwCookie == i_dwCookie)
			break;
	}

	// If not found, the cookie was not valid.
	if (iConsumer == m_arrayConsumer.size())
		return E_ST_INVALIDCOOKIE;

	pTempInfo = m_arrayConsumer[iConsumer].pInfo;
	m_arrayConsumer.deleteAt(iConsumer);

	cConsumer = m_arrayConsumer.size();

#ifdef _DEBUG
		dbg_cConsumer--;
		dbgValidateConsumerList();
#endif

	// Do all the consumer array related operation before the lock is released.
	// Do not move this lock any further down, because the MetabaseListener::Uninit
	// takes another lock. Taking two locks would create an opportunity for a deadlock.
	cLock.Unlock();

	// If this is the last consumer that unadvised, get rid of the metabase listener.
	if (cConsumer == 0)
	{
        if (NULL != m_pEventFirer)
        {
		    m_pEventFirer->Done();
		    m_pEventFirer = NULL;
        }
	}

	UninitConsumerInfo(pTempInfo);
	delete pTempInfo;
	return S_OK;
}

// =======================================================================
HRESULT CSTEventManager::InternalFireEvents(ULONG i_snid)
{
	HRESULT		hr = S_OK;
	
	hr = m_DeltaCache.CommitLatestSnapshotDelta(i_snid);
	if (FAILED(hr)) {	return hr;	}
	hr = AddEvents();
	return hr; 
}

// =======================================================================
// Add events from the delta cache to the event firer's event queue, so 
// that clients receive appropriate events.
// =======================================================================
HRESULT CSTEventManager::AddEvents()
{
	Array<UpdateStoreDelta>	*paSnapshotDelta = NULL;
	ULONG		cUpdateStoreDelta = 0;
	EventConsumerInfo *pConsumer = NULL;
	ISimpleTableWrite2 **pISTWrites = NULL;
	LPWSTR		wszTableName = NULL; 
	char*		pWriteCache = NULL;
	ULONG		cbWriteCache;
	ULONG		cbWriteVarData;
	ULONG		iConsumer;
	ULONG		iTable;
	ULONG		iDelta;
	ULONG		iUSDelta;
	WCHAR		*wszCCLBFileName = NULL;
	HRESULT		hr = S_OK;
	
	// Make sure no two threads access the consumer list simultaneously.
	CLock	cLock(m_seConsumerLock);

	// Nothing to put into the event queue, if there are no consumers.
	if (m_pEventFirer == NULL)
	{
		return S_OK;
	}

#ifdef _DEBUG
	m_DeltaCache.dbgValidate();
#endif

	Array<DeltaCacheEntry> *paDeltaCache = m_DeltaCache.GetDeltaCache();

	for (iDelta = 0; iDelta < paDeltaCache->size(); iDelta++)
	{
		for (iConsumer = 0; iConsumer < m_arrayConsumer.size(); iConsumer++)
		{
			pConsumer = m_arrayConsumer[iConsumer].pInfo;
			// Add events, only if the consumer is interested in this snapshot.
			if (pConsumer->snid > (*paDeltaCache)[iDelta].snid)
			{
				continue;
			}

			// Prepare the ISTWrite array to be added to the EventFirer's event queue.
			pISTWrites = new ISimpleTableWrite2*[pConsumer->cms];
			if (pISTWrites == NULL) {	return E_OUTOFMEMORY;	}
			ZeroMemory(pISTWrites, sizeof(ISimpleTableWrite2*) * pConsumer->cms);

			paSnapshotDelta = (*paDeltaCache)[iDelta].paSnapshotDelta;
			cUpdateStoreDelta = paSnapshotDelta->size();
			for (iTable = 0; iTable < pConsumer->cms; iTable++)
			{
				for (iUSDelta = 0; iUSDelta < cUpdateStoreDelta; iUSDelta++)
				{
					if (!wcscmp(pConsumer->ams[iTable].wszTable, (*paSnapshotDelta)[iUSDelta].wszTableName))
					{
						if (NULL == pISTWrites[iTable])
						{
							hr = CreateWriteTable(pConsumer->ams[iTable].wszDatabase, (*paSnapshotDelta)[iUSDelta].wszTableName, 
								(*paSnapshotDelta)[iUSDelta].pWriteCache, (*paSnapshotDelta)[iUSDelta].cbWriteCache, 
								(*paSnapshotDelta)[iUSDelta].cbWriteVarData, &pISTWrites[iTable]);
						}
						else
						{
							hr = AppendToWriteTable((*paSnapshotDelta)[iUSDelta].pWriteCache, (*paSnapshotDelta)[iUSDelta].cbWriteCache, 
								(*paSnapshotDelta)[iUSDelta].cbWriteVarData, pISTWrites[iTable]);
						}

						if (FAILED(hr)) {	goto Cleanup;	}
					}
				}
			}

			ASSERT(m_pEventFirer != NULL);
			hr = m_pEventFirer->AddEvent(pConsumer->pISTEvent, pISTWrites, pConsumer->cms, m_arrayConsumer[iConsumer].dwCookie);
			if (FAILED(hr)) {	goto Cleanup;	}

			// Increment this consumer's snapshot id.
			pConsumer->snid = GetNextSnid((*paDeltaCache)[iDelta].snid);
		}
	}

	// Get the smallest snapshot id that is being referenced. Delete the delta cache entries for
	// snapshots that are not referenced any more.
	hr = CSimpleTableDispenser::GetFilePath(&wszCCLBFileName);
	if (FAILED(hr)) {	goto Cleanup;	}
	m_DeltaCache.DeleteOldSnapshots(g_snapshotMap.FindSmallestSnapshot(wszCCLBFileName));		

	ASSERT(m_pEventFirer != NULL);
	hr = m_pEventFirer->FireEvents();

#ifdef _DEBUG
		dbgValidateConsumerList();
#endif
Cleanup:

	if (FAILED(hr))
	{
		if (pISTWrites)
		{
			delete [] pISTWrites;
			pISTWrites = NULL;
		}
	}

	if (wszCCLBFileName)
	{
		delete [] wszCCLBFileName;
	}

	return hr;
}

// =======================================================================
HRESULT CSTEventManager::InternalCancelEvents()
{
	// Delete the deltas for the snapshot whose commit failed.
	m_DeltaCache.AbortLatestSnapshotDelta();
	return S_OK;
}

// =======================================================================
// Initialize the metabase listener. 
// =======================================================================
HRESULT CSTEventManager::InitMetabaseListener()
{
    HRESULT     hr = S_OK;

	// Create a metabase listener.
	ASSERT(m_pMBListener == NULL);

	m_pMBListener = new CMetabaseListener;
	if (m_pMBListener == NULL)	
    {	
        hr = E_OUTOFMEMORY;	
        goto Cleanup; 
    }

	m_pMBListener->AddRef();
	hr = m_pMBListener->Init();
	if (FAILED(hr)) 
    { 
        goto Cleanup; 
    }

Cleanup:

    return hr;
}

// =======================================================================
// Uninit the metabase listener. 
// =======================================================================
HRESULT CSTEventManager::UninitMetabaseListener()
{
	HRESULT hr = S_OK;

	if (m_pMBListener != NULL)
	{
		hr = m_pMBListener->Uninit();
		m_pMBListener->Release();
		m_pMBListener = NULL;
	}

    return hr;
}

// =======================================================================
HRESULT CSTEventManager::InternalRehookNotifications()
{
    // If there is no MetabaseListener, that means the inital cookdown didn't
    // succeed. In that case WAS is not in a state where it can process changes.
    if (NULL == m_pMBListener)
    {
        ASSERT(0 && L"WAS shouldn't call rehook if the inital cookdown didn't succeed!");
        return S_OK;
    }

	// Delete the deltas for the snapshot whose commit failed.
	return m_pMBListener->RehookNotifications();
}



// =======================================================================
// Utility functions.
// =======================================================================

// =======================================================================
HRESULT CSTEventManager::InitConsumerInfo(
	EventConsumerInfo *i_pInfo,
	ISimpleTableEvent *i_pISTEvent,
	DWORD		i_snid,
	MultiSubscribe *i_ams,
	ULONG		i_cms)
{
	ULONG		iTable;
	ULONG		iCell;
	HRESULT		hr = S_OK;

	ASSERT(i_pInfo);
	ASSERT(i_pISTEvent);
	ASSERT(i_ams);
	ASSERT(i_cms > 0);

	ZeroMemory(i_pInfo, sizeof(EventConsumerInfo));

	hr = i_pISTEvent->QueryInterface(IID_ISimpleTableEvent, (LPVOID*)&(i_pInfo->pISTEvent));
	if(FAILED(hr)) {	return hr;	}
	if (i_snid == SNID_LATEST)
	{
		i_snid = m_DeltaCache.GetLatestSnid()+1;
	}
	i_pInfo->snid =  i_snid; 
	i_pInfo->cms = i_cms;

	i_pInfo->ams = new MultiSubscribe[i_cms];
	if (i_pInfo->ams == NULL) { return E_OUTOFMEMORY; }
	ZeroMemory(i_pInfo->ams, sizeof(MultiSubscribe) * i_cms);

	for (iTable = 0; iTable < i_cms; iTable++)
	{
		i_pInfo->ams[iTable].wszDatabase = new WCHAR[wcslen(i_ams[iTable].wszDatabase)+1];
		if (i_pInfo->ams[iTable].wszDatabase == NULL) { return E_OUTOFMEMORY; }
		wcscpy(i_pInfo->ams[iTable].wszDatabase, i_ams[iTable].wszDatabase);

		i_pInfo->ams[iTable].wszTable = new WCHAR[wcslen(i_ams[iTable].wszTable)+1];
		if (i_pInfo->ams[iTable].wszTable == NULL) { return E_OUTOFMEMORY; }
		wcscpy(i_pInfo->ams[iTable].wszTable, i_ams[iTable].wszTable);

		if (i_pInfo->ams[iTable].pQueryData)
		{
			i_pInfo->ams[iTable].pQueryData = new STQueryCell[*(ULONG*)i_ams[iTable].pQueryMeta];
			if (i_pInfo->ams[iTable].pQueryData == NULL) { return E_OUTOFMEMORY; }
			ZeroMemory(i_pInfo->ams[iTable].pQueryData, sizeof(STQueryCell) * (*(ULONG*)i_ams[iTable].pQueryMeta));

			for (iCell = 0; iCell < (*(ULONG*)i_ams[iTable].pQueryMeta); iCell++)
			{
				i_pInfo->ams[iTable].pQueryData[iCell].pData = new BYTE[i_ams[iTable].pQueryData[iCell].cbSize];
				if (i_pInfo->ams[iTable].pQueryData[iCell].pData == NULL) { return E_OUTOFMEMORY; }
				memcpy(i_pInfo->ams[iTable].pQueryData[iCell].pData, i_ams[iTable].pQueryData[iCell].pData, i_ams[iTable].pQueryData[iCell].cbSize);

				i_pInfo->ams[iTable].pQueryData[iCell].eOperator = i_ams[iTable].pQueryData[iCell].eOperator;
				i_pInfo->ams[iTable].pQueryData[iCell].iCell = i_ams[iTable].pQueryData[iCell].iCell;
				i_pInfo->ams[iTable].pQueryData[iCell].dbType = i_ams[iTable].pQueryData[iCell].dbType;
				i_pInfo->ams[iTable].pQueryData[iCell].cbSize = i_ams[iTable].pQueryData[iCell].cbSize;
			}
		}
		i_pInfo->ams[iTable].pQueryMeta = i_ams[iTable].pQueryMeta;
		i_pInfo->ams[iTable].eQueryFormat = i_ams[iTable].eQueryFormat;
	}
	return S_OK;
}

// =======================================================================
HRESULT CSTEventManager::UninitConsumerInfo(
	EventConsumerInfo *i_pInfo)
{
	ULONG		iTable;
	ULONG		iCell;

	ASSERT(i_pInfo);

	if (i_pInfo->pISTEvent)
	{
		i_pInfo->pISTEvent->Release();
		i_pInfo->pISTEvent = NULL;
	}

	if (i_pInfo->ams)
	{
		for (iTable = 0; iTable < i_pInfo->cms; iTable++)
		{
			if (i_pInfo->ams[iTable].wszDatabase)
			{
				delete [] i_pInfo->ams[iTable].wszDatabase;
			}
			if (i_pInfo->ams[iTable].wszTable)
			{
				delete [] i_pInfo->ams[iTable].wszTable;
			}
			if (i_pInfo->ams[iTable].pQueryData)
			{
				for (iCell = 0; iCell < (*(ULONG*)i_pInfo->ams[iTable].pQueryMeta); iCell++)
				{
					if (i_pInfo->ams[iTable].pQueryData[iCell].pData)
					{
						delete [] i_pInfo->ams[iTable].pQueryData[iCell].pData;
					}
				}
				delete [] i_pInfo->ams[iTable].pQueryData;
			}
		}
		delete [] i_pInfo->ams;
		i_pInfo->ams = NULL;
	}
	
	return S_OK;
}

// =======================================================================
HRESULT CSTEventManager::AddConsumer(
	EventConsumerInfo *i_pInfo, 
	DWORD		*o_pdwCookie)
{
	EventConsumer *pConsumer = NULL;

	ASSERT(i_pInfo && o_pdwCookie);

	// Add a new consumer.
	try
	{
		m_arrayConsumer.setSize(m_arrayConsumer.size()+1);
	}
	catch(HRESULT e)
	{
		ASSERT(E_OUTOFMEMORY == e);
		return e;//Array should only throw E_OUTOFMEMORY;
	}

	pConsumer = &m_arrayConsumer[m_arrayConsumer.size()-1];
	pConsumer->pInfo = i_pInfo;
	pConsumer->dwCookie = GetNextCookie();
	*o_pdwCookie = pConsumer->dwCookie;
	return S_OK;
}

// =======================================================================
// Given a write cache, generate a memory table that contains this write 
// cache. The Database and Table names are used to get the schema of this 
// table.
// =======================================================================
HRESULT CSTEventManager::CreateWriteTable(
	LPWSTR		i_wszDatabase, 
	LPWSTR		i_wszTable, 
	char*		i_pWriteCache,			//
	ULONG		i_cbWriteCache,			// These three define the write cache.
	ULONG		i_cbWriteVarData,		//
	ISimpleTableWrite2 **o_ppISTWrites)
{
	ISimpleTableWrite2 *pISTWrite = NULL;
	ISimpleTableMarshall *pISTMarshall = NULL;
	char*		pWriteCacheCopy = NULL;		
	HRESULT		hr = S_OK;
	
	// Create an empty memory table that has the correct schema.
	hr = m_pISTDisp->GetMemoryTable(i_wszDatabase, i_wszTable, 0, NULL, NULL, eST_QUERYFORMAT_CELLS, fST_LOS_READWRITE|fST_LOS_MARSHALLABLE, &pISTWrite);
	if (FAILED(hr)) {	goto Cleanup;	}

	// Make a copy of the write cache for the memory table to consume.
	pWriteCacheCopy = new char[i_cbWriteCache];
	if (pWriteCacheCopy == NULL) {	hr = E_OUTOFMEMORY; goto Cleanup;	}
	memcpy(pWriteCacheCopy, i_pWriteCache, i_cbWriteCache);

	hr = pISTWrite->QueryInterface(IID_ISimpleTableMarshall, (LPVOID*)&pISTMarshall);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	hr = pISTMarshall->ConsumeMarshallable(fST_MCACHE_WRITE_COPY, pWriteCacheCopy, i_cbWriteCache, NULL, i_cbWriteVarData, NULL, NULL, NULL, NULL, NULL, NULL);
	if (FAILED(hr)) {	goto Cleanup;	}
	pISTMarshall->Release();
	pISTMarshall = NULL;

	// Set the out param.
	*o_ppISTWrites = pISTWrite;

Cleanup:
	if (FAILED(hr))
	{
		if (pISTWrite)
		{
			pISTWrite->Release();
		}
		if (pISTMarshall)
		{
			pISTMarshall->Release();
		}
		if (pWriteCacheCopy)
		{
			delete [] pWriteCacheCopy;
		}
	}
	return hr;
}

// =======================================================================
// Appends the given write cache (i_pWriteCache), to the given memory
// table (i_pISTWrites). 
// =======================================================================
HRESULT CSTEventManager::AppendToWriteTable(
	char*		i_pWriteCache,
	ULONG		i_cbWriteCache,
	ULONG		i_cbWriteVarData,
	ISimpleTableWrite2 *i_pISTWrites)
{
	ISimpleTableMarshall *pISTMarshall = NULL;
	HRESULT		hr = S_OK;
	
	hr = i_pISTWrites->QueryInterface(IID_ISimpleTableMarshall, (LPVOID*)&pISTMarshall);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	hr = pISTMarshall->ConsumeMarshallable(fST_MCACHE_WRITE_COPY | fST_MCACHE_WRITE_MERGE, i_pWriteCache, i_cbWriteCache, NULL, i_cbWriteVarData, NULL, NULL, NULL, NULL, NULL, NULL);
	if (FAILED(hr)) {	goto Cleanup;	}
	pISTMarshall->Release();
	pISTMarshall = NULL;

Cleanup:
	if (FAILED(hr))
	{
		if (pISTMarshall)
		{
			pISTMarshall->Release();
		}
	}
	return hr;
}


// =======================================================================
//		ISimpleTableEventMgr implementations.
// =======================================================================

// =======================================================================
// Hook up the notification interceptor either if there is a consumer is
// expecting notification from the table or the schema specifies that deltas
// should be stored for the table.
// =======================================================================
HRESULT CSTEventManager::InternalIsTableConsumed(
	LPCWSTR		i_wszDatabase, 
	LPCWSTR		i_wszTable)
{
    ISimpleTableRead2* pISTRTableMeta = NULL;
	STQueryCell	qcMeta = { (LPVOID)i_wszTable, eST_OP_EQUAL, iTABLEMETA_InternalName, DBTYPE_WSTR, sizeof(WCHAR) * (ULONG)(wcslen(i_wszTable)+1)};
    ULONG		cCells = sizeof(qcMeta) / sizeof(STQueryCell);
    ULONG		iColumn = iTABLEMETA_MetaFlags;
    DWORD*		pdwTableMetaFlags;
	HRESULT		hr = S_OK;

	// Make sure no two threads access the consumer list simultaneously.
	CLock	cLock(m_seConsumerLock);

	// Check if the schema requires persisting deltas.
    hr = m_pISTDisp->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA, reinterpret_cast<LPVOID>(&qcMeta), reinterpret_cast<LPVOID>(&cCells), eST_QUERYFORMAT_CELLS, 
                  0, reinterpret_cast<LPVOID *>(&pISTRTableMeta));
    if (FAILED (hr)) return hr;

    hr = pISTRTableMeta->GetColumnValues(0, 1, &iColumn, 0, reinterpret_cast<LPVOID *>(&pdwTableMetaFlags));
	pISTRTableMeta->Release(); 
    if (FAILED (hr)) {	return hr;	}
	
	if(pdwTableMetaFlags && (*pdwTableMetaFlags & fTABLEMETA_STOREDELTAS))
	{
		return S_OK;
	}

	// Check if there are any consumers listening on this table.
	for (ULONG iConsumer = 0; iConsumer < m_arrayConsumer.size(); iConsumer++)
	{
		for (ULONG iTable = 0; iTable < m_arrayConsumer[iConsumer].pInfo->cms; iTable++)
		{
			if (!wcscmp(m_arrayConsumer[iConsumer].pInfo->ams[iTable].wszTable, i_wszTable))
			{
				ASSERT(!wcscmp(m_arrayConsumer[iConsumer].pInfo->ams[iTable].wszDatabase, i_wszDatabase));
				return S_OK;
			}
		}
	}
	return S_FALSE;
}

#ifdef _DEBUG

// =======================================================================
void CSTEventManager::dbgValidateConsumerList()
{
	ASSERT(dbg_cConsumer == m_arrayConsumer.size());
	for (ULONG i = 0; i < m_arrayConsumer.size(); i++)
	{
		ASSERT(_CrtIsValidPointer(m_arrayConsumer[i].pInfo, sizeof(EventConsumer), TRUE));
		ASSERT(_CrtIsValidPointer(m_arrayConsumer[i].pInfo->pISTEvent, sizeof(ISimpleTableEvent), FALSE));
		ASSERT(m_arrayConsumer[i].pInfo->cms > 0);
		ASSERT(_CrtIsValidPointer(m_arrayConsumer[i].pInfo->ams, sizeof(MultiSubscribe) * m_arrayConsumer[i].pInfo->cms, TRUE));
		for (ULONG j = 0; j < m_arrayConsumer[i].pInfo->cms; j++)
		{
			ASSERT(_CrtIsValidPointer(m_arrayConsumer[i].pInfo->ams[j].wszDatabase, sizeof(WCHAR), TRUE));
			ASSERT(_CrtIsValidPointer(m_arrayConsumer[i].pInfo->ams[j].wszTable, sizeof(WCHAR), TRUE));
		}
	}
}
#endif

// =======================================================================
UINT CEventFirer::EventFirerThreadStart(LPVOID i_lpParam)
{
	CEventFirer	*pEventFirer = (CEventFirer*)i_lpParam;
	HRESULT		hr = S_OK;

	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		TRACE(L"[CEventFirer::EventFirerThreadStart] Call to CoInitializeEx failed with hr = %08x\n", hr);
		goto Cleanup;
	}

	ASSERT(pEventFirer != NULL);
	hr = pEventFirer->Main();
	if (FAILED(hr))
	{
		TRACE(L"[CEventFirer::EventFirerThreadStart] Call to CEventFirer::Main failed with hr = %08x\n", hr);
	}

Cleanup:

	delete pEventFirer;
	
	if (FAILED(hr))
	{
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_EVENT_FIRING_THREAD_DIED_UNEXPECTEDLY));
	}

	CoUninitialize();
	return hr;
}

// =======================================================================
HRESULT CEventFirer::Init()
{
	ULONG		i;
	UINT		dwThreadID;

	// Create the event kernel objects.
	for (i = 0; i < g_cHandles; i++)
	{
		m_aHandles[i] = CreateEvent(NULL,	// Use default security settings.
									FALSE,	// Auto-reset.
									FALSE,	// Initially nonsignaled.
									NULL);  // With no name.
		if (m_aHandles[i] == NULL) 
		{ 
			return HRESULT_FROM_WIN32(GetLastError()); 
		}
	}

	// Start a thread for this consumer.
	m_hThread = (HANDLE) _beginthreadex(NULL, 0, EventFirerThreadStart, (LPVOID)this, 0, &dwThreadID);
	if (m_hThread == NULL)
	{
		return HRESULT_FROM_WIN32(GetLastError()); 
	}

	return S_OK;
}

// =======================================================================
HRESULT CEventFirer::AddEvent(
	ISimpleTableEvent*		i_pISTEvent,
	ISimpleTableWrite2**	i_ppISTWrite,
	ULONG					i_cms,
	DWORD					i_dwCookie)
{
	EventItem *pEvent = NULL;

	ASSERT(i_pISTEvent && i_ppISTWrite);

	// Lock the event queue.
	CLock	cLock(m_seEventQueueLock);

	// Add a new event to the event queue.
	try
	{
		m_aEventQueue.setSize(m_aEventQueue.size()+1);
	}
	catch(HRESULT e)
	{
		ASSERT(E_OUTOFMEMORY == e);
		return e;//Array should only throw E_OUTOFMEMORY;
	}

	pEvent = &m_aEventQueue[m_aEventQueue.size()-1];
	pEvent->pISTEvent = i_pISTEvent;
	pEvent->ppISTWrite = i_ppISTWrite;
	pEvent->cms = i_cms;
	pEvent->dwCookie = i_dwCookie;
	return S_OK;
}

// =======================================================================
HRESULT CEventFirer::Main()
{
	DWORD		dwWait;
	BOOL		fDone = FALSE;
	BOOL		bEventQueueEmpty = FALSE;
	EventItem	event;
	ULONG		i;
	HRESULT		hr = S_OK;

	// initialize event to prevent uninitialized variable
	memset (&event, 0x00, sizeof (EventItem));

	while (!fDone)
	{
		// Sleep until a commit/advise happens or all consumers are done.
		dwWait = WaitForMultipleObjects(g_cHandles, m_aHandles, FALSE, INFINITE);

		// If all consumers are done, leave.
		if (dwWait == WAIT_OBJECT_0 + g_iHandleDone)
		{
			fDone = TRUE;
		}
		// A commit or advise happened. This requires an event to be fired.
		else if (dwWait == WAIT_OBJECT_0 + g_iHandleFire)
		{
			bEventQueueEmpty = FALSE;
			while (bEventQueueEmpty != TRUE)
			{
				{
					// Lock the event queue.
					CLock	cLock(m_seEventQueueLock);

					if (m_aEventQueue.size() == 0)
					{
						bEventQueueEmpty = TRUE;
					}
					else
					{
						event = m_aEventQueue[0];
						m_aEventQueue.deleteAt(0);
					}
				}
				// Event queue is unlocked.
				if (bEventQueueEmpty != TRUE)
				{
					// Fire the events for this consumer.
					ASSERT(event.pISTEvent);

					// We are calling into client's code, anything can happen.
					try
					{
						hr = event.pISTEvent->OnChange(event.ppISTWrite, event.cms, event.dwCookie);
						if (FAILED(hr))
						{
							TRACE(L"[CEventFirer::Main] Client's OnChange method failed with hr = 0x%x.\n", hr);
						}
						hr = S_OK;
					}
					catch (...)
					{
						LOG_ERROR(Win32, (EVENT_E_INTERNALEXCEPTION, ID_CAT_CAT, IDS_COMCAT_NOTIFICATION_CLIENT_THREW_EXCEPTION));
					}

					// Release the write tables.
					for (i = 0; i < event.cms; i++)
					{
						if (event.ppISTWrite[i])
						{
							event.ppISTWrite[i]->Release();
						}
					}

					delete [] event.ppISTWrite;
				}
			}			
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			fDone = TRUE;
		}
	}

	// The consumer is done.
	return hr;
}

// =======================================================================
HRESULT CEventFirer::FireEvents()
{
	ASSERT(m_aHandles[g_iHandleFire] != NULL);
	if (SetEvent(m_aHandles[g_iHandleFire]) == FALSE)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	return S_OK;
}

// =======================================================================
HRESULT CEventFirer::Done()
{
	HANDLE hThread = m_hThread;
	m_hThread = NULL;

	ASSERT(m_aHandles[g_iHandleDone] != NULL);
	if (SetEvent(m_aHandles[g_iHandleDone]) == FALSE)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// Setting the "Done" event, will eventually delete this object. Therefore
	// we can't use the data member anymore, we use a copy instead.

	// Wait on the queue thread to be done.
	if (hThread)
	{
		WaitForSingleObject(hThread, INFINITE);
	}
	CloseHandle(hThread);


	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\eventtable\sltevent.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include "SLTEvent.h"
#include "catmacros.h"

// -----------------------------------------
// CSLTEvent: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CSLTEvent::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_IInterceptorPlugin)
	{
		*ppv = (IInterceptorPlugin*) this;
	}
	else if (riid == IID_ISimpleTableInterceptor)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (IInterceptorPlugin*) this;
	}

	if (NULL != *ppv)
	{
		((IInterceptorPlugin*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CSLTEvent::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
}

// =======================================================================
STDMETHODIMP_(ULONG) CSLTEvent::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

// ------------------------------------
// ISimpleTableInterceptor:
// ------------------------------------
STDMETHODIMP CSLTEvent::Intercept(
	LPCWSTR 	i_wszDatabase,
	LPCWSTR 	i_wszTable, 
	ULONG		i_TableID,
	LPVOID		i_QueryData,
	LPVOID		i_QueryMeta,
	DWORD		i_eQueryFormat,
	DWORD		i_fLOS,
	IAdvancedTableDispenser* i_pISTDisp,
	LPCWSTR		i_wszLocator,
	LPVOID		i_pSimpleTable,
	LPVOID*		o_ppvSimpleTable)
{
	HRESULT		hr = S_OK;

	m_wszTable = new WCHAR[wcslen(i_wszTable)+1];
	if (m_wszTable == NULL) {	return E_OUTOFMEMORY;	}
	wcscpy(m_wszTable, i_wszTable);

	hr = i_pISTDisp->QueryInterface(IID_ISimpleTableEventMgr, (LPVOID *)&m_pISTEventMgr);
	if (FAILED(hr)) { return hr; }	
	*o_ppvSimpleTable = i_pSimpleTable;
	return S_OK;

}

// ------------------------------------
// IInterceptorPlugin:
// ------------------------------------

STDMETHODIMP CSLTEvent::OnPopulateCache(
	ISimpleTableWrite2* i_pISTW2)
{
	ISimpleTableController* pISTController = NULL;
	HRESULT		hr = S_OK;

	hr = i_pISTW2->QueryInterface(IID_ISimpleTableController, (LPVOID *)&pISTController);		
	if(FAILED(hr)) return hr;
	hr = pISTController->PopulateCache();
	pISTController->Release();
	return hr;
}

STDMETHODIMP CSLTEvent::OnUpdateStore(
	ISimpleTableWrite2* i_pISTW2)
{
	ISimpleTableController* pISTController = NULL;
	ISimpleTableMarshall* pISTMarshall = NULL;
	IID			iid;
	char*		pv1;	
	char*		ptempv1 = NULL;
	ULONG		cb1;	
	char*		pv2; 
	ULONG		cb2;
	HRESULT		hr = S_OK;

	// Marshall the changes to the delta cache.
	hr = i_pISTW2->QueryInterface(IID_ISimpleTableController, (LPVOID *)&pISTController);		
	if(FAILED(hr)) return hr;

	hr = pISTController->GetMarshallingInterface(&iid, (LPVOID *)&pISTMarshall);
	if (FAILED(hr)) { goto Cleanup; }
	ASSERT(IID_ISimpleTableMarshall == iid);

	hr = pISTMarshall->SupplyMarshallable(fST_MCACHE_WRITE_COPY, &pv1, &cb1, &pv2, &cb2, NULL, NULL, NULL, NULL, NULL, NULL);
	if (FAILED(hr)) { goto Cleanup; }

	if (cb1 > 0)
	{
		ptempv1 = new char[cb1];
		if (ptempv1 == NULL) {	hr = E_OUTOFMEMORY; goto Cleanup;	}
		memcpy(ptempv1, pv1, cb1);
	}

	// Complete UpdateStore.
	hr = i_pISTW2->UpdateStore();
	if (FAILED(hr)) { goto Cleanup; }

	// If UpdateStore() succeeded add the delta to the delta cache.
	if (cb1 > 0)
	{
		hr = m_pISTEventMgr->AddUpdateStoreDelta(m_wszTable, ptempv1, cb1, cb2);
		if (FAILED(hr)) { goto Cleanup; }
	}

Cleanup:
	if (pISTMarshall)
	{
		pISTMarshall->Release();
	}

	if (pISTController)
	{
		pISTController->Release();
	}

	if (FAILED(hr) && ptempv1)
	{
		delete [] ptempv1;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\eventmgr\postprocess.cpp ===
#include "catmacros.h"
#include "sdtfst.h"

#define MAX_WAS_COLUMNS 50

HRESULT CompactIfSamePrimaryKey(
    ISimpleTableWrite2      *i_pISTWrite,
	ISimpleTableController  *i_pISTControl,
    SimpleColumnMeta        *i_pscmMeta,
    DWORD                   i_cColumns,
    DWORD                   i_iOld,
    DWORD                   i_iCurrent);


//
// This method is used to post process a change notification table. The code
// walks through all the rows and if there are any rows that have been inserted
// after being deleted, it will convert the action of the deleted row to "IGNORE"
// and the action of the inserted row to "UPDATE".
// =======================================================================
STDAPI PostProcessChangesInternal(
    ISimpleTableWrite2  *i_pISTWrite)
{
	ISimpleTableController *pISTControl = NULL;
    SimpleColumnMeta ascmMeta[MAX_WAS_COLUMNS];
	DWORD		iCurrent = 0;
    DWORD       iOld = 0;
    DWORD       cColumns = 0;
  	DWORD		eAction;
	HRESULT		hr = S_OK;

    if (NULL == i_pISTWrite)
    {
        // Nothing to postprocess.
        goto Cleanup;
    }

    hr = i_pISTWrite->QueryInterface(IID_ISimpleTableController, (LPVOID*)&pISTControl);
    ASSERT(SUCCEEDED(hr)); 

    //
    // How many columns does this table have.
    //

    hr = i_pISTWrite->GetTableMeta(NULL, NULL, NULL, &cColumns);
    ASSERT(SUCCEEDED(hr)); 

   	hr = i_pISTWrite->GetColumnMetas(cColumns, NULL, ascmMeta);
    ASSERT(SUCCEEDED(hr)); 

    while (S_OK == (hr = pISTControl->GetWriteRowAction(iCurrent, &eAction)))
    {
        if (eST_ROW_INSERT == eAction && iCurrent > 1)
        {
            // 
            // See if this row has been deleted previously. If so, convert
            // to an update.
            //
            for (iOld = iCurrent - 1; iOld >= 0; iOld--)
            {
                hr = pISTControl->GetWriteRowAction(iOld, &eAction);
                ASSERT(S_OK == hr);

                if (eST_ROW_DELETE  == eAction)
                {
                    // There is a potential for compacting the two rows.
                    hr = CompactIfSamePrimaryKey(i_pISTWrite, pISTControl, ascmMeta, cColumns, iOld, iCurrent);
                    if (FAILED(hr))
                    {
                        goto Cleanup;
                    }

                    //
                    // If we did compact the two rows, we are done with this current row.
                    //
                    if (hr == S_OK)
                    {
                        break;
                    }
                }
            }
        }

        iCurrent++;
    }

    if (hr == E_ST_NOMOREROWS)
    {
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:
    
    if (NULL != pISTControl)
    {
        pISTControl->Release();
    }
    return hr;
}

//
// See if the two rows have the same primary key:
// If they do, then
//      convert the action of the deleted row to "IGNORE"
//      convert the action of the inserted row to "UPDATE"
//      update the column status of the changed columns to "CHANGED"
// =======================================================================
HRESULT CompactIfSamePrimaryKey(
    ISimpleTableWrite2      *i_pISTWrite,
	ISimpleTableController  *i_pISTControl,
    SimpleColumnMeta        *i_pscmMeta,
    DWORD                   i_cColumns,
    DWORD                   i_iOld,
    DWORD                   i_iCurrent)
{
    LPVOID      pvDataOld[MAX_WAS_COLUMNS];
    ULONG       pcbSizeOld[MAX_WAS_COLUMNS];
    ULONG       pdwStatusOld[MAX_WAS_COLUMNS];
    LPVOID      pvDataCurrent[MAX_WAS_COLUMNS];
    ULONG       pcbSizeCurrent[MAX_WAS_COLUMNS];
    ULONG       pdwStatusCurrent[MAX_WAS_COLUMNS];
    ULONG       iColumn = 0;
    BOOL        fSameKey = TRUE;
    HRESULT     hr = S_OK;

    ASSERT(MAX_WAS_COLUMNS > i_cColumns);

    hr = i_pISTWrite->GetWriteColumnValues(i_iOld, i_cColumns, NULL, pdwStatusOld, pcbSizeOld, pvDataOld);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = i_pISTWrite->GetWriteColumnValues(i_iCurrent, i_cColumns, NULL, pdwStatusCurrent, pcbSizeCurrent, pvDataCurrent);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // See if the two rows have the same primary key.
    //
    for (iColumn = 0; iColumn < i_cColumns; iColumn++)
    {
        if ((i_pscmMeta[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY) && 
    		 CMemoryTable::InternalMatchValues( eST_OP_NOTEQUAL, 
                                                i_pscmMeta[iColumn].dbType, 
                                                i_pscmMeta[iColumn].fMeta, 
                                                pcbSizeOld[iColumn], 
                                                pcbSizeCurrent[iColumn], 
                                                pvDataOld[iColumn], 
                                                pvDataCurrent[iColumn]))
        {
            hr = S_FALSE;
            break;
        }
    }

    //
    // if the we found the same key then we should:
    // 1: figure out which properties changed.
    // 2: mark the old row as "IGNORE"
    // 3: mark the current row as update.
    //
    
    if (S_OK == hr)
    {
        for (iColumn = 0; iColumn < i_cColumns; iColumn++)
        {
            if (!(i_pscmMeta[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY) && 
    		     CMemoryTable::InternalMatchValues( eST_OP_NOTEQUAL, 
                                                    i_pscmMeta[iColumn].dbType, 
                                                    i_pscmMeta[iColumn].fMeta, 
                                                    pcbSizeOld[iColumn], 
                                                    pcbSizeCurrent[iColumn], 
                                                    pvDataOld[iColumn], 
                                                    pvDataCurrent[iColumn]))
            {
                hr = i_pISTControl->ChangeWriteColumnStatus(i_iCurrent, iColumn, fST_COLUMNSTATUS_CHANGED);
                ASSERT(hr);
            }
        }

        hr = i_pISTControl->SetWriteRowAction(i_iOld, eST_ROW_IGNORE); 
        ASSERT(hr == S_OK);

        hr = i_pISTControl->SetWriteRowAction(i_iCurrent, eST_ROW_UPDATE); 
        ASSERT(hr == S_OK);
    }

Cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\fastcache\sdtfst_com.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include <objbase.h>
#include "sdtfst.h"

// -----------------------------------------
// CSLTShapeless: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CMemoryTable::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_fIsDataTable) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableWrite2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableController)
		{
			*ppv = (ISimpleTableController*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
		else if (riid == IID_ISimpleTableMarshall && (fST_LOS_MARSHALLABLE & m_fTable))
		{
			*ppv = (ISimpleTableMarshall*) this;
		}

	}
	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CMemoryTable::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

// =======================================================================
STDMETHODIMP_(ULONG) CMemoryTable::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\fastcache\sdtfst.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.

// TODO: Implement hashing in MoveToRowByIdentity.
// TODO: Implement a faster CopyWriteRowFromReadRow.
// TODO: In SetRow fail to insert an existing row.  Probably ignorable; better perf; spec decision.
// TODO: For marshalling: need to correct endian-ness.
// TODO: SetRow and SetWriteColumn both are inner loops.  Most SetRow work can be done in SetWriteColumn to optimize.

// 64-BIT Assumptions:
// No variable data will be larger than _MAX_ULONG bytes.
// The caches cannot have more than _MAX_ULONG rows.

#include "sdtfst.h"							// My header.
#include "catmacros.h"						// Simple macros.
#include "catalog.h"							// The simple table idl header.
#include "catmeta.h"
#include <oledberr.h>						// OLEDB error codes.

#define oDOESNOTEXIST				(~0L)	// Offset does not exist.
#define cbminDATAGROWTH				1024	// Minimum count of bytes to grow the cache at a time.
#define cbmaxDATAGROWTH			67108864	// Maximum count of bytes to grow the cache at a time.
#define cmaxERRGROWTH				2500	// Maximum count of errors to grow the error cache at a time.
#define cmaxCOLUMNS					50		// Maximum number of columns that can be declared: Change CopyWriteRowFromRead if this changes.
												
										// Cache flags:
#define fCACHE_METAINITIALIZED	0x00000001	// The cache meta is initialized.
#define fCACHE_LOADING			0x00000002	// The cache is loading clean.
#define fCACHE_READY			0x00000004	// The cache is ready for external use.
#define fCACHE_INVALID			0x00000008	// The cache is invalid.
#define fCACHE_CONTINUING		0x00000010	// The cache is continuing from a prior loading.
#define fCACHE_ROWCOPYING		0x00000020	// The cache is copying a read row into a write row.
//								0x00070000	// Reserved for cache marshalling flags from catalog.idl.

										// Cursor designations and flags:
#define eCURSOR_READ				0		// Designates the read cursor.
#define eCURSOR_WRITE				1		// Designates the write cursor.
#define fCURSOR_READ_BEFOREFIRST	0x01	// The read cursor is right before the first row.
#define fCURSOR_READ_ATLAST			0x02	// The read cursor is at the last row.
#define fCURSOR_WRITE_BEFOREFIRST	0x10	// The write cursor is right before the first row.
#define fCURSOR_WRITE_ATLAST		0x20	// The write cursor is at the last row.
#define fCURSOR_ADDING				0x80	// The cursor had added a row to the write cache but has not set it.

										// Internal column status (low nibble reserved!):
#define fCOLUMNSTATUS_READINDEX		0x10	// The column value is a reference index to the read vardata.
#define fCOLUMNSTATUS_WRITEINDEX	0x20	// The column value is a reference index to the write vardata.


// =======================================================================
CMemoryTable::CMemoryTable () 
	: m_fTable (0)
	, m_cColumns (0)
	, m_cUnknownSizes (0)
	, m_cStatusParts (0)
	, m_cValueParts (0)
	, m_acolmetas (NULL)
	, m_acoloffsets (NULL)
	, m_acolDefaults (NULL)
	, m_alDefSizes (NULL)
	, m_cbMinCache (cbminDATAGROWTH)

	, m_fCache (0)
	, m_cRefs (1)

	, m_cReadRows (0)
	, m_cbReadVarData (0)
	, m_pvReadVarData (NULL)

	, m_pvReadCache (NULL)
	, m_cbReadCache (0)
	, m_cbmaxReadCache (0)

	, m_cWriteRows (0)
	, m_cbWriteVarData (0)
	, m_pvWriteVarData (NULL)

	, m_pvWriteCache (NULL)
	, m_cbWriteCache (0)
	, m_cbmaxWriteCache (0)

	, m_cErrs (0)
	, m_cmaxErrs (0)
	, m_pvErrs (NULL)

	, m_cRef (0)
	, m_fIsDataTable (0)
{
}

// =======================================================================
CMemoryTable::~CMemoryTable() 
{
	CleanupCaches(); 
	if (m_acolmetas != NULL)
	{
		delete[] m_acolmetas;
		m_acolmetas = NULL;
	}
	if (m_acoloffsets != NULL)
	{
		delete[] m_acoloffsets;
		m_acoloffsets = NULL;
	}
	if (m_acolDefaults != NULL)
	{
		delete[] m_acolDefaults;
		m_acolDefaults = NULL;
	}
	if (m_alDefSizes != NULL)
	{
		delete[] m_alDefSizes;
		m_alDefSizes = NULL;
	}
}

// ------------------------------------
// ISimpleTableInterceptor:
// ------------------------------------

// ==================================================================
STDMETHODIMP CMemoryTable::Intercept
(
	LPCWSTR					i_wszDatabase,
	LPCWSTR 				i_wszTable, 
	ULONG					i_TableID,
	LPVOID					i_QueryData,
	LPVOID					i_QueryMeta,
	DWORD					i_eQueryFormat,
	DWORD					i_fTable,
	IAdvancedTableDispenser* i_pISTDisp,
	LPCWSTR					i_wszLocator,
	LPVOID					i_pv,
	LPVOID*					o_ppv
)
{
    STQueryCell*		pQueryCell = (STQueryCell*) i_QueryData;
	SimpleColumnMeta	columnmeta;
	HRESULT				hr;

// ie: Assert component is posing as class factory / dispenser.
	ASSERT (!m_fIsDataTable);
	if (m_fIsDataTable)
		return E_UNEXPECTED;
	ASSERT (NULL != o_ppv);
	if (NULL == o_ppv)
		return E_INVALIDARG;
	if(i_wszLocator)
		return E_INVALIDARG;
	*o_ppv = NULL;

// Determine minimum cache size:
	if (eST_QUERYFORMAT_CELLS != i_eQueryFormat) return E_ST_QUERYNOTSUPPORTED;
	if (i_QueryMeta == NULL && i_QueryData != NULL) return E_ST_INVALIDQUERY;
	if (i_QueryMeta != NULL)
	{
		if (*((ULONG*) i_QueryMeta) == 0 && i_QueryData != NULL) return E_ST_INVALIDQUERY;
		if (*((ULONG*) i_QueryMeta) > 1) return E_ST_QUERYNOTSUPPORTED;
		if (*((ULONG*) i_QueryMeta) == 1)
		{
			if (NULL == i_QueryData) return E_ST_INVALIDQUERY;
			if (pQueryCell->iCell != iST_CELL_cbminCACHE) return E_ST_QUERYNOTSUPPORTED;
			if (pQueryCell->eOperator != eST_OP_EQUAL) return E_ST_INVALIDQUERY;
			if (pQueryCell->dbType != DBTYPE_UI4) return E_ST_INVALIDQUERY;
			if (pQueryCell->cbSize != sizeof (ULONG)) return E_ST_INVALIDQUERY;
			m_cbMinCache = *((ULONG*) pQueryCell->pData);
		}
	}

/// As a shapeless cache none of these parameters are supported:
	ASSERT (NULL == i_pv);
	if (NULL != i_pv)
		return E_INVALIDARG;

// Remember what little is necessary:
	m_fTable = i_fTable;

// Leave the cache shapeless

// Supply ISimpleTable* and transition state from class factory / dispenser to data table:
	*o_ppv = (ISimpleTableWrite2*) this;
	((ISimpleTableWrite2*) this)->AddRef ();
	InterlockedIncrement ((LONG*) &m_fIsDataTable);

	return S_OK;
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableRead2
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::GetRowIndexByIdentity	(ULONG* i_acb, LPVOID* i_apv, ULONG* o_piRow)
{
	// ie: Assert cache is ready.
	ASSERT(fCACHE_READY & m_fCache); 
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	return (MoveToEitherRowByIdentity (eCURSOR_READ, i_acb, i_apv, o_piRow));
}

HRESULT CMemoryTable::GetRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	// ie: Assert cache is ready.
	ASSERT(fCACHE_READY & m_fCache); 
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	return GetEitherRowIndexBySearch (eCURSOR_READ, i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);
}

// =======================================================================
HRESULT CMemoryTable::GetColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes , LPVOID* o_apvValues)
{
	// ie: Assert cache is ready.
	ASSERT(fCACHE_READY & m_fCache); 
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	return (GetEitherColumnValues (i_iRow, eCURSOR_READ, i_cColumns, i_aiColumns, NULL, o_acbSizes , o_apvValues));
}

// =======================================================================
HRESULT CMemoryTable::GetTableMeta(ULONG * o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns)
{
	// Todo:  In the old GetTableMeta, we didn't support pfTable or the Query stuff, for the new GetTableMeta if
	//		  we want to support pcVersion or pfTable, we need to implement it.
	ASSERT (NULL == o_pcVersion);
	if (NULL != o_pcVersion)
		return E_INVALIDARG;
	ASSERT (NULL == o_pfTable);
	if (NULL != o_pfTable)
		return E_INVALIDARG;

	 // ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// The Following line is commented out because logic tables that validate during Populate Cache
	// will not work if this check is present.
	//areturn_on_fail (!(fCACHE_LOADING & m_fCache), E_ST_INVALIDCALL); // ie: Assert cache is not loading.

	if(o_pcRows)
		*o_pcRows = m_cReadRows;
	if(o_pcColumns)
		*o_pcColumns = m_cColumns;

	// TODO: Need to support Version
	if (o_pcVersion)
		*o_pcVersion = 0;

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetColumnMetas(ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas )
{
	 // ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// Make sure caller passed in a valid buffer.
	if (NULL == o_aColumnMetas)
	{
		return E_INVALIDARG;
	}

	// ie: Note column out of range.
	if (i_cColumns > m_cColumns)
		return E_ST_NOMORECOLUMNS;

	ULONG iColumn;
	ULONG iTarget;
       
	for ( ULONG i = 0; i < i_cColumns; i ++ )
	{
		if(NULL != i_aiColumns)
			iColumn = i_aiColumns[i];
		else
			iColumn = i;

		iTarget = (i_cColumns == 1) ? 0 : iColumn;

		if ( iColumn >= m_cColumns )
			return 	E_ST_NOMORECOLUMNS;
		
		memcpy( &(o_aColumnMetas[iTarget]), &(m_acolmetas[iColumn]), sizeof( SimpleColumnMeta ) );
	
		// Mask the internal flags:
		o_aColumnMetas[iTarget].fMeta &= fCOLUMNMETA_MetaFlags_Mask;
	}
	
	return(S_OK);
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableWrite2
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::AddRowForDelete (ULONG i_iReadRow)
{
	ULONG	iWriteRow;
	HRESULT hr;
	// Make sure that there is a read row before adding the write row.
	// else UpdateStore will AV if there is a write row with invalid data.
	LPVOID	pvRow		= NULL;

	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL; 

	// Make sure that there is a read row before adding the write row.
	// else UpdateStore will AV if there is a write row with invalid data.
	hr = GetRowFromIndex(eCURSOR_READ, i_iReadRow, &pvRow);
	if (FAILED (hr)) { return hr; }

	hr = AddWriteRow(eST_ROW_DELETE, &iWriteRow);
	if (FAILED (hr)) { return hr; }
	hr = CopyWriteRowFromReadRow(i_iReadRow, iWriteRow);
	if (FAILED (hr)) { return hr; }
	return hr; 
}

// =======================================================================
HRESULT CMemoryTable::AddRowForInsert (ULONG* o_piWriteRow)
{
	DWORD	dbtype = 0;
	DWORD	fMeta = 0;
	BYTE	*pbStatus;
	ULONG	i;
	LPVOID	pvRow = NULL;
	HRESULT hr = S_OK;

	// Assert that there is a valid return pointer.
	ASSERT(o_piWriteRow);

	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	hr = AddWriteRow(eST_ROW_INSERT, o_piWriteRow);
	if (FAILED (hr)) { return hr; }

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, *o_piWriteRow, &pvRow)))
		return hr;
	ASSERT(pvRow != NULL);

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::AddRowForUpdate (ULONG i_iReadRow, ULONG* o_piWriteRow)
{
	HRESULT hr = S_OK;
	// Make sure that there is a read row before adding the write row.
	// else UpdateStore will AV if there is a write row with invalid data.
	LPVOID	pvRow		= NULL;

	// Assert that there is a valid return pointer.
	ASSERT(o_piWriteRow);

	// ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;


	if (!(fCACHE_LOADING & m_fCache)) // ie: Update from read to write cache: Add and copy into the new write row:
							
	{
		// Make sure that there is a read row before adding the write row.
		// else UpdateStore will AV if there is a write row with invalid data.
		hr = GetRowFromIndex(eCURSOR_READ, i_iReadRow, &pvRow);
		if (FAILED (hr)) { return hr; }

		hr = AddWriteRow(eST_ROW_UPDATE, o_piWriteRow);
		if (FAILED (hr)) { return hr; }
		hr = CopyWriteRowFromReadRow(i_iReadRow, *o_piWriteRow);
		if (FAILED (hr)) { return hr; }
	}

	return hr;
}

// =======================================================================
HRESULT CMemoryTable::SetWriteColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues)
{
	DWORD			fColumn;
	ULONG			cb = 0;
	ULONG			cbMaxSize;
	LPVOID*			ppvValue;
	ULONG*			pulSize;
	BYTE*			pbStatus;
	ULONG			iColumn;
	ULONG			iSource;
	ULONG			icb = 0;
	LPVOID			pv;
	LPVOID			pvWriteRow = NULL;
	HRESULT			hr = S_OK;

	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

    if (i_apvValues==NULL)	return E_INVALIDARG;

	if (i_cColumns == 0)
		return E_INVALIDARG;

	if (i_cColumns > m_cColumns)
		return E_ST_NOMORECOLUMNS;

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow)))
		return hr;

	ASSERT(pvWriteRow);
	for(ULONG ipv=0; ipv<i_cColumns; ipv++)
	{
		if(NULL != i_aiColumns)
			iColumn	= i_aiColumns[ipv]; 
		else
			iColumn	= ipv;

		iSource = (i_cColumns == 1) ? 0 : iColumn;

		ASSERT(iSource < m_cColumns);
		if (iSource >= m_cColumns)
			return E_INVALIDARG;

		if(NULL != i_acbSizes)
		{
			icb = i_acbSizes[iSource];
		}
		else
		{
			//reset number of bytes in case size is not given. This prevents
			//problems of reusing the size of the previous parameter.
			icb = 0;
		}


		pv	= i_apvValues[iSource];

	// Parameter validation: column ordinal:
		// ie: Note column out of range (do not assert).
		if (iColumn >= m_cColumns)
			return E_ST_NOMORECOLUMNS;

	// Remember the column flags:
		fColumn = m_acolmetas[iColumn].fMeta;

	// Can't update a primary key column. Unless:
	// The cache is being created, or a row is being copied from read to write cache or the row is an insert.
		if (fColumn & fCOLUMNMETA_PRIMARYKEY && fCACHE_READY & m_fCache && !(m_fCache & fCACHE_ROWCOPYING) && *(pdwDataActionPart (pvWriteRow)) != eST_ROW_INSERT)
		{
			return E_ST_PKNOTCHANGABLE;
		}

		if ((fColumn & fCOLUMNMETA_NOTNULLABLE) && (pv == 0) && !(fColumn & fCOLUMNMETA_NOTPERSISTABLE))
		{
			return E_ST_VALUENEEDED;
		}

	// Parameter validation: specified size:
		if (0 != icb) // ie: Size specified:
		{
			// TODO: Verify that the size is valid
			// areturn_on_fail (NULL != pv && ((fCOLUMNMETA_UNKNOWNSIZE & fColumn) || (DBTYPE_BYTES == m_acolmetas[iColumn].dbType && icb == m_acolmetas[iColumn].cbSize)), E_ST_VALUEINVALID); // ie: Assert column size must be passed and value is non-null.
		}
		else // ie: Size not specified:
		{
			if (!(!(fCOLUMNMETA_UNKNOWNSIZE & fColumn) || NULL == pv))
				return E_ST_SIZENEEDED;
		}

	// Parameter validation: by type:
		if (DBTYPE_WSTR == m_acolmetas[iColumn].dbType && NULL != pv) // ie: Column is a string and specified value is non-null:
		{
			cbMaxSize = m_acolmetas[iColumn].cbSize;
			if (~0 != cbMaxSize) // ie: Column has a maximum length:
			{
				if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
				{
					// multi-string
					cb = (ULONG)GetMultiStringLength (LPCWSTR(pv)) * sizeof (WCHAR);
				}
				else
				{
					// normal string
					cb = (ULONG)(wcslen (LPCWSTR (pv)) + 1) * sizeof (WCHAR);
				}
				// ie: Assert specified string is within maximum length.
				if (cb > cbMaxSize) 
					return E_ST_SIZEEXCEEDED;
			}
		}
		else
		{
			cb = m_acolmetas[iColumn].cbSize;
		}

	// Parameter validation: by flags: (Cannot check non-nullable columns here; done in LoadRow/SetRow instead).

	// Prepare to set the column:
		ppvValue	= ppvDataValuePart (pvWriteRow, iColumn);
		pulSize		= pulDataSizePart (pvWriteRow, iColumn);
		pbStatus	= pbDataStatusPart (pvWriteRow, iColumn);

	// Set the column size:
		if (fCOLUMNMETA_VARIABLESIZE & fColumn) // ie: Column value is variable size (and therefore a pointer):
		{
			if (pv != NULL)
			{
				if (fCOLUMNMETA_UNKNOWNSIZE & fColumn) // ie: Column-size only knowable by passing it:
				{
					*pulSize = icb;

				}
				else // Has to be a string, because "BYTES" with FIXEDSIZE are not VARIABLESIZE.
				{
					ASSERT (DBTYPE_WSTR == m_acolmetas[iColumn].dbType);
					if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
					{
						// multi-string
						icb = (ULONG) GetMultiStringLength (LPCWSTR(pv)) * sizeof (WCHAR);
					}
					else
					{
						// normal string
						icb = (ULONG)(wcslen (LPCWSTR (pv)) + 1) * sizeof (WCHAR);
					}
				}

			// Set the column value:
				hr = AddVarDataToWriteCache (icb, pv, (ULONG **)&ppvValue);
				if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
				
				// Recalculate the pointers if the cache has been resized.
				if (hr == S_FALSE)
				{
					GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow);
					pulSize		= pulDataSizePart (pvWriteRow, iColumn);
					pbStatus	= pbDataStatusPart (pvWriteRow, iColumn);
				}
				(*pbStatus) &= ~fCOLUMNSTATUS_READINDEX;
				(*pbStatus) |= (fCACHE_LOADING & m_fCache ? fCOLUMNSTATUS_READINDEX : fCOLUMNSTATUS_WRITEINDEX);
			}
		}
		else // ie: Column data size is fixed:
		{
			if (NULL != pv) // ie: Caller has data to copy:
			{
				memcpy (ppvValue, pv, cb);
			}
		}

	// Set the column status:
		if (NULL == pv) // ie: Value is null and not pass-by-value:
		{
			(*pbStatus) &= ~fST_COLUMNSTATUS_NONNULL;
		}
		else // ie: Value is non-null or pass-by-value:
		{
			(*pbStatus) |= fST_COLUMNSTATUS_NONNULL;
		}

	// if setwritecolumn has been called, probably something has changed
		(*pbStatus) |= fST_COLUMNSTATUS_CHANGED;
	}

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG *i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes , LPVOID* o_apvValues)
{
	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	return (GetEitherColumnValues (i_iRow, eCURSOR_WRITE, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes , o_apvValues));
}

// =======================================================================
HRESULT CMemoryTable::GetWriteRowIndexByIdentity	(ULONG* i_acb, LPVOID* i_apv, ULONG* o_piRow)
{
	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	return (MoveToEitherRowByIdentity (eCURSOR_WRITE, i_acb, i_apv, o_piRow));
}

// =======================================================================
HRESULT CMemoryTable::GetWriteRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, 
											   ULONG* i_aiColumns, ULONG* i_acbSizes, 
											   LPVOID* i_apvValues, ULONG* o_piRow)
{
 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	return GetEitherRowIndexBySearch (eCURSOR_WRITE, i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);
}

HRESULT CMemoryTable::GetErrorTable(DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
{
    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP CMemoryTable::UpdateStore()
{
    HRESULT hr = S_OK;
	
	if (!(m_fTable & fST_LOS_READWRITE)) return E_NOTIMPL;
	hr = InternalPreUpdateStore ();
    if (!SUCCEEDED(hr))
        return hr;
	DiscardPendingWrites ();
	return hr;
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableController:
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::ShapeCache (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
{
	// ie: Assert meta not already initialized.	
	ASSERT (!(fCACHE_METAINITIALIZED & m_fCache));	
	if (fCACHE_METAINITIALIZED & m_fCache)
		return E_ST_INVALIDCALL;
	// ie: Assert at least one column specified.
	ASSERT (0 < i_cColumns);											
	if (0 == i_cColumns)
		return E_INVALIDARG;

	// ie: Assert pointer validity.
	ASSERT (NULL != i_acolmetas);									
	if (NULL == i_acolmetas)
		return E_INVALIDARG;

	ASSERT(i_cColumns < cmaxCOLUMNS);

// Setup the meta (note that if meta setup fails the cache remains uninitialized):
	return SetupMeta (i_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);
}

// =======================================================================
HRESULT CMemoryTable::PrePopulateCache (DWORD i_fControl)
{
	HRESULT		hr;

	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache); 
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;
	// ie: Assert supported control flags.
	ASSERT (0 == (~fCOLUMNMETA_MetaFlags_Mask & i_fControl)); 
	if (0 != (~fCOLUMNMETA_MetaFlags_Mask & i_fControl))
		return E_INVALIDARG;

	if (!(fST_POPCONTROL_RETAINREAD & i_fControl))
	{
		// ie: Assert retain errors was not specified.
		ASSERT (!(fST_POPCONTROL_RETAINERRS & i_fControl)); 
		if (fST_POPCONTROL_RETAINERRS & i_fControl)
			return E_INVALIDARG;
	}

	if (fST_POPCONTROL_RETAINREAD & i_fControl) // ie: Retaining the existing read cache:
	{
	// Continue cache loading:
		ContinueReadCacheLoading ();

	// Cleanup error cache unless otherwise requested:
		if (!(fST_POPCONTROL_RETAINERRS & i_fControl))
		{
			CleanupErrorCache ();
		}
	}
	else // ie: Replacing the existing read cache:
	{
	// Begin cache loading:
		BeginReadCacheLoading ();
	}

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::PostPopulateCache ()
{
	HRESULT				hr;

	// ie: Assert cache is loading.
	ASSERT (fCACHE_LOADING & m_fCache); 
	if (!(fCACHE_LOADING & m_fCache))
		return E_ST_INVALIDCALL;

// Remove any deleted rows, shrink cache, and end loading:
	if (m_cWriteRows)
		RemoveDeletedRows();
	hr = ShrinkWriteCache ();
	if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
	EndReadCacheLoading ();
	
	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::DiscardPendingWrites ()
{
	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL; 

	CleanupWriteCache();
	CleanupErrorCache();
	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetWriteRowAction (ULONG i_iRow, DWORD* o_peAction)
{
	LPVOID	pvWriteRow;
	DWORD*	pdwAction;
	HRESULT	hr;

	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL; 

	ASSERT(NULL != o_peAction);
	
	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow)))
		return hr;
	ASSERT (NULL != pvWriteRow);

// Get the action part of the current write row:
	pdwAction = pdwDataActionPart (pvWriteRow);
	ASSERT (NULL != pdwAction);
	*o_peAction = *pdwAction;

	return hr;
}

// =======================================================================
HRESULT CMemoryTable::SetWriteRowAction (ULONG i_iRow, DWORD i_eAction)
{
	DWORD*	pdwAction;
	LPVOID	pvWriteRow;
	HRESULT	hr;

	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	ASSERT (eST_ROW_IGNORE == i_eAction || eST_ROW_INSERT == i_eAction || eST_ROW_UPDATE == i_eAction || eST_ROW_DELETE == i_eAction);
	if (!(eST_ROW_IGNORE == i_eAction || eST_ROW_INSERT == i_eAction || eST_ROW_UPDATE == i_eAction || eST_ROW_DELETE == i_eAction))
		return E_INVALIDARG;
	
	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow)))
		return hr;

// Set the action part of the current write row:
	pdwAction = pdwDataActionPart (pvWriteRow);
	ASSERT (NULL != pdwAction);
	*pdwAction = i_eAction;
	return hr;
}

// =======================================================================
HRESULT CMemoryTable::ChangeWriteColumnStatus (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
{
	BYTE*			pbStatus;
	BYTE			bStatusChange;
	LPVOID			pvWriteRow;
	HRESULT			hr;

	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL; 
	
// Parameter validation: column ordinal:
	// ie: Note column out of range (do not assert).
	if (i_iColumn >= m_cColumns) 
		return E_ST_NOMORECOLUMNS;

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow)))
		return hr;
	ASSERT (NULL != pvWriteRow);

	bStatusChange = (BYTE) i_fStatus;
	pbStatus = pbDataStatusPart (pvWriteRow, i_iColumn);
	switch (bStatusChange)
	{
		case 0:
			(*pbStatus) &= ~fST_COLUMNSTATUS_CHANGED;
		break;
		case fST_COLUMNSTATUS_CHANGED:
			(*pbStatus) |= fST_COLUMNSTATUS_CHANGED;
		break;

		default:
		ASSERT (0);
		return E_INVALIDARG;
	}
	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::AddDetailedError (STErr* i_pSTErr)
{
	STErr*	pSTErr;
	ULONG	cErrs;
	HRESULT	hr;

	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache); 
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// ie: Assert non-null detailed error.
	ASSERT (NULL != i_pSTErr); 
	if (NULL == i_pSTErr)
		return E_INVALIDARG;
	
// Verify indices:
	cErrs	= m_cErrs;
	pSTErr	= pSTErrPart (cErrs - 1);
	
// Add error:
	hr = AddErrorToErrorCache (i_pSTErr);
	return hr;
}

// ==================================================================
STDMETHODIMP CMemoryTable::GetMarshallingInterface (IID * o_piid, LPVOID * o_ppItf)
{
	// parameter validation
	ASSERT(NULL != o_piid);
	if (NULL == o_piid)
		return E_INVALIDARG;
	ASSERT(NULL != o_ppItf);
	if (NULL == o_ppItf)
		return E_INVALIDARG;

//	if(fST_LOS_MARSHALLABLE & m_fTable)
//	{ // ie: we are a marshallable table
		*o_piid = IID_ISimpleTableMarshall;
		*o_ppItf = (ISimpleTableMarshall *)this;
		((ISimpleTableMarshall *) *o_ppItf)->AddRef();
		return S_OK;
/*	}
	else
	{// ie: we are NOT a marshallable table
		return E_NOTIMPL;
	} */
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableAdvanced:
// -----------------------------------------

// ==================================================================
STDMETHODIMP CMemoryTable::PopulateCache ()
{
	PrePopulateCache (0);
	PostPopulateCache ();
    return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetDetailedErrorCount (ULONG* o_pcErrs)
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache); 
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// ie: Assert non-null error count destination.
	ASSERT (NULL != o_pcErrs); 
	if (NULL == o_pcErrs)
		return E_INVALIDARG;

	*o_pcErrs = m_cErrs;
	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetDetailedError (ULONG i_iErr, STErr* o_pSTErr)
{
	STErr*	pSTErr;

	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache); 
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// ie: Assert non-null error pointer pointer and null error pointer.
	ASSERT (NULL != o_pSTErr); 
	if (NULL == o_pSTErr)
		return E_INVALIDARG;
	// ie: Note detailed error is out of range (do not assert).
	if (!(0 < m_cErrs && i_iErr < m_cErrs))
		return E_ST_NOMOREERRORS;

	pSTErr				= pSTErrPart (i_iErr);
	o_pSTErr->iRow		= pSTErr->iRow;
	o_pSTErr->hr		= pSTErr->hr;
	o_pSTErr->iColumn	= pSTErr->iColumn;

	return S_OK;
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableMarshall:
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::SupplyMarshallable 
(
	DWORD i_fCaches,
	char **	o_ppv1,	ULONG *	o_pcb1,	
	char **	o_ppv2, ULONG *	o_pcb2, 
	char **	o_ppv3, ULONG *	o_pcb3, 
	char **	o_ppv4, ULONG *	o_pcb4, 
	char **	o_ppv5,	ULONG *	o_pcb5
)
{
	HRESULT		hr = S_OK;
//	areturn_on_fail ((m_fTable & fST_LOS_MARSHALLABLE), E_NOTIMPL);// ie: Assert table marshallable.

	// ie: Assert cache is ready.
	ASSERT(fCACHE_READY & m_fCache); 
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	// ie: Assert supported caches.
	ASSERT (0 == (~maskfST_MCACHE & i_fCaches)); 
	if (0 != (~maskfST_MCACHE & i_fCaches))
		return E_INVALIDARG;

// Supply the requested cache buffers and note they were marshalled:
	if(fST_MCACHE_READ & i_fCaches) // ie: Read cache:
	{
		*o_ppv1					= (char *)m_pvReadCache;
		*o_pcb1					= m_cbReadCache;
		*o_ppv2					= NULL;
		*o_pcb2					= m_cbReadVarData;
		m_fCache	|= (fST_MCACHE_READ);
	}
	if(fST_MCACHE_WRITE & i_fCaches || fST_MCACHE_WRITE_COPY & i_fCaches) // ie: Write cache:
	{
		hr = ShrinkWriteCache ();
		if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
		*o_ppv1					= (char *)m_pvWriteCache;
		*o_pcb1					= m_cbWriteCache;
		*o_ppv2					= NULL;
		*o_pcb2					= m_cbWriteVarData;
		if(fST_MCACHE_WRITE & i_fCaches)
		{
			m_fCache	|= (fST_MCACHE_WRITE);
		}
	}
	if(fST_MCACHE_ERRS & i_fCaches) // ie: Error cache:
	{
		*o_ppv3					= (char *)m_pvErrs;
		*o_pcb3					= m_cErrs * sizeof (STErr);
		m_fCache	|= fST_MCACHE_ERRS;
	}

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::ConsumeMarshallable
(
	DWORD i_fCaches,
	char * i_pv1, ULONG i_cb1,
	char * i_pv2, ULONG i_cb2,
	char * i_pv3, ULONG i_cb3, 
	char * i_pv4, ULONG i_cb4,	
	char * i_pv5, ULONG i_cb5
)
{	
//	areturn_on_fail ((m_fTable & fST_LOS_MARSHALLABLE), E_NOTIMPL);// ie: Assert table marshallable.
	// ie: Assert cache is not loading.
	ASSERT (!(fCACHE_LOADING & m_fCache)); 
	if (fCACHE_LOADING & m_fCache)
		return E_ST_INVALIDCALL;
	// ie: Assert cache metainitialized.
	ASSERT ((fCACHE_METAINITIALIZED & m_fCache)); 
	if (!((fCACHE_METAINITIALIZED & m_fCache)))
		return E_ST_INVALIDCALL;

	// ie: Assert supported caches.
	ASSERT (0 == (~maskfST_MCACHE & i_fCaches)); 
	if (0 != (~maskfST_MCACHE & i_fCaches))
		return E_INVALIDARG;

// Consume the requested cache buffers and note they were marshalled (cleanup current buffers and compute new maximums):
	if(fST_MCACHE_READ & i_fCaches) // ie: Read cache:
	{
		CleanupReadCache();
		m_pvReadCache		= i_pv1;
		m_cbReadCache		= i_cb1;
		m_cbReadVarData		= i_cb2;
		m_cbmaxReadCache	= m_cbReadCache;
		m_cReadRows			= (m_cbReadCache - m_cbReadVarData) / cbDataTotalParts();
		m_pvReadVarData		= (BYTE *)m_pvReadCache + (m_cbReadCache - m_cbReadVarData);
		m_fCache			|= fST_MCACHE_READ;
	}
	if(fST_MCACHE_WRITE & i_fCaches || fST_MCACHE_WRITE_COPY & i_fCaches) // ie: Write cache:
	{
		if (!(fST_MCACHE_WRITE_MERGE & i_fCaches))
		{
			CleanupWriteCache();
			m_pvWriteCache		= i_pv1;
			m_cbWriteCache		= i_cb1;
			m_cbWriteVarData	= i_cb2;
			m_cbmaxWriteCache	= m_cbWriteCache;
			m_cWriteRows		= (m_cbWriteCache - m_cbWriteVarData) / cbDataTotalParts();
			m_pvWriteVarData	= (BYTE *)m_pvWriteCache + (m_cbWriteCache - m_cbWriteVarData);
			if(fST_MCACHE_WRITE & i_fCaches)
			{
				m_fCache			|= fST_MCACHE_WRITE;
			}
		}
		else
		{
			// Merge the memory buffers.
			m_pvWriteCache = CoTaskMemRealloc (m_pvWriteCache, m_cbWriteCache + i_cb1);
			if(NULL == m_pvWriteCache) return E_OUTOFMEMORY; 
			m_pvWriteVarData = (BYTE *)m_pvWriteCache + (m_cbWriteCache - m_cbWriteVarData);
			memmove((BYTE*)m_pvWriteVarData + i_cb1, m_pvWriteVarData, m_cbWriteVarData);
			memcpy(m_pvWriteVarData, i_pv1, i_cb1);
			// Fix the pointers and sizes.
			m_cbWriteCache		+= i_cb1;
			m_cbWriteVarData	+= i_cb2;
			m_cbmaxWriteCache	= m_cbWriteCache;
			m_cWriteRows		= (m_cbWriteCache - m_cbWriteVarData) / cbDataTotalParts();
			m_pvWriteVarData	= (BYTE *)m_pvWriteCache + (m_cbWriteCache - m_cbWriteVarData);
			
			// Fix the variable data indices.
			PostMerge(m_cWriteRows - ((i_cb1 - i_cb2) / cbDataTotalParts()),	// Old number of rows.
						(i_cb1 - i_cb2) / cbDataTotalParts(),					// Additional number of rows.
						m_cbWriteVarData - i_cb2);								// Old m_cbWriteVarData.
		}

	}
	if(fST_MCACHE_ERRS & i_fCaches) // ie: Error cache:
	{
		CleanupErrorCache();	
		m_pvErrs			= i_pv3;
		m_cErrs				= i_cb3 / sizeof (STErr);
		m_cmaxErrs			= m_cErrs;
		m_fCache			|= fST_MCACHE_ERRS;
	}

// Mark the cache ready:
	m_fCache |= fCACHE_READY;

	return S_OK;
}


//=================================================================================
// Update the variable data indices of i_cMergeRows many rows, starting from row 
// i_iStartRow. All indices will be incremented by i_iDelta.
//=================================================================================
void CMemoryTable::PostMerge (ULONG i_iStartRow, ULONG i_cMergeRows, ULONG i_iDelta)
{
	DWORD		fColumn;
	LPVOID*		ppvValue;
	BYTE		bStatus;
	LPVOID		pvRow;
	ULONG		cbRow;
	ULONG		iColumn;
		
	cbRow = cbDataTotalParts ();
	pvRow = (BYTE*)m_pvWriteCache + (i_iStartRow * cbRow);

	while (i_cMergeRows-- > 0)
	{
		for(iColumn = 0; iColumn < m_cColumns; iColumn++)
		{
			fColumn		= m_acolmetas[iColumn].fMeta;
			bStatus		= *(pbDataStatusPart (pvRow, iColumn));
			ppvValue	= ppvDataValuePart (pvRow, iColumn);

			if (fCOLUMNMETA_VARIABLESIZE & fColumn) // ie: Column data size varies:
			{
				if (fST_COLUMNSTATUS_NONNULL & bStatus) // ie: Index exists:
				{
					*(ULONG*)ppvValue += i_iDelta;
				}
			}
		}
		pvRow = (BYTE *)pvRow + cbRow;
	}
}

//=================================================================================
inline HRESULT CMemoryTable::SetupMeta (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbDefSizes)
{
	ULONG				iColumn;
	DWORD				fHasPrimaryKey;
	SimpleColumnMeta*	pcolmeta;
	ColumnDataOffsets*	pcoloffsets;
	ULONG				cbStatusParts;
	ULONG				cbValueParts;
	ULONG				iDynamic;

	// ie: Assert cache is totally uninitialized.
	ASSERT (0 == m_fCache); 
	if (0 != m_fCache)
		return E_ST_INVALIDCALL;
	// ie: Assert maximum columns (supported by ColumnDataOffsets).
	ASSERT (i_cColumns < 32768); 
	if (!(i_cColumns < 32768))
		return E_INVALIDARG;

// Initialize the table flags, column count, column meta, column offsets:
	m_fTable					= i_fTable;
	m_cColumns					= i_cColumns;

	ASSERT (NULL == m_acolmetas);
	m_acolmetas = (SimpleColumnMeta*) new SimpleColumnMeta[m_cColumns]; 
	if(NULL == m_acolmetas) return E_OUTOFMEMORY;
	memcpy (m_acolmetas, i_acolmetas, m_cColumns * sizeof (SimpleColumnMeta));
	ASSERT (NULL == m_acoloffsets);
	m_acoloffsets = (ColumnDataOffsets*) new ColumnDataOffsets[m_cColumns]; 
	if(NULL == m_acoloffsets) return E_OUTOFMEMORY;
	if (i_apvDefaults)
	{
		ASSERT (NULL == m_acolDefaults);
		m_acolDefaults = (LPVOID*) new LPVOID[m_cColumns]; 
		if(NULL == m_acolDefaults) return E_OUTOFMEMORY;
		memcpy (m_acolDefaults, i_apvDefaults, m_cColumns * sizeof (LPVOID));
		ASSERT (NULL == m_alDefSizes);
		m_alDefSizes = (ULONG*) new ULONG[m_cColumns]; 
		if(NULL == m_alDefSizes) return E_OUTOFMEMORY;
		memcpy (m_alDefSizes, i_acbDefSizes, m_cColumns * sizeof (ULONG));
	}	

// Setup extended meta information:
	for 
	(
	// Initialization:
		iColumn = 0,
		pcolmeta = m_acolmetas, 
		pcoloffsets = m_acoloffsets,
		m_cUnknownSizes = 0, 
		cbValueParts = 0, 
		fHasPrimaryKey = FALSE; 
	// Termination:
		iColumn < m_cColumns; 
	// Iteration:
		iColumn++, 
		pcolmeta = &(m_acolmetas[iColumn]), 
		pcoloffsets = &(m_acoloffsets[iColumn])
	)
	{

	// Assert size specified is valid:
		switch (pcolmeta->dbType)
		{
		// Check the size is not zero for not sized-by-type columns
			case DBTYPE_BYTES:
			case DBTYPE_WSTR:
				ASSERT (0 != pcolmeta->cbSize);
				if (0 == pcolmeta->cbSize)
					return E_ST_INVALIDMETA;
			break;
		// Check size of sized-by-type columns
			case DBTYPE_DBTIMESTAMP:
				ASSERT (pcolmeta->cbSize == sizeof (DBTIMESTAMP));
				if (pcolmeta->cbSize != sizeof (DBTIMESTAMP))
					return E_ST_INVALIDMETA;
			break;
			case DBTYPE_GUID:
				ASSERT (pcolmeta->cbSize == sizeof (GUID));
				if (pcolmeta->cbSize != sizeof (GUID))
					return E_ST_INVALIDMETA;
			break;
			case DBTYPE_UI4:
				ASSERT (pcolmeta->cbSize == sizeof (ULONG));
				if (pcolmeta->cbSize != sizeof (ULONG))
					return E_ST_INVALIDMETA;
			break;

			default:
				ASSERT (0);
			break;
		}
		// ie: Assert flags specified are supported.
		ASSERT (0 == (~fCOLUMNMETA_MetaFlags_Mask & pcolmeta->fMeta)); 
		if (0 != (~fCOLUMNMETA_MetaFlags_Mask & pcolmeta->fMeta))
			return E_ST_INVALIDMETA;

	// Determine fixed-length by-type columns:
		if (DBTYPE_UI4 == pcolmeta->dbType || DBTYPE_GUID == pcolmeta->dbType || DBTYPE_DBTIMESTAMP == pcolmeta->dbType)
		{
			// ie: Assert fixed-length flag is specified.
			ASSERT (fCOLUMNMETA_FIXEDLENGTH & pcolmeta->fMeta); 
			if (!(fCOLUMNMETA_FIXEDLENGTH & pcolmeta->fMeta))
				return E_ST_INVALIDMETA;
		}
	// Determine whether a primary key was specified: flag pass-by-ref primary key columns as non-nullable:
		if (fCOLUMNMETA_PRIMARYKEY & pcolmeta->fMeta)
		{
			fHasPrimaryKey = TRUE;
			// ie: Assert Not NULLable flag is specified.
			ASSERT (fCOLUMNMETA_NOTNULLABLE & pcolmeta->fMeta); 
			if (!(fCOLUMNMETA_NOTNULLABLE & pcolmeta->fMeta))
				return E_ST_INVALIDMETA;
		}

	// Determine columns whose size can only be known by passing it explicitly:
		if(pcolmeta->fMeta & fCOLUMNMETA_UNKNOWNSIZE)
			m_cUnknownSizes++;
		
	// Pre-compute column data offsets (must be done before accumulating data buffer byte count):
		pcoloffsets->obStatus	= (WORD) iColumn;
		pcoloffsets->oulSize	= (WORD) (fCOLUMNMETA_UNKNOWNSIZE & pcolmeta->fMeta ? m_cUnknownSizes-1 : ~0);
		pcoloffsets->opvValue	= cbValueParts / sizeof (LPVOID);

	// Accumulate data buffer byte count of value:
		if (fCOLUMNMETA_VARIABLESIZE & pcolmeta->fMeta) // ie: Variable size data: buffer holds pointer to data:
		{
			cbValueParts += sizeof (LPVOID);
		}
		else // ie: Fixed size data: buffer holds data:
		{
			cbValueParts += cbWithPadding (pcolmeta->cbSize, sizeof (LPVOID)); // ie: Pad for alignment by void*.
		}
	}
	// ie: Assert a primary key was specified.
	ASSERT (fHasPrimaryKey); 
	if (!(fHasPrimaryKey))
		return E_ST_INVALIDMETA;

// Determine the count of status and value parts in 32-bit units:
	cbStatusParts = cbWithPadding (iColumn, sizeof (DWORD_PTR)); // ie: Pad for alignment by dword.
	// ie: Assert 32/64-bit boundary alignment of status parts.
	ASSERT (0 == cbStatusParts % sizeof (DWORD_PTR)); 
	if (0 != cbStatusParts % sizeof (DWORD_PTR)) 
		return E_UNEXPECTED;
	m_cStatusParts = cbStatusParts / sizeof (DWORD_PTR);
	// ie: Assert 32/64-bit boundary alignment of value parts.
	ASSERT (0 == cbValueParts % sizeof (LPVOID)); 
	if (0 != cbValueParts % sizeof (LPVOID))
		return E_UNEXPECTED;
	m_cValueParts = cbValueParts / sizeof (LPVOID);
	m_cUnknownSizes = (cbWithPadding (m_cUnknownSizes * sizeof (ULONG), sizeof (ULONG_PTR))) / sizeof (ULONG); // ie: Align size parts on 32/64-bit boundary as necessary.

// Adjust column data offsets (buffer contents ordered by statuses, then lengths, then values):
	for (iColumn = 0, pcoloffsets = m_acoloffsets; iColumn < m_cColumns; iColumn++, pcoloffsets = &(m_acoloffsets[iColumn]))
	{
		pcoloffsets->obStatus	+= 0;
		pcoloffsets->oulSize	+= ( ((WORD) ~0) == pcoloffsets->oulSize ? 0 : (WORD) m_cStatusParts);
		pcoloffsets->opvValue	+= (WORD) (m_cStatusParts + m_cUnknownSizes);
	}

// Flag the cache as meta initialized:
	m_fCache = fCACHE_METAINITIALIZED;
	return S_OK;
}

// -----------------------------------------
// Cache management:
// -----------------------------------------

//=================================================================================
void CMemoryTable::CleanupCaches ()
{
// Flag cache as not ready and clean the caches:
	m_fCache &= ~fCACHE_READY;
	CleanupReadCache ();
	CleanupWriteCache ();
	CleanupErrorCache ();
	return;
}

//=================================================================================
// How does the cache grow?
// The first allocation is of size m_cbMinCache. 
//		(unless the caller has requested for more than m_cbMinCache)
// Then we double the size of the fast cache.
//		(unless the caller requested for more memory than the current size
//		in which case we make the size double of the request)
// We never grow the size of the fast cache by more than cbmaxDATAGROWTH.
//		(unless the caller has asked for more than cbmaxDATAGROWTH)
//=================================================================================
HRESULT CMemoryTable::ResizeCache (DWORD i_fCache, ULONG i_cbRequest)
{
	LPVOID* ppv;
	LPVOID  pvTmp;
	LPVOID  pvNew = NULL;
	LPVOID* ppvVarData = NULL;
	ULONG	cbOldSize = 0;
	ULONG   cbVarData = 0;
	ULONG   cbmaxVarDataNow = 0;
	ULONG   cbNewSize = 0;

	switch (i_fCache)
	{
		case fST_MCACHE_WRITE:
			if (i_cbRequest > cbmaxDATAGROWTH)
			{
				cbNewSize = m_cbmaxWriteCache + i_cbRequest; 
			}
			else if ((m_cbmaxWriteCache == 0) && (i_cbRequest < m_cbMinCache))
			{
				cbNewSize = m_cbMinCache;
			}
			else
			{
				cbmaxVarDataNow = (m_cbmaxWriteCache < i_cbRequest ? i_cbRequest * 2 : m_cbmaxWriteCache * 2);
				cbNewSize = (cbmaxDATAGROWTH < (cbmaxVarDataNow - m_cbmaxWriteCache) ? m_cbmaxWriteCache + cbmaxDATAGROWTH : cbmaxVarDataNow);
			}

			ppv = &m_pvWriteCache;
			ppvVarData = &m_pvWriteVarData;
			cbVarData = m_cbWriteVarData;
			cbOldSize = m_cbmaxWriteCache;

		break;
		case fST_MCACHE_ERRS:
			ppv = &m_pvErrs;
			cbOldSize = m_cErrs * sizeof (STErr);
			cbNewSize = i_cbRequest;
		break;
		default:
			ASSERT (0); // ie: Unknown cache: module programming mistake.
		return E_UNEXPECTED;
	}

	if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & i_fCache)) // ie: Not marshalled or on the client: automatic reallocation works:
	{
		pvNew = CoTaskMemRealloc (*ppv, cbNewSize);
		if(NULL == pvNew) return E_OUTOFMEMORY;
		*ppv = pvNew;
	}
	else // ie: Marshalled and on the server: manual transfer required:
	{
		ASSERT (cbOldSize <= cbNewSize); // Resize will exclude valid data: module programming mistake.
		m_fCache &= ~i_fCache;
		pvTmp = *ppv;
		// ie: Just forget the marshalled cache. i.e. pass NULL as your first param.
		pvNew = CoTaskMemRealloc (NULL, cbNewSize);
		if(NULL == pvNew) return E_OUTOFMEMORY;
		*ppv = pvNew;
		memcpy (*ppv, pvTmp, cbOldSize);
	}

// For write cache only.
	if (i_fCache & fST_MCACHE_WRITE)
	{
		// Slide the variable data cache to the end of the memory blob.
		*ppvVarData = ((BYTE*)*ppv) + (cbNewSize - cbVarData);
		memmove(*ppvVarData,
				((BYTE*)*ppvVarData) - (cbNewSize - cbOldSize),
				cbVarData);	
		m_cbmaxWriteCache = cbNewSize;
	}
	return S_OK;
}

//=================================================================================
void CMemoryTable::CleanupReadCache ()
{
// Free the read cache (always on the client or only on the server if not marshalled):
	if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & fST_MCACHE_READ))
	{	
		if (NULL != m_pvReadCache) { delete m_pvReadCache; m_pvReadCache = NULL; }
		m_fCache &= ~fST_MCACHE_READ;
	}

// Clear the read cache:
	m_cReadRows			= 0;
	m_cbReadVarData		= 0;
	m_pvReadCache		= NULL;
	m_pvReadVarData		= NULL;
	m_cbReadCache		= 0;
	m_cbmaxReadCache	= 0;

	return;
}	
	
//=================================================================================
void CMemoryTable::CleanupWriteCache ()
{
// Free the write cache (always on the client or only on the server if not marshalled):
	if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & fST_MCACHE_WRITE))
	{	
		if (NULL != m_pvWriteCache) { delete m_pvWriteCache; m_pvWriteCache = NULL; }
		m_fCache &= ~fST_MCACHE_WRITE;
	}

// Clear the write cache:
	m_cWriteRows		= 0;
	m_cbWriteVarData	= 0;
	m_pvWriteCache		= NULL;
	m_pvWriteVarData	= NULL;
	m_cbWriteCache		= 0;
	m_cbmaxWriteCache	= 0;

	return;
}	
	
//=================================================================================
void CMemoryTable::CleanupErrorCache ()
{
// Free the error cache (always on the client or only on the server if not used in marshalling):
	if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & fST_MCACHE_ERRS))
	{	
		if (NULL != m_pvErrs) { delete m_pvErrs; m_pvErrs = NULL; }
		m_fCache &= ~fST_MCACHE_ERRS;
	}

// Clear the error cache:
	m_cErrs				= 0;
	m_cmaxErrs			= 0;
	m_pvErrs			= NULL;

	return;
}

//=================================================================================
HRESULT CMemoryTable::ShrinkWriteCache ()
{
	LPVOID		pvNewWriteVarData, pvTmp;
	HRESULT		hr = S_OK;

// Shrink the cache as necessary:
	if (m_cbWriteCache < m_cbmaxWriteCache)
	{
		pvNewWriteVarData = (BYTE*)m_pvWriteCache + (m_cWriteRows * cbDataTotalParts());
		memmove(pvNewWriteVarData, m_pvWriteVarData, m_cbWriteVarData);
		m_cbmaxWriteCache = m_cbWriteCache;

		if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & fST_MCACHE_WRITE)) // ie: Not marshalled or on the client: automatic reallocation works:
		{
			m_pvWriteCache = CoTaskMemRealloc (m_pvWriteCache, m_cbWriteCache);	
			if(NULL == m_pvWriteCache) return E_OUTOFMEMORY;
		}
		else // ie: Marshalled and on the server: manual transfer required:
		{
			m_fCache &= ~fST_MCACHE_WRITE;
			pvTmp = m_pvWriteCache;
			m_pvWriteCache = NULL; // ie: Just forget the marshalled cache.
			m_pvWriteCache = CoTaskMemRealloc (m_pvWriteCache, m_cbWriteCache);	
			if(NULL == m_pvWriteCache) return E_OUTOFMEMORY;
			memcpy (m_pvWriteCache, pvTmp, m_cbWriteCache);
		}
		m_pvWriteVarData = (BYTE*)m_pvWriteCache + (m_cWriteRows * cbDataTotalParts());
	}
	return hr;
}

//=================================================================================
// Function: CMemoryTable::RemoveDeletedRows
//
// Synopsis: Removes rows marked as 'DELETED' from the write cache. The function keeps
//           rows in the correct order, and uses a state machine to copy the non-deleted
//           rows quickly.
//			 We have three states:
//				INITIALIZE  We are at the beginning of array, and have not found any
//							deleted elements yet. We don't have to copy these elements
//							and have a separate state to show this.
//				DELETE		We found an element that needs to be deleted
//				COPY		We found an element that needs to be copied after we found
//							an element that gets deleted
//
//			When we find an element that needs to be deleted, we skip over the neighbours
//          that need to be deleted as well. As soon as we find an element that needs to
//          be copied we go into COPY mode and find all neighbours of that element that
//          needs to be copied as well. This means that we will moving blocks of 'valid
//          data' at a time, instead of copying single block.
//=================================================================================
void CMemoryTable::RemoveDeletedRows ()
{
	ASSERT(m_cWriteRows > 0);

	enum MODE
	{
		MODE_INITIALIZE = 1,
		MODE_DELETE		= 2,
		MODE_COPY		= 3
	};

	ULONG cbRow				= cbDataTotalParts ();
	ULONG iInsertionPoint	= 0;					// where should we copy valid rows to
	ULONG iCopyStart		= 0;					// where should we start copying from
	ULONG cNrElemsToCopy	= 0;					// number of elements to copy
	ULONG cNrNonDeletes		= 0;					// number of non-deleted elements
	ULONG iMode				= MODE_INITIALIZE;		// state/mode 

	for (ULONG idx=0; idx < m_cWriteRows; ++idx)
	{
		DWORD *pdwDeletedAction = pdwDataActionPart ((BYTE *)m_pvWriteCache + (idx *cbRow));
		if (*pdwDeletedAction == eST_ROW_DELETE)
		{
			switch (iMode)
			{
			case MODE_INITIALIZE:		
				// we found the first element that is marked as deleted. 
				iInsertionPoint = idx;
				iMode = MODE_DELETE;
				break;

			case MODE_COPY:
				// we found an element that needs to be deleted after a block of valid
				// elements. Copy the block of valid elements to the insertpoint
				ASSERT (cNrElemsToCopy > 0);
				ASSERT (iInsertionPoint < iCopyStart);
				memmove ((BYTE *)m_pvWriteCache + (iInsertionPoint * cbRow),
						 (BYTE *)m_pvWriteCache + (iCopyStart * cbRow),
						 cNrElemsToCopy * cbRow);
				iInsertionPoint += cNrElemsToCopy;
				cNrElemsToCopy = 0;
				iMode = MODE_DELETE;
				break;

			default:
				// do nothing
				break;
			}
		}
		else
		{
			++cNrNonDeletes;
			switch (iMode)
			{
			case MODE_DELETE:
				// we found an element after a block of deleted elements. Go into copy
				// mode to count the number of elements that needs to be copied. Also keep
				// track of where the valid element block started with iCopyStart
				iMode = MODE_COPY;
				iCopyStart = idx;
				cNrElemsToCopy = 1;
				break;
			case MODE_COPY:
				++cNrElemsToCopy;
				break;
			default:
				break;
			}
		}
	}

	// When the cache has some valid elements at the end of the cache, we need to copy
	// these elements as well. This needs to happen after we have walked through all the
	// elements.
	if (cNrElemsToCopy != 0)
	{
		ASSERT (iInsertionPoint < iCopyStart);
		memmove ((BYTE *)m_pvWriteCache + (iInsertionPoint * cbRow),
				 (BYTE *)m_pvWriteCache + (iCopyStart * cbRow),
				 cNrElemsToCopy * cbRow);
	}
		
	m_cbWriteCache -= ((m_cWriteRows - cNrNonDeletes) * cbDataTotalParts());
	m_cWriteRows = cNrNonDeletes;
}

//=================================================================================
HRESULT CMemoryTable::AddRowToWriteCache (ULONG* o_piRow, LPVOID* o_ppvRow)
{
	ULONG		cmaxRowsNow;
	ULONG		cRowTotalParts;
	HRESULT		hr = S_OK;

	if (m_cbWriteCache + cbDataTotalParts() > m_cbmaxWriteCache)
	{
		hr = ResizeCache (fST_MCACHE_WRITE, cbDataTotalParts());
		if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
	}

// Supply the index of and pointer to the added row:
	*o_piRow = m_cWriteRows;
	*o_ppvRow = ( ((LPVOID*) m_pvWriteCache) + ( cDataTotalParts() * m_cWriteRows ) );

// Increment the count of rows filled and clear the current row:
	m_cWriteRows++;
	memset (*o_ppvRow, 0, cbDataTotalParts());
	m_cbWriteCache += cbDataTotalParts();

	return hr;
}

//=================================================================================
HRESULT CMemoryTable::AddVarDataToWriteCache (ULONG i_cb, LPVOID i_pv, ULONG** o_pib)
{
	ULONG		cbPadded;
	ULONG		cbmaxVarDataNow;
	ULONG		cbNewSize;
	ULONG		cbColumnOffset;
	HRESULT		hr = S_OK;

// Grow vardata cache as necessary:
	cbPadded = cbWithPadding (i_cb, sizeof (DWORD_PTR));
	if (m_cbWriteCache + cbPadded > m_cbmaxWriteCache)
	{
		cbColumnOffset = (ULONG)((BYTE*)*o_pib - (BYTE*)m_pvWriteCache);
		hr = ResizeCache (fST_MCACHE_WRITE, cbPadded);
		if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
		// Let the caller know about the resize.
		hr = S_FALSE;
		*o_pib = (ULONG*)((BYTE*)m_pvWriteCache + cbColumnOffset);
	}

// Copy the data, supply its index, and increment the count of bytes filled:
	m_pvWriteVarData = ((BYTE*) m_pvWriteVarData) - cbPadded;
	memcpy (m_pvWriteVarData, i_pv, i_cb);
	m_cbWriteVarData += cbPadded;
	**o_pib = m_cbWriteVarData;
	m_cbWriteCache += cbPadded;

	return hr;
}

//=================================================================================
HRESULT CMemoryTable::AddErrorToErrorCache (STErr* i_pSTErr)
{
	ULONG		cmaxErrsNow;
	HRESULT		hr = S_OK;

	if (m_cErrs == m_cmaxErrs)
	{
		cmaxErrsNow = (m_cmaxErrs * 2) + 1;
		ULONG cMaxErrsNewSize = (cmaxERRGROWTH < (cmaxErrsNow - m_cmaxErrs) ? m_cmaxErrs + cmaxERRGROWTH : cmaxErrsNow);
		hr = ResizeCache (fST_MCACHE_ERRS, cMaxErrsNewSize * sizeof (STErr));
		if (FAILED (hr)) 
		{	
			ASSERT (hr == S_OK); 
			return hr; 
		}
		m_cmaxErrs = cMaxErrsNewSize;
	
	}

// Copy error into cache and increment error count:
	memcpy ( (LPVOID) (((STErr*) m_pvErrs) + m_cErrs), i_pSTErr, sizeof (STErr));
	m_cErrs++;

	return hr;
}

//=================================================================================
void CMemoryTable::BeginReadCacheLoading ()
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache); 
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return;
	// ie: Assert cache is not already loading.
	ASSERT (!(fCACHE_LOADING & m_fCache)); 
	if (fCACHE_LOADING & m_fCache)
		return;

// Flag the cache as loading:
	m_fCache |= fCACHE_LOADING;

// Clean the previous caches:
	CleanupCaches ();
	return;
}

//=================================================================================
void CMemoryTable::ContinueReadCacheLoading ()
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache); 
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return;
	// ie: Assert cache is not already loading.
	ASSERT (!(fCACHE_LOADING & m_fCache)); 
	if (fCACHE_LOADING & m_fCache)
		return;

// Flag the cache as loading (and no longer ready):
	m_fCache &= ~fCACHE_READY;
	m_fCache |= (fCACHE_LOADING | fCACHE_CONTINUING);

// Clean only the write cache:
	CleanupWriteCache ();

// Write cache now impersonates the read cache:
	m_cWriteRows		= m_cReadRows;
	m_cbWriteVarData	= m_cbReadVarData;
	m_pvWriteCache		= m_pvReadCache;
	m_pvWriteVarData	= m_pvReadVarData;
	m_cbWriteCache		= m_cbReadCache;
	m_cbmaxWriteCache	= m_cbmaxReadCache;

	return;
}

//=================================================================================
void CMemoryTable::EndReadCacheLoading ()
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache); 
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return;
	// ie: Assert cache is loading.
	ASSERT (fCACHE_LOADING & m_fCache); 
	if (!(fCACHE_LOADING & m_fCache))
		return;
	// ie: Assert cache was clean or we are continuing.
	ASSERT (!(fCACHE_READY & m_fCache) || (fCACHE_CONTINUING & m_fCache)); 
	if (!(!(fCACHE_READY & m_fCache) || (fCACHE_CONTINUING & m_fCache)))
		return;

// Assert cache loading succeeded:
	if (fCACHE_INVALID & m_fCache) // ie: Cache loading failed: flag cache as un-useable:
	{
		m_fCache &= ~fCACHE_LOADING;
		m_fCache &= ~fCACHE_READY;
		ASSERT (0);
		return;
	}

// Transform the "populated" write cache into the "populated" read cache:
	m_cReadRows			= m_cWriteRows;
	m_cbReadVarData		= m_cbWriteVarData;
	m_pvReadCache		= m_pvWriteCache;
	m_pvReadVarData		= m_pvWriteVarData;
	m_cbReadCache		= m_cbWriteCache;
	m_cbmaxReadCache	= m_cbmaxWriteCache;

// Clear the write cache for consumer use:
	m_cWriteRows		= 0;
	m_cbWriteVarData	= 0;
	m_pvWriteCache		= NULL;
	m_pvWriteVarData	= NULL;
	m_cbWriteCache		= 0;
	m_cbmaxWriteCache	= 0;

// Flag the cache as ready to use:
	m_fCache &= ~(fCACHE_LOADING | fCACHE_CONTINUING);
	m_fCache |= fCACHE_READY;

	return;
}


// -----------------------------------------
// Offset and pointer calculation helpers:
// -----------------------------------------

// =======================================================================
inline ULONG CMemoryTable::cbWithPadding (ULONG i_cb, ULONG i_cbPadTo) { return ( (i_cb + (i_cbPadTo - 1)) & (-((LONG)i_cbPadTo)) ); }

// =======================================================================
inline ULONG CMemoryTable::cbDataTotalParts	() { return (cDataTotalParts () * sizeof (LPVOID)); }

// =======================================================================
inline ULONG CMemoryTable::cDataStatusParts	() { return (m_cStatusParts); }
inline ULONG CMemoryTable::cDataSizeParts		() { return (m_cUnknownSizes); }
inline ULONG CMemoryTable::cDataValueParts		() { return (m_cValueParts); }
inline ULONG CMemoryTable::cDataTotalParts() { return (cDataStatusParts () + cDataSizeParts () + cDataValueParts () + 1); }

// =======================================================================
inline ULONG CMemoryTable::obDataStatusPart	(ULONG i_iColumn) { return (m_acoloffsets[i_iColumn].obStatus); }
inline ULONG CMemoryTable::obDataSizePart		(ULONG i_iColumn) { return (oulDataSizePart (i_iColumn) * sizeof (ULONG_PTR)); }
inline ULONG CMemoryTable::obDataValuePart		(ULONG i_iColumn) { return (opvDataValuePart (i_iColumn) * sizeof (LPVOID)); }

// =======================================================================
inline ULONG CMemoryTable::oulDataSizePart		(ULONG i_iColumn) { return (((WORD) ~0) == m_acoloffsets[i_iColumn].oulSize ? oDOESNOTEXIST : m_acoloffsets[i_iColumn].oulSize); }
inline ULONG CMemoryTable::opvDataValuePart	(ULONG i_iColumn) { return (m_acoloffsets[i_iColumn].opvValue); }
inline ULONG CMemoryTable::odwDataActionPart	() { return (cDataTotalParts () - 1); } // Action bit is the last 4-byte of the row.

// =======================================================================
inline BYTE*	CMemoryTable::pbDataStatusPart	(LPVOID i_pv, ULONG i_iColumn) { return ( ((BYTE*) i_pv) + obDataStatusPart(i_iColumn) ); }
inline ULONG*	CMemoryTable::pulDataSizePart	(LPVOID i_pv, ULONG i_iColumn)
{
	WORD oulSize = m_acoloffsets[i_iColumn].oulSize;
	return (ULONG *)((((WORD) ~0) == oulSize ? NULL : ((BYTE *)i_pv) + sizeof(ULONG_PTR)*oulSize));
}
inline LPVOID*	CMemoryTable::ppvDataValuePart	(LPVOID i_pv, ULONG i_iColumn) { return ( ((LPVOID*) i_pv) + opvDataValuePart(i_iColumn) ); }
inline DWORD*	CMemoryTable::pdwDataActionPart	(LPVOID i_pv) { return (DWORD *)( ((BYTE *)i_pv) + sizeof(DWORD_PTR)*odwDataActionPart ()  ); }

// =======================================================================
inline LPVOID	CMemoryTable::pvVarDataFromIndex (BYTE i_statusIndex, LPVOID i_pv, ULONG i_iColumn)
{
	return ( ((BYTE*) (fCOLUMNSTATUS_READINDEX & i_statusIndex ? ((BYTE*)m_pvReadCache) + m_cbmaxReadCache : ((BYTE*)m_pvWriteCache) + m_cbmaxWriteCache)) - (*((ULONG*) ppvDataValuePart (i_pv, i_iColumn))) );
}

// =======================================================================
inline LPVOID	CMemoryTable::pvDefaultFromIndex (ULONG i_iColumn) { return (m_acolDefaults ?  m_acolDefaults[i_iColumn] :  NULL); }
inline ULONG	CMemoryTable::lDefaultSize (ULONG i_iColumn) { return (m_alDefSizes ?  m_alDefSizes[i_iColumn] :  0); }

// =======================================================================
inline STErr*	CMemoryTable::pSTErrPart (ULONG i_iErr) { return ( (((STErr*) m_pvErrs) + i_iErr) ); }

// -----------------------------------------
// Derived class helpers:
// -----------------------------------------

// =======================================================================
// Type-aware matching
BOOL CMemoryTable::InternalMatchValues(DWORD eOperator, DWORD dbType, DWORD fMeta, ULONG size1, ULONG size2, void *pv1, void *pv2)
{
	switch(eOperator)
	{
	case eST_OP_EQUAL:
		if(!(pv1 && pv2)) // ie at least one is null or zero
		{
			return (!pv1 && !pv2); 
		}
		else // both pv1 and pv2 are not null
		{
			switch (dbType)
			{
			case DBTYPE_DBTIMESTAMP:
				return !::memcmp(pv1, pv2, sizeof (DBTIMESTAMP));
			break;
			case DBTYPE_GUID:
				return !::memcmp(pv1, pv2, sizeof (GUID));
			break;
			case DBTYPE_WSTR:
				if (fMeta & fCOLUMNMETA_MULTISTRING)
				{
					return MultiStringCompare ((LPCWSTR) pv1, (LPCWSTR) pv2, fMeta & fCOLUMNMETA_CASEINSENSITIVE);
				}
				else
				{
					if (fMeta & fCOLUMNMETA_CASEINSENSITIVE)
						return !::_wcsicmp((LPCWSTR)pv1, (LPCWSTR)pv2);
					else
						return !::wcscmp((LPCWSTR)pv1, (LPCWSTR)pv2);
				}
			break;
			case DBTYPE_BYTES:
				return (size1 == size2) && !::memcmp(pv1, pv2, size1);
			break;
			case DBTYPE_UI4:
				return *(DWORD*)pv1==*(DWORD*)pv2;
			break;
			default:
				ASSERT(0);
				return FALSE;
			break;
			}
		}//else
	break;
	case eST_OP_NOTEQUAL:
		if(!(pv1 && pv2)) // ie at least one is null or zero
		{
			return (pv1 || pv2);  // at least one should not be NULL/zero to succeed
		}
		else // both pv1 and pv2 are not null
		{
			switch (dbType)
			{
			case DBTYPE_DBTIMESTAMP:
				return ::memcmp(pv1, pv2, sizeof (DBTIMESTAMP));
			break;
			case DBTYPE_GUID:
				return ::memcmp(pv1, pv2, sizeof (GUID));
			break;
			case DBTYPE_WSTR:
				if (fMeta & fCOLUMNMETA_MULTISTRING)
				{
					return !MultiStringCompare ((LPCWSTR) pv1, (LPCWSTR) pv2, fMeta & fCOLUMNMETA_CASEINSENSITIVE);
				}
				else
				{
					if (fMeta & fCOLUMNMETA_CASEINSENSITIVE)
						return ::_wcsicmp((LPCWSTR)pv1, (LPCWSTR)pv2);
					else
						return ::wcscmp((LPCWSTR)pv1, (LPCWSTR)pv2);
				}
			break;
			case DBTYPE_BYTES:
				return (size1 != size2) || ::memcmp(pv1, pv2, size1);
			break;
			case DBTYPE_UI4:
				return *(DWORD*)pv1 != *(DWORD*)pv2;
			break;
			default:
				ASSERT(0);
				return FALSE;
			break;
			}
		}//else
	break;
	default: // we don't support other operators (yet)
		ASSERT(0);
		return FALSE;
	break;
	}
}


// -----------------------------------------
// read/write helpers:
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::GetRowFromIndex(DWORD i_eReadOrWrite, ULONG i_iRow, VOID** o_ppvRow)
{
	HRESULT		hr = S_OK;
	ULONG		cRows;								// Count of rows present.
	ULONG		cRowTotalParts;						// Count of parts of a row.
	LPVOID*		ppvFirstRow;						// Pointer to the first row.

// Setup for either:
	switch (i_eReadOrWrite)
	{
		case eCURSOR_READ:
			cRows			= m_cReadRows;
			ppvFirstRow		= (LPVOID*) m_pvReadCache;
		break;

		case eCURSOR_WRITE:
			cRows			= m_cWriteRows;
			ppvFirstRow		= (LPVOID*) m_pvWriteCache;
		break;
		default:
			cRows 			= 0;
			ppvFirstRow		= 0;
	}
	
	cRowTotalParts	= cDataTotalParts ();
// Check if the row index is within limits:
	if (i_iRow >= cRows)
	{
		return E_ST_NOMOREROWS;
	}

// Index and point to the row and note we are on a row:
	*o_ppvRow = ppvFirstRow + (i_iRow * cRowTotalParts);
	return hr;
}

// =======================================================================
HRESULT CMemoryTable::MoveToEitherRowByIdentity(DWORD i_eReadOrWrite, ULONG* i_acb, LPVOID* i_apv, ULONG* o_piRow)
{
	HRESULT	hr = S_OK;
	ULONG	iKeyColumn;
	LPVOID	pv;
	ULONG	cbColSize, i;
	ULONG	iRow;
	BOOL	fColMatched;

// TODO: Do not bother checking if we are already on the row!

	// parameter validation; we need i_acb not null only for dbbytes
// TODO: Verify i_acb non-null if pk has bytes types.
	if (!i_apv)
		return E_INVALIDARG;

	if (o_piRow == 0)
		return E_INVALIDARG;

	// initialize output parameter
	*o_piRow = ~0;

	
	iRow = 0;
	// keep looking at rows until we find a match or we are out of rows
	while (E_ST_NOMOREROWS != hr)
	{
		fColMatched = TRUE;
		iKeyColumn = 0;
		i=0;
		while ((i<m_cColumns) && fColMatched)
		{	
			if(m_acolmetas[i].fMeta & fCOLUMNMETA_PRIMARYKEY) // only look at key columns
			{
				//NULL PK is invalid.
				if (NULL == i_apv[iKeyColumn])
				{
                    return E_INVALIDARG;
				}

				hr = GetEitherColumnValues(iRow, i_eReadOrWrite, 1, &i, NULL, &cbColSize, &pv);
				if (FAILED (hr)) { return hr; }

				switch(m_acolmetas[i].dbType)
				{
				case DBTYPE_BYTES:
					ASSERT(i_acb);
					if (!i_acb)
						return E_INVALIDARG;
					fColMatched = InternalMatchValues(eST_OP_EQUAL, m_acolmetas[i].dbType, m_acolmetas[i].fMeta, cbColSize, i_acb[iKeyColumn], pv, i_apv[iKeyColumn]);
				break;
				default:
					fColMatched = InternalMatchValues(eST_OP_EQUAL, m_acolmetas[i].dbType, m_acolmetas[i].fMeta, 0, 0, pv, i_apv[iKeyColumn]);
				break;
				}

				// advance the index in the "in" structures
				iKeyColumn++;
			}
			if(fColMatched) i++;
		}
		if( i == m_cColumns) 
		{
			*o_piRow = iRow;
			break; // we've found a match
		}
		iRow++;
	}
	return hr;
}

HRESULT CMemoryTable::GetEitherRowIndexBySearch(DWORD i_eReadOrWrite,
												ULONG i_iStartingRow, ULONG i_cColumns, 
											    ULONG* i_aiColumns, ULONG* i_acbSizes, 
											    LPVOID* i_apvValues, ULONG* o_piRow)
{
	HRESULT	hr = S_OK;

	LPVOID	pv;
	ULONG	cbColSize;
	ULONG	iRow;
	BOOL	fColMatched;

	if (i_cColumns > m_cColumns)
		return E_ST_NOMORECOLUMNS;

	if (i_aiColumns == 0 && i_cColumns != m_cColumns)
		return E_INVALIDARG;

	if (o_piRow == 0)
		return E_INVALIDARG;

	if (i_apvValues == 0)
		return E_INVALIDARG;

	// initialize output parameter.
	*o_piRow = ~0;

	ULONG iColToGet;

	iRow = i_iStartingRow;
	// keep looking at rows until we find a match or we are out of rows
	while (E_ST_NOMOREROWS != hr)
	{
		fColMatched = TRUE;
		ULONG iColToGet;
		// get the value for each column that we are interested in, and compare it
		// to the value for that column that is passed in. When all values match, the
		// whole row matches.
		for (ULONG idx=0; idx<i_cColumns; ++idx)
		{
			if (i_aiColumns == 0)
			{
				iColToGet = idx;
			}
			else
			{
				iColToGet = i_aiColumns[idx];
				if (iColToGet < 0)
				{
					return E_INVALIDARG;
				}

				if (iColToGet >= m_cColumns)
				{
					return E_ST_NOMORECOLUMNS;
				}
			}

			// get single row
			hr = GetEitherColumnValues(iRow, i_eReadOrWrite, 1, &iColToGet, NULL, &cbColSize, &pv);
			if (FAILED (hr)) 
			{ 
				return hr; 
			}
		
			switch(m_acolmetas[iColToGet].dbType)
			{
			case DBTYPE_BYTES:
				ASSERT(i_acbSizes);
				if (!i_acbSizes)
					return E_INVALIDARG;
				fColMatched = InternalMatchValues(eST_OP_EQUAL, m_acolmetas[iColToGet].dbType, m_acolmetas[iColToGet].fMeta, cbColSize, i_acbSizes[iColToGet], pv, i_apvValues[iColToGet]);
			break;
			default:
				fColMatched = InternalMatchValues(eST_OP_EQUAL, m_acolmetas[iColToGet].dbType, m_acolmetas[iColToGet].fMeta, 0, 0, pv, i_apvValues[iColToGet]);
			break;
			}

			if (!fColMatched)
			{
				break;
			}
		}

		if (fColMatched)
		{
			*o_piRow = iRow;
			break; // break out the while loop, because we found a match
		}

		iRow++;
	}
	return hr;
}
// =======================================================================
HRESULT CMemoryTable::GetEitherColumnValues (ULONG i_iRow, DWORD i_eReadOrWrite, ULONG i_cColumns, ULONG *i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes , LPVOID* o_apvValues)
{
	DWORD			fColumn;
	BYTE			fIndex;
	ULONG			cbMaxSize;
	LPVOID*			ppvValue;
	LPVOID			pvValue = NULL;
	ULONG*			pulSize;
	BYTE			bStatus;
	LPVOID			pvRow = NULL;
	ULONG			iColumn;
	ULONG			ipv;
	ULONG			iTarget;
	HRESULT			hr			= S_OK;

// Parameter validation:
	// ie: Assert caller's buffer is valid.
	if (NULL == o_apvValues)
		return E_INVALIDARG;
	// ie: Assert count is valid.
	if (i_cColumns == 0)
		return E_INVALIDARG;

	if (i_cColumns > m_cColumns)
		return E_ST_NOMORECOLUMNS;

	if (i_eReadOrWrite == eCURSOR_READ)
	{
		// ie: Assert no status expected on read row.
		ASSERT (NULL == o_afStatus); 
		if (NULL != o_afStatus)
		{
			hr = E_ST_INVALIDCALL;
			goto Cleanup; 
		}
		fIndex = fCOLUMNSTATUS_READINDEX;
	}
	else
	{
		fIndex = fCOLUMNSTATUS_WRITEINDEX;
	}

		
	if (FAILED(hr = GetRowFromIndex(i_eReadOrWrite, i_iRow, &pvRow)))
		return hr;
	ASSERT(pvRow != NULL);

	for(ipv=0; ipv<i_cColumns; ipv++)
	{
		if(NULL != i_aiColumns)
			iColumn = i_aiColumns[ipv];
		else
			iColumn = ipv;

		// If caller needs one column only, he doesn't need to pass a buffer for all the columns.
		iTarget = (i_cColumns == 1) ? 0 : iColumn;

		// ie: Note column out of range (do not assert).
		if (iColumn >= m_cColumns)
		{
			hr = E_ST_NOMORECOLUMNS;
			goto Cleanup; 
		}

	// Remember the column flags, status, and value reference:
		fColumn		= m_acolmetas[iColumn].fMeta;
		bStatus		= *(pbDataStatusPart (pvRow, iColumn));
		ppvValue	= ppvDataValuePart (pvRow, iColumn);

	// Get the column value:
		if (fCOLUMNMETA_VARIABLESIZE & fColumn) // ie: Column data size varies: pointer copy:
		{
			if (fST_COLUMNSTATUS_NONNULL & bStatus) // ie: Data exists:
			{
				pvValue = pvVarDataFromIndex (fIndex, pvRow, iColumn);
			}
			else // ie: No data:
			{
				// Apply defaults if the user hasn't explicitly asked not to.
				if ( (fColumn & fCOLUMNMETA_PRIMARYKEY) || !(m_fTable & fST_LOS_NODEFAULTS))
				{
					pvValue = pvDefaultFromIndex(iColumn);
				}
				else
				{
					pvValue = NULL;
				}

				if (pvValue != NULL)
				{
					bStatus |= fST_COLUMNSTATUS_DEFAULTED|fST_COLUMNSTATUS_NONNULL;
				}
			}
			o_apvValues[iTarget] = pvValue;
		}
		else // ie: Column data size fixed: value copy:
		{
			if (fST_COLUMNSTATUS_NONNULL & bStatus) // ie: Data to copy:
			{
				o_apvValues[iTarget] = ppvValue;
			}
			else // ie: No data to copy:
			{
				// Apply defaults if the user hasn't explicitly asked not to.
				if ( (fColumn & fCOLUMNMETA_PRIMARYKEY) || !(m_fTable & fST_LOS_NODEFAULTS))
				{
					o_apvValues[iTarget] = pvDefaultFromIndex(iColumn);
				}
				else
				{
					o_apvValues[iTarget] = NULL;
				}

				if (o_apvValues[iTarget] != NULL)
				{
					bStatus |= fST_COLUMNSTATUS_DEFAULTED|fST_COLUMNSTATUS_NONNULL;
				}
			}
		}

	// Get the row status (optional): Only valid for GetWriteColumn:
		if (o_afStatus)
		{
			o_afStatus[iTarget] = (bStatus & maskfST_COLUMNSTATUS);
		}

	// Get the column size (optional):
		if (o_acbSizes)
		{
			if (fCOLUMNMETA_VARIABLESIZE & fColumn) // ie: Column data size varies:
			{
				if (fCOLUMNMETA_UNKNOWNSIZE & fColumn) // ie: Column data size must be passed:
				{
					if (!(bStatus & fST_COLUMNSTATUS_DEFAULTED))
					{
						o_acbSizes[iTarget] = *(pulDataSizePart (pvRow, iColumn));
					}
					else
					{
						o_acbSizes[iTarget] = lDefaultSize(iColumn);
					}
				}
				else // ie: Column data size must be determined:
				{
					ASSERT (DBTYPE_WSTR == m_acolmetas[iColumn].dbType);
					ULONG cLength = 0;
					if (pvValue != 0)
					{
						if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
						{
							cLength = (ULONG) GetMultiStringLength ((LPCWSTR) pvValue);
						}
						else
						{
							cLength = (ULONG) wcslen ((LPCWSTR) pvValue) + 1;
						}
					}
					o_acbSizes[iTarget] = (ULONG)(fST_COLUMNSTATUS_NONNULL & bStatus ? cLength * sizeof (WCHAR) : 0);
				}
			}
			else // ie: Column data size is fixed:
			{
                #define FixedAndNullable(fColumnMetaFlags) (fCOLUMNMETA_FIXEDLENGTH == ((fCOLUMNMETA_NOTNULLABLE | fCOLUMNMETA_FIXEDLENGTH) & fColumnMetaFlags))
				o_acbSizes[iTarget] = (FixedAndNullable(fColumn) && !(fST_COLUMNSTATUS_NONNULL & bStatus) ? 0 : m_acolmetas[iColumn].cbSize);
			}
		}

	} // For all columns requested

Cleanup:

	if(FAILED(hr))
	{
// Initialize out parameters
		for(ipv=0; ipv<i_cColumns; ipv++)
		{
			o_apvValues[ipv]		= NULL;
			if(NULL != o_acbSizes)
			{
				o_acbSizes[ipv]	= 0;
			}
		}
	}

	return hr;
}

// =======================================================================
HRESULT CMemoryTable::AddWriteRow(DWORD fAction, ULONG* o_piWriteRow)
{
	HRESULT hr = S_OK;
	LPVOID	pvWriteRow;	// todo: Not used, can be deleted.

// Add a row to the write cache and obtain its index and pointer:
	hr = AddRowToWriteCache (o_piWriteRow, &pvWriteRow);
	if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }

// Set the row action appropriately:
	if (fCACHE_READY & m_fCache) // ie: Adding the write cache: Set the row action:
	{
		hr = SetWriteRowAction (*o_piWriteRow, fAction);
	}// else: ie: Adding to the read cache: Row action not present.

	return hr;
}

// =======================================================================
HRESULT CMemoryTable::CopyWriteRowFromReadRow(ULONG i_iReadRow, ULONG i_iWriteRow)
{
	HRESULT	hr;
	ULONG	i;
	ULONG	cColumns = m_cColumns;

	ULONG	acb[cmaxCOLUMNS];
	LPVOID	apv[cmaxCOLUMNS];

	ULONG	*pcb		= acb;
	LPVOID	*ppv		= apv;
	BOOL	bDynAlloc	= FALSE;
	LPVOID	pvWriteRow	= NULL;

	if(cColumns > cmaxCOLUMNS)
	{
		ASSERT (NULL == pcb);
		pcb = new ULONG[cColumns];		
		if(NULL == pcb) return E_OUTOFMEMORY; 
		ASSERT (NULL == ppv); 
		ppv = new LPVOID[cColumns];				
		if(NULL == ppv) return E_OUTOFMEMORY; 
		bDynAlloc = TRUE;
	}

	hr = GetColumnValues(i_iReadRow, cColumns, NULL, pcb, ppv);
	if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }

	m_fCache |= fCACHE_ROWCOPYING;
	hr = SetWriteColumnValues(i_iWriteRow, cColumns, NULL, pcb, ppv);
	m_fCache &= ~fCACHE_ROWCOPYING;
	if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iWriteRow, &pvWriteRow)))
		return hr;
	ASSERT(pvWriteRow != NULL);

	for(i=0; i<cColumns; i++)
	{
		BYTE	*pbStatus;
		
		pbStatus =  pbDataStatusPart (pvWriteRow, i);
		(*pbStatus) &= ~fST_COLUMNSTATUS_CHANGED;
	}

	if(bDynAlloc)
	{
		if (NULL != pcb) { delete[] pcb; pcb = NULL; }
		if (NULL != ppv) { delete[] ppv; ppv = NULL; }	
	}

	return S_OK;
}



// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleDataTableDispenser2:
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::InternalPreUpdateStore ()
{
	LPVOID		pvWriteRow = NULL;
	BYTE		bStatus;
	ULONG		iColumn = 0;
	ULONG		i = 0;
	HRESULT		hr = S_OK;

	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL; 

	// TODO: Validate that all NOTNULLABLE columns are set.
	while (SUCCEEDED(hr = GetRowFromIndex(eCURSOR_WRITE, i++, &pvWriteRow)))
	{
		// Insure all non-nullable columns were set:
		for (iColumn = 0; iColumn < m_cColumns; iColumn++)
		{
			if (fCOLUMNMETA_NOTNULLABLE & (m_acolmetas[iColumn].fMeta)) // ie: Column marked not nullable:
			{
				bStatus = *(pbDataStatusPart (pvWriteRow, iColumn));
				if (!(fST_COLUMNSTATUS_NONNULL & bStatus)) 
					return E_ST_VALUENEEDED;		// ie: Verify column is not null.
			}
		}
	}

	if (hr == E_ST_NOMOREROWS)
		hr = S_OK;

	return hr;
}

SIZE_T
CMemoryTable::GetMultiStringLength (LPCWSTR i_wszMS) const
{
	SIZE_T iTotalLen = 0;
	ASSERT (i_wszMS != 0);

	if ((*i_wszMS == L'\0') && (*(i_wszMS+1) == L'\0'))
	{
		iTotalLen = 2;
	}
	else
	{
		for (LPCWSTR pCurString = i_wszMS;
			 *pCurString != L'\0';
			 pCurString = i_wszMS + iTotalLen)
		{
			iTotalLen += wcslen (pCurString) + 1;
		}

		iTotalLen++; // for last L\'0'
	}

	return iTotalLen;
}

BOOL
CMemoryTable::MultiStringCompare (LPCWSTR i_wszLHS, 
								  LPCWSTR i_wszRHS,
								  BOOL fCaseInsensitive)
{
	ASSERT (i_wszLHS != 0);
	ASSERT (i_wszRHS != 0);

	LPCWSTR pLHS;
	LPCWSTR pRHS;

	for (pLHS = i_wszLHS, pRHS = i_wszRHS;
	     *pLHS != L'\0' && *pRHS != L'\0';
		 pLHS += wcslen (pLHS) + 1, pRHS += wcslen (pRHS) + 1)
	 {
		 BOOL fResult;
		 if (fCaseInsensitive)
		 {
			 fResult = _wcsicmp (pLHS, pRHS);
		 }
		 else
		 {
			 fResult = wcscmp (pLHS, pRHS);
		 }

		 if (fResult != 0)
		 {
			 return FALSE;
		 }
	 }

	 // we compared all the string, so they must be equal

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\icompilationplugin.h ===
//  Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
//  Filename:       ICompilationPlugin.h
//  Author:         Stephenr
//  Date Created:   6/22/00
//  Description:    We need aa extensible way to allow disparate pieces of code to
//                  update and cook the meta into new forms.  Those pieces of code
//                  that wish to do this must derive from this interface.
//

#ifndef __ICOMPILATIONPLUGIN_H__
#define __ICOMPILATIONPLUGIN_H__

#ifndef __OUTPUT_H__
    #include "Output.h"
#endif
#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif


class ICompilationPlugin
{
public:
    ICompilationPlugin(){}
    virtual ~ICompilationPlugin(){}
    
    virtual void Compile(TPEFixup &fixup, TOutput &out) = 0;
};


#endif //__ICOMPILATIONPLUGIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\main.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#define INITGUID
#include "XMLUtility.h"
#include "Catalog42Ver.h"
#include "__product__.ver"
#include "atlimpl.cpp"
#ifndef __TPOPULATETABLESCHEMA_H__
    #include "TPopulateTableSchema.h"
#endif
#include "..\..\stores\FixedSchemaInterceptor\TableSchema.cpp"

#pragma warning(disable : 4800)

wchar_t g_szProgramVersion[255];

static wchar_t *szProgramHelp[]={
L"Catalog Utility - Version %d.%02d.%02d Build(%d)",
L"\r\n%s\r\n\r\n",
L"This program has two purposes surrounding XML and the Catalog:                 \r\n",
L"        1)  Validating XML File - This is useful for any XML file whether      \r\n",
L"            related to Catalog or not.                                         \r\n",
L"        2)  Compiling - This refers to the Compiling of Catalog Meta and Wiring\r\n",
L"            into the following files: An Unmanaged C++ Header, The Catalog XML \r\n",
L"            Schema (xms) file and The Catalog Dynamic Link Library.            \r\n",
L"                                                                               \r\n",
L"CatUtil [/?] [Validate] [/Compile] [/meta=[CatMeta.xml]] [/wire=[CatWire.xml]] \r\n",
L"        [/header=[CatMeta.h]] [/schema=[Catalog.xms]] [/dll=[Catalog.dll]]     \r\n",
L"        [xmlfilename]                                                          \r\n",
L"                                                                               \r\n",
L"? - Brings up this help screen.                                                \r\n",
L"                                                                               \r\n",
L"validate - Will indicate whether the given file is 'Valid' according to its DTD\r\n",
L"        or XML Schema.  This requires an 'xmlfilename'.                        \r\n",
L"                                                                               \r\n",
L"xmlfilename - If specified with no other options, the XML file will be checked \r\n",
L"        for 'Well-Formity'.                                                    \r\n",
L"                                                                               \r\n",
L"product - Associates the dll with the given product name.  The Product Name    \r\n",
L"        must be supplied.  This association MUST be done before the Catalog may\r\n",
L"        be used with the given product.                                        \r\n",
L"                                                                               \r\n",
L"compile - Compile of Catalog Meta and Wiring as described above, using deaults \r\n",
L"        where no values are supplied.  To do a partial compile (ie only        \r\n",
L"        generate the Unmanaged C++ Header) do NOT specify the 'Compile' option \r\n",
L"        and only specify the 'meta' and 'header' options.  'Compile' is the    \r\n",
L"        same as '/meta /wire /header /schema /dll' where any of those flags    \r\n",
L"        explicitly specified may override the defaults.                        \r\n",
L"                                                                               \r\n",
L"meta   - Specifies the Catalog Meta XML file.  The default is CatMeta.xml.     \r\n",
L"             This is an input only file and will not be modified               \r\n",
L"wire   - Specifies the Catalog Wiring XML file.  The default is CatWire.xml.   \r\n",
L"             This is an input only file and will not be modified               \r\n",
L"header - Specifies the Unmanaged C++ Header file.  The default is CatMeta.h.   \r\n",
L"             This is an input/output file and will be updated only if changed. \r\n",
L"schema - Specifies the Catalog XML Schema file.  The default is Catalog.xms.   \r\n",
L"             This is an output file and will overwrite a previous version.     \r\n",
L"dll    - Specifies the Catalog DLL file.  The default is Catalog.dll.          \r\n",
L"             This is an input/output file and will update the previous version.\r\n",
L"             Either the 'compile' or 'product' option must be specified along  \r\n",
L"             with the 'dll' option.                                            \r\n",
L"config - Specifies the Machine Config Directory.                               \r\n",
L"             The 'product' option must be specified along with the 'config'    \r\n",
L"             option.                                                           \r\n",
L"                                                                               \r\n",
L"\r\n", 0};


enum
{
    iHelp,
    iValidate,
    iCompile,
    iMeta,
    iWire,
    iHeader,
    iSchema,
    iDll,
    iProduct,
    iConfig,
    cCommandLineSwitches
};
wchar_t * CommandLineSwitch[cCommandLineSwitches]  ={L"?"  , L"validate", L"compile", L"meta", L"wire", L"header", L"schema", L"dll" , L"product" , L"config"};
int       kCommandLineSwitch[cCommandLineSwitches] ={0x8000, 0x01       , 0x7e      , 0x02   , 0x66   , 0x0a     , 0x12     , 0x00   , 0x80       , 0x00}; 
//Each of the above bits dictates an action.  Which is NOT necessarily a 1 to 1 relation to the command line switch.

const int MinNumCharsInSwitch = 3;//From the command line the user only needs to use the first 3 charaters of the switch
enum
{
    eParseForWellFormedOnly = 0x0000,
    eHelp                   = 0x8000,
    eValidateXMLFile        = 0x0001,
    eValidateMeta           = 0x0002,
    eValidateWiring         = 0x0004,
    eHeaderFromMeta         = 0x0008,
    eSchemaFromMeta         = 0x0010,
    eMetaFixup              = 0x0020,
    eFixedTableFixup        = 0x0040,
    eProduct		        = 0x0080
};

LPCWSTR wszDefaultOption[cCommandLineSwitches] =
{
    0//no file associated with help
    ,0//no default file associated with validate (the last parameter is considered the XML file; no default)
    ,0//no file associated with compile
    ,L"CatMeta.xml"
    ,L"CatWire.xml"
    ,L"CatMeta.h"
    ,L"Catalog.xms"
    ,L"Catalog.dll"
    ,0
    ,0
};

void GetOption(LPCWSTR wszCommandLineSwitch, LPCWSTR &wszOption, LPCWSTR wszDefaultOption)
{
    while(*wszCommandLineSwitch != L'=' && *wszCommandLineSwitch != 0x00)//advance to the '='
        ++wszCommandLineSwitch;
    if(*wszCommandLineSwitch != L'=')//if no '=' then use the dafault
        wszOption = wszDefaultOption;
    else
        wszOption = ++wszCommandLineSwitch;//now point past the '='
}


HRESULT ParseCommandLine(int argc, wchar_t *argv[ ], DWORD &dwCommandLineSwitches, LPCWSTR wszOption[cCommandLineSwitches])
{
    if(argc < 2)//we must have been passed at least the filename
        return E_INVALIDARG;
    if(argc > (cCommandLineSwitches + 2))//we must not be passed more than ALL of the switches
        return E_INVALIDARG;

    dwCommandLineSwitches = 0x00;
    for(int q=0; q<cCommandLineSwitches; q++)
        wszOption[q] = wszDefaultOption[q];//start with all of the default filenames

    for(int n=1;n<argc;n++)
        if(*argv[n] == '/' || *argv[n] == '-')//only acknowledge those command lines that begin with a '/' or a '-'
        {
            for(int i=0; i<cCommandLineSwitches; i++)
                if(0 == wcsncmp(&argv[n][1], CommandLineSwitch[i], MinNumCharsInSwitch))//Compare the first MinNumCharsInSwitch characters
                {
                    dwCommandLineSwitches |= kCommandLineSwitch[i];
                    switch(i)
                    {
                    case iHelp:     //This option does not have a '=filename' option
                    case iCompile:  //We should already be setup for defaults
                        break;
                    case iValidate: //This option does not have a '=filename' option but if one is given we will accept it
                    case iMeta:
                    case iWire:
                    case iHeader:
                    case iSchema:
                    case iDll:
                    case iConfig:
                        GetOption(argv[n], wszOption[i], wszDefaultOption[i]);
                        break;
                    case iProduct:
                        GetOption(argv[n], wszOption[i], wszDefaultOption[i]);
                        if(0 == wszOption[i])//if a Product is not specified then bail
                            return E_FAIL;
                        break;
                    }
                    break;
                }
            if(i == cCommandLineSwitches)
                return E_FAIL;//an unknown switch was specified so bail
        }
        else//assume any parameter without a leading '/' or '-' is the XML file name
            wszOption[iValidate] = argv[n];

    //We should have covered this case
    if(eParseForWellFormedOnly == dwCommandLineSwitches && 0 == wszOption[iValidate])
        return E_FAIL;

    return S_OK;
}

extern "C" int __cdecl wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
{
    TCom            com;
    TScreenOutput   Screen;
    DWORD           dwCommandLineSwitches = 0;
    try
    {
        int i=0;
        Screen.printf(szProgramHelp[i++], VER_PRODUCTVERSION);
        Screen.printf(szProgramHelp[i++], TEXT(VER_LEGALCOPYRIGHT_STR));

        wsprintf(g_szProgramVersion, szProgramHelp[0], VER_PRODUCTVERSION);
        
        LPCWSTR wszFilename[cCommandLineSwitches] = {0};//Most of the switches can have an '=filename' following, but /regsiter has an '=Product',
        LPCWSTR &wszProduct = wszFilename[iProduct];//This isn't really a filename like the rest.

        if(FAILED(ParseCommandLine(argc, argv, dwCommandLineSwitches, wszFilename)) || dwCommandLineSwitches & eHelp)
        {
            //If fialed to parse OR /? was specified then display help and exit
            while(szProgramHelp[i])
                Screen.printf(szProgramHelp[i++]);
            return 0;
        }

        //Now that we have all of the filenames and other options, we need to expand any environment variables passed in
        WCHAR   Filename[cCommandLineSwitches][MAX_PATH];
        for(i=0;i<cCommandLineSwitches; ++i)
        {
            if(wszFilename[i])//if it's NULL then leave it NULL
            {
                ExpandEnvironmentStrings(wszFilename[i], Filename[i], MAX_PATH);
                wszFilename[i] = Filename[i];
            }
        }

        if(eParseForWellFormedOnly == dwCommandLineSwitches || eValidateXMLFile & dwCommandLineSwitches)
        {
            TXmlFile xml;
            xml.Parse(wszFilename[iValidate], static_cast<bool>(dwCommandLineSwitches & eValidateXMLFile));
        }

        if(dwCommandLineSwitches & (eValidateMeta | eValidateWiring | eHeaderFromMeta | eSchemaFromMeta | eMetaFixup | eFixedTableFixup) && !(dwCommandLineSwitches & eProduct))
        {
            TXmlFile xml[0x20];//We don't support more than 0x20 meta files
            int      iXmlFile=0;

            WCHAR    MetaFiles[MAX_PATH * 0x20];
            wcscpy(MetaFiles, wszFilename[iMeta]);
            LPWSTR token = wcstok( MetaFiles, L",");
            while( token != NULL )
            {
                xml[iXmlFile].Parse(token, true);//Parse and validate

                if(!xml[iXmlFile].IsSchemaEqualTo(TComCatMetaXmlFile::m_szComCatMetaSchema))
                {
                    Screen.printf(L"Error! %s is not a valid %s.  This is required for any type of Compilation.", token, TComCatMetaXmlFile::m_szComCatMetaSchema);
                    THROW(ERROR - META XML FILE NOT VALID);
                }
                ++iXmlFile;
                token = wcstok( NULL, L",");
            }

            Screen.printf(L"Compatible %s file detected\n", TComCatMetaXmlFile::m_szComCatMetaSchema);
        
            TComCatMetaXmlFile ComCatMeta(xml, iXmlFile, Screen);
            ComCatMeta.Dump(TDebugOutput());

            TPopulateTableSchema populatedTableSchemaHeap(Screen, ComCatMeta, kTableSchemaSignature0, kTableSchemaSignature1, 0x1000);

            //Schema generation should come before anything else since other options may be dependant on it
            if(dwCommandLineSwitches & eSchemaFromMeta)
                TSchemaGeneration(wszFilename[iSchema], ComCatMeta, Screen);//the construction of this object creates the schema files

            if((dwCommandLineSwitches & eFixedTableFixup) && !(dwCommandLineSwitches & eProduct))
            {
                TComCatDataXmlFile ComCatData;//Update the PEFixup structure with these tables
                ComCatData.Parse(wszFilename[iWire], true);
                if(!ComCatData.IsSchemaEqualTo(TComCatDataXmlFile::m_szComCatDataSchema))
                    Screen.printf(L"Warning! %s specified, but %s is not a %s file.  Nothing to do.", CommandLineSwitch[iMeta], wszFilename[iWire], TComCatDataXmlFile::m_szComCatDataSchema);
                else
                {
                    ComCatData.Compile(ComCatMeta, Screen);
                    ComCatData.Dump(TDebugOutput());
                }
            }
            if(dwCommandLineSwitches & eHeaderFromMeta)
                TTableInfoGeneration(wszFilename[iHeader], ComCatMeta, Screen);//the construction of this object creates the TableInfo file
            if(dwCommandLineSwitches & eMetaFixup)
                TFixupDLL(wszFilename[iDll], ComCatMeta, populatedTableSchemaHeap, Screen);//The construction of this object causes the DLL to be fixed up

            {
                ULONG cBytes = ComCatMeta.GetCountDatabaseMeta() * sizeof(DatabaseMeta);         
                cBytes +=      ComCatMeta.GetCountTableMeta()    * sizeof(TableMeta);          
                cBytes +=      ComCatMeta.GetCountColumnMeta()    * sizeof(ColumnMeta);
                cBytes +=      ComCatMeta.GetCountTagMeta()    * sizeof(TagMeta);               
                cBytes +=      ComCatMeta.GetCountIndexMeta()    * sizeof(IndexMeta);              
                cBytes +=      ComCatMeta.GetCountULONG()    * sizeof(ULONG);                        
                cBytes +=      ComCatMeta.GetCountQueryMeta()    * sizeof(QueryMeta);          
                cBytes +=      ComCatMeta.GetCountRelationMeta()    * sizeof(RelationMeta);

                Screen.printf(L"Number of bytes used to store meta information = %d\n (INCLUDING wiring, NOT including Hash tables and UI4 Pool)\n", cBytes);
            }

        }

        if(dwCommandLineSwitches & eProduct)//do this last since something could have gone wrong in the Compile
        {
            TRegisterProductName(wszProduct, wszFilename[iDll], Screen);
            TRegisterMachineConfigDirectory(wszProduct, wszFilename[iConfig], Screen);//If not Config option was specified but eProduct WAS, then we'll remove the MachineConfig value
        }
    }
    catch(TException &e)
    {
//#ifdef _DEBUG
        e.Dump(Screen);
//#else
//        e.Dump(TDebugOutput());
//#endif
        if(dwCommandLineSwitches & eMetaFixup)
            Screen.printf(L"XMLUtility(0) : error : Fixup PE FAILED!\n");//This extra output message is so BUILD will report the error.
        return 1;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\filechng\filechng.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef __FILECHNG_H_
#define __FILECHNG_H_

#include "catalog.h"
#include "array_t.h"
#include "limits.h"
#include "utsem.h"

#define fST_FILESTATUS_NOCHANGE 0x00000001
#define fST_FILESTATUS_ADD		0x00000002
#define fST_FILESTATUS_UPDATE	0x00000003

#define HIGH_COOKIE	0xFFFF0000
#define LOW_COOKIE	0x0000FFFF

// Internal values for FileConsumerInfo::fFlags
#define fFCI_ADDCONSUMER		0x00010000
#define fFCI_REMOVECONSUMER		0x00020000
#define fFCI_INTERNALMASK		0xFFFF0000

// File information that is cached.
struct FileInfo
{
	LPWSTR		wszFileName;
	FILETIME	ftLastModified;
	DWORD		fStatus;
};

struct FileConsumerInfo
{
	LPWSTR		wszDirectory;
	LPWSTR		wszFile;
	DWORD		fFlags;
	ISimpleTableFileChange *pISTNotify;
	DWORD		dwCookie;
	Array<FileInfo> *paFileCache;
};

class CListener
{
	// Overhead handles.
	enum 
	{ 
		m_eDoneHandle,
		m_eConsumerChangeHandle,
		m_eOverheadHandleCount
	};

	// consts
	enum 
	{
		m_eConsumerLimit = MAXIMUM_WAIT_OBJECTS - m_eOverheadHandleCount
	};

public:
	CListener() : m_dwNextCookie(0), m_fInit(FALSE)
	{
	}

	~CListener()
	{
	}

	HRESULT Init();
	HRESULT Uninit();
	BOOL IsFull();
	HRESULT Listen();
	HRESULT AddConsumer(ISimpleTableFileChange *i_pISTFile, LPCWSTR	i_wszDirectory, LPCWSTR i_wszFile, DWORD i_fFlags, DWORD *o_pdwCookie);
	HRESULT RemoveConsumer(DWORD i_dwCookie);
	static UINT ListenerThreadStart(LPVOID lpParam);

private:
	void UninitConsumer(FileConsumerInfo *i_pConsumerInfo);
	HRESULT UpdateFileCache(LPCWSTR i_wszDirectory,	ULONG i_iConsumer, BOOL i_bCreate);
	HRESULT AddFile(Array<FileInfo>& i_aFileCache, LPCWSTR i_wszDirectory, WIN32_FIND_DATA *i_pFindFileData, BOOL i_bCreate);
	HRESULT UpdateFile(Array<FileInfo>& i_aFileCache, LPCWSTR i_wszDirectory, WIN32_FIND_DATA *i_pFindFileData);
	HRESULT FireEvents(Array<FileInfo>& i_aFileCache, ISimpleTableFileChange* pISTNotify);

	DWORD GetNextCookie()
	{
		ASSERT(m_dwNextCookie < USHRT_MAX);
		return ++m_dwNextCookie;
	}

	DWORD					m_fInit;
	DWORD					m_dwNextCookie;

	// The following members can be manipulated by multiple threads.
	CSemExclusive			m_seArrayLock;
	Array<HANDLE>			m_aHandles;
	Array<FileConsumerInfo>	m_aConsumers;
};


struct ListenerInfo
{
	DWORD					dwListenerID;
	CListener				*pListener;
};

class CSTFileChangeManager 
{
public:
	CSTFileChangeManager() : m_dwNextCookie(0)
	{}

	~CSTFileChangeManager()
	{}

	HRESULT Init()
	{
		return E_NOTIMPL;
	}

// ISimpleTableListen
public:
	HRESULT InternalListen(ISimpleTableFileChange *i_pISTFile, LPCWSTR i_wszDirectory, LPCWSTR i_wszFile, DWORD i_fFlags, DWORD	*o_pdwCookie);
	HRESULT InternalUnlisten(DWORD i_dwCookie);

private:
	HRESULT AddListener(CListener *i_pListener, DWORD *o_pdwCookie);
	DWORD GetNextCookie()
	{
		ASSERT(m_dwNextCookie < USHRT_MAX);
		return ++m_dwNextCookie;
	}

	DWORD				m_dwNextCookie;
	Array<ListenerInfo>	m_aListenerMap;
};


#endif //__FILECHNG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\output.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __OUTPUT_H__
#define __OUTPUT_H__

//  TOutput - Abstract base class that provides a printf function
//            Derived classes could send the printf data anywhere.
class TOutput
{
public:
    TOutput(){}
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const = 0;
};

// TNullOutput - TOutput implementation that sends the output nowhere

class TNullOutput: public TOutput
{
public:
    TNullOutput(){}
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const 
    {
        // do nothing
    }
};



// TScreenOutput - TOutput implementation that sends the output
//                 to the screen.
class TScreenOutput : public TOutput
{
public:
    TScreenOutput(){}
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const
    {
	    va_list args;
	    va_start(args, szFormat);

	    _vtprintf(szFormat, args);

	    va_end(args);
    }
};


// TDebugOutput - TOutput implementation that sends the output
//                 to the debug monitor.
class TDebugOutput : public TOutput
{
public:
    TDebugOutput(){}
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const
    {
	    va_list args;
	    va_start(args, szFormat);

	    TCHAR szBuffer[512];
	    _vstprintf(szBuffer, szFormat, args);
	    
	    OutputDebugString(szBuffer);
	    va_end(args);
    }
};


// TExceptionOutput - TOutput implementation that keeps the output internally for use by an exception handler
class TExceptionOutput : public TOutput
{
public:
    TExceptionOutput()
    {
        m_szBuffer[0] = NULL;
    }
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const
    {
	    va_list args;
	    va_start(args, szFormat);

        _vstprintf(const_cast<TCHAR *>(m_szBuffer), szFormat, args);

        va_end(args);
    }
    TCHAR * GetString (void)
    {
        return m_szBuffer;
    }
private:
	TCHAR m_szBuffer[512];
};


#endif // __OUTPUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\mbschemacompilation.cpp ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        MBSchemaCompilation.cpp
// Author:          Stephenr
// Date Created:    10/16/2000
// Description:     This function takes an MBSchema.Xml (or MBExtensionsSchema.Xml) and merges the Metabase Schema with
//                  the shipped schema and generates a MBSchema.bin file.  From that new bin file, a merged MBSchema.Xml
//                  is generated.
//

#ifndef __XMLUTILITY_H__
    #include "XMLUtility.h"
#endif
#ifndef __catalog_h__
    #include "Catalog.h"
#endif
#ifndef __MBSCHEMACOMPILATION_H__
    #include "MBSchemaCompilation.h"
#endif

#include "svcmsg.h"

#define LOG_ERROR0(x)                     {LOG_ERROR(Interceptor, (0, 0, E_ST_COMPILEFAILED,           ID_CAT_CONFIG_SCHEMA_COMPILE, x,                 L"",  L"",  L"",  L"" ))   ;}
#define LOG_ERROR_WIN32(win32err, call)   {LOG_ERROR(Interceptor, (0, 0, HRESULT_FROM_WIN32(win32err), ID_CAT_CONFIG_SCHEMA_COMPILE, IDS_COMCAT_WIN32, call,  L"",  L"",  L"" ))   ;}


//////////////////////////////////////
//                                  //
//        Public Methods            //
//                                  //
//////////////////////////////////////
#define kwszBinFileNameCore           (L"MBSchema.bin.\0\0")             //L"MBSchema.bin."  just requires a version to be added
#define kwszBinFileNameSearchString   (L"MBSchema.bin.????????h\0")      //L"MBSchema.bin.????????h" this is used in FindFirstFile
#define kwszFormatString              (L"MBSchema.bin.%08xh\0")    
#define kwszFormatStringFull          (L"%sMBSchema.bin.%08xh")    



TMBSchemaCompilation::TMBSchemaCompilation() :
             m_cchFullyQualifiedBinFileName (0)
            ,m_lBinFileVersion              (-1)
{
}


TMBSchemaCompilation::~TMBSchemaCompilation()
{
}


//This is the heart of the class - its whole purpose in life is to take an Extensions XML file (which contains Metabase Schema, usually just
//the user-defined properties, thus the name Extensions XML) and the DLL and produce a FixedTableHeap which contains a merge of the meta
//in both.  A Bin file is generated (we name it, the user supplies the path).  And an composite XML Schema file is generated (file name
//is supplied by the user).
//After the user calls Compile, they will need to GetBinFileName - I didn't want to add more params and make this function do double duty.
HRESULT
TMBSchemaCompilation::Compile
(
    ISimpleTableDispenser2 *    i_pISTDispenser,
    LPCWSTR                     i_wszExtensionsXmlFile,
    LPCWSTR                     i_wszSchemaXmlFile,
    const FixedTableHeap *      i_pFixedTableHeap
)
{
    HRESULT hr;

    ASSERT(0 != i_pISTDispenser);
    //ASSERT(0 != i_wszExtensionsXmlFile);This is allowed to be NULL
    ASSERT(0 != i_wszSchemaXmlFile);
    ASSERT(0 != i_pFixedTableHeap);
    ASSERT(i_pFixedTableHeap->IsValid());
    if( 0 == i_pISTDispenser        ||
        0 == i_wszSchemaXmlFile     ||
        0 == i_pFixedTableHeap      ||
        !i_pFixedTableHeap->IsValid())
        return E_INVALIDARG;

    ASSERT(0 != m_saBinPath.m_p && "The Schema BinPath must be set before calling Compile");
    if(0 == m_saBinPath.m_p)
        return E_ST_INVALIDSTATE;

    #ifdef _DEBUG
    TDebugOutput out;
    #else
    TNullOutput  out;
    #endif

    try
    {
        DWORD dwStartingTickCount = GetTickCount();

        TMetabaseMetaXmlFile mbmeta(i_pFixedTableHeap, i_wszExtensionsXmlFile, i_pISTDispenser, out);
        mbmeta.Dump(out);//Dump the tables before they're inferred

        out.printf(L"TMetaInferrence().Compile(mbmeta, out);\r\n");
        TMetaInferrence().Compile(mbmeta, out);
        mbmeta.Dump(out);//Dump the tables after the inferrence

        out.printf(L"THashedPKIndexes().Compile(mbmeta, out);\r\n");
        THashedPKIndexes hashedPKIndexes;
        hashedPKIndexes.Compile(mbmeta, out);

        out.printf(L"THashedUniqueIndexes().Compile(mbmeta, out);\r\n");
        THashedUniqueIndexes hashedUniqueIndexes;
        hashedUniqueIndexes.Compile(mbmeta, out);

        mbmeta.Dump(out);//Dump the tables after the inferrence

        SIZE_T cchXmlFile = wcslen(i_wszSchemaXmlFile);

        //Allocate enough space to hold the temp filenames
        TSmartPointerArray<WCHAR> saBinFileNew  = new WCHAR[m_cchFullyQualifiedBinFileName];
        TSmartPointerArray<WCHAR> saBinFileTmp  = new WCHAR[m_cchFullyQualifiedBinFileName];
        TSmartPointerArray<WCHAR> saXmlFileTmp  = new WCHAR[cchXmlFile + 5];//enough room to tack on ".tmp\0"

        if(0 == saBinFileNew.m_p || 0 == saBinFileTmp.m_p || 0 == saXmlFileTmp.m_p)
            return E_OUTOFMEMORY;//if any of the allocs fail then return error

        //Now build the New Bin filename
        LONG lNewBinVersion=0;
        InterlockedExchange(&lNewBinVersion, m_lBinFileVersion+1);//if no bin file exists, m_lBinFileVersion is -1
        wsprintf(saBinFileNew, kwszFormatStringFull, m_saBinPath, lNewBinVersion);

        //build the temp bin filename
        wcscpy(saBinFileTmp, m_saBinPath);
        wcscat(saBinFileTmp, kwszBinFileNameCore);
        wcscat(saBinFileTmp, L"tmp");

        //Xml tmp file is the filename passed in with ".tmp" tacked onto the end 
        memcpy(saXmlFileTmp.m_p,   i_wszSchemaXmlFile, cchXmlFile * sizeof(WCHAR));
        memcpy(saXmlFileTmp.m_p  + cchXmlFile, L".tmp\0", 5 * sizeof(WCHAR));


        TWriteSchemaBin(saBinFileTmp).Compile(mbmeta, out);
        TMBSchemaGeneration(saXmlFileTmp).Compile(mbmeta, out);

        MoveFileEx(saBinFileTmp, saBinFileNew, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED);
        if(0 == MoveFileEx(saXmlFileTmp, i_wszSchemaXmlFile, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
        {
            hr = GetLastError();

            static const WCHAR wszMoveFileEx[] = L"MoveFileEx to ";
            static const ULONG cchMoveFileEx   = (ULONG)sizeof(wszMoveFileEx)/sizeof(WCHAR) - 1;
            TSmartPointerArray<WCHAR> saCall   = new WCHAR[cchMoveFileEx + cchXmlFile + 1];
            if(0 != saCall.m_p)
            {
                wcscpy(saCall, wszMoveFileEx);
                wcscat(saCall, i_wszSchemaXmlFile);
                LOG_ERROR_WIN32(hr, saCall);
            }
            else
            {
                LOG_ERROR_WIN32(hr, L"MoveFileEx");
            }

            hr = HRESULT_FROM_WIN32(hr);
            DBGERROR((DBG_CONTEXT, "Could not move to %ws, hr=0x%x\n", i_wszSchemaXmlFile, hr));
            return hr;
        }

        if(FAILED(hr = SetBinFileVersion(lNewBinVersion)))//now lock the new file into memory and start using it
            return hr;//inside SetBinFileName we will delete the file if it fails to load correctly

        out.printf(L"\r\n%s file generated\n", saBinFileNew);
        out.printf(L"\r\n%s file generated\n", i_wszSchemaXmlFile);

        DWORD dwEndingTickCount = GetTickCount();
        out.printf(L"HeapColumnMeta       %8d bytes\n", mbmeta.GetCountColumnMeta()          * sizeof(ColumnMeta)        );
        out.printf(L"HeapDatabaseMeta     %8d bytes\n", mbmeta.GetCountDatabaseMeta()        * sizeof(DatabaseMeta)      );
        out.printf(L"HeapHashedIndex      %8d bytes\n", mbmeta.GetCountHashedIndex()         * sizeof(HashedIndex)       );
        out.printf(L"HeapIndexMeta        %8d bytes\n", mbmeta.GetCountIndexMeta()           * sizeof(IndexMeta)         );
        out.printf(L"HeapQueryMeta        %8d bytes\n", mbmeta.GetCountQueryMeta()           * sizeof(QueryMeta)         );
        out.printf(L"HeapRelationMeta     %8d bytes\n", mbmeta.GetCountRelationMeta()        * sizeof(RelationMeta)      );
        out.printf(L"HeapServerWiringMeta %8d bytes\n", mbmeta.GetCountServerWiringMeta()    * sizeof(ServerWiringMeta)  );
        out.printf(L"HeapTableMeta        %8d bytes\n", mbmeta.GetCountTableMeta()           * sizeof(TableMeta)         );
        out.printf(L"HeapTagMeta          %8d bytes\n", mbmeta.GetCountTagMeta()             * sizeof(TagMeta)           );
        out.printf(L"HeapULONG            %8d bytes\n", mbmeta.GetCountULONG()               * sizeof(ULONG)             );
        out.printf(L"HeapPooled           %8d bytes\n", mbmeta.GetCountOfBytesPooledData()                               );
        out.printf(L"Total time to build the %s file: %d milliseconds\n", i_wszSchemaXmlFile, dwEndingTickCount - dwStartingTickCount);
    }
    catch(TException &e)
    {
        e.Dump(out);
        return E_ST_COMPILEFAILED;
    }
    return S_OK;
}

extern HINSTANCE g_hModule;

//This function returns the BinFileName to be used for getting all of the IST meta tables used by the Metabase.
//This file name changes as new versions get compiled; but this abstraction guarentees that the filename returned
//exists AND is lock into memory and thus cannot be deleted by some other process or thread.  It isn't released
//until another file has been compiled and locked into memory, OR when the process shuts down.
HRESULT
TMBSchemaCompilation::GetBinFileName
(
    LPWSTR      o_wszBinFileName,           //Buffer to receive the BinFileName
    ULONG *     io_pcchSizeBinFileName      //This is a SIZE param so it always INCLUDE the NULL - unlike wcslen
)
{
    //It's OK for o_wszBinFileName to be NULL - this is how the user finds out the size of the buffer needed.
    ASSERT(io_pcchSizeBinFileName != 0);

    //Before the user can get the BinFileName they must first have set the path
    if(0 == m_saBinPath.m_p)
    {
        WCHAR wszPath[1024];
        GetModuleFileName(g_hModule, wszPath, 1024);
        LPWSTR pBackSlash = wcsrchr(wszPath, L'\\');
        if(pBackSlash)
            *pBackSlash = 0x00;
        SetBinPath(wszPath);
    }

    if(0 != o_wszBinFileName && *io_pcchSizeBinFileName < (ULONG) m_cchFullyQualifiedBinFileName)
        return E_ST_SIZEEXCEEDED;

    LONG lBinFileVersion;
    InterlockedExchange(&lBinFileVersion, m_lBinFileVersion);
    if(0 != o_wszBinFileName)//return a copy of the filename g_wszMBSchemaBinFileName
    {
        if(lBinFileVersion != -1)
        {
            wsprintf(o_wszBinFileName, kwszFormatStringFull, m_saBinPath, lBinFileVersion);
            HRESULT hr;
            if(FAILED(hr = m_aBinFile[lBinFileVersion % 0x3F].LoadBinFile(o_wszBinFileName, lBinFileVersion)))
                return hr;
        }
        else
            o_wszBinFileName[0] = 0x00;
    }
    
    //return the wcslen+1 of g_wszMBSchemaBinFileName in *io_pcchSchemaBinFileName
    *io_pcchSizeBinFileName = (ULONG) m_cchFullyQualifiedBinFileName;//return the buffer size required
    if(0 == o_wszBinFileName)
        return S_OK;

    return (0x00 == o_wszBinFileName[0] ? S_FALSE : S_OK);
}


HRESULT
TMBSchemaCompilation::ReleaseBinFileName
(
    LPCWSTR         i_wszBinFileName
)
{
    HRESULT hr=S_OK;

    ASSERT(i_wszBinFileName);
    if(i_wszBinFileName[0] == 0x00)
        return S_OK;

    LONG lVersion;
    if(FAILED(hr = BinFileToBinVersion(lVersion, i_wszBinFileName)))
        return hr;

    ASSERT(m_aBinFile[lVersion % 0x3F].m_lBinFileVersion == lVersion && L"This is a bug, we should never have more than 64 versions of the bin file loaded at once");
    m_aBinFile[lVersion % 0x3F].UnloadBinFile();
    return S_OK;
}


//This is broken out into a separate method because on start up, we'll be called to GetBinFileName without first an MBSchemaCompilation
HRESULT
TMBSchemaCompilation::SetBinPath
(
    LPCWSTR     i_wszBinPath
)
{
    ASSERT(i_wszBinPath);
    if(0 == i_wszBinPath)
        return E_INVALIDARG;

    DWORD BinPathAttributes = GetFileAttributes(i_wszBinPath);
    if(-1 == BinPathAttributes)
        return HRESULT_FROM_WIN32(GetLastError());
    
    if(0 == (FILE_ATTRIBUTE_DIRECTORY & BinPathAttributes))
        return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);

    if(0 != m_saBinPath.m_p)
        return S_FALSE;//this is so the caller can distinguish between S_OK and S_HEY_YOU_ALREADY_SET_THE_PATH

    //we need to know this all over the place so keep track of it
    m_cchFullyQualifiedBinFileName = wcslen(i_wszBinPath);
    
    m_saBinPath = new WCHAR [m_cchFullyQualifiedBinFileName+2];//one for the terminating NULL the second in case we need to add a trailing backslash

    if(0 == m_saBinPath.m_p)
        return E_OUTOFMEMORY;

    wcscpy(m_saBinPath, i_wszBinPath);

    if(m_saBinPath[m_cchFullyQualifiedBinFileName - 1] != L'\\')//if the path doesn't end in a backslash then add one
    {
        m_saBinPath[m_cchFullyQualifiedBinFileName]     = L'\\';
        m_saBinPath[m_cchFullyQualifiedBinFileName+1]   = 0x00;
        m_cchFullyQualifiedBinFileName++;
    }

    //up to this point m_cchFullyQualifiedBinFileName has been the strlen of the path, now add in the size of the filename too
    m_cchFullyQualifiedBinFileName += wcslen(kwszBinFileNameSearchString)+1;//one for the NULL

    //Everytime the user sets the path, we need to scan the directory of the new path for the latest Bin file
    WalkTheFileSystemToFindTheLatestBinFileName();

    return S_OK;
}




//////////////////////////////////////
//                                  //
//        Private Methods           //
//                                  //
//////////////////////////////////////

static int g_aValidHexChars[256] = {
//  x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//0x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//1x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//2x
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,//3x
    0,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,//4x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//5x
    0,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,//6x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//7x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//8x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//9x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//ax
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//bx
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//cx
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//dx
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//ex
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 //fx
};



//This just takes the numeric extension and converts from hex string to a ULONG (file is assumed to be in the form L"*.*.xxxxxxxx", where L"xxxxxxxx" is a hex number)
HRESULT
TMBSchemaCompilation::BinFileToBinVersion
(
    LONG   &o_lBinVersion,
    LPCWSTR i_wszBinFileName
) const
{
    SIZE_T cchBinFileName = wcslen(i_wszBinFileName);
    if(cchBinFileName == 0)
        return E_ST_INVALIDBINFILE;
    if(cchBinFileName >= m_cchFullyQualifiedBinFileName)
        return E_ST_INVALIDBINFILE;//we must have a filename of the form MBSchema.bin.old or something

    //if the file is something like MBSchema.bin.tmp the following code will catch that
    for(SIZE_T i=cchBinFileName-9;i<cchBinFileName-1;++i)
    {
        if(0 == g_aValidHexChars[i_wszBinFileName[i]])
            return E_ST_INVALIDBINFILE;
    }

    //convert the number at the end of the string to a ULONG
    o_lBinVersion = wcstol(i_wszBinFileName + cchBinFileName - 9, 0, 16);
    return S_OK;
}

HRESULT
TMBSchemaCompilation::DeleteBinFileVersion
(
    LONG i_lBinFileVersion
)
{
    HRESULT hr = S_OK;

    TSmartPointerArray<WCHAR> saBinFileName = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saBinFileName.m_p)
        return E_OUTOFMEMORY;

    wsprintf(saBinFileName, kwszFormatStringFull, m_saBinPath, i_lBinFileVersion);
    m_aBinFile[i_lBinFileVersion % 0x3F].UnloadBinFile();
    DeleteFile(saBinFileName);

    return S_OK;
}

//This checks the validity of the FixedTableHeap mapped into memory
bool
TMBSchemaCompilation::IsValidBin
(
    TFileMapping &mapping
) const
{
    return (mapping.Size()>4096 && reinterpret_cast<const class FixedTableHeap *>(mapping.Mapping())->IsValid()) ? true : false;
}


HRESULT
TMBSchemaCompilation::RenameBinFileVersion
(
    LONG    i_lSourceVersion,
    LONG    i_lDestinationVersion
)
{
    HRESULT hr = S_OK;

    TSmartPointerArray<WCHAR> saSourceBinFileName = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saSourceBinFileName.m_p)
        return E_OUTOFMEMORY;

    wsprintf(saSourceBinFileName, kwszFormatStringFull, m_saBinPath, i_lSourceVersion);


    TSmartPointerArray<WCHAR> saDestinationBinFileName = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saDestinationBinFileName.m_p)
        return E_OUTOFMEMORY;

    wsprintf(saDestinationBinFileName, kwszFormatStringFull, m_saBinPath, i_lDestinationVersion);

    if(0 == MoveFileEx(saSourceBinFileName, saDestinationBinFileName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
        return E_FAIL;
    return S_OK;
}


//This sets the BinFileName in a thread safe fashion
HRESULT
TMBSchemaCompilation::SetBinFileVersion
(
    LONG    i_lBinFileVersion
)
{
    HRESULT hr = S_OK;

    TSmartPointerArray<WCHAR> saBinFileName = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saBinFileName.m_p)
        return E_OUTOFMEMORY;

    wsprintf(saBinFileName, kwszFormatStringFull, m_saBinPath, i_lBinFileVersion);

    //This will either load the file OR if already loaded, it will bump the ref count
    if(FAILED(hr = m_aBinFile[i_lBinFileVersion % 0x3F].LoadBinFile(saBinFileName, i_lBinFileVersion)))
    {   //if that fails then delete the file and FAIL
        DeleteFile(saBinFileName);
        return hr;
    }

    //verify that the file is in fact a valid SchemaBin file
    if(false == IsValidBin(m_aBinFile[i_lBinFileVersion % 0x3F]))
    {   //if that fails then delete the file and FAIL
        DeleteBinFileVersion(i_lBinFileVersion);
        return E_ST_INVALIDBINFILE;
    }

    LONG lPrevBinFileVersion = m_lBinFileVersion;
    InterlockedExchange(&m_lBinFileVersion, i_lBinFileVersion);
    DeleteBinFileVersion(lPrevBinFileVersion);
    if(lPrevBinFileVersion>0)
        DeleteBinFileVersion(lPrevBinFileVersion-1);

    return hr;
}


HRESULT
TMBSchemaCompilation::WalkTheFileSystemToFindTheLatestBinFileName()
{
    //Before the user can get the BinFileName they must first have set the path
    ASSERT(0 != m_saBinPath.m_p);

    HANDLE  hFindFile = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;

    //we need to scan the directory for
    //files of the form MBSchema.bin.????????.  The file whose ? translates to 
    //the largest number represents our MBSchema.bin.  Note: It would take 136 years
    //without a restart for this to roll over - assuming a compile every second.  This
    //is a safe assumption since the compilation process itself currently takes
    //about 2 seconds (on a 900 MHz machine).

    //Build the search string L"d:\Bin-Path\MBSchema.bin.????????h"
    TSmartPointerArray<WCHAR> saSearchString = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saSearchString.m_p)
        return E_OUTOFMEMORY;
    wcscpy(saSearchString, m_saBinPath);
    wcscat(saSearchString, kwszBinFileNameSearchString);

    WIN32_FIND_DATA FindFileData;
    hFindFile = FindFirstFile(saSearchString, &FindFileData);
    if(INVALID_HANDLE_VALUE == hFindFile)
    {   //it's perfectly valid to find NO matching files - in this case we return L"" with a size of 0
        FindClose(hFindFile);
        return S_OK;
    }

    LONG lMostCurrentBinVersion = -1;
    BinFileToBinVersion(lMostCurrentBinVersion, FindFileData.cFileName);

    //Now try to find the first matching file which ALSO has a valid version number.
    while(-1 == lMostCurrentBinVersion)
    {
        if(!FindNextFile(hFindFile, &FindFileData))//if we walk the list finding bogus matches then bail
        {
            FindClose(hFindFile);
            return S_OK;
        }
        BinFileToBinVersion(lMostCurrentBinVersion, FindFileData.cFileName);
    }

    BOOL bAllDeletesSucceeded;//if any DeleteFile fails then we DON'T rename the most current BinFile to MBSChema.bin.00000000
    bAllDeletesSucceeded=true;

    //Now try to find the MOST CUREENT bin file
    while(FindNextFile(hFindFile, &FindFileData))
    {
        LONG lBinVersion;
        if(FAILED(BinFileToBinVersion(lBinVersion, FindFileData.cFileName)))
            continue;
        if(lBinVersion > lMostCurrentBinVersion)
        {
            //delete the PrevBinVersion and make lBinVersion the previous one
            if(0 == DeleteBinFileVersion(lMostCurrentBinVersion))
                bAllDeletesSucceeded= false;

            //and make this one the most current bin file
            lMostCurrentBinVersion = lBinVersion;
        }
        else
        {
            if(0 == DeleteFile(FindFileData.cFileName))
                bAllDeletesSucceeded = false;
        }
    }
    FindClose(hFindFile);

    //At this point we have attempted to delete all but the MostCurrentBinFile
    if(bAllDeletesSucceeded)
    {//if all deletes succeeded, we can rename the most wszMostCurrentBinFileName to L"MBSchema.bin.00000000"
        if(lMostCurrentBinVersion!=0)
        {
            if(SUCCEEDED(RenameBinFileVersion(lMostCurrentBinVersion, 0/*destination version 0*/)))
                lMostCurrentBinVersion = 0;
        }
    }
    
    return SetBinFileVersion(lMostCurrentBinVersion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\filechng\filechng.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// =======================================================================
#include "FileChng.h"
#include "catmacros.h"
#include "catmeta.h"
#include <process.h>

UINT CListener::ListenerThreadStart(LPVOID	lpParam)
{
	CListener	*pListener = (CListener*)lpParam;
	HRESULT		hr = S_OK;

	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		TRACE(L"[CSTFileChangeManager::ListenerThreadStart] Call to CoInitializeEx failed with hr = %08x\n", hr);
		goto Cleanup;
	}

	ASSERT(pListener);
	hr = pListener->Listen();
	if (FAILED(hr))
	{
		TRACE(L"[CSTFileChangeManager::ListenerThreadStart] Call to CSTFileChangeManager::Listen failed with hr = %08x\n", hr);
	}

	// When Listen() is done, the file notify manager should have removed 
	// this object from his list.

Cleanup:

	delete pListener;

	CoUninitialize();
	return hr;
}

// =======================================================================
// ISimpleTableListen
// =======================================================================
HRESULT CSTFileChangeManager::InternalListen(
	ISimpleTableFileChange	*i_pISTFile,
	LPCWSTR		i_wszDirectory,
	LPCWSTR		i_wszFile,
	DWORD		i_fFlags,
	DWORD		*o_pdwCookie)
{
	CListener	*pListener = NULL;
	UINT		dwThreadID;
	DWORD		dwHighCookie = 0; 
	HANDLE		hThread = NULL;
	HRESULT		hr = S_OK;
	ULONG		iListener = 0;

	// Argument validation.
	if (!i_pISTFile || !i_wszDirectory || !o_pdwCookie)
	{
		return E_INVALIDARG;
	}

	// @TODO: do we need more validation. Does directory exist? Are flags valid?

	// Init out param.
	*o_pdwCookie = 0;

	// Search for a listener to handle the request.
	if (m_aListenerMap.size() > 0)
	{
		for (iListener = m_aListenerMap.size(); iListener > 0; iListener--)
		{
			if (m_aListenerMap[iListener-1].pListener->IsFull() != TRUE)
			{
				pListener = m_aListenerMap[iListener-1].pListener;
				dwHighCookie = m_aListenerMap[iListener-1].dwListenerID;
				break;
			}
		}
	}

	// If no listener is found:
	if (pListener == NULL)
	{
		// Create a new listener object.
		pListener = new CListener;
		if (pListener == NULL)
		{
			return E_OUTOFMEMORY;
		}

		hr = pListener->Init();
		if (FAILED(hr)) goto Cleanup;

		// Start a thread for this consumer.
		hThread = (HANDLE) _beginthreadex(NULL, 0, CListener::ListenerThreadStart, (LPVOID)pListener, 0, &dwThreadID);
		if (hThread == NULL)
		{
			hr = HRESULT_FROM_WIN32(GetLastError()); 
			goto Cleanup;
		}

		// Add listener to listener list.
		hr = AddListener(pListener, &dwHighCookie);
		if (FAILED(hr)) goto Cleanup;
	}

	// Initialize it with user provided data.
	hr = pListener->AddConsumer(i_pISTFile, i_wszDirectory, i_wszFile, i_fFlags, o_pdwCookie);
	if (FAILED(hr)) goto Cleanup;

	*o_pdwCookie = *o_pdwCookie | (dwHighCookie << 16);
Cleanup:
	if (FAILED(hr))
	{
		if (pListener)
		{
			delete pListener;
		}
		InternalUnlisten(*o_pdwCookie);
	}
	// @TODO: Do I need to keep the handle around?
	if (hThread != NULL)
	{
		CloseHandle(hThread);
	}

	return hr;
}

// =======================================================================
HRESULT CSTFileChangeManager::InternalUnlisten(
	DWORD		i_dwCookie)
{
	ULONG		iListener;
	HRESULT		hr = S_OK;

	// Find the consumer in the consumer list.
	for (iListener = 0; iListener < m_aListenerMap.size(); iListener++)
	{
		if (m_aListenerMap[iListener].dwListenerID == ((i_dwCookie & HIGH_COOKIE)>>16))
			break;
	}
	// If not found, the cookie was not valid.
	if (iListener == m_aListenerMap.size())
		return E_INVALIDARG;

	// Signal the done event.
	ASSERT(m_aListenerMap[iListener].pListener != NULL);
	hr = m_aListenerMap[iListener].pListener->RemoveConsumer(i_dwCookie);

	// If the listener doesn't have anything to listen do delete it.
	if (hr == S_FALSE)
	{
		m_aListenerMap.deleteAt(iListener); 
	}
	return S_OK;
}

// =======================================================================
HRESULT CSTFileChangeManager::AddListener(
	CListener	*i_pListener, 
	DWORD		*o_pdwCookie)
{
	ListenerInfo *pListener = NULL;
	ULONG		i;
	HRESULT		hr = S_OK;

	ASSERT(i_pListener && o_pdwCookie);

	// Add a new consumer.
	try
	{
		m_aListenerMap.setSize(m_aListenerMap.size()+1);
	}
	catch(HRESULT e)
	{
		// @TODO: Stop the listener thread.
		ASSERT(E_OUTOFMEMORY == e);
		return e;//Array should only throw E_OUTOFMEMORY;
	}

	pListener = &m_aListenerMap[m_aListenerMap.size()-1];
	pListener->pListener = i_pListener;
	pListener->dwListenerID = GetNextCookie();
	*o_pdwCookie = pListener->dwListenerID;
	return S_OK;
}

// =======================================================================
//	CListener
// =======================================================================

// If Init() fails the caller should delete the listener object.
// Not called by multiple threads.
// =======================================================================
HRESULT CListener::Init() 
{
	ULONG		i = 0;
	
	// Synchronize access to the consumer and handle array.
	CLock	cLock(m_seArrayLock);

	// Alocate room for two handles.
	try
	{
		m_aHandles.setSize(m_aHandles.size() + m_eOverheadHandleCount);
	}
	catch(HRESULT e)
	{
		ASSERT(E_OUTOFMEMORY == e);
		return e;//Array should only throw E_OUTOFMEMORY;
	}

	// Create the Done and ConsumerUpdate events.
	for (i = 0; i < m_eOverheadHandleCount; i++)
	{
		m_aHandles[i] = CreateEvent(NULL,	// Use default security settings.
									FALSE,	// Auto-reset.
									FALSE,	// Initially nonsignaled.
									NULL);  // With no name.
		if (m_aHandles[i] == NULL) 
		{ 
			return HRESULT_FROM_WIN32(GetLastError()); 
		}
	}

	return S_OK;
}

// Can this listener serve another consumer. The maximum number of consumers
// a listener can serve is CONSUMER_LIMIT, which has to be less than
// MAXIMUM_WAIT_OBJECTS -  (the limit on WaitForMultiple objects)
// Not called by multiple threads.
// =======================================================================
BOOL CListener::IsFull() 
{
	// Synchronize access to the consumer and handle array.
	CLock	cLock(m_seArrayLock);

	return ((m_dwNextCookie > USHRT_MAX) || m_aConsumers.size() == m_eConsumerLimit);
}

// Not called by multiple threads.
// =======================================================================
HRESULT CListener::AddConsumer(
	ISimpleTableFileChange *i_pISTFile, 
	LPCWSTR		i_wszDirectory, 
	LPCWSTR		i_wszFile, 
	DWORD		i_fFlags,
	DWORD*		o_pdwCookie) 
{
	FileConsumerInfo *pConsumerInfo = NULL;
	BOOL		bAppendBackslash = FALSE;
	HRESULT		hr = S_OK;

	ASSERT(i_pISTFile && i_wszDirectory && o_pdwCookie);

	// Synchronize access to the consumer and handle array.
	CLock	cLock(m_seArrayLock);

	// Allocate room for a new consumer.
	try
	{
		m_aConsumers.setSize(m_aConsumers.size()+1);
	}
	catch(HRESULT e)
	{
		ASSERT(E_OUTOFMEMORY == e);
		return e;//Array should only throw E_OUTOFMEMORY;
	}

	pConsumerInfo = &m_aConsumers[m_aConsumers.size()-1];
	ZeroMemory(pConsumerInfo, sizeof(FileConsumerInfo));

	// Init the consumer.
	hr = i_pISTFile->QueryInterface(IID_ISimpleTableFileChange, (LPVOID*)&pConsumerInfo->pISTNotify);
	if(FAILED(hr)) {	goto Cleanup;	}

	// Directory name must contain a backslash at the end.
	if (i_wszDirectory[wcslen(i_wszDirectory)-1] != L'\\')
		bAppendBackslash = TRUE;
	pConsumerInfo->wszDirectory = new WCHAR[wcslen(i_wszDirectory) + (bAppendBackslash ? 2 : 1)];
	if (pConsumerInfo->wszDirectory == NULL)  {	hr = E_OUTOFMEMORY; goto Cleanup; }

	wcscpy(pConsumerInfo->wszDirectory, i_wszDirectory);
	if (bAppendBackslash)
	{
		wcscat(pConsumerInfo->wszDirectory, L"\\");
	}

	if (i_wszFile != NULL)
	{
		pConsumerInfo->wszFile = new WCHAR[wcslen(i_wszFile) + 1];
		if (pConsumerInfo->wszFile == NULL)  {	hr = E_OUTOFMEMORY; goto Cleanup; }
		wcscpy(pConsumerInfo->wszFile, i_wszFile);
	}

	// Create the file cache.
	pConsumerInfo->paFileCache = new Array<FileInfo>;
	if (pConsumerInfo->paFileCache == NULL)   {	hr = E_OUTOFMEMORY; goto Cleanup; }

	pConsumerInfo->fFlags = i_fFlags | fFCI_ADDCONSUMER;

	// Notify the listener thread to pick up this new consumer.
	if (SetEvent(m_aHandles[m_eConsumerChangeHandle]) == FALSE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Cleanup;
	}

	// Set the lower 2-bytes of the cookie.
	*o_pdwCookie = GetNextCookie();
Cleanup:
	if (FAILED(hr))
	{
		ASSERT(pConsumerInfo && (pConsumerInfo == &m_aConsumers[m_aConsumers.size()-1]));
		UninitConsumer(pConsumerInfo);
		m_aConsumers.deleteAt(m_aConsumers.size()-1);
	}
	return hr;
}

// Not called by multiple threads.
// =======================================================================
HRESULT CListener::RemoveConsumer(
	DWORD		i_dwCookie) 
{
	FileConsumerInfo *pConsumerInfo = NULL;
	ULONG		iConsumer;

	// Synchronize access to the consumer and handle array.
	CLock	cLock(m_seArrayLock);

	// Find the consumer in the consumer list.
	for (iConsumer = 0; iConsumer < m_aConsumers.size(); iConsumer++)
	{
		if (m_aConsumers[iConsumer ].dwCookie == (i_dwCookie & LOW_COOKIE))
			break;
	}
	// If not found, the cookie was not valid.
	if (iConsumer  == m_aConsumers.size())
		return E_INVALIDARG;

	pConsumerInfo = &m_aConsumers[iConsumer];

	pConsumerInfo->fFlags |= fFCI_REMOVECONSUMER;

	// Notify the listener thread to pick up this new consumer.
	if (SetEvent(m_aHandles[m_eConsumerChangeHandle]) == FALSE)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

// =======================================================================
void CListener::UninitConsumer(
	FileConsumerInfo *i_pConsumerInfo) 
{
	if (i_pConsumerInfo->wszDirectory)
	{
		delete [] i_pConsumerInfo->wszDirectory;
	}

	if (i_pConsumerInfo->wszFile)
	{
		delete [] i_pConsumerInfo->wszFile;
	}

	if (i_pConsumerInfo->pISTNotify)
	{
		i_pConsumerInfo->pISTNotify->Release();
	}

	if (i_pConsumerInfo->paFileCache)
	{
		delete i_pConsumerInfo->paFileCache;
	}
}

// =======================================================================
HRESULT CListener::Listen()
{
	DWORD		dwWait;
	DWORD		dwError;
	BOOL		fDone = FALSE;
	ULONG		iChangedDirectory = 0;
	ULONG		iConsumer = 0;
	HRESULT		hr = S_OK;

	while (!fDone)
	{
		// Sleep until a file change happens or the consumer is done.
		dwWait = WaitForMultipleObjects(m_aHandles.size(), &m_aHandles[0], FALSE, 0xFFFFFFFF);
		// @TODO: think about timeout.
		// If consumer is done, leave.
		if (dwWait == WAIT_OBJECT_0 + m_eDoneHandle)
		{
			fDone = TRUE;
		}
		// A consumer has been added or removed.
		else if (dwWait == WAIT_OBJECT_0 + m_eConsumerChangeHandle)
		{
			// Synchronize access to the consumer and handle array.
			CLock	cLock(m_seArrayLock);

			// Iterate through consumers to find the added/removed ones.
			for (iConsumer = 0; iConsumer < m_aConsumers.size(); iConsumer++)
			{
				// If consumer has been added:
				if (m_aConsumers[iConsumer].fFlags & fFCI_ADDCONSUMER)
				{
					// Allocate room for a new handle.
					try
					{
						m_aHandles.setSize(m_aHandles.size()+1);
					}
					catch(HRESULT e)
					{
						ASSERT(E_OUTOFMEMORY == e);
						hr = e;//Array should only throw E_OUTOFMEMORY;
						goto Cleanup;
					}

					// Init file change notification.
					m_aHandles[m_aHandles.size()-1] = FindFirstChangeNotificationW(m_aConsumers[iConsumer].wszDirectory, 
								m_aConsumers[iConsumer].fFlags & fST_FILECHANGE_RECURSIVE, 
								FILE_NOTIFY_CHANGE_FILE_NAME|FILE_NOTIFY_CHANGE_LAST_WRITE);
					if (m_aHandles[m_aHandles.size()-1] == INVALID_HANDLE_VALUE)
					{
						hr = HRESULT_FROM_WIN32(GetLastError());
						goto Cleanup;
					}

					// Add files to the file cache.
					hr = UpdateFileCache(m_aConsumers[iConsumer].wszDirectory, iConsumer, TRUE);
					if (FAILED(hr))	{ goto Cleanup;	}

					// Clear the internal flags.
					m_aConsumers[iConsumer].fFlags &= ~fFCI_INTERNALMASK;
				}
				// If consumer has been removed:
				else if (m_aConsumers[iConsumer].fFlags & fFCI_REMOVECONSUMER)
				{
					// Remove the files from the file cache.
					hr = UpdateFileCache(m_aConsumers[iConsumer].wszDirectory, iConsumer, TRUE);
					if (FAILED(hr))	{ goto Cleanup;	}

					// Delete the handle and consumer info.
					ASSERT(m_aHandles[iConsumer] != INVALID_HANDLE_VALUE);
					FindCloseChangeNotification(m_aHandles[iConsumer]);
					m_aHandles.deleteAt(iConsumer);
					UninitConsumer(&m_aConsumers[iConsumer]);
					m_aConsumers.deleteAt(iConsumer);

					// Readjust the loop variable.
					iConsumer--;
				}
				
			}
		}
		else if (dwWait > WAIT_OBJECT_0 + m_eConsumerChangeHandle && dwWait < WAIT_OBJECT_0 + m_eOverheadHandleCount + m_aHandles.size())
		{
			// Synchronize access to the consumer and handle array.
			CLock	cLock(m_seArrayLock);

			ASSERT(dwWait < WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS);

			iChangedDirectory = dwWait - m_eOverheadHandleCount;

			// Update the file cache and inform the consumer.
			hr = UpdateFileCache(m_aConsumers[iChangedDirectory].wszDirectory, iChangedDirectory, FALSE);
			if (FAILED(hr))	{ goto Cleanup;	}

			hr = FireEvents(*m_aConsumers[iChangedDirectory].paFileCache, m_aConsumers[iChangedDirectory].pISTNotify);
			if (FAILED(hr)) { goto Cleanup; }

			// Wait for next change.
			if (FindNextChangeNotification(m_aHandles[dwWait]) == FALSE)
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				goto Cleanup;
			}
		}
		else
		{
			ASSERT(dwWait == WAIT_FAILED);
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Cleanup;
		}
	}
	// The consumer is done.
Cleanup:

	return hr;
}

// This method is called 
// 1 - when a consumer wants to listen to a new directory
// 2 - when a change occured in one of the listened directories.
// =======================================================================
HRESULT CListener::UpdateFileCache(
	LPCWSTR		i_wszDirectory,
	ULONG		i_iConsumer,
	BOOL		i_bCreate)
{
	WIN32_FIND_DATA FindFileData;
	HANDLE		hFind;
	BOOL		bNext = TRUE;
	WCHAR		awchFileSearch[_MAX_PATH];
	WCHAR		awchNextDir[_MAX_PATH];
	HRESULT		hr = S_OK;

	// @TODO: ASSERT directory name ends with \.
	// @TODO: Handle overflow case.
	wcsncpy(awchFileSearch, i_wszDirectory, _MAX_PATH);
	wcscat(awchFileSearch, L"*.*");

	hFind = FindFirstFile(awchFileSearch, &FindFileData);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Cleanup;
	}

	do
	{
		if ((m_aConsumers[i_iConsumer].fFlags & fST_FILECHANGE_RECURSIVE) && (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			&& wcscmp(FindFileData.cFileName, L".") && wcscmp(FindFileData.cFileName, L".."))
		{
			wcsncpy(awchNextDir, i_wszDirectory, _MAX_PATH);
			wcscat(awchNextDir, FindFileData.cFileName);
			wcscat(awchNextDir, L"\\");
			hr = UpdateFileCache(awchNextDir, i_iConsumer, i_bCreate);
		}
		// Deal only with files of interest to us.
		// @TODO: The filenames need to be provided via Advise.
		else if (!Wszlstrcmpi(FindFileData.cFileName, m_aConsumers[i_iConsumer].wszFile))
		{
			if (i_bCreate)
			{
				hr = AddFile(*m_aConsumers[i_iConsumer].paFileCache, i_wszDirectory, &FindFileData, i_bCreate);
			}
			else
			{
				hr = UpdateFile(*m_aConsumers[i_iConsumer].paFileCache, i_wszDirectory, &FindFileData);
			}
		}
		if (FAILED(hr)) { goto Cleanup; }
	
	} while ((bNext = FindNextFile(hFind, &FindFileData)) == TRUE);

	if ((hr = HRESULT_FROM_WIN32(GetLastError())) != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
		goto Cleanup;
	else
		hr = S_OK;

Cleanup:
	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);
	return hr;
}

// =======================================================================
HRESULT CListener::AddFile(	
	Array<FileInfo>& i_aFileCache,
	LPCWSTR		i_wszDirectory,
	WIN32_FIND_DATA *i_pFindFileData,
	BOOL		i_bCreate)
{
	FileInfo	*pFileInfo;

	ASSERT(i_pFindFileData && i_wszDirectory);

	// Add a new consumer.
	try
	{
		i_aFileCache.setSize(i_aFileCache.size()+1);
	}
	catch(HRESULT e)
	{
		ASSERT(E_OUTOFMEMORY == e);
		return e;//Array should only throw E_OUTOFMEMORY;
	}

	pFileInfo = &i_aFileCache[i_aFileCache.size()-1];

	pFileInfo->wszFileName = new WCHAR[wcslen(i_wszDirectory) + wcslen(i_pFindFileData->cFileName)+1];
	if (pFileInfo->wszFileName == NULL) 
	{
		return E_OUTOFMEMORY;
	}
	wcscpy(pFileInfo->wszFileName, i_wszDirectory);
	wcscat(pFileInfo->wszFileName, i_pFindFileData->cFileName);

	pFileInfo->ftLastModified = i_pFindFileData->ftLastWriteTime;
	pFileInfo->fStatus = i_bCreate ? 0 : fST_FILESTATUS_ADD;
	return S_OK;
}

// =======================================================================
HRESULT CListener::UpdateFile(	
	Array<FileInfo>& i_aFileCache,
	LPCWSTR		i_wszDirectory,
	WIN32_FIND_DATA *i_pFindFileData)
{
	WCHAR		awchFullPath[_MAX_PATH];
	HRESULT		hr = S_OK;

	wcscpy(awchFullPath, i_wszDirectory);
	wcscat(awchFullPath, i_pFindFileData->cFileName);

	for (ULONG i = 0; i < i_aFileCache.size(); i++)
	{
		if (!Wszlstrcmpi(i_aFileCache[i].wszFileName, awchFullPath))
		{
			// Initially, I was just comparing the LastWriteTime which worked fine for file edits. However
			// when the file was overwritten by a file copy, I'd get the write time changed twice and I'd call
			// OnFileModify twice. To prevent this I check both AccessTime and WriteTime.
			if (CompareFileTime(&i_aFileCache[i].ftLastModified, &i_pFindFileData->ftLastAccessTime) &&
				CompareFileTime(&i_aFileCache[i].ftLastModified, &i_pFindFileData->ftLastWriteTime))
			{
				i_aFileCache[i].ftLastModified = i_pFindFileData->ftLastWriteTime;
				i_aFileCache[i].fStatus = fST_FILESTATUS_UPDATE;
			}
			else
			{
				i_aFileCache[i].fStatus = fST_FILESTATUS_NOCHANGE;
			}
			return S_OK;
		}
	}

	// If the file wasn't already in the cache add it.
	return AddFile(i_aFileCache, i_wszDirectory, i_pFindFileData, FALSE);
}

// =======================================================================
HRESULT CListener::FireEvents(
	Array<FileInfo>& i_aFileCache,
	ISimpleTableFileChange* pISTNotify)
{
	HRESULT		hr = S_OK;

	for (ULONG i = 0; i < i_aFileCache.size(); i++)
	{
		if (i_aFileCache[i].fStatus == fST_FILESTATUS_NOCHANGE)
		{
		}
		else if (i_aFileCache[i].fStatus == fST_FILESTATUS_ADD)
		{
			hr = pISTNotify->OnFileCreate(i_aFileCache[i].wszFileName);
		}
		else if (i_aFileCache[i].fStatus == fST_FILESTATUS_UPDATE)
		{
			hr = pISTNotify->OnFileModify(i_aFileCache[i].wszFileName);
		}
		else
		{
			hr = pISTNotify->OnFileDelete(i_aFileCache[i].wszFileName);

			// Get rid of this entry.
			delete [] i_aFileCache[i].wszFileName;
			i_aFileCache.deleteAt(i);
			i--;
			continue;
		}
		i_aFileCache[i].fStatus = 0;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\stdafx.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __STDAFX_H__
#define __STDAFX_H__

#include "WinWrap.h"

#ifndef _INC_STDIO
    #include "stdio.h"
#endif
#ifndef __stable_h__
    #include "catalog.h"
#endif
#ifndef __oledb_h__
    #include "oledb.h"
#endif
#ifndef _INC_STDLIB
    #include "stdlib.h"
#endif
#ifndef _INC_WCHAR
    #include "wchar.h"
#endif

//DEFINE_GUID(GUID_NULL, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
#ifndef __ATLBASE_H__
    #include <atlbase.h>
#endif

#ifndef __RPCDCE_H__
    #include "rpcdce.h"
#endif

#ifndef __XMLUTILITY_H__
    #include "XmlUtility.h"
#endif

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tcomcatdataxmlfile.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TCOMCATDATAFILE_H__
#define __TCOMCATDATAFILE_H__

//The only non-standard header that we need for the class declaration is TOutput
#ifndef __OUTPUT_H__
    #include "Output.h"
#endif
#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif
#ifndef __TXMLFILE_H__
    #include "TXmlFile.h"
#endif
#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif


class TComCatDataXmlFile : public TXmlFile, public ICompilationPlugin
{
public:
    TComCatDataXmlFile();

    virtual void Compile(TPEFixup &fixup, TOutput &out);

    void                Dump(TOutput &out) const;
    void                Parse(LPCWSTR szComCatDataFile, bool bValidate=true){ASSERT(bValidate);TXmlFile::Parse(szComCatDataFile, bValidate);}

    static LPCWSTR      m_szComCatDataSchema;
private:
    TPEFixup  * m_pFixup;
    TOutput   * m_pOut;

    void                AddRowToPool(IXMLDOMNode *pNode_Row, TTableMeta & TableMeta);
    void                AddTableToPool(IXMLDOMNode *pNode_Table, TTableMeta & TableMeta);
    unsigned long       DetermineBestModulo(ULONG cRows, ULONG aHashes[]);
    void                FillInTheHashTables();
    void                FillInTheFixedHashTable(TTableMeta &i_TableMeta);
    unsigned long       FillInTheHashTable(unsigned long cRows, ULONG aHashes[], ULONG Modulo);
};

#endif // __TCOMCATDATAFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tcomcatdataxmlfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "stdafx.h"
#include "XMLUtility.h"

LPCWSTR TComCatDataXmlFile::m_szComCatDataSchema=L"ComCatData_v6";



//We do everything we need with XmlFile in the ctor so we don't keep it around
TComCatDataXmlFile::TComCatDataXmlFile() : m_pFixup(0), m_pOut(0)
{
}

void TComCatDataXmlFile::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    ASSERT(IsSchemaEqualTo(m_szComCatDataSchema));

    CComPtr<IXMLDOMElement>     pElement_Root;
    XIF(m_pXMLDoc->get_documentElement(&pElement_Root));

    CComPtr<IXMLDOMNodeList>    pNodeList_TableID;
    XIF(pElement_Root->get_childNodes(&pNodeList_TableID));

    long cTables;
    XIF(pNodeList_TableID->get_length(&cTables));

    while(cTables--)
    {
        CComPtr<IXMLDOMNode>    pNode_Table;
        XIF(pNodeList_TableID->nextNode(&pNode_Table));

        CComBSTR bstrTableName;
        XIF(pNode_Table->get_baseName(&bstrTableName));

        if(0 == bstrTableName.m_str)
            continue;//ignore comment elements

        unsigned long iTableMeta = m_pFixup->FindTableBy_TableName(bstrTableName.m_str);//Find the table by its internal name
        if(static_cast<long>(iTableMeta) < 1)
            continue;//we're obviously not at a TableNode

        TTableMeta TableMeta(*m_pFixup, iTableMeta);
        m_pFixup->TableMetaFromIndex(iTableMeta)->iFixedTable = m_pFixup->GetCountULONG();//This is where we're going to start putting the fixed table.
        AddTableToPool(pNode_Table, TableMeta);//Add the table to the pool
        //Now that the table is added we need to know how many rows there were.
        unsigned long culongTable = m_pFixup->GetCountULONG() - TableMeta.Get_iFixedTable();//The number of ulongs in the table
        unsigned long ciRows = culongTable / *TableMeta.Get_CountOfColumns();//The number of rows the the ulong count divided by the count of columns
        m_pFixup->TableMetaFromIndex(iTableMeta)->ciRows = ciRows;//store that back into the table.
    }

    FillInTheHashTables();
}


//
//
//  Private member functions
//
//
void TComCatDataXmlFile::AddRowToPool(IXMLDOMNode *pNode_Row, TTableMeta & TableMeta)
{
    CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_Row_AttributeMap;
    XIF(pNode_Row->get_attributes(&pNodeMap_Row_AttributeMap));
    ASSERT(0 != pNodeMap_Row_AttributeMap.p);//The schema should prevent this.

    TColumnMeta ColumnMeta(*m_pFixup, TableMeta.Get_iColumnMeta());

    unsigned cColumns = *TableMeta.Get_CountOfColumns();
    for(;cColumns;--cColumns, ColumnMeta.Next())
    {
        CComBSTR bstrColumnPublicName = ColumnMeta.Get_PublicName();
        if(0 == (*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTPERSISTABLE))
        {
            switch(*ColumnMeta.Get_Type())
            {
            case DBTYPE_GUID:
                {
                    GUID guid;
                    if(!GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, guid, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                    {
                        const GUID * pDefaultValue = reinterpret_cast<const GUID *>(ColumnMeta.Get_DefaultValue()); 
                        if(pDefaultValue)
                            m_pFixup->AddULongToList(m_pFixup->AddGuidToList(*pDefaultValue));
                        else
                            m_pFixup->AddULongToList(0);
                    }
                    else
                        m_pFixup->AddULongToList(m_pFixup->AddGuidToList(guid));//AddGuidToList returns the index to the guid, so add it to the ULong pool
                }
                break;
            case DBTYPE_WSTR:
                {
                    CComVariant var;
                    if(!GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, var, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                    {
                        LPCWSTR pDefaultValue = reinterpret_cast<LPCWSTR>(ColumnMeta.Get_DefaultValue());
                        if(pDefaultValue)
                            m_pFixup->AddULongToList(m_pFixup->AddWCharToList(pDefaultValue, *ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FIXEDLENGTH ? *ColumnMeta.Get_Size() : -1));
                        else
                            m_pFixup->AddULongToList(0);
                    }
                    else
                    {
                        //verify that the string isn't too long
                        unsigned long size = -1;
                        if(*ColumnMeta.Get_Size() != -1)
                        {
                            if(*ColumnMeta.Get_Size() < (wcslen(var.bstrVal)+1)*sizeof(WCHAR))
                            {
                                m_errorOutput->printf(L"Error - String (%s) is too large according to the Meta for Column (%s).\n", var.bstrVal, ColumnMeta.Get_InternalName());
                                THROW(ERROR - STRING TOO LARGE);
                            }
                            if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FIXEDLENGTH)
                                size = *ColumnMeta.Get_Size();//if fixed length then pass the size to AddWCharToList so it will reserve the whole size
                        }
                        m_pFixup->AddULongToList(m_pFixup->AddWCharToList(var.bstrVal, size));//AddWCharToList returns the index to the wchar *, so add it to the ULong pool
                    }
                }
                break;
            case DBTYPE_UI4:
                {
                    ULONG ulong = 0;
                    if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_ENUM)
                    {
                        CComVariant var;
                        if(GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, var, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                        {
                            TTagMeta TagMeta(*m_pFixup, ColumnMeta.Get_iTagMeta());
                            for(unsigned long iTag=0; iTag<ColumnMeta.Get_ciTagMeta(); ++iTag, TagMeta.Next())
                            {
                                if(0 == lstrcmpi(var.bstrVal, TagMeta.Get_PublicName()))
                                {
                                    ulong = *TagMeta.Get_Value();
                                    break;
                                }
                            }
                            if(iTag == ColumnMeta.Get_ciTagMeta())
                            {
                                m_errorOutput->printf(L"Error - Tag %s not found", var.bstrVal);
                                THROW(ERROR - TAG NOT FOUND);
                            }
                            ulong = m_pFixup->AddUI4ToList(ulong);
                        }
                        //else ulong == 0 means NULL
                    }
                    else if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FLAG)
                    {
                        CComVariant var;
                        if(GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, var, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                        {
                            LPWSTR token = wcstok(var.bstrVal, L" ,|");
                            TTagMeta TagMeta(*m_pFixup, ColumnMeta.Get_iTagMeta());
                            unsigned long iTag=0;
                            while(token && iTag<ColumnMeta.Get_ciTagMeta())
                            {
                                if(0 == lstrcmpi(token, TagMeta.Get_PublicName()))
                                {
                                    ulong |= *TagMeta.Get_Value();
                                    TagMeta.Reset();//Reset the TagMeta pointer to the first TagMeta for the column
                                    iTag = 0;
                                    token = wcstok(0, L" ,|");
                                    continue;
                                }
                                ++iTag;
                                TagMeta.Next();
                            }
                            if(iTag == ColumnMeta.Get_ciTagMeta())
                            {
                                m_errorOutput->printf(L"Error - Tag %s not found", token);
                                THROW(ERROR - TAG NOT FOUND);
                            }
                            ulong = m_pFixup->AddUI4ToList(ulong);
                        }
                        // else ulong == 0 means NULL
                    }
                    else if(GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, ulong, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                        ulong = m_pFixup->AddUI4ToList(ulong);//convert to aUI4 index
                    if(0 == ulong)//is our ULONG NULL
                    {
                        const ULONG * pUlong = reinterpret_cast<const ULONG *>(ColumnMeta.Get_DefaultValue());
                        ulong = pUlong ? m_pFixup->AddUI4ToList(*pUlong) : 0;
                    }
                    m_pFixup->AddULongToList(ulong);
                }
                break;
            case DBTYPE_BYTES:
                {
                    CComVariant var;
                    if(GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, var, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                    {
                        unsigned char *pBytes=0;
                        unsigned long length = (ULONG) wcslen(var.bstrVal)/2;

                        if(*ColumnMeta.Get_Size() < length)
                        {
                            m_errorOutput->printf(L"Error - Byte array (%s) too long.  Maximum size should be %d bytes.\n", var.bstrVal, *ColumnMeta.Get_Size());
                            THROW(ERROR - BYTE ARRAY TOO LARGE);
                        }
                        if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FIXEDLENGTH)
                        {
                            length = *ColumnMeta.Get_Size();
                        }
                        try
                        {
                            pBytes = new unsigned char[length];
                            ConvertWideCharsToBytes(var.bstrVal, pBytes, length);//This puts the length in the first ULONG
                            m_pFixup->AddULongToList(m_pFixup->AddBytesToList(pBytes, length));//use the index to the bytes
                            delete [] pBytes;
                        }
                        catch(TException &e)
                        {
                            delete [] pBytes;
                            throw e;
                        }
                    }
                    else
                    {
                        const unsigned char *pDefaultValue = ColumnMeta.Get_DefaultValue();
                        if(pDefaultValue)
                        {
                            const ULONG * pSizeofDefaultValue = reinterpret_cast<const ULONG *>(pDefaultValue - sizeof(ULONG));
                            m_pFixup->AddULongToList(m_pFixup->AddBytesToList(pDefaultValue, *pSizeofDefaultValue));
                        }
                        else
                            m_pFixup->AddULongToList(0);
                    }
                }
                break;
            default:
                ASSERT(false && "Unknown Data Type in XML file");
                THROW(ERROR - UNKNOWN DATA TYPE);
            }
        }
        else
        {
            m_pFixup->AddULongToList(0);//We need to add even NON_PERSISTABLE values so the row/column arithmetic works out
        }
    }
}


void TComCatDataXmlFile::AddTableToPool(IXMLDOMNode *pNode_Table, TTableMeta & TableMeta)
{
    CComPtr<IXMLDOMNodeList> pNodeList_Row;
    XIF(pNode_Table->get_childNodes(&pNodeList_Row));

    long cRows;
    XIF(pNodeList_Row->get_length(&cRows));

    while(cRows--)
    {
        CComPtr<IXMLDOMNode>    pNode_Row;
        XIF(pNodeList_Row->nextNode(&pNode_Row));

        CComBSTR RowName;
        XIF(pNode_Row->get_baseName(&RowName));//This returns NULL string for comments

        if(0==RowName.m_str || 0!=wcscmp(RowName.m_str, TableMeta.Get_PublicRowName()))
            continue;//ignore all but the Table's Rows (usually only comments can exist and still be valid)

        AddRowToPool(pNode_Row, TableMeta);
    }
}


void TComCatDataXmlFile::Dump(TOutput &out) const
{
    static bool bDump=false;
    if(!bDump)
        return;

    #define GetTableMetaArrayPointer        m_pFixup->TableMetaFromIndex
    #define GetCountOfTableMeta             m_pFixup->GetCountTableMeta
    #define GetColumnMetaArrayPointer       m_pFixup->ColumnMetaFromIndex
    #define GetCountOfColumnMeta            m_pFixup->GetCountColumnMeta
    #define GetHashedIndexArrayPointer      m_pFixup->HashedIndexFromIndex
    #define GetULongArrayPointer            m_pFixup->ULongFromIndex
    #define GuidFromIndex                   m_pFixup->GuidFromIndex
    #undef String
    #define String(i)                       (i ? m_pFixup->StringFromIndex(i) : L"<null>")
    #define UI4FromIndex(i)                 (i ? m_pFixup->UI4FromIndex(i) : -1)
    #define output                          out.printf
    #define COMACROSASSERT                  ASSERT

    const TableMeta *pTableMeta = GetTableMetaArrayPointer();
    WCHAR szBuf[2048];
    for(unsigned long iTableMeta=0; iTableMeta< GetCountOfTableMeta(); ++iTableMeta, ++pTableMeta)
    {
        if(static_cast<long>(pTableMeta->iFixedTable) > 0)
        {
            const ULONG *pLong= GetULongArrayPointer(pTableMeta->iFixedTable);
            const ColumnMeta *pColumnMeta = GetColumnMetaArrayPointer(pTableMeta->iColumnMeta);

            wsprintf(szBuf, L"Fixed Table --------- %s ---------\n", String(pTableMeta->PublicName));
            output(szBuf);

            output(L"\t{");
            for(unsigned long iColumn=0;iColumn<UI4FromIndex(pTableMeta->CountOfColumns); ++iColumn, ++pColumnMeta)
            {
                wsprintf(szBuf, L"%50s", String(pColumnMeta->InternalName));output(szBuf);
                if(iColumn != UI4FromIndex(pTableMeta->CountOfColumns)-1)
                    output(L" , ");
            }
            output(L"}\n");

            for(unsigned long iRow=0; iRow<pTableMeta->ciRows; ++iRow)
            {
                pColumnMeta = GetColumnMetaArrayPointer(pTableMeta->iColumnMeta);
                ULONG RowHash = 0;

                output(L"\t{");
                for(unsigned long iColumn=0;iColumn<UI4FromIndex(pTableMeta->CountOfColumns); ++iColumn, ++pColumnMeta)
                {
                    if(0 == (UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_NOTPERSISTABLE))
                    {
                        if(0 == pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn])
                        {
                            wsprintf(szBuf, L"%50s", L"<Null>");
                            output(szBuf);
                        }
                        else
                        {
                            switch(UI4FromIndex(pColumnMeta->Type))
                            {
                            case DBTYPE_GUID:
                                {
                                    const GUID *pGuid = GuidFromIndex(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]);

                                    LPOLESTR szGuid;
                                    StringFromCLSID(*pGuid, &szGuid);
                                    wsprintf(szBuf, L"%50s", szGuid);
                                    output(szBuf);
                                    CoTaskMemFree(szGuid);
                                    if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY)
                                        RowHash = Hash(*pGuid, RowHash);
                                }
                                break;
                            case DBTYPE_WSTR:
                                {
                                    wsprintf(szBuf, L"%50s", String(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]));
                                    output(szBuf);
                                    if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY)
                                        RowHash = Hash(String(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]), RowHash);
                                }
                                break;
                            case DBTYPE_UI4:
                                wsprintf(szBuf, L"%39s 0x%08X", L"", UI4FromIndex(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]));
                                output(szBuf);
                                if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY)
                                    RowHash = Hash(UI4FromIndex(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]), RowHash);
                                break;
                            case DBTYPE_BYTES:
                                wsprintf(szBuf, L"%50s", L" <Bytes>  ");
                                output(szBuf);
                                break;
                            default:
                                COMACROSASSERT(false && "Something's wrong, we should never get a type other than the four basic types");
                            }
                        }
                    }
                    else
                    {
                        output(L"    ");
                    }
                    if(iColumn != UI4FromIndex(pTableMeta->CountOfColumns)-1)
                        output(L" , ");
                }
                wsprintf(szBuf, L"} Hash= 0x%08x, Modulo= 0x%08x, RowHash= 0x%08x\n", RowHash, GetHashedIndexArrayPointer(pTableMeta->iHashTableHeader)->iNext, RowHash % GetHashedIndexArrayPointer(pTableMeta->iHashTableHeader)->iNext);
                output(szBuf);
                Sleep(20);
            }
            wsprintf(szBuf, L"end Table   --------- %s ---------\n\n", String(pTableMeta->PublicName));
            output(szBuf);
        }
    }
    #undef  GetTableMetaArrayPointer
    #undef  GetCountOfTableMeta
    #undef  GetColumnMetaArrayPointer
    #undef  GetCountOfColumnMeta
    #undef  GetHashedIndexArrayPointer
    #undef  GetULongArrayPointer
    #undef  GuidFromIndex
    #undef  StringFromIndex
    #undef  UI4FromIndex
    #undef  output
    #undef  COMACROSASSERT
}

extern unsigned int kPrime[];

unsigned long TComCatDataXmlFile::DetermineBestModulo(ULONG cRows, ULONG aHashes[])
{
    unsigned long BestModulo = 0;
    unsigned int LeastDups                  = -1;

    static HashedIndex  pHashTable[kLargestPrime * 2];

    for(unsigned int iPrimeNumber=0; kPrime[iPrimeNumber] != 0 && kPrime[iPrimeNumber]<(cRows * 20) && LeastDups!=0; ++iPrimeNumber)
    {
        if(kPrime[iPrimeNumber]<cRows)//we don't have a chance of coming up with few duplicates if the prime number is LESS than the number of rows in the table.
            continue;                //So skip all the small primes.

        m_infoOutput->printf(L".");

        unsigned int Dups           = 0;
        unsigned int DeepestLink    = 0;

        //We're going to use the HashPool to store this temporary data so we can figure out the dup count and the deepest depth
        memset(pHashTable, -1, sizeof(pHashTable));
        for(unsigned long iRow=0; iRow<cRows && Dups<LeastDups && DeepestLink<5;++iRow)
        {
            ULONG HashedIndex = aHashes[iRow] % kPrime[iPrimeNumber];

            if(0 == pHashTable[HashedIndex].iNext)//if this is the second time we've seen this hash, then bump the Dups
                ++Dups;

            ++(pHashTable[HashedIndex].iNext);//For now Next holds the number of occurances of this hash

            if(pHashTable[HashedIndex].iNext > DeepestLink)
                DeepestLink = pHashTable[HashedIndex].iNext;
        }
        if(DeepestLink<5 && Dups<LeastDups)
        {
            LeastDups                 = Dups;
            BestModulo  = kPrime[iPrimeNumber];
        }
    }

    if(0 == BestModulo)
        THROW(No hashing scheme seems reasonable.);

    return BestModulo;
}


void TComCatDataXmlFile::FillInTheHashTables()
{
    //Walk the TableMeta looking for tables with an iFixedTable greater than zero.  If iFixedTable is less than zero then 
    //the table is a Meta table.  If iFixedTable is greater than zero then it's a fixed table in the ULONG pool.
    TTableMeta TableMeta(*m_pFixup);
    for(unsigned long iTableMeta=0; iTableMeta<TableMeta.GetCount(); ++iTableMeta, TableMeta.Next())
    {
        //If this table is not stored in the fixed table then there's nothing to build the hash on.
        if(0 >= static_cast<long>(TableMeta.Get_iFixedTable()))
            continue;

        FillInTheFixedHashTable(TableMeta);
    }
}


void TComCatDataXmlFile::FillInTheFixedHashTable(TTableMeta &i_TableMeta)
{
    m_infoOutput->printf(L"Building %s hash table", i_TableMeta.Get_InternalName());

    //Get a pointer to the table
    const ULONG *pTable = m_pFixup->ULongFromIndex(i_TableMeta.Get_iFixedTable());//The table is a Fixed table stored in the ULONG pool

    TSmartPointerArray<unsigned long> pRowHash = new unsigned long [i_TableMeta.Get_ciRows()];
    if(0 == pRowHash.m_p)
        THROW(out of memory);

    //Get the ColumnMeta so we can interpret pTable correctly.
    TColumnMeta ColumnMeta(*m_pFixup, i_TableMeta.Get_iColumnMeta());
    for(unsigned long iRow=0; iRow < i_TableMeta.Get_ciRows(); ++iRow, pTable += *i_TableMeta.Get_CountOfColumns(), ColumnMeta.Reset())
    {
        unsigned long RowHash=0;//This hash is the combination of all PKs that uniquely identifies the row

        //I could make this process faster by building an array of PK indexes; but I think code clarity wins out here.
        for(unsigned long iColumnMeta=0; iColumnMeta < *i_TableMeta.Get_CountOfColumns(); ++iColumnMeta, ColumnMeta.Next())
        {
            if(0 == (*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_PRIMARYKEY))
                continue;//Only build the hash for primarykey values

            if(0 == pTable[iColumnMeta])
            {
                m_errorOutput->printf(L"Error - Table %s, Column %s is a PrimaryKey and is set to NULL.\n", i_TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName());
                THROW(Fixed table contains NULL value in PrimaryKey);
            }

            switch(*ColumnMeta.Get_Type())
            {
            case DBTYPE_GUID:
                RowHash = Hash(*m_pFixup->GuidFromIndex(pTable[iColumnMeta]), RowHash);break;
            case DBTYPE_WSTR:
                RowHash = Hash(m_pFixup->StringFromIndex(pTable[iColumnMeta]), RowHash);break;
            case DBTYPE_UI4:
                RowHash = Hash(m_pFixup->UI4FromIndex(pTable[iColumnMeta]), RowHash);break;
            case DBTYPE_BYTES:
                RowHash = Hash(m_pFixup->ByteFromIndex(pTable[iColumnMeta]), m_pFixup->BufferLengthFromIndex(pTable[iColumnMeta]), RowHash);break;
            default:
                THROW(unsupported type);
            }
        }
        pRowHash[iRow] = RowHash;
    }

    //OK Now we have the 32 bit hash values.  Now we need to see which prime number acts as the best modulo.
    unsigned long Modulo = DetermineBestModulo(i_TableMeta.Get_ciRows(), pRowHash);

    //Now actually fill in the hash table
    unsigned long iHashTable = FillInTheHashTable(i_TableMeta.Get_ciRows(), pRowHash, Modulo);

    i_TableMeta.Get_pMetaTable()->iHashTableHeader = iHashTable;
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_pFixup->HashedIndexFromIndex(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;

    m_infoOutput->printf(L"\n%s hash table has %d nonunique entries.\n", i_TableMeta.Get_InternalName(), cNonUniqueEntries);

}
  

unsigned long TComCatDataXmlFile::FillInTheHashTable(unsigned long cRows, ULONG aHashes[], ULONG Modulo)
{
    HashedIndex header;//This is actually the HashTableHeader
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(&header);
    pHeader->Modulo = Modulo;
    pHeader->Size   = Modulo;//This Size is not only the number of HashedIndex entries but where we put the overflow from duplicate Hashes.

    //We'll fixup the Size member when we're done.
    ULONG iHashTableHeader = m_pFixup->AddHashedIndexToList(&header)/sizeof(HashedIndex);
    ULONG iHashTable = iHashTableHeader+1;

    HashedIndex     hashedindextemp;
    for(ULONG i=0;i<Modulo;++i)//-1 fill the hash table
        m_pFixup->AddHashedIndexToList(&hashedindextemp);

    for(unsigned long iRow=0; iRow<cRows; ++iRow)
    {
        ASSERT(-1 != aHashes[iRow]);//These fixed table should have a hash for each row.  If a hash turns out to be -1, we have a problem, since we've reserved -1 to indicate an empty slot.
        //This builds the hases for the TableName
        ULONG HashedIndex = aHashes[iRow] % pHeader->Modulo;
        if(-1 == m_pFixup->HashedIndexFromIndex(iHashTable + HashedIndex)->iOffset)
            m_pFixup->HashedIndexFromIndex(iHashTable + HashedIndex)->iOffset = iRow;//iNext is already -1 so no need to set it
        else
        {   //Otherwise we have to walk the linked list to find the last one so we can append this one to the end
            unsigned int LastInLink = HashedIndex;
            while(-1 != m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext)
                LastInLink = m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext;

            m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext = pHeader->Size;//Size is the end of the hash table, so append it to the end and bump the Size.

            //Reuse the temp variable
            hashedindextemp.iNext   = -1;//we only added enough for the hash table without the overflow slots.  So these dups need to be added to the heap with -1 set for iNext.
            hashedindextemp.iOffset = iRow;
            m_pFixup->AddHashedIndexToList(&hashedindextemp);

            ++pHeader->Size;
        }
    }

    //Now fix the Header Size         //The type is HashedIndex, so HashedIndex.iOffset maps to HashedHeader.Size
    m_pFixup->HashedIndexFromIndex(iHashTableHeader)->iOffset = pHeader->Size;

    return iHashTableHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tcom.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TCOM_H__
#define __TCOM_H__

class TCom
{
public:
    TCom(){CoInitialize(NULL);}
    ~TCom(){CoUninitialize();}
};

#endif //__TCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tcomcatmetaxmlfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
/*
Modifying Meta for the ColumnMeta table

List of File Requiring Change
    CATMETA.XMS
    CATMETA_CORE.XML
    "Inferrence Rule for Catalog Meta Tables.doc"
    METATABLESTRUCTS.H
    TMETAINFERRENCE.CPP
Steps
    1.	Add the new columns to ColumnMetaPublic in MetaTableStructs.h.
    2.	Add the new attributes to CatMeta.XMS
    3.	Add the new columns to CatMeta_Core.XML
    4.	Add the new "m_bstr_" variables to the TComCatMetaXmlFile object (in TComCatMetaXmlFile.h)
    5.	Initialize the new "m_bstr_" variables in the TComCatMetaXmlFile constructor (TComCatMetaXmlFile.cpp)
    6.	Modify TComCatMetaXmlFile.cpp::FillInThePEColumnMeta (TComCatMetaXmlFile.cpp) to read in the new columns.
        a.	Update the 'if(InheritsColumnMeta)'.  Note that UI4 value explicitly specified overrides the property the column inherited from.  And flag values are Ored with the inherited flags.
        b.	Update the 'else' clause.
    7.	Modify TComCatMetaXmlFile.cpp::AddColumnByReference (TComCatMetaXmlFile.cpp).
    8.	Update "Inferrence Rule for Catalog Meta Tables.doc".  Remember, UI4 values in Meta tables may NOT be NULL.
    9.	Modify TMetaInferrence::InferColumnMeta (TMetaInferrence.cpp)
   10.  Change FixedTableHeap.h version number (kFixedTableHeapVersion)
*/


#include "stdafx.h"
#include "catalog.h"
#include "XMLUtility.h"

#ifndef __TCOLUMNMETA_H__
    #include "TColumnMeta.h"
#endif
#ifndef __TDATABASEMETA_H__
    #include "DatabaseMeta.h"
#endif
#ifndef __TINDEXMETA_H__
    #include "TIndexMeta.h"
#endif
#ifndef __TQUERYMETA_H__
    #include "TQueryMeta.h"
#endif
#ifndef __TRELATIONMETA_H__
    #include "TRelationMeta.h"
#endif
#ifndef __TTABLEMETA_H__
    #include "TableMeta.h"
#endif
#ifndef __TTAGMETA_H__
    #include "TagMeta.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __HASH_H__
    #include "Hash.h"
#endif
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif
#ifndef __THEAP_H__
    #include "THeap.h"
#endif

LPCWSTR TComCatMetaXmlFile::m_szComCatMetaSchema    =L"ComCatMeta_v7";
GlobalRowCounts g_coreCounts; // global count of the rows in the meta tables that come from catmeta_core.xml

#define     IIS_SYNTAX_ID_DWORD         1   //  DWORD                                              EXTENDEDTYPE0   (| EXTENDEDTYPE0")
#define     IIS_SYNTAX_ID_STRING        2   //  STRING                               EXTENDEDTYPE1                 (| EXTENDEDTYPE1")
#define     IIS_SYNTAX_ID_EXPANDSZ      3   //  EXPANDSZ                             EXTENDEDTYPE1 EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE1")
#define     IIS_SYNTAX_ID_MULTISZ       4   //  MULTISZ                EXTENDEDTYPE2                               (| EXTENDEDTYPE2")
#define     IIS_SYNTAX_ID_BINARY        5   //  BINARY                 EXTENDEDTYPE2               EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE2")
#define     IIS_SYNTAX_ID_BOOL          6   //  DWORD                  EXTENDEDTYPE2 EXTENDEDTYPE1                 (| EXTENDEDTYPE1 | EXTENDEDTYPE2")
#define     IIS_SYNTAX_ID_BOOL_BITMASK  7   //  DWORD                  EXTENDEDTYPE2 EXTENDEDTYPE1 EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE1 | EXTENDEDTYPE2")
#define     IIS_SYNTAX_ID_MIMEMAP       8   //  MULTISZ  EXTENDEDTYPE3                                             (| EXTENDEDTYPE3") 
#define     IIS_SYNTAX_ID_IPSECLIST     9   //  MULTISZ  EXTENDEDTYPE3                             EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE3") 
#define     IIS_SYNTAX_ID_NTACL        10   //  BINARY   EXTENDEDTYPE3               EXTENDEDTYPE1                 (| EXTENDEDTYPE1 | EXTENDEDTYPE3") 
#define     IIS_SYNTAX_ID_HTTPERRORS   11   //  MULTISZ  EXTENDEDTYPE3               EXTENDEDTYPE1 EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE1 | EXTENDEDTYPE3")  
#define     IIS_SYNTAX_ID_HTTPHEADERS  12   //  MULTISZ  EXTENDEDTYPE3 EXTENDEDTYPE2                               (| EXTENDEDTYPE2 | EXTENDEDTYPE3") 

TOLEDataTypeToXMLDataType OLEDataTypeToXMLDataType[]={
//                                    ,bImplicitlyRequired                                                                                                 fMetaFlagsEx
//String             ,MappedString            ,dbType         ,cbSize         ,fCOLUMNMETA                                                                ,fCOLUMNSCHEMAGENERATOR
L"STRING"            ,L"string"       ,false,  DBTYPE_WSTR,    -1,             0,                                                                          (IIS_SYNTAX_ID_STRING        <<2),
L"Bool"              ,L"ui4"          ,false,  DBTYPE_UI4,     sizeof(ULONG),  fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_BOOL | fCOLUMNMETA_CASEINSENSITIVE,   (IIS_SYNTAX_ID_BOOL          <<2),
L"MULTISZ"           ,L"string"       ,false,  DBTYPE_WSTR,    -1,             fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_MULTISZ       <<2),
L"BINARY"            ,L"bin.hex"      ,false,  DBTYPE_BYTES,   -1,             0,                                                                          (IIS_SYNTAX_ID_BINARY        <<2),
L"EXPANDSZ"          ,L"string"       ,false,  DBTYPE_WSTR,    -1,             fCOLUMNMETA_EXPANDSTRING,                                                   (IIS_SYNTAX_ID_EXPANDSZ      <<2),
L"IPSECLIST"         ,L"bin.hex"      ,false,  DBTYPE_BYTES   ,-1             ,fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_IPSECLIST     <<2),
L"MIMEMAP"           ,L"string"       ,false,  DBTYPE_WSTR    ,-1             ,fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_MIMEMAP       <<2),
L"NTACL"             ,L"bin.hex"      ,false,  DBTYPE_BYTES   ,-1             ,0,                                                                          (IIS_SYNTAX_ID_NTACL         <<2),
L"BOOL_BITMASK"      ,L"ui4"          ,false,  DBTYPE_UI4     ,sizeof(ULONG)  ,0,                                                                          (IIS_SYNTAX_ID_BOOL_BITMASK  <<2),
L"HTTPERRORS"        ,L"string"       ,false,  DBTYPE_WSTR    ,-1             ,fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_HTTPERRORS    <<2),
L"HTTPHEADERS"       ,L"string"       ,false,  DBTYPE_WSTR    ,-1             ,fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_HTTPHEADERS   <<2),

L"GUID"              ,L"uuid"         ,false,  DBTYPE_GUID,    sizeof(GUID),   fCOLUMNMETA_FIXEDLENGTH,                                                    0,
L"WSTR"              ,L"string"       ,false,  DBTYPE_WSTR,    -1,             0,                                                                          (IIS_SYNTAX_ID_STRING        <<2),
L"UI4"               ,L"ui4"          ,false,  DBTYPE_UI4,     sizeof(ULONG),  fCOLUMNMETA_FIXEDLENGTH,                                                    (IIS_SYNTAX_ID_DWORD         <<2),
L"BYTES"             ,L"bin.hex"      ,false,  DBTYPE_BYTES,   -1,             0,                                                                          (IIS_SYNTAX_ID_BINARY        <<2),
L"Boolean"           ,L"ui4"          ,false,  DBTYPE_UI4,     sizeof(ULONG),  fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_BOOL | fCOLUMNMETA_CASEINSENSITIVE,   (IIS_SYNTAX_ID_BOOL          <<2),
L"Enum"              ,L"ui4"          ,false,  DBTYPE_UI4,     sizeof(ULONG),  fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_ENUM,                                 (IIS_SYNTAX_ID_DWORD         <<2),
L"Flag"              ,L"ui4"          ,false,  DBTYPE_UI4,     sizeof(ULONG),  fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_FLAG,                                 (IIS_SYNTAX_ID_DWORD         <<2),
L"String"            ,L"string"       ,false,  DBTYPE_WSTR,    -1,             0,                                                                          (IIS_SYNTAX_ID_STRING        <<2),
L"int32"             ,L"ui4"          ,false,  DBTYPE_UI4,     sizeof(ULONG),  fCOLUMNMETA_FIXEDLENGTH,                                                    (IIS_SYNTAX_ID_DWORD         <<2),
L"Byte[]"            ,L"bin.hex"      ,false,  DBTYPE_BYTES,   -1,             0,                                                                          (IIS_SYNTAX_ID_BINARY        <<2),
L"DWORD"             ,L"ui4"          ,false,  DBTYPE_UI4,     sizeof(ULONG),  fCOLUMNMETA_FIXEDLENGTH,                                                    (IIS_SYNTAX_ID_DWORD         <<2),
L"XMLBLOB"           ,L"string"       ,false,  DBTYPE_WSTR,    -1,             0,                                                                          (IIS_SYNTAX_ID_STRING        <<2) | fCOLUMNMETA_XMLBLOB,
L"StrictBool"        ,L"ui4"          ,false,  DBTYPE_UI4,     sizeof(ULONG),  fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_BOOL,                                 (IIS_SYNTAX_ID_BOOL          <<2),
L"DBTIMESTAMP"       ,L"notsupported" ,false,  DBTYPE_DBTIMESTAMP,   sizeof (DBTIMESTAMP),  fCOLUMNMETA_FIXEDLENGTH,											   0,
0                    ,0               ,false,  0              ,0,              0,                                                                          0
};
/*  These aren't supported at this time
L"I4",             L"i4",           true,
L"I2",             L"i2",           true,
L"R4",             L"r4",           true,
L"R8",             L"r8",           true,
L"CY",             L"int",          true,
L"DATE",           L"date",         true,
L"BSTR",           L"string",       true,
L"ERROR",          L"ui4",          true,
L"BOOL",           L"boolean",      true,
L"DECIMAL",        L"float",        true,
L"UI1",            L"ui1",          true,
L"ARRAY",          L"bin.hex",      true,
L"I1",             L"i1",           true,
L"UI2",            L"ui2",          true,
L"I8",             L"i8",           true,
L"UI8",            L"ui8",          true,
L"STR",            L"string",       false,
L"NUMERIC",        L"int",          true,
L"DBDATE",         L"date",         true,
L"DBTIME",         L"time",         true,
L"DBTIMESTAMP",    L"dateTime",     true
};
*/
static int numelementsOLEDataTypeToXMLDataType = (sizeof(OLEDataTypeToXMLDataType) / sizeof(OLEDataTypeToXMLDataType[0]))-1;

//We do everything we need with XmlFile in the ctor so we don't keep it around
TComCatMetaXmlFile::TComCatMetaXmlFile(TXmlFile *pXmlFile, int cXmlFile, TOutput &out) : TFixupHeaps()
                ,m_bstr_Attributes          (kszAttributes          )
                ,m_bstr_BaseVersion         (kszBaseVersion         )
                ,m_bstr_cbSize              (kszcbSize              )
                ,m_bstr_CellName            (kszCellName            )
                ,m_bstr_CharacterSet        (kszCharacterSet        )
                ,m_bstr_ChildElementName    (kszChildElementName    )
                ,m_bstr_ColumnInternalName  (kszColumnInternalName  )
                ,m_bstr_ColumnMeta          (kszColumnMeta          )
                ,m_bstr_ColumnMetaFlags     (kszColumnMetaFlags     )
                ,m_bstr_ConfigItemName      (kszConfigItemName      )
                ,m_bstr_ConfigCollectionName(kszConfigCollectionName)
                ,m_bstr_ContainerClassList  (kszContainerClassList  )
                ,m_bstr_DatabaseInternalName(kszDatabaseInternalName)
                ,m_bstr_DatabaseMeta        (kszDatabaseMeta        )
                ,m_bstr_dbType              (kszdbType              )
                ,m_bstr_DefaultValue        (kszDefaultValue        )
				,m_bstr_Description			(kszDescription			)
                ,m_bstr_EnumMeta            (kszEnumMeta            )
                ,m_bstr_ExtendedVersion     (kszExtendedVersion     )
                ,m_bstr_FlagMeta            (kszFlagMeta            )
                ,m_bstr_ForeignTable        (kszForeignTable        )
                ,m_bstr_ForeignColumns      (kszForeignColumns      )
                ,m_bstr_ID                  (kszID                  )
                ,m_bstr_IndexMeta           (kszIndexMeta           )
                ,m_bstr_InheritsColumnMeta  (kszInheritsColumnMeta  )
                ,m_bstr_Interceptor         (kszInterceptor         )
				,m_bstr_InterceptorDLLName  (kszInterceptorDLLName  )
                ,m_bstr_InternalName        (kszInternalName        )
                ,m_bstr_Locator             (kszLocator             )
                ,m_bstr_MaximumValue        (kszMaximumValue        )
                ,m_bstr_Merger              (kszMerger              )
                ,m_bstr_MergerDLLName       (kszMergerDLLName       )
                ,m_bstr_MetaFlags           (kszMetaFlags           )
                ,m_bstr_MinimumValue        (kszMinimumValue        )
                ,m_bstr_NameValueMeta       (kszNameValueMeta       )
                ,m_bstr_Operator            (kszOperator            )
                ,m_bstr_PrimaryTable        (kszPrimaryTable        )
                ,m_bstr_PrimaryColumns      (kszPrimaryColumns      )
                ,m_bstr_PublicName          (kszPublicName          )
				,m_bstr_PublicColumnName    (kszPublicColumnName    )
                ,m_bstr_PublicRowName       (kszPublicRowName       )
                ,m_bstr_QueryMeta           (kszQueryMeta           )
                ,m_bstr_ReadPlugin          (kszReadPlugin          )
				,m_bstr_ReadPluginDLLName   (kszReadPluginDLLName   )
                ,m_bstr_RelationMeta        (kszRelationMeta        )
                ,m_bstr_SchemaGenFlags      (kszSchemaGenFlags      )
                ,m_bstr_ServerWiring        (kszServerWiring        )
                ,m_bstr_TableMeta           (kszTableMeta           )
                ,m_bstr_TableMetaFlags      (kszTableMetaFlags      )
                ,m_bstr_UserType            (kszUserType            )
                ,m_bstr_Value               (kszValue               )
                ,m_bstr_WritePlugin         (kszWritePlugin         )
				,m_bstr_WritePluginDLLName  (kszWritePluginDLLName  )
                ,m_out(out)
                ,m_pxmlFile(pXmlFile)
                ,m_pXMLDocMetaMeta(0)
                ,m_pXMLDoc(0)
{
    m_pXMLDocMetaMeta = pXmlFile->GetXMLDOMDocument();
    {//confirm that this is the MetaMeta xml file
        CComPtr<IXMLDOMNodeList>    pNodeList_DatabaseMeta;
        XIF(m_pXMLDocMetaMeta->getElementsByTagName(m_bstr_DatabaseMeta, &pNodeList_DatabaseMeta));

        if(0 == pNodeList_DatabaseMeta.p)
        {
            m_out.printf(L"No Database Meta found.  Unable to proceed.\n");
            THROW(No Database Meta found.);
        }
        long cDatabaseMeta;
        XIF(pNodeList_DatabaseMeta->get_length(&cDatabaseMeta));
        if(0 == cDatabaseMeta)
        {
            m_out.printf(L"No DatabaseMeta found.  Unable to proceed.\n");
            THROW(ERROR - NO DATABASEMETA FOUND);
        }
        long i;
        for(i=0;i<cDatabaseMeta;++i)
        {
            CComPtr<IXMLDOMNode> pNode_DatabaseMeta;
            XIF(pNodeList_DatabaseMeta->nextNode(&pNode_DatabaseMeta));

            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement = pNode_DatabaseMeta;ASSERT(0 != pElement.p);//Get the IXMLDOMElement interface pointer

            CComVariant             var_Name;
            XIF(pElement->getAttribute(m_bstr_InternalName, &var_Name));

            if(0 == lstrcmpi(var_Name.bstrVal, L"META"))
                break;
        }
        if(i==cDatabaseMeta)
        {
            m_out.printf(L"The first Meta file listed does not contain the MetaMeta.\n");
            THROW(ERROR - METAMETA NOT FOUND);
        }
    }
    for(int iXmlFile=0;iXmlFile<cXmlFile; ++iXmlFile)
    {
        ULONG iStartingTable = GetCountTableMeta();

        m_pxmlFile = pXmlFile + iXmlFile;
        m_pXMLDoc = m_pxmlFile->GetXMLDOMDocument();
        FillInThePEDatabaseMeta();
        Dump(TDebugOutput());
        FillInThePERelationMeta();

        // save the count of rows in the tables after catmeta_core.xml has been compiled
        if(iXmlFile==0)
        {
            g_coreCounts.cCoreTables    = GetCountTableMeta();
            g_coreCounts.cCoreDatabases = GetCountDatabaseMeta();
            g_coreCounts.cCoreColumns   = GetCountColumnMeta();
            g_coreCounts.cCoreTags      = GetCountTagMeta();
            g_coreCounts.cCoreIndexes   = GetCountIndexMeta();
            g_coreCounts.cCoreRelations = GetCountRelationMeta();
            g_coreCounts.cCoreQueries   = GetCountQueryMeta();

            m_out.printf(L"core tables: %d\n", g_coreCounts.cCoreTables);
            m_out.printf(L"core databases: %d\n", g_coreCounts.cCoreDatabases);
            m_out.printf(L"core columns: %d\n", g_coreCounts.cCoreColumns);
            m_out.printf(L"core tags: %d\n", g_coreCounts.cCoreTags);
            m_out.printf(L"core indexes: %d\n", g_coreCounts.cCoreIndexes);
            m_out.printf(L"core relations: %d\n", g_coreCounts.cCoreRelations);
            m_out.printf(L"core queries: %d\n", g_coreCounts.cCoreQueries);
        }
    }
/*
    FillInTheHashTables();
    if(FAILED(GenerateCLBSchemaBlobs()))
    {
        m_out.printf(L"Fail to generate Complib schema blobs.\n");
        THROW(ERROR - FAIL TO GENERATE BLOBS);
    }*/
    m_pXMLDoc = 0;//We don't addref on this one since we use it locally within the ctor only.
    m_out.printf(L"%s conforms to all enforceable conventions.\n", m_szComCatMetaSchema);
}


//
//Private functions
//
unsigned long TComCatMetaXmlFile::AddArrayOfColumnsToBytePool(unsigned long Table, LPWSTR wszColumnNames)
{
    ASSERT(0 == Table%4);
    ULONG iColumnMeta_0th = FindColumnBy_Table_And_Index(Table, AddUI4ToList(0));

    unsigned long aColumnsAsBytes[255];
    unsigned long iColumns=0;

    wchar_t *       pszColumn;
    pszColumn = wcstok(wszColumnNames, L" ");
    while(pszColumn != 0)
    {
        ULONG iColumnMeta = iColumnMeta_0th;

        unsigned char index;
        for(index=0; iColumnMeta<GetCountColumnMeta() && ColumnMetaFromIndex(iColumnMeta)->Table == Table; ++index, ++iColumnMeta)
        {
            if(ColumnMetaFromIndex(iColumnMeta)->InternalName == AddWCharToList(pszColumn))
            {
                aColumnsAsBytes[iColumns++] = index;
                if(iColumns >= 255)
                {
                    m_out.printf(L"Error - Too many columns specified.\n");
                    THROW(ERROR - TOO MANY COLUMNS);
                }
                break;
            }
        }
        if(iColumnMeta==GetCountColumnMeta() || ColumnMetaFromIndex(iColumnMeta)->Table!=Table)
        {
            m_out.printf(L"Error in RelationMeta - Column (%s) not found in Table (%s).\n", pszColumn, StringFromIndex(Table));
            THROW(ERROR - BAD COLUMN IN RELATIONMETA);
        }
        pszColumn = wcstok(0, L" ");//Next token (next Flag RefID)
    }
    return AddBytesToList(reinterpret_cast<unsigned char *>(aColumnsAsBytes), (iColumns)*sizeof(ULONG));
}



void TComCatMetaXmlFile::AddColumnByReference(ULONG iTableName_Destination, ULONG iColumnIndex_Destination, ULONG iColumnMeta_Source, ColumnMeta &o_columnmeta)
{
    ColumnMeta * pColumnMeta = ColumnMetaFromIndex(iColumnMeta_Source);

    if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_DIRECTIVE)
    {
        m_out.printf(L"Error in inheritance - Referenced Column (%s) is a Directive colum, this is not yet supported.\n", StringFromIndex(pColumnMeta->InternalName));
        THROW(ERROR - BAD INHERITANCE);
    }

    //If the column is a Flag of Enum we need to add TagMeta
    if(UI4FromIndex(pColumnMeta->MetaFlags) & (fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM))
    {
        ULONG iTagMeta = FindTagBy_Table_And_Index(pColumnMeta->Table, pColumnMeta->Index);
        ASSERT(-1 != iTagMeta);
        if(-1 == iTagMeta)
        {
            THROW(ERROR - TAGMETA NOT FOUND);
        }
        
        /*struct TagMetaPublic
        {
            ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
            ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;            //UI4       This is the iOrder member of the ColumnMeta
            ULONG PRIMARYKEY            InternalName;           //String
            ULONG                       PublicName;             //String
            ULONG                       Value;
        };*/
        ULONG iTagMetaStart = iTagMeta;
        for( ;iTagMeta<GetCountTagMeta()
            && TagMetaFromIndex(iTagMeta)->Table==pColumnMeta->Table
            && TagMetaFromIndex(iTagMeta)->ColumnIndex==pColumnMeta->Index;++iTagMeta)
        {
            TagMeta *pTagMeta = TagMetaFromIndex(iTagMeta);

            TagMeta tagmeta;

            tagmeta.Table           = iTableName_Destination    ;
            tagmeta.ColumnIndex     = iColumnIndex_Destination  ;
            tagmeta.InternalName    = pTagMeta->InternalName    ;
            tagmeta.PublicName      = pTagMeta->PublicName      ;
            tagmeta.Value           = pTagMeta->Value           ;
            tagmeta.ID              = pTagMeta->ID              ;

            m_HeapTagMeta.AddItemToHeap(tagmeta);
        }
    }

    o_columnmeta.Table                  = iTableName_Destination                ;//Index into Pool
    o_columnmeta.Index                  = iColumnIndex_Destination              ;//Column Index
    o_columnmeta.InternalName           = pColumnMeta->InternalName             ;//Index into Pool
    o_columnmeta.PublicName             = pColumnMeta->PublicName               ;//Index into Pool
    o_columnmeta.Type                   = pColumnMeta->Type                     ;//These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    o_columnmeta.Size                   = pColumnMeta->Size                     ;//
    o_columnmeta.MetaFlags              = pColumnMeta->MetaFlags                ;//ColumnMetaFlags defined in CatMeta.xml
    o_columnmeta.DefaultValue           = pColumnMeta->DefaultValue             ;//Only valid for UI4s
    o_columnmeta.FlagMask               = pColumnMeta->FlagMask                 ;//Only valid for flags
    o_columnmeta.StartingNumber         = pColumnMeta->StartingNumber           ;//Only valid for UI4s
    o_columnmeta.EndingNumber           = pColumnMeta->EndingNumber             ;//Only valid for UI4s
    o_columnmeta.CharacterSet           = pColumnMeta->CharacterSet             ;//Index into Pool - Only valid for WSTRs
    o_columnmeta.SchemaGeneratorFlags   = AddUI4ToList(fCOLUMNMETA_PROPERTYISINHERITED | (pColumnMeta->SchemaGeneratorFlags ? UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) : 0));//ColumnMetaFlags defined in CatMeta.xml
    o_columnmeta.ID                     = pColumnMeta->ID                       ;
    o_columnmeta.UserType               = pColumnMeta->UserType                 ;
    o_columnmeta.Attributes             = pColumnMeta->Attributes               ;
	o_columnmeta.Description			= pColumnMeta->Description				;
	o_columnmeta.PublicColumnName		= pColumnMeta->PublicColumnName         ;
    o_columnmeta.ciTagMeta              = 0                                     ;//Count of Tags - Only valid for UI4s
    o_columnmeta.iTagMeta               = 0                                     ;//Index into TagMeta - Only valid for UI4s
    o_columnmeta.iIndexName             = 0                                     ;//IndexName of a single column index (for this column)
}

/*struct ColumnMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Index;                  //UI4       Column Index
    ULONG                       InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Type;                   //UI4       These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    ULONG                       Size;                   //UI4
    ULONG                       MetaFlags;              //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       DefaultValue;           //Bytes
    ULONG                       FlagMask;               //UI4       Only valid for flags
    ULONG                       StartingNumber;         //UI4       Only valid for UI4s
    ULONG                       EndingNumber;           //UI4       Only valid for UI4s
    ULONG                       CharacterSet;           //String    Only valid for Strings
    ULONG                       SchemaGeneratorFlags;   //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       ID;                     //UI4       Metabase ID
    ULONG                       UserType;               //UI4       One of the Metabase UserTypes
    ULONG                       Attributes;             //UI4       Metabase Attribute flags
	ULONG						Description;			//String	Description
	ULONG                       PublicColumnName;       //String    Public Column name (XML Tag)
    ULONG                       ciTagMeta;              //Count of Tags - Only valid for UI4s
    ULONG                       iTagMeta;               //Index into TagMeta - Only valid for UI4s
    ULONG                       iIndexName;             //IndexName of a single column index (for this column)
};*/
void TComCatMetaXmlFile::FillInThePEColumnMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table, unsigned long ParentTable)
{
    ASSERT(0 == Table%4);
    ASSERT(0 == ParentTable%4);

    bool    bColumnMetaFound    = false;
    ULONG   Index               = 0;

    if(ParentTable)//If there is a parent table, the column meta derives from it
    {
        unsigned long iColumnMeta = FindColumnBy_Table_And_Index(ParentTable, AddUI4ToList(0));
        if(-1 == iColumnMeta)
        {
            m_out.printf(L"Error in inheritance chain of Table(%s) - Parent Table must be defined BEFORE inheriting tables.\n", StringFromIndex(Table));
            THROW(ERROR - BAD INHERITANCE);
        }

        ColumnMeta columnmeta;
        for(Index = 0; iColumnMeta<GetCountColumnMeta() && ColumnMetaFromIndex(iColumnMeta)->Table == ParentTable; ++Index, ++iColumnMeta)
        {
            memset(&columnmeta, 0x00, sizeof(columnmeta));

            AddColumnByReference(Table, AddUI4ToList(Index), iColumnMeta, columnmeta);
            m_HeapColumnMeta.AddItemToHeap(columnmeta);
        }

    }


    //Get All ColumnMeta elements under the TableMeta node
    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_TableMeta = pNode_TableMeta;ASSERT(0 != pElement_TableMeta.p);
    CComPtr<IXMLDOMNodeList>    pNodeList_ColumnMeta;
    XIF(pElement_TableMeta->getElementsByTagName(m_bstr_ColumnMeta, &pNodeList_ColumnMeta));

    if(0 == pNodeList_ColumnMeta.p)
        return;

    long cColumnMeta;
    XIF(pNodeList_ColumnMeta->get_length(&cColumnMeta));

    ULONG iColumnMeta_First=-1;
    ULONG cInheritanceWarnings=0;
    wstring wstrIgnoredColumns;

    //Walk the list to the next sibling that is a ColumnMeta element
    while(cColumnMeta--)
    {
        ColumnMeta columnmeta;
        memset(&columnmeta, 0x00, sizeof(columnmeta));

        CComPtr<IXMLDOMNode> pNode_ColumnMeta;
        XIF(pNodeList_ColumnMeta->nextNode(&pNode_ColumnMeta));
        ASSERT(0 != pNode_ColumnMeta.p);

        //Get the attribute map for this element
        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_ColumnMeta_AttributeMap;
        XIF(pNode_ColumnMeta->get_attributes(&pNodeMap_ColumnMeta_AttributeMap));
        ASSERT(0 != pNodeMap_ColumnMeta_AttributeMap.p);//The schema should prevent this.

        //Is this Property inherited?
        CComVariant var_string;
        if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_InheritsColumnMeta, var_string, false))
        {
            //The inheritance string is of the form  TableName:ColumnName
            wchar_t * pTableName = wcstok(var_string.bstrVal, L":");
            wchar_t * pColumnName = wcstok(0, L":");
            if(0==pTableName || 0==pColumnName)
            {
                CComVariant var_string;
                m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_InheritsColumnMeta, var_string);
                m_out.printf(L"Error in inheritance - Table (%s), Property number (%d) attempted to inherit from (%s).  the inheritance must be of the form (TableName:CollumnName)\n", StringFromIndex(Table), Index, var_string.bstrVal);
                THROW(ERROR IN PROERTY INHERITANCE);
            }
            ULONG iColumnInternalName;
            ULONG iColumnMeta = FindColumnBy_Table_And_InternalName(AddWCharToList(pTableName), iColumnInternalName=AddWCharToList(pColumnName));

            if(-1 == iColumnMeta)
            {
                CComVariant var_string;
                m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_InheritsColumnMeta, var_string);
                ++cInheritanceWarnings;
                WCHAR wszTemp[50];
                wsprintf(wszTemp,L"%-38s ", var_string.bstrVal);
                wstrIgnoredColumns += wszTemp;
                wstrIgnoredColumns += (0 == (cInheritanceWarnings & 0x01)) ? L"\n" : L" ";
                //@@@m_out.printf(L"INHERITANCE WARNING! Table (%s) attempted to inherit from (%s) which does not exist.  Property ignored\n", StringFromIndex(Table), var_string.bstrVal);
                continue;//continue without bumping the Index.
            }    
            //Now we tolerate duplicate inherited columns and ignore them
            //so we need to search this table's ColumnMeta for column name we're getting ready to add.
            if(-1 != iColumnMeta_First)
            {
                TColumnMeta columnmetaThis(*this, iColumnMeta_First); 
                ULONG j=iColumnMeta_First;
                for(;j<columnmetaThis.GetCount();++j, columnmetaThis.Next())
                {
                    if(columnmetaThis.Get_pMetaTable()->InternalName == iColumnInternalName)
                        break;
                }
                if(j<columnmetaThis.GetCount())
                {
                    ++cInheritanceWarnings;
                    WCHAR wszTemp[50];
                    wsprintf(wszTemp,L"%-38s", StringFromIndex(iColumnInternalName));
                    wstrIgnoredColumns += wszTemp;
                    wstrIgnoredColumns += (0 == (cInheritanceWarnings & 0x01)) ? L"\n" : L" ";
                    //@@@m_out.printf(L"INHERITANCE WARNING! Table (%s) attempted to inherit from (%s) a second time.  Property ignored\n", StringFromIndex(Table), StringFromIndex(iColumnInternalName));
                    continue;//continue without bumping Index
                }
            }

            AddColumnByReference(Table, AddUI4ToList(Index), iColumnMeta, columnmeta);
            //Now fall through to fill in the rest


            //Table         - Already filled in
            //Index         - Already filled in
            //InternalName  - Already filled in (can't override the InternalName)
            //PublicName
                    ULONG PublicName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_PublicName);
                    if(0 != PublicName)
                        columnmeta.PublicName = PublicName;
            //Type          - Already filled in (can't override the Type)
            //Size          - Already filled in (can't override the Size)
            //MetaFlags
                    ULONG MetaFlags;//We don't want to clobber any MetaFlags that have already been set.
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_ColumnMetaFlags, 0, MetaFlags);
                    //Inheritted properties can only OR in new flags; they can't reset flags to zero.
                    columnmeta.MetaFlags = AddUI4ToList(MetaFlags | UI4FromIndex(columnmeta.MetaFlags));

            //DefaultValue needs to be filled in after MetaFlags, Type and Size and TagMeta
            //FlagMask      - Already filled in
            //StartingNumber
                    ULONG StartingNumber;
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_MinimumValue, StartingNumber, false))
                        columnmeta.StartingNumber = AddUI4ToList(StartingNumber);
            //EndingNumber
                    ULONG EndingNumber;
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_MaximumValue, EndingNumber, false))
                        columnmeta.EndingNumber = AddUI4ToList(EndingNumber);
            //CharacterSet
                    ULONG CharacterSet;
                    if(0 != (CharacterSet = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_CharacterSet)))
                        columnmeta.CharacterSet = CharacterSet;
            //SchemaGeneratorFlags
                    ULONG SchemaGeneratorFlags;
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_SchemaGenFlags, 0, SchemaGeneratorFlags);
                    //Inheritted properties can only OR in new flags; they can't reset flags to zero.
                    columnmeta.SchemaGeneratorFlags = AddUI4ToList(SchemaGeneratorFlags | UI4FromIndex(columnmeta.SchemaGeneratorFlags));
            //ID
                    ULONG ID;
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_ID, ID, false))
                        columnmeta.ID = AddUI4ToList(ID);//Convert to index into aUI4 pool
            //UserType
                    ULONG UserType;
                    if(GetEnum(pNodeMap_ColumnMeta_AttributeMap, m_bstr_UserType, UserType, false))
                        columnmeta.UserType = AddUI4ToList(UserType);
            //Attributes
                    ULONG Attributes;
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_Attributes, 0, Attributes);
                    columnmeta.Attributes = AddUI4ToList(Attributes | UI4FromIndex(columnmeta.Attributes));
			//Description
                    ULONG Description;
                    if(0 != (Description = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_Description)))
                        columnmeta.Description = Description;
        	//PublicColumnName
                    ULONG PublicColumnName;
                    if(0 != (PublicColumnName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_PublicColumnName)))
                        columnmeta.PublicColumnName = PublicColumnName;
        
            //ciTagMeta         inferred later
            //iTagMeta          inferred later
            //iIndexName        inferred later

            //DefaultValue                                                                             
                    ULONG DefaultValue = GetDefaultValue(pNodeMap_ColumnMeta_AttributeMap, columnmeta, false /*don't default a flag value to zero if DefaultValue is not specified*/);
                    if(0 != DefaultValue)
                        columnmeta.DefaultValue = DefaultValue;
                    if(-1 == iColumnMeta_First)
                        iColumnMeta_First = m_HeapColumnMeta.AddItemToHeap(columnmeta)/sizeof(ColumnMeta);
                    else
                        m_HeapColumnMeta.AddItemToHeap(columnmeta);
        }
        else //If the column is inherited and has TagMeta, AddColumnByReference has already filled in the tagmeta
        {
            //We need to know whether there are Flag or Enum child elements
            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_ColumnMeta = pNode_ColumnMeta;ASSERT(0 != pElement_ColumnMeta.p);
            CComPtr<IXMLDOMNodeList>    pNodeList_FlagMeta;
            XIF(pElement_ColumnMeta->getElementsByTagName(m_bstr_FlagMeta, &pNodeList_FlagMeta));

            long cFlagMeta=0;
            if(pNodeList_FlagMeta.p)
            {
                XIF(pNodeList_FlagMeta->get_length(&cFlagMeta));
            }

            long cEnumMeta=0;
            CComPtr<IXMLDOMNodeList>    pNodeList_EnumMeta;
            if(cFlagMeta == 0)
            {
                XIF(pElement_ColumnMeta->getElementsByTagName(m_bstr_EnumMeta, &pNodeList_EnumMeta));
                if(pNodeList_EnumMeta.p)
                {
                    XIF(pNodeList_EnumMeta->get_length(&cEnumMeta));
                }
            }
            //No if cFlagMeta>0 then we set the MetaFlag, fCOLUMNMETA_FLAG.  If cEnumMeta>0 we set the MetaFlag fCOLUMNMETA_ENUM.
            //Table
                    columnmeta.Table = Table;
            //Index
                    columnmeta.Index = AddUI4ToList(Index);
            //InternalName
                    columnmeta.InternalName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_InternalName, true);
            //PublicName
                    columnmeta.PublicName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_PublicName);
            //Type
                    //Get the Type attribute - the Type MUST exist in the OLEDataTypeToXMLDataType array
                    int iOLEDataTypeIndex;
                    Get_OLEDataTypeToXMLDataType_Index(pNodeMap_ColumnMeta_AttributeMap, m_bstr_dbType, iOLEDataTypeIndex);//Get the index into the OLEDataType array
                    columnmeta.Type = AddUI4ToList(OLEDataTypeToXMLDataType[iOLEDataTypeIndex].dbType);
            //Size
                    if(!m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_cbSize, columnmeta.Size, false))
                        columnmeta.Size = OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize;
                    else
                    {
                        if(static_cast<unsigned long>(-1) != OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize &&
                                          columnmeta.Size != OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize)
                        {
                            m_out.printf(L"WARNING!! Bad Size attribute.  A size was specified (%d); but was expecting (%d).  Using expected value of (%d) as the size.\n", columnmeta.Size, OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize, OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize);
                            columnmeta.Size = OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize;
                        }
                    }
                    if(0 == columnmeta.Size)
                    {
                        m_out.printf(L"Error in Size attribute.  A size of 0 was specified.  This size does not make sense.\n");
                        THROW(ERROR - BAD SIZE);
                    }
                    columnmeta.Size = AddUI4ToList(columnmeta.Size);
            //MetaFlags
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_ColumnMetaFlags, 0, columnmeta.MetaFlags);
                    if(columnmeta.MetaFlags & ( fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | 
                                                fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE))
                    {
                        m_out.printf(L"Warning - Table (%s), Column (%s) - Some MetaFlag should be inferred (resetting these flags).  The following flags should NOT be specified by the user.  These flags are inferred:fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE\n", StringFromIndex(columnmeta.Table), StringFromIndex(columnmeta.InternalName));
                        columnmeta.MetaFlags &= ~(fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM |
                                                    fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE);
                    }
                    columnmeta.MetaFlags |= OLEDataTypeToXMLDataType[iOLEDataTypeIndex].fCOLUMNMETA;

                    //There is one case where fCOLUMNMETA_FIXEDLENGTH cannot be determined by the type alone
                    if(columnmeta.Type == DBTYPE_BYTES && columnmeta.Size != -1)//Size == -1 implies NOT FIXEDLENGTH
                        columnmeta.MetaFlags |= fCOLUMNMETA_FIXEDLENGTH;
                    if(cFlagMeta>0)
                        columnmeta.MetaFlags |= fCOLUMNMETA_FLAG;
                    else if(cEnumMeta>0)
                        columnmeta.MetaFlags |= fCOLUMNMETA_ENUM;

                    columnmeta.MetaFlags = AddUI4ToList(columnmeta.MetaFlags);
            //DefaultValue needs to be filled in after MetaFlags, Type and Size and TagMeta
            //FlagMask          inferred later
            //StartingNumber
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_MinimumValue, columnmeta.StartingNumber, false))
                        columnmeta.StartingNumber = AddUI4ToList(columnmeta.StartingNumber);
            //EndingNumber
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_MaximumValue, columnmeta.EndingNumber, false))
                        columnmeta.EndingNumber = AddUI4ToList(columnmeta.EndingNumber);
            //CharacterSet
                    columnmeta.CharacterSet = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_CharacterSet);
            //SchemaGeneratorFlags
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_SchemaGenFlags, 0, columnmeta.SchemaGeneratorFlags);
                    if(columnmeta.SchemaGeneratorFlags & (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED))
                    {
                        m_out.printf(L"Warning - Table (%s), Column (%s) - Some MetaFlagsEx should be inferred (resetting these flags).  The following flags should NOT be specified by the user.  These flags are inferred:fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED\n", StringFromIndex(columnmeta.Table), StringFromIndex(columnmeta.InternalName));
                        columnmeta.SchemaGeneratorFlags &= ~(fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED);
                    }
                    columnmeta.SchemaGeneratorFlags = AddUI4ToList(columnmeta.SchemaGeneratorFlags | OLEDataTypeToXMLDataType[iOLEDataTypeIndex].fCOLUMNSCHEMAGENERATOR);//Some types have inferred SchemaGeneratorFlags
            //ID
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_ID, columnmeta.ID, false))
                        columnmeta.ID = AddUI4ToList(columnmeta.ID);//Convert to index into aUI4 pool
            //UserType
                    if(GetEnum(pNodeMap_ColumnMeta_AttributeMap, m_bstr_UserType, columnmeta.UserType, false))
                        columnmeta.UserType = AddUI4ToList(columnmeta.UserType);
            //Attributes
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_Attributes, 0, columnmeta.Attributes);
                    columnmeta.Attributes = AddUI4ToList(columnmeta.Attributes);
			//Description
                    columnmeta.Description = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_Description);
			//PublicColumnName
                    columnmeta.PublicColumnName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_PublicColumnName);
         
            //ciTagMeta         inferred later
            //iTagMeta          inferred later
            //iIndexName        inferred later

                    if(cFlagMeta>0)
                    {   //Walk the children and build up a TagMeta table and get the FlagMask
                        FillInThePEFlagTagMeta(pNodeList_FlagMeta, Table, columnmeta.Index);
                    }
                    else if(cEnumMeta>0)
                    {   //Walk the children and build up a TagMeta table
                        FillInThePEEnumTagMeta(pNodeList_EnumMeta, Table, columnmeta.Index);
                    }
                    columnmeta.DefaultValue = GetDefaultValue(pNodeMap_ColumnMeta_AttributeMap, columnmeta);
                    if(-1 == iColumnMeta_First)
                        iColumnMeta_First = m_HeapColumnMeta.AddItemToHeap(columnmeta)/sizeof(ColumnMeta);
                    else
                        m_HeapColumnMeta.AddItemToHeap(columnmeta);
        }

        //Bump the Index
        Index++;
    }
    if(0 != cInheritanceWarnings)
    {
        m_out.printf(L"Warning! Table %s contained %d INHERITANCE WARNINGs on columns:\n%s\n", StringFromIndex(Table), cInheritanceWarnings, wstrIgnoredColumns.c_str());;
    }


    if(0 == Index)
    {
        m_out.printf(L"Warning! Table %s contains no %s elements.\n", StringFromIndex(Table), m_bstr_ColumnMeta);
    }
}

/*struct DatabaseMeta
{
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       CountOfTables;          //UI4       Count of tables in database
	ULONG						Description;			//String
	ULONG                       iSchemaBlob;            //Index into Bytes
    ULONG                       cbSchemaBlob;           //Count of Bytes of the SchemaBlob
    ULONG                       iNameHeapBlob;          //Index into Bytes
    ULONG                       cbNameHeapBlob;         //Count of Bytes of the SchemaBlob
    ULONG                       iTableMeta;             //Index into TableMeta
    ULONG                       iGuidDid;               //Index to aGuid where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
};*/
void TComCatMetaXmlFile::FillInThePEDatabaseMeta()
{
    //Get All DatabaseMeta elements
    CComPtr<IXMLDOMNodeList>    pNodeList_DatabaseMeta;
    XIF(m_pXMLDoc->getElementsByTagName(m_bstr_DatabaseMeta, &pNodeList_DatabaseMeta));

    if(0 == pNodeList_DatabaseMeta.p)
    {
        m_out.printf(L"No Database Meta found.  Unable to proceed.\n");
        THROW(No Database Meta found.);
    }

    //Walk the list to the next Database
    while(true)
    {
        DatabaseMeta databasemeta;
        memset(&databasemeta, 0x00, sizeof(databasemeta));//Start with a NULL row

        //Get the next DatabaseMeta node
        CComPtr<IXMLDOMNode> pNode_DatabaseMeta;
        XIF(pNodeList_DatabaseMeta->nextNode(&pNode_DatabaseMeta));
        if(0 == pNode_DatabaseMeta.p)
            break;

        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap;
        XIF(pNode_DatabaseMeta->get_attributes(&pNodeMap));ASSERT(0 != pNodeMap.p);//The schema should prevent this.

//InternalName
        databasemeta.InternalName   = GetString_AndAddToWCharList(pNodeMap, m_bstr_InternalName, true);
//PublicName
        databasemeta.PublicName     = GetString_AndAddToWCharList(pNodeMap, m_bstr_PublicName);
//BaseVersion
        m_pxmlFile->GetNodeValue(pNodeMap, m_bstr_BaseVersion, databasemeta.BaseVersion, false);
        databasemeta.BaseVersion = AddUI4ToList(databasemeta.BaseVersion);//Convert to index into aUI4 pool
//ExtendedVersion
        m_pxmlFile->GetNodeValue(pNodeMap, m_bstr_ExtendedVersion, databasemeta.ExtendedVersion, false);
        databasemeta.ExtendedVersion = AddUI4ToList(databasemeta.ExtendedVersion);//Convert to index into aUI4 pool
//Description
		databasemeta.Description    = GetString_AndAddToWCharList(pNodeMap, m_bstr_Description, false);
//CountOfTables     inferred later
//iSchemaBlob       inferred later
//cbSchemaBlob      inferred later
//iNameHeapBlob     inferred later
//cbNameHeapBlob    inferred later
//iTableMeta        inferred later
//iGuidDid          inferred later


        //Default ServerWiringMeta for this Database
        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_DatabaseMeta = pNode_DatabaseMeta;ASSERT(0 != pElement_DatabaseMeta.p);
        CComPtr<IXMLDOMNodeList> pNodeList_ServerWiring;
		
		// get all serverwiring elements that are defined at Database level. Use select
		// nodes to get the direct children and ignore all the grand-children.
        XIF(pElement_DatabaseMeta->selectNodes(m_bstr_ServerWiring, &pNodeList_ServerWiring));

        long cServerWiring=0;
        if(pNodeList_ServerWiring.p)
        {
            XIF(pNodeList_ServerWiring->get_length(&cServerWiring));//This gets all the descendants, but we only care about the first one.
        }

        if(0 == cServerWiring)
        {
            m_out.printf(L"Error in Database (%s) - At least one ServerWiring element must exist beneath each Database", StringFromIndex(databasemeta.InternalName));
            THROW(ERROR - No ServerWiring Found);
        }

		ServerWiringMeta *pDefaultServerWiring = new ServerWiringMeta[cServerWiring];
		if (pDefaultServerWiring == 0)
		{
			THROW(E_OUTOFMEMORY);
		}

		for (long iServerWiring=0; iServerWiring < cServerWiring; ++iServerWiring)
		{
			CComPtr<IXMLDOMNode> pNode_ServerWiring;
			XIF(pNodeList_ServerWiring->nextNode(&pNode_ServerWiring));

			FillInTheServerWiring(pNode_ServerWiring, 0, 0, pDefaultServerWiring[iServerWiring]);
		}

        FillInThePETableMeta(pNode_DatabaseMeta, databasemeta.InternalName, pDefaultServerWiring, cServerWiring);//WalkTheTableMeta returns the index to the first table. The count is
        m_HeapDatabaseMeta.AddItemToHeap(databasemeta);
    }
}

/*struct TagMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;              //Index into Pool
    ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;        //This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY            InternalName;       //Index into Pool
    ULONG                       PublicName;         //Index into Pool
    ULONG                       Value;
};*/
void TComCatMetaXmlFile::FillInThePEEnumTagMeta(IXMLDOMNodeList *pNodeList_TagMeta, unsigned long Table, unsigned long ColumnIndex)
{
    ASSERT(0 == Table%4);
    ASSERT(0 == ColumnIndex%4);

    long    cEnum;
    XIF(pNodeList_TagMeta->get_length(&cEnum));

    unsigned long NextValue = 0;
    while(cEnum--)
    {
        TagMeta tagmeta;
        memset(&tagmeta, 0x00, sizeof(tagmeta));

        CComPtr<IXMLDOMNode>    pNode_Enum;
        XIF(pNodeList_TagMeta->nextNode(&pNode_Enum));ASSERT(0 != pNode_Enum.p);

        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_Enum;
        XIF(pNode_Enum->get_attributes(&pNodeMap_Enum));ASSERT(0 != pNodeMap_Enum.p);//The schema should prevent this.

//Table
        tagmeta.Table = Table;
//ColumnIndex
        tagmeta.ColumnIndex = ColumnIndex;
//InternalName
        tagmeta.InternalName = GetString_AndAddToWCharList(pNodeMap_Enum, m_bstr_InternalName, true);
//PublicName
        tagmeta.PublicName = GetString_AndAddToWCharList(pNodeMap_Enum, m_bstr_PublicName);
//Value
        tagmeta.Value = NextValue;
        m_pxmlFile->GetNodeValue(pNodeMap_Enum, m_bstr_Value, tagmeta.Value, false);
        NextValue = tagmeta.Value+1;
        tagmeta.Value = AddUI4ToList(tagmeta.Value);
//ID
        m_pxmlFile->GetNodeValue(pNodeMap_Enum, m_bstr_ID, tagmeta.ID, false);
        tagmeta.ID = AddUI4ToList(tagmeta.ID);//Convert to index into aUI4 pool

        m_HeapTagMeta.AddItemToHeap(tagmeta);
    }
}

/*struct TagMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;              //Index into Pool
    ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;        //This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY            InternalName;       //Index into Pool
    ULONG                       PublicName;         //Index into Pool
    ULONG                       Value;
};*/
void TComCatMetaXmlFile::FillInThePEFlagTagMeta(IXMLDOMNodeList *pNodeList_TagMeta, unsigned long Table, unsigned long ColumnIndex)
{
    ASSERT(0 == Table%4);
    ASSERT(0 == ColumnIndex%4);

    long    cFlag;
    XIF(pNodeList_TagMeta->get_length(&cFlag));

    unsigned long NextValue = 1;
    while(cFlag--)
    {
        TagMeta tagmeta;
        memset(&tagmeta, 0x00, sizeof(tagmeta));

        CComPtr<IXMLDOMNode>    pNode_Flag;
        XIF(pNodeList_TagMeta->nextNode(&pNode_Flag));ASSERT(0 != pNode_Flag.p);

        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_Flag;
        XIF(pNode_Flag->get_attributes(&pNodeMap_Flag));ASSERT(0 != pNodeMap_Flag.p);//The schema should prevent this.

//Table
        tagmeta.Table = Table;
//ColumnIndex
        tagmeta.ColumnIndex = ColumnIndex;
//InternalName
        tagmeta.InternalName = GetString_AndAddToWCharList(pNodeMap_Flag, m_bstr_InternalName, true);
//PublicName
        tagmeta.PublicName = GetString_AndAddToWCharList(pNodeMap_Flag, m_bstr_PublicName);
//Value
        tagmeta.Value = NextValue;
        m_pxmlFile->GetNodeValue(pNodeMap_Flag, m_bstr_Value, tagmeta.Value, false);
        if(0 != (tagmeta.Value & (tagmeta.Value-1)))//This yields zero for all powers of two
            m_out.printf(L"WARNING! - Flag Value (0x%08x) is not a power of two.  Table (%s), Flag (%s)\n", tagmeta.Value, StringFromIndex(Table), StringFromIndex(tagmeta.InternalName));

        NextValue = tagmeta.Value<<1;
        if(0 == tagmeta.Value)//A flag value of zero is OK but it messes up our inferrence, so after a flag of value 0, the next flag is 1
            NextValue = 1;

        tagmeta.Value = AddUI4ToList(tagmeta.Value);
//ID
        m_pxmlFile->GetNodeValue(pNodeMap_Flag, m_bstr_ID, tagmeta.ID, false);
        tagmeta.ID = AddUI4ToList(tagmeta.ID);//Convert to index into aUI4 pool

        m_HeapTagMeta.AddItemToHeap(tagmeta);
    }
}

/*struct IndexMeta
{
    ULONG PRIMARYKEY    Table;                          //String
    ULONG PRIMARYKEY    InternalName;                   //String
    ULONG               PublicName;                     //String
    ULONG PRIMARYKEY    ColumnIndex;                    //UI4       This is the iOrder member of the ColumnMeta
    ULONG               ColumnInternalName;             //String
    ULONG               MetaFlags;                      //UI4       Index Flag
};*/
void TComCatMetaXmlFile::FillInThePEIndexMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table)
{
    ASSERT(0 == Table%4);

    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_TableMeta = pNode_TableMeta;ASSERT(0 != pElement_TableMeta.p);
    CComPtr<IXMLDOMNodeList>    pNodeList_IndexMeta;
    XIF(pElement_TableMeta->getElementsByTagName(m_bstr_IndexMeta, &pNodeList_IndexMeta));

    long cIndexMeta=0;
    if(pNodeList_IndexMeta.p)
    {
        XIF(pNodeList_IndexMeta->get_length(&cIndexMeta));
    }

    //Walk the IndexMeta for this table
    while(cIndexMeta--)
    {
        IndexMeta indexmeta;
        memset(&indexmeta, 0x00, sizeof(indexmeta));

        CComPtr<IXMLDOMNode>    pNode_IndexMeta;
        XIF(pNodeList_IndexMeta->nextNode(&pNode_IndexMeta));

        //Get the attribute map for this element
        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_IndexMetaAttributeMap;
        XIF(pNode_IndexMeta->get_attributes(&pNodeMap_IndexMetaAttributeMap));ASSERT(0 != pNodeMap_IndexMetaAttributeMap.p);//The schema should prevent this.

//Table
        indexmeta.Table = Table;
//InternalName
        indexmeta.InternalName = GetString_AndAddToWCharList(pNodeMap_IndexMetaAttributeMap, m_bstr_InternalName, true);
//PublicName
        indexmeta.PublicName = GetString_AndAddToWCharList(pNodeMap_IndexMetaAttributeMap, m_bstr_PublicName);
//ColumnIndex           Filled in below
//ColumnInternalName    Filled in below
//MetaFlags
        GetFlags(pNodeMap_IndexMetaAttributeMap, m_bstr_MetaFlags, 0, indexmeta.MetaFlags);
        indexmeta.MetaFlags = AddUI4ToList(indexmeta.MetaFlags);

        CComVariant     varColumnInternalNames;
        m_pxmlFile->GetNodeValue(pNodeMap_IndexMetaAttributeMap, m_bstr_ColumnInternalName, varColumnInternalNames);

        wchar_t * pszColumnInternalName = wcstok(varColumnInternalNames.bstrVal, L" ");
        unsigned int ColumnIndex = 0;
        while(pszColumnInternalName != 0)
        {
//ColumnInternalName
            indexmeta.ColumnInternalName = AddWCharToList(pszColumnInternalName);
            ULONG iColumnMeta = FindColumnBy_Table_And_InternalName(Table, indexmeta.ColumnInternalName);
            if(-1 == iColumnMeta)
            {
                m_out.printf(L"IndexMeta Error - ColumnInternalName (%s) not found in table.\n", StringFromIndex(Table));
                THROW(ERROR IN INDEXMETA - INVALID INTERNALCOLNAME);
            }

//ColumnIndex
            indexmeta.ColumnIndex = ColumnMetaFromIndex(iColumnMeta)->Index;
            m_HeapIndexMeta.AddItemToHeap(indexmeta);

            pszColumnInternalName = wcstok(0, L" ");//Next token (next Flag RefID)
        }
    }
}

/*struct QueryMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Index;                  //UI4
    ULONG                       CellName;               //String
    ULONG                       Operator;               //UI4
    ULONG                       MetaFlags;              //UI4
};*/
void TComCatMetaXmlFile::FillInThePEQueryMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table)
{
    ASSERT(0 == Table%4);

    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_TableMeta = pNode_TableMeta;ASSERT(0 != pElement_TableMeta.p);
    CComPtr<IXMLDOMNodeList>    pNodeList_QueryMeta;
    XIF(pElement_TableMeta->getElementsByTagName(m_bstr_QueryMeta, &pNodeList_QueryMeta));

    long cQueryMeta=0;
    if(pNodeList_QueryMeta)
    {
        XIF(pNodeList_QueryMeta->get_length(&cQueryMeta));
    }

    ULONG PrevInternalName=-1;
    ULONG Index=0;
    while(cQueryMeta--)
    {
        QueryMeta querymeta;
        memset(&querymeta, 0x00, sizeof(querymeta));

        CComPtr<IXMLDOMNode>    pNode_QueryMeta;
        XIF(pNodeList_QueryMeta->nextNode(&pNode_QueryMeta));

        //Get the attribute map for this element
        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_QueryMetaAttributeMap;
        XIF(pNode_QueryMeta->get_attributes(&pNodeMap_QueryMetaAttributeMap));ASSERT(0 != pNodeMap_QueryMetaAttributeMap.p);//The schema should prevent this.

//Table
        querymeta.Table = Table;
//InternalName
        querymeta.InternalName = GetString_AndAddToWCharList(pNodeMap_QueryMetaAttributeMap, m_bstr_InternalName, true);
//PublicName
        querymeta.PublicName = GetString_AndAddToWCharList(pNodeMap_QueryMetaAttributeMap, m_bstr_PublicName);
//Index     Filled in below
//CellName
        querymeta.CellName = GetString_AndAddToWCharList(pNodeMap_QueryMetaAttributeMap, m_bstr_CellName, false);
//Operator
        GetEnum(pNodeMap_QueryMetaAttributeMap, m_bstr_Operator, querymeta.Operator, false);
        querymeta.Operator = AddUI4ToList(querymeta.Operator);//convert to index into the pool
//MetaFlags
        GetFlags(pNodeMap_QueryMetaAttributeMap, m_bstr_MetaFlags, 0, querymeta.MetaFlags);
        querymeta.MetaFlags = AddUI4ToList(querymeta.MetaFlags);//convert to index into pool

//Index
        Index = (querymeta.CellName == PrevInternalName) ? Index+1 : 0;
        querymeta.Index = AddUI4ToList(Index);

        m_HeapQueryMeta.AddItemToHeap(querymeta);

        PrevInternalName = querymeta.InternalName;//Remember the InternalName so we can bump the index
    }
}

/*struct RelationMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY PrimaryTable;           //String
    ULONG                       PrimaryColumns;         //Bytes
    ULONG PRIMARYKEY FOREIGNKEY ForeignTable;           //String
    ULONG                       ForeignColumns;         //Bytes
    ULONG                       MetaFlags;
};*/
void TComCatMetaXmlFile::FillInThePERelationMeta()
{
    //Get All RelationMeta elements
    CComPtr<IXMLDOMNodeList>    pNodeList_RelationMeta;
    XIF(m_pXMLDoc->getElementsByTagName(m_bstr_RelationMeta, &pNodeList_RelationMeta));

    long cRelations=0;
    if(pNodeList_RelationMeta.p)
    {
        XIF(pNodeList_RelationMeta->get_length(&cRelations));
    }
    if(0 == cRelations)
        return;

    m_out.printf(L"Filling in RelationMeta\n");
    //Walk the list to the next RelationMeta
    while(cRelations--)
    {
        RelationMeta relationmeta;

        //Get the next DatabaseMeta node
        CComPtr<IXMLDOMNode> pNode_RelationMeta;
        XIF(pNodeList_RelationMeta->nextNode(&pNode_RelationMeta));
        ASSERT(0 != pNode_RelationMeta.p);

        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_RelationMetaAttributeMap;
        XIF(pNode_RelationMeta->get_attributes(&pNodeMap_RelationMetaAttributeMap));ASSERT(0 != pNodeMap_RelationMetaAttributeMap.p);//The schema should prevent this.

//PrimaryTable
        relationmeta.PrimaryTable = GetString_AndAddToWCharList(pNodeMap_RelationMetaAttributeMap, m_bstr_PrimaryTable, true);
//PrimaryColumns
        CComVariant     varPrimaryColumns;
        m_pxmlFile->GetNodeValue(pNodeMap_RelationMetaAttributeMap, m_bstr_PrimaryColumns, varPrimaryColumns, true);
        relationmeta.PrimaryColumns = AddArrayOfColumnsToBytePool(relationmeta.PrimaryTable, varPrimaryColumns.bstrVal);
//ForeignTable
        relationmeta.ForeignTable = GetString_AndAddToWCharList(pNodeMap_RelationMetaAttributeMap, m_bstr_ForeignTable, true);
//ForeignColumns
        CComVariant     varForeignColumns;
        m_pxmlFile->GetNodeValue(pNodeMap_RelationMetaAttributeMap, m_bstr_ForeignColumns, varForeignColumns, true);
        relationmeta.ForeignColumns = AddArrayOfColumnsToBytePool(relationmeta.ForeignTable, varForeignColumns.bstrVal);
//MetaFlags
        GetFlags(pNodeMap_RelationMetaAttributeMap, m_bstr_MetaFlags, 0, relationmeta.MetaFlags);
        relationmeta.MetaFlags = AddUI4ToList(relationmeta.MetaFlags);

        m_HeapRelationMeta.AddItemToHeap(relationmeta);
    }
}

void TComCatMetaXmlFile::FillInThePEServerWiringMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table, ServerWiringMeta *pDefaultServerWiring, ULONG cNrDefaultServerWiring)
{
    //Get the list of ServerWiringMeta children
    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_TableMeta = pNode_TableMeta;ASSERT(0 != pElement_TableMeta.p);
    CComPtr<IXMLDOMNodeList> pNodeList_ServerWiring;
    XIF(pElement_TableMeta->getElementsByTagName(m_bstr_ServerWiring, &pNodeList_ServerWiring));

    ULONG   cServerWiring=0;
    if(pNodeList_ServerWiring.p)
    {
        XIF(pNodeList_ServerWiring->get_length(reinterpret_cast<long *>(&cServerWiring)));
    }

    if(0 == cServerWiring)//If none specified then use the DefaultServerWiring
    {
		for (ULONG iServerWiring=0; iServerWiring<cNrDefaultServerWiring; ++iServerWiring)
		{
			ServerWiringMeta serverwiring;
			memcpy(&serverwiring, pDefaultServerWiring + iServerWiring, sizeof(serverwiring));
			serverwiring.Table = Table;
			m_HeapServerWiringMeta.AddItemToHeap(serverwiring);
		}
    }
    else//otherwise walk the list of ServerWiring and add them to the heap
    {
        for(ULONG iServerWiring=0; iServerWiring<cServerWiring; ++iServerWiring)
        {
            CComPtr<IXMLDOMNode> pNode_ServerWiring;
            XIF(pNodeList_ServerWiring->nextNode(&pNode_ServerWiring));

            ServerWiringMeta serverwiring;
            FillInTheServerWiring(pNode_ServerWiring, Table, iServerWiring, serverwiring);
            m_HeapServerWiringMeta.AddItemToHeap(reinterpret_cast<const unsigned char *>(&serverwiring), sizeof(serverwiring));
        }
    }
}

/*struct TableMeta
{
    ULONG FOREIGNKEY            Database;               //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       PublicRowName;          //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       NameColumn;             //UI4       iOrder of the NameColumn
    ULONG                       NavColumn;              //UI4       iOrder of the NavColumn
    ULONG                       CountOfColumns;         //UI4       Count of Columns
    ULONG                       MetaFlags;              //UI4       TableMetaFlags are defined in CatInpro.meta
    ULONG                       SchemaGeneratorFlags;   //UI4       SchemaGenFlags are defined in CatInpro.meta
    ULONG                       ConfigItemName;         //String
    ULONG                       ConfigCollectionName;   //String
	ULONG						Description				//String
    ULONG                       PublicRowNameColumn;    //UI4       If PublicRowName is NULL, this specifies the column whose enum values represent possible PublicRowNames
    ULONG                       ciRows;                 //Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
    ULONG                       iColumnMeta;            //Index into ColumnMeta
    ULONG                       iFixedTable;            //Index into g_aFixedTable
    ULONG                       cPrivateColumns;        //This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
    ULONG                       cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG                       iIndexMeta;             //Index into IndexMeta
    ULONG                       iHashTableHeader;       //If the table is a fixed table, then it will have a hash table.
    ULONG                       nTableID;               //This is a 24 bit Hash of the Table name.
    ULONG                       iServerWiring;          //Index into the ServerWiringHeap (this is a temporary hack for CatUtil)
    ULONG                       cServerWiring;          //Count of ServerWiring (this is a temporary hack for CatUtil)
};
*/
void TComCatMetaXmlFile::FillInThePETableMeta(IXMLDOMNode *pNode_DatabaseMeta, 
											  unsigned long Database, 
											  ServerWiringMeta *pDefaultServerWiring,
											  ULONG cNrDefaultServerWiring)
{
    //Get All TableMeta elements under the Database node
    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_DatabaseMeta = pNode_DatabaseMeta;ASSERT(0 != pElement_DatabaseMeta.p);
    CComPtr<IXMLDOMNodeList> pNodeList_TableMeta;
    XIF(pElement_DatabaseMeta->getElementsByTagName(m_bstr_TableMeta, &pNodeList_TableMeta));

    if(0 == pNodeList_TableMeta.p)
        return;

    long cTableMeta;
    XIF(pNodeList_TableMeta->get_length(&cTableMeta));

    //Walk the list to the next sibling that is a ColumnMeta element
    while(cTableMeta--)
    {
        TableMeta tablemeta;
        memset(&tablemeta, 0x00, sizeof(tablemeta));

        CComPtr<IXMLDOMNode> pNode_TableMeta;
        XIF(pNodeList_TableMeta->nextNode(&pNode_TableMeta));
        ASSERT(0 != pNode_TableMeta.p);

        //Get the attribute map for this element
        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_TableMetaAttributeMap;
        XIF(pNode_TableMeta->get_attributes(&pNodeMap_TableMetaAttributeMap));ASSERT(0 != pNodeMap_TableMetaAttributeMap.p);//The schema should prevent this.

//Database
        tablemeta.Database = Database;
//InternalName
        tablemeta.InternalName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_InternalName, true);
//PublicName
        tablemeta.PublicName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_PublicName);
//PublicRowName
        tablemeta.PublicRowName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_PublicRowName);
//BaseVersion
        m_pxmlFile->GetNodeValue(pNodeMap_TableMetaAttributeMap, m_bstr_BaseVersion, tablemeta.BaseVersion, false);
        tablemeta.BaseVersion = AddUI4ToList(tablemeta.BaseVersion);//convert to index to UI4 pool
//ExtendedVersion
        m_pxmlFile->GetNodeValue(pNodeMap_TableMetaAttributeMap, m_bstr_ExtendedVersion, tablemeta.ExtendedVersion, false);
        tablemeta.ExtendedVersion = AddUI4ToList(tablemeta.ExtendedVersion);//convert to index to UI4 pool
//NameColumn    inferred later
//NavColumn     inferred later
//CountOfColumn inferred later
//MetaFlags
        GetFlags(pNodeMap_TableMetaAttributeMap, m_bstr_TableMetaFlags, 0, tablemeta.MetaFlags);
        tablemeta.MetaFlags = AddUI4ToList(tablemeta.MetaFlags);
//SchemaGeneratorFlags
        GetFlags(pNodeMap_TableMetaAttributeMap, m_bstr_SchemaGenFlags, 0, tablemeta.SchemaGeneratorFlags);
        if(tablemeta.SchemaGeneratorFlags & (fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED))
        {
            m_out.printf(L"Warning - Table (%s) - Some TableMeta::MetaFlagsEx should be inferred (resetting these flags).  The following flags should NOT be specified by the user.  These flags are inferred:fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED\n", StringFromIndex(tablemeta.InternalName));
            tablemeta.SchemaGeneratorFlags &= ~(fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED);
        }
        tablemeta.SchemaGeneratorFlags = AddUI4ToList(tablemeta.SchemaGeneratorFlags);
//ConfigItemName
        tablemeta.ConfigItemName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_ConfigItemName);
//ConfigCollectionName
        tablemeta.ConfigCollectionName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_ConfigCollectionName);
//PublicRowNameColumn inferred later
//ContainerClassList
        tablemeta.ContainerClassList = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_ContainerClassList);
//Description
		tablemeta.Description = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_Description);
//ChildElementName
		tablemeta.ChildElementName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_ChildElementName);

        //This allows us to specify the ColumnMeta for one table and inherit all the properties without specifying them in another.
        ULONG ParentTableMeta = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_InheritsColumnMeta);

        FillInThePEColumnMeta(pNode_TableMeta, tablemeta.InternalName, ParentTableMeta);
        FillInThePEIndexMeta(pNode_TableMeta, tablemeta.InternalName);
        FillInThePEQueryMeta(pNode_TableMeta, tablemeta.InternalName);
        FillInThePEServerWiringMeta(pNode_TableMeta, tablemeta.InternalName, pDefaultServerWiring, cNrDefaultServerWiring);

        m_HeapTableMeta.AddItemToHeap(tablemeta);
    }
}

/*struct ServerWiringMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Order;                  //UI4
    ULONG                       ReadPlugin;             //UI4
	ULONG						ReadPluginDLLName;      //String
    ULONG                       WritePlugin;            //UI4
	ULONG						WritePluginDLLName;		//String
    ULONG                       Interceptor;            //UI4
    ULONG                       InterceptorDLLName;     //String
    ULONG                       Flags;                  //UI4       Last, NoNext, First, Next
    ULONG                       Locator;                //String
    ULONG                       Reserved;               //UI4       for Protocol.  Protocol may be needed for managed property support
    ULONG                       Merger;                 //UI4       
    ULONG                       MergerDLLName;          //String       
};*/
void TComCatMetaXmlFile::FillInTheServerWiring(IXMLDOMNode *pNode_ServerWiring, ULONG Table, ULONG Order, TableSchema::ServerWiringMeta &serverwiring)
{
    memset(&serverwiring, 0x00, sizeof(serverwiring));

    CComPtr<IXMLDOMNamedNodeMap> pNodeMap_ServerWiring;
    XIF(pNode_ServerWiring->get_attributes(&pNodeMap_ServerWiring));ASSERT(0 != pNodeMap_ServerWiring.p);//The schema should prevent this.

//Table
    serverwiring.Table = Table;
//Order
    serverwiring.Order = AddUI4ToList(Order);
//ReadPlugin
    GetEnum(pNodeMap_ServerWiring, m_bstr_ReadPlugin,  serverwiring.ReadPlugin);//This will set the ReadPlugin to zero if it's not specified
    serverwiring.ReadPlugin = AddUI4ToList(serverwiring.ReadPlugin);
//ReadPluginDLLName
    serverwiring.ReadPluginDLLName = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_ReadPluginDLLName);
//WritePlugin
    GetEnum(pNodeMap_ServerWiring, m_bstr_WritePlugin, serverwiring.WritePlugin);//This will set the WritePlugin to zero if it's not specified
    serverwiring.WritePlugin = AddUI4ToList(serverwiring.WritePlugin);
//WritePluginDLLName
    serverwiring.WritePluginDLLName = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_WritePluginDLLName);
//Interceptor
    GetEnum(pNodeMap_ServerWiring, m_bstr_Interceptor, serverwiring.Interceptor);//This will set the Interceptor to zero if it's not specified
    serverwiring.Interceptor = AddUI4ToList(serverwiring.Interceptor);
//InterceptorDLLName
    serverwiring.InterceptorDLLName = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_InterceptorDLLName);
//Flags
    GetFlags(pNodeMap_ServerWiring, m_bstr_MetaFlags, 0, serverwiring.Flags);
    serverwiring.Flags = AddUI4ToList(serverwiring.Flags);
//Locator
    serverwiring.Locator = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_Locator);
//Reserved
//Merger
    GetEnum(pNodeMap_ServerWiring, m_bstr_Merger, serverwiring.Merger);//This will set the WritePlugin to zero if it's not specified
    serverwiring.Merger= AddUI4ToList(serverwiring.Merger);
//Interceptor
    serverwiring.MergerDLLName = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_MergerDLLName);
}


void TComCatMetaXmlFile::Get_OLEDataTypeToXMLDataType_Index(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, int &i) const
{
    CComVariant     var_dbType;
    m_pxmlFile->GetNodeValue(pMap, bstr, var_dbType);

    for(i=0;i<numelementsOLEDataTypeToXMLDataType;i++)//Walk the list to find the 
        if(0 == _wcsicmp(OLEDataTypeToXMLDataType[i].String, var_dbType.bstrVal))
            return;

    m_out.printf(L"Error - Unknown Datatype: %s\n", var_dbType.bstrVal);
    THROW(ERROR - UNKNOWN DATATYPE);
}


unsigned long TComCatMetaXmlFile::GetDefaultValue(IXMLDOMNamedNodeMap *pMap, ColumnMeta &columnMeta, bool bDefaultFlagToZero)
{
    CComVariant     varDafaultValue;
    if(!m_pxmlFile->GetNodeValue(pMap, m_bstr_DefaultValue, varDafaultValue, false))
    {
        if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FLAG && bDefaultFlagToZero)
        {
            unsigned long x = 0;
            return AddBytesToList(reinterpret_cast<unsigned char *>(&x), sizeof(ULONG));//infer a default value of 0 for flags.
        }
        return 0;
    }

    switch(UI4FromIndex(columnMeta.Type))
    {
    case DBTYPE_GUID:
        {
            GUID guid;
            if(FAILED(UuidFromString(varDafaultValue.bstrVal, &guid)))
            {
                m_out.printf(L"Error in DefaultValue:  Value (%s) was expected to be type UUID.\n", varDafaultValue.bstrVal);
                THROW(ERROR IN DEFAULT VALUE);
            }
            return AddBytesToList(reinterpret_cast<unsigned char *>(&guid), sizeof(GUID));
        }
    case DBTYPE_WSTR:
        if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_MULTISTRING)
        {
            ULONG ulStrLen = lstrlen(varDafaultValue.bstrVal);
            if((ulStrLen+2)*sizeof(WCHAR) > UI4FromIndex(columnMeta.Size))
            {
                m_out.printf(L"Error in DefaultValue: DefaultValue (%s) is too big.  Maximum size is %d.\n",varDafaultValue.bstrVal, UI4FromIndex(columnMeta.Size));
                THROW(ERROR DEFAULT VALUE TOO BIG);
            }
            if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH)
            {
                m_out.printf(L"Error in DefaultValue - 'Defaulting a FIXEDLENGTH - MULTISTRING is not yet supported");
                THROW(ERROR NOT SUPPORTED);
            }
            if(0==ulStrLen)
            {
                WCHAR  wszDoubleNULL[2];
                wszDoubleNULL[0] = 0x00;
                wszDoubleNULL[1] = 0x00;
                return AddBytesToList(reinterpret_cast<unsigned char *>(wszDoubleNULL), 2 * sizeof(WCHAR));
            }

            LPWSTR pMultiString = new WCHAR [ulStrLen+2];
            if(0 == pMultiString)
            {
                THROW(ERROR - OUT OF MEMORY);
            }
            pMultiString[0] = 0x00;

            LPWSTR token = wcstok(varDafaultValue.bstrVal, L"|\r\n");
            ULONG cchMultiString = 0;
            while(token)
            {
                LPWSTR wszTemp = token;
                while(*wszTemp==L' ' || *wszTemp==L'\t' || *wszTemp==L'\r')//ignore leading spaces and tabs
                {
                    wszTemp++;
                }
                if(0 == *wszTemp)//and if only tabs and spaces exist then bail
                    break;

				ULONG iLen = (ULONG) wcslen (wszTemp);
				while (iLen > 0 && (wszTemp[iLen-1]==L' ' || wszTemp[iLen-1]==L'\t' || wszTemp[iLen-1]==L'\r'))//ignore trailing spaces and tabs
					iLen--;
				
                wcsncpy(pMultiString + cchMultiString, wszTemp, iLen);
				pMultiString[cchMultiString + iLen] = L'\0';
                cchMultiString += (iLen + 1);

                token = wcstok(0, L"|\r\n");//ignore spaces and tabs
            }
            pMultiString[cchMultiString++] = 0x00;//put the second NULL
            unsigned long lRtn = AddBytesToList(reinterpret_cast<unsigned char *>(pMultiString), cchMultiString * sizeof(WCHAR));
            delete [] pMultiString;
            return lRtn;//return the index past the size
        }
        if((UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) && (lstrlen(varDafaultValue.bstrVal)+1)*sizeof(WCHAR) > UI4FromIndex(columnMeta.Size))
        {
            m_out.printf(L"Error in DefaultValue: DefaultValue (%s) is too big.  Maximum size is %d.\n",varDafaultValue.bstrVal, UI4FromIndex(columnMeta.Size));
            THROW(ERROR DEFAULT VALUE TOO BIG);
        }
        if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH)
        {
            ULONG cbSize = (ULONG)((-1==UI4FromIndex(columnMeta.Size) ? sizeof(WCHAR)*(wcslen(varDafaultValue.bstrVal)+1) : UI4FromIndex(columnMeta.Size)));
            WCHAR * wszTemp = new WCHAR [cbSize/sizeof(WCHAR)];
            if(0 == wszTemp)
                THROW(ERROR - OUT OF MEMORY);
            memset(wszTemp, 0x00, cbSize);
            wcscpy(wszTemp, varDafaultValue.bstrVal);
            return AddBytesToList(reinterpret_cast<unsigned char *>(wszTemp), cbSize);
        }
        return AddBytesToList(reinterpret_cast<unsigned char *>(varDafaultValue.bstrVal), sizeof(WCHAR)*(wcslen(varDafaultValue.bstrVal)+1));
    case DBTYPE_UI4:
        ULONG ui4;
        if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_BOOL)
        {
            static WCHAR * kwszBoolStrings[] = {L"false", L"true", L"0", L"1", L"no", L"yes", L"off", L"on", 0};

            if(varDafaultValue.bstrVal[0]>=L'0' && varDafaultValue.bstrVal[0]<=L'9')
            {   //Accept a numeric value for bool
                ui4 = _wtol(varDafaultValue.bstrVal);
                if(ui4 > 1)//print a warning if the numeric is not 0 or 1.
                    m_out.printf(L"Warning!  Table (%s), Numeric DefaultValue (%u) specified - expecting bool.\r\n", StringFromIndex(columnMeta.InternalName), ui4);
            }
            else
            {
                unsigned long iBoolString;
                for(iBoolString=0; kwszBoolStrings[iBoolString] &&
                    (0 != _wcsicmp(kwszBoolStrings[iBoolString], varDafaultValue.bstrVal)); ++iBoolString);

                if(0 == kwszBoolStrings[iBoolString])
                {
                    m_out.printf(L"Error in DefaultValue: Bool (%s) is not a valid value for column %s.\n    The following are the only legal Bool values (case insensitive):\n    false, true, 0, 1, no, yes, off, on.\n", varDafaultValue.bstrVal, StringFromIndex(columnMeta.InternalName));
                    THROW(ERROR - INVALID BOOL FOR DEFAULT VALUE);
                }

                ui4 = (iBoolString & 0x01);
            }
        }
        else if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_ENUM)//if enum, just scan the TagMeta for the matching InternalName, and return the value of the Tag
        {
            ui4 = 0;
            bool bFound=false;
            ULONG iTagMeta;
            for(iTagMeta = GetCountTagMeta()-1; iTagMeta != -1 && (TagMetaFromIndex(iTagMeta)->Table == columnMeta.Table);--iTagMeta)
            {
#ifdef DEBUG
                TagMeta * pTagMeta = TagMetaFromIndex(iTagMeta);
                LPCWSTR   wszInternalName = StringFromIndex(TagMetaFromIndex(iTagMeta)->InternalName);
#endif
                if((TagMetaFromIndex(iTagMeta)->ColumnIndex == columnMeta.Index) && 
                    0 == lstrcmpi(varDafaultValue.bstrVal, StringFromIndex(TagMetaFromIndex(iTagMeta)->InternalName)))
                {
                    ui4 = UI4FromIndex(TagMetaFromIndex(iTagMeta)->Value);
                    bFound=true;
                    break;
                }
            }
            if(!bFound)
            {
                m_out.printf(L"Error in DefaultValue: Enum (%s) is not a valid Tag for column %s.\n", varDafaultValue.bstrVal, StringFromIndex(columnMeta.InternalName));
                THROW(ERROR - INVALID ENUM FOR DEFAULT VALUE);
            }
        }
        else if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FLAG)//if flag, walk the list of flags, find the matching Tag and OR in its value.
        {
            ui4 = 0;
            LPWSTR token = wcstok(varDafaultValue.bstrVal, L" ,|");

            //We allow defaults to specify a numeric instead of strings
            if(token && *token>=L'0' && *token<=L'9')
            {
                ui4 = _wtol(token);
                m_out.printf(L"Warning!  Table (%s), Numeric DefaultValue (%u) specified - expecting flags.\r\n", StringFromIndex(columnMeta.InternalName), ui4);
            }
            else
            {
                while(token)
                {
                    bool bFound=false;
                    ULONG iTagMeta;
                    for(iTagMeta = GetCountTagMeta()-1; iTagMeta != -1 && (TagMetaFromIndex(iTagMeta)->Table == columnMeta.Table);--iTagMeta)
                    {
                        if(TagMetaFromIndex(iTagMeta)->ColumnIndex == columnMeta.Index &&
                            0 == lstrcmpi(token, StringFromIndex(TagMetaFromIndex(iTagMeta)->InternalName)))
                        {
                            bFound=true;
                            break;
                        }
                    }
                    if(!bFound)
                    {
                        m_out.printf(L"Error in DefaultValue: Flag (%s) is not a valid Tag for column %s.\n", token, StringFromIndex(columnMeta.InternalName));
                        THROW(ERROR - INVALID FLAG FOR DEFAULT VALUE);
                    }
                    ui4 |= UI4FromIndex(TagMetaFromIndex(iTagMeta)->Value);
                    token = wcstok(0, L" ,|");
                }
            }
        }
        else if(*varDafaultValue.bstrVal == L'-' || (*varDafaultValue.bstrVal >= L'0' && *varDafaultValue.bstrVal <= L'9'))
        {
            ui4 = _wtol(varDafaultValue.bstrVal);
        }
        else
        {
            m_out.printf(L"Error in DefaultValue:  Only UI4s of type Enum or Flag may specify non numeric values for DefaultValue.  %s is illegal.\n", varDafaultValue.bstrVal);
            THROW(ERROR - ILLEGAL DEFAULT VALUE);
        }
        return AddBytesToList(reinterpret_cast<unsigned char *>(&ui4), sizeof(ULONG));
    case DBTYPE_BYTES:
        {
            unsigned long   cbString = lstrlen(varDafaultValue.bstrVal)/2;
            unsigned long   cbArray = (UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) ? UI4FromIndex(columnMeta.Size) : cbString;
            if(cbString != cbArray)
            {
                m_out.printf(L"WARNING!  DefaultValue (%s) does not match Size (%d).  Filling remainder of byte array with zeroes.\n", varDafaultValue.bstrVal, UI4FromIndex(columnMeta.Size));
            }

            unsigned char * byArray = new unsigned char [cbArray];
            if((UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) && cbArray > UI4FromIndex(columnMeta.Size))
            {
                m_out.printf(L"Error in DefaultValue: DefaultValue (%s) is too big.  Maximum size is %d.\n",varDafaultValue.bstrVal, UI4FromIndex(columnMeta.Size));
                THROW(ERROR DEFAULT VALUE TOO BIG);
            }

            if(0 == byArray)
            {
                m_out.printf(L"Error - Out of memory.\n");
                THROW(OUT OF MEMORY);
            }
            if(cbArray > cbString)
                memset(byArray, 0x00, cbArray);
            //Convert the string into a byte array
            m_pxmlFile->ConvertWideCharsToBytes(varDafaultValue.bstrVal, byArray, cbString);
            unsigned long lRtn = AddBytesToList(byArray, cbArray);//AddBytesToList just slams the bytes into the pool (prepending the length) and returns the index to bytes
            delete [] byArray;
            return lRtn;//return the index past the size
        }
    default:
        ASSERT(false && L"Bad Type");
    }
    return S_OK;

}


bool TComCatMetaXmlFile::GetEnum(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, unsigned long &Enum, bool bMustExists) const
{
    Enum = 0;

    CComVariant     var;
    if(!m_pxmlFile->GetNodeValue(pMap, bstr, var, bMustExists))//get the string of the enum
        return false;

    CComPtr<IXMLDOMNodeList>    pNodeList;
    XIF(m_pXMLDocMetaMeta->getElementsByTagName(m_bstr_EnumMeta, &pNodeList));//get all of the EnumMeta elements

    long cEnums=0;
    if(pNodeList.p)
    {
        XIF(pNodeList->get_length(&cEnums));
    }

    for(long i=0; i<cEnums; ++i)
    {
        CComPtr<IXMLDOMNode>    pNodeEnum;
        XIF(pNodeList->nextNode(&pNodeEnum));

        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement = pNodeEnum;ASSERT(0 != pElement.p);//Get the IXMLDOMElement interface pointer

        CComVariant             var_Name;
        XIF(pElement->getAttribute(m_bstr_InternalName, &var_Name));

        if(0 == lstrcmpi(var_Name.bstrVal, var.bstrVal))//if we found a matching enum
        {
            CComVariant             var_Value;
            XIF(pElement->getAttribute(m_bstr_Value, &var_Value));
            Enum = wcstol(var_Value.bstrVal, 0, 10);
            return true;
        }
    }

    if(i == cEnums)
    {
        m_out.printf(L"Error - Unknown enum (%s) specified.\n", var.bstrVal);
        THROW(ERROR - UNKNOWN FLAG);
    }

    return false;
}


void TComCatMetaXmlFile::GetFlags(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, LPCWSTR /*Flag Type Not Used*/, unsigned long &lFlags) const
{
    lFlags = 0;//start off with lFlags at zero

    CComVariant     var;
    if(!m_pxmlFile->GetNodeValue(pMap, bstr, var, false))
        return;

    CComPtr<IXMLDOMNodeList>    pNodeList;
    XIF(m_pXMLDocMetaMeta->getElementsByTagName(m_bstr_FlagMeta, &pNodeList));

    long cFlags=0;
    if(pNodeList.p)
    {
        XIF(pNodeList->get_length(&cFlags));
    }

    wchar_t *       pszFlag;
    pszFlag = wcstok(var.bstrVal, L" |,");
    while(pszFlag != 0)
    {
        XIF(pNodeList->reset());

        for(long i=0; i<cFlags; ++i)
        {
            CComPtr<IXMLDOMNode>    pNodeFlag;
            XIF(pNodeList->nextNode(&pNodeFlag));

            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement = pNodeFlag;ASSERT(0 != pElement.p);//Get the IXMLDOMElement interface pointer

            CComVariant             var_Name;
            XIF(pElement->getAttribute(m_bstr_InternalName, &var_Name));

            if(0 == lstrcmpi(var_Name.bstrVal, pszFlag))//if we found a matching flag
            {
                CComVariant             var_Value;
                XIF(pElement->getAttribute(m_bstr_Value, &var_Value));
                lFlags |= wcstol(var_Value.bstrVal, 0, 10);
                break;
            }
        }

        if(i == cFlags)
        {
            m_out.printf(L"Error - Unknown flag (%s) specified.\n", pszFlag);
            THROW(ERROR - UNKNOWN FLAG);
        }
        pszFlag = wcstok(0, L" ,|");//Next token (next Flag RefID)
    }
}


unsigned long TComCatMetaXmlFile::GetString_AndAddToWCharList(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, bool bMustExist)
{
    CComVariant var_string;
    if(!m_pxmlFile->GetNodeValue(pMap, bstr, var_string, bMustExist))//if it must exist and doesn't an exception will be thrown
        return 0;                                        //if it doesn't have to exist AND the attribute doesn't exist then return 0 (which indicates 0 length string)
    return AddWCharToList(var_string.bstrVal);           //if it does exist then add it to the list of WChars
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tcolumnmeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TCOLUMNMETA_H__
#define __TCOLUMNMETA_H__

#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif
#ifndef __TTAGMETA_H__
    #include "TTagMeta.h"
#endif

/*
struct ColumnMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Index;                  //UI4       Column Index
    ULONG                       InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Type;                   //UI4       These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    ULONG                       Size;                   //UI4
    ULONG                       MetaFlags;              //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       DefaultValue;           //Bytes
    ULONG                       FlagMask;               //UI4       Only valid for flags
    ULONG                       StartingNumber;         //UI4       Only valid for UI4s
    ULONG                       EndingNumber;           //UI4       Only valid for UI4s
    ULONG                       CharacterSet;           //String    Only valid for Strings
    ULONG                       SchemaGeneratorFlags;   //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       ID;                     //UI4       Metabase ID
    ULONG                       UserType;               //UI4       One of the Metabase UserTypes
    ULONG                       Attributes;             //UI4       Metabase Attribute flags
    ULONG                       ciTagMeta;              //Count of Tags - Only valid for UI4s
    ULONG                       iTagMeta;               //Index into TagMeta - Only valid for UI4s
    ULONG                       iIndexName;             //IndexName of a single column index (for this column)
	ULONG						Description;			//String	Description
	ULONG                       PublicColumnName;       //String    PublicColumnName
};
*/

class TColumnMeta : public TMetaTable<ColumnMeta>
{
public:
    TColumnMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<ColumnMeta>(fixup,i){}
    const WCHAR * Get_Table               () const {return m_Fixup.StringFromIndex( Get_MetaTable().Table                );}
    const ULONG * Get_Index               () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().Index                );}
    const WCHAR * Get_InternalName        () const {return m_Fixup.StringFromIndex( Get_MetaTable().InternalName         );}
    const WCHAR * Get_PublicName          () const {return m_Fixup.StringFromIndex( Get_MetaTable().PublicName           );}
    const WCHAR * Get_PublicColumnName    () const {return m_Fixup.StringFromIndex( Get_MetaTable().PublicColumnName           );}
    const ULONG * Get_Type                () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().Type                 );}
    const ULONG * Get_Size                () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().Size                 );}
    const ULONG * Get_MetaFlags           () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().MetaFlags            );}
    const BYTE  * Get_DefaultValue        () const {return m_Fixup.ByteFromIndex(   Get_MetaTable().DefaultValue         );}
    const ULONG * Get_FlagMask            () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().FlagMask             );}
    const ULONG * Get_StartingNumber      () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().StartingNumber       );}
    const ULONG * Get_EndingNumber        () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().EndingNumber         );}
    const WCHAR * Get_CharacterSet        () const {return m_Fixup.StringFromIndex( Get_MetaTable().CharacterSet         );}
    const ULONG * Get_SchemaGeneratorFlags() const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().SchemaGeneratorFlags );}
    const ULONG * Get_ID                  () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().ID                   );}
    const ULONG * Get_UserType            () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().UserType             );}
    const ULONG * Get_Attributes          () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().Attributes           );}
          ULONG   Get_ciTagMeta           () const {return Get_MetaTable().ciTagMeta;}
          ULONG   Get_iTagMeta            () const {return Get_MetaTable().iTagMeta;}
    const WCHAR * Get_iIndexName          () const {return m_Fixup.StringFromIndex( Get_MetaTable().iIndexName           );}
	const WCHAR * Get_Description         () const {return m_Fixup.StringFromIndex( Get_MetaTable().Description          );}

    //Warning!! Users should not rely on this pointer once a Column is added, since the add could cause a relocation of the data.
    virtual ColumnMeta *Get_pMetaTable  ()       {return m_Fixup.ColumnMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount      () const {return m_Fixup.GetCountColumnMeta();};
    const ColumnMeta & Get_MetaTable () const {return *m_Fixup.ColumnMetaFromIndex(m_iCurrent);}
};

#endif //__TCOLUMNMETA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tcomplibcompilationplugin.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TCOMPLIBCOMPILATIONPLUGIN_H__
#define __TCOMPLIBCOMPILATIONPLUGIN_H__

#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif
#ifndef __complib_h__
    #include "complib.h"
#endif
#ifndef __ICR_SCHEMA__
    #include "icmprecs.h"
#endif

class TComplibCompilationPlugin : public ICompilationPlugin
{
public:
    TComplibCompilationPlugin();
    ~TComplibCompilationPlugin();

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    TPEFixup *          m_pFixup;
    TOutput  *          m_pOut;

    HRESULT GenerateCLBSchemaBlobs();
    HRESULT _AddTableToSchema(ULONG iDabaseMeta, ULONG iTableMeta, TABLEID tableId, IComponentRecordsSchema* pICRSchema);
};



#endif // __TCOMPLIBCOMPILATIONPLUGIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tcomcatmetaxmlfile.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TCOMCATMETAXMLFILE_H__
#define __TCOMCATMETAXMLFILE_H__

//The only non-standard header that we need for the class declaration is TOutput
#ifndef __OUTPUT_H__
    #include "Output.h"
#endif
#ifndef __TFIXUPHEAPS_H__
    #include "TFixupHeaps.h"
#endif
#ifndef __TXMLFILE_H__
    #include "TXmlFile.h"
#endif
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif
#ifndef __THEAP_H__
    #include "THeap.h"
#endif

class TComCatMetaXmlFile : public TFixupHeaps
{
public:
    TComCatMetaXmlFile(TXmlFile *pXmlFile, int cXmlFile, TOutput &out);//We do everything we need with XmlFile in the ctor so we don't keep it around
    ~TComCatMetaXmlFile(){}
    static LPCWSTR              m_szComCatMetaSchema;

private:
    //ComCatMeta Elements and Attributes
    const CComBSTR              m_bstr_Attributes;
    const CComBSTR              m_bstr_BaseVersion;
    const CComBSTR              m_bstr_cbSize;
    const CComBSTR              m_bstr_CellName;
    const CComBSTR              m_bstr_CharacterSet;
    const CComBSTR              m_bstr_ChildElementName;
    const CComBSTR              m_bstr_ColumnInternalName;
    const CComBSTR              m_bstr_ColumnMeta;
    const CComBSTR              m_bstr_ColumnMetaFlags;
    const CComBSTR              m_bstr_ConfigItemName;
    const CComBSTR              m_bstr_ConfigCollectionName;
    const CComBSTR              m_bstr_ContainerClassList;
    const CComBSTR              m_bstr_DatabaseInternalName;
    const CComBSTR              m_bstr_DatabaseMeta;
    const CComBSTR              m_bstr_dbType;
    const CComBSTR              m_bstr_DefaultValue;
	const CComBSTR				m_bstr_Description;
    const CComBSTR              m_bstr_EnumMeta;
    const CComBSTR              m_bstr_ExtendedVersion;
    const CComBSTR              m_bstr_FlagMeta;
    const CComBSTR              m_bstr_ForeignTable;
    const CComBSTR              m_bstr_ForeignColumns;
    const CComBSTR              m_bstr_ID;
    const CComBSTR              m_bstr_IndexMeta;
    const CComBSTR              m_bstr_InheritsColumnMeta;
    const CComBSTR              m_bstr_Interceptor;
	const CComBSTR              m_bstr_InterceptorDLLName;
    const CComBSTR              m_bstr_InternalName;
    const CComBSTR              m_bstr_Locator;
    const CComBSTR              m_bstr_MaximumValue;
    const CComBSTR              m_bstr_Merger;
    const CComBSTR              m_bstr_MergerDLLName;
    const CComBSTR              m_bstr_MetaFlags;
    const CComBSTR              m_bstr_MinimumValue;
    const CComBSTR              m_bstr_NameValueMeta;
    const CComBSTR              m_bstr_Operator;
    const CComBSTR              m_bstr_PrimaryTable;
    const CComBSTR              m_bstr_PrimaryColumns;
    const CComBSTR              m_bstr_PublicName;
    const CComBSTR              m_bstr_PublicRowName;
	const CComBSTR				m_bstr_PublicColumnName;
    const CComBSTR              m_bstr_QueryMeta;
    const CComBSTR              m_bstr_ReadPlugin;
	const CComBSTR				m_bstr_ReadPluginDLLName;
    const CComBSTR              m_bstr_RelationMeta;
    const CComBSTR              m_bstr_SchemaGenFlags;
    const CComBSTR              m_bstr_ServerWiring;
    const CComBSTR              m_bstr_TableMeta;
    const CComBSTR              m_bstr_TableMetaFlags;
    const CComBSTR              m_bstr_UserType;
    const CComBSTR              m_bstr_Value;
    const CComBSTR              m_bstr_WritePlugin;
	const CComBSTR				m_bstr_WritePluginDLLName;


    TOutput &                   m_out;
    IXMLDOMDocument *           m_pXMLDoc;//This is only valid during construction
    IXMLDOMDocument *           m_pXMLDocMetaMeta;
    TXmlFile                  * m_pxmlFile;

    static LPCWSTR              m_szNameLegalCharacters;

    unsigned long   AddArrayOfColumnsToBytePool(unsigned long iTableMeta, LPWSTR wszColumnNames);
    void            AddColumnByReference(ULONG iTableName_Destination, ULONG iColumnIndex_Destination, ULONG iColumnMeta_Source, ColumnMeta &o_columnmeta);
    void            FillInThePEColumnMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table, unsigned long ParentTable);
    void            FillInThePEDatabaseMeta();
    void            FillInThePEEnumTagMeta(IXMLDOMNodeList *pNodeList_TagMeta, unsigned long Table, unsigned long ColumnIndex);
    void            FillInThePEFlagTagMeta(IXMLDOMNodeList *pNodeList_TagMeta, unsigned long Table, unsigned long ColumnIndex);
    void            FillInThePEIndexMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table);
    void            FillInThePEQueryMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table);
    void            FillInThePERelationMeta();
    void            FillInThePETableMeta(IXMLDOMNode *pNode_DatabaseMeta, unsigned long Database, ServerWiringMeta *pDefaultServerWiring, ULONG cNrDefaultServerWiring);
    void            FillInTheServerWiring(IXMLDOMNode *pNode_ServerWiring, ULONG Table, ULONG Order, TableSchema::ServerWiringMeta &serverwiring);
    void            FillInThePEServerWiringMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table, ServerWiringMeta *pDefaultServerWiring, ULONG cNrDefaultServerWiring);
    void            Get_OLEDataTypeToXMLDataType_Index(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, int &i) const;
    unsigned long   GetDefaultValue(IXMLDOMNamedNodeMap *pMap, ColumnMeta &columnMeta, bool bDefaultFlagToZero=true);
    bool            GetEnum(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, unsigned long &Enum, bool bMustExists=false) const;
    void            GetFlags(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, LPCWSTR szFlagType, unsigned long &lFlags) const;
    unsigned long   GetString_AndAddToWCharList(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, bool bMustExist=false);
};

struct GlobalRowCounts 
{
    ULONG cCoreTables;
    ULONG cCoreDatabases;
    ULONG cCoreColumns;
    ULONG cCoreTags;
    ULONG cCoreIndexes;
    ULONG cCoreRelations;
    ULONG cCoreQueries;
};

#endif // __TCOMCATMETAXMLFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tcomplibcompilationplugin.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TCOMPLIBCOMPILATIONPLUGIN_H__
    #include "TComplibCompilationPlugin.h"
#endif

#define SCHEMATEMPCLBFILE L"blobgen.clb"


TComplibCompilationPlugin::TComplibCompilationPlugin() :
                 m_pFixup(0)
                ,m_pOut(0)
{
}

TComplibCompilationPlugin::~TComplibCompilationPlugin()
{
}

void TComplibCompilationPlugin::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;
    
    HRESULT hr;
    if(FAILED(hr = GenerateCLBSchemaBlobs()))
    {
        m_pOut->printf(L"Error creating CLBSchemaBlobs\n");
        THROW(ERROR CREATING CLBSCHEMABLOBS);
    }
}

//***********************************************************************************************************
//Generating Complib schema blobs from the existing information in pFixup, then fill in the blobs into pFixup
//***********************************************************************************************************
HRESULT TComplibCompilationPlugin::GenerateCLBSchemaBlobs()
{
    CComPtr<IComponentRecords> pICRTemp;
    HRESULT hr = S_OK;
    ULONG i = 0;

    m_pOut->printf(L"generating Complib schema blobs...\n");

    hr = OpenComponentLibraryEx( SCHEMATEMPCLBFILE, DBPROP_TMODEF_WRITE|DBPROP_TMODEF_READ, &pICRTemp, NULL);

    if ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = CreateComponentLibraryEx( SCHEMATEMPCLBFILE, DBPROP_TMODEF_DFTWRITEMASK, &pICRTemp, NULL);
        if ( FAILED( hr ) ) goto ErrExit;

        hr = pICRTemp->Save( NULL );
        if ( FAILED( hr ) ) goto ErrExit;

        hr = S_OK;
    }

    if ( FAILED (hr) ) goto ErrExit;

    pICRTemp.Release();

    //For each database, generating complib schema blobs.
    for ( i = 0; i < m_pFixup->GetCountDatabaseMeta(); i ++ )
    {
        CComPtr<IComponentRecordsSchema> pICRSchema;
        CComPtr<IComponentRecords> pICR;
        ULONG iTableMeta = m_pFixup->DatabaseMetaFromIndex(i)->iTableMeta;
        ULONG iStart = iTableMeta;
        ULONG cTableMeta = m_pFixup->UI4FromIndex(m_pFixup->DatabaseMetaFromIndex(i)->CountOfTables);
        TABLEID tableId = 0;

        ULONG cbSchemaSize = 0;
        BYTE*  pSchema = NULL;  
        ULONG cbNameHeap = 0;
        HGLOBAL  hNameHeap = 0;
        
        
        unsigned char GuidDid[sizeof(GUID)];
        memset(GuidDid, 0x00, sizeof(GUID));
        wcsncpy(reinterpret_cast<LPWSTR>(GuidDid), m_pFixup->StringFromIndex(m_pFixup->DatabaseMetaFromIndex(i)->InternalName), sizeof(GUID)/sizeof(WCHAR));
        m_pFixup->DatabaseMetaFromIndex(i)->iGuidDid    = m_pFixup->AddBytesToList(GuidDid, sizeof(GUID));//The database InternalName cast to a GUID

        //check for fTABLEMETA_EMITCLBBLOB flag, skip all non-clb tables. 
        while((iTableMeta<(iStart+cTableMeta) && !(m_pFixup->UI4FromIndex(m_pFixup->TableMetaFromIndex(iTableMeta)->SchemaGeneratorFlags) & fTABLEMETA_EMITCLBBLOB)))
        {
            iTableMeta++;
        }

        if ( iTableMeta == iStart + cTableMeta )
            continue;

        //Found the first table that has fTABLEMETA_EMITCLBBLOB flag, create the ICR 
        //instance that will help us to generate the blob.
        m_pOut->printf(L"Generating blobs for database %s.\n",m_pFixup->StringFromIndex(m_pFixup->DatabaseMetaFromIndex(i)->InternalName));
        
        hr = OpenComponentLibraryEx( SCHEMATEMPCLBFILE, DBPROP_TMODEF_WRITE|DBPROP_TMODEF_READ, &pICR, NULL );
        if ( FAILED( hr ) ) goto ErrExit;

        hr = pICR->QueryInterface( IID_IComponentRecordsSchema, (void**)&pICRSchema );
        if ( FAILED( hr ) ) goto ErrExit;

        hr = _AddTableToSchema(i, iTableMeta, tableId, pICRSchema);
        if ( FAILED( hr ) ) goto ErrExit;
        tableId++;
        iTableMeta++;

        //Walk through the rest of the tables
        while (  iTableMeta < iStart + cTableMeta )
        {
            if ( m_pFixup->UI4FromIndex(m_pFixup->TableMetaFromIndex(iTableMeta)->SchemaGeneratorFlags) & fTABLEMETA_EMITCLBBLOB )
            {
                _AddTableToSchema( i, iTableMeta, tableId, pICRSchema);
                tableId++;
            }

            iTableMeta++;
        }

        //Generating the blobs
        hr = pICRSchema->GetSchemaBlob( &cbSchemaSize, &pSchema, &cbNameHeap, &hNameHeap );
        if ( FAILED( hr ) ) goto ErrExit;

        m_pOut->printf(L"\tGenerated Blobs: schema %d bytes, name heap %d bytes.\n",cbSchemaSize,cbNameHeap );

        //Add the blobs to the m_Fixups structures
        m_pFixup->DatabaseMetaFromIndex(i)->iSchemaBlob = m_pFixup->AddBytesToList( pSchema, cbSchemaSize );
        m_pFixup->DatabaseMetaFromIndex(i)->cbSchemaBlob = cbSchemaSize;

        BYTE    *pbData;
        pbData = (BYTE *) GlobalLock(hNameHeap);
        m_pFixup->DatabaseMetaFromIndex(i)->iNameHeapBlob = m_pFixup->AddBytesToList( pbData, cbNameHeap );
        m_pFixup->DatabaseMetaFromIndex(i)->cbNameHeapBlob = cbNameHeap;

        GlobalUnlock(pbData);
        GlobalFree(hNameHeap);
    }

ErrExit:

    DeleteFile( SCHEMATEMPCLBFILE );

    return hr;
        
}


//**********************************************************************************************************
//Helper function. Get meta from pFixup, fill into ICRSchema structures
//**********************************************************************************************************
HRESULT TComplibCompilationPlugin::_AddTableToSchema(ULONG iDabaseMeta, ULONG iTableMeta, TABLEID tableId, IComponentRecordsSchema* pICRSchema)
{
    HRESULT hr = S_OK;

    //Get the pointer to the current TableMeta struct
    TableMeta* pCurTableMeta = m_pFixup->TableMetaFromIndex(iTableMeta);
    m_pOut->printf(L"\tCreating Table %s.\n", m_pFixup->StringFromIndex(pCurTableMeta->InternalName));

    //Get the count of columns for this table.
    ULONG cColumns = m_pFixup->UI4FromIndex(pCurTableMeta->CountOfColumns);

    //Get the start index of this table's columns in the ColumnMeta table
    ULONG iColumnMeta = pCurTableMeta->iColumnMeta;

    DBINDEXCOLUMNDESC *pKeys = NULL;    //multi-column PK info
    ULONG i,j;

    ICRSCHEMA_COLUMN*   pColumnDefs = new ICRSCHEMA_COLUMN[cColumns];
    if ( !pColumnDefs )
        return E_OUTOFMEMORY;

    ULONG cPK = 0;  //count of PK columns

    ULONG cIndexMeta = pCurTableMeta->cIndexMeta; //count of Indexmeta entries associated
                                                  //with this table

    DBINDEXCOLUMNDESC *pIndexDecs = NULL;         //Index info
    
    memset( pColumnDefs, 0, sizeof( ICRSCHEMA_COLUMN ) * cColumns);

    for ( i = 0; i < cColumns; i ++ )
    {
            
        //Get the pointer to the current ColumnMeta struct
        ColumnMeta * pCurColumnMeta = m_pFixup->ColumnMetaFromIndex(i + iColumnMeta);

        //copy the column name
        wcscpy( pColumnDefs[i].rcColumn, m_pFixup->StringFromIndex(pCurColumnMeta->InternalName));
        //Validate the column size if within the limit
        //To Do: validate through meta database instead. 
        if ( wcslen( pColumnDefs[i].rcColumn ) + 1  >= MAXCOLNAME )
        {
            m_pOut->printf(L"%s is too long, column internal name can't exceed %d characters",
                             pColumnDefs[i].rcColumn, MAXCOLNAME-1 );
            hr = E_FAIL;
            goto ErrExit;
        }
         
        // Multistrings are handled as bytes in the clb.
        if ( ( m_pFixup->UI4FromIndex(pCurColumnMeta->MetaFlags) & fCOLUMNMETA_MULTISTRING) &&
			 ( eCOLUMNMETA_String == m_pFixup->UI4FromIndex(pCurColumnMeta->Type) ) )
		{
			pColumnDefs[i].wType = static_cast<DBTYPE>(eCOLUMNMETA_BYTES);
        }
		else
		{
	        pColumnDefs[i].wType = static_cast<DBTYPE>(m_pFixup->UI4FromIndex(pCurColumnMeta->Type));
		}

        pColumnDefs[i].Ordinal = static_cast<USHORT>(m_pFixup->UI4FromIndex(pCurColumnMeta->Index) + 1 );

        pColumnDefs[i].cbSize = m_pFixup->UI4FromIndex(pCurColumnMeta->Size);

        if ( ! (m_pFixup->UI4FromIndex(pCurColumnMeta->MetaFlags) & fCOLUMNMETA_NOTNULLABLE) )
            pColumnDefs[i].fFlags |= ICRSCHEMA_COL_NULLABLE;

        if ( m_pFixup->UI4FromIndex(pCurColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY )
        {
            pColumnDefs[i].fFlags |= ICRSCHEMA_COL_PK;
            //Primary key can't be null.
            pColumnDefs[i].fFlags &= ~ICRSCHEMA_COL_NULLABLE;
            cPK ++;
        }

        if ( m_pFixup->UI4FromIndex(pCurColumnMeta->MetaFlags) & fCOLUMNMETA_CASEINSENSITIVE )
            pColumnDefs[i].fFlags |= ICRSCHEMA_COL_CASEINSEN;
    }

    WCHAR       rcTable[MAXTABLENAME];
    wcscpy( rcTable, m_pFixup->StringFromIndex(m_pFixup->DatabaseMetaFromIndex(iDabaseMeta)->InternalName));
    wcscat( rcTable, L".");
    wcscat( rcTable, m_pFixup->StringFromIndex(pCurTableMeta->InternalName));


    //Validate the table size is within the limit
    //To Do: validate through meta database instead. 
    if ( wcslen( rcTable ) + 1  >= MAXTABLENAME )
    {
        m_pOut->printf(L"%s is too long, table internal name plus database internal name can't exceed %d characters",
                         rcTable, MAXTABLENAME-2 );
        hr = E_FAIL;
        goto ErrExit;
    }

    hr = pICRSchema->CreateTableEx(rcTable,
                                   cColumns,
                                   pColumnDefs,
                                   0,
                                   0,
                                   tableId,
                                   cPK > 1? TRUE:FALSE
                                   );
        
    if ( FAILED( hr ) ) goto ErrExit;

    
    //If PK is on multilple columns, we need to build a unique hashed key index
    if ( cPK > 1 )
    {
        ICRSCHEMA_INDEX indexDef;
        memset( &indexDef, 0, sizeof(ICRSCHEMA_INDEX) );
        ULONG iKeyColumn = 0;

        _snwprintf(indexDef.rcIndex, MAXINDEXNAME, L"MPK_%s", m_pFixup->StringFromIndex(pCurTableMeta->InternalName));
        indexDef.fFlags = ICRSCHEMA_DEX_UNIQUE | ICRSCHEMA_DEX_PK;
        indexDef.RowThreshold = 16;
        indexDef.Type = ICRSCHEMA_TYPE_HASHED;
        indexDef.Keys = static_cast<USHORT>(cPK);

        pKeys = new DBINDEXCOLUMNDESC[cPK];
        if ( !pKeys )
        {
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        } 

        memset( pKeys, 0, sizeof( DBINDEXCOLUMNDESC ) * cPK );
        

        //Walk through the ICRSCHEMA_COLUMN array to pick up the PK column names
        for ( j = 0; j < cColumns; j ++ )
        {
            if ( pColumnDefs[j].fFlags & ICRSCHEMA_COL_PK )
            {
                pKeys[iKeyColumn].eIndexColOrder = DBINDEX_COL_ORDER_ASC;
                pKeys[iKeyColumn].pColumnID = new DBID;
                if ( !pKeys[iKeyColumn].pColumnID )
                {
                    hr = E_OUTOFMEMORY;
                    goto ErrExit;
                } 

                pKeys[iKeyColumn].pColumnID->eKind = DBKIND_NAME;
                pKeys[iKeyColumn].pColumnID->uName.pwszName = pColumnDefs[j].rcColumn;

                iKeyColumn ++;
                if ( iKeyColumn == cPK )
                    break;
            }
        }

        m_pOut->printf(L"\tCreating Index %s.\n", indexDef.rcIndex);
        hr = pICRSchema->CreateIndexEx(rcTable,
                                       &indexDef,
                                       pKeys
                                       );
        if ( FAILED( hr ) ) goto ErrExit;

    }   //if ( cPK > 1 )

    //Read index meta, create index for this table. 
    if ( cIndexMeta > 0 )
    {
        TIndexMeta  tIndexMeta( *m_pFixup, pCurTableMeta->iIndexMeta);  //Helper class
        ICRSCHEMA_INDEX indexDef;
        pIndexDecs = new DBINDEXCOLUMNDESC[cIndexMeta];
        if ( !pIndexDecs )
        {
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        } 

        memset( pIndexDecs, 0, sizeof( DBINDEXCOLUMNDESC ) * cIndexMeta );
    
        i = 0;
        while( i < cIndexMeta )
        {
            memset( &indexDef, 0, sizeof(ICRSCHEMA_INDEX) );
            //Tranlate IndexMeta to ICRSCHEMA_INDEX
            wcscpy( indexDef.rcIndex, tIndexMeta.Get_InternalName() );
            
            //Validate index name is within the limit
            //To Do: validate through meta database instead. 
            if ( wcslen( indexDef.rcIndex ) + 1  >= MAXINDEXNAME )
            {
                m_pOut->printf(L"%s is too long, index internal name can't exceed %d characters",
                                 indexDef.rcIndex, MAXINDEXNAME-1 );
                hr = E_FAIL;
                goto ErrExit;
            }


            if ( *tIndexMeta.Get_MetaFlags() & fINDEXMETA_SORTED )
                indexDef.Type = ICRSCHEMA_TYPE_SORTED;
            else
                indexDef.Type = ICRSCHEMA_TYPE_HASHED;

            indexDef.fFlags = 0;

            if ( *tIndexMeta.Get_MetaFlags() & fINDEXMETA_UNIQUE)
                indexDef.fFlags = ICRSCHEMA_DEX_UNIQUE;

            indexDef.RowThreshold = 16;
 
            j = 0;
            //Get the names of the columns current index builds on.
            do{
            
                if ( !pIndexDecs[j].pColumnID )
                {
                    pIndexDecs[j].pColumnID = new DBID;
                    if ( !pIndexDecs[j].pColumnID )
                    {
                        hr = E_OUTOFMEMORY;
                        goto ErrExit;
                    } 

                    pIndexDecs[j].eIndexColOrder = DBINDEX_COL_ORDER_ASC;
                    pIndexDecs[j].pColumnID->eKind = DBKIND_NAME;
                }
            
                pIndexDecs[j].pColumnID->uName.pwszName = (LPWSTR)(tIndexMeta.Get_ColumnInternalName());

                tIndexMeta.Next();
                j++;
                
            
            }while ( i+j < cIndexMeta && wcscmp( tIndexMeta.Get_InternalName(), indexDef.rcIndex ) == 0  );
            indexDef.Keys = static_cast<USHORT>(j);

            m_pOut->printf(L"\tCreating Index %s.\n", indexDef.rcIndex);
            hr = pICRSchema->CreateIndexEx(rcTable,
                                           &indexDef,
                                           pIndexDecs
                                           );

            if ( FAILED( hr ) ) goto ErrExit;

            i += j; 

        }   //while( i < cIndexMeta )
    }   //if ( cIndexMeta > 0 )

        

ErrExit:

    if ( pColumnDefs )
        delete [] pColumnDefs;

    if ( pKeys )
    {
        for ( i = 0; i < cPK; i ++ )
        {
            if ( pKeys[i].pColumnID )
                delete pKeys[i].pColumnID;
        }

        delete [] pKeys;
    }

    if ( pIndexDecs )
    {
        for ( i = 0; i < cIndexMeta; i ++ )
        {
            if ( pIndexDecs[i].pColumnID )
                delete pIndexDecs[i].pColumnID;
        }

        delete [] pIndexDecs;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tfile.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TFILE_H__
#define __TFILE_H__

//The only non-standard header that we need for the class declaration is TException
#ifndef __TEXCEPTION_H__
    #include "TException.h"
#endif

class TFile
{
public:
    TFile(LPCWSTR wszFileName, TOutput &out, bool bBinary=false, LPSECURITY_ATTRIBUTES psa=0);
    virtual ~TFile();

    void Write(LPCSTR szBuffer, unsigned int nNumChars) const;
    void Write(const unsigned char *pch, unsigned int nNumChars) const;
    void Write(unsigned char ch) const;
    void Write(unsigned long ul) const;
    void Write(LPCWSTR wszBuffer, unsigned int nNumWCHARs);
private:
    HANDLE m_hFile;
    char * m_pBuffer;
    unsigned int m_cbSizeOfBuffer;

};


class TMetaFileMapping
{
public:
    TMetaFileMapping(LPCWSTR filename);
    ~TMetaFileMapping();
    unsigned long Size() const {return m_Size;}
    unsigned char * Mapping() const {return m_pMapping;}

private:
    HANDLE          m_hFile;
    HANDLE          m_hMapping;
    unsigned char * m_pMapping;
    unsigned long   m_Size;
};
#endif //__TFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tfixedtableheapbuilder.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TFIXEDTABLEHEAPBUILDER_H__
    #include "TFixedTableHeapBuilder.h"
#endif
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif




TFixedTableHeapBuilder::TFixedTableHeapBuilder() :
                 m_pFixup(0)
                ,m_pOut(0)
{
}

TFixedTableHeapBuilder::~TFixedTableHeapBuilder()
{
}

void TFixedTableHeapBuilder::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    BuildMetaTableHeap();
}

//The FixedTableHeap is layed out as follows, the fixed length data comes first
//All indexes listed below are byte offsets from the beginning of the FixedTableHeap.  All indexes within the structs are indexes within
//other structs.  For example, DatabaseMeta has a provate column that gives an index to the first table belonging to the database.  That
//index is a TableMeta struct array index (&aTableMeta[index]); it is NOT a byte offset.
/*
0   ULONG           kFixedTableHeapSignature0
1   ULONG           kFixedTableHeapSignature1
2   ULONG           kFixedTableHeapKey
3   ULONG           kFixedTableHeapVersion
4   ULONG           kcbHeap
5   ULONG           EndOfHeap                                       This is the byte offset just beyond the heap.  All indexes should be less than this (this is basically just the size of the heap)

6   ULONG           iColumnMeta                                     This is the byte offset to the aColumnMeta
7   ULONG           cColumnMeta

8   ULONG           iDatabaseMeta
9   ULONG           cDatabaseMeta

A   ULONG           iHashTableHeap
B   ULONG           cbHashTableHeap                                 Size of the HashTableHeap in count of bytes

C   ULONG           iIndexMeta
D   ULONG           cIndexMeta

E   ULONG           iPooledHeap                                     All data is stored in a pooled heap (including UI4s)
F   ULONG           cbPooledHeap                                    Size of the Pooled Heap in count of bytes

10  ULONG           iQueryMeta
11  ULONG           cQueryMeta

12  ULONG           iRelationMeta
13  ULONG           cRelationMeta

14  ULONG           iServerWiringMeta
15  ULONG           cServerWiringMeta

16  ULONG           iTableMeta
17  ULONG           cTableMeta

18  ULONG           iTagMeta
19  ULONG           cTagMeta

1A  ULONG           iULONG                                          Pool For Non Meta Tables
1B  ULONG           cULONG
                              //0x400 ULONGs in a page
    ULONG           aReserved[0x400 - 0x1C]                         This dummy array puts the ULONG pool on a page boundary, this is important for FixedPackedSchema which is located at the beginning of the ULONG pool
------------------------------------Page Boundary------------------------------------
    ULONG               aULONG              [cULONG             ]   FixedPackedSchema pool is always located first in the ULONG pool.
    ColumnMeta          aColumnMeta         [cColumnMeta        ]
    DatabaseMeta        aDatabaseMeta       [cDatabaseMeta      ]
    HashedIndex         HashTableHeap       [cbHashTableHeap    ]
    IndexMeta           aIndexMeta          [cIndexMeta         ]
    unsigned char       PooledDataHeap      [cbPooledDataHeap   ]
    QueryMeta           aQueryMeta          [cQueryMeta         ]
    RelationMeta        aRelationMeta       [cRelationMeta      ]
    ServerWiringMeta    aServerWiringMeta   [cServerWiringMeta  ]
    TableMeta           aTableMeta          [cTableMeta         ]
    TagMeta             aTagMeta            [cTagMeta           ]
*/
void TFixedTableHeapBuilder::BuildMetaTableHeap()
{
    //The heap signatures need to be 0 so multiple signatures don't appear in Catalog.dll
    m_FixedTableHeap.GrowHeap(1024);//pre allocate enough space for the header info, the rest are allocated in pretty big chunks

    m_FixedTableHeap.AddItemToHeap(0);                                     //kFixedTableHeapSignature0
    m_FixedTableHeap.AddItemToHeap(0);                                     //kFixedTableHeapSignature1
    m_FixedTableHeap.AddItemToHeap(kFixedTableHeapKey);                    //kFixedTableHeapKey
    m_FixedTableHeap.AddItemToHeap(kFixedTableHeapVersion);                //kFixedTableHeapVersion    
    m_FixedTableHeap.AddItemToHeap(0);                                     //kcbHeap
    //The above 5 ULONG DON'T get written into the DLL.  They are used to find the position of the heap within the file; but should NOT be overritten.
                                                                 
    //Reserve space for EndOfHeap index                                                                    
    ULONG iiEndOfHeap = m_FixedTableHeap.AddItemToHeap(0L);                //EndOfHeap                 

    //Reserve space for iColumnMeta index                                                                  
    ULONG iiColumnMeta = m_FixedTableHeap.AddItemToHeap(0L);               //iColumnMeta               
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountColumnMeta());        //cColumnMeta               
 
    //Reserve space for iDatabasemeta index
    ULONG iiDatabaseMeta = m_FixedTableHeap.AddItemToHeap(0L);             //iDatabaseMeta             
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountDatabaseMeta());      //cDatabaseMeta             
 
    //Reserve space for iDatabasemeta index
    ULONG iiHashTableHeap = m_FixedTableHeap.AddItemToHeap(0L);            //iHashTableHeap                
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountHashedIndex()*sizeof(HashedIndex));//cbHashTableHeap               
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiIndexMeta = m_FixedTableHeap.AddItemToHeap(0L);                //iIndexMeta                    
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountIndexMeta());         //cIndexMeta                    
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiPooledDataHeap = m_FixedTableHeap.AddItemToHeap(0L);           //iPooledDataHeap
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountOfBytesPooledData()); //cbPooledDataHeap                  
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiQueryMeta = m_FixedTableHeap.AddItemToHeap(0L);                //iQueryMeta                    
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountQueryMeta());         //cQueryMeta                    
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiRelationMeta = m_FixedTableHeap.AddItemToHeap(0L);             //iRelationMeta                 
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountRelationMeta());      //cRelationMeta                 
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiServerWiringMeta = m_FixedTableHeap.AddItemToHeap(0L);         //iServerWiringMeta             
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountServerWiringMeta());  //cServerWiringMeta             
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiTableMeta = m_FixedTableHeap.AddItemToHeap(0L);                //iTableMeta                    
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountTableMeta());         //cTableMeta                    
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiTagMeta = m_FixedTableHeap.AddItemToHeap(0L);                  //iTagMeta                      
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountTagMeta());           //cTagMeta                      
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiULONG = m_FixedTableHeap.AddItemToHeap(0L);                    //iULONG                        
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountULONG());             //cULONG                        

    ULONG ulTemp[0x400];
#ifdef _DEBUG
    for(ULONG i=0;i<0x400;++i)ulTemp[i] = 0x6db6db6d;
#endif
    m_FixedTableHeap.AddItemToHeap(ulTemp, 0x400-0x1C);

    //ULONG pool must come first so that the FixedPackedSchema is page alligned
    ULONG iULONG            = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->ULongFromIndex(0)           ), m_pFixup->GetCountULONG()           * sizeof(ULONG));

    ULONG iColumnMeta       = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->ColumnMetaFromIndex(0)      ), m_pFixup->GetCountColumnMeta()      * sizeof(ColumnMeta));
    ULONG iDatabaseMeta     = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->DatabaseMetaFromIndex(0)    ), m_pFixup->GetCountDatabaseMeta()    * sizeof(DatabaseMeta));
    ULONG iHashedIndex      = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->HashedIndexFromIndex(0)     ), m_pFixup->GetCountHashedIndex()     * sizeof(HashedIndex));
    ULONG iIndexMeta        = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->IndexMetaFromIndex(0)       ), m_pFixup->GetCountIndexMeta()       * sizeof(IndexMeta));
    ULONG iPooledDataHeap   = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->PooledDataPointer()         ), m_pFixup->GetCountOfBytesPooledData());
    ULONG iQueryMeta        = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->QueryMetaFromIndex(0)       ), m_pFixup->GetCountQueryMeta()       * sizeof(QueryMeta));
    ULONG iRelationMeta     = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->RelationMetaFromIndex(0)    ), m_pFixup->GetCountRelationMeta()    * sizeof(RelationMeta));
    ULONG iServerWiringMeta = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->ServerWiringMetaFromIndex(0)), m_pFixup->GetCountServerWiringMeta()* sizeof(ServerWiringMeta));
    ULONG iTableMeta        = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->TableMetaFromIndex(0)       ), m_pFixup->GetCountTableMeta()       * sizeof(TableMeta));
    ULONG iTagMeta          = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->TagMetaFromIndex(0)         ), m_pFixup->GetCountTagMeta()         * sizeof(TagMeta));

    *m_FixedTableHeap.GetTypedPointer(iiColumnMeta      /sizeof(ULONG)) = iColumnMeta      ;
    *m_FixedTableHeap.GetTypedPointer(iiDatabaseMeta    /sizeof(ULONG)) = iDatabaseMeta    ;
    *m_FixedTableHeap.GetTypedPointer(iiHashTableHeap   /sizeof(ULONG)) = iHashedIndex     ;
    *m_FixedTableHeap.GetTypedPointer(iiIndexMeta       /sizeof(ULONG)) = iIndexMeta       ;
    *m_FixedTableHeap.GetTypedPointer(iiPooledDataHeap  /sizeof(ULONG)) = iPooledDataHeap  ;
    *m_FixedTableHeap.GetTypedPointer(iiQueryMeta       /sizeof(ULONG)) = iQueryMeta       ;
    *m_FixedTableHeap.GetTypedPointer(iiRelationMeta    /sizeof(ULONG)) = iRelationMeta    ;
    *m_FixedTableHeap.GetTypedPointer(iiServerWiringMeta/sizeof(ULONG)) = iServerWiringMeta;
    *m_FixedTableHeap.GetTypedPointer(iiTableMeta       /sizeof(ULONG)) = iTableMeta       ;
    *m_FixedTableHeap.GetTypedPointer(iiTagMeta         /sizeof(ULONG)) = iTagMeta         ;
    *m_FixedTableHeap.GetTypedPointer(iiULONG           /sizeof(ULONG)) = iULONG           ;

    *m_FixedTableHeap.GetTypedPointer(iiEndOfHeap       /sizeof(ULONG)) = m_FixedTableHeap.GetEndOfHeap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\texception.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TEXCEPTION_H__
#define __TEXCEPTION_H__

//The only non-standard header that we need for the class declaration is TOutput
#ifndef __OUTPUT_H__
    #include "Output.h"
#endif

struct TException
{
    TException(HRESULT hr, LPCTSTR szFile, LPCTSTR szLineOfCode, UINT nLineNumber) : m_hr(hr), m_szFile(szFile), m_szLineOfCode(szLineOfCode), m_nLineNumber(nLineNumber){}
    void Dump(TOutput &out){out.printf(TEXT("TException raised:\n\tHRESULT:    \t0x%08x\n\tFile:      \t%s\n\tLine Number:\t%d\n\tCode:      \t%s\n"), m_hr, m_szFile, m_nLineNumber, m_szLineOfCode);}

    HRESULT m_hr;
    LPCTSTR m_szFile;
    LPCTSTR m_szLineOfCode;
    UINT    m_nLineNumber;
};

inline void ThrowExceptionIfFailed(HRESULT hr, LPCTSTR szFile, LPCTSTR szLineOfCode, UINT nLineNumber)
{
    if(FAILED(hr))
    {
//        DebugBreak();
        throw TException(hr, szFile, szLineOfCode, nLineNumber);
    }
}

inline void ThrowException(LPCTSTR szFile, LPCTSTR szLineOfCode, UINT nLineNumber)
{
//    DebugBreak();
    throw TException(E_FAIL, szFile, szLineOfCode, nLineNumber);
}

#define XIF(q)      ThrowExceptionIfFailed(q, TEXT(__FILE__), TEXT(#q), __LINE__)
#define THROW(q)    ThrowException(TEXT(__FILE__), TEXT(#q), __LINE__)

#endif //__TEXCEPTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tfixedtableheapbuilder.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TFIXEDTABLEHEAPBUILDER_H__
#define __TFIXEDTABLEHEAPBUILDER_H__

#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif

class TFixedTableHeapBuilder : public ICompilationPlugin
{
public:
    TFixedTableHeapBuilder();
    ~TFixedTableHeapBuilder();

    virtual void Compile(TPEFixup &fixup, TOutput &out);

    THeap<ULONG>                m_FixedTableHeap;
protected:
    TPEFixup                  * m_pFixup;
    TOutput                   * m_pOut;

    void                        BuildMetaTableHeap();
};



#endif // __TFIXEDTABLEHEAPBUILDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "StdAfx.h"
#ifndef __TFILE_H__
    #include "TFile.h"
#endif


TFile::TFile(LPCWSTR wszFileName, TOutput &out, bool bBinary, LPSECURITY_ATTRIBUTES psa) : m_cbSizeOfBuffer(0), m_pBuffer(0)
{
    if(-1 != GetFileAttributes(wszFileName))//if GetFileAttributes fails then the file does not exist
    {   //if it does NOT fail then lets delete the file before we open it.  The only reason I'm doing all of this is because 
        //_wfopen failed once and weren't able to repro the problem on another machine.  So this is a bit over coded
        if(0 == DeleteFile(wszFileName))
        {   //if delete file fails then report this warning, but continue any way.
            out.printf(L"Warning! Unable to delete file %s.  Last error returned 0x%08x.\n\tCheck to see that the file is not Read-Only\n", wszFileName, GetLastError());
        }
    }

	if(INVALID_HANDLE_VALUE == (m_hFile = CreateFile(wszFileName, GENERIC_WRITE, 0, psa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)))
    {
        out.printf(L"Error - Failed to create file %s.\n", wszFileName);
        THROW(CreateFile Failed.);
    }
}


TFile::~TFile()
{
    if(m_hFile)
        CloseHandle(m_hFile);

    delete [] m_pBuffer;
}


void TFile::Write(LPCSTR szBuffer, unsigned int nNumChars) const
{
    DWORD dwBytesWritten;
	if(!WriteFile(m_hFile, reinterpret_cast<const void *>(szBuffer), DWORD(nNumChars), &dwBytesWritten, NULL))
	{
        THROW(L"Write File Failed.");
	}
}


void TFile::Write(const unsigned char *pch, unsigned int nNumChars) const
{
    Write(reinterpret_cast<const char *>(pch), nNumChars);
}


void TFile::Write(unsigned char ch) const
{
    Write(reinterpret_cast<const char *>(&ch), sizeof(unsigned char));
}


void TFile::Write(unsigned long ul) const
{
    Write(reinterpret_cast<const char *>(&ul), sizeof(unsigned long));
}


void TFile::Write(LPCWSTR wszBuffer, unsigned int nNumWCHARs)
{
    if(nNumWCHARs > m_cbSizeOfBuffer)
    {
        delete [] m_pBuffer;
        m_pBuffer = new char [nNumWCHARs];//We want to write the file as chars not UNICODE
        if(0 == m_pBuffer)
            THROW(ERROR - FAILED TO ALLOCATE MEMORY);
        m_cbSizeOfBuffer = nNumWCHARs;
    }
    WideCharToMultiByte(CP_UTF8, 0, wszBuffer, nNumWCHARs, m_pBuffer, nNumWCHARs, 0, 0);

    DWORD dwBytesWritten;
	if(!WriteFile(m_hFile, reinterpret_cast<const void *>(m_pBuffer), DWORD(nNumWCHARs), &dwBytesWritten, NULL))
	{
        THROW(ERROR - WRITE FILE FAILED);
	}
}


TMetaFileMapping::TMetaFileMapping(LPCWSTR filename)
{
    m_hFile = CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
    m_hMapping = CreateFileMapping(m_hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
    m_pMapping = reinterpret_cast<unsigned char *>(MapViewOfFile(m_hMapping, FILE_MAP_WRITE, 0, 0, 0));
    if(0 == m_pMapping)//We only check the last step of the process since the last two steps should fail gracefully if passed NULL.
        THROW(ERROR MAPPING VIEW OF FILE);
    m_Size = GetFileSize(m_hFile, 0);
}


TMetaFileMapping::~TMetaFileMapping()
{
    if(m_pMapping)
    {
        if(0 == FlushViewOfFile(m_pMapping,0))
            THROW(ERROR - UNABLE TO FLUSH TO DISK);
        UnmapViewOfFile(m_pMapping);
        m_pMapping = 0;
    }

    if(m_hMapping)
        CloseHandle(m_hMapping);
    m_hMapping = 0;

    if(m_hFile)
        CloseHandle(m_hFile);
    m_hFile = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tdatabasemeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TDATABASEMETA_H__
#define __TDATABASEMETA_H__

#ifndef __PEFIXUP_H__
    #include "TPEFixup.h"
#endif
#ifndef __TTABLEMETA_H__
    #include "TTableMeta.h"
#endif

/*
struct DatabaseMeta
{
    ULONG PRIMARYKEY            InternalName            //String
    ULONG                       PublicName              //String
    ULONG                       BaseVersion             //UI4
    ULONG                       ExtendedVersion         //UI4
    ULONG                       CountOfTables           //UI4       Count of tables in database
    ULONG                       iSchemaBlob             //Index into Pool
    ULONG                       cbSchemaBlob            //Count of Bytes of the SchemaBlob
    ULONG                       iNameHeapBlob           //Index into Pool
    ULONG                       cbNameHeapBlob          //Count of Bytes of the SchemaBlob
    ULONG                       iTableMeta              //Index into TableMeta
    ULONG                       iGuidDid                //Index to Pool, where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
	ULONG						Description				//String
};
*/

class TDatabaseMeta : public TMetaTable<DatabaseMeta>
{
public:
    TDatabaseMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<DatabaseMeta>(fixup,i){}
    const WCHAR * Get_InternalName    () const {return m_Fixup.StringFromIndex(   Get_MetaTable().InternalName   );}
    const WCHAR * Get_PublicName      () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicName     );}
    const ULONG * Get_BaseVersion     () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().BaseVersion    );}
    const ULONG * Get_ExtendedVersion () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().ExtendedVersion);}
    const ULONG * Get_CountOfTables   () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().CountOfTables  );}
    const BYTE  * Get_iSchemaBlob     () const {return m_Fixup.ByteFromIndex(     Get_MetaTable().iSchemaBlob    );}
    const ULONG   Get_cbSchemaBlob    () const {return                            Get_MetaTable().cbSchemaBlob    ;}
    const BYTE  * Get_iNameHeapBlob   () const {return m_Fixup.ByteFromIndex(     Get_MetaTable().iNameHeapBlob  );}
          ULONG   Get_cbNameHeapBlob  () const {return                            Get_MetaTable().cbNameHeapBlob  ;}
          ULONG   Get_iTableMeta      () const {return                            Get_MetaTable().iTableMeta      ;}
    const GUID  * Get_iGuidDid        () const {return m_Fixup.GuidFromIndex(     Get_MetaTable().iGuidDid       );}
	const WCHAR * Get_Desciption      () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Description    );}
   
    virtual DatabaseMeta * Get_pMetaTable   ()       {return m_Fixup.DatabaseMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount          () const {return m_Fixup.GetCountDatabaseMeta();};
    const DatabaseMeta & Get_MetaTable () const {return *m_Fixup.DatabaseMetaFromIndex(m_iCurrent);}
};

#endif //__TDATABASEMETA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tfixupdll.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TFIXUPDLL_H__
#define __TFIXUPDLL_H__

#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif
#ifndef __TFIXEDTABLEHEAPBUILDER_H__
    #include "TFixedTableHeapBuilder.h"
#endif

class TCatalogDLL
{
public:
    TCatalogDLL(LPCWSTR szFilename) : m_CatalogsFixedTableHeapSize(0), m_iOffsetOfFixedTableHeap(0), m_pMappedFile(0), m_szFilename(szFilename){}
    ~TCatalogDLL(){delete m_pMappedFile;}

    const FixedTableHeap * LocateTableSchemaHeap(TOutput &out);

protected:
    ULONG                       m_CatalogsFixedTableHeapSize;
    ULONG                       m_iOffsetOfFixedTableHeap;
    TMetaFileMapping          * m_pMappedFile;
    LPCWSTR                     m_szFilename;
};

class TFixupDLL : public TFixedTableHeapBuilder
{
public:
    TFixupDLL(LPCWSTR szFilename);
    ~TFixupDLL();

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    ULONG                       m_iOffsetOfFixedTableHeap;
    TMetaFileMapping          * m_pMappedFile;
    LPCWSTR                     m_szFilename;
    ULONG                       m_CatalogsFixedTableHeapSize;

    void                        DisplayStatistics() const;
    void                        LocateSignatures();
    void                        SetupToModifyPE();
    void                        UpdateTheDLL();
};


#endif // __TFIXUPDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tfixupdll.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TFIXUPDLL_H__
    #include "TFixupDLL.h"
#endif
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif


const FixedTableHeap * TCatalogDLL::LocateTableSchemaHeap(TOutput &out)
{
    if(0 == m_iOffsetOfFixedTableHeap)//If we haven't already gotten the pointer, then load the DLL and find it
    {
        if(0 == m_pMappedFile)
        {
            m_pMappedFile = new TMetaFileMapping(m_szFilename);
            if(0 == m_pMappedFile)
                THROW(MEMORY ALLOCATION FAILED);
        }
        m_iOffsetOfFixedTableHeap = 0;
        for(ULONG i=0;i<(m_pMappedFile->Size()-(32*sizeof(ULONG)));++i)
        {
            if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i)  ==kFixedTableHeapSignature0 &&
               *reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+sizeof(ULONG))==kFixedTableHeapSignature1)
            {
                if(0 != m_iOffsetOfFixedTableHeap)
                {
                    out.printf(L"Multiple TableSchema signatures found.  Cannot continue.\n");
                    THROW(ERROR - MULTIPLE FIXEDTABLEHEAP SIGNATURES);
                }
                if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(2*sizeof(ULONG)))  !=kFixedTableHeapKey)
                {
                    out.printf(L"Error - Invalid FixedTableHeapKey.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
                    THROW(ERROR - INVALID FIXEDTABLEHEAPKEY);
                }
                if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(3*sizeof(ULONG)))  !=kFixedTableHeapVersion)
                {
                    out.printf(L"Error - Invalid FixedTableHeapVersion.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
                    THROW(ERROR - INVALID FIXEDTABLEHEAPVERSION);
                }
                m_CatalogsFixedTableHeapSize = *reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(4*sizeof(ULONG)));
                m_iOffsetOfFixedTableHeap = i;
            }

        }
        if(0==m_iOffsetOfFixedTableHeap)
        {
            out.printf(L"Error - FixedTableHeap Signatures NOT found.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
            THROW(ERROR - SIGNATURES NOT FOUND);
        }
    }
    //After we've found it return a pointer to it
    return reinterpret_cast<const FixedTableHeap *>(m_pMappedFile->Mapping() + m_iOffsetOfFixedTableHeap);
}


TFixupDLL::TFixupDLL(LPCWSTR szFilename) :
                 m_iOffsetOfFixedTableHeap(0)
                ,m_szFilename(szFilename)
{
}

TFixupDLL::~TFixupDLL()
{
    delete m_pMappedFile;
}

void TFixupDLL::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    if(-1 == GetFileAttributes(m_szFilename))//if GetFileAttributes fails then the file does not exist
    {
        m_pOut->printf(L"File not found (%s).\n", m_szFilename);
        THROW(ERROR - FILE NOT FOUND);
    }

    SetupToModifyPE();
    LocateSignatures();
    BuildMetaTableHeap();
    UpdateTheDLL();
}


void TFixupDLL::DisplayStatistics() const
{
}


void TFixupDLL::LocateSignatures()
{   //FixedTableHeap
    m_iOffsetOfFixedTableHeap = 0;
    for(ULONG i=0;i<(m_pMappedFile->Size()-(32*sizeof(ULONG)));++i)
    {
        if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i)  ==kFixedTableHeapSignature0 &&
           *reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+sizeof(ULONG))==kFixedTableHeapSignature1)
        {
            if(0 != m_iOffsetOfFixedTableHeap)
            {
                m_pOut->printf(L"Multiple TableSchema signatures found.  Cannot continue.\n");
                THROW(ERROR - MULTIPLE FIXEDTABLEHEAP SIGNATURES);
            }
            if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(2*sizeof(ULONG)))  !=kFixedTableHeapKey)
            {
                m_pOut->printf(L"Error - Invalid FixedTableHeapKey.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
                THROW(ERROR - INVALID FIXEDTABLEHEAPKEY);
            }
            if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(3*sizeof(ULONG)))  !=kFixedTableHeapVersion)
            {
                m_pOut->printf(L"Error - Invalid FixedTableHeapVersion.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
                THROW(ERROR - INVALID FIXEDTABLEHEAPVERSION);
            }
            m_CatalogsFixedTableHeapSize = *reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(4*sizeof(ULONG)));
            m_iOffsetOfFixedTableHeap = i;
        }

    }
    if(0==m_iOffsetOfFixedTableHeap)
    {
        m_pOut->printf(L"Error - FixedTableHeap Signatures NOT found.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
        THROW(ERROR - SIGNATURES NOT FOUND);
    }
}


void TFixupDLL::SetupToModifyPE()
{
    wstring strNewDLL = m_szFilename;
    strNewDLL += L".new";
    if(0 == CopyFile(m_szFilename, strNewDLL.c_str(), FALSE))
    {
        m_pOut->printf(L"Error while making a copy of %s.\n",m_szFilename);
        THROW(ERROR - COPY FILE FAILED);
    }

    m_pMappedFile = new TMetaFileMapping(strNewDLL.c_str());
    if(0 == m_pMappedFile)
        THROW(MEMORY ALLOCATION FAILED);
}


void TFixupDLL::UpdateTheDLL()
{
    if(m_FixedTableHeap.GetEndOfHeap() > m_CatalogsFixedTableHeapSize)
    {
        m_pOut->printf(L"The DLL's FixedTableHeap isn't big enough.  FixedTableHeap needs to be %d bytes.  Current size is only %d bytes.  Update $\\src\\core\\catinproc\\sources with:/D\"CB_FIXED_TABLEHEAP=%d\"\n", m_FixedTableHeap.GetEndOfHeap(), m_CatalogsFixedTableHeapSize, m_FixedTableHeap.GetEndOfHeap());
        THROW(ERROR - FIXEDTABLEHEAP HEAP NOT BIG ENOUGH);
    }
    else
    {
        m_pOut->printf(L"FixedTableHeap will have %d bytes of unused space.  Heap size (%d bytes), Used heap space (%d bytes).\n", m_CatalogsFixedTableHeapSize-m_FixedTableHeap.GetEndOfHeap(), m_CatalogsFixedTableHeapSize, m_FixedTableHeap.GetEndOfHeap());

        m_pOut->printf(L"\nFixed Table Heap Summary\n_____________________________\n");
        ULONG i=0;
        m_pOut->printf(L"Fixed Table Heap Header                                  %10d bytes   \n",  4096);
        m_pOut->printf(L"HeapSignature0      = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"HeapSignature1      = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"HeapKey             = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"HeapVersion         = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cbHeap              = 0x%08X  - (%10d)                      \n",  m_CatalogsFixedTableHeapSize        ,m_CatalogsFixedTableHeapSize        );++i;
        m_pOut->printf(L"EndOfHeap           = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"iColumnMeta         = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cColumnMeta         = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(ColumnMeta));++i;
        m_pOut->printf(L"iDatabaseMeta       = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cDatabaseMeta       = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(DatabaseMeta));++i;
        m_pOut->printf(L"iHashTableHeap      = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cbHashTableHeap     = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"iIndexMeta          = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cIndexMeta          = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(IndexMeta));++i;
        m_pOut->printf(L"iPooledHeap         = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cbPooledHeap        = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"iQueryMeta          = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cQueryMeta          = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(QueryMeta));++i;
        m_pOut->printf(L"iRelationMeta       = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cRelationMeta       = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(RelationMeta));++i;
        m_pOut->printf(L"iServerWiringMeta   = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cServerWiringMeta   = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(ServerWiringMeta));++i;
        m_pOut->printf(L"iTableMeta          = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cTableMeta          = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(TableMeta));++i;
        m_pOut->printf(L"iTagMeta            = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cTagMeta            = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(TagMeta));++i;
        m_pOut->printf(L"iULONG              = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cULONG              = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(ULONG));++i;
        m_pOut->printf(L"End Fixed Table Heap Summary\n_____________________________\n");
    }

    //Leave the first 5 DWORDs of the DLL's heap in tact.
    memcpy(m_pMappedFile->Mapping()+m_iOffsetOfFixedTableHeap+(5*sizeof(ULONG)),  m_FixedTableHeap.GetHeapPointer()+(5*sizeof(ULONG)), m_FixedTableHeap.GetEndOfHeap()-(5*sizeof(ULONG)));

    m_pOut->printf(L"PE update succeeded.\n");
    DisplayStatistics();
    delete m_pMappedFile;
    m_pMappedFile = 0;

    wstring strOldDLL = m_szFilename;
    strOldDLL += L".old";
    wstring strNewDLL = m_szFilename;
    strNewDLL += L".new";

    //Make a backup copy of the file
    if(0 == CopyFile(m_szFilename, strOldDLL.c_str(), FALSE))
    {
        m_pOut->printf(L"Error while making a backup copy of %s.\n",m_szFilename);
        THROW(ERROR - COPY FILE FAILED);
    }
    //Copy the new file over top of the original
    if(0 == CopyFile(strNewDLL.c_str(), m_szFilename, FALSE))
    {
        m_pOut->printf(L"Error renaming %s to %s...restoring previous version.\n", strNewDLL.c_str(), m_szFilename);
        if(0 == CopyFile(strOldDLL.c_str(), m_szFilename, FALSE))
        {
            m_pOut->printf(L"Error while restoring previous version (%s) to %s.\n", strOldDLL.c_str(), m_szFilename);
            THROW(ERROR - UNABLE TO RESTORE PREVIOUS VERSION OF DLL);
        }
        THROW(ERROR - UNABLE TO COPY NEW DLL OVER EXISTING ONE);
    }
    m_pOut->printf(L"Backup copy of %s renamed as %s.\n", m_szFilename, strOldDLL.c_str());

    //Now delete the working copy
    if(0 == DeleteFile(strNewDLL.c_str()))
        m_pOut->printf(L"Warning - Failed to delete working copy DLL (%s).\n",strNewDLL.c_str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\thashedpkindexes.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __THASHEDPKINDEXES_H__
#define __THASHEDPKINDEXES_H__

#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif

class THashedPKIndexes : public ICompilationPlugin
{
public:
    THashedPKIndexes();
    ~THashedPKIndexes();

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    typedef ULONG HashArray[kLargestPrime*2];

    THeap<HashedIndex>  m_HashedIndexHeap;
    TPEFixup *          m_pFixup;
    TOutput  *          m_pOut;

    unsigned long   DetermineBestModulo(ULONG cRows, ULONG cPrimaryKeys, HashArray aHashes[]);
    unsigned long   DetermineModuloRating(ULONG cRows, ULONG AccumulativeLinkage, ULONG Modulo) const;
    unsigned long   FillInTheHashTable(unsigned long cRows, unsigned long cPrimaryKeys, HashArray Hashes[], ULONG Modulo);
    void            FillInTheHashTableForColumnMeta  ();
    void            FillInTheHashTableForDatabase    ();
    void            FillInTheHashTableForIndexMeta   ();
    void            FillInTheHashTableForQueryMeta   ();
    void            FillInTheHashTableForRelationMeta();
    void            FillInTheHashTableForTableMeta   ();
    void            FillInTheHashTableForTagMeta     ();
    void            FillInTheHashTables();
};



#endif // __THASHEDPKINDEXES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tfixupheaps.h ===
// Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
// Filename:        TFixupHeaps.h
// Author:          Stephenr
// Date Created:    9/19/00
// Description:     This class abstracts the basic heap storage of the meta tables.
//                  We can have different consumers of meta XML that need to build heap.
//                  The consumers need to present a TPeFixup interface to allow
//                  CompilationPlugins to act on this meta.  The easiest way to store
//                  this meta is in heaps.  That's what this object does.
//

#ifndef __TFIXUPHEAPS_H__
#define __TFIXUPHEAPS_H__

#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif
#ifndef __THEAP_H__
    #include "THeap.h"
#endif


class TFixupHeaps : public TPEFixup
{
public:
    TFixupHeaps(){}
    virtual ~TFixupHeaps(){}

    //Begin TPEFixup - This is the interface by which other code accesses the fixed data before it's written into the DLL (or where ever we choose to put it).
    virtual unsigned long       AddBytesToList(const unsigned char * pBytes, size_t cbBytes){return m_HeapPooled.AddItemToHeap(pBytes, (ULONG)cbBytes);}
    virtual unsigned long       AddGuidToList(const GUID &guid)                             {return m_HeapPooled.AddItemToHeap(guid);}
    virtual unsigned long       AddUI4ToList(ULONG ui4)                                     {return m_HeapPooled.AddItemToHeap(ui4);}
    virtual unsigned long       AddULongToList(ULONG ulong)                                 {return m_HeapULONG.AddItemToHeap(ulong);}
    virtual unsigned long       AddWCharToList(LPCWSTR wsz, unsigned long cwchar=-1)        {return m_HeapPooled.AddItemToHeap(wsz, cwchar);}
    virtual unsigned long       FindStringInPool(LPCWSTR wsz, unsigned long cwchar=-1) const{return m_HeapPooled.FindMatchingHeapEntry(wsz);}

    virtual unsigned long       AddColumnMetaToList         (ColumnMeta       *p, ULONG count=1)       {return m_HeapColumnMeta.AddItemToHeap(p, count);            }
    virtual unsigned long       AddDatabaseMetaToList       (DatabaseMeta     *p, ULONG count=1)       {return m_HeapDatabaseMeta.AddItemToHeap(p, count);          }
    virtual unsigned long       AddHashedIndexToList        (HashedIndex      *p, ULONG count=1)       {return m_HeapHashedIndex.AddItemToHeap(p, count);           }
    virtual unsigned long       AddIndexMetaToList          (IndexMeta        *p, ULONG count=1)       {return m_HeapIndexMeta.AddItemToHeap(p, count);             }
    virtual unsigned long       AddQueryMetaToList          (QueryMeta        *p, ULONG count=1)       {return m_HeapQueryMeta.AddItemToHeap(p, count);             }
    virtual unsigned long       AddRelationMetaToList       (RelationMeta     *p, ULONG count=1)       {return m_HeapRelationMeta.AddItemToHeap(p, count);          }
    virtual unsigned long       AddServerWiringMetaToList   (ServerWiringMeta *p, ULONG count=1)       {return m_HeapServerWiringMeta.AddItemToHeap(p, count);      }
    virtual unsigned long       AddTableMetaToList          (TableMeta        *p, ULONG count=1)       {return m_HeapTableMeta.AddItemToHeap(p, count);             }
    virtual unsigned long       AddTagMetaToList            (TagMeta          *p, ULONG count=1)       {return m_HeapTagMeta.AddItemToHeap(p, count);               }
    virtual unsigned long       AddULongToList              (ULONG            *p, ULONG count)         {return m_HeapULONG.AddItemToHeap(p, count);                 }

    virtual const BYTE       *  ByteFromIndex               (ULONG i) const {return m_HeapPooled.BytePointerFromIndex(i);             }
    virtual const GUID       *  GuidFromIndex               (ULONG i) const {return m_HeapPooled.GuidPointerFromIndex(i);             }
    virtual const WCHAR      *  StringFromIndex             (ULONG i) const {return m_HeapPooled.StringPointerFromIndex(i);           }
    virtual       ULONG         UI4FromIndex                (ULONG i) const {return *m_HeapPooled.UlongPointerFromIndex(i);           }
    virtual const ULONG      *  UI4pFromIndex               (ULONG i) const {return m_HeapPooled.UlongPointerFromIndex(i);            }
                                                                                                                                    
    virtual unsigned long       BufferLengthFromIndex       (ULONG i) const {return m_HeapPooled.GetSizeOfItem(i);                    }

    virtual ColumnMeta       *  ColumnMetaFromIndex         (ULONG i=0)     {return m_HeapColumnMeta.GetTypedPointer(i);            }
    virtual DatabaseMeta     *  DatabaseMetaFromIndex       (ULONG i=0)     {return m_HeapDatabaseMeta.GetTypedPointer(i);          }
    virtual HashedIndex      *  HashedIndexFromIndex        (ULONG i=0)     {return m_HeapHashedIndex.GetTypedPointer(i);           }
    virtual IndexMeta        *  IndexMetaFromIndex          (ULONG i=0)     {return m_HeapIndexMeta.GetTypedPointer(i);             }
    virtual QueryMeta        *  QueryMetaFromIndex          (ULONG i=0)     {return m_HeapQueryMeta.GetTypedPointer(i);             }
    virtual RelationMeta     *  RelationMetaFromIndex       (ULONG i=0)     {return m_HeapRelationMeta.GetTypedPointer(i);          }
    virtual ServerWiringMeta *  ServerWiringMetaFromIndex   (ULONG i=0)     {return m_HeapServerWiringMeta.GetTypedPointer(i);      }
    virtual TableMeta        *  TableMetaFromIndex          (ULONG i=0)     {return m_HeapTableMeta.GetTypedPointer(i);             }
    virtual TagMeta          *  TagMetaFromIndex            (ULONG i=0)     {return m_HeapTagMeta.GetTypedPointer(i);               }
    virtual ULONG            *  ULongFromIndex              (ULONG i=0)     {return m_HeapULONG.GetTypedPointer(i);                 }
    virtual unsigned char    *  PooledDataPointer           ()              {return reinterpret_cast<unsigned char *>(m_HeapPooled.GetTypedPointer(0));}

    virtual unsigned long       GetCountColumnMeta          ()        const {return m_HeapColumnMeta.GetCountOfTypedItems();        }
    virtual unsigned long       GetCountDatabaseMeta        ()        const {return m_HeapDatabaseMeta.GetCountOfTypedItems();      }
    virtual unsigned long       GetCountHashedIndex         ()        const {return m_HeapHashedIndex.GetCountOfTypedItems();       }
    virtual unsigned long       GetCountIndexMeta           ()        const {return m_HeapIndexMeta.GetCountOfTypedItems();         }
    virtual unsigned long       GetCountQueryMeta           ()        const {return m_HeapQueryMeta.GetCountOfTypedItems();         }
    virtual unsigned long       GetCountRelationMeta        ()        const {return m_HeapRelationMeta.GetCountOfTypedItems();      }
    virtual unsigned long       GetCountServerWiringMeta    ()        const {return m_HeapServerWiringMeta.GetCountOfTypedItems();  }
    virtual unsigned long       GetCountTableMeta           ()        const {return m_HeapTableMeta.GetCountOfTypedItems();         }
    virtual unsigned long       GetCountTagMeta             ()        const {return m_HeapTagMeta.GetCountOfTypedItems();           }
    virtual unsigned long       GetCountULONG               ()        const {return m_HeapULONG.GetCountOfTypedItems();             }
    virtual unsigned long       GetCountOfBytesPooledData   ()        const {return m_HeapPooled.GetEndOfHeap();                    }

    virtual unsigned long       FindTableBy_TableName(ULONG Table, bool bCaseSensitive=false)
    {
        ASSERT(0 == Table%4);
        unsigned long iTableMeta;
        if(bCaseSensitive)
        {
            for(iTableMeta=GetCountTableMeta()-1;iTableMeta!=(-1);--iTableMeta)
            {
                if(TableMetaFromIndex(iTableMeta)->InternalName == Table)
                    return iTableMeta;
            }
        }
        else
        {
            for(iTableMeta=GetCountTableMeta()-1;iTableMeta!=(-1);--iTableMeta)
            {
                if(0==_wcsicmp(StringFromIndex(TableMetaFromIndex(iTableMeta)->InternalName), StringFromIndex(Table)))
                    return iTableMeta;
            }
        }
        return -1;
    }
    virtual unsigned long       FindTableBy_TableName(LPCWSTR wszTable)
    {
        ULONG Table = FindStringInPool(wszTable);
        return (Table == -1) ? -1 : FindTableBy_TableName(Table);
    }
    virtual unsigned long       FindColumnBy_Table_And_Index(unsigned long Table, unsigned long Index, bool bCaseSensitive=false)
    {
        ASSERT(0 == Table%4);
        ASSERT(Index>0 && 0 == Index%4);
        bool bTableMatches=false;
        //Start at the end because presumably the caller cares about the ColumnMeta for the columns just added
        if(bCaseSensitive)
        {
            for(ULONG iColumnMeta=GetCountColumnMeta()-1; iColumnMeta!=(-1);--iColumnMeta)
            {
                if( ColumnMetaFromIndex(iColumnMeta)->Table == Table)
                {
                    bTableMatches = true;
                    if(ColumnMetaFromIndex(iColumnMeta)->Index == Index)
                        return iColumnMeta;
                }
                else if(bTableMatches)
                    return -1;
            }
        }
        else
        {
            for(ULONG iColumnMeta=GetCountColumnMeta()-1; iColumnMeta!=(-1);--iColumnMeta)
            {
                if(0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->Table), StringFromIndex(Table)))
                {
                    bTableMatches = true;
                    if(ColumnMetaFromIndex(iColumnMeta)->Index == Index)
                        return iColumnMeta;
                }
                else if(bTableMatches)
                    return -1;
            }
        }
        return -1;
    }
    virtual unsigned long       FindColumnBy_Table_And_InternalName(unsigned long Table, unsigned long  InternalName, bool bCaseSensitive=false)
    {
        ASSERT(0 == Table%4);
        ASSERT(0 == InternalName%4);
        bool bTableMatches=false;
        //Start at the end because presumably the caller cares about the ColumnMeta for the columns just added
        if(bCaseSensitive)
        {
            for(ULONG iColumnMeta=GetCountColumnMeta()-1; iColumnMeta!=(-1);--iColumnMeta)
            {
                if( ColumnMetaFromIndex(iColumnMeta)->Table==Table)
                {
                    bTableMatches = true;
                    if(ColumnMetaFromIndex(iColumnMeta)->InternalName==InternalName)
                        return iColumnMeta;
                }
                else if(bTableMatches)//if we previously found the table and now we don't match the table, then we never will, so bail.
                {
                    return -1;
                }
            }
        }
        else
        {
            for(ULONG iColumnMeta=GetCountColumnMeta()-1; iColumnMeta!=(-1);--iColumnMeta)
            {
                if(ColumnMetaFromIndex(iColumnMeta)->Table==Table || 0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->Table), StringFromIndex(Table)))
                {
                    bTableMatches = true;
                    if(ColumnMetaFromIndex(iColumnMeta)->InternalName==InternalName || 0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->InternalName), StringFromIndex(InternalName)))
                        return iColumnMeta;
                }
                else if(bTableMatches)//if we previously found the table and now we don't match the table, then we never will, so bail.
                {
                    return -1;
                }
            }
        }
        return -1;
    }
    virtual unsigned long       FindTagBy_Table_And_Index(ULONG iTableName, ULONG iColumnIndex, bool bCaseSensitive=false)
    {
        ASSERT(0 == iTableName%4);
        ASSERT(iColumnIndex>0 && 0 == iColumnIndex%4);
        bool bTableMatches=false;
        if(bCaseSensitive)
        {
            for(ULONG iTagMeta=0; iTagMeta<GetCountTagMeta();++iTagMeta)
            {
                if( TagMetaFromIndex(iTagMeta)->Table       == iTableName)
                {
                    bTableMatches = true;
                    if(TagMetaFromIndex(iTagMeta)->ColumnIndex == iColumnIndex)
                        return iTagMeta;
                }
                else if(bTableMatches)
                {
                    return -1;
                }
            }
        }
        else
        {
            for(ULONG iTagMeta=0; iTagMeta<GetCountTagMeta();++iTagMeta)
            {
                if(0==_wcsicmp(StringFromIndex(TagMetaFromIndex(iTagMeta)->Table), StringFromIndex(iTableName)))
                {
                    bTableMatches = true;
                    if(TagMetaFromIndex(iTagMeta)->ColumnIndex == iColumnIndex)
                        return iTagMeta;
                }
                else if(bTableMatches)
                {
                    return -1;
                }
            }
        }
        return -1;
    }

    //End TPEFixup
    virtual void Dump(TOutput &out)
    {
        const DWORD kNothing            = 0x00;
        const DWORD kDatabaseMeta       = 0x01;
        const DWORD kTableMeta          = 0x02;
        const DWORD kColumnMeta         = 0x04;
        const DWORD kTagMeta            = 0x08;
        const DWORD kIndexMeta          = 0x10;
        const DWORD kQueryMeta          = 0x20;
        const DWORD kRelationMeta       = 0x40;
        const DWORD kServerWiringMeta   = 0x80;
        const DWORD kEverything         = 0xFF;

        static DWORD dwDump=kNothing;
        if(dwDump==kNothing)
            return;
        if(GetCountColumnMeta()<1100)
            return;

        #define output out.printf
        #define String(x) (x ? StringFromIndex(x) : L"(null)")
        #define UI4(x) (x ? UI4FromIndex(x) : 0xbaadf00d)
        WCHAR szBuf[2048];

        if(dwDump & kDatabaseMeta)
        {
            wsprintf(szBuf, L"\nDatabaseMeta\n");output(szBuf);
            wsprintf(szBuf, L"{%40s, %40s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %40s}\n", L"InternalName", L"PublicName", L"BaseVersion", L"ExtendedVersion",
                            L"CountOfTables", L"iSchemaBlob", L"cbSchemaBlob", L"iNameHeapBlob", L"cbNameHeapBlob", L"iTableMeta", L"iGuidDid", L"Description");
            output(szBuf);
            for(unsigned int iDatabaseMeta=0; iDatabaseMeta<GetCountDatabaseMeta(); iDatabaseMeta++)
            {
                wsprintf(szBuf, L"{%40s, %40s,      0x%08X,      0x%08X,      0x%08X, %15d, %15d, %15d, %15d, %15d, %15d, %40s}\n", 
                                String(DatabaseMetaFromIndex(iDatabaseMeta)->InternalName   )   ,//Index into Pool
                                String(DatabaseMetaFromIndex(iDatabaseMeta)->PublicName     )   ,//Index into Pool
                                UI4(DatabaseMetaFromIndex(iDatabaseMeta)->BaseVersion       )   ,//
                                UI4(DatabaseMetaFromIndex(iDatabaseMeta)->ExtendedVersion   )   ,//
                                UI4(DatabaseMetaFromIndex(iDatabaseMeta)->CountOfTables     )   ,//Count of tables in database
                                DatabaseMetaFromIndex(iDatabaseMeta)->iSchemaBlob                        ,//Index into Bytes
                                DatabaseMetaFromIndex(iDatabaseMeta)->cbSchemaBlob                       ,//Count of Bytes of the SchemaBlob
                                DatabaseMetaFromIndex(iDatabaseMeta)->iNameHeapBlob                      ,//Index into Bytes
                                DatabaseMetaFromIndex(iDatabaseMeta)->cbNameHeapBlob                     ,//Count of Bytes of the SchemaBlob
                                DatabaseMetaFromIndex(iDatabaseMeta)->iTableMeta                         ,//Index into TableMeta
                                DatabaseMetaFromIndex(iDatabaseMeta)->iGuidDid                           ,//Index to aGuid where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
				  String(DatabaseMetaFromIndex(iDatabaseMeta)->Description     )						 );//Description                           
                output(szBuf);Sleep(10);
            }
        }
        if(dwDump & kTableMeta)
        {
            wsprintf(szBuf, L"\nTableMeta\n");output(szBuf);
            wsprintf(szBuf, L"{%40s, %40s, %40s, %40s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %40s, %40s, %15s, %15s, %15s, %15s, %15s, %15s, %40s}\n", L"Database", L"InternalName",
                            L"PublicName", L"PublicRowName", L"BaseVersion", L"ExtendedVersion", L"NameColumn", L"NavColumn", L"CountOfColumns", L"MetaFlags",
                            L"SchemaGenFlags", L"ConfigItemName", L"ConfigCollectionName", L"PublicRowNameColumn", L"ciRows", L"iColumnMeta", L"iFixedTable", L"cPrivateColumns", L"cIndexMeta", L"iIndexMeta", L"Description");
            output(szBuf);
            for(unsigned int iTableMeta=0; iTableMeta<GetCountTableMeta(); iTableMeta++)
            {
                wsprintf(szBuf, L"{%40s, %40s, %40s, %40s,      0x%08X,      0x%08X,      0x%08X,      0x%08X,      0x%08X,      0x%08X,      0x%08X, %40s, %40s, %15d, %15d, %15d, %15d, %15d, %15d, %15d, %40s}\n", 
                                String(TableMetaFromIndex(iTableMeta)->Database             )   ,//Index into Pool
                                String(TableMetaFromIndex(iTableMeta)->InternalName         )   ,//Index into Pool
                                String(TableMetaFromIndex(iTableMeta)->PublicName           )   ,//Index into Pool
                                String(TableMetaFromIndex(iTableMeta)->PublicRowName        )   ,//Index into Pool
                                UI4(TableMetaFromIndex(iTableMeta)->BaseVersion             )   ,//
                                UI4(TableMetaFromIndex(iTableMeta)->ExtendedVersion         )   ,//
                                UI4(TableMetaFromIndex(iTableMeta)->NameColumn              )   ,//iOrder of the NameColumn
                                UI4(TableMetaFromIndex(iTableMeta)->NavColumn               )   ,//iOrder of the NavColumn
                                UI4(TableMetaFromIndex(iTableMeta)->CountOfColumns          )   ,//Count of Columns
                                UI4(TableMetaFromIndex(iTableMeta)->MetaFlags               )   ,//TableMetaFlags are defined in CatInpro.meta
                                UI4(TableMetaFromIndex(iTableMeta)->SchemaGeneratorFlags    )   ,//SchemaGenFlags are defined in CatInpro.meta
                                String(TableMetaFromIndex(iTableMeta)->ConfigItemName                )   ,
                                String(TableMetaFromIndex(iTableMeta)->ConfigCollectionName          )   ,
                                UI4(TableMetaFromIndex(iTableMeta)->PublicRowNameColumn     )   ,
                                TableMetaFromIndex(iTableMeta)->ciRows                                   ,//Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
                                TableMetaFromIndex(iTableMeta)->iColumnMeta                              ,//Index into ColumnMeta
                                TableMetaFromIndex(iTableMeta)->iFixedTable                              ,//Index into g_aFixedTable
                                TableMetaFromIndex(iTableMeta)->cPrivateColumns                          ,//This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
                                TableMetaFromIndex(iTableMeta)->cIndexMeta                               ,//The number of IndexMeta entries in this table
                                TableMetaFromIndex(iTableMeta)->iIndexMeta                               ,//Index into IndexMeta
								String(TableMetaFromIndex(iTableMeta)->Description            )			 );
                output(szBuf);Sleep(10);
            }
        }
        if(dwDump & kColumnMeta)
        {
            wsprintf(szBuf, L"\nColumnMeta\n");output(szBuf);
            wsprintf(szBuf, L"{      %40s, %15s, %40s, %40s, %40s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %40s, %15s, %15s, %40s}\n", L"Table", L"Index", L"InternalName", L"PublicName", L"PublicColumnName",
                            L"Type", L"Size", L"MetaFlags", L"MetaFlagsEx", L"DefaultValue", L"FlagMask", L"StartingNumber", L"EndingNumber", L"CharacterSet", L"ciTagMeta", L"iTagMeta", L"Description");
            output(szBuf);
            for(unsigned int iColumnMeta=200; iColumnMeta<1100 /*GetCountColumnMeta()*/; iColumnMeta++)
            {
                wsprintf(szBuf, L"%5d {%40s,      0x%08X, %40s, %40s,      0x%08X,      0x%08X,      0x%08X,       0x%08X, %15s,      0x%08X,      0x%08X,      0x%08X, %40s, %15d, %15d, %40s}\n", 
                                iColumnMeta,
                                String(ColumnMetaFromIndex(iColumnMeta)->Table           )  ,//Index into Pool
                                UI4(ColumnMetaFromIndex(iColumnMeta)->Index              )  ,//Index into UI4 pool, Column Index
                                String(ColumnMetaFromIndex(iColumnMeta)->InternalName    )  ,//Index into Pool
                                String(ColumnMetaFromIndex(iColumnMeta)->PublicName      )  ,//Index into Pool
								String(ColumnMetaFromIndex(iColumnMeta)->PublicColumnName)  ,//Index into pool
                                UI4(ColumnMetaFromIndex(iColumnMeta)->Type               )  ,//These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
                                UI4(ColumnMetaFromIndex(iColumnMeta)->Size               )  ,//
                                UI4(ColumnMetaFromIndex(iColumnMeta)->MetaFlags          )  ,//ColumnMetaFlags defined in CatInpro.meta
                                UI4(ColumnMetaFromIndex(iColumnMeta)->SchemaGeneratorFlags) ,//ColumnMetaFlags defined in CatInpro.meta
                                ColumnMetaFromIndex(iColumnMeta)->DefaultValue ? L"<Bytes>" : L"<Null>",
                                UI4(ColumnMetaFromIndex(iColumnMeta)->FlagMask           )  ,//Only valid for flags
                                UI4(ColumnMetaFromIndex(iColumnMeta)->StartingNumber     )  ,//Only valid for UI4s
                                UI4(ColumnMetaFromIndex(iColumnMeta)->EndingNumber       )  ,//Only valid for UI4s
                                ColumnMetaFromIndex(iColumnMeta)->CharacterSet ? String(ColumnMetaFromIndex(iColumnMeta)->CharacterSet) : L"<Null>",//Index into Pool - Only valid for WSTRs
                                ColumnMetaFromIndex(iColumnMeta)->ciTagMeta                 ,//Count of Tags - Only valid for UI4s
                                ColumnMetaFromIndex(iColumnMeta)->iTagMeta                  ,//Index into TagMeta - Only valid for UI4s
								String(ColumnMetaFromIndex(iColumnMeta)->Description    )   );  //Index into Pool
                output(szBuf);Sleep(10);
            }
        }
        if(dwDump & kTagMeta)
        {
            wsprintf(szBuf, L"\nTagMeta\n");output(szBuf);
            wsprintf(szBuf, L"{%40s, %15s, %40s, %40s, %15s}\n", L"Table", L"ColumnIndex", L"InternalName", L"PublicName", L"Value");
            output(szBuf);
            for(unsigned int iTagMeta=0; iTagMeta<GetCountTagMeta(); iTagMeta++)
            {
                wsprintf(szBuf, L"{%40s,      0x%08X, %40s, %40s,      0x%08X}\n", 
                                String (TagMetaFromIndex(iTagMeta)->Table           ),
                                UI4    (TagMetaFromIndex(iTagMeta)->ColumnIndex     ),
                                String (TagMetaFromIndex(iTagMeta)->InternalName    ),
                                String (TagMetaFromIndex(iTagMeta)->PublicName      ),        
                                UI4    (TagMetaFromIndex(iTagMeta)->Value           ));
                output(szBuf);Sleep(10);
            }
        }
        if(dwDump & kIndexMeta)
        {
            wsprintf(szBuf, L"\nIndexMeta\n");output(szBuf);
            wsprintf(szBuf, L"{%40s, %40s, %15s, %40s, %40s, %15s, %15s}\n", L"Table", L"PublicName", L"ColumnIndex", L"InternalName", L"ColumnInternalName", L"MetaFlags", L"iHashTable");
            output(szBuf);
            for(unsigned int iIndexMeta=0; iIndexMeta<GetCountIndexMeta(); iIndexMeta++)
            {
                wsprintf(szBuf, L"{%40s, %40s,      0x%08X, %40s, %40s,      0x%08X,      0x%08X}\n", 
                                String (IndexMetaFromIndex(iIndexMeta)->Table               ),
                                String (IndexMetaFromIndex(iIndexMeta)->PublicName          ),
                                UI4    (IndexMetaFromIndex(iIndexMeta)->ColumnIndex         ),
                                String (IndexMetaFromIndex(iIndexMeta)->InternalName        ),        
                                String (IndexMetaFromIndex(iIndexMeta)->ColumnInternalName  ),
                                UI4    (IndexMetaFromIndex(iIndexMeta)->MetaFlags           ),
                                        IndexMetaFromIndex(iIndexMeta)->iHashTable          );
                output(szBuf);Sleep(10);
            }
        }
        if(dwDump & kQueryMeta)
        {
            wsprintf(szBuf, L"\nQueryMeta\n");output(szBuf);
            wsprintf(szBuf, L"{%40s, %40s, %40s, %15s, %40s, %15s, %15s}\n", L"Table", L"InternalName", L"PublicName" ,L"Index" ,L"CellName" ,L"Operator" ,L"MetaFlags");
            output(szBuf);
            for(unsigned int iQueryMeta=0; iQueryMeta<GetCountQueryMeta(); iQueryMeta++)
            {
                wsprintf(szBuf, L"{%40s, %40s, %40s,      0x%08X, %40s,      0x%08X,      0x%08X}\n", 
                                String (QueryMetaFromIndex(iQueryMeta)->Table       ),
                                String (QueryMetaFromIndex(iQueryMeta)->InternalName),
                                String (QueryMetaFromIndex(iQueryMeta)->PublicName  ),
                                UI4    (QueryMetaFromIndex(iQueryMeta)->Index       ),
                                String (QueryMetaFromIndex(iQueryMeta)->CellName    ),
                                UI4    (QueryMetaFromIndex(iQueryMeta)->Operator    ),
                                UI4    (QueryMetaFromIndex(iQueryMeta)->MetaFlags   ));
                output(szBuf);Sleep(10);
            }
        }
        if(dwDump & kRelationMeta)
        {
            wsprintf(szBuf, L"\nRelationMeta\n");output(szBuf);
            wsprintf(szBuf, L"{%40s, %20s, %40s, %20s, %15s}\n", L"PrimaryTable", L"PrimaryColumns", L"ForeignTable", L"ForeignColumns", L"MetaFlags");
            output(szBuf);
            for(unsigned int iRelationMeta=0; iRelationMeta<GetCountRelationMeta(); iRelationMeta++)
            {
                wsprintf(szBuf, L"{%40s, %20s, %40s, %20s,      0x%08X}\n", 
                                String(RelationMetaFromIndex(iRelationMeta)->PrimaryTable   ),
                                                L"<bytes>"                               ,
                                String(RelationMetaFromIndex(iRelationMeta)->ForeignTable   ),
                                                L"<bytes>"                               ,
                                UI4(RelationMetaFromIndex(iRelationMeta)->MetaFlags         ));
                output(szBuf);Sleep(10);
            }
        }
        if(dwDump & kServerWiringMeta)
        {
            wsprintf(szBuf, L"\nServerWiringMeta\n");output(szBuf);
            wsprintf(szBuf, L"{%40s, %15s, %15s, %40s, %15s, %40s, %15s, %40s, %15s, %40s, %15s, %15s, %40s}\n", 
				L"Table" ,L"Order" ,L"ReadPlugin" L"ReadPluginDLLName",L"WritePlugin",L"WritePluginDLLName"
                ,L"Interceptor" ,L"InterceptorDLLName" ,L"Flags" ,L"Locator" ,L"Reserved", L"Merger", L"MergerDLLName");
            output(szBuf);
            for(unsigned int iServerWiringMeta=0; iServerWiringMeta<GetCountServerWiringMeta(); ++iServerWiringMeta)
            {
                ServerWiringMeta *pServerWiringMeta = ServerWiringMetaFromIndex(iServerWiringMeta);
                wsprintf(szBuf, L"{%40s, %15d, %15d, %40s, %15d, %40s, %15d, %40s, %15d, %40s, %15d, %15d, %40s}\n"
                    ,String(pServerWiringMeta->Table)
                    ,UI4   (pServerWiringMeta->Order)
                    ,UI4   (pServerWiringMeta->ReadPlugin)
					,String(pServerWiringMeta->ReadPluginDLLName)
                    ,UI4   (pServerWiringMeta->WritePlugin)
					,String(pServerWiringMeta->WritePluginDLLName)
                    ,UI4   (pServerWiringMeta->Interceptor)
                    ,String(pServerWiringMeta->InterceptorDLLName)
                    ,UI4   (pServerWiringMeta->Flags)
                    ,String(pServerWiringMeta->Locator)
                    ,UI4   (pServerWiringMeta->Reserved)
					,UI4   (pServerWiringMeta->Merger)
                    ,String(pServerWiringMeta->MergerDLLName));
                output(szBuf);Sleep(10);
            }
        }
    }
protected:
    //We need a buch of Heaps.  We could use the Array template (array_t.h); but we're going to use THeap instead.
    THeap<ColumnMeta      >     m_HeapColumnMeta      ;
    THeap<DatabaseMeta    >     m_HeapDatabaseMeta    ;
    THeap<HashedIndex     >     m_HeapHashedIndex     ;
    THeap<IndexMeta       >     m_HeapIndexMeta       ;
    THeap<QueryMeta       >     m_HeapQueryMeta       ;
    THeap<RelationMeta    >     m_HeapRelationMeta    ;
    THeap<ServerWiringMeta>     m_HeapServerWiringMeta;
    THeap<TableMeta       >     m_HeapTableMeta       ;
    THeap<TagMeta         >     m_HeapTagMeta         ;
    THeap<ULONG           >     m_HeapULONG           ;

    TPooledHeap                 m_HeapPooled          ;
};

#endif //__TFIXUPHEAPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\thasheduniqueindexes.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __THASHEDUNIQUEINDEXES_H__
    #include "THashedUniqueIndexes.h"
#endif
#ifndef __TQUERYMETA_H__
    #include "TQueryMeta.h"
#endif

class TServerWiringMeta : public TMetaTable<ServerWiringMeta>
{
public:
    TServerWiringMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<ServerWiringMeta>(fixup,i){}

    virtual ServerWiringMeta *Get_pMetaTable ()       {return m_Fixup.ServerWiringMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount  () const {return m_Fixup.GetCountServerWiringMeta();};
    const ServerWiringMeta & Get_MetaTable () const {return *m_Fixup.ServerWiringMetaFromIndex(m_iCurrent);}
};


THashedUniqueIndexes::THashedUniqueIndexes() :
                m_pFixup(0)
                ,m_pOut(0)
{
}


THashedUniqueIndexes::~THashedUniqueIndexes()
{
}


void THashedUniqueIndexes::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    TTableMeta tableMeta(fixup);
    for(ULONG iTableMeta=0; iTableMeta<tableMeta.GetCount();++iTableMeta, tableMeta.Next())
    {
        FillInTheHashTableViaIndexMeta(tableMeta);
    }
}


extern unsigned int kPrime[];


unsigned long THashedUniqueIndexes::DetermineBestModulo(ULONG cRows, ULONG aHashes[])
{
    unsigned long BestModulo = 0;
    unsigned int LeastDups                  = -1;

    static HashedIndex  pHashTable[kLargestPrime * 2];

    //Let's first see if the index is a reasonable one for large tables
    if(cRows > kLargestPrime/2)
        return kLargestPrime;

    ULONG cPrimesTried=0;
    ULONG AccumulativeLinkage=0;
    ULONG BestModuloRating=0;
    for(unsigned int iPrimeNumber=0; kPrime[iPrimeNumber] != 0 && kPrime[iPrimeNumber]<(cRows * 20) && BestModuloRating<60; ++iPrimeNumber)
    {
        if(kPrime[iPrimeNumber]<cRows)//we don't have a chance of coming up with few duplicates if the prime number is LESS than the number of rows in the table.
            continue;                //So skip all the small primes.

        m_pOut->printf(L".");

        unsigned int Dups           = 0;
        unsigned int DeepestLink    = 0;

        AccumulativeLinkage=0;

        //We're going to use the HashPool to store this temporary data so we can figure out the dup count and the deepest depth
        memset(pHashTable, -1, sizeof(pHashTable));
        for(unsigned long iRow=0; iRow<cRows && Dups<LeastDups;++iRow)
        {
            ULONG HashedIndex = aHashes[iRow] % kPrime[iPrimeNumber];

            if(0 == pHashTable[HashedIndex].iNext)//if this is the second time we've seen this hash, then bump the Dups
                ++Dups;

            ++(pHashTable[HashedIndex].iNext);//For now Next holds the number of occurances of this hash
            AccumulativeLinkage += (pHashTable[HashedIndex].iNext+1);

            if(pHashTable[HashedIndex].iNext > DeepestLink)
                DeepestLink = pHashTable[HashedIndex].iNext;
        }
        ++cPrimesTried;
        ULONG ModuloRating = DetermineModuloRating(cRows, AccumulativeLinkage, kPrime[iPrimeNumber]);
        if(ModuloRating > BestModuloRating)
        {
            BestModulo          = kPrime[iPrimeNumber];
            BestModuloRating    = ModuloRating;
        }
        //m_pOut->printf(L"\nRating %4d\tModulo %4d\tcRows %4d\tAccLinkage %4d", ModuloRating, kPrime[iPrimeNumber], cRows, AccumulativeLinkage);
    }
    //m_pOut->printf(L"cPrimesTried %4d\tBestModulo %4d\n", cPrimesTried, BestModulo);

    if(0 == BestModulo)
        THROW(No hashing scheme seems reasonable.);

    return BestModulo;
}

//returns a number between 0 and 100 where 100 is a perfect Modulo
unsigned long THashedUniqueIndexes::DetermineModuloRating(ULONG cRows, ULONG AccumulativeLinkage, ULONG Modulo) const
{
    if(0 == cRows)
        return 100;

    unsigned long ModuloRating = (cRows*100) / AccumulativeLinkage;//This doesn't take into account the Modulo value
    if(ModuloRating > 100)
        return 100;

    //Now we need to add in the bonus that makes the rating go up as we approach  Modulo of kLargestPrime.
    //This wiill raise the Rating by as much as 50% of the way toward 100.  In other word a rating of 60 with a Modulo of kLargestPrime would result in
    //a final rating of 80.
    ModuloRating += (((100 - ModuloRating) * Modulo) / (2*kLargestPrime));

    return ModuloRating;
}

unsigned long THashedUniqueIndexes::FillInTheHashTable(unsigned long cRows, ULONG aHashes[], ULONG Modulo)
{
    HashedIndex header;//This is actually the HashTableHeader
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(&header);
    pHeader->Modulo = Modulo;
    pHeader->Size   = Modulo;//This Size is not only the number of HashedIndex entries but where we put the overflow from duplicate Hashes.

    //We'll fixup the Size member when we're done.
    ULONG iHashTableHeader = m_pFixup->AddHashedIndexToList(&header)/sizeof(HashedIndex);
    ULONG iHashTable = iHashTableHeader+1;

    HashedIndex     hashedindextemp;
    for(ULONG i=0;i<Modulo;++i)//-1 fill the hash table
        m_pFixup->AddHashedIndexToList(&hashedindextemp);

    for(unsigned long iRow=0; iRow<cRows; ++iRow)
    {
        ASSERT(-1 != aHashes[iRow]);//These fixed table should have a hash for each row.  If a hash turns out to be -1, we have a problem, since we've reserved -1 to indicate an empty slot.
        //This builds the hases for the TableName
        ULONG HashedIndex = aHashes[iRow] % pHeader->Modulo;
        if(-1 == m_pFixup->HashedIndexFromIndex(iHashTable + HashedIndex)->iOffset)
            m_pFixup->HashedIndexFromIndex(iHashTable + HashedIndex)->iOffset = iRow;//iNext is already -1 so no need to set it
        else
        {   //Otherwise we have to walk the linked list to find the last one so we can append this one to the end
            unsigned int LastInLink = HashedIndex;
            while(-1 != m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext)
                LastInLink = m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext;

            m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext = pHeader->Size;//Size is the end of the hash table, so append it to the end and bump the Size.

            //Reuse the temp variable
            hashedindextemp.iNext   = -1;//we only added enough for the hash table without the overflow slots.  So these dups need to be added to the heap with -1 set for iNext.
            hashedindextemp.iOffset = iRow;
            m_pFixup->AddHashedIndexToList(&hashedindextemp);

            ++pHeader->Size;
        }
    }

    //Now fix the Header Size         //The type is HashedIndex, so HashedIndex.iOffset maps to HashedHeader.Size
    m_pFixup->HashedIndexFromIndex(iHashTableHeader)->iOffset = pHeader->Size;

    return iHashTableHeader;
}


void THashedUniqueIndexes::FillInTheHashTableViaIndexMeta(TTableMeta &i_tableMeta)
{
    if(0 == i_tableMeta.Get_cIndexMeta())
        return;//If there's no IndexMeta for this table, just return

    ULONG   iIndexMeta=i_tableMeta.Get_iIndexMeta();

    while(iIndexMeta != (i_tableMeta.Get_iIndexMeta() + i_tableMeta.Get_cIndexMeta()))
    {
        TIndexMeta indexMeta(*m_pFixup, iIndexMeta);
        LPCWSTR wszIndexName=indexMeta.Get_InternalName();
        ULONG   i;
        //Walk the indexMeta to find out how many match the Index name
        for(i=iIndexMeta;i<(i_tableMeta.Get_iIndexMeta() + i_tableMeta.Get_cIndexMeta()) && wszIndexName==indexMeta.Get_InternalName();++i, indexMeta.Next());

        //Reset the list to point to the first index (that matches the Index name)
        indexMeta.Reset();
        FillInTheHashTableViaIndexMeta(i_tableMeta, indexMeta, i-iIndexMeta);

        iIndexMeta = i;
    }
}

void THashedUniqueIndexes::FillInTheHashTableViaIndexMeta(TTableMeta &i_tableMeta, TIndexMeta &i_indexMeta, ULONG cIndexMeta)
{
    ASSERT(cIndexMeta != 0);


    //We only build hash table for UNIQUE indexes
//    if(0 == (fINDEXMETA_UNIQUE & *indexMeta.Get_MetaFlags()))
//        return;

    TSmartPointer<TMetaTableBase> pMetaTable;
    GetMetaTable(i_indexMeta.Get_pMetaTable()->Table, &pMetaTable);

    //Only care about the meta tables right now.  In the future we might handle the other fixed tables.  GetMetaTable returns NULL for non Meta tables.
    if(0 == pMetaTable.m_p)
        return;

    m_pOut->printf(L"Building indexed (%s) hash table for table: %s", i_indexMeta.Get_InternalName(), i_tableMeta.Get_InternalName());

    TSmartPointerArray<unsigned long> pRowHash = new unsigned long [pMetaTable->GetCount()];
    if(0 == pRowHash.m_p)
        THROW(OUT OF MEMORY);

    //Get the ColumnMeta so we can interpret pTable correctly.
    for(unsigned long iRow=0; iRow < pMetaTable->GetCount(); ++iRow, pMetaTable->Next())
    {
        ULONG *pData = pMetaTable->Get_pulMetaTable();
        unsigned long RowHash=0;//This hash is the combination of all PKs that uniquely identifies the row
        i_indexMeta.Reset();
        for(ULONG iIndexMeta=0;iIndexMeta < cIndexMeta; i_indexMeta.Next(), ++iIndexMeta)
        {
            ULONG iColumn = *i_indexMeta.Get_ColumnIndex();
            TColumnMeta ColumnMeta(*m_pFixup, i_tableMeta.Get_iColumnMeta() + iColumn);

            if(0 == pData[iColumn])
            {
                m_pOut->printf(L"\nError - Table (%s), Column number %d (%s) is an Index but is set to NULL.\n", i_tableMeta.Get_InternalName(), iColumn, ColumnMeta.Get_InternalName());
                THROW(Fixed table contains NULL value in Unique Index);
            }

            switch(*ColumnMeta.Get_Type())
            {
            case DBTYPE_GUID:
                RowHash = Hash(*m_pFixup->GuidFromIndex(pData[iColumn]), RowHash);break;
            case DBTYPE_WSTR:
                RowHash = Hash(m_pFixup->StringFromIndex(pData[iColumn]), RowHash);break;
            case DBTYPE_UI4:
                RowHash = Hash(m_pFixup->UI4FromIndex(pData[iColumn]), RowHash);break;
            case DBTYPE_BYTES:
                RowHash = Hash(m_pFixup->ByteFromIndex(pData[iColumn]), m_pFixup->BufferLengthFromIndex(pData[iColumn]), RowHash);break;
            default:
                THROW(unsupported type);
            }
        }
        pRowHash[iRow] = RowHash;
    }
    i_indexMeta.Reset();

    //OK Now we have the 32 bit hash values.  Now we need to see which prime number acts as the best modulo.
    unsigned long Modulo = DetermineBestModulo(pMetaTable->GetCount(), pRowHash);

    //Now actually fill in the hash table
    unsigned long iHashTable = FillInTheHashTable(pMetaTable->GetCount(), pRowHash, Modulo);

    i_indexMeta.Get_pMetaTable()->iHashTable = iHashTable;
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_pFixup->HashedIndexFromIndex(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;

    m_pOut->printf(L"\n%s hash table has %d nonunique entries.\n", i_tableMeta.Get_InternalName(), cNonUniqueEntries);

}


void THashedUniqueIndexes::GetMetaTable(ULONG iTableName, TMetaTableBase ** o_ppMetaTable) const
{
    ASSERT(0!=o_ppMetaTable);
    *o_ppMetaTable = 0;
    if(iTableName      == m_pFixup->FindStringInPool(L"COLUMNMETA"))
    {
        *o_ppMetaTable = new TColumnMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"DATABASEMETA"))
    {
        *o_ppMetaTable = new TDatabaseMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"INDEXMETA"))
    {
        *o_ppMetaTable = new TIndexMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"QUERYMETA"))
    {
        *o_ppMetaTable = new TQueryMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"RELATIONMETA"))
    {
        *o_ppMetaTable = new TRelationMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"SERVERWIRINGMETA"))
    {
        *o_ppMetaTable = new TServerWiringMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"TABLEMETA"))
    {
        *o_ppMetaTable = new TTableMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"TAGMETA"))
    {
        *o_ppMetaTable = new TTagMeta(*m_pFixup);
    }
    else return;

    if(0 == *o_ppMetaTable)
        THROW(OUT OF MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\thashedpkindexes.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __THASHEDPKINDEXES_H__
    #include "THashedPKIndexes.h"
#endif
#ifndef __TQUERYMETA_H__
    #include "TQueryMeta.h"
#endif




THashedPKIndexes::THashedPKIndexes() :
                 m_pFixup(0)
                ,m_pOut(0)
{
}

THashedPKIndexes::~THashedPKIndexes()
{
}

void THashedPKIndexes::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    m_HashedIndexHeap.GrowHeap(400000);//make plenty of room to reduce reallocs

    //We special case the Meta tables since we know for a fact that they are ordered in such a way that they can be queried by
    //any number of PrimaryKeys (ie. TagMeta can be queried by Table, Table/ColumnIndex, or Table/ColumnIndex/InternalName).  This
    //is because of the way the Meta tables are sorted and the containment enforced in CatMeta.XML.
    FillInTheHashTableForColumnMeta  ();
    FillInTheHashTableForDatabase    ();
    FillInTheHashTableForIndexMeta   ();
    FillInTheHashTableForQueryMeta   ();
//@@@    FillInTheHashTableForRelationMeta();
    FillInTheHashTableForTableMeta   ();
    FillInTheHashTableForTagMeta     ();

    m_pFixup->AddHashedIndexToList(m_HashedIndexHeap.GetTypedPointer(), m_HashedIndexHeap.GetCountOfTypedItems());
}

//We start with two because there are going to be tables with only one row.  To prevent an 'if' statement
//ALL FIXED tables will have a hash table associated with them, even those with one row.  So by starting
//with 2 as the first prime, the hash table will be of size 2, for those tables with only one row.
unsigned int kPrime[] = {
      2,     3,      5,      7,     11,     13,     17,     19,     23,     29, 
     31,    37,     41,     43,     47,     53,     59,     61,     67,     71, 
     73,    79,     83,     89,     97,    101,    103,    107,    109,    113, 
    127,   131,    137,    139,    149,    151,    157,    163,    167,    173, 
    179,   181,    191,    193,    197,    199,    211,    223,    227,    229, 
    233,   239,    241,    251,    257,    263,    269,    271,    277,    281, 
    283,   293,    307,    311,    313,    317,    331,    337,    347,    349, 
    353,   359,    367,    373,    379,    383,    389,    397,    401,    409, 
    419,   421,    431,    433,    439,    443,    449,    457,    461,    463, 
    467,   479,    487,    491,    499,    503,    509,    521,    523,    541, 
    547,   557,    563,    569,    571,    577,    587,    593,    599,    601, 
    607,   613,    617,    619,    631,    641,    643,    647,    653,    659, 
    661,   673,    677,    683,    691,    701,    709,    719,    727,    733, 
    739,   743,    751,    757,    761,    769,    773,    787,    797,    809, 
    811,   821,    823,    827,    829,    839,    853,    857,    859,    863, 
    877,   881,    883,    887,    907,    911,    919,    929,    937,    941, 
    947,   953,    967,    971,    977,    983,    991,    997,   1009,   1013, 
   1019,  1021,   1031,   1033,   1039,   1049,   1051,   1061,   1063,   1069, 
   1087,  1091,   1093,   1097,   1103,   1109,   1117,   1123,   1129,   1151, 
   1153,  1163,   1171,   1181,   1187,   1193,   1201,   1213,   1217,   1223, 
   1229,  1231,   1237,   1249,   1259,   1277,   1279,   1283,   1289,   1291, 
   1297,  1301,   1303,   1307,   1319,   1321,   1327,   1361,   1367,   1373, 
   1381,  1399,   1409,   1423,   1427,   1429,   1433,   1439,   1447,   1451, 
   1453,  1459,   1471,   1481,   1483,   1487,   1489,   1493,   1499,   1511, 
   1523,  1531,   1543,   1549,   1553,   1559,   1567,   1571,   1579,   1583, 
   1597,  1601,   1607,   1609,   1613,   1619,   1621,   1627,   1637,   1657, 
   1663,  1667,   1669,   1693,   1697,   1699,   1709,   1721,   1723,   1733, 
   1741,  1747,   1753,   1759,   1777,   1783,   1787,   1789,   1801,   1811, 
   1823,  1831,   1847,   1861,   1867,   1871,   1873,   1877,   1879,   1889, 
   1901,  1907,   1913,   1931,   1933,   1949,   1951,   1973,   1979,   1987, 
   1993,  1997,   1999,   2003,   2011,   2017,   2027,   2029,   2039,   2053, 
   2063,  2069,   2081,   2083,   2087,   2089,   2099,   2111,   2113,   2129, 
   2131,  2137,   2141,   2143,   2153,   2161,   2179,   2203,   2207,   2213, 
   2221,  2237,   2239,   2243,   2251,   2267,   2269,   2273,   2281,   2287, 
   2293,  2297,   2309,   2311,   2333,   2339,   2341,   2347,   2351,   2357, 
   2371,  2377,   2381,   2383,   2389,   2393,   2399,   2411,   2417,   2423, 
   2437,  2441,   2447,   2459,   2467,   2473,   2477,   2503,   2521,   2531, 
   2539,  2543,   2549,   2551,   2557,   2579,   2591,   2593,   2609,   2617, 
   2621,  2633,   2647,   2657,   2659,   2663,   2671,   2677,   2683,   2687, 
   2689,  2693,   2699,   2707,   2711,   2713,   2719,   2729,   2731,   2741, 
   2749,  2753,   2767,   2777,   2789,   2791,   2797,   2801,   2803,   2819, 
   2833,  2837,   2843,   2851,   2857,   2861,   2879,   2887,   2897,   2903, 
   2909,  2917,   2927,   2939,   2953,   2957,   2963,   2969,   2971,   2999, 
   3001,  3011,   3019,   3023,   3037,   3041,   3049,   3061,   3067,   3079, 
   3083,  3089,   3109,   3119,   3121,   3137,   3163,   3167,   3169,   3181, 
   3187,  3191,   3203,   3209,   3217,   3221,   3229,   3251,   3253,   3257, 
   3259,  3271,   3299,   3301,   3307,   3313,   3319,   3323,   3329,   3331, 
   3343,  3347,   3359,   3361,   3371,   3373,   3389,   3391,   3407,   3413, 
   3433,  3449,   3457,   3461,   3463,   3467,   3469,   3491,   3499,   3511, 
   3517,  3527,   3529,   3533,   3539,   3541,   3547,   3557,   3559,   3571, 
   3581,  3583,   3593,   3607,   3613,   3617,   3623,   3631,   3637,   3643, 
   3659,  3671,   3673,   3677,   3691,   3697,   3701,   3709,   3719,   3727, 
   3733,  3739,   3761,   3767,   3769,   3779,   3793,   3797,   3803,   3821, 
   3823,  3833,   3847,   3851,   3853,   3863,   3877,   3881,   3889,   3907, 
   3911,  3917,   3919,   3923,   3929,   3931,   3943,   3947,   3967,   3989,
   4001,  4003,   4007,   4013,   4019,   4021,   4027,   4049,   4051,   4057,
   4073,  4079,   4091,   4093,   4099,   4111,   4127,   4129,   4133,   4139,
   4153,  4157,   4159,   4177,   4201,   4211,   4217,   4219,   4229,   4231,
   4241,  4243,   4253,   4259,   4261,   4271,   4273,   4283,   4289,   4297,
   4327,  4337,   4339,   4349,   4357,   4363,   4373,   4391,   4397,   4409,
   4421,  4423,   4441,   4447,   4451,   4457,   4463,   4481,   4483,   4493,
   4507,  4513,   4517,   4519,   4523,   4547,   4549,   4561,   4567,   4583,
   4591,  4597,   4603,   4621,   4637,   4639,   4643,   4649,   4651,   4657,
   4663,  4673,   4679,   4691,   4703,   4721,   4723,   4729,   4733,   4751,
   4759,  4783,   4787,   4789,   4793,   4799,   4801,   4813,   4817,   4831,
   4861,  4871,   4877,   4889,   4903,   4909,   4919,   4931,   4993,   4937,
   4943,  4951,   4957,   4967,   4969,   4973,   4987,   4993,   4999,   5003,
   5009,  5011,   5021,   5023,   5039,   5051,   5059,   5077,   5081,   5087,
   5099,  5101,   5107,   5113,   5119,   5147,   5153,   5167,   5171,   5179,
   5189,  5197,   5209,   5227,   5231,   5233,   5237,   5261,   5273,   5279,
   10007, 20011,  0 };//These last two prime are to cover an extreme corner case


unsigned long THashedPKIndexes::DetermineBestModulo(ULONG cRows, ULONG cPrimaryKeys, HashArray Hashes[])
{
    if(0 == cRows)//Some kinds of meta may have no rows (like IndexMeta).
        return 1;

    unsigned long BestModulo = 0;
    unsigned int LeastDups                  = -1;

    static HashedIndex  pHashTable[kLargestPrime * 2];
    unsigned long PreferredLeastDups = 5;

    if(cRows > kLargestPrime/2)
        return kLargestPrime;

    ULONG LeastDeepestLink = -1;
    ULONG BestModuloRating=0;

    //We're going to use a formula to determine which Modulo is best
    ULONG AccumulativeLinkage=0;
    for(unsigned int iPrimeNumber=0; kPrime[iPrimeNumber] != 0 && kPrime[iPrimeNumber]<(cRows * 20) && BestModuloRating<60; ++iPrimeNumber)
    {
        if(kPrime[iPrimeNumber]<cRows)//we don't have a chance of coming up with few duplicates if the prime number is LESS than the number of rows in the table.
            continue;                //So skip all the small primes.

        m_pOut->printf(L".");

        unsigned int Dups           = 0;
        unsigned int DeepestLink    = 0;

        //We're going to use the HashPool to store this temporary data so we can figure out the dup count and the deepest depth
        memset(pHashTable, -1, sizeof(pHashTable));
        AccumulativeLinkage = 0;
        for(unsigned long iPrimaryKey=0; iPrimaryKey<cPrimaryKeys; ++iPrimaryKey)
        {
            for(unsigned long iRow=0; iRow<cRows/* && Dups<LeastDups && DeepestLink<LeastDeepestLink*/;++iRow)
            {
                if(-1 == Hashes[iPrimaryKey][iRow])//Ignore those with a -1 for the hash.  We're all but guarenteed that all hashes are non -1
                    continue;

                ULONG HashedIndex = Hashes[iPrimaryKey][iRow] % kPrime[iPrimeNumber];

                if(0 == pHashTable[HashedIndex].iNext)//if this is the first duplicate for this hash, then bump the Dups
                    ++Dups;

                ++(pHashTable[HashedIndex].iNext);//For now Next holds the number of occurances of this hash
                AccumulativeLinkage += (pHashTable[HashedIndex].iNext + 1);

                if(pHashTable[HashedIndex].iNext > DeepestLink)
                    DeepestLink = pHashTable[HashedIndex].iNext;
            }
        }
        ULONG ModuloRating = DetermineModuloRating(cRows, AccumulativeLinkage, kPrime[iPrimeNumber]);
        if(ModuloRating > BestModuloRating)
        {
            BestModulo          = kPrime[iPrimeNumber];
            BestModuloRating    = ModuloRating;
        }
        //m_pOut->printf(L"\nRating %4d\tModulo %4d\tcRows %4d\tAccLinkage %4d", ModuloRating, kPrime[iPrimeNumber], cRows, AccumulativeLinkage);
    }

    if(0 == BestModulo)
        THROW(No hashing scheme seems reasonable.);

    return BestModulo;
}

//returns a number between 0 and 100 where 100 is a perfect Modulo
unsigned long THashedPKIndexes::DetermineModuloRating(ULONG cRows, ULONG AccumulativeLinkage, ULONG Modulo) const
{
    if(0 == cRows)
        return 100;

    unsigned long ModuloRating = (cRows*100) / AccumulativeLinkage;//This doesn't take into account the Modulo value
    if(ModuloRating > 100)
        return 100;

    //Now we need to add in the bonus that makes the rating go up as we approach  Modulo of kLargestPrime.
    //This wiill raise the Rating by as much as 50% of the way toward 100.  In other word a rating of 60 with a Modulo of kLargestPrime would result in
    //a final rating of 80.
    ModuloRating += (((100 - ModuloRating) * Modulo) / kLargestPrime);

    return ModuloRating;
}

unsigned long THashedPKIndexes::FillInTheHashTable(unsigned long cRows, unsigned long cPrimaryKeys, HashArray Hashes[], ULONG Modulo)
{
    HashedIndex header;//This is actually the HashTableHeader
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(&header);
    pHeader->Modulo = Modulo;
    pHeader->Size   = Modulo;//This Size is not only the number of HashedIndex entries but where we put the overflow from duplicate Hashes.

    //We'll fixup the Size member when we're done.
    ULONG iHashTableHeader = m_HashedIndexHeap.AddItemToHeap(header)/sizeof(HashedIndex);
    ULONG iHashTable = iHashTableHeader+1;

    HashedIndex     hashedindextemp;
    for(ULONG i=0;i<Modulo;++i)
        m_HashedIndexHeap.AddItemToHeap(hashedindextemp);

    for(unsigned long iPrimaryKey=0; iPrimaryKey<cPrimaryKeys; ++iPrimaryKey)
    {
        for(unsigned long iRow=0; iRow<cRows; ++iRow)
        {
            if(-1 != Hashes[iPrimaryKey][iRow])
            {   //This builds the hases for the TableName
                ULONG HashedIndex = Hashes[iPrimaryKey][iRow] % pHeader->Modulo;
                if(-1 == m_HashedIndexHeap.GetTypedPointer(iHashTable + HashedIndex)->iOffset)
                    m_HashedIndexHeap.GetTypedPointer(iHashTable + HashedIndex)->iOffset = iRow;//iNext is already -1 so no need to set it
                else
                {   //Otherwise we have to walk the linked list to find the last one so we can append this one to the end
                    unsigned int LastInLink = HashedIndex;
                    while(-1 != m_HashedIndexHeap.GetTypedPointer(iHashTable + LastInLink)->iNext)
                        LastInLink = m_HashedIndexHeap.GetTypedPointer(iHashTable + LastInLink)->iNext;

                    m_HashedIndexHeap.GetTypedPointer(iHashTable + LastInLink)->iNext = pHeader->Size;//Size is the end of the hash table, so append it to the end and bump the Size.

                    //Reuse the temp variable
                    hashedindextemp.iNext   = -1;//we only added enough for the hash table without the overflow slots.  So these dups need to be added to the heap with -1 set for iNext.
                    hashedindextemp.iOffset = iRow;
                    m_HashedIndexHeap.AddItemToHeap(hashedindextemp);

                    ++pHeader->Size;
                }
            }
        }
    }
    //Now fix the Header Size         //The type is HashedIndex, so HashedIndex.iOffset maps to HashedHeader.Size
    m_HashedIndexHeap.GetTypedPointer(iHashTableHeader)->iOffset = pHeader->Size;

    return iHashTableHeader;
}

void THashedPKIndexes::FillInTheHashTableForColumnMeta()
{
    m_pOut->printf(L"Building ColumnMeta hash table");
    unsigned int iRow,iPrimaryKey;//indexes are reused

    //ColumnMeta has two primarykeys so build hashes for all of the first PK, then build the hashes for both PKs
    const int cPrimaryKeys = 2;
    HashArray Hashes[cPrimaryKeys];
    TColumnMeta ColumnMeta(*m_pFixup);
    ULONG cRows = ColumnMeta.GetCount();
    if(cRows>(kLargestPrime*2))
    {
        m_pOut->printf(L"Error! Too Many Rows - ColumnMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
        THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
    }

    LPCWSTR pPrevTableName=0;
    Hashes[0][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, ColumnMeta.Next())
    {
        if(ColumnMeta.Get_Table() == pPrevTableName)
            Hashes[0][iRow] = -1;
        else
            Hashes[0][iRow] = Hash(pPrevTableName=ColumnMeta.Get_Table(), 0);
    }

    ColumnMeta.Reset();
    Hashes[1][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, ColumnMeta.Next())
    {
        if(0 == ColumnMeta.Get_Index())
            Hashes[1][iRow] = -1;
        else
            Hashes[1][iRow] = Hash(*ColumnMeta.Get_Index(), Hash(ColumnMeta.Get_Table(), 0));
    }
    //At this point we have a list of the 32 bit hash values

    //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
    //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
    //and determine which one leaves up with the least duplicates.

    unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, Hashes);

    //OK, now that the setup is done we can build the hash.  We reuse the Hashes list since it just stores the 32 bit hash values.
    //We just need to modulo the value to store it into the hash.
    unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, Hashes, Modulo);

    ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"COLUMNMETA");
    m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
    m_pOut->printf(L"\nColumnMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
}

void THashedPKIndexes::FillInTheHashTableForDatabase    ()
{
    m_pOut->printf(L"Building DatabaseMeta hash table");
    unsigned int iRow,iPrimaryKey;//indexes are reused

    //DatabaseMeta has one primarykey so build hashes for the PK values
    const int cPrimaryKeys = 1;
    HashArray Hashes[cPrimaryKeys];
    TDatabaseMeta DatabaseMeta(*m_pFixup);
    ULONG cRows = DatabaseMeta.GetCount();
    if(cRows>(kLargestPrime*2))
    {
        m_pOut->printf(L"Error! Too Many Rows - DatabaseMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
        THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
    }

    Hashes[0][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, DatabaseMeta.Next())
        Hashes[0][iRow] = Hash(DatabaseMeta.Get_InternalName(), 0);

    //At this point we have a list of the 32 bit hash values

    //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
    //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
    //and determine which one leaves up with the least duplicates.

    unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, Hashes);

    //OK, now that the setup is done we can build the hash.  We reuse the Hashes list since it just stores the 32 bit hash values.
    //We just need to modulo the value to store it into the hash.
    unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, Hashes, Modulo);

    ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"DATABASEMETA");
    m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
    m_pOut->printf(L"\nDatabaseMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
}

void THashedPKIndexes::FillInTheHashTableForIndexMeta   ()
{
    m_pOut->printf(L"Building IndexMeta hash table");
    unsigned int iRow,iPrimaryKey;//indexes are reused

    //IndexMeta has three primarykeys so build hashes for all of the first PK, then build the hashes for two PKs, then all three
    const int cPrimaryKeys = 3;
    HashArray Hashes[cPrimaryKeys];
    TIndexMeta IndexMeta(*m_pFixup);
    ULONG cRows = IndexMeta.GetCount();
    if(cRows>(kLargestPrime*2))
    {
        m_pOut->printf(L"Error! Too Many Rows - IndexMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
        THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
    }

    LPCWSTR pPrevTableName=0;
    Hashes[0][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, IndexMeta.Next())
    {
        if(IndexMeta.Get_Table() == pPrevTableName)
            Hashes[0][iRow] = -1;
        else
            Hashes[0][iRow] = Hash(pPrevTableName=IndexMeta.Get_Table(), 0);
    }

    IndexMeta.Reset();
    pPrevTableName=0;
    LPCWSTR pPrevInteralName=0;
    Hashes[1][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, IndexMeta.Next())
    {
        if(IndexMeta.Get_Table() == pPrevTableName && IndexMeta.Get_InternalName() == pPrevInteralName)
            Hashes[1][iRow] = -1;
        else
            Hashes[1][iRow] = Hash(pPrevInteralName=IndexMeta.Get_InternalName(), Hash(pPrevTableName=IndexMeta.Get_Table(), 0));
    }

    IndexMeta.Reset();
    for(iRow=0; iRow<cRows; ++iRow, IndexMeta.Next())
        Hashes[2][iRow] = Hash(*IndexMeta.Get_ColumnIndex(), Hash(IndexMeta.Get_InternalName(), Hash(IndexMeta.Get_Table(), 0)));

    //At this point we have a list of the 32 bit hash values

    //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
    //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
    //and determine which one leaves up with the least duplicates.

    unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, Hashes);

    //OK, now that the setup is done we can build the hash.  We reuse the Hashes list since it just stores the 32 bit hash values.
    //We just need to modulo the value to store it into the hash.
    unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, Hashes, Modulo);

    ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"INDEXMETA");
    m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
    m_pOut->printf(L"\nIndexMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
}

void THashedPKIndexes::FillInTheHashTableForQueryMeta   ()
{
    m_pOut->printf(L"Building QueryMeta hash table");
    unsigned int iRow,iPrimaryKey;//indexes are reused

    //QueryMeta has two primarykeys so build hashes for all of the first PK, then build the hashes for two PKs
    const int cPrimaryKeys = 2;
    HashArray Hashes[cPrimaryKeys];
    TQueryMeta QueryMeta(*m_pFixup);
    ULONG cRows = QueryMeta.GetCount();
    if(cRows>(kLargestPrime*2))
    {
        m_pOut->printf(L"Error! Too Many Rows - QueryMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
        THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
    }

    LPCWSTR pPrevTableName=0;
    Hashes[0][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, QueryMeta.Next())
    {
        if(QueryMeta.Get_Table() == pPrevTableName)
            Hashes[0][iRow] = -1;
        else
            Hashes[0][iRow] = Hash(pPrevTableName=QueryMeta.Get_Table(), 0);
    }

    QueryMeta.Reset();
    Hashes[1][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, QueryMeta.Next())
            Hashes[1][iRow] = Hash(QueryMeta.Get_InternalName(), Hash(QueryMeta.Get_Table(), 0));

    //At this point we have a list of the 32 bit hash values

    //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
    //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
    //and determine which one leaves up with the least duplicates.

    unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, Hashes);

    //OK, now that the setup is done we can build the hash.  We reuse the Hashes list since it just stores the 32 bit hash values.
    //We just need to modulo the value to store it into the hash.
    unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, Hashes, Modulo);

    ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"QUERYMETA");
    m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
    m_pOut->printf(L"\nQueryMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
}

void THashedPKIndexes::FillInTheHashTableForRelationMeta()
{
    //@@@ We can't do the relation meta until we sort them.  At that point we need to sort the rows by PrimaryTable and have a separate table sorted
    //@@@ by ForeignTable
}

void THashedPKIndexes::FillInTheHashTableForTableMeta   ()
{
    m_pOut->printf(L"Building TableMeta hash table");
    unsigned int iRow,iPrimaryKey;//indexes are reused

    //TableMeta has one primarykey so build hashes for the PK values
    const int cPrimaryKeys = 1;
    HashArray Hashes[cPrimaryKeys];
    TTableMeta TableMeta(*m_pFixup);
    ULONG cRows = TableMeta.GetCount();
    if(cRows>(kLargestPrime*2))
    {
        m_pOut->printf(L"Error! Too Many Rows - TableMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
        THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
    }

    Hashes[0][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, TableMeta.Next())
        Hashes[0][iRow] = Hash(TableMeta.Get_InternalName(), 0);

    //At this point we have a list of the 32 bit hash values

    //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
    //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
    //and determine which one leaves up with the least duplicates.

    unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, Hashes);

    //OK, now that the setup is done we can build the hash.  We reuse the Hashes list since it just stores the 32 bit hash values.
    //We just need to modulo the value to store it into the hash.
    unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, Hashes, Modulo);

    ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"TABLEMETA");
    m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
    m_pOut->printf(L"\nTableMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
}

void THashedPKIndexes::FillInTheHashTableForTagMeta     ()
{
    m_pOut->printf(L"Building TagMeta hash table");
    unsigned int iRow,iPrimaryKey;//indexes are reused

    //TagMeta has three primarykeys so build hashes for all of the first PK, then build the hashes for two PKs, then all three
    const int cPrimaryKeys = 3;
    HashArray Hashes[cPrimaryKeys];
    TTagMeta TagMeta(*m_pFixup);
    ULONG cRows = TagMeta.GetCount();
    if(cRows>(kLargestPrime*2))
    {
        m_pOut->printf(L"Error! Too Many Rows - TagMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
        THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
    }

    LPCWSTR pPrevTableName=0;
    Hashes[0][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, TagMeta.Next())
    {
        if(TagMeta.Get_Table() == pPrevTableName)
            Hashes[0][iRow] = -1;
        else
            Hashes[0][iRow] = Hash(pPrevTableName=TagMeta.Get_Table(), 0);
    }

    TagMeta.Reset();
    pPrevTableName=0;
    ULONG iPrevColumnIndex=-1;
    Hashes[1][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, TagMeta.Next())
    {
        if(TagMeta.Get_Table() == pPrevTableName && *TagMeta.Get_ColumnIndex() == iPrevColumnIndex)
            Hashes[1][iRow] = -1;
        else
            Hashes[1][iRow] = Hash(iPrevColumnIndex=*TagMeta.Get_ColumnIndex(), Hash(pPrevTableName=TagMeta.Get_Table(), 0));
    }

    TagMeta.Reset();
    Hashes[2][0] = -1;
    for(iRow=0; iRow<cRows; ++iRow, TagMeta.Next())
        Hashes[2][iRow] = Hash(TagMeta.Get_InternalName(), Hash(*TagMeta.Get_ColumnIndex(), Hash(TagMeta.Get_Table(), 0)));

    //At this point we have a list of the 32 bit hash values

    //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
    //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
    //and determine which one leaves up with the least duplicates.

    unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, Hashes);

    //OK, now that the setup is done we can build the hash.  We reuse the Hashes list since it just stores the 32 bit hash values.
    //We just need to modulo the value to store it into the hash.
    unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, Hashes, Modulo);

    ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"TAGMETA");
    m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
    m_pOut->printf(L"\nTagMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\thasheduniqueindexes.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __THASHEDUNIQUEINDEXES_H__
#define __THASHEDUNIQUEINDEXES_H__

#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif

class THashedUniqueIndexes : public ICompilationPlugin
{
public:
    THashedUniqueIndexes();
    ~THashedUniqueIndexes();

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    TPEFixup *          m_pFixup;
    TOutput  *          m_pOut;

    unsigned long   DetermineBestModulo(ULONG cRows, ULONG aHashes[]);
    unsigned long   DetermineModuloRating(ULONG cRows, ULONG AccumulativeLinkage, ULONG Modulo) const;
    unsigned long   FillInTheHashTable(unsigned long cRows, ULONG aHashes[], ULONG Modulo);
    void            FillInTheHashTableViaIndexMeta(TTableMeta &i_TableMeta);
    void            FillInTheHashTableViaIndexMeta(TTableMeta &i_tableMeta, TIndexMeta &i_indexMeta, ULONG cIndexMeta);
    void            GetMetaTable(ULONG iTableName, TMetaTableBase ** o_ppMetaTable) const;
};



#endif // __THASHEDUNIQUEINDEXES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tlateschemavalidate.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TLATESCHEMAVALIDATE_H__
#define __TLATESCHEMAVALIDATE_H__

#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif


class TLateSchemaValidate : public ICompilationPlugin
{
public:
    TLateSchemaValidate(){}
    virtual void Compile(TPEFixup &fixup, TOutput &out);
};

#endif //__TLATESCHEMAVALIDATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tmbschemageneration.h ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMBSchemaGeneration.h
// Author:          Stephenr
// Date Created:    10/9/2000
// Description:     This compilation plugin takes the metabase's meta and generates MBSchema.xml.
//

#ifndef __TMBSCHEMAGENERATION_H__
#define __TMBSCHEMAGENERATION_H__

#ifndef __STDAFX_H__
    #include "stdafx.h"
#endif
#ifndef __catalog_h__
    #include "catalog.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif


class TMBSchemaGeneration : public ICompilationPlugin
{
public:
    TMBSchemaGeneration(LPCWSTR i_wszSchemaXmlFile);

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    LPCWSTR     m_wszSchemaXmlFile;
};
#endif // __TMBSCHEMAGENERATION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tlateschemavalidate.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"


void TLateSchemaValidate::Compile(TPEFixup &fixup, TOutput &out)
{
    //Currently we only have one LateSchemaValidation to to:

    //We walk the hash table entries for the TableMeta, looking for tables with the same name (case insensitive)
    //We need to be run AFTER the PK hash tables are built.
    TTableMeta tablemeta(fixup);

    ULONG iTableMeta=0;
    for(; iTableMeta< tablemeta.GetCount() && 0!=_wcsicmp(tablemeta.Get_InternalName(), L"TABLEMETA"); ++iTableMeta, tablemeta.Next());
    
    //We couldn't have gotten this far without TABLEMETA existing; but what the heck let's check anyway
    if(iTableMeta == tablemeta.GetCount())
    {
        THROW(ERROR - NO TABLEMETA FOR TABLEMETA FOUND);
    }

    HashTableHeader * pHashTableHeader      = reinterpret_cast<HashTableHeader *>(fixup.HashedIndexFromIndex(tablemeta.Get_iHashTableHeader()));
    HashedIndex     * pHashedIndexZeroth    = reinterpret_cast<HashedIndex *>(pHashTableHeader+1);

    HashedIndex     * pHashedIndex          = pHashedIndexZeroth;
    for(ULONG iHashTable=0; iHashTable<pHashTableHeader->Modulo; ++iHashTable, ++pHashedIndex)
    {
        if(-1 != pHashedIndex->iNext)//if there are more than one TableMeta at this hash entry
        {
            ASSERT(-1 != pHashedIndex->iOffset);//it does not make sense to have more than one row with the same hash; but have the row index be -1.

            HashedIndex *pHashIndexTemp0 = pHashedIndex;
            while(pHashIndexTemp0->iNext != -1)//follow the chain
            {
                HashedIndex *pHashIndexTemp1 = pHashIndexTemp0;
                while(pHashIndexTemp1->iNext != -1)//follow the chain
                {
                    pHashIndexTemp1 = pHashedIndexZeroth + pHashIndexTemp1->iNext;
                    ASSERT(-1 != pHashIndexTemp1->iOffset);//it does not make sense to have a hash entry for row -1.

                    if(0 == _wcsicmp(fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp0->iOffset)->InternalName),
                                     fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp1->iOffset)->InternalName)))
                    {
                        out.printf(L"TableName collision between (Database:%s Table:%s) and (Database:%s Table:%s)\r\n",
                            fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp0->iOffset)->Database),
                            fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp0->iOffset)->InternalName),
                            fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp1->iOffset)->Database),
                            fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp1->iOffset)->InternalName));
                        THROW(ERROR - TWO TABLE HAVE THE SAME CASE INSENSITIVE NAME);
                    }
                }

                pHashIndexTemp0 = pHashedIndexZeroth + pHashIndexTemp0->iNext;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tmbschemageneration.cpp ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMBSchemaGeneration.cpp
// Author:          Stephenr
// Date Created:    10/9/2000
// Description:     This compilation plugin takes the metabase's meta and generates MBSchema.xml.
//

#ifndef __XMLUTILITY_H__
    #include "XMLUtility.h"
#endif
#ifndef __TABLEINFO_H__  
    #include "catmeta.h"
#endif
#ifndef __TMBSCHEMAGENERATION_H__
    #include "TMBSchemaGeneration.h"
#endif
#ifndef _WRITER_GLOBAL_HELPER_H_
    #include "WriterGlobalHelper.h"
#endif
#ifndef _WRITER_H
    #include "Writer.h"
#endif
#ifndef _CATALOGPROPERTYWRITER_H_
    #include "CatalogPropertyWriter.h"
#endif
#ifndef _CATALOGCOLLECTIONWRITER_H_
    #include "CatalogCollectionWriter.h"
#endif
#ifndef _CATALOGSCHEMAWRITER_H_
    #include "CatalogSchemaWriter.h"
#endif
//#include "WriterGlobals.h"



TMBSchemaGeneration::TMBSchemaGeneration(LPCWSTR i_wszSchemaXmlFile) :
                m_wszSchemaXmlFile(i_wszSchemaXmlFile)
{
}

void TMBSchemaGeneration::Compile(TPEFixup &fixup, TOutput &out)
{
    TDatabaseMeta databasemeta(fixup);
    ULONG iMetabaseDatabaseMeta=0;
    for( ;iMetabaseDatabaseMeta<databasemeta.GetCount(); ++iMetabaseDatabaseMeta, databasemeta.Next())
    {
        if(0 == _wcsicmp(databasemeta.Get_InternalName(), wszDATABASE_METABASE))
            break;
    }
    if(databasemeta.GetCount() == iMetabaseDatabaseMeta)
    {
        THROW(METABASE DATABASE NOT FOUND);
    }

    {//CWriter doesn't close the file until the dtor, so scope it here
        //I don't have to keep track of these pointers, they are owned by the object that returns them.
        CWriter writer;
        XIF(writer.Initialize(m_wszSchemaXmlFile, NULL));
	    XIF(writer.BeginWrite(eWriter_Schema));//This writes the UTF8 header bytes

        TSmartPointer<CCatalogSchemaWriter> spCSchemaWriter;
	    XIF(writer.GetCatalogSchemaWriter(&spCSchemaWriter));

        TTableMeta tablemeta(fixup, databasemeta.Get_iTableMeta()+1);//skip the MetabaseBaseClass
        LPCWSTR pszMETABASE = tablemeta.Get_Database();                
        for(ULONG iTableMeta=databasemeta.Get_iTableMeta()+1; iTableMeta<(tablemeta.GetCount()-2); ++iTableMeta, tablemeta.Next())
        {
            ASSERT(tablemeta.Get_Database()==pszMETABASE);
            if(0 == wcscmp(tablemeta.Get_InternalName(), wszTABLE_IIsInheritedProperties))
                continue;
            if(0 == wcscmp(tablemeta.Get_InternalName(), wszTABLE_MBProperty))
                break;
            /*
            struct tTABLEMETARow {
                     WCHAR *     pDatabase;
                     WCHAR *     pInternalName;
                     WCHAR *     pPublicName;
                     WCHAR *     pPublicRowName;
                     ULONG *     pBaseVersion;
                     ULONG *     pExtendedVersion;
                     ULONG *     pNameColumn;
                     ULONG *     pNavColumn;
                     ULONG *     pCountOfColumns;
                     ULONG *     pMetaFlags;
                     ULONG *     pSchemaGeneratorFlags;
                     WCHAR *     pConfigItemName;
                     WCHAR *     pConfigCollectionName;
                     ULONG *     pPublicRowNameColumn;
                     WCHAR *     pContainerClassList;
					 WCHAR *	 pDescription;
            };*/
		    tTABLEMETARow tmRow;
            tmRow.pDatabase                 = const_cast<LPWSTR> (tablemeta.Get_Database            ());
            tmRow.pInternalName             = const_cast<LPWSTR> (tablemeta.Get_InternalName        ());
            tmRow.pPublicName               = const_cast<LPWSTR> (tablemeta.Get_PublicName          ());
            tmRow.pPublicRowName            = const_cast<LPWSTR> (tablemeta.Get_PublicRowName       ());
            tmRow.pBaseVersion              = const_cast<ULONG *>(tablemeta.Get_BaseVersion         ());
            tmRow.pExtendedVersion          = const_cast<ULONG *>(tablemeta.Get_ExtendedVersion     ());
            tmRow.pNameColumn               = const_cast<ULONG *>(tablemeta.Get_NameColumn          ());
            tmRow.pNavColumn                = const_cast<ULONG *>(tablemeta.Get_NavColumn           ());
            tmRow.pCountOfColumns           = const_cast<ULONG *>(tablemeta.Get_CountOfColumns      ());
            tmRow.pMetaFlags                = const_cast<ULONG *>(tablemeta.Get_MetaFlags           ());
            tmRow.pSchemaGeneratorFlags     = const_cast<ULONG *>(tablemeta.Get_SchemaGeneratorFlags());
            tmRow.pConfigItemName           = const_cast<LPWSTR> (tablemeta.Get_ConfigItemName      ());
            tmRow.pConfigCollectionName     = const_cast<LPWSTR> (tablemeta.Get_ConfigCollectionName());
            tmRow.pPublicRowNameColumn      = const_cast<ULONG *>(tablemeta.Get_PublicRowNameColumn ());
            tmRow.pContainerClassList       = const_cast<LPWSTR> (tablemeta.Get_ContainerClassList  ());
			tmRow.pDescription				= const_cast<LPWSTR> (tablemeta.Get_Description         ());

            CCatalogCollectionWriter * pCollectionWriter;
		    XIF(spCSchemaWriter->GetCollectionWriter(&tmRow, &pCollectionWriter));
        
            TColumnMeta columnmeta(fixup, tablemeta.Get_iColumnMeta());
            for(ULONG iColumnMeta=0; iColumnMeta<*tablemeta.Get_CountOfColumns(); ++iColumnMeta, columnmeta.Next())
            {
                /*
                struct tCOLUMNMETARow {
                         WCHAR *     pTable;
                         ULONG *     pIndex;
                         WCHAR *     pInternalName;
                         WCHAR *     pPublicName;
                         ULONG *     pType;
                         ULONG *     pSize;
                         ULONG *     pMetaFlags;
                 unsigned char *     pDefaultValue;
                         ULONG *     pFlagMask;
                         ULONG *     pStartingNumber;
                         ULONG *     pEndingNumber;
                         WCHAR *     pCharacterSet;
                         ULONG *     pSchemaGeneratorFlags;
                         ULONG *     pID;
                         ULONG *     pUserType;
                         ULONG *     pAttributes;
						 WCHAR *	 pDescription
                };*/
                tCOLUMNMETARow cmRow;
                cmRow.pTable                   = const_cast<LPWSTR> (columnmeta.Get_Table               ());
                cmRow.pIndex                   = const_cast<ULONG *>(columnmeta.Get_Index               ());
                cmRow.pInternalName            = const_cast<LPWSTR> (columnmeta.Get_InternalName        ());

                if(0 == wcscmp(L"Location", cmRow.pInternalName))//Locatioin is derived from the MetabaseBaseClass
                    continue;

                cmRow.pPublicName              = const_cast<LPWSTR> (columnmeta.Get_PublicName          ());
                cmRow.pType                    = const_cast<ULONG *>(columnmeta.Get_Type                ());
                cmRow.pSize                    = const_cast<ULONG *>(columnmeta.Get_Size                ());
                cmRow.pMetaFlags               = const_cast<ULONG *>(columnmeta.Get_MetaFlags           ());
                cmRow.pDefaultValue            = const_cast<unsigned char *>(columnmeta.Get_DefaultValue());
                cmRow.pFlagMask                = const_cast<ULONG *>(columnmeta.Get_FlagMask            ());
                cmRow.pStartingNumber          = const_cast<ULONG *>(columnmeta.Get_StartingNumber      ());
                cmRow.pEndingNumber            = const_cast<ULONG *>(columnmeta.Get_EndingNumber        ());
                cmRow.pCharacterSet            = const_cast<LPWSTR> (columnmeta.Get_CharacterSet        ());
                cmRow.pSchemaGeneratorFlags    = const_cast<ULONG *>(columnmeta.Get_SchemaGeneratorFlags());
                cmRow.pID                      = const_cast<ULONG *>(columnmeta.Get_ID                  ());
                cmRow.pUserType                = const_cast<ULONG *>(columnmeta.Get_UserType            ());
                cmRow.pAttributes              = const_cast<ULONG *>(columnmeta.Get_Attributes          ());
				cmRow.pDescription             = const_cast<LPWSTR> (columnmeta.Get_Description         ());
				cmRow.pPublicColumnName        = const_cast<LPWSTR> (columnmeta.Get_PublicColumnName    ());
               
                ULONG aColumnMetaSizes[cCOLUMNMETA_NumberOfColumns];
                memset(aColumnMetaSizes, 0x00, sizeof(ULONG) * cCOLUMNMETA_NumberOfColumns); 
                if(cmRow.pDefaultValue)//If there is a default value, then we need to supply the size of the DefaultValue byte array.
                    aColumnMetaSizes[iCOLUMNMETA_DefaultValue] = fixup.BufferLengthFromIndex(columnmeta.Get_MetaTable().DefaultValue);

                CCatalogPropertyWriter * pPropertyWriter;
			    XIF(pCollectionWriter->GetPropertyWriter(&cmRow,
                                                         aColumnMetaSizes,
                                                         &pPropertyWriter));


                if(columnmeta.Get_ciTagMeta() > 0)
                {
                    TTagMeta tagmeta(fixup, columnmeta.Get_iTagMeta());
                    for(ULONG iTagMeta=0; iTagMeta<columnmeta.Get_ciTagMeta(); ++iTagMeta, tagmeta.Next())
                    {
                        /*
                        struct tTAGMETARow {
                                 WCHAR *     pTable;
                                 ULONG *     pColumnIndex;
                                 WCHAR *     pInternalName;
                                 WCHAR *     pPublicName;
                                 ULONG *     pValue;
                                 ULONG *     pID;
                        };*/
                        tTAGMETARow tagmetRow;
                        tagmetRow.pTable              = const_cast<LPWSTR> (tagmeta.Get_Table       ());
                        tagmetRow.pColumnIndex        = const_cast<ULONG *>(tagmeta.Get_ColumnIndex ());
                        tagmetRow.pInternalName       = const_cast<LPWSTR> (tagmeta.Get_InternalName());
                        tagmetRow.pPublicName         = const_cast<LPWSTR> (tagmeta.Get_PublicName  ());
                        tagmetRow.pValue              = const_cast<ULONG *>(tagmeta.Get_Value       ());
                        tagmetRow.pID                 = const_cast<ULONG *>(tagmeta.Get_ID          ());

    				    XIF(pPropertyWriter->AddFlag(&tagmetRow));
                    }//for(ULONG iTagMeta
                }//if(columnmeta.Get_ciTagMeta() > 0)
            }//for(ULONG iColumnMeta
        }//for(ULONG iTableMeta

	    XIF(spCSchemaWriter->WriteSchema());
	    XIF(writer.EndWrite(eWriter_Schema));
    }//dtor of CWrite closes the handle...now we can make a copy of it
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\thierarchyelement.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __THIERARCHYELEMENT_H__
#define __THIERARCHYELEMENT_H__


//This template helps organize elements in a tree hierarchy.  It does NOT allow for removal of elements or rearranging of elements.
//It creates the hierarchy upon construction and is fixed.  Children are added by instantiating an element whose parent is 'this'.
//There is one 'root' element and is constructed by omitting the pParent ctor parameter.  All other elements are created as
//descendants of the root.

template <class T> class THierarchyElement
{
public:
    THierarchyElement(const T *p=0, THierarchyElement *pParent=0) : m_p(p), m_pChild(0), m_pParent(pParent), m_pSibling(0)
    {
        if(m_pParent)
        {
            //We need to put ourself at the beginning of the parent's child list
            m_pSibling = m_pParent->m_pChild;               
            m_pParent->m_pChild = this;
            /*   Before construction        After construction
                      ----------               ---------- 
                     |  Parent  |             |  Parent  |
                      ----------               ---------- 
                          |                        |      
                          V                        V      
                      ----------               ----------     ---------- 
                     |  Child   |             |   this   |-->|  Child   |
                      ----------               ----------     ---------- 
                 The last child constructed is always the first child in the list.
            */
        }
    }

    const THierarchyElement *Child()   const {return m_pChild;  }
    const THierarchyElement *Parent()  const {return m_pParent; }
    const THierarchyElement *Sibling() const {return m_pSibling;}
    const T                 *GetData() const {return m_p;       }

private://The members are private to ensure integrity
    THierarchyElement *m_pChild;
    THierarchyElement *m_pParent;
    THierarchyElement *m_pSibling;
    const T           *m_p;//This holds the data that the hierarchy encapsulates
};

#endif // __THIERARCHYELEMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tmetabasemetaxmlfile.cpp ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMetabaseMetaXmlFile.cpp
// Author:          Stephenr
// Date Created:    9/19/00
// Description:     This class builds the meta heaps from the MetabaseMeta.XML file and the shipped meta located in the Fixed Tables.
//                  The shipped meta is un alterable.  So if discrepencies appear between the MetabaseMeta.XML file and the shipped
//                  schema, the meta reverts back to what was 'shipped'.
//

#include "catmacros.h"
#include "svcmsg.h"
#include "TMetabaseMetaXmlFile.h"

#define THROW_ERROR0(x)                           {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, L"",  L"",  L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR1(x, str1)                     {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, L"",  L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR2(x, str1, str2)               {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR3(x, str1, str2, str3)         {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR4(x, str1, str2, str3, str4)   {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, str4))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}

#define LOG_ERROR1(x, str1)                       {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, L"",  L"",  L"" ))   ;}
#define LOG_ERROR2(x, str1, str2)                 {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, L"",  L"" ))   ;}
#define LOG_ERROR3(x, str1, str2, str3)           {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, L"" ))   ;}
#define LOG_ERROR4(x, str1, str2, str3, str4)     {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, str4))   ;}

#define LOG_WARNING1(x, str1)                     {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEWARNING, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, L"",  L"",  L"",  eSERVERWIRINGMETA_NoInterceptor, 0, eDETAILEDERRORS_Populate, -1, -1, m_wszXmlFile, eDETAILEDERRORS_WARNING));}
#define LOG_WARNING2(x, str1, str2)               {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEWARNING, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, L"",  L"",  eSERVERWIRINGMETA_NoInterceptor, 0, eDETAILEDERRORS_Populate, -1, -1, m_wszXmlFile, eDETAILEDERRORS_WARNING));}
#define LOG_WARNING3(x, str1, str2, str3)         {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEWARNING, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, L"",  eSERVERWIRINGMETA_NoInterceptor, 0, eDETAILEDERRORS_Populate, -1, -1, m_wszXmlFile, eDETAILEDERRORS_WARNING));}
#define LOG_WARNING4(x, str1, str2, str3, str4)   {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEWARNING, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, str4, eSERVERWIRINGMETA_NoInterceptor, 0, eDETAILEDERRORS_Populate, -1, -1, m_wszXmlFile, eDETAILEDERRORS_WARNING));}

//We do everything we need with XmlFile in the ctor so we don't keep it around
TMetabaseMetaXmlFile::TMetabaseMetaXmlFile(const FixedTableHeap *pShippedSchemaHeap, LPCWSTR wszXmlFile, ISimpleTableDispenser2 *pISTDispenser, TOutput &out) :
     m_Attributes               (kszAttributes)
    ,m_BaseVersion              (kszBaseVersion)
    ,m_CharacterSet             (kszCharacterSet)
    ,m_Collection               (kszTableMeta)
    ,m_ContainerClassList       (kszContainerClassList)
    ,m_DatabaseMeta             (kszDatabaseMeta)
    ,m_DefaultValue             (kszDefaultValue)
	,m_Description				(kszDescription)
    ,m_EndingNumber             (kszMaximumValue)
    ,m_Enum                     (kszEnumMeta)
    ,m_ExtendedVersion          (kszExtendedVersion)
    ,m_Flag                     (kszFlagMeta)
    ,m_ID                       (kszID)
    ,m_IIsConfigObject          (wszTABLE_IIsConfigObject)
    ,m_InheritsPropertiesFrom   (kszInheritsColumnMeta)
    ,m_InternalName             (kszInternalName)
    ,m_Meta                     (wszDATABASE_META)
    ,m_Metabase                 (wszDATABASE_METABASE)
    ,m_MetabaseBaseClass        (wszTABLE_MetabaseBaseClass)
    ,m_MetaFlags                (kszColumnMetaFlags)
    ,m_NameColumn               (kszNameColumn)
    ,m_NavColumn                (kszNavColumn)
    ,m_Property                 (kszColumnMeta)
    ,m_PublicName               (kszPublicName)
	,m_PublicColumnName			(kszPublicColumnName)
    ,m_PublicRowName            (kszPublicRowName)
    ,m_SchemaGeneratorFlags     (kszSchemaGenFlags)
    ,m_Size                     (kszcbSize)
    ,m_StartingNumber           (kszMinimumValue)
    ,m_Type                     (kszdbType)
    ,m_UserType                 (kszUserType)
    ,m_Value                    (kszValue)

    //m_aiUI4 initialized in PresizeHeaps
    ,m_iColumnMeta_Location         (0)
    ,m_iCurrentColumnIndex          (0)
    ,m_iCurrentDatabaseName         (0)
    ,m_iCurrentTableName            (0)
    ,m_iCurrentTableMeta            (0)
    ,m_ipoolPrevUserDefinedID       (0)
    ,m_iTableName_IIsConfigObject   (0)
    ,m_iLastShippedCollection       (0)
    ,m_iLastShippedProperty         (0)
    ,m_iLastShippedTag              (0)
    ,m_LargestID                    (kLargestReservedID)
    ,m_NextColumnIndex              (0)
    ,m_out                          (out)
    ,m_pShippedSchemaHeap           (pShippedSchemaHeap)
    ,m_State                        (eLookingForTheMetabaseDatabase)
    ,m_spISTAdvancedDispenser       (pISTDispenser)
    ,m_wszXmlFile                   (wszXmlFile)
{
    ASSERT(0 != pShippedSchemaHeap);
    ASSERT(0 != pISTDispenser);

    m_out.printf(L"\r\n\r\n----------------------Metabase Compilation Starting----------------------\r\n\r\n");

    PresizeHeaps();//This minimizes reallocs

    const DatabaseMeta *pDatabaseMeta_METABASE=0;
    BuildDatabaseMeta(pDatabaseMeta_METABASE);//This scans the shipped databases and adds the "Meta" & "Metabase" databases to the DatabaseHeap

    //Put the Meta tables into the heap
    const TableMeta *pTableMeta = m_pShippedSchemaHeap->Get_aTableMeta(0);
    for(ULONG iTableMeta=0; iTableMeta<m_pShippedSchemaHeap->Get_cTableMeta(); ++iTableMeta, ++pTableMeta)
        if(m_Meta.IsEqual(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pTableMeta->Database))))
            AddShippedTableMetaToHeap(pTableMeta, true);
        else
            break;

    //From the FixedTableHeap, Locate the first TableMeta for the metabase (DatabaseMeta::iTableMeta)
    const TableMeta * pTableMetaCurrent = m_pShippedSchemaHeap->Get_aTableMeta(pDatabaseMeta_METABASE->iTableMeta);
    ASSERT(0 != pTableMetaCurrent);
    //Verify that the first table is the 'MetabaseBaseClass' table.
    if(0 != _wcsicmp(wszTABLE_MetabaseBaseClass, reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pTableMetaCurrent->InternalName))))
    {
        LOG_ERROR(Interceptor, (reinterpret_cast<ISimpleTableWrite2 **>(0), m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE,
            IDS_COMCAT_CLASS_NOT_FOUND_IN_META, wszTABLE_MetabaseBaseClass, L"", L"", L""));
        THROW_ERROR1(IDS_COMCAT_CLASS_NOT_FOUND_IN_META, wszTABLE_MetabaseBaseClass);
    }
    
    //Add MetabaseBaseClass to the TableMeta heap
    //Add its column(s) to the ColumnMeta heap
    AddShippedTableMetaToHeap(pTableMetaCurrent);//This in turn calls AddColumnMetaToHeap for each column
    m_iColumnMeta_Location = m_iLastShippedProperty;

    //Verify that the next table is the 'IIsConfigObject' table.
    ++pTableMetaCurrent;
    if(0 != _wcsicmp(wszTABLE_IIsConfigObject, reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pTableMetaCurrent->InternalName))))
    {
        THROW_ERROR1(IDS_COMCAT_CLASS_NOT_FOUND_IN_META, wszTABLE_IIsConfigObject);
    }
    m_iTableName_IIsConfigObject = AddWCharToList(wszTABLE_IIsConfigObject);
    //Add it to the TableMeta heap
    //Add its column(s) to the ColumnMeta heap
    AddShippedTableMetaToHeap(pTableMetaCurrent);//This in turn calls AddColumnMetaToHeap for each column, which calls AddTagMetaToHeap for each tag.

    ULONG iIISConfigObjectTable = m_iLastShippedCollection;

    //Now we're ready to merge the contents of the XML file with the shipped schema
    //so we need to do some setup

    //Get TagMeta table
    if(FAILED(pISTDispenser->GetTable( wszDATABASE_META, wszTABLE_TAGMETA, 0, 0, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<LPVOID *>(&m_spISTTagMeta))))
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA, wszTABLE_TAGMETA);
    }

    //Get ColumnMeta table Indexed 'ByName'
    STQueryCell             acellsMeta[2];
    acellsMeta[0].pData        = COLUMNMETA_ByName;
    acellsMeta[0].eOperator    = eST_OP_EQUAL;
    acellsMeta[0].iCell        = iST_CELL_INDEXHINT;
    acellsMeta[0].dbType       = DBTYPE_WSTR;
    acellsMeta[0].cbSize       = 0;

    ULONG one=1;
    if(FAILED(pISTDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, &acellsMeta, &one, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_spISTColumnMeta))))
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA, wszTABLE_COLUMNMETA);
    }

    //Get ColumnMeta table Indexed 'ByID'
    acellsMeta[0].pData        = COLUMNMETA_ByID;
    if(FAILED(pISTDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, &acellsMeta, &one, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_spISTColumnMetaByID))))
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA, wszTABLE_COLUMNMETA);
    }


    //Get TableMeta table - Database 'Metabase'
    acellsMeta[0].pData        = wszDATABASE_METABASE;
    acellsMeta[0].eOperator    = eST_OP_EQUAL;
    acellsMeta[0].iCell        = iTABLEMETA_Database;
    acellsMeta[0].dbType       = DBTYPE_WSTR;
    acellsMeta[0].cbSize       = 0;

    if(FAILED(pISTDispenser->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA, &acellsMeta, &one, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_spISTTableMeta))))
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA, wszTABLE_TABLEMETA);
    }

    //Allocate aBool[Database::CountOfTables] to indicate which of the Tables we listed in the XML file
    ULONG cTableMetaRows;
    VERIFY(SUCCEEDED(m_spISTTableMeta->GetTableMeta( 0, 0, &cTableMetaRows, 0)));
    ASSERT(cTableMetaRows > 50);//I know there are more that 50 classes, let's just verify that.
    if(0 == (m_aBoolShippedTables = new bool [cTableMetaRows]))
    {
        THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
    }

    //Initialize each element to false
    for(ULONG iRow=0;iRow < cTableMetaRows; ++iRow)
        m_aBoolShippedTables[iRow] = false;

    //Parse the XML file
    if(0 != wszXmlFile)//we tolerate NULL here.  In that case we're just generating a Bin file with the shipped schema
    {
        TXmlParsedFile_NoCache xmlParsedFile;
        if(FAILED(xmlParsedFile.Parse(*this, wszXmlFile)))
        {
            //@@@ Parse using DOM to report the error
            THROW(ERROR PARSING XML FILE);
        }
    }

    //The ExtendedVersion contains the LargestID withing the IIsConfigObject table
    TableMetaFromIndex(iIISConfigObjectTable)->ExtendedVersion = AddUI4ToList(m_LargestID);

    //At this point we have all of the Collections defined within the XML
    //Now we need to make sure that none of the shipped collections we delete
    //Walk the m_aBoolShippedTables looking for any 'false' values (starting at row 2 - row 0 is MetabaseBaseClass, row 1 is IIsConfigObject)
    for(iRow=2; iRow<cTableMetaRows-2; ++iRow)//The last two tables are MBProperty and MBPropertyDiff.  We always add these from the shipped schema PLUS! extra group tags (see below)
    {
        if(!m_aBoolShippedTables[iRow])
        {
            ULONG   iTableMetaInternalName = iTABLEMETA_InternalName;
            LPWSTR wszTableName;
            VERIFY(SUCCEEDED(m_spISTTableMeta->GetColumnValues(iRow, 1, &iTableMetaInternalName, 0, reinterpret_cast<LPVOID *>(&wszTableName))));
            ULONG iRowTableMeta = m_pShippedSchemaHeap->FindTableMetaRow(wszTableName);
            ASSERT(iRowTableMeta != -1);
            //Add it from the ShippedSchemaHeap to the TableMeta heap
            AddShippedTableMetaToHeap(m_pShippedSchemaHeap->Get_aTableMeta(iRowTableMeta));//This adds all shipped columns and tags too
        }
    }

    {//MBProperty
        ULONG   iTableMetaInternalName = iTABLEMETA_InternalName;
        LPWSTR  wszTableName;
        VERIFY(SUCCEEDED(m_spISTTableMeta->GetColumnValues(iRow++, 1, &iTableMetaInternalName, 0, reinterpret_cast<LPVOID *>(&wszTableName))));
        ASSERT(0 == _wcsicmp(wszTableName, wszTABLE_MBProperty));
        ULONG iRowTableMeta = m_pShippedSchemaHeap->FindTableMetaRow(wszTableName);
        ASSERT(iRowTableMeta != -1);
        //Add it from the ShippedSchemaHeap to the TableMeta heap
        AddShippedTableMetaToHeap(m_pShippedSchemaHeap->Get_aTableMeta(iRowTableMeta));//This adds all shipped columns and tags too

        //We have strategically chosen the last column in this table to be the Group column.  This is because we need to add the Tag enums
        //for those User defined collections.
        ULONG iMBProperyTableName       = TagMetaFromIndex(GetCountTagMeta()-1)->Table;
        ULONG iMBProperyGroupColumnIndex= TagMetaFromIndex(GetCountTagMeta()-1)->ColumnIndex;

        ASSERT(0 == wcscmp(StringFromIndex(iMBProperyTableName), wszTABLE_MBProperty));

        //Walk the Tables (after IISConfigObject and not including MBProperty)
        for(ULONG iTableMeta=iIISConfigObjectTable; iTableMeta<GetCountTableMeta()-2; ++iTableMeta)//minus 2 because we don't care about the last table MBProperty
        {
            //Is this table one of the shipped collections?
            ULONG   iRow;
            LPVOID  apvValues[1];
            apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(StringFromIndex(TableMetaFromIndex(iTableMeta)->InternalName)));

            //Look for the Table in the shipped schema
            if(FAILED(m_spISTTableMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
            {
                TagMeta tagmeta;
                tagmeta.Table           = iMBProperyTableName;
                tagmeta.ColumnIndex     = iMBProperyGroupColumnIndex;
                tagmeta.InternalName    = TableMetaFromIndex(iTableMeta)->InternalName;
                tagmeta.PublicName      = TableMetaFromIndex(iTableMeta)->PublicName;
                tagmeta.Value           = AddUI4ToList(UI4FromIndex(TagMetaFromIndex(GetCountTagMeta()-1)->Value)+1);//increment the previous enum
                tagmeta.ID              = AddUI4ToList(0);

                AddTagMetaToList(&tagmeta);
            }
        }
    }
    {//MBPropertyDiff
        ULONG   iTableMetaInternalName = iTABLEMETA_InternalName;
        LPWSTR  wszTableName;
        VERIFY(SUCCEEDED(m_spISTTableMeta->GetColumnValues(iRow++, 1, &iTableMetaInternalName, 0, reinterpret_cast<LPVOID *>(&wszTableName))));
        ASSERT(0 == _wcsicmp(wszTableName, wszTABLE_MBPropertyDiff));
        ULONG iRowTableMeta = m_pShippedSchemaHeap->FindTableMetaRow(wszTableName);
        ASSERT(iRowTableMeta != -1);
        //Add it from the ShippedSchemaHeap to the TableMeta heap
        AddShippedTableMetaToHeap(m_pShippedSchemaHeap->Get_aTableMeta(iRowTableMeta));//This adds all shipped columns and tags too

        //We have strategically chosen the last column in this table to be the Group column.  This is because we need to add the Tag enums
        //for those User defined collections.
        ULONG iMBProperyTableName       = TagMetaFromIndex(GetCountTagMeta()-1)->Table;
        ULONG iMBProperyGroupColumnIndex= TagMetaFromIndex(GetCountTagMeta()-1)->ColumnIndex;

        ASSERT(0 == wcscmp(StringFromIndex(iMBProperyTableName), wszTABLE_MBPropertyDiff));

        //Walk the Tables (after IISConfigObject and not including MBProperty)
        for(ULONG iTableMeta=iIISConfigObjectTable; iTableMeta<GetCountTableMeta()-3; ++iTableMeta)//minus 2 because we don't care about the last two tables MBProperty & MBPropertyDiff
        {
            //Is this table one of the shipped collections?
            ULONG   iRow;
            LPVOID  apvValues[1];
            apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(StringFromIndex(TableMetaFromIndex(iTableMeta)->InternalName)));

            //Look for the Table in the shipped schema
            if(FAILED(m_spISTTableMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
            {
                TagMeta tagmeta;
                tagmeta.Table           = iMBProperyTableName;
                tagmeta.ColumnIndex     = iMBProperyGroupColumnIndex;
                tagmeta.InternalName    = TableMetaFromIndex(iTableMeta)->InternalName;
                tagmeta.PublicName      = TableMetaFromIndex(iTableMeta)->PublicName;
                tagmeta.Value           = AddUI4ToList(UI4FromIndex(TagMetaFromIndex(GetCountTagMeta()-1)->Value)+1);//increment the previous enum
                tagmeta.ID              = AddUI4ToList(0);

                AddTagMetaToList(&tagmeta);
            }
        }
    }
//    out.printf(L"Size of m_HeapColumnMeta       %d bytes\n", m_HeapColumnMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapDatabaseMeta     %d bytes\n", m_HeapDatabaseMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapHashedIndex      %d bytes\n", m_HeapHashedIndex.GetEndOfHeap());
//    out.printf(L"Size of m_HeapIndexMeta        %d bytes\n", m_HeapIndexMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapQueryMeta        %d bytes\n", m_HeapQueryMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapRelationMeta     %d bytes\n", m_HeapRelationMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapServerWiringMeta %d bytes\n", m_HeapServerWiringMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapTableMeta        %d bytes\n", m_HeapTableMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapTagMeta          %d bytes\n", m_HeapTagMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapULONG            %d bytes\n", m_HeapULONG.GetEndOfHeap());
//    out.printf(L"Size of m_HeapPooled           %d bytes\n", m_HeapPooled.GetEndOfHeap());
}



//TXmlParsedFileNodeFactory members
HRESULT TMetabaseMetaXmlFile::CreateNode(const TElement &Element)
{
    if(XML_ELEMENT != Element.m_ElementType)//Ignore non Element nodes
        return S_OK;
    if(Element.m_NodeFlags & fEndTag)//Ignore EndTags
        return S_OK;

    HRESULT hr = S_OK;

    switch(m_State)
    {
    case eLookingForTheMetabaseDatabase:
        //From the XML file, walk the elements looking for the Metabase Database
        if(eDatabaseMetaLevel != Element.m_LevelOfElement)
            break;
        if(!m_DatabaseMeta.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Property element, then ignore it - may be a comment, could be querymeta or indexmeta, neither of which we care about
            break;

        if(GetAttribute(Element, m_InternalName).Value().IsEqual(m_Metabase))//If the InternalName is 'Metabase'
        {
            m_State = eLookingForTheIIsConfigObjectTable;
        }
        break;
    case eLookingForTheIIsConfigObjectTable:
        //From there walk the elements looking for the IIsConfigObject Collection element (ignoring everything before it)
        if(eDatabaseMetaLevel == Element.m_LevelOfElement)
        {
            m_out.printf(L"Error - Found Level 1 element when expecting IIsConfigObjectTable\r\n");
            return E_SDTXML_LOGICAL_ERROR_IN_XML;//returning E_SDTXML_LOGICAL_ERROR_IN_XML will cause us to just use the shipped schema
        }

        if(eCollectionLevel != Element.m_LevelOfElement)
            break;
        if(!m_Collection.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
            break;

        if(!GetAttribute(Element, m_InternalName).Value().IsEqual(m_MetabaseBaseClass))//If the InternalName is 'IIsConfigObject'
        {
            m_State = eLookingForGlobalProperties;
            hr = CreateNode(Element);
        }
        break;
    case eLookingForGlobalProperties:
        switch(Element.m_LevelOfElement)
        {
        case eDatabaseMetaLevel://1
            m_out.printf(L"Error - Found Level 1 element when expecting GlobalProperties\r\n");
            return E_SDTXML_LOGICAL_ERROR_IN_XML;//returning E_SDTXML_LOGICAL_ERROR_IN_XML will cause us to just use the shipped schema
        case eCollectionLevel://2
            {
                if(!m_Collection.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Collection element, then ignore it - may be a comment
                    break;

                if(GetAttribute(Element, m_InternalName).Value().IsEqual(m_IIsConfigObject))//If the InternalName is 'IIsConfigObject'
                    break;//Then this table has already been added, continue looking for global properties.


                //when we get here, we're done with global properties; and we're ready for the classes (with their inherited properties).
                m_State = eLookingForCollectionOrInheritedProperties;
                //This recursive call prevents us from having duplicate code here AND at 'case eLookingForCollectionOrInheritedProperties:'
                //This sould only happen once (at the first level 2 element following IIsConfigObject)
                hr = CreateNode(Element);
            }
            break;
        case eProperytLevel://3
            {
                if(!m_Property.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Property element, then ignore it - may be a comment, could be querymeta or indexmeta, neither of which we care about
                    break;

                ULONG iColumnInternalName = AddStringToHeap(GetAttribute(Element, m_InternalName).Value());

                if(ShouldAddColumnMetaToHeap(Element, iColumnInternalName))
                {   //If we failed to get the Row by Search then it's not in the shipped schema
                    AddColumnMetaToHeap(Element, iColumnInternalName);
                }
                else
                {
                    m_iCurrentColumnIndex = 0;//This indicate that we should ignore TagMeta children
                }
            }
            break;
        case eTagLevel://4
            {
                bool bFlag;
                if(!(bFlag = m_Flag.IsEqual(Element.m_ElementName, Element.m_ElementNameLength)) && !m_Enum.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
                    break;
                if(0 == m_iCurrentColumnIndex)
                    break;//We got a TagMeta without a ColumnMeta
                //If this is the first flag we've seen for this column we need to OR in the fCOLUMNMETA_FLAG MetaFlag on the last column in the list
                //so just do it everytime we see a tag
                ColumnMeta *pColumnMeta = ColumnMetaFromIndex(GetCountColumnMeta()-1);
                pColumnMeta->MetaFlags = AddUI4ToList(UI4FromIndex(pColumnMeta->MetaFlags) | (bFlag ? fCOLUMNMETA_FLAG : fCOLUMNMETA_ENUM));

                AddTagMetaToHeap(Element);
            }
            break;
        default:
            break;
        }
        break;
    case eLookingForCollectionOrInheritedProperties:
        switch(Element.m_LevelOfElement)
        {
        case eDatabaseMetaLevel://1
            return E_SDTXML_DONE;
        case eCollectionLevel://2
            {
                if(!m_Collection.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Collection element, then ignore it - may be a comment
                    break;

                //We need a NULL terminate string for the TableInternalName so add it to the list
                m_iCurrentTableName = AddStringToHeap(GetAttribute(Element, m_InternalName).Value());

                //Look up the collection in the Fixed interceptor
                ULONG   iRow;
                LPVOID  apvValues[1];
                apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(StringFromIndex(m_iCurrentTableName)));

                //Look for the Table in the shipped schema
                if(FAILED(m_spISTTableMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
                {//if the table is NOT one of the shipped collections then add it
                    AddTableMetaToHeap(Element);
                    //We now look for the properties
                }
                else
                {
                    //Keep track of which shipped tables we've seen (this way we can add back in any shipped collections that are removed from the XML file).
                    m_aBoolShippedTables[iRow] = true;
                    ULONG iRowTableMeta = m_pShippedSchemaHeap->FindTableMetaRow(StringFromIndex(m_iCurrentTableName));
                    ASSERT(iRowTableMeta != -1);
                    //Add it from the ShippedSchemaHeap to the TableMeta heap
                    AddShippedTableMetaToHeap(m_pShippedSchemaHeap->Get_aTableMeta(iRowTableMeta), false, &GetAttribute(Element, m_ContainerClassList).Value());//This adds all shipped columns and tags too
                    //@@@ ToDo:  Do we support user modifications to tha TableMeta (like adding classes to the ContainerClassList)?  If so we do that here.
                    //Now we need to look for User-defined properties (and tags) for this collection
                }
            }
            break;
        case eProperytLevel://3
            {
                if(!m_Property.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Property element, then ignore it - may be a comment, could be querymeta or indexmeta, neither of which we care about
                    break;

                AddColumnMetaViaReferenceToHeap(Element);
            }
            break;
        case eTagLevel:
            {
                m_out.printf(L"Tag found under inherited property.  Tags are being ignored\r\n");
            }
            break;
        default:
            break;
        }
        break;
    default:
        ASSERT(false);
    }
    return hr;
}

//private member functions
void TMetabaseMetaXmlFile::AddColumnMetaByReference(ULONG iColumnMeta_Source)
{
    ColumnMeta * pColumnMeta = ColumnMetaFromIndex(iColumnMeta_Source);

    m_iCurrentColumnIndex = AddUI4ToList(m_NextColumnIndex);//Don't increment m_NextColumnIndex until this column is actually added

    if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_DIRECTIVE)
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_IN_DIRECTIVE_INHERITANCE, StringFromIndex(pColumnMeta->InternalName));
    }

    //If the column is a Flag of Enum we need to add TagMeta
    if(UI4FromIndex(pColumnMeta->MetaFlags) & (fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM))
    {
        ULONG iTagMeta = FindTagBy_Table_And_Index(pColumnMeta->Table, pColumnMeta->Index);
        ASSERT(-1 != iTagMeta);
        if(-1 == iTagMeta)
        {
            THROW_ERROR2(IDS_COMCAT_INHERITED_FLAG_OR_ENUM_HAS_NO_TAGS_DEFINED, StringFromIndex(pColumnMeta->Table), StringFromIndex(pColumnMeta->InternalName));
        }
        
        for( ;iTagMeta<GetCountTagMeta() && TagMetaFromIndex(iTagMeta)->Table==pColumnMeta->Table && TagMetaFromIndex(iTagMeta)->ColumnIndex==pColumnMeta->Index ;++iTagMeta)
        {
            TagMeta *pTagMeta = TagMetaFromIndex(iTagMeta);

            TagMeta tagmeta;
            tagmeta.Table           = m_iCurrentTableName       ;
            tagmeta.ColumnIndex     = m_iCurrentColumnIndex     ;
            tagmeta.InternalName    = pTagMeta->InternalName    ;
            tagmeta.PublicName      = pTagMeta->PublicName      ;
            tagmeta.Value           = pTagMeta->Value           ;
            tagmeta.ID              = pTagMeta->ID              ;

            AddTagMetaToList(&tagmeta);
        }
    }

    ColumnMeta columnmeta;
    memset(&columnmeta, 0x00, sizeof(ColumnMeta));
    columnmeta.Table                = m_iCurrentTableName                   ;//Index into Pool
    columnmeta.Index                = m_iCurrentColumnIndex                 ;//Column Index
    columnmeta.InternalName         = pColumnMeta->InternalName             ;//Index into Pool
    columnmeta.PublicName           = pColumnMeta->PublicName               ;//Index into Pool
    columnmeta.Type                 = pColumnMeta->Type                     ;//These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    columnmeta.Size                 = pColumnMeta->Size                     ;//
    columnmeta.MetaFlags            = pColumnMeta->MetaFlags                ;//ColumnMetaFlags defined in CatMeta.xml
    columnmeta.DefaultValue         = pColumnMeta->DefaultValue             ;//Only valid for UI4s
    columnmeta.FlagMask             = pColumnMeta->FlagMask                 ;//Only valid for flags
    columnmeta.StartingNumber       = pColumnMeta->StartingNumber           ;//Only valid for UI4s
    columnmeta.EndingNumber         = pColumnMeta->EndingNumber             ;//Only valid for UI4s
    columnmeta.CharacterSet         = pColumnMeta->CharacterSet             ;//Index into Pool - Only valid for WSTRs

    //Columns added here may be shipped properties; but we OR in the USERDEFINED flag to indicate that this property is NOT part of the shipped schema for THIS table.
    columnmeta.SchemaGeneratorFlags = AddUI4ToList(fCOLUMNMETA_USERDEFINED | fCOLUMNMETA_PROPERTYISINHERITED | (pColumnMeta->SchemaGeneratorFlags ? UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) : 0));//ColumnMetaFlags defined in CatMeta.xml
    columnmeta.ID                   = pColumnMeta->ID                       ;
    columnmeta.UserType             = pColumnMeta->UserType                 ;
    columnmeta.Attributes           = pColumnMeta->Attributes               ;
	columnmeta.Description			= pColumnMeta->Description				;
	columnmeta.PublicColumnName     = pColumnMeta->PublicColumnName         ;
    //columnmeta.ciTagMeta            = 0                                     ;//Count of Tags - Only valid for UI4s
    //columnmeta.iTagMeta             = 0                                     ;//Index into TagMeta - Only valid for UI4s
    //columnmeta.iIndexName           = 0                                     ;//IndexName of a single column index (for this column)

    AddColumnMetaToList(&columnmeta);
    ++m_NextColumnIndex;
}


void TMetabaseMetaXmlFile::AddColumnMetaToHeap(const TElement &i_Element, ULONG i_iColumnInternalName)
{
    //<Property InternalName ="KeyType" ID="1002" Type="STRING" MetaFlags="PRIMARYKEY" UserType="IIS_MD_UT_SERVER" Attributes="INHERIT"/>
    ColumnMeta columnmeta;
    memset(&columnmeta, 0x00, sizeof(ColumnMeta));
    columnmeta.Table                = m_iCurrentTableName;
    columnmeta.Index                = AddUI4ToList(m_NextColumnIndex);//Don't increment m_NextColumnIndex until this column is actually added
    columnmeta.InternalName         = i_iColumnInternalName;

    if(~0x00 != FindUserDefinedPropertyBy_Table_And_InternalName(m_iCurrentTableName, i_iColumnInternalName))
        return;//No need to proceed, this property is already in the global property list

    m_iCurrentColumnIndex           = columnmeta.Index;
    columnmeta.PublicName           = AddStringToHeap(GetAttribute(i_Element, m_PublicName).Value());

    //Several things are inferred from the Type: Size, MetaFlags, SchemaGeneratorFlags
    const TOLEDataTypeToXMLDataType * pOLEDataType = Get_OLEDataTypeToXMLDataType(GetAttribute(i_Element, m_Type).Value());

    columnmeta.Type                 = AddUI4ToList(pOLEDataType->dbType);
    const TAttr & attrSize          = GetAttribute(i_Element, m_Size);
    if(attrSize.IsNULL())
        columnmeta.Size             = AddUI4ToList(pOLEDataType->cbSize);
    else
    {
        WCHAR * dummy;
        columnmeta.Size             = AddUI4ToList(wcstol(attrSize.Value().GetString(), &dummy, 10));
    }

    ULONG MetaFlags = StringToFlagValue(GetAttribute(i_Element, m_MetaFlags).Value(), wszTABLE_COLUMNMETA, iCOLUMNMETA_MetaFlags);
    if(MetaFlags & (fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE))
    {
        m_out.printf(L"Error! - Invalid MetaFlag supplied.  Ignoring property (%s).  Some MetaFlags must be inferred (fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE)\r\n", StringFromIndex(i_iColumnInternalName));
        MetaFlags &= ~(fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE);
    }
    columnmeta.MetaFlags            = AddUI4ToList(MetaFlags | pOLEDataType->fCOLUMNMETA);

    ULONG MetaFlagsEx = StringToFlagValue(GetAttribute(i_Element, m_SchemaGeneratorFlags).Value(), wszTABLE_COLUMNMETA, iCOLUMNMETA_SchemaGeneratorFlags);
    if(MetaFlagsEx & (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED))
    {
        m_out.printf(L"Error! - Invalid MetaFlagsEx supplied.  Ignoring property (%s).  Some MetaFlagsEx must be inferred (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED)\r\n", StringFromIndex(i_iColumnInternalName));
        MetaFlags &= ~(fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED);
    }
    columnmeta.SchemaGeneratorFlags = AddUI4ToList(MetaFlagsEx | pOLEDataType->fCOLUMNSCHEMAGENERATOR | fCOLUMNMETA_USERDEFINED);//Mark this property as a UserDefined property
    columnmeta.DefaultValue         = 0;//This gets filled in last since the rest of ColumnMeta is needed
    columnmeta.FlagMask             = 0;//Inferred from TagMeta
    columnmeta.StartingNumber       = AddUI4ToList(GetAttribute(i_Element, m_StartingNumber).Value().ToUI4());

    const TAttr & attrEndingNumber  = GetAttribute(i_Element, m_EndingNumber);
    if(attrEndingNumber.IsNULL())
        columnmeta.EndingNumber     = AddUI4ToList(static_cast<ULONG>(~0x00));
    else
        columnmeta.EndingNumber     = AddUI4ToList(attrEndingNumber.Value().ToUI4());

    columnmeta.CharacterSet         = AddStringToHeap(GetAttribute(i_Element, m_CharacterSet).Value());
    columnmeta.ID                   = AddUI4ToList(GetAttribute(i_Element, m_ID).Value().ToUI4());
    columnmeta.UserType             = AddUI4ToList(StringToEnumValue(GetAttribute(i_Element, m_UserType).Value(), wszTABLE_COLUMNMETA, iCOLUMNMETA_UserType, true));
    columnmeta.Attributes           = AddUI4ToList(StringToFlagValue(GetAttribute(i_Element, m_Attributes).Value(), wszTABLE_COLUMNMETA, iCOLUMNMETA_Attributes));
	columnmeta.Description			= AddStringToHeap(GetAttribute(i_Element, m_Description).Value());
	columnmeta.PublicColumnName     = AddStringToHeap(GetAttribute(i_Element, m_PublicColumnName).Value());
    columnmeta.ciTagMeta            = 0;//Inferred later
    columnmeta.iTagMeta             = 0;//Inferred later
    columnmeta.iIndexName           = 0;//Not used in the Metabase

    if(UI4FromIndex(columnmeta.ID) > m_LargestID)
        m_LargestID = UI4FromIndex(columnmeta.ID);

    columnmeta.DefaultValue         = GetDefaultValue(i_Element, columnmeta);
    
    AddColumnMetaToList(&columnmeta);
    ++m_NextColumnIndex;
}


ULONG TMetabaseMetaXmlFile::GetDefaultValue(const TElement &i_Element, ColumnMeta & columnmeta)
{
    const ULONG IIS_SYNTAX_ID_DWORD        = 1;
    const ULONG IIS_SYNTAX_ID_STRING       = 2;
    const ULONG IIS_SYNTAX_ID_EXPANDSZ     = 3;
    const ULONG IIS_SYNTAX_ID_MULTISZ      = 4;
    const ULONG IIS_SYNTAX_ID_BINARY       = 5;
    const ULONG IIS_SYNTAX_ID_BOOL         = 6;
    const ULONG IIS_SYNTAX_ID_BOOL_BITMASK = 7;
    const ULONG IIS_SYNTAX_ID_MIMEMAP      = 8;
    const ULONG IIS_SYNTAX_ID_IPSECLIST    = 9;
    const ULONG IIS_SYNTAX_ID_NTACL        =10;
    const ULONG IIS_SYNTAX_ID_HTTPERRORS   =11;
    const ULONG IIS_SYNTAX_ID_HTTPHEADERS  =12;

    const TSizedString & strDefaultValue = GetAttribute(i_Element, m_DefaultValue).Value();
    if(strDefaultValue.IsNULL())
        return 0;//NULL

    ULONG SynID = SynIDFromMetaFlagsEx(UI4FromIndex(columnmeta.SchemaGeneratorFlags));

    switch(SynID)
    {
    case IIS_SYNTAX_ID_DWORD       : // 1 DWORD 
    case IIS_SYNTAX_ID_BOOL        : // 6 DWORD   
    case IIS_SYNTAX_ID_BOOL_BITMASK: // 7 DWORD   
        {
            return AddUI4ToList(strDefaultValue.ToUI4());
        }
        break;

    case IIS_SYNTAX_ID_STRING      : // 2 STRING 
    case IIS_SYNTAX_ID_EXPANDSZ    : // 3 EXPANDSZ
        {
            return AddStringToHeap(strDefaultValue);
        }
        break;

    case IIS_SYNTAX_ID_MULTISZ     : // 4 MULTISZ 
    case IIS_SYNTAX_ID_MIMEMAP     : // 8 MULTISZ 
    case IIS_SYNTAX_ID_IPSECLIST   : // 9 MULTISZ 
    case IIS_SYNTAX_ID_HTTPERRORS  : //11 MULTISZ    
    case IIS_SYNTAX_ID_HTTPHEADERS : //12 MULTISZ  
        {
            ULONG ulStrLen = (ULONG) strDefaultValue.GetStringLength();
            if((ulStrLen+2)*sizeof(WCHAR) > UI4FromIndex(columnmeta.Size))
            {
                WCHAR wszSize[12];
                wsprintf(wszSize, L"%d", UI4FromIndex(columnmeta.Size));
                LOG_ERROR(Interceptor, (0,
                                        m_spISTAdvancedDispenser,
                                        E_ST_COMPILEFAILED,
                                        ID_CAT_CONFIG_SCHEMA_COMPILE,
                                        IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_TOO_LARGE,
                                        wszSize,
                                        StringFromIndex(columnmeta.InternalName),
                                        static_cast<ULONG>(0),
                                        StringFromIndex(columnmeta.Table)));
                THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);
            }
            if(UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH)
            {
                LOG_ERROR(Interceptor, (0,
                                        m_spISTAdvancedDispenser,
                                        E_ST_COMPILEFAILED,
                                        ID_CAT_CONFIG_SCHEMA_COMPILE,
                                        IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_FIXEDLENGTH_MULTISTRING_NOT_ALLOWED,
                                        StringFromIndex(columnmeta.InternalName),
                                        static_cast<ULONG>(0),
                                        StringFromIndex(columnmeta.Table)));
                THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);
            }
            if(0==ulStrLen)
            {
                WCHAR  wszDoubleNULL[2];
                wszDoubleNULL[0] = 0x00;
                wszDoubleNULL[1] = 0x00;
                return AddBytesToList(reinterpret_cast<unsigned char *>(wszDoubleNULL), 2 * sizeof(WCHAR));
            }

            TSmartPointerArray<WCHAR> saString = new WCHAR [ulStrLen+1];
            TSmartPointerArray<WCHAR> saMultiString = new WCHAR [ulStrLen+2];
            if(0 == saString.m_p || 0 == saMultiString.m_p)
            {
                THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
            }
            memcpy(saString.m_p, strDefaultValue.GetString(), strDefaultValue.GetStringLength() *sizeof(WCHAR));//make a copy of the string so we can strtok it
            saString[strDefaultValue.GetStringLength()] = 0x00;//NULL terminate it too
            saMultiString[0] = 0x00;

            LPWSTR token = wcstok(saString, L"|\r\n");
            ULONG cchMultiString = 0;
            while(token)
            {
                LPWSTR wszTemp = token;
                while(*wszTemp==L' ' || *wszTemp==L'\t')//ignore leading spaces and tabs
                    wszTemp++;

                if(0 == *wszTemp)//and if only tabs and spaces exist then bail
                    break;
                wcscpy(saMultiString + cchMultiString, wszTemp);
                cchMultiString += (ULONG) (wcslen(wszTemp) + 1);

                token = wcstok(0, L"|\r\n");
            }
            saMultiString[cchMultiString++] = 0x00;//put the second NULL
            return AddBytesToList(reinterpret_cast<unsigned char *>(saMultiString.m_p), cchMultiString * sizeof(WCHAR));
        }
        break;

    case IIS_SYNTAX_ID_BINARY      : // 5 BINARY  
    case IIS_SYNTAX_ID_NTACL       : //10 BINARY  
        {
            unsigned long                       cbArray = (ULONG)strDefaultValue.GetStringLength();
            if(cbArray & 0x01)
            {
                TSmartPointerArray<WCHAR> saString = new WCHAR [strDefaultValue.GetStringLength()+1];
                if(0 == saString.m_p)
                {
                    THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
                }
                memcpy(saString.m_p, strDefaultValue.GetString(), strDefaultValue.GetStringLength() *sizeof(WCHAR));//make a copy of the string so we can strtok it
                saString[strDefaultValue.GetStringLength()] = 0x00;//NULL terminate it too
                THROW_ERROR1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_ODD_NUMBER_OF_CHARACTERS, saString);
            }
            cbArray /= 2;//There are two characters per hex byte.

            if((UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) && cbArray > UI4FromIndex(columnmeta.Size))
            {
                WCHAR wszSize[12];
                wsprintf(wszSize, L"%d", UI4FromIndex(columnmeta.Size));
                THROW_ERROR2(IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_TOO_LARGE, wszSize, StringFromIndex(columnmeta.InternalName));
            }

            TSmartPointerArray<unsigned char>   sabyArray;
            sabyArray = new unsigned char [(UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) ? UI4FromIndex(columnmeta.Size) : cbArray];
            if(0 == sabyArray.m_p)
            {
                THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
            }
            memset(sabyArray.m_p, 0x00, (UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) ? UI4FromIndex(columnmeta.Size) : cbArray);

            //Convert the string into a byte array
            ConvertWideCharsToBytes(strDefaultValue.GetString(), sabyArray.m_p, cbArray);
            return AddBytesToList(sabyArray.m_p, (UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) ? UI4FromIndex(columnmeta.Size) : cbArray);//AddBytesToList just slams the bytes into the pool (prepending the length) and returns the index to bytes
        }
        break;
    default:
        ASSERT(false && L"Unknown Synid");
    }
    return 0;
}

static LPCWSTR kwszHexLegalCharacters = L"abcdefABCDEF0123456789";

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

//This converts the string to bytes (an L'A' gets translated to 0x0a NOT 'A')
void TMetabaseMetaXmlFile::ConvertWideCharsToBytes(LPCWSTR string, unsigned char *pBytes, unsigned long length)
{
    for(;length; --length, ++pBytes)//while length is non zero
    {
        if(kWcharToNibble[(*string)&0x007f] & 0xf0)
        {
            TSmartPointerArray<WCHAR> saByteString = new WCHAR [(length * 2) + 1];
			if (saByteString == 0)
			{
				THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
			}
            memcpy(saByteString, string, length * 2);
            saByteString[length * 2] = 0x00;//NULL terminate it
            THROW_ERROR1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_A_NON_HEX_CHARACTER, saByteString);
        }
        *pBytes =  kWcharToNibble[(*string++)&0x007f]<<4;//The first character is the high nibble

        if(kWcharToNibble[(*string)&0x007f] & 0xf0)
        {
            TSmartPointerArray<WCHAR> saByteString = new WCHAR [(length * 2) + 1];
			if (saByteString == 0)
			{
				THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
			}

            memcpy(saByteString, string, length * 2);
            saByteString[length * 2] = 0x00;//NULL terminate it
            THROW_ERROR1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_A_NON_HEX_CHARACTER, saByteString);
        }
        *pBytes |= kWcharToNibble[(*string++)&0x007f];   //The second is the low nibble
    }
}

void TMetabaseMetaXmlFile::AddColumnMetaViaReferenceToHeap(const TElement &i_Element)
{
    //<Property       InheritsPropertiesFrom ="IIsConfigObject:MaxConnections"/>
    const TAttr & attrInheritsPropertiesFrom = GetAttribute(i_Element, m_InheritsPropertiesFrom);
    if(attrInheritsPropertiesFrom.IsNULL())
    {
        WCHAR wszOffendingXml[0x100];
        wcsncpy(wszOffendingXml, i_Element.m_NumberOfAttributes>0 ? i_Element.m_aAttribute[0].m_Name : L"", 0xFF);//copy up to 0xFF characters
        wszOffendingXml[0xFF]=0x00;

        LOG_ERROR2(IDS_SCHEMA_COMPILATION_ATTRIBUTE_NOT_FOUND, kszInheritsColumnMeta, wszOffendingXml);
    }
    
    ColumnMeta columnmeta;
    memset(&columnmeta, 0x00, sizeof(ColumnMeta));

    //wcstok needs a NULL terminated string
    WCHAR szTemp[256];
    if(attrInheritsPropertiesFrom.Value().GetStringLength() >= 256)
    {
        wcsncpy(szTemp, attrInheritsPropertiesFrom.Value().GetString(), 256);
        szTemp[252]=L'.';
        szTemp[253]=L'.';
        szTemp[254]=L'.';
        szTemp[255]=0x00;

        THROW_ERROR2(IDS_SCHEMA_COMPILATION_ATTRIBUTE_CONTAINS_TOO_MANY_CHARACTERS, kszInheritsColumnMeta, szTemp);
    }
    memcpy(szTemp, attrInheritsPropertiesFrom.Value().GetString(), attrInheritsPropertiesFrom.Value().GetStringLength() * sizeof(WCHAR));
    szTemp[attrInheritsPropertiesFrom.Value().GetStringLength()] = 0x00;//NULL terminate it

    //The inheritance string is of the form  TableName:ColumnName
    WCHAR * pTableName = wcstok(szTemp, L":");
    WCHAR * pColumnName = wcstok(0, L":");
    if(0==pTableName || 0==pColumnName)
    {
        memcpy(szTemp, attrInheritsPropertiesFrom.Value().GetString(), attrInheritsPropertiesFrom.Value().GetStringLength() * sizeof(WCHAR));
        szTemp[attrInheritsPropertiesFrom.Value().GetStringLength()] = 0x00;

        THROW_ERROR1(IDS_SCHEMA_COMPILATION_INHERITSPROPERTIESFROM_ERROR, szTemp);
    }
    if(*pTableName!=L'i' && *pTableName!=L'I')
    {
        THROW_ERROR2(IDS_SCHEMA_COMPILATION_INHERITSPROPERTIESFROM_BOGUS_TABLE, pTableName, wszTABLE_IIsConfigObject);
    }

    //See if the property is already part of this collection, if it is just ignore it.
    ULONG iColumnInternalName=AddWCharToList(pColumnName, attrInheritsPropertiesFrom.Value().GetStringLength() + 1 - (ULONG)(pColumnName-pTableName));
    ULONG iColumnAlreadyAdded;
    bool  bColumnAlreadyPartOfTheTable = (-1 != (iColumnAlreadyAdded = FindColumnBy_Table_And_InternalName(m_iCurrentTableName, iColumnInternalName, true)));
    if(!bColumnAlreadyPartOfTheTable)
    {
        //All inheritance MUST be from IIsConfigObject
        ULONG iColumnMeta = FindColumnBy_Table_And_InternalName(m_iTableName_IIsConfigObject, iColumnInternalName, true);

        if(-1 == iColumnMeta)
            return;//ignore properties we don't understand.  We would log an error but there are currently lots of these because of the way the MetaMigrate works

        //Now we tolerate duplicate inherited columns and ignore them
        //so we need to search this table's ColumnMeta for column name we're getting ready to add.
        ULONG i=GetCountColumnMeta()-1;
        for(; i>0 && ColumnMetaFromIndex(i)->Table==m_iCurrentTableName; --i)
        {
            if(ColumnMetaFromIndex(i)->InternalName == iColumnInternalName)
                return;//This ColumnInternalName already belongs to this table's ColumnMeta so ignore it
        }

        iColumnAlreadyAdded = m_NextColumnIndex;

        AddColumnMetaByReference(iColumnMeta);
    }

    //Check for overriding ColumnMeta - some ColumnMeta is inherited but overridden by the inheriting class
    CheckForOverrridingColumnMeta(i_Element, iColumnAlreadyAdded);

    //if this column is NOT already part of the table AND the table is a shipped table, then the shipped table has just been EXTENDED.
    if(!bColumnAlreadyPartOfTheTable && m_iCurrentTableMeta <= m_iLastShippedCollection)
    {//If this is a Shipped collection, then we need to mark the MetaFlagsEx (AKA SchemaGeneratorFlags) as EXTENDED (meaning the collection is a shipped collection; but it has been EXTENDED somehow).
        TableMetaFromIndex(m_iCurrentTableMeta)->SchemaGeneratorFlags = AddUI4ToList(UI4FromIndex(TableMetaFromIndex(m_iCurrentTableMeta)->SchemaGeneratorFlags) | fTABLEMETA_EXTENDED);
    }
}

ULONG TMetabaseMetaXmlFile::AddMergedContainerClassListToList(const TSizedString *i_pContainerClassList, LPCWSTR i_wszContainerClassListShipped, ULONG i_cchContainerClassListShipped, bool &o_bExtended)
{
    o_bExtended = false;

    //if the XML is NULL or L"" then use the shipped list
    if(0 == i_pContainerClassList || i_pContainerClassList->IsNULL() || 0 == i_pContainerClassList->GetStringLength())
        return AddWCharToList(i_wszContainerClassListShipped, i_cchContainerClassListShipped);

    //if the shipped schema is NULL or L"" then use the XML list
    if(0==i_cchContainerClassListShipped || 0==i_wszContainerClassListShipped)
    {
        o_bExtended = true;
        return AddStringToHeap(*i_pContainerClassList);
    }

    //this is cch of the string        this is cch of the buffer
    if(i_pContainerClassList->GetStringLength()==(i_cchContainerClassListShipped-1) && 0==memcmp(i_pContainerClassList->GetString(), i_wszContainerClassListShipped, i_pContainerClassList->GetStringLength() * sizeof(WCHAR)))
        return AddWCharToList(i_wszContainerClassListShipped, i_cchContainerClassListShipped);

    //@@@TODO  The line below disabled support for modifying ContainerClassList
    //return AddWCharToList(i_wszContainerClassListShipped, i_cchContainerClassListShipped);

    //this is the maximum size buffer needed.
    TSmartPointerArray<WCHAR> saMergedContainerClassList = new WCHAR[i_pContainerClassList->GetStringLength() + i_cchContainerClassListShipped + 2];//the plus one is for the extra comma between the strings, plus one more for the trailing comma that gets removed at the end
    TSmartPointerArray<WCHAR> saXmlContainerClassList    = new WCHAR[i_pContainerClassList->GetStringLength() + 2];//Add 2 to make searching easier

    if(0 == saMergedContainerClassList.m_p || 0 == saXmlContainerClassList.m_p)
    {
        THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
    }

    //wcstr needs two NULL terminated strings
    memcpy(saXmlContainerClassList.m_p, i_pContainerClassList->GetString(), i_pContainerClassList->GetStringLength()*sizeof(WCHAR));
    saXmlContainerClassList.m_p[i_pContainerClassList->GetStringLength()] = 0x00;//null terminate it
    saXmlContainerClassList.m_p[i_pContainerClassList->GetStringLength()+1] = 0x00;//This second NULL makes the searching below easier

    //@@@TODO: This is NOT the most efficient way of doing this; but it is the most straight forward.  We may need to optimize it.

    //if the XML string is different than the shipped list, then merge the two
    memcpy(saMergedContainerClassList.m_p, i_wszContainerClassListShipped, i_cchContainerClassListShipped * sizeof(WCHAR));//this cch includes the NULL
    ULONG   cchStringLenMergedList = i_cchContainerClassListShipped-1;

    saMergedContainerClassList[cchStringLenMergedList++] = L',';//add a comma to the end for easier searching
    saMergedContainerClassList[cchStringLenMergedList]   = 0x00;//NULL Terminate it

    LPWSTR  token = wcstok(saXmlContainerClassList, L",");
    while(token)
    {
        //OK, now to keep from finding property "Foo" in the MergedList "Foo2,Foo3," we need to look for the trailing comma (note the trailing comma - it's there for a reason)
        //we need to make the tokenized string "Foo\0Bar,Zee" into "Foo,\0ar,Zee"
        ULONG wchToken = (ULONG)wcslen(token);
        WCHAR wchAfterTheComma = 0x00;

        wchAfterTheComma  = token[wchToken+1];
        token[wchToken+1] = 0x00;
        token[wchToken]   = L',';

        if(0 == wcsstr(saMergedContainerClassList, token))
        {//if this class was not found in the merged list, then add it
            o_bExtended = true;
            wcscpy(saMergedContainerClassList + cchStringLenMergedList, token);
            cchStringLenMergedList += wchToken+1;
        }
        //now put the toekn back to the way it was
        token[wchToken+1] = wchAfterTheComma;
        token[wchToken]   = 0x00;

        token = wcstok(0, L",");
    }
    ASSERT(saMergedContainerClassList[cchStringLenMergedList-1] == L',');
    saMergedContainerClassList[--cchStringLenMergedList] = 0x00;//remove the last comma


    return AddWCharToList(saMergedContainerClassList, cchStringLenMergedList+1/*This parameter is the size including the NULL*/);
}

void TMetabaseMetaXmlFile::AddServerWiringMetaToHeap(ULONG iTableName, bool i_bFixedInterceptor)
{
    ServerWiringMeta serverwiringmeta;
    serverwiringmeta.Table          = iTableName;
    serverwiringmeta.Order          = AddUI4ToList(0);
    serverwiringmeta.ReadPlugin     = 0;//defaulted later
    serverwiringmeta.WritePlugin    = 0;//defaulted later
    serverwiringmeta.Merger         = 0;//defaulted later

    //All tables come from the XML interceptor except MBPropertyDiff, which comes from the differencing interceptor
    if(i_bFixedInterceptor)//the only other databases use the FixedInterceptor
        serverwiringmeta.Interceptor    = AddUI4ToList(eSERVERWIRINGMETA_Core_FixedInterceptor);
    else
    {
        if(0 == _wcsicmp(wszTABLE_MBPropertyDiff, StringFromIndex(iTableName)))
            serverwiringmeta.Interceptor    = AddUI4ToList(eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor);
        else if(0 == _wcsicmp(wszTABLE_MBProperty, StringFromIndex(iTableName)))
            serverwiringmeta.Interceptor    = AddUI4ToList(eSERVERWIRINGMETA_Core_MetabaseInterceptor);
        else
            serverwiringmeta.Interceptor    = AddUI4ToList(eSERVERWIRINGMETA_Core_XMLInterceptor);
    }

    serverwiringmeta.ReadPluginDLLName	= 0;//inferred later
    serverwiringmeta.WritePluginDLLName	= 0;//inferred later
    serverwiringmeta.InterceptorDLLName	= 0;//inferred later
    serverwiringmeta.MergerDLLName		= 0;//inferred later
    serverwiringmeta.Flags				= 0;//inferred later
    serverwiringmeta.Locator			= 0;//inferred later
    serverwiringmeta.Reserved			= 0;//inferred later

    AddServerWiringMetaToList(&serverwiringmeta);
}

void TMetabaseMetaXmlFile::AddShippedColumnMetaToHeap(ULONG i_iTableName, const ColumnMeta *i_pColumnMeta)
{
    ColumnMeta columnmeta;
    memset(&columnmeta, 0x00, sizeof(ColumnMeta));

    m_iCurrentColumnIndex           = AddUI4ToList( m_NextColumnIndex);//Don't increment m_NextColumnIndex until this column is actually added

    columnmeta.Table                = i_iTableName;
    columnmeta.Index                = m_iCurrentColumnIndex;
    columnmeta.InternalName         = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->InternalName)/sizeof(WCHAR));

    if(i_pColumnMeta->PublicName == i_pColumnMeta->InternalName)
        columnmeta.PublicName       = columnmeta.InternalName;
    else
        columnmeta.PublicName       = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->PublicName)/sizeof(WCHAR));

    columnmeta.Type                 = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->Type)));
    columnmeta.Size                 = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->Size)));
    columnmeta.MetaFlags            = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->MetaFlags)));
    columnmeta.DefaultValue         = AddBytesToList(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->DefaultValue), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->DefaultValue));
    columnmeta.FlagMask             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->FlagMask)));
    columnmeta.StartingNumber       = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->StartingNumber)));
    columnmeta.EndingNumber         = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->EndingNumber)));
    columnmeta.CharacterSet         = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->CharacterSet)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->CharacterSet)/sizeof(WCHAR));
    columnmeta.SchemaGeneratorFlags = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->SchemaGeneratorFlags)));
    columnmeta.ID                   = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->ID)));
    columnmeta.UserType             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->UserType)));
    columnmeta.Attributes           = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->Attributes)));
    columnmeta.Description			= AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->Description)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->Description)/sizeof(WCHAR));
    columnmeta.PublicColumnName		= AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->PublicColumnName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->PublicColumnName)/sizeof(WCHAR));
	columnmeta.ciTagMeta            = 0;//Inferred later
    columnmeta.iTagMeta             = 0;//Inferred later
    columnmeta.iIndexName           = 0;//Not used

    const TagMeta * pTagMeta = m_pShippedSchemaHeap->Get_aTagMeta(i_pColumnMeta->iTagMeta);
    for(ULONG i=0;i<i_pColumnMeta->ciTagMeta;++i, ++pTagMeta)
        AddShippedTagMetaToHeap(i_iTableName, columnmeta.Index, pTagMeta);

    m_iLastShippedProperty = AddColumnMetaToList(&columnmeta) / sizeof(ColumnMeta);//Keep track of the last shipped property, this can make some lookups faster
    ++m_NextColumnIndex;
    m_iCurrentColumnIndex = 0;//This set to zero means that no more Tags are allowed to be added to this column
}


void TMetabaseMetaXmlFile::AddShippedIndexMetaToHeap(ULONG i_iTableName, const IndexMeta *i_pIndexMeta)
{
    IndexMeta indexmeta;
    indexmeta.Table                 = i_iTableName;
    indexmeta.InternalName          = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pIndexMeta->InternalName)/sizeof(WCHAR));

    if(i_pIndexMeta->PublicName == i_pIndexMeta->InternalName)
        indexmeta.PublicName        = indexmeta.InternalName;
    else
        indexmeta.PublicName        = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pIndexMeta->PublicName)/sizeof(WCHAR));

    indexmeta.ColumnIndex           = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->ColumnIndex)));
    indexmeta.ColumnInternalName    = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->ColumnInternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pIndexMeta->ColumnInternalName)/sizeof(WCHAR));
    indexmeta.MetaFlags             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->MetaFlags)));

    AddIndexMetaToList(&indexmeta);
}


void TMetabaseMetaXmlFile::AddShippedTableMetaToHeap(const TableMeta *i_pTableMeta, bool i_bFixedInterceptor, const TSizedString *i_pContainerClassList)
{
    TableMeta tablemeta;
    memset(&tablemeta, 0x00, sizeof(TableMeta));

    m_iCurrentDatabaseName          = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->Database)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->Database)/sizeof(WCHAR));
    tablemeta.Database              = m_iCurrentDatabaseName;
    tablemeta.InternalName          = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->InternalName)/sizeof(WCHAR));

    if(i_pTableMeta->PublicName == i_pTableMeta->InternalName)
        tablemeta.PublicName        = tablemeta.InternalName;
    else
        tablemeta.PublicName        = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->PublicName)/sizeof(WCHAR));

    tablemeta.PublicRowName         = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->PublicRowName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->PublicRowName)/sizeof(WCHAR));
    tablemeta.BaseVersion           = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->BaseVersion)));
    tablemeta.ExtendedVersion       = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ExtendedVersion)));
    tablemeta.NameColumn            = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->NameColumn)));
    tablemeta.NavColumn             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->NavColumn)));
    tablemeta.CountOfColumns        = 0;//This will be inferred later 
    tablemeta.MetaFlags             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->MetaFlags)));
    //tablemeta.SchemaGeneratorFlags is done after ContainerClassList
    tablemeta.ConfigItemName        = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ConfigItemName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->ConfigItemName)/sizeof(WCHAR));
    tablemeta.ConfigCollectionName  = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ConfigCollectionName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->ConfigCollectionName)/sizeof(WCHAR));
    tablemeta.PublicRowNameColumn   = 0;

    //Users can modify this column.  They can add classes but not removed any.
    bool bExtended;
    tablemeta.ContainerClassList    = AddMergedContainerClassListToList(i_pContainerClassList, reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ContainerClassList)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->ContainerClassList)/sizeof(WCHAR), bExtended);
    tablemeta.SchemaGeneratorFlags  = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->SchemaGeneratorFlags)) | (bExtended ? fTABLEMETA_EXTENDED : 0));

    tablemeta.Description           = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->Description)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->Description)/sizeof(WCHAR));
    tablemeta.ChildElementName      = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ChildElementName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->ChildElementName)/sizeof(WCHAR));

    tablemeta.ciRows                = 0;//N/A   
    tablemeta.iColumnMeta           = 0;//Inferred later
    tablemeta.iFixedTable           = 0;//N/A
    tablemeta.cPrivateColumns       = 0;//N/A
    tablemeta.cIndexMeta            = 0;//N/A
    tablemeta.iIndexMeta            = 0;//N/A
    tablemeta.iHashTableHeader      = 0;//N/A
    tablemeta.nTableID              = 0;//N/A
    tablemeta.iServerWiring         = 0;//N/A
    tablemeta.cServerWiring         = 0;//N/A

    m_iCurrentTableMeta             = AddTableMetaToList(&tablemeta) / sizeof(TableMeta);//Keep track of the last shipped collection, this can make some lookups faster
    m_iLastShippedCollection        = m_iCurrentTableMeta;
    m_NextColumnIndex               = 0;//We're starting a new table so the ColumnIndex start at zero
    m_iCurrentTableName             = tablemeta.InternalName;

    AddServerWiringMetaToHeap(tablemeta.InternalName, i_bFixedInterceptor);

    const ColumnMeta * pColumnMeta = m_pShippedSchemaHeap->Get_aColumnMeta(i_pTableMeta->iColumnMeta);
    for(;m_NextColumnIndex<*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->CountOfColumns));++pColumnMeta)
        AddShippedColumnMetaToHeap(tablemeta.InternalName, pColumnMeta);//This function increments the m_NextColumnIndex counter

    if(i_bFixedInterceptor && -1!=i_pTableMeta->iIndexMeta)
    {
        const IndexMeta * pIndexMeta = m_pShippedSchemaHeap->Get_aIndexMeta(i_pTableMeta->iIndexMeta);
        for(ULONG iIndexMeta=0; iIndexMeta<i_pTableMeta->cIndexMeta; ++iIndexMeta, ++pIndexMeta)
            AddShippedIndexMetaToHeap(tablemeta.InternalName, pIndexMeta);
    }
    //The last shipped Collection to be added is IISConfigObject.  We rely on m_NextColumnIndex to be correct so we can continue to increment it
    //when adding user defined properties.
}


void TMetabaseMetaXmlFile::AddShippedTagMetaToHeap(ULONG i_iTableName, ULONG i_iColumnIndex, const TagMeta *i_pTagMeta)
{
    TagMeta tagmeta;

    tagmeta.Table                   = i_iTableName;
    tagmeta.ColumnIndex             = i_iColumnIndex;
    tagmeta.InternalName            = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTagMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTagMeta->InternalName)/sizeof(WCHAR));

    if(i_pTagMeta->PublicName == i_pTagMeta->InternalName)
        tagmeta.PublicName          = tagmeta.InternalName;
    else
        tagmeta.PublicName          = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTagMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTagMeta->PublicName)/sizeof(WCHAR));

    tagmeta.Value                   = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTagMeta->Value)));
    tagmeta.ID                      = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTagMeta->ID)));

    m_iLastShippedTag = AddTagMetaToList(&tagmeta) / sizeof(TagMeta);//Keep track of the last shipped tag, this can make some lookups faster
}


ULONG TMetabaseMetaXmlFile::AddStringToHeap(const TSizedString &i_str)
{
    if(i_str.IsNULL())
        return 0;//NULL

    TSmartPointerArray<WCHAR>   saTemp;
    WCHAR                       szTemp[1024];//We need to make a copy of the string because it needs to be NULL terminated
    WCHAR *                     pTemp = szTemp;

    if(i_str.GetStringLength() >= 1024)//only allocate heap space if the stack variable isn't big enough
    {
        saTemp = new WCHAR [i_str.GetStringLength() + 1];
        if(0 == saTemp.m_p)
        {
            THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
        }
		pTemp  = saTemp.m_p;
    }

    memcpy(pTemp, i_str.GetString(), i_str.GetStringLength() * sizeof(WCHAR));
    pTemp[i_str.GetStringLength()]=0x00;//NULL terminate the temp string
    return AddWCharToList(pTemp, i_str.GetStringLength()+1);
}

void TMetabaseMetaXmlFile::AddTableMetaToHeap(const TElement &i_Element)
{
    TableMeta tablemeta;
    memset(&tablemeta, 0x00, sizeof(TableMeta));

    tablemeta.Database              = m_iCurrentDatabaseName;
    tablemeta.InternalName          = m_iCurrentTableName;
    tablemeta.PublicName            = AddStringToHeap(GetAttribute(i_Element, m_PublicName).Value());        
    tablemeta.PublicRowName         = AddStringToHeap(GetAttribute(i_Element, m_PublicRowName).Value());        
    tablemeta.BaseVersion           = AddUI4ToList(GetAttribute(i_Element, m_BaseVersion).Value().ToUI4());
    tablemeta.ExtendedVersion       = AddUI4ToList(GetAttribute(i_Element, m_ExtendedVersion).Value().ToUI4());
    tablemeta.NameColumn            = AddStringToHeap(GetAttribute(i_Element, m_NameColumn).Value());        
    tablemeta.NavColumn             = AddStringToHeap(GetAttribute(i_Element, m_NavColumn).Value());        
    tablemeta.CountOfColumns        = 0;//This will be inferred later 

    const TAttr & attrMetaFlags = GetAttribute(i_Element, m_MetaFlags);
    if(!attrMetaFlags.IsNULL())
        tablemeta.MetaFlags             = AddUI4ToList(StringToFlagValue(attrMetaFlags.Value(), wszTABLE_TABLEMETA, iTABLEMETA_MetaFlags));
    else
        tablemeta.MetaFlags             = AddUI4ToList(0);

    const TAttr & attrSchemaGeneratorFlags = GetAttribute(i_Element, m_SchemaGeneratorFlags);
    if(attrSchemaGeneratorFlags.IsNULL())
        tablemeta.SchemaGeneratorFlags  = AddUI4ToList(fCOLUMNMETA_USERDEFINED);//Make sure this table is marked as an extended table
    else
    {
        ULONG SchemaGeneratorFlags = StringToFlagValue(attrSchemaGeneratorFlags.Value(), wszTABLE_TABLEMETA, iTABLEMETA_SchemaGeneratorFlags);
        if(SchemaGeneratorFlags & (fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED))
        {
            m_out.printf(L"Warning - Table (%s) - Some TableMeta::MetaFlagsEx should be inferred (resetting these flags).  The following flags should NOT be specified by the user.  These flags are inferred:fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED\n", StringFromIndex(tablemeta.InternalName));
            SchemaGeneratorFlags &= ~(fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED);
        }
        tablemeta.SchemaGeneratorFlags  = AddUI4ToList(SchemaGeneratorFlags | fCOLUMNMETA_USERDEFINED);
    }

    //tablemeta.ConfigItemName        = 0;
    //tablemeta.ConfigCollectionName  = 0; 
    //tablemeta.PublicRowNameColumn   = 0;
    tablemeta.ContainerClassList    = AddStringToHeap(GetAttribute(i_Element, m_ContainerClassList).Value());
    tablemeta.Description			= AddStringToHeap(GetAttribute(i_Element, m_Description).Value());
    //tablemeta.ChildElementName      = 0;//N/A  Not used by the Metabase
    //tablemeta.ciRows                = 0;//N/A   
    //tablemeta.iColumnMeta           = 0;//Inferred later
    //tablemeta.iFixedTable           = 0;//N/A
    //tablemeta.cPrivateColumns       = 0;//N/A
    //tablemeta.cIndexMeta            = 0;//N/A
    //tablemeta.iIndexMeta            = 0;//N/A
    //tablemeta.iHashTableHeader      = 0;//N/A
    //tablemeta.nTableID              = 0;//N/A
    //tablemeta.iServerWiring         = 0;//N/A
    //tablemeta.cServerWiring         = 0;//N/A

    m_iCurrentTableMeta = AddTableMetaToList(&tablemeta);
    AddServerWiringMetaToHeap(tablemeta.InternalName);

    m_NextColumnIndex           = 0;//We're starting a new table so the ColumnIndex start at zero
    m_iCurrentColumnIndex       = 0;//This prevents us from receiving TagMeta without first getting a Column

    AddColumnMetaByReference(m_iColumnMeta_Location);
}

void TMetabaseMetaXmlFile::AddTagMetaToHeap(const TElement &i_Element)
{
    TagMeta tagmeta;
    tagmeta.Table               = m_iCurrentTableName;
    tagmeta.ColumnIndex         = m_iCurrentColumnIndex;
    tagmeta.InternalName        = AddStringToHeap(GetAttribute(i_Element, m_InternalName).Value());        
    tagmeta.PublicName          = AddStringToHeap(GetAttribute(i_Element, m_PublicName).Value());                
    tagmeta.Value               = AddUI4ToList(GetAttribute(i_Element, m_Value).Value().ToUI4());
    tagmeta.ID                  = AddUI4ToList(GetAttribute(i_Element, m_ID).Value().ToUI4());

    if(UI4FromIndex(tagmeta.ID) > m_LargestID)
        m_LargestID = UI4FromIndex(tagmeta.ID);

    AddTagMetaToList(&tagmeta);
}


unsigned long TMetabaseMetaXmlFile::AddUI4ToList(ULONG ui4)
{
    //At kcStaticUI4HeapEntries==429 this optimization gets a 69% hit ratio
    if(ui4<kcStaticUI4HeapEntries)//The first kcStaticUI4HeapEntries are initialized in the beginning so we don't have to scan the heap
        return m_aiUI4[ui4];

    return m_HeapPooled.AddItemToHeapWithoutPooling(reinterpret_cast<const unsigned char *>(&ui4), sizeof(ULONG));
}


unsigned long TMetabaseMetaXmlFile::AddWCharToList(LPCWSTR wsz, unsigned long cwchar)
{
    if(0 == wsz)
        return 0;
    return (m_HeapPooled.AddItemToHeap(wsz, cwchar));
}


//Scans the shipped databases and adds the "Meta" & "Metabase" databases to the DatabaseHeap
void TMetabaseMetaXmlFile::BuildDatabaseMeta(const DatabaseMeta * &o_pDatabaseMeta_METABASE)
{
    //From the FixedTableHeap, find the DatabaseMeta for 'Metabase'
    const DatabaseMeta *pDatabaseMeta = m_pShippedSchemaHeap->Get_aDatabaseMeta(0);
    const DatabaseMeta *pDatabaseMeta_METABASE=0;
    for(ULONG iDatabaseMeta=0;iDatabaseMeta<m_pShippedSchemaHeap->Get_cDatabaseMeta();++iDatabaseMeta,++pDatabaseMeta)// assume Metabase database is last - so walk backward from the end
    {
        if(m_Meta.IsEqual(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->InternalName))))
        {
            //Add this row to the DatabaseMeta heap.
            DatabaseMeta databasemeta;
            memset(&databasemeta, 0x00, sizeof(databasemeta));
            databasemeta.InternalName   = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->InternalName)/sizeof(WCHAR));

            if(pDatabaseMeta->PublicName == pDatabaseMeta->InternalName)
                databasemeta.PublicName = databasemeta.InternalName;
            else
                databasemeta.PublicName = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->PublicName)/sizeof(WCHAR));

            databasemeta.BaseVersion    = AddUI4ToList(*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->BaseVersion)));
            databasemeta.ExtendedVersion= AddUI4ToList(*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->ExtendedVersion)));
            //databasemeta.CountOfTables  = 0;//We'll leave this to be inferred later (since the CountOfTables of the shipped schema may not be the same as what we're compiling)
			databasemeta.Description    = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->Description)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->Description)/sizeof(WCHAR));
            //databasemeta.iSchemaBlob    = 0;//Not used
            //databasemeta.cbSchemaBlob   = 0;//Not used
            //databasemeta.iNameHeapBlob  = 0;//Not used
            //databasemeta.cbNameHeapBlob = 0;//Not used
            //databasemeta.iTableMeta     = 0;//This will be inferred later (it should turn out to be 0 since this is the only database in the bin file).
            //databasemeta.iGuidDid       = 0;//Not used

            AddDatabaseMetaToList(&databasemeta);
        }
        else if(m_Metabase.IsEqual(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->InternalName))))
        {
            pDatabaseMeta_METABASE = pDatabaseMeta;

            //Add this row to the DatabaseMeta heap.
            DatabaseMeta databasemeta;
            memset(&databasemeta, 0x00, sizeof(databasemeta));
            databasemeta.InternalName   = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->InternalName)/sizeof(WCHAR));

            if(pDatabaseMeta->PublicName == pDatabaseMeta->InternalName)
                databasemeta.PublicName = databasemeta.InternalName;
            else
                databasemeta.PublicName = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->PublicName)/sizeof(WCHAR));

            databasemeta.BaseVersion    = AddUI4ToList(*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->BaseVersion)));
            databasemeta.ExtendedVersion= AddUI4ToList(*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->ExtendedVersion)));
            //databasemeta.CountOfTables  = 0;//We'll leave this to be inferred later (since the CountOfTables of the shipped schema may not be the same as what we're compiling)
			databasemeta.Description	= AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->Description)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->Description)/sizeof(WCHAR));
            //databasemeta.iSchemaBlob    = 0;//Not used
            //databasemeta.cbSchemaBlob   = 0;//Not used
            //databasemeta.iNameHeapBlob  = 0;//Not used
            //databasemeta.cbNameHeapBlob = 0;//Not used
            //databasemeta.iTableMeta     = 0;//This will be inferred later (it should turn out to be 0 since this is the only database in the bin file).
            //databasemeta.iGuidDid       = 0;//Not used

            AddDatabaseMetaToList(&databasemeta);
            break;//We're assuming that the Metabase database comes after the Meta database.
        }
    }
    if(0 == pDatabaseMeta_METABASE)
    {
        THROW_ERROR1(IDS_SCHEMA_COMPILATION_NO_METABASE_DATABASE, wszTABLE_MetabaseBaseClass);
    }
    o_pDatabaseMeta_METABASE = pDatabaseMeta_METABASE;
}


void TMetabaseMetaXmlFile::CheckForOverrridingColumnMeta(const TElement &i_Element, ULONG i_iColumnMetaToOverride)
{
    //Now check for overriding PropertyMeta (the only one we plan to support is MetaFlagsEx)
    const TSizedString & schemageneratorflagsValue = GetAttribute(i_Element, m_SchemaGeneratorFlags).Value();
    if(0==schemageneratorflagsValue.GetString())
        return;

    ColumnMeta * pColumnMeta = ColumnMetaFromIndex(i_iColumnMetaToOverride);

    ULONG ulMetaFlagsEx = UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) | StringToFlagValue(schemageneratorflagsValue, wszTABLE_COLUMNMETA, iCOLUMNMETA_SchemaGeneratorFlags);

    if(UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) != ulMetaFlagsEx)
        ulMetaFlagsEx |= fCOLUMNMETA_EXTENDED;//if MetaFlagsEx is different from the ColumnMeta defined in IISConfigObject, the indicate so by setting the EXTENDED flag
    pColumnMeta->SchemaGeneratorFlags = AddUI4ToList(ulMetaFlagsEx);
}

//Returns the index to the ColumnMeta or ~0x00 if the property was not found
ULONG TMetabaseMetaXmlFile::FindUserDefinedPropertyBy_Table_And_InternalName(unsigned long Table, unsigned long  InternalName)
{
    ASSERT(0 == Table%4);
    ASSERT(0 == InternalName%4);
    
    for(ULONG iColumnMeta=m_iLastShippedProperty+1; iColumnMeta<GetCountColumnMeta();--iColumnMeta)
    {
        if( 0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->Table), StringFromIndex(Table)) &&
            0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->InternalName), StringFromIndex(InternalName)))
            break;
    }
    return (iColumnMeta<GetCountColumnMeta() ? iColumnMeta : ~0x00); //return ~0 if the property was not found
}


const TOLEDataTypeToXMLDataType * TMetabaseMetaXmlFile::Get_OLEDataTypeToXMLDataType(const TSizedString &i_str)
{
    const TOLEDataTypeToXMLDataType * pOLEDataType = OLEDataTypeToXMLDataType;

    for(;0 != pOLEDataType->String; ++pOLEDataType)//Walk the list to find the
        if(i_str.IsEqualCaseInsensitive(pOLEDataType->String))
            return pOLEDataType;

    WCHAR szType[1024];
    memcpy(szType, i_str.GetString(), min(i_str.GetStringLength(), 1023));
    szType[min(i_str.GetStringLength(), 1023)] = 0x00;
    THROW_ERROR1(IDS_SCHEMA_COMPILATION_UNKNOWN_DATA_TYPE, szType);

    return 0;
}


const TMetabaseMetaXmlFile::TAttr & TMetabaseMetaXmlFile::GetAttribute(const TElement &i_Element, const TSizedString &i_AttrName)
{
    static TAttr attrNULL;
    ULONG iAttr=0;
    for(;iAttr<i_Element.m_NumberOfAttributes;++iAttr)
    {
        if(i_AttrName.IsEqual(i_Element.m_aAttribute[iAttr].m_Name, i_Element.m_aAttribute[iAttr].m_NameLength))
            return *reinterpret_cast<const TAttr *>(&i_Element.m_aAttribute[iAttr]);
    }
    return attrNULL;
}


void TMetabaseMetaXmlFile::PresizeHeaps()
{
    //presize heaps

    //These numbers come from the Debug Output that's generated at the end of the copilation
    //We leave a little extra room to handle user defined properties.  So only if the user defines
    //lots of properties do we ever have to do a realloc.

    m_HeapColumnMeta.GrowHeap(160000);
    m_HeapDatabaseMeta.GrowHeap(88);
    m_HeapHashedIndex.GrowHeap(450000);
    m_HeapIndexMeta.GrowHeap(392);
    //m_HeapQueryMeta.GrowHeap(0);
    //m_HeapRelationMeta.GrowHeap(0);
    m_HeapServerWiringMeta.GrowHeap(3000);
    m_HeapTableMeta.GrowHeap(8000);
    m_HeapTagMeta.GrowHeap(100000);
    //m_HeapULONG.GrowHeap(0);
    m_HeapPooledUserDefinedID.GrowHeap(300);

    m_HeapPooled.GrowHeap(55000);

    m_HeapPooled.SetFirstPooledIndex(-1);

    for(ULONG UI4Value=0;UI4Value!=kcStaticUI4HeapEntries;++UI4Value)//For values between 0 and 255 we'll index to them directly so we done linearly search for the matching entry
        m_aiUI4[UI4Value] = m_HeapPooled.AddItemToHeap(UI4Value);

    m_HeapPooled.SetFirstPooledIndex(m_HeapPooled.GetEndOfHeap());
}


bool TMetabaseMetaXmlFile::ShouldAddColumnMetaToHeap(const TElement &Element, ULONG iColumnInternalName)
{
    //If the property a shipped property?  If so ignore it.  If the proerty is in error, log warning and ignore it.

    tCOLUMNMETARow columnmetaRow = {0};
    columnmetaRow.pTable        = wszTABLE_IIsConfigObject;
    columnmetaRow.pInternalName = const_cast<LPWSTR>(StringFromIndex(iColumnInternalName));

    ULONG aiColumns[2];
    aiColumns[0] = iCOLUMNMETA_Table;
    aiColumns[1] = iCOLUMNMETA_InternalName;

    ULONG iColumnMetaRow;
    if(SUCCEEDED(m_spISTColumnMeta->GetRowIndexBySearch(  0, 2, aiColumns, 0, reinterpret_cast<LPVOID *>(&columnmetaRow), &iColumnMetaRow)))
        return false;

    //If the property was not found ByName, the search ByID
    ULONG        ulID   = GetAttribute(Element, m_ID).Value().ToUI4();
    columnmetaRow.pID   = &ulID;
    aiColumns[1]        = iCOLUMNMETA_ID;

    if(SUCCEEDED(m_spISTColumnMetaByID->GetRowIndexBySearch(  0, 2, aiColumns, 0, reinterpret_cast<LPVOID *>(&columnmetaRow), &iColumnMetaRow)))
    {   //We already searched for this property ByName and didn't find it in the shipped schema, now we ARE finding it by ID.  That a conflict.
        LPWSTR wszShippedProperty = L"";
        ULONG  iColumnInternalName = iCOLUMNMETA_InternalName;
        VERIFY(SUCCEEDED(m_spISTColumnMetaByID->GetColumnValues(iColumnMetaRow, 1, &iColumnInternalName, 0, reinterpret_cast<LPVOID *>(&wszShippedProperty))));

        WCHAR wszOffendingXml[0x100];
        wcsncpy(wszOffendingXml, Element.m_NumberOfAttributes>0 ? Element.m_aAttribute[0].m_Name : L"", 0xFF);//copy up to 0xFF characters
        wszOffendingXml[0xFF]=0x00;

        WCHAR wszID[12];
        wsprintf(wszID, L"%d", ulID);

        LOG_WARNING4(IDS_SCHEMA_COMPILATION_USERDEFINED_PROPERTY_HAS_COLLIDING_ID, columnmetaRow.pInternalName, wszID, wszShippedProperty, wszOffendingXml);
        return false;
    }

    //At this point we know we have a User-Defined property
    //check to see if we've seen this ID before
    ULONG ipoolCurrentID = m_HeapPooledUserDefinedID.AddItemToHeap(ulID);
    if(ipoolCurrentID <= m_ipoolPrevUserDefinedID)//if this ID wasn't added to the end of the list, then we have a warning
    {
        WCHAR wszOffendingXml[0x100];
        wcsncpy(wszOffendingXml, Element.m_NumberOfAttributes>0 ? Element.m_aAttribute[0].m_Name : L"", 0xFF);//copy up to 0xFF characters
        wszOffendingXml[0xFF]=0x00;

        WCHAR wszID[12];
        wsprintf(wszID, L"%d", ulID);

        LOG_WARNING3(IDS_SCHEMA_COMPILATION_USERDEFINED_PROPERTY_HAS_COLLIDING_ID_, columnmetaRow.pInternalName, wszID, wszOffendingXml);
        return false;//ignore this property
    }
    m_ipoolPrevUserDefinedID = ipoolCurrentID;//remember the latest ID added,

    return true;
}


ULONG TMetabaseMetaXmlFile::StringToEnumValue(const TSizedString &i_strValue, LPCWSTR i_wszTable, ULONG i_iColumn, bool bAllowNumeric)
{
    if(i_strValue.IsNULL())
        return 0;

    if(bAllowNumeric && i_strValue.GetString()[0] >= L'0' && i_strValue.GetString()[0] <= L'9')
    {
        WCHAR * dummy;
        return wcstol(i_strValue.GetString(), &dummy, 10);
    }

    //We need a NULL terminated string so we can call wcstok
    TSmartPointerArray<WCHAR>   saTemp;
    WCHAR                       szTemp[1024];//We need to make a copy of the string because it needs to be NULL terminated
    WCHAR *                     pTemp = szTemp;

    if(i_strValue.GetStringLength() >= 1024)//only allocate heap space if the stack variable isn't big enough
    {
        saTemp = new WCHAR [i_strValue.GetStringLength() + 1];
        if(0 == saTemp.m_p)
        {
            THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
        }
		pTemp  = saTemp.m_p;
    }

    memcpy(pTemp, i_strValue.GetString(), i_strValue.GetStringLength() * sizeof(WCHAR));
    pTemp[i_strValue.GetStringLength()] = 0x00;//NULL terminate it

    ULONG   iRow;
    LPVOID  apvValues[3];
    apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(i_wszTable));
    apvValues[1] = reinterpret_cast<LPVOID>(&i_iColumn);
    apvValues[2] = reinterpret_cast<LPVOID>(pTemp);
    if(FAILED(m_spISTTagMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
    {//The XML contains a bogus flag
        THROW_ERROR2(IDS_SCHEMA_COMPILATION_ILLEGAL_ENUM_VALUE, pTemp, i_wszTable);
    }

    ULONG * plEnum;
    ULONG   iValueColumn = iTAGMETA_Value;
    VERIFY(SUCCEEDED(m_spISTTagMeta->GetColumnValues(iRow, 1, &iValueColumn, 0, reinterpret_cast<LPVOID *>(&plEnum))));
    return *plEnum;
}


ULONG TMetabaseMetaXmlFile::StringToFlagValue(const TSizedString &i_strValue, LPCWSTR i_wszTable, ULONG i_iColumn)
{
    if(i_strValue.IsNULL())
        return 0;

    //We need a NULL terminated string so we can call wcstok
    TSmartPointerArray<WCHAR>   saTemp;
    WCHAR                       szTemp[1024];//We need to make a copy of the string because it needs to be NULL terminated
    WCHAR *                     pTemp = szTemp;

    if(i_strValue.GetStringLength() >= 1024)//only allocate heap space if the stack variable isn't big enough
    {
        saTemp = new WCHAR [i_strValue.GetStringLength() + 1];
        if(0 == saTemp.m_p)
        {
            THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
        }
		pTemp  = saTemp.m_p;
    }

    memcpy(pTemp, i_strValue.GetString(), i_strValue.GetStringLength() * sizeof(WCHAR));
    pTemp[i_strValue.GetStringLength()] = 0x00;//NULL terminate it

    ULONG   lFlags = 0;
    WCHAR * pFlag = wcstok(pTemp, L" |,");

    ULONG   iRow;
    LPVOID  apvValues[3];
    apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(i_wszTable));
    apvValues[1] = reinterpret_cast<LPVOID>(&i_iColumn);

    ULONG iValueColumn = iTAGMETA_Value;
    ULONG *pFlagValue;
    while(pFlag != 0)
    {
        apvValues[2] = reinterpret_cast<LPVOID>(pFlag);
        if(FAILED(m_spISTTagMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
        {//The XML contains a bogus flag
            LOG_ERROR2(IDS_SCHEMA_COMPILATION_ILLEGAL_FLAG_VALUE, pFlag, i_wszTable); 
        }
        else
        {
            VERIFY(SUCCEEDED(m_spISTTagMeta->GetColumnValues(iRow, 1, &iValueColumn, 0, reinterpret_cast<LPVOID *>(&pFlagValue))));
            lFlags |= *pFlagValue;
        }
        pFlag = wcstok(0, L" ,|");
    }
    return lFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\theap.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __THEAP_H__
#define __THEAP_H__

#ifndef __TEXCEPTION_H__
    #include "TException.h"
#endif
//This is a heap that holds UI4s and bytes, it does NOT directly hold strings or GUIDs.  TPooledHeap takes care of pooling like strings and guids.
class TBaseHeap
{
public:
    TBaseHeap(ULONG cbInitialSize) : 
         m_cbSizeOfHeap(0)
        ,m_iEndOfHeap(0)
        ,m_pHeap(0)
    {
        if(cbInitialSize>0)
            GrowHeap(cbInitialSize);
     }

    virtual ~TBaseHeap()
    {
        if(0 != m_pHeap)
        {
            ASSERT(m_cbSizeOfHeap>0);
            free(m_pHeap);
            m_pHeap = 0;
        }
    }

    virtual void    GrowHeap(ULONG cbAmountToGrow)
    {
        m_pHeap = reinterpret_cast<unsigned char *>(realloc(m_pHeap, m_cbSizeOfHeap += (ULONG)RoundUpToNearestULONGBoundary(cbAmountToGrow)));
        if(0 == m_pHeap)
            THROW(OUT OF MEMORY);
    }

    ULONG                   GetEndOfHeap() const {return m_iEndOfHeap;}
    ULONG                   GetSizeOfHeap()     const {return m_cbSizeOfHeap;}
    const unsigned char *   GetHeapPointer()    const {return m_pHeap;}

protected:
    size_t          RoundUpToNearestULONGBoundary(size_t cb) const {return ((cb + 3) & -4);}
    unsigned char * m_pHeap;//Making this protected saves a bunch of const_casts

    ULONG           m_cbSizeOfHeap;
    ULONG           m_iEndOfHeap;//This is where new items get added.  Since items always reside on a ULONG boundary, this should always be divisible by 4 (sizeof(ULONG))

};

template <class T> class THeap : public TBaseHeap
{
public:
    THeap(const TBaseHeap &heap) : TBaseHeap(0){AddItemToHeap(heap);}
    THeap(ULONG cbInitialSize=0x10) : TBaseHeap(cbInitialSize){}

    operator T *()                        const {return reinterpret_cast<T *>(m_pHeap);}

    T *                     GetTypedPointer(ULONG i=0)     {ASSERT(0==i || i<GetCountOfTypedItems()); return (reinterpret_cast<T *>(m_pHeap))+i;}
    ULONG                   GetCountOfTypedItems()   const {return m_iEndOfHeap / sizeof(T);}

    ULONG   AddItemToHeap(const unsigned char *aBytes, unsigned long cb)
    {
        if(0 == aBytes || 0 == cb)
            return m_iEndOfHeap;
        ASSERT(m_cbSizeOfHeap >= m_iEndOfHeap);//they're both unsigned so if the ever fails we're in trouble.

        ULONG cbPaddedSize = (ULONG) RoundUpToNearestULONGBoundary(cb);

        //Check to see if it will fit into the heap
        if((m_cbSizeOfHeap - m_iEndOfHeap) < cbPaddedSize)
            GrowHeap(cb);//GrowHeap rounds up to nearest ULONG boundary for us
        
        //Get a pointer to the place where we're adding this data (which is located at the end of the heap).
        unsigned char * pData = m_pHeap + m_iEndOfHeap;
        if(cb != cbPaddedSize)//if the cb is not on ULONG boundary, we need to pad with zeros (the last ULONG is sufficient)
            *(reinterpret_cast<ULONG *>(pData + cbPaddedSize) - 1) = 0;
        memcpy(pData, aBytes, cb);
        m_iEndOfHeap += cbPaddedSize;

        return (ULONG)(pData - m_pHeap);//return the byte offset of the data from the beginning of the heap
    }

    ULONG   AddItemToHeap(const TBaseHeap &heap)
    {
        return AddItemToHeap(heap.GetHeapPointer(), heap.GetSizeOfHeap());
    }

    ULONG   AddItemToHeap(const T& t)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(&t), sizeof(T));
    }
    ULONG   AddItemToHeap(const T *t, ULONG count)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(t), sizeof(T)*count);
    }
};

//So heaps can be declared without the template syntax we create this specialized template.
//template <> class THeap<ULONG>
//{
//};


//This is a heap that holds strings, byte arrays, guids and any other non-UI4 types.  Items are added to the heap but not removed.
//Like items are pooled together. The second identical string added to the heap, will not result in the second string being
//appended to the end of the heap.  Instead it will return the index the the matching string previously added to the heap.  This
//applies to GUIDs and byte arrays as well.  One other thing, the 0th element is reserved to represent NULL.
class TPooledHeap : public THeap<ULONG>
{
public:
    ULONG   AddItemToHeap(const unsigned char *aBytes, unsigned long cb)
    {
        if(0 == aBytes || 0 == cb)//Are we adding NULL
            return 0;//The 0th index is reserved to represent NULL

        ULONG iHeapItem = FindMatchingHeapEntry(aBytes, cb);
        if(iHeapItem)//if a matching byte array was found, then return the index to the match
            return iHeapItem;

        THeap<ULONG>::AddItemToHeap(cb);//cbSize
        return THeap<ULONG>::AddItemToHeap(aBytes, cb);//return the byte offset of the data from the beginning of the heap
    }
    ULONG   AddItemToHeapWithoutPooling(const unsigned char *aBytes, unsigned long cb)
    {
        if(0 == aBytes || 0 == cb)//Are we adding NULL
            return 0;//The 0th index is reserved to represent NULL

        THeap<ULONG>::AddItemToHeap(cb);//cbSize
        return THeap<ULONG>::AddItemToHeap(aBytes, cb);//return the byte offset of the data from the beginning of the heap
    }

    ULONG   AddItemToHeap(const GUID * pguid)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(pguid), sizeof(GUID));
    }

    ULONG   AddItemToHeap(const GUID &guid)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(&guid), sizeof(GUID));
    }

    ULONG   AddItemToHeap(const TBaseHeap &heap)
    {
        //Another Heap is just stored as an array of bytes
        return AddItemToHeap(heap.GetHeapPointer(), heap.GetSizeOfHeap());
    }

    ULONG   AddItemToHeap(ULONG ul)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(&ul), sizeof(ULONG));
    }

    ULONG   AddItemToHeap(LPCWSTR wsz, unsigned long cwchar=-1)
    {
        if(0==wsz || 0==cwchar)
            return 0;//The 0th index is reserved to represent NULL

        if(cwchar == -1)
            cwchar = (unsigned long)wcslen(wsz)+1;//add one for the terminating NULL
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(wsz), cwchar*2);//convert cwchar to cbchar
    }

    ULONG FindMatchingHeapEntry(const WCHAR *wsz) const
    {
        if(0 == wsz)
            return 0;//0 is reserved to represent NULL
        return FindMatchingHeapEntry(reinterpret_cast<const unsigned char *>(wsz), (ULONG)(sizeof(WCHAR)*(wcslen(wsz)+1)));
    }

    ULONG FindMatchingHeapEntry(const unsigned char *aBytes, unsigned long cb) const
    {
        if(0 == aBytes || 0 == cb)
            return 0;//0 is reserved to represent NULL

        for(const HeapEntry *pHE = reinterpret_cast<const HeapEntry *>(GetHeapPointer()+m_iFirstPooledIndex); IsValidHeapEntry(pHE); pHE = pHE->Next())
        {
            if(pHE->cbSize == cb && 0 == memcmp(pHE->Value, aBytes, cb))
                return (ULONG)(reinterpret_cast<const unsigned char *>(pHE) - GetHeapPointer()) + sizeof(ULONG);//return the bytes offset (from m_pHeap) of the Value (not the HeapEntry)
        }
        //If we make it through the HeapEntries without finding a match then return 0 to indicate 'No Match'
        return 0;
    }
    void SetFirstPooledIndex(ULONG iFirstPooledIndex){m_iFirstPooledIndex = (iFirstPooledIndex>0x1000000) ? 0x1000000 : iFirstPooledIndex;}

    const unsigned char * BytePointerFromIndex(ULONG i)   const {ASSERT(i<GetEndOfHeap()); return ((0 == i || GetEndOfHeap() < i) ? 0 : reinterpret_cast<const unsigned char *>(GetHeapPointer() + i));}
    const GUID          * GuidPointerFromIndex(ULONG i)   const {return reinterpret_cast<const GUID *>(BytePointerFromIndex(i));}
    const WCHAR         * StringPointerFromIndex(ULONG i) const {return reinterpret_cast<const WCHAR *>(BytePointerFromIndex(i));}
    const ULONG         * UlongPointerFromIndex(ULONG i)  const {return reinterpret_cast<const ULONG *>(BytePointerFromIndex(i));}

    ULONG                 GetSizeOfItem(ULONG i)          const {return (0==i) ? 0 : UlongPointerFromIndex(i)[-1];}

    TPooledHeap(ULONG cbInitialSize=0x10) : THeap<ULONG>(cbInitialSize), m_iFirstPooledIndex(0)
    {
        THeap<ULONG>::AddItemToHeap(static_cast<ULONG>(0));
    }//This represents NULL
private:
    struct HeapEntry
    {
        ULONG cbSize;//Size in count of bytes.  Size is the Size of the Value array (NOT including the Size itself).  This is the ACTUAL size of the data (NOT rounded to the nearest ULONG)
        unsigned char Value[1];                                                                                   //cbSize is the actual size so we need to round up to locate the next HeapEntry
        const HeapEntry * Next() const {return reinterpret_cast<const HeapEntry *>(reinterpret_cast<const unsigned char *>(this) + ((cbSize + 3) & -4) + sizeof(ULONG));}//Add sizeof(ULONG) for the cbSize ULONG
    };
    ULONG m_iFirstPooledIndex;

    bool    IsValidHeapEntry(const HeapEntry *pHE) const {return (reinterpret_cast<const unsigned char *>(pHE) >= GetHeapPointer() && reinterpret_cast<const unsigned char *>(pHE) < (GetHeapPointer()+GetEndOfHeap()));}
};




#endif // __THEAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tindexmeta.h ===
#ifndef __TINDEXMETA_H__
#define __TINDEXMETA_H__

#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif

/*
struct IndexMeta
{
    ULONG PRIMARYKEY    Table;                          //String
    ULONG PRIMARYKEY    InternalName;                   //String
    ULONG               PublicName;                     //String
    ULONG PRIMARYKEY    ColumnIndex;                    //UI4       This is the iOrder member of the ColumnMeta
    ULONG               ColumnInternalName;             //String
    ULONG               MetaFlags;                      //UI4       Index Flag
};
*/

class TIndexMeta : public TMetaTable<IndexMeta>
{
public:
    TIndexMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<IndexMeta>(fixup,i){}
    const WCHAR *Get_Table               ()  const {return m_Fixup.StringFromIndex(Get_MetaTable().Table);}
    const WCHAR *Get_InternalName        ()  const {return m_Fixup.StringFromIndex(Get_MetaTable().InternalName);}
    const WCHAR *Get_PublicName          ()  const {return m_Fixup.StringFromIndex(Get_MetaTable().PublicName);}
    const ULONG *Get_ColumnIndex         ()  const {return m_Fixup.UI4pFromIndex(  Get_MetaTable().ColumnIndex);}
    const WCHAR *Get_ColumnInternalName  ()  const {return m_Fixup.StringFromIndex(Get_MetaTable().ColumnInternalName);}
    const ULONG *Get_MetaFlags           ()  const {return m_Fixup.UI4pFromIndex(  Get_MetaTable().MetaFlags);}
    const ULONG  Get_iHashTable          ()  const {return Get_MetaTable().iHashTable;}

    virtual IndexMeta * Get_pMetaTable  ()       {return m_Fixup.IndexMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount      () const {return m_Fixup.GetCountIndexMeta();};
    const IndexMeta & Get_MetaTable () const {return *m_Fixup.IndexMetaFromIndex(m_iCurrent);}
};



#endif // __TINDEXMETA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tpefixup.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "stdafx.h"
#include "XMLUtility.h"

#ifndef __TPEFIXUP_H__
    #include "TPeFixup.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tmetainferrence.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TMETAINFERRENCE_H__
#define __TMETAINFERRENCE_H__


#ifndef __ICOMPILATIONPLUGIN_H__
    #include "ICompilationPlugin.h"
#endif


class TMetaInferrence : public ICompilationPlugin
{
public:
    TMetaInferrence() : m_pFixup(0), m_pOut(0), m_iZero(0){}
    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    static LPCWSTR m_szNameLegalCharacters;
    static LPCWSTR m_szPublicTagLegalCharacters;

    TPEFixup * m_pFixup;
    TOutput  * m_pOut;
    ULONG      m_iZero;

    void ValidateStringAsLegalVariableName(LPCWSTR wszString) const;

    void InferTableMeta_NameColumn_NavColumn(TableMeta *pTableMeta);
    unsigned long InferPublicRowName(unsigned long PublicName);
    void ValidateStringAsLegalVariableName(LPCWSTR wszString, LPCWSTR wszLegalChars=0, bool bAllowNumericFirstCharacter=false);

    void InferDatabaseMeta();
    void InferColumnMeta();
    void InferIndexMeta();
    void InferQueryMeta();
    void InferRelationMeta();//RelationMeta need to come before TableMeta since Inferrence of NameColumn, NvaColumn rely on fCOLUMNMETA_FOREIGNKEY.
    void InferServerWiringMeta();
    void InferTableMeta();
    void InferTagMeta();
};

#endif //__TMETAINFERRENCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tpopulatetableschema.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "stdafx.h"
#include "XMLUtility.h"
#ifndef __TPOPULATETABLESCHEMA_H__
    #include "TPopulateTableSchema.h"
#endif
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif


//The TableSchemaHeap is layed out as follows, the fixed length data comes first
/*
    ULONG           TableSchemaHeapSignature0
    ULONG           TableSchemaHeapSignature1
    ULONG           CountOfTables                       This is interesting only when no query is supplied and we want to walk through every table (this won't be efficient)
    ULONG           TableSchemaRowIndex                 This is the byte offset just beyond the last TableSchema entry.
    ULONG           EndOfHeap                           This is the byte offset just beyond the heap.  All indexes should be less than this
    ULONG           iSimpleColumnMetaHeap               This is described below
    ULONG           Reserved2
    ULONG           Reserved3
    HashTableHeader TableNameHashHeader                 This is the hash table that map a TableID to its aTableSchema byte offset (from the beginning of TableSchemaHeap)
    HashedIndex     aHashedIndex[507]                   The HashTableHeader contains the modulo (503 is the largest prime number less than the hash table size) for the hash table; but the table can never grow beyond this pre-allocated space.
                                                        This size was chosen so that the entire hash table would fit into the same page in memory.
---------------------------<Page Boundary>---------------------------
    unsigned char   aTableSchema[]                      This is where each Table's TableSchema goes.  FirstTableID (4096) == &aTableSchema[0] - &TableSchemaHeap, LastTableID == &aTableSchema[CountOfTables-1] - &TableSchemaHeap
    ULONG           aTableSchemaRowIndex[CountOfTables] This is used to walk ALL of the tables.  Presumably, someone will get all the CollectionMeta and iterate through all of them

---------------------------<SimpleColumnMetaHeap>---------------------
    ULONG           iCollectionMeta                     ULONG index from the beginning of the TableSchemaHeap
    ULONG           cCollectionMeta                     count of SimpleColumnMetas there are for CollectionMeta
    ULONG           iPropertyMeta
    ULONG           cPropertyMeta
    ULONG           iServerWiringMeta
    ULONG           cServerWiringMeta
    ULONG           iTagMeta
    ULONG           cTagMeta
    SimpleColumnMeta aSimpleColumnMeta[cCollectionMeta]
    SimpleColumnMeta aSimpleColumnMeta[cPropertyMeta]
    SimpleColumnMeta aSimpleColumnMeta[cServerWiringMeta]
    SimpleColumnMeta aSimpleColumnMeta[cTagMeta]

One optimization we could do is to make sure that every table's schema (whose size is <=4096) fits into one page.  In other words, minimize TableSchema crossing a page boundary
*/


//This class takes the meta from the old format (TableMeta, ColumnMeta etc.) and puts it into the new format (TableSchema
//which includes CollectionMeta, PropertyMeta etc.)
TPopulateTableSchema::TPopulateTableSchema() : THeap<ULONG>(0x400), m_pFixup(0), m_pOut(0)
{
    memset(m_scmCollectionMeta,   0x00, sizeof(SimpleColumnMeta) * kciTableMetaPublicColumns);
    memset(m_scmPropertyMeta,     0x00, sizeof(SimpleColumnMeta) * kciColumnMetaPublicColumns);
    memset(m_scmServerWiringMeta, 0x00, sizeof(SimpleColumnMeta) * kciServerWiringMetaPublicColumns);
    memset(m_scmTagMeta,          0x00, sizeof(SimpleColumnMeta) * kciTagMetaPublicColumns);
}

void TPopulateTableSchema::Compile(TPEFixup &i_fixup, TOutput &i_out)
{
    m_pFixup    = &i_fixup;
    m_pOut      = &i_out;

    static ULONG aHistogramOfTableSchemaSizesBy16thOfAPage[64];
    static ULONG aHistogramOfTableSchemaMinusHeapSizesBy16thOfAPage[64];
    memset(aHistogramOfTableSchemaSizesBy16thOfAPage, 0x00, sizeof(aHistogramOfTableSchemaSizesBy16thOfAPage));
    memset(aHistogramOfTableSchemaMinusHeapSizesBy16thOfAPage, 0x00, sizeof(aHistogramOfTableSchemaSizesBy16thOfAPage));

    AddItemToHeap(kTableSchemaSignature0);
    AddItemToHeap(kTableSchemaSignature1);

    ULONG CountOfTables = 0;
    ULONG iCountOfTables = AddItemToHeap(CountOfTables);

    TSmartPointerArray<ULONG> aTableSchemaRowIndex = new ULONG[i_fixup.GetCountTableMeta()];//This lookup table gets placed at the end of the heap
    if(0 == aTableSchemaRowIndex.m_p)
    {
        THROW(ERROR - OUTOFMEMORY);
    }

    ULONG TableSchemaRowIndex=0;//We'll fill this in at the end.
    ULONG iTableSchemaRowIndex = AddItemToHeap(TableSchemaRowIndex);//but allocate the space for it here

    ULONG EndOfHeap = 0;//We'll fill this in at the end.
    ULONG iEndOfHeap = AddItemToHeap(EndOfHeap);//but allocate the space for it here

    ULONG iSimpleColumnMetaHeap = 0;
    ULONG iiSimpleColumnMetaHeap = AddItemToHeap(iSimpleColumnMetaHeap);

    ULONG Reserved2 = 0;
    ULONG iReserved2 = AddItemToHeap(Reserved2);

    ULONG Reserved3 = 0;
    ULONG iReserved3 = AddItemToHeap(Reserved3);

    ULONG modulo;
    DetermineHashTableModulo(modulo);
    AddItemToHeap(modulo);//TableNameHashHeader.Modulo
    AddItemToHeap(modulo);//Initial size of the hash table is the same

    TableSchema::HashedIndex aHashedIndex[TableSchema::kMaxHashTableSize];
    AddItemToHeap(reinterpret_cast<const unsigned char *>(aHashedIndex), sizeof(TableSchema::HashedIndex)*TableSchema::kMaxHashTableSize);//The HashTable is uninitialized at this point
    //we'll fill it in as we go through the tables

    //At last count there were 101 columns in CollectionMeta, 4 PropertyMeta, 1 ServerWiringMeta.  So we're going to need at least
    //this much space (assuming the average table has 4 or more columns).
    THeap<ULONG> TableSchemaHeapTemp(i_fixup.GetCountTableMeta() * 101*sizeof(ULONG));//We'll build up this heap, then slam the whole thing into the real TableSchemaHeap (this).

    TTableMeta TableMeta_ColumnMeta         (i_fixup, i_fixup.FindTableBy_TableName(L"COLUMNMETA"));
    TTableMeta TableMeta_ServerWiringMeta   (i_fixup, i_fixup.FindTableBy_TableName(L"SERVERWIRINGMETA"));
    TTableMeta TableMeta_TableMeta          (i_fixup, i_fixup.FindTableBy_TableName(L"TABLEMETA"));
    TTableMeta TableMeta_TagMeta            (i_fixup, i_fixup.FindTableBy_TableName(L"TAGMETA"));

    TTableMeta TableMeta(i_fixup);
    for(unsigned long iTable=0; iTable < i_fixup.GetCountTableMeta(); iTable++, TableMeta.Next())
    {
        if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTABLESCHEMAHEAPENTRY)
            continue;

        ++CountOfTables;

        TPooledHeap PooledHeap;//This is where strings, bytes and guids get pooled

        TableSchema::CollectionMeta collectionmeta;

        //Inferrence rule 2.u.
        TableMeta.Get_pMetaTable()->nTableID = TableIDFromTableName(TableMeta.Get_InternalName());
        if(0 == (TableMeta.Get_pMetaTable()->nTableID & 0xFFFFF800))
        {
            i_out.printf(L"ERROR - Table (%s) cannot be added to the FixedPackedSchema because its TableID is (0x%08x).  Just alter the table name by a character, that should fix the problem.\n"
                        ,TableMeta.Get_InternalName(), TableMeta.Get_pMetaTable()->nTableID);
            THROW(ERROR - TABLEID HAS UPPER 21 BITS AS ZERO);
        }

        FillInThePublicColumns(reinterpret_cast<ULONG *>(&collectionmeta), TableMeta_TableMeta, reinterpret_cast<ULONG *>(TableMeta.Get_pMetaTable()), PooledHeap, m_scmCollectionMeta);
/*
        collectionmeta.Database             = PooledHeap.AddItemToHeap(TableMeta.Get_Database());               //0
        collectionmeta.InternalName         = PooledHeap.AddItemToHeap(TableMeta.Get_InternalName());           //1
        collectionmeta.PublicName           = PooledHeap.AddItemToHeap(TableMeta.Get_PublicName());             //2
        collectionmeta.PublicRowName        = PooledHeap.AddItemToHeap(TableMeta.Get_PublicRowName());          //3
        collectionmeta.BaseVersion          = *TableMeta.Get_BaseVersion();                                     //4
        collectionmeta.ExtendedVersion      = *TableMeta.Get_ExtendedVersion();                                 //5
        collectionmeta.NameColumn           = *TableMeta.Get_NameColumn();                                      //6
        collectionmeta.NavColumn            = *TableMeta.Get_NavColumn();                                       //7
        collectionmeta.MetaFlags            = *TableMeta.Get_MetaFlags();                                       //8
        collectionmeta.SchemaGeneratorFlags = *TableMeta.Get_SchemaGeneratorFlags();                            //9
        collectionmeta.ConfigItemName       = PooledHeap.AddItemToHeap(TableMeta.Get_ConfigItemName());         //10
        collectionmeta.ConfigCollectionName = PooledHeap.AddItemToHeap(TableMeta.Get_ConfigCollectionName());   //11
        collectionmeta.PublicRowNameColumn  = *TableMeta.Get_PublicRowNameColumn();                             //12
        collectionmeta.CountOfProperties    = *TableMeta.Get_CountOfColumns();                                  //13
*/

        collectionmeta.CountOfTags          = 0;//The rest of the CollectionMeta must be calculated later
        collectionmeta.nTableID             = TableMeta.Get_nTableID();
        collectionmeta.iFixedTableRows      = TableMeta.Get_iFixedTable();//This is an index into a heap that the FixedPackInterceptor knows nothing about
        collectionmeta.cFixedTableRows      = TableMeta.Get_ciRows();
        collectionmeta.iIndexMeta           = TableMeta.Get_iIndexMeta();//This is an index into a heap that the FixedPackInterceptor knows nothing about
        collectionmeta.cIndexMeta           = TableMeta.Get_cIndexMeta();
        collectionmeta.iHashTableHeader     = TableMeta.Get_iHashTableHeader();//This is an index into a heap that the FixedPackInterceptor knows nothing about
        collectionmeta.iTagMeta             = sizeof(TableSchema::CollectionMeta) + (collectionmeta.CountOfProperties * sizeof(TableSchema::PropertyMeta));//If there are tags they'll start at this offset (this does NOT imply that there ARE tag, use CountOfTags to determine that)
        collectionmeta.iServerWiring        = 0;//We can't determine this without first figuring out the Tags
        collectionmeta.cServerWiring        = TableMeta.Get_cServerWiring();;
        collectionmeta.iHeap                = 0;//We can't determine this without first figuring out the ServerWiring
        collectionmeta.cbHeap               = 0;

        ULONG TableOffset = AddItemToHeap(reinterpret_cast<const unsigned char *>(&collectionmeta), sizeof(collectionmeta));
        aTableSchemaRowIndex[CountOfTables-1] = TableOffset;//This lookup table gets placed at the end of the heap
        m_pOut->printf(L"Table:%40s    Offset: 0x%08x (%d)\n", reinterpret_cast<LPCWSTR>(PooledHeap.GetHeapPointer()+collectionmeta.InternalName), TableOffset, TableOffset);

        {//These pointers are only valid until the next AddItemToHeap since it may realloc and thus relocate the heap.  So we'll scope them here
            TableSchema::HashedIndex         *pFirstHashedIndex = reinterpret_cast<TableSchema::HashedIndex *>(m_pHeap + 8*sizeof(ULONG) + sizeof(TableSchema::HashTableHeader));
            TableSchema::HashedIndex         *pHashedIndex = const_cast<TableSchema::HashedIndex *>(pFirstHashedIndex + collectionmeta.nTableID%modulo);
            TableSchema::HashTableHeader     *pHashTableHeader = reinterpret_cast<TableSchema::HashTableHeader *>(pFirstHashedIndex - 1);
            ASSERT(pHashTableHeader->Size != ~0);
            ASSERT(pHashTableHeader->Size >= pHashTableHeader->Modulo);
            if(0x0000c664 == TableOffset)//I can't remember why this restriction exists; but Marcel assures me that the catalog doesn't work when this condition is met.
                THROW(ERROR - TABLEOFFSET MAY NOT BE C664 - REARRANGE THE TABLEMETA);
            if(pHashedIndex->iOffset != -1)//If we already seen this hash
            {
                while(pHashedIndex->iNext != -1)//follow the chain of duplicate hashes
                {
                    //We need to make sure that tables with the same TableID%modulo don't actually match TableIDs.
                    //We DON'T need to do a string compare, however, since like strings should equal like TableIDs.
                    TableSchema::TTableSchema OtherTable;
                    OtherTable.Init(m_pHeap + pHashedIndex->iOffset);
                    if(OtherTable.GetCollectionMeta()->nTableID == collectionmeta.nTableID)
                    {
                        m_pOut->printf(L"Error!  TableID collision between tables %s & %s.  You have either used a duplicate table name (remember table names are case-insensitive) OR it is also remotely possible that two tables with unlike table name CAN result in the same TableID (this is VERY rare).",
                            OtherTable.GetPointerFromIndex(OtherTable.GetCollectionMeta()->InternalName), TableMeta.Get_InternalName());
                        THROW(TableID collision);
                    }
                    
                    pHashedIndex = pFirstHashedIndex + pHashedIndex->iNext;
                }
                pHashedIndex->iNext = pHashTableHeader->Size;
                pHashedIndex = pFirstHashedIndex + pHashTableHeader->Size;
                ++pHashTableHeader->Size;
            }
            //iNext should already be initialized to -1
            ASSERT(pHashedIndex->iNext == -1);
            ASSERT(pHashedIndex->iOffset == -1);

            pHashedIndex->iOffset = TableOffset;
        }
        TSmartPointerArray<TableSchema::PropertyMeta> aPropertyMeta = new TableSchema::PropertyMeta [collectionmeta.CountOfProperties];
        if(0 == aPropertyMeta.m_p)
            THROW(OUT OF MEMORY);

        TColumnMeta ColumnMeta(i_fixup, TableMeta.Get_iColumnMeta());

        ULONG iTagMeta = collectionmeta.iTagMeta;
        for(unsigned long iProperty=0; iProperty < collectionmeta.CountOfProperties; ++iProperty, ColumnMeta.Next())
        {
            FillInThePublicColumns(reinterpret_cast<ULONG *>(&aPropertyMeta[iProperty]), TableMeta_ColumnMeta, reinterpret_cast<ULONG *>(ColumnMeta.Get_pMetaTable()), PooledHeap, m_scmPropertyMeta);
/*
            aPropertyMeta[iProperty].Table                = collectionmeta.InternalName;
            aPropertyMeta[iProperty].Index                = *ColumnMeta.Get_Index();
            aPropertyMeta[iProperty].InternalName         = PooledHeap.AddItemToHeap(ColumnMeta.Get_InternalName());
            aPropertyMeta[iProperty].PublicName           = PooledHeap.AddItemToHeap(ColumnMeta.Get_PublicName());
            aPropertyMeta[iProperty].Type                 = *ColumnMeta.Get_Type();
            aPropertyMeta[iProperty].Size                 = *ColumnMeta.Get_Size();
            aPropertyMeta[iProperty].MetaFlags            = *ColumnMeta.Get_MetaFlags();
            aPropertyMeta[iProperty].DefaultValue         = PooledHeap.AddItemToHeap(ColumnMeta.Get_DefaultValue(), ColumnMeta.Get_DefaultValue() ? *(reinterpret_cast<const ULONG *>(ColumnMeta.Get_DefaultValue())-1) : 0);
            aPropertyMeta[iProperty].FlagMask             = *ColumnMeta.Get_FlagMask();
            aPropertyMeta[iProperty].StartingNumber       = *ColumnMeta.Get_StartingNumber();
            aPropertyMeta[iProperty].EndingNumber         = *ColumnMeta.Get_EndingNumber();
            aPropertyMeta[iProperty].CharacterSet         = PooledHeap.AddItemToHeap(ColumnMeta.Get_CharacterSet());
            aPropertyMeta[iProperty].SchemaGeneratorFlags = *ColumnMeta.Get_SchemaGeneratorFlags();
*/
            aPropertyMeta[iProperty].CountOfTags          = ColumnMeta.Get_ciTagMeta();
            aPropertyMeta[iProperty].iTagMeta             = aPropertyMeta[iProperty].CountOfTags ? iTagMeta : 0;
            aPropertyMeta[iProperty].iIndexName           = PooledHeap.AddItemToHeap(ColumnMeta.Get_iIndexName());

            //If there are other tags they'll start at iTagMeta
            iTagMeta += sizeof(TableSchema::TagMeta)*aPropertyMeta[iProperty].CountOfTags;

            //Total up the Tag count for the whole table
            collectionmeta.CountOfTags += aPropertyMeta[iProperty].CountOfTags;
        }
        if(collectionmeta.CountOfProperties)//Memory table has no Properties
            AddItemToHeap(reinterpret_cast<const unsigned char *>(aPropertyMeta.m_p), collectionmeta.CountOfProperties * sizeof(TableSchema::PropertyMeta));

        {//OK now we ca fixup the collectionmeta.CountOfTags already added to the heap.
            //Also, we know where the ServerWiring starts
            //Again pCollection is only valid 'til we call AddItemToHeap, so scope it here.
            TableSchema::CollectionMeta *pCollection = reinterpret_cast<TableSchema::CollectionMeta *>(m_pHeap + TableOffset);
            pCollection->CountOfTags    = collectionmeta.CountOfTags;
            pCollection->iServerWiring  = collectionmeta.iTagMeta + sizeof(TableSchema::TagMeta)*collectionmeta.CountOfTags;
            pCollection->iHeap          = pCollection->iServerWiring + sizeof(TableSchema::ServerWiringMeta)*collectionmeta.cServerWiring;
            //Now the only thing that needs to be filled in the collectionmeta is the cbHeap, which we won't know until we add the ServerWiring
        }

        if(collectionmeta.CountOfTags)
        {
            TSmartPointerArray<TableSchema::TagMeta> aTagMeta = new TableSchema::TagMeta [collectionmeta.CountOfTags];
            if(0 == aTagMeta.m_p)
                THROW(OUT OF MEMORY);

            ColumnMeta.Reset();
            for(iProperty=0; iProperty < collectionmeta.CountOfProperties; ++iProperty, ColumnMeta.Next())
            {
                if(0 != ColumnMeta.Get_ciTagMeta())
                    break;
            }

            TTagMeta    TagMeta(i_fixup, ColumnMeta.Get_iTagMeta());//Walk all the tags for the table (NOT just the column)
            for(ULONG iTag=0; iTag<collectionmeta.CountOfTags; ++iTag, TagMeta.Next())
            {
                FillInThePublicColumns(reinterpret_cast<ULONG *>(&aTagMeta[iTag]), TableMeta_TagMeta, reinterpret_cast<ULONG *>(TagMeta.Get_pMetaTable()), PooledHeap, m_scmTagMeta);
/*
                aTagMeta[iTag].Table            = PooledHeap.AddItemToHeap(TagMeta.Get_Table());
                aTagMeta[iTag].ColumnIndex      = *TagMeta.Get_ColumnIndex();
                aTagMeta[iTag].InternalName     = PooledHeap.AddItemToHeap(TagMeta.Get_InternalName());
                aTagMeta[iTag].PublicName       = PooledHeap.AddItemToHeap(TagMeta.Get_PublicName());
                aTagMeta[iTag].Value            = *TagMeta.Get_Value();
*/
            }
            AddItemToHeap(reinterpret_cast<const unsigned char *>(aTagMeta.m_p), collectionmeta.CountOfTags * sizeof(TableSchema::TagMeta));
        }

        //ServerWiring
        collectionmeta.cServerWiring = TableMeta.Get_cServerWiring();
        if(0!=wcscmp(L"MEMORY_SHAPEABLE", TableMeta.Get_InternalName()))//memory table has no ServerWiring
        {
            ASSERT(collectionmeta.cServerWiring>0);//There must be at least one ServerWiringMeta
        }
        
        TSmartPointerArray<TableSchema::ServerWiringMeta> aServerWiring = new TableSchema::ServerWiringMeta [TableMeta.Get_cServerWiring()];
        if(0 == aServerWiring.m_p)
            THROW(OUT OF MEMORY);

        ServerWiringMeta *pServerWiring = i_fixup.ServerWiringMetaFromIndex(TableMeta.Get_iServerWiring());
        for(ULONG iServerWiring=0; iServerWiring<TableMeta.Get_cServerWiring(); ++iServerWiring, ++pServerWiring)
        {
            FillInThePublicColumns(reinterpret_cast<ULONG *>(&aServerWiring[iServerWiring]), TableMeta_ServerWiringMeta, reinterpret_cast<ULONG *>(pServerWiring), PooledHeap, m_scmServerWiringMeta);
/*
            aServerWiring[iServerWiring].Table          = PooledHeap.AddItemToHeap(i_fixup.StringFromIndex(pServerWiring->Table));
            aServerWiring[iServerWiring].Order          = i_fixup.UI4FromIndex(pServerWiring->Order);
            aServerWiring[iServerWiring].ReadPlugin     = i_fixup.UI4FromIndex(pServerWiring->ReadPlugin);
            aServerWiring[iServerWiring].WritePlugin    = i_fixup.UI4FromIndex(pServerWiring->WritePlugin);
            aServerWiring[iServerWiring].Interceptor    = i_fixup.UI4FromIndex(pServerWiring->Interceptor);
            aServerWiring[iServerWiring].DLLName        = PooledHeap.AddItemToHeap(i_fixup.StringFromIndex(pServerWiring->DLLName));
            aServerWiring[iServerWiring].Flags          = i_fixup.UI4FromIndex(pServerWiring->Flags);
            aServerWiring[iServerWiring].Locator        = PooledHeap.AddItemToHeap(i_fixup.StringFromIndex(pServerWiring->Locator));
*/
        }
        AddItemToHeap(reinterpret_cast<const unsigned char *>(aServerWiring.m_p), TableMeta.Get_cServerWiring() * sizeof(TableSchema::ServerWiringMeta));
        ULONG iPooledHeap = AddItemToHeap(PooledHeap);//Now add the PooledHeap (which contains all the Strings, Byte arrays and Guids)

        {//Only now do we know how big the table's PooledHeap is
            TableSchema::CollectionMeta *pCollection = reinterpret_cast<TableSchema::CollectionMeta *>(m_pHeap + TableOffset);
            pCollection->cbHeap = PooledHeap.GetSizeOfHeap();
        }

        ULONG TableSize = GetEndOfHeap() - TableOffset;
        ULONG TableSizeMinusPooledHeap = TableSize - (GetEndOfHeap()-iPooledHeap);
        ++aHistogramOfTableSchemaSizesBy16thOfAPage[(TableSize/0x100)%64];
        ++aHistogramOfTableSchemaMinusHeapSizesBy16thOfAPage[(TableSizeMinusPooledHeap/0x100)%64];
    }
    //TableSchemaRowIndex helps us verify that indexes are in the correct range.
    //This is also where the TableSchemaRowIndex array belongs.  It is used to iterate through the tables aka. CollectionMeta
    TableSchemaRowIndex = AddItemToHeap(reinterpret_cast<const unsigned char *>(aTableSchemaRowIndex.m_p), CountOfTables * sizeof(ULONG));
    *reinterpret_cast<ULONG *>(const_cast<unsigned char *>(GetHeapPointer()+iTableSchemaRowIndex)) = TableSchemaRowIndex;

    iSimpleColumnMetaHeap = AddSimpleColumnMetaHeap();
    *reinterpret_cast<ULONG *>(const_cast<unsigned char *>(GetHeapPointer()+iiSimpleColumnMetaHeap)) = iSimpleColumnMetaHeap;
    
    //This is always the last thing we do is take stock of the Heap's size
    EndOfHeap = GetEndOfHeap();
    *reinterpret_cast<ULONG *>(const_cast<unsigned char *>(GetHeapPointer()+iEndOfHeap)) = EndOfHeap;

    TDebugOutput debug;
    debug.printf(L"\nHistogram of TableSchema sizes\n");
    ULONG iSize;
    for(iSize=0;iSize<64;++iSize)
    {
        debug.printf(L"%6d - %6d (bytes)    %3d\n", iSize*0x100, (iSize+1)*0x100, aHistogramOfTableSchemaSizesBy16thOfAPage[iSize]);
    }
    debug.printf(L"\n\nHistogram of TableSchema sizes (not including the PooledHeap)\n");
    for(iSize=0;iSize<64;++iSize)
    {
        debug.printf(L"%6d - %6d (bytes)    %3d\n", iSize*0x100, (iSize+1)*0x100, aHistogramOfTableSchemaMinusHeapSizesBy16thOfAPage[iSize]);
    }
    ULONG iULong = i_fixup.AddULongToList(GetTypedPointer(), GetCountOfTypedItems());
    ASSERT(0 == iULong && "FixedPackedSchema needs to be at the beginning of the ULONG pool so that it's page aligned");
}

//Private methods
ULONG TPopulateTableSchema::AddSimpleColumnMetaHeap()
{
    /*SimpleColumnMetaHeap
    ULONG           iCollectionMeta
    ULONG           cCollectionMeta
    ULONG           iPropertyMeta
    ULONG           cPropertyMeta
    ULONG           iServerWiringMeta
    ULONG           cServerWiringMeta
    ULONG           iTagMeta
    ULONG           cTagMeta
    SimpleColumnMeta aSimpleColumnMeta[cCollectionMeta]
    SimpleColumnMeta aSimpleColumnMeta[cPropertyMeta]
    SimpleColumnMeta aSimpleColumnMeta[cServerWiringMeta]
    SimpleColumnMeta aSimpleColumnMeta[cTagMeta]
    */

    //SimpleColumnMeta is 3 ULONGs
    TTableMeta TableMeta_ColumnMeta         (*m_pFixup, m_pFixup->FindTableBy_TableName(L"COLUMNMETA"));
    TTableMeta TableMeta_ServerWiringMeta   (*m_pFixup, m_pFixup->FindTableBy_TableName(L"SERVERWIRINGMETA"));
    TTableMeta TableMeta_TableMeta          (*m_pFixup, m_pFixup->FindTableBy_TableName(L"TABLEMETA"));
    TTableMeta TableMeta_TagMeta            (*m_pFixup, m_pFixup->FindTableBy_TableName(L"TAGMETA"));

    ULONG i = 8L;
    ULONG iSimpleColumnMetaHeap = AddItemToHeap(i);
    AddItemToHeap(*TableMeta_TableMeta.Get_CountOfColumns());
    i += *TableMeta_TableMeta.Get_CountOfColumns() * (sizeof(SimpleColumnMeta)/sizeof(ULONG));

    AddItemToHeap(i);
    AddItemToHeap(*TableMeta_ColumnMeta.Get_CountOfColumns());
    i += *TableMeta_ColumnMeta.Get_CountOfColumns() * (sizeof(SimpleColumnMeta)/sizeof(ULONG));

    AddItemToHeap(i);
    AddItemToHeap(*TableMeta_ServerWiringMeta.Get_CountOfColumns());
    i += *TableMeta_ServerWiringMeta.Get_CountOfColumns() * (sizeof(SimpleColumnMeta)/sizeof(ULONG));

    AddItemToHeap(i);
    AddItemToHeap(*TableMeta_TagMeta.Get_CountOfColumns());

    AddItemToHeap(reinterpret_cast<const unsigned char *>(m_scmCollectionMeta), (*TableMeta_TableMeta.Get_CountOfColumns()) * sizeof(SimpleColumnMeta));
    AddItemToHeap(reinterpret_cast<const unsigned char *>(m_scmPropertyMeta), (*TableMeta_ColumnMeta.Get_CountOfColumns()) * sizeof(SimpleColumnMeta));
    AddItemToHeap(reinterpret_cast<const unsigned char *>(m_scmServerWiringMeta), (*TableMeta_ServerWiringMeta.Get_CountOfColumns()) * sizeof(SimpleColumnMeta));
    AddItemToHeap(reinterpret_cast<const unsigned char *>(m_scmTagMeta), (*TableMeta_TagMeta.Get_CountOfColumns()) * sizeof(SimpleColumnMeta));

    return iSimpleColumnMetaHeap;
}

//This doesn't actually fill in the hash table, it just determines whether the tables will fit into the hashtable and what the modulo is.
void TPopulateTableSchema::DetermineHashTableModulo(ULONG &modulo) const
{
    TableSchema::HashedIndex         hashedindex;
    TableSchema::HashedIndex         aHashedIndex[TableSchema::kMaxHashTableSize];

    TableSchema::HashTableHeader    &hashtableheader = *reinterpret_cast<TableSchema::HashTableHeader *>(&hashedindex);

    //Walk the tables and fillin the HashTable trying each of the prime numbers as a modulo
    const ULONG kPrime[]={503,499,491,487,479,467,463,461,457,449,443,439,433,431,421,419,409,401,397,389,383,379,373,367,359,353,349,347,337,331,317,313,311,307,0};

    ULONG CountOfTables = m_pFixup->GetCountTableMeta();

    ULONG iPrime=0;
    for(; kPrime[iPrime]; ++iPrime)
    {
        if(kPrime[iPrime] > TableSchema::kMaxHashTableSize)
            continue;//a valid modulo MUST be less than or equal to the size of the hash table

        hashtableheader.Modulo  = kPrime[iPrime];
        hashtableheader.Size    = hashtableheader.Modulo;//The initial size is the same as the prime number, the overflow go into the slots at the end (up to kMaxHashTableSize since that's the static FIXED size of the buffer)

        memset(aHashedIndex, -1, sizeof(TableSchema::HashedIndex) * TableSchema::kMaxHashTableSize);//Must initialize to -1

        TTableMeta TableMeta(*m_pFixup);
        unsigned long iTable=0;
        for(; iTable<CountOfTables && hashtableheader.Size<=TableSchema::kMaxHashTableSize; iTable++, TableMeta.Next())
        {
            if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTABLESCHEMAHEAPENTRY)
                continue;

            TableSchema::HashedIndex *pHashedIndex = aHashedIndex + (TableMeta.Get_nTableID()%hashtableheader.Modulo);
            if(-1 != pHashedIndex->iOffset)
                ++hashtableheader.Size;

            ++pHashedIndex->iOffset;//Increment so we can track not only how many dups there are but how deep the links go (for now I don't care, as long as the hash table fits)
        }
        if(iTable==CountOfTables && hashtableheader.Size<=TableSchema::kMaxHashTableSize)
        {
            modulo = hashtableheader.Modulo;//Set this back to the Modulo so when we build the HashTable we know where to start filling in the overflow buckets
            m_pOut->printf(L"TableSchemaHeap modulo is %d\n", modulo);
            return;//if we made it through the list, we're good to go.
        }
    }
    m_pOut->printf(L"Cannot generate TableID hash table.  There must be alot of tables or something, 'cause this shouldn't happen.");
    THROW(Unable to generate TableID hash table);
}

void TPopulateTableSchema::FillInThePublicColumns(ULONG * o_dest, TTableMeta &i_tablemeta, ULONG * i_source, TPooledHeap &pooledHeap, SimpleColumnMeta *o_pSimpleColumnMeta)
{
    TColumnMeta columnmeta(*m_pFixup, i_tablemeta.Get_iColumnMeta());
    for(ULONG i=0;i<*i_tablemeta.Get_CountOfColumns();++i, columnmeta.Next())
    {
        if(0 == o_pSimpleColumnMeta[i].dbType)
        {
            o_pSimpleColumnMeta[i].dbType = *columnmeta.Get_Type();
            o_pSimpleColumnMeta[i].cbSize = *columnmeta.Get_Size();
            o_pSimpleColumnMeta[i].fMeta  = *columnmeta.Get_MetaFlags();
        }

        switch(*columnmeta.Get_Type())
        {
        case DBTYPE_UI4:
            if(0 == i_source[i])
            {
                m_pOut->printf(L"Error - Table(%s), Column(%d) - NULL not supported for meta UI4 columns\n", i_tablemeta.Get_InternalName(), i);
                THROW(ERROR - NULL UI4 VALUE IN META TABLE);
            }
            else
            {
                o_dest[i] = m_pFixup->UI4FromIndex(i_source[i]);
            }
            break;
        case DBTYPE_BYTES:
        case DBTYPE_WSTR:
            if(0 == i_source[i])
                o_dest[i] = 0;
            else            //Add the item to the local pool
                o_dest[i] = pooledHeap.AddItemToHeap(m_pFixup->ByteFromIndex(i_source[i]), m_pFixup->BufferLengthFromIndex(i_source[i]));
            break;
        case DBTYPE_DBTIMESTAMP:
        default:
            m_pOut->printf(L"Error - Unsupported Type (%d)\n", *columnmeta.Get_Type());
            THROW(ERROR - UNSUPPORTED TYPE);
            break;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tmetainferrence.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "stdafx.h"
#include "XMLUtility.h"

LPCWSTR TMetaInferrence::m_szNameLegalCharacters =L"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
LPCWSTR TMetaInferrence::m_szPublicTagLegalCharacters  =L"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789[]";

void TMetaInferrence::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup    = &fixup;
    m_pOut      = &out;

    m_iZero = m_pFixup->AddUI4ToList(0);//we need this all over the place so add it here then use the index where needed

    //Ordering here is important since TableMeta sets some flags according to how the ColumnMeta flags are set; but some ColumnMeta flags are inferred.
    InferTagMeta();
    InferColumnMeta();
    InferQueryMeta();
    InferIndexMeta();
    InferRelationMeta();
    InferServerWiringMeta();
    InferTableMeta();
    InferDatabaseMeta();
}

void TMetaInferrence::InferColumnMeta()
{
    //CompositeOfMetaFlags is used if at least one PK is declared per table, and to verify that no more than one NameColumn
    //and no more than one NavColumn are declared per table.
    ULONG CompositeOfMetaFlags=(fCOLUMNMETA_PRIMARYKEY | fCOLUMNMETA_NAMECOLUMN | fCOLUMNMETA_NAVCOLUMN);
    ULONG CompositeOfSchemaGeneratorFlags=(fCOLUMNMETA_USEASPUBLICROWNAME);
    ULONG PreviousTable=0;


    for(unsigned long iColumnMeta=0; iColumnMeta<m_pFixup->GetCountColumnMeta(); ++iColumnMeta)
    {
        ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);

        //Inference Rule 3.a.i.
            //The TableMeta.InternalName of the parent XML element determines Table to which the column belongs.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pColumnMeta->Table);


        //Inference Rule 3.b.i.
            //The first ColumnMeta element encountered under each table is set to Index 0.  Each successive ColumnMeta element has an Index value one greater than the previous ColumnMeta.Index.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pColumnMeta->Index);


        //Inference Rule 3.c.i.
            //ColumnMeta.InternalName is a primary key so it must not be NULL.
        if(0 == pColumnMeta->InternalName)
        {
            m_pOut->printf(L"Validation Error in ColumnMeta for Table (%s). ColumnMeta.InternalName is a primarykey, so it must not be NULL.", m_pFixup->StringFromIndex(pColumnMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 3.c.ii.
            //ColumnMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pColumnMeta->InternalName));


        //Inference Rule 3.d.i.
            //ColumnMeta PublicName is set to be the same as the ColumnMeta.InternalName if one is not supplied.
        if(0 == pColumnMeta->PublicName)
        {
            pColumnMeta->PublicName = pColumnMeta->InternalName;
        }
        else
        {
            //Inference Rule 3.d.ii.
                //ColumnMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pColumnMeta->PublicName));
        }


        //Inference Rule 3.e.i.
            //Type is specified as a string and is mapped according to its TagMeta.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pColumnMeta->Type);


        //Inference Rule 3.f.i.
            //Size is defaulted to -1 if the ColumnMeta.Type is DBTYPE_STRING or DBTYPE_BYTES (or equivalent) and no Size is supplied.
        ASSERT(0 != pColumnMeta->Size);//There is a mapping that is handled at XML read time that deals with this

        //Inference Rule 3.g.i.1 - Also See Below
            //fCOLUMNMETA_PRIMARYKEY  must be set on at least one column per table.
        if(PreviousTable != pColumnMeta->Table)
        {
            if(0 == (CompositeOfMetaFlags & fCOLUMNMETA_PRIMARYKEY))
            {
                m_pOut->printf(L"Error - Table (%s) has no primarykey.  fCOLUMNMETA_PRIMARYKEY must be set on at least one column per table", m_pFixup->StringFromIndex(PreviousTable));
                THROW(ERROR - VALIDATION ERROR);
            }
            CompositeOfMetaFlags = 0;//We scanning a new table so start with no flags set
            CompositeOfSchemaGeneratorFlags = 0;
        }

        //Inference Rule 3.g.ii.1  - This is handled in RelationMeta inferrence
            //fCOLUMNMETA_FOREIGNKEY  is set when the table is listed as a RelationMeta.ForeignTable and the column is listed as one of the RelationMeta.ForeignColumns.


        //Inference Rule 3.g.iii.1 
            //Only one NameColumn may be specified per table.
        ULONG MetaFlags = m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags);
        if((MetaFlags & fCOLUMNMETA_NAMECOLUMN) && (CompositeOfMetaFlags & fCOLUMNMETA_NAMECOLUMN))
        {
            m_pOut->printf(L"Error - Table (%s) has more than one NameColumn", m_pFixup->StringFromIndex(pColumnMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.g.iv.1 
            //Only one NavColumn may be specified per table.
        if((MetaFlags & fCOLUMNMETA_NAVCOLUMN) && (CompositeOfMetaFlags & fCOLUMNMETA_NAVCOLUMN))
        {
            m_pOut->printf(L"Error - Table (%s) has more than one NavColumn", m_pFixup->StringFromIndex(pColumnMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.g.vi.1 
            //fCOLUMNMETA_ FLAG must only be set if the ColumnMeta.Type is DBTYPE_UI4 or DWORD_METADATA.
        if((MetaFlags & fCOLUMNMETA_FLAG) && m_pFixup->UI4FromIndex(pColumnMeta->Type)!=static_cast<ULONG>(DBTYPE_UI4) && m_pFixup->UI4FromIndex(pColumnMeta->Type)!=static_cast<ULONG>(DWORD_METADATA))
        {
            m_pOut->printf(L"Error - Table (%s) Column (%s) - fCOLUMNMETA_FLAG must only be set on UI4 columns", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.g.vii.1 
            //fCOLUMNMETA_ ENUM must only be set if the ColumnMeta.Type is DBTYPE_UI4 or DWORD_METADATA.
        if((MetaFlags & fCOLUMNMETA_ENUM) && m_pFixup->UI4FromIndex(pColumnMeta->Type)!=static_cast<ULONG>(DBTYPE_UI4) && m_pFixup->UI4FromIndex(pColumnMeta->Type)!=static_cast<ULONG>(DWORD_METADATA))
        {
            m_pOut->printf(L"Error - Table (%s) Column (%s) - fCOLUMNMETA_ENUM must only be set on UI4 columns", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.g.xx.1 
            //fCOLUMNMETA_NOTNULLABLE is set if fCOLUMNMETA_PRIMARYKEY is set.
        if(MetaFlags & fCOLUMNMETA_PRIMARYKEY)
            MetaFlags |= fCOLUMNMETA_NOTNULLABLE;

        //Inference Rule 3.g.xxviii.1
            //fCOLUMNMETA_UNKNOWNSIZE bit is set when ColumnMeta.Type is BYTES and ColumnMeta.Size is -1.
        if(m_pFixup->UI4FromIndex(pColumnMeta->Size)==-1 && (m_pFixup->UI4FromIndex(pColumnMeta->Type)==DBTYPE_BYTES || m_pFixup->UI4FromIndex(pColumnMeta->Type)==BINARY_METADATA))
            MetaFlags |= fCOLUMNMETA_UNKNOWNSIZE;


        //Inference Rule 3.g.xxi.1 
            //fCOLUMNMETA_FIXEDLENGTH is set if Size it not -1
        if(-1 != m_pFixup->UI4FromIndex(pColumnMeta->Size))
            MetaFlags |= fCOLUMNMETA_FIXEDLENGTH;


        //Inference Rule 3.j.i.1 
            //ColumnMeta.StartingNumber is defaulted to 0 if none is supplied.
        if(0 == pColumnMeta->StartingNumber)
            pColumnMeta->StartingNumber = m_iZero;


        //Inference Rule 3.k.i.1 
            //ColumnMeta.EndingNumber is defaulted to 0xFFFFFFFF if none is supplied.
        if(0 == pColumnMeta->EndingNumber)
            pColumnMeta->EndingNumber = m_pFixup->AddUI4ToList(-1);


        //Inference Rule 3.g.xxii.1 
            //fCOLUMNMETA_HASNUMERICRANGE is set if the Type is UI4 and, StartingNumber is not 0 or EndingNumber is not 0xFFFFFFFF.
        if( ((m_pFixup->UI4FromIndex(pColumnMeta->Type) == DBTYPE_UI4 || m_pFixup->UI4FromIndex(pColumnMeta->Type) == DWORD_METADATA)) &&
            ((m_pFixup->UI4FromIndex(pColumnMeta->StartingNumber)!=0   || m_pFixup->UI4FromIndex(pColumnMeta->EndingNumber)!=-1)))
            MetaFlags |= fCOLUMNMETA_HASNUMERICRANGE;


        //Inference Rule 3.g.xxix.1
            //fCOLUMNMETA_VARIABLESIZE bit is set when fCOLUMNMETA_FIXEDLENGTH is not set.
        if(0 == (fCOLUMNMETA_FIXEDLENGTH & MetaFlags))
            MetaFlags |= fCOLUMNMETA_VARIABLESIZE;



        //Inference Rule 3.i.i - See Below
            //FlagMask is the ORing of all of the TagMeta when fCOLUMNMETA_FLAG is set.  Otherwise it is defaulted to 0.
        //Inference Rule 3.j.i.1 - See Above
            //ColumnMeta.StartingNumber is defaulted to 0 if none is supplied.
        //Inference Rule 3.k.i.1 - See Above
            //ColumnMeta.EndingNumber is defaulted to 0xFFFFFFFF if none is supplied.



        //Inference Rule 3.m.i.1
            //fCOLUMNMETA_USEASPUBLICROWNAME should only be set on column whose MetaFlags fCOLUMNMETA_ENUM bit is set.
        ASSERT(0 != pColumnMeta->SchemaGeneratorFlags);
        if((m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags)&fCOLUMNMETA_USEASPUBLICROWNAME) &&
            0==(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags)&fCOLUMNMETA_ENUM))
        {
            m_pOut->printf(L"Error - Table (%s) - USEASPUBLICROWNAME was set on a non ENUM Column (%s)", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        ULONG SchemaGeneratorFlags = m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags);
        //Inference Rule 3.m.i.2
            //Only one column can be marked as fCOLUMNMETA_USEASPUBLICROWNAME
        if((SchemaGeneratorFlags & fCOLUMNMETA_USEASPUBLICROWNAME) && (CompositeOfSchemaGeneratorFlags & fCOLUMNMETA_USEASPUBLICROWNAME))
        {
            m_pOut->printf(L"Error - Table (%s) has more than one PublicRowNameColumn", m_pFixup->StringFromIndex(pColumnMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.m.xi.2
            //XMLBLOB columns may not also be marked as PRIMARYKEY or NOTPERSISTABLE
        if((SchemaGeneratorFlags & fCOLUMNMETA_XMLBLOB) && (MetaFlags & fCOLUMNMETA_PRIMARYKEY))
        {
            m_pOut->printf(L"Error - Table (%s) has XMLBLOB column (%s) marked as the PrimaryKey", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }



        //Inference Rule 3.n.i
            //ciTagMeta is the count of TagMeta whose Table equals ColumnMeta.Table.
        //Inference Rule 3.o.i
            //iTagMeta is an index to the first TagMeta whose Table equals ColumnMeta.Table and whose ColumnIndex equals ColumnMeta.Index.  Or zero if no tags exist for this column.
        pColumnMeta->iTagMeta   = 0;
        pColumnMeta->ciTagMeta  = 0;
        pColumnMeta->FlagMask   = m_iZero;
        if(MetaFlags & (fCOLUMNMETA_ENUM | fCOLUMNMETA_FLAG))
        {
            //Inference Rule 3.o.i
                //iTagMeta is an index to the first TagMeta whose Table equals ColumnMeta.Table and whose ColumnIndex equals ColumnMeta.Index.  Or zero if no tags exist for this column.
            for(pColumnMeta->iTagMeta = 0;pColumnMeta->iTagMeta<m_pFixup->GetCountTagMeta();++pColumnMeta->iTagMeta)
            {
                if( m_pFixup->TagMetaFromIndex(pColumnMeta->iTagMeta)->Table == pColumnMeta->Table &&
                    m_pFixup->TagMetaFromIndex(pColumnMeta->iTagMeta)->ColumnIndex == pColumnMeta->Index)
                    break;
            }
            if(pColumnMeta->iTagMeta==m_pFixup->GetCountTagMeta())
            {
                m_pOut->printf(L"Error - Table (%s) - No TagMeta found for Column (%s)", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                THROW(ERROR - VALIDATION ERROR);
            }

            //Inference Rule 3.n.i
                //ciTagMeta is the count of TagMeta whose Table equals ColumnMeta.Table and whose ColumnIndex equals ColumnMeta.Index.
            ULONG iTagMeta = pColumnMeta->iTagMeta;
            ULONG FlagMask = 0;
            for(;iTagMeta<m_pFixup->GetCountTagMeta()
                && m_pFixup->TagMetaFromIndex(iTagMeta)->Table == pColumnMeta->Table
                && m_pFixup->TagMetaFromIndex(iTagMeta)->ColumnIndex == pColumnMeta->Index;++iTagMeta, ++pColumnMeta->ciTagMeta)
                FlagMask |= m_pFixup->UI4FromIndex(m_pFixup->TagMetaFromIndex(iTagMeta)->Value);

            //Inference Rule 3.i.i - See Above for defaulting to 0
                //FlagMask is the ORing of all of the TagMeta when fCOLUMNMETA_FLAG is set.  Otherwise it is defaulted to 0.
            if(MetaFlags & fCOLUMNMETA_FLAG)
                pColumnMeta->FlagMask = m_pFixup->AddUI4ToList(FlagMask);
        }


        pColumnMeta->MetaFlags = m_pFixup->AddUI4ToList(MetaFlags);

        CompositeOfMetaFlags |= MetaFlags;
        CompositeOfSchemaGeneratorFlags |= SchemaGeneratorFlags;
        PreviousTable = pColumnMeta->Table;

        //Inference Rule 3.q
        if(0 == pColumnMeta->ID)
            pColumnMeta->ID = m_iZero;
        //Inference Rule 3.r
        if(0 == pColumnMeta->UserType)
            pColumnMeta->UserType = m_iZero;
        //Inference Rule 3.s
        ASSERT(0 != pColumnMeta->Attributes);//Attributes is a flag and should already be defaulted to zero

		//Inference Rule 3.t.i.
		// PublicColumnName is same as PublicName if not specified
		if(0 == pColumnMeta->PublicColumnName)
		{
			pColumnMeta->PublicColumnName = pColumnMeta->PublicName;
		}
		else
		{
			//Inference Rule 3.t.ii.
			//ColumnMeta.PublicColumnName should be validated to be a legal C++ variable name.
			ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pColumnMeta->PublicColumnName));
		}
    }

    //Inference Rule 3.g.i.1.
        //fCOLUMNMETA_PRIMARYKEY  must be set on at least one column per table.
    //The last table in the ColumnMeta list will exit the for loop before we get to check this.  So check it now.
    if(0 == (CompositeOfMetaFlags & fCOLUMNMETA_PRIMARYKEY))
    {
        m_pOut->printf(L"Error - Table (%s) has no primarykey.  fCOLUMNMETA_PRIMARYKEY must be set on at least one column per table", m_pFixup->StringFromIndex(m_pFixup->ColumnMetaFromIndex(PreviousTable)->Table));
        THROW(ERROR - VALIDATION ERROR);
    }

}


void TMetaInferrence::InferDatabaseMeta()
{
    for(unsigned long i=0; i<m_pFixup->GetCountDatabaseMeta(); ++i)
    {
        DatabaseMeta *pDatabaseMeta = m_pFixup->DatabaseMetaFromIndex(i);

        //Inference Rule 1.a.i.
            //DatabaseMeta.InternalName is a primarykey, so it must not be NULL.
        if(0 == pDatabaseMeta->InternalName)
        {
            m_pOut->printf(L"Validation Error in DatabaseMeta Row %d. DatabaseMeta.InternalName is a primarykey, so it must not be NULL.", i);
            THROW(ERROR - VALIDATION ERROR);
        }

        //Infereence Rule 1.a.ii.
            //DatabaseMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pDatabaseMeta->InternalName));


        //Infereence Rule 1.a.iii.
            //DatabaseMeta.InternalName should be no more than 16 characters (including the terminating NULL).
        if(wcslen(m_pFixup->StringFromIndex(pDatabaseMeta->InternalName))>15)
        {
            m_pOut->printf(L"Error - DatabaseMeta.InternalName (%s) is too long.  Must be 15 characters or less.", m_pFixup->StringFromIndex(pDatabaseMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 1.b.i.
            //DatabaseMeta.PublicName should be inferred from DatabaseMeta.InternalName if not supplied.
        if(0 == pDatabaseMeta->PublicName)
        {
            pDatabaseMeta->PublicName = pDatabaseMeta->InternalName;
        }
        else
        {
            //Inference Rule 1.b.ii.
                //DatabaseMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pDatabaseMeta->PublicName));
        }


        //Inference Rule 1.c.i.
            //DatabaseMeta.BaseVersion should be defaulted to zero if not specified.
        if(0 == pDatabaseMeta->BaseVersion)
            pDatabaseMeta->BaseVersion = m_iZero;


        //Inference Rule 1.d.i.
            //DatabaseMeta.ExtendedVersion should be defaulted to zero if not specified.
        if(0 == pDatabaseMeta->ExtendedVersion)
            pDatabaseMeta->ExtendedVersion = m_iZero;


        //Inference Rule 1.j.i.
            //DatabaseMeta.iTableMeta is an index to the first table whose Database matches the DatabaseMeta.InternalName.
        ASSERT(0 == pDatabaseMeta->iTableMeta);
        pDatabaseMeta->iTableMeta = 0;
        for(pDatabaseMeta->iTableMeta = 0;pDatabaseMeta->iTableMeta<m_pFixup->GetCountTableMeta();++pDatabaseMeta->iTableMeta)
        {
            if(m_pFixup->TableMetaFromIndex(pDatabaseMeta->iTableMeta)->Database == pDatabaseMeta->InternalName)
                break;//exit on the first occurance of a table within this database
        }

        //Inference Rule 1.j.ii.
            //DatabaseMeta.iTableMeta must have a legal value (between 0 and total number of TableMeta).
        if(pDatabaseMeta->iTableMeta == m_pFixup->GetCountTableMeta())
        {
            m_pOut->printf(L"Error - No tables belong to Database (%s)", m_pFixup->StringFromIndex(pDatabaseMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 1.e.i.
            //DatabaseMeta.CountOfTables should be inferred from the number of TableMeta whose Database column is equal to DatabaseMeta.InternalName.
        ASSERT(0 == pDatabaseMeta->CountOfTables);//This should not be filled in yet.  In Retail build, if it is, we'll overwrite it.
        pDatabaseMeta->CountOfTables = 0;
        for(unsigned long iTableMeta=pDatabaseMeta->iTableMeta;iTableMeta<m_pFixup->GetCountTableMeta();++iTableMeta)
        {
            if(m_pFixup->TableMetaFromIndex(iTableMeta)->Database == pDatabaseMeta->InternalName)
                ++pDatabaseMeta->CountOfTables;
            else if(pDatabaseMeta->CountOfTables != 0)//If we already saw the first Table in this database, then we're done (since all tables within a database
                break;                              //are contiguously located).
        }
        pDatabaseMeta->CountOfTables = m_pFixup->AddUI4ToList(pDatabaseMeta->CountOfTables);

        //f.    iSchemaBlob     Compilation Plugin
        //g.    cbSchemaBlob    Compilation Plugin
        //h.    iNameHeapBlob   Compilation Plugin
        //i.    cbNameHeapBlob  Compilation Plugin

        //Inference Rule 1.j.i. - See above - This rule is executed before 1.e.i.
            //DatabaseMeta.iTableMeta is an index to the first table whose Database matches the DatabaseMeta.InternalName.

        //Inference Rule 1.j.ii. - See above - This rule is executed before 1.e.i.
            //DatabaseMeta.iTableMeta must have a legal value (between 0 and total number of TableMeta).

        //k     iGuidDid        Compilation Plugin
    }
}

void TMetaInferrence::InferIndexMeta()
{
    for(unsigned long iIndexMeta=0; iIndexMeta<m_pFixup->GetCountIndexMeta(); ++iIndexMeta)
    {
        IndexMeta *pIndexMeta = m_pFixup->IndexMetaFromIndex(iIndexMeta);

        //Inference Rule 5.a.i.
            //IndexMeta.Table is a primary key so it must not be NULL.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pIndexMeta->Table);


        //Inference Rule 5.b.i.
            //IndexMeta.InternalName is a primary key so it must not be NULL.
        ASSERT(0 != pIndexMeta->InternalName);


        //Inference Rule 5.b.ii.
            //IndexMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pIndexMeta->InternalName));


        //Inference Rule 5.c.i.
            //IndexMeta.PublicName is inferred from the IndexMeta.InternalName if one is not supplied.
        if(0 == pIndexMeta->PublicName)
        {
            pIndexMeta->PublicName = pIndexMeta->InternalName;
        }
        else
        {
            //Inference Rule 5.c.ii.
                //IndexMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pIndexMeta->PublicName));
        }


        //Inference Rule 5.d.i.-See Below
            //ColumnIndex is the ColumnMeta.Index whose Table matches IndexMeta.Table and whose InternalName matches IndexMeta.ColumnInternalName.
        //Inference Rule 5.e.i.
            //There must exist a ColumnMeta whose Table matches IndexMeta.Table and whose InternalName matches IndexMeta.ColumnInternalName.
        ULONG iColumnMeta;
        for(iColumnMeta=0;iColumnMeta<m_pFixup->GetCountColumnMeta();++iColumnMeta)
        {
            ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);
            if( pColumnMeta->InternalName == pIndexMeta->ColumnInternalName &&
                pColumnMeta->Table == pIndexMeta->Table)
                break;
        }
        if(m_pFixup->GetCountColumnMeta() == iColumnMeta)
        {
            m_pOut->printf(L"Error in IndexMeta - Table (%s), No ColumnMeta.InternalName matches IndexMeta ColumnInternalName (%s)", m_pFixup->StringFromIndex(pIndexMeta->Table), m_pFixup->StringFromIndex(pIndexMeta->ColumnInternalName));
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 5.d.i.-See Below
            //ColumnIndex is the ColumnMeta.Index whose Table matches IndexMeta.Table and whose InternalName matches IndexMeta.ColumnInternalName.
        pIndexMeta->ColumnIndex = m_pFixup->ColumnMetaFromIndex(iColumnMeta)->Index;

        //Inference Rule 5.f.
            //MetaFlags is defaulted to zero of not supplied.
        if(0 == pIndexMeta->MetaFlags)
            pIndexMeta->MetaFlags = m_iZero;
    }
}

void TMetaInferrence::InferQueryMeta()
{
    for(unsigned long iQueryMeta=0; iQueryMeta<m_pFixup->GetCountQueryMeta(); ++iQueryMeta)
    {
        QueryMeta *pQueryMeta = m_pFixup->QueryMetaFromIndex(iQueryMeta);

        //Inference Rule 6.a.i.
            //QueryMeta.Table is a primary key so it must not be NULL.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pQueryMeta->Table);

        //Inference Rule 6.b.i.
            //QueryMeta.InternalName is a primary key so it must not be NULL.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pQueryMeta->InternalName);


        //Inference Rule 6.b.ii.
            //QueryMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pQueryMeta->InternalName));


        //Inference Rule 6.c.i.
            //QueryMeta.PublicName is inferred from the QueryMeta.InternalName if one is not supplied.
        if(0 == pQueryMeta->PublicName)
        {
            pQueryMeta->PublicName = pQueryMeta->InternalName;
        }
        else
        {
            //Inference Rule 6.c.ii.
                //QueryMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pQueryMeta->PublicName));
        }

        //Inference Rule 6.e.i.
            //CellName is defaulted to L"" is not supplied.
        if(0 == pQueryMeta->CellName)
        {
            pQueryMeta->CellName = m_pFixup->AddWCharToList(L"");
        }

        //Inference Rule 6.e.ii.
            //If CellName is provided and CellName is not CellName equals L"__FILE", it must match a ColumnMeta whose InternalName and a ColumnMeta.Table must match the QueryMeta.Table.
        if(pQueryMeta->CellName != m_pFixup->FindStringInPool(L"") && pQueryMeta->CellName != m_pFixup->FindStringInPool(L"__FILE"))
        {
            ULONG iColumnMeta;
            for(iColumnMeta=0;iColumnMeta<m_pFixup->GetCountColumnMeta();++iColumnMeta)
            {
                ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);
                if( pColumnMeta->Table == pQueryMeta->Table &&
                    pColumnMeta->InternalName == pQueryMeta->CellName)
                    break;
            }
            if(m_pFixup->GetCountColumnMeta() == iColumnMeta)
            {
                m_pOut->printf(L"Error in QueryMeta - Table (%s), No ColumnMeta.InternalName matches QueryMeta CellName (%s)", m_pFixup->StringFromIndex(pQueryMeta->Table), m_pFixup->StringFromIndex(pQueryMeta->CellName));
                THROW(ERROR - VALIDATION ERROR);
            }
        }


        //Inference Rule 6.f.i.
            //Operator is set to 'EQUAL" (zero) if not supplied.
        if(0 == pQueryMeta->Operator)
            pQueryMeta->Operator = m_iZero;


        //Inference Rule 6.g.
            //MetaFlags is set to zero is not supplied.
        if(0 == pQueryMeta->MetaFlags)
            pQueryMeta->MetaFlags = m_iZero;
    }
}


//@@@ What happens if the PrimaryTable and ForeignTable are the same?
void TMetaInferrence::InferRelationMeta()
{
    for(unsigned long iRelationMeta=0; iRelationMeta<m_pFixup->GetCountRelationMeta(); ++iRelationMeta)
    {
        RelationMeta *pRelationMeta = m_pFixup->RelationMetaFromIndex(iRelationMeta);

        //Inference Rule 7.a.i.
            //PrimaryTable must not be NULL and must match a TableMeta.InternalName.
        if(0 == pRelationMeta->PrimaryTable)
        {
            m_pOut->printf(L"Error in RelationMeta Row (%s) - PrimaryTable must exist.", iRelationMeta);
            THROW(ERROR - VALIDATION ERROR);
        }
        ULONG iPrimaryTable = m_pFixup->FindTableBy_TableName(pRelationMeta->PrimaryTable);
        if(-1 == iPrimaryTable)
        {
            m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s) not found in TableMeta", m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable));
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 7.b.i.
            //There must be as many PrimaryColumns as there are primary keys in the primary table.
        if(0 == pRelationMeta->PrimaryColumns)
        {
            m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s) has no PrimaryColumns entry", m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable));
            THROW(ERROR - VALIDATION ERROR);
        }
        ULONG cPrimaryKeysInPrimaryTable=0;
        ULONG iColumnMeta = m_pFixup->FindColumnBy_Table_And_Index(m_pFixup->TableMetaFromIndex(iPrimaryTable)->InternalName, m_iZero);
        ULONG iColumnMeta_PrimaryTable = iColumnMeta;//This is used below 7.d.i
        for(;m_pFixup->ColumnMetaFromIndex(iColumnMeta)->Table == m_pFixup->TableMetaFromIndex(iPrimaryTable)->InternalName;++iColumnMeta)
        {
            ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);
            if(fCOLUMNMETA_PRIMARYKEY & m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags))
                ++cPrimaryKeysInPrimaryTable;
        }
        if(cPrimaryKeysInPrimaryTable != m_pFixup->BufferLengthFromIndex(pRelationMeta->PrimaryColumns)/sizeof(ULONG))
        {
            m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s) has (%d) PrimaryColumns but (%d) were supplied", m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), cPrimaryKeysInPrimaryTable, m_pFixup->BufferLengthFromIndex(pRelationMeta->PrimaryColumns)/sizeof(ULONG));
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 7.c.i.
            //ForeignTable must not be NULL and must match a TableMeta.InternalName.
        if(0 == pRelationMeta->ForeignTable)
        {
            m_pOut->printf(L"Error in RelationMeta Row (%s) - ForeignTable must exist.", iRelationMeta);
            THROW(ERROR - VALIDATION ERROR);
        }
        ULONG iForeignTable = m_pFixup->FindTableBy_TableName(pRelationMeta->ForeignTable);
        if(-1 == iForeignTable)
        {
            m_pOut->printf(L"Error in RelationMeta - ForeignTable (%s) not found in TableMeta", m_pFixup->StringFromIndex(pRelationMeta->ForeignTable));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 7.d.i.
            //There must be as many ForeignColumns as there are primary keys in the primary table.
        if(0 == pRelationMeta->ForeignColumns)
        {
            m_pOut->printf(L"Error in RelationMeta - ForeignTable (%s) has no ForeignColumns entry", m_pFixup->StringFromIndex(pRelationMeta->ForeignTable));
            THROW(ERROR - VALIDATION ERROR);
        }
        if(cPrimaryKeysInPrimaryTable != m_pFixup->BufferLengthFromIndex(pRelationMeta->ForeignColumns)/sizeof(ULONG))
        {
            m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s) has (%d) PrimaryColumns but (%d) ForeignColumns were supplied", m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), cPrimaryKeysInPrimaryTable, m_pFixup->BufferLengthFromIndex(pRelationMeta->ForeignColumns)/sizeof(ULONG));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 7.e.
            //MetaFlags 	DefaultValue (0)
        if(0 == pRelationMeta->MetaFlags)
            pRelationMeta->MetaFlags = m_iZero;

        //Inference Rule 7.e.i.1.
            //fRELATIONMETA_USECONTAINMENT There can be only one containment relationship per ForeignTable.
        //@@@ TODO

        //Inference Rule 7.e.ii.1.
            //fRELATIONMETA_CONTAINASSIBLING Tables marked with this flag should infer the USECONTAINMENT flag.
        if((m_pFixup->UI4FromIndex(pRelationMeta->MetaFlags) & (fRELATIONMETA_CONTAINASSIBLING | fRELATIONMETA_USECONTAINMENT))
                    == fRELATIONMETA_CONTAINASSIBLING)//if CONTAINASSIBLING is set but USECONTAINMENT is NOT, then infer USECONTAINMENT
        {
            pRelationMeta->MetaFlags = m_pFixup->AddUI4ToList(m_pFixup->UI4FromIndex(pRelationMeta->MetaFlags) |
                            fRELATIONMETA_USECONTAINMENT);
        }

        ULONG iColumnMeta_ForeignTable = m_pFixup->FindColumnBy_Table_And_Index(m_pFixup->TableMetaFromIndex(iForeignTable)->InternalName, m_iZero);
        for(ULONG iPK=0;iPK<cPrimaryKeysInPrimaryTable;++iPK)
        {
            ULONG iForeignKey = reinterpret_cast<const ULONG *>(m_pFixup->ByteFromIndex(pRelationMeta->ForeignColumns))[iPK];
            ULONG iPrimaryKey = reinterpret_cast<const ULONG *>(m_pFixup->ByteFromIndex(pRelationMeta->PrimaryColumns))[iPK];

            ColumnMeta *pColumnMeta_ForeignKey = m_pFixup->ColumnMetaFromIndex(iColumnMeta_ForeignTable + iForeignKey);
            ColumnMeta *pColumnMeta_PrimaryKey = m_pFixup->ColumnMetaFromIndex(iColumnMeta_PrimaryTable + iPrimaryKey);

            //Inference Rule 7.d.ii.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.Type.
            if(pColumnMeta_ForeignKey->Type != pColumnMeta_PrimaryKey->Type)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.Type mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.iii.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.Size.
            if(pColumnMeta_ForeignKey->Size != pColumnMeta_PrimaryKey->Size)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.Size mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.iv.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.FlagMask.
            if(pColumnMeta_ForeignKey->FlagMask != pColumnMeta_PrimaryKey->FlagMask)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.FlagMask mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.v.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.StartingNumber.
            if(pColumnMeta_ForeignKey->StartingNumber != pColumnMeta_PrimaryKey->StartingNumber)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.StartingNumber mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.vi.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.EndingNumber.
            if(pColumnMeta_ForeignKey->EndingNumber != pColumnMeta_PrimaryKey->EndingNumber)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.EndingNumber mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.vii.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.CharacterSet.
            if(pColumnMeta_ForeignKey->CharacterSet != pColumnMeta_PrimaryKey->CharacterSet)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.CharacterSet mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.viii.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.MetaFlags set (fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_HASNUMERICRANGE |fCOLUMNMETA_LEGALCHARSET | fCOLUMNMETA_ILLEGALCHARSET | fCOLUMNMETA_NOTPERSISTABLE | fCOLUMNMETA_MULTISTRING | fCOLUMNMETA_EXPANDSTRING | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE)
            ULONG FlagsThatMustMatch = (fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_HASNUMERICRANGE |fCOLUMNMETA_LEGALCHARSET | fCOLUMNMETA_ILLEGALCHARSET | fCOLUMNMETA_NOTPERSISTABLE | fCOLUMNMETA_MULTISTRING | fCOLUMNMETA_EXPANDSTRING | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE);
            if( (m_pFixup->UI4FromIndex(pColumnMeta_ForeignKey->MetaFlags)&FlagsThatMustMatch) !=
                (m_pFixup->UI4FromIndex(pColumnMeta_PrimaryKey->MetaFlags)&FlagsThatMustMatch))
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.MetaFlags mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }

            //Inference Rule 7.d.ix
                //If a containment relation, each ForeignColumn must map to a PrimaryColumn of the same ColumnMeta.MetaFags set (fCOLUMNMETA_NOTNULLABLE)
            FlagsThatMustMatch = (fCOLUMNMETA_NOTNULLABLE);
            if( (m_pFixup->UI4FromIndex(pRelationMeta->MetaFlags) & fRELATIONMETA_USECONTAINMENT) &&
                ((m_pFixup->UI4FromIndex(pColumnMeta_ForeignKey->MetaFlags)&FlagsThatMustMatch) !=
                 (m_pFixup->UI4FromIndex(pColumnMeta_PrimaryKey->MetaFlags)&FlagsThatMustMatch)) )
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.MetaFlags mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }

            //Inference Rule 3.g.ii.1  - This is handled in RelationMeta inferrence
                //fCOLUMNMETA_FOREIGNKEY  is set when the table is listed as a RelationMeta.ForeignTable and the column is listed as one of the RelationMeta.ForeignColumns.
            pColumnMeta_ForeignKey->MetaFlags = m_pFixup->AddUI4ToList(m_pFixup->UI4FromIndex(pColumnMeta_ForeignKey->MetaFlags) | fCOLUMNMETA_FOREIGNKEY);
        }
    }
}


void TMetaInferrence::InferTableMeta()
{
    for(unsigned long i=0; i<m_pFixup->GetCountTableMeta(); ++i)
    {
        TableMeta *pTableMeta = m_pFixup->TableMetaFromIndex(i);

        //Inference Rule 2.a.i.
            //TableMeta XML elements exist as children of the Database under which they belong.  So Database is inferred from the parent DatabaseMeta.InternalName.
        ASSERT(0 != pTableMeta->Database);//This rule must have already been executed.  If not, it is a programming error.


        //Inference Rule 2.b.i.
            //TableMeta.InternalName is a primary key so it must not be NULL.
        if(0 == pTableMeta->InternalName)
        {
            m_pOut->printf(L"Validation Error in TableMeta Row %d. TableMeta.InternalName is a primarykey, so it must not be NULL.", i);
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 2.b.ii.
            //TableMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pTableMeta->InternalName));


        //Inference Rule 2.c.i.
            //TableMeta.PublicName is inferred from TableMeta.InternalName if not supplied.
        if(0 == pTableMeta->PublicName)
        {
            pTableMeta->PublicName = pTableMeta->InternalName;
        }
        else
        {
            //Inference Rule 2.c.ii.
                //TableMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pTableMeta->PublicName));
        }


        //Inference Rule 2.d.i.
            //PublicRowName is inferred from the PublicName if one is not supplied.  If the PublicName ends in 's', the PublicRowName is inferred as the PublicName without the 's'.  Otherwise the PublicRowName is 'A' followed by the PublicName.
        if(0 == pTableMeta->PublicRowName)
        {
            pTableMeta->PublicRowName = InferPublicRowName(pTableMeta->PublicName);
        }


        //Inference Rule 2.e.i.
            //TableMeta.BaseVersion is defaulted to zero if none is supplied.
        if(0 == pTableMeta->BaseVersion)
            pTableMeta->BaseVersion = m_iZero;


        //Inference Rule 2.f.i.
            //TableMeta.ExtendedVersion is defaulted to zero if none is supplied.
        if(0 == pTableMeta->ExtendedVersion)
            pTableMeta->ExtendedVersion = m_iZero;


        //Inference Rule 2.p.i.
            //TableMeta.iColumnMeta is an index to the first ColumnMeta row whose Table matches the TableMeta.InternalName
        ASSERT(0 == pTableMeta->iColumnMeta);
        pTableMeta->iColumnMeta = 0;
        for(pTableMeta->iColumnMeta = 0;pTableMeta->iColumnMeta<m_pFixup->GetCountColumnMeta();++pTableMeta->iColumnMeta)
        {
            if(m_pFixup->ColumnMetaFromIndex(pTableMeta->iColumnMeta)->Table == pTableMeta->InternalName)
                break;//exit on the first occurance of a column within this table
        }

        //Inference Rule 2.i.i.
            //TableMeta.CountOfColumns is the count of ColumnMeta whose Table equals the TableMeta.InternalName
        ASSERT(0 == pTableMeta->CountOfColumns);
        while((pTableMeta->iColumnMeta + pTableMeta->CountOfColumns) < m_pFixup->GetCountColumnMeta() &&
            m_pFixup->ColumnMetaFromIndex(pTableMeta->iColumnMeta + pTableMeta->CountOfColumns)->Table == pTableMeta->InternalName)++pTableMeta->CountOfColumns;
        pTableMeta->CountOfColumns = m_pFixup->AddUI4ToList(pTableMeta->CountOfColumns);


        //Inference Rule 2.g.i.
            //TableMeta.NameColumn can be inferred from a column whose ColumnMeta.MetaFlags fCOLUMNMETA_NAMECOLUMN bit is set.  If no columns have this bit set,
            //it is the first primary key whole type is WSTR.  If no primary keys are of type WSTR, it is the first column of type WSTR.  If no columns
            //are of type WSTR, the NameColumn is set to be the TableMeta.NavColumn value.  Thus the NavColumn inferrence rule must be executed before
            //the NameColumn inferrence rule.
        //Inference Rule 2.h.i.
            //TableMeta.NavColumn can be inferred from a column whose ColumnMeta.MetaFlags fCOLUMNMETA_NAVCOLUMN bit is set.  If no columns have this bit set,
            //it is set to be the first primary key that is not also a foreign key.  If no column is a primary key that is not also a foreign key, the NavColumn
            //is set as the first primary key whose type is WSTR.  If none of the above conditions are met, the NavColumn is set as the first primary key.
        InferTableMeta_NameColumn_NavColumn(pTableMeta);

        ASSERT(0 != pTableMeta->MetaFlags);
        ULONG MetaFlags = m_pFixup->UI4FromIndex(pTableMeta->MetaFlags);

        ULONG fORingOfAllColumnMeta_MetaFlags = 0;
        ULONG fORingOfAllColumnMeta_SchemaGeneratorFlags = 0;
        bool  bPrimaryKey_MerkedAs_InsertUnique = false;
        for(ULONG iColumnMeta=0; iColumnMeta<m_pFixup->UI4FromIndex(pTableMeta->CountOfColumns); ++iColumnMeta)
        {
            ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta + pTableMeta->iColumnMeta);
            ASSERT(m_pFixup->UI4FromIndex(pColumnMeta->Index) == iColumnMeta);

            if((m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags)&(fCOLUMNMETA_PRIMARYKEY | fCOLUMNMETA_INSERTUNIQUE)) == (fCOLUMNMETA_PRIMARYKEY | fCOLUMNMETA_INSERTUNIQUE))
                bPrimaryKey_MerkedAs_InsertUnique = true;

            fORingOfAllColumnMeta_MetaFlags |= m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags);
            fORingOfAllColumnMeta_SchemaGeneratorFlags |= m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags);

            //Inference Rule 2.n.i.
                //PublicRowNameColumn is inferred from the ColumnMeta whose SchemaGeneratorFlags has the fCOLUMNMETA_USEASPUBLICROWNAME bit set.
            if(m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags)&fCOLUMNMETA_USEASPUBLICROWNAME)
            {
                ASSERT(0 == pTableMeta->PublicRowNameColumn);//Can have more than one of these.  This is handled by Inference Rule 3.m.i.2
                pTableMeta->PublicRowNameColumn = m_pFixup->AddUI4ToList(iColumnMeta);
            }
        }

        if(fORingOfAllColumnMeta_SchemaGeneratorFlags & fCOLUMNMETA_VALUEINCHILDELEMENT)
        {
            //Inference Rule 2.aa.ii
                //This property is NOT NULL if at least one column has the VALUEINCHILDELEMENT set in SchemaGeneratorFlags.
            if(0 == pTableMeta->ChildElementName)
            {
                m_pOut->printf(L"Error - Table (%s) has at least one column marked as VALUEINCHILDELEMENT but no ChildElementName is set in the TableMeta", m_pFixup->StringFromIndex(pTableMeta->InternalName));
                THROW(ERROR - VALIDATION ERROR);
            }
        }
        else
        {
            //Inference Rule 2.aa.i
                //This property is NULL if no column has the VALUEINCHILDELEMENT set in SchemaGeneratorFlags.
            if(0 != pTableMeta->ChildElementName)
            {
                m_pOut->printf(L"Error - Table (%s) has no column marked as VALUEINCHILDELEMENT but a ChildElementName is set in the TableMeta", m_pFixup->StringFromIndex(pTableMeta->InternalName));
                THROW(ERROR - VALIDATION ERROR);
            }
        }

        //Inference Rule 2.j.xviii.1 
            //If any column is marked as fCOLUMNMETA_PRIMARYKEY and fCOLUMNMETA_INSERTUNIQUE, the fTABLEMETA_OVERWRITEALLROWS must
            //be specified.  It is not inferred - it should be explicitly specified..
        if(bPrimaryKey_MerkedAs_InsertUnique && 0==(MetaFlags & fTABLEMETA_OVERWRITEALLROWS))
        {
            m_pOut->printf(L"Error - Table (%s) has a PRIMARYKEY column that is also marked as INSERTUNIQUE.  This requires the table to be marked as OVERWRITEALLROWS", m_pFixup->StringFromIndex(pTableMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 2.j.v.1.
            //fTABLEMETA_HASUNKNOWNSIZES indicates whether any of the table's ColumnMeta.MetaFlags fCOLUMNMETA_UNKNOWNSIZE bit is set.  This depends in Inferrence Rule 3.g.xxviii.1.
        if(fORingOfAllColumnMeta_MetaFlags & fCOLUMNMETA_UNKNOWNSIZE)
            MetaFlags |= fTABLEMETA_HASUNKNOWNSIZES;


        //Inference Rule 2.j.x.1.
            //If any of the table's ColumnMeta.Metaflags specify fCOLUMNMETA_DIRECTIVE then fTABLEMETA_HASDIRECTIVES is set.
        if(fORingOfAllColumnMeta_MetaFlags & fCOLUMNMETA_DIRECTIVE)
            MetaFlags |= fTABLEMETA_HASDIRECTIVES;
        pTableMeta->MetaFlags = m_pFixup->AddUI4ToList(MetaFlags);


        ULONG SchemaGeneratorFlags = m_pFixup->UI4FromIndex(pTableMeta->SchemaGeneratorFlags);
        //Inference Rule 2.k.iii.1.
            //fTABLEMETA_ISCONTAINED is set if there is a RelationMeta.ForeignTable that matches TableMeta.InternalName and RelationMeta.Metaflags' fRELATIONMETA_USECONTAINMENT bit is set.
        for(ULONG iRelationMeta=0; iRelationMeta<m_pFixup->GetCountRelationMeta(); ++iRelationMeta)
        {
            RelationMeta *pRelationMeta = m_pFixup->RelationMetaFromIndex(iRelationMeta);
            if(m_pFixup->UI4FromIndex(pRelationMeta->MetaFlags)&fRELATIONMETA_USECONTAINMENT &&
                pRelationMeta->ForeignTable == pTableMeta->InternalName)
            {
                SchemaGeneratorFlags |= fTABLEMETA_ISCONTAINED;
                break;
            }
        }
        pTableMeta->SchemaGeneratorFlags = m_pFixup->AddUI4ToList(SchemaGeneratorFlags);


        //Inference Rule 2.n.i.-See Above
            //PublicRowNameColumn is inferred from the ColumnMeta whose SchemaGeneratorFlags has the fCOLUMNMETA_USEASPUBLICROWNAME bit set.

        //Inference Rule 2.n.ii.
            //If no column has the fCOLUMNMETA_USEASPUBLICROWNAME bit set, TableMeta. PublicRowNameColumn column is defaulted to -1.
        if(0 == pTableMeta->PublicRowNameColumn)
        {
            pTableMeta->PublicRowNameColumn = m_pFixup->AddUI4ToList(-1);
        }


        //Inference Rule 2.p.i. - See Above
            //TableMeta.iColumnMeta is an index to the first ColumnMeta row whose Table matches the TableMeta.InternalName


        pTableMeta->iIndexMeta = 0;
        //Inference Rule 2.s.i.
            //iIndexMeta is an index to the first IndexMeta whose Table matches the TableMeta.InternalName.
        for( ; pTableMeta->iIndexMeta<m_pFixup->GetCountIndexMeta();++pTableMeta->iIndexMeta)
        {
            if(m_pFixup->IndexMetaFromIndex(pTableMeta->iIndexMeta)->Table == pTableMeta->InternalName)
                break;
        }
        if(pTableMeta->iIndexMeta==m_pFixup->GetCountIndexMeta())
            pTableMeta->iIndexMeta = -1;//No IndexMeta for this table

        //Inference Rule 2.r.i.
            //cIndexMeta is the count of IndexMeta whose Table matches the TableMeta.InternalName.
        pTableMeta->cIndexMeta = 0;
        for( ; (pTableMeta->iIndexMeta + pTableMeta->cIndexMeta)<m_pFixup->GetCountIndexMeta();++pTableMeta->cIndexMeta)
        {
            if(m_pFixup->IndexMetaFromIndex(pTableMeta->iIndexMeta + pTableMeta->cIndexMeta)->Table != pTableMeta->InternalName)
                break;
        }

        //Inference Rule 2.v.i.
            //iServerWiring is an index to the first ServerWiringMeta row whose Table matches the TableMeta.InternalName. 
        pTableMeta->iServerWiring=0;
        for( ;pTableMeta->iServerWiring<m_pFixup->GetCountServerWiringMeta();++pTableMeta->iServerWiring)
        {
            if(m_pFixup->ServerWiringMetaFromIndex(pTableMeta->iServerWiring)->Table == pTableMeta->InternalName)
                break;
        }
        ASSERT(pTableMeta->iServerWiring<m_pFixup->GetCountServerWiringMeta());
        //Inference Rule 2.w.i.
            //cServerWiring is the count of ServerWiringMeta rows whole Table matches the TableMeta.InternalName.
        pTableMeta->cServerWiring=0;
        for( ; (pTableMeta->iServerWiring + pTableMeta->cServerWiring)<m_pFixup->GetCountServerWiringMeta();++pTableMeta->cServerWiring)
        {
            if(m_pFixup->ServerWiringMetaFromIndex(pTableMeta->iServerWiring + pTableMeta->cServerWiring)->Table != pTableMeta->InternalName)
                break;
        }

        if(MetaFlags & fTABLEMETA_HASDIRECTIVES)
        {
            for(ULONG iColumnMeta=0; iColumnMeta<m_pFixup->UI4FromIndex(pTableMeta->CountOfColumns); ++iColumnMeta)
            {   //we're only validating PKs that are NOT FKs
                ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta + pTableMeta->iColumnMeta);
                
                if(fCOLUMNMETA_PRIMARYKEY == (m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags)
                                                & (fCOLUMNMETA_PRIMARYKEY | fCOLUMNMETA_FOREIGNKEY)))
                {
                    if(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_DIRECTIVE)
                    {   //A directive column may NOT have a DefaultValue
                        if(0 != pColumnMeta->DefaultValue)
                        {
                            m_pOut->printf(L"Directive Table (%s), has Directive Column (%s) with a DefaultValue.\r\n"
                                            ,m_pFixup->StringFromIndex(pTableMeta->InternalName)
                                            ,m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                            m_pOut->printf(L"In a Directive Table, all PrimaryKeys that are not ForeignKeys must have a default"
                                          L"value (with one exception - the Directive column itself must NOT have a Default Value)\r\n");
                            THROW(ERROR IN DIRECTIVE COLUMN - DEFAULT VALUE SUPPLIED FOR DIRECTIVE COLUMN);
                        }
                    }
                    else
                    {   //Not DIRECTIVE PK Column must have a DefaultValue
                        if(0 == pColumnMeta->DefaultValue)
                        {
                            m_pOut->printf(L"Directive Table (%s), has PrimaryKey Column (%s) but no DefaultValue was supplied\r\n"
                                            ,m_pFixup->StringFromIndex(pTableMeta->InternalName)
                                            ,m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                            m_pOut->printf(L"In a Directive Table, all PrimaryKeys that are not ForeignKeys must have a default"
                                          L"value (with one exception - the Directive column itself must NOT have a Default Value)\r\n");
                            THROW(ERROR IN DIRECTIVE COLUMN - NOT DEFAULT VALUE);
                        }
                    }
                }
            }
        }
#if 0
        //Inference Rule 2.x.i.
            //cPrivateColumns is hard coded based on the meta tables.  Only Meta tables have a private column count.
        if(pTableMeta->InternalName         == m_pFixup->FindStringInPool(L"COLUMNMETA"))
            pTableMeta->cPrivateColumns = kciColumnMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"DATABASEMETA"))
            pTableMeta->cPrivateColumns = kciDatabaseMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"INDEXMETA"))
            pTableMeta->cPrivateColumns = kciIndexMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"QUERYMETA"))
            pTableMeta->cPrivateColumns = kciQueryMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"RELATIONMETA"))
            pTableMeta->cPrivateColumns = kciRelationMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"SERVERWIRINGMETA"))
            pTableMeta->cPrivateColumns = kciServerWiringMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"TABLEMETA"))
            pTableMeta->cPrivateColumns = kciTableMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"TAGMETA"))
            pTableMeta->cPrivateColumns = kciTagMetaPrivateColumns;
#endif
    }
}

void TMetaInferrence::InferTagMeta()
{
    for(ULONG iTagMeta=0; iTagMeta<m_pFixup->GetCountTagMeta(); ++iTagMeta)
    {
        TagMeta *pTagMeta = m_pFixup->TagMetaFromIndex(iTagMeta);

        //Inference Rule 4.c.i.
            //TagMeta.InternalName must exist.
        if(0 == pTagMeta->InternalName)
        {
            m_pOut->printf(L"Error - TagMeta.InternalName is missing on Table (%s), ColumnIndex (%d).", pTagMeta->Table ? m_pFixup->StringFromIndex(pTagMeta->Table) : L"<unknown>", pTagMeta->ColumnIndex ? m_pFixup->UI4FromIndex(pTagMeta->ColumnIndex) : -1);
            THROW(ERROR - VALIDATION ERROR);
        }

        //We'd like to scan the TableMeta; but PublicRowNameColumn has not yet been inferred.
        //So we'll have to scan for the ColumnMeta instead and look at the MetaFlagsEx (SchemaGeneratorFlags)
        ULONG iColumnMeta = m_pFixup->FindColumnBy_Table_And_Index(pTagMeta->Table, pTagMeta->ColumnIndex);
        ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);

        //If this is not the enum used as PublicRow name then Numerics are OK as a first char
        bool bAllowNumeric = !(m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) & fCOLUMNMETA_USEASPUBLICROWNAME);

        //Inference Rule 4.c.ii.
            //TagMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pTagMeta->InternalName), m_szNameLegalCharacters, bAllowNumeric);
        
        //Inference Rule 4.d.i.
            //TagMeta.PublicName is set to the TagMeta.InternalName if none is supplied.
        if(0 == pTagMeta->PublicName)
        {
            pTagMeta->PublicName = pTagMeta->InternalName;
            //if the InternalName is a legal C++ variable name and this enum is the EnumPublicRowName column
            //then we're good to go.
        }
        else
        {
            //Inference Rule 4.d.ii.
                //TagMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pTagMeta->PublicName),
                    bAllowNumeric ? m_szPublicTagLegalCharacters : m_szNameLegalCharacters, bAllowNumeric);
        }
        


        ASSERT(0 != pTagMeta->Value);
    }
}


//Inference Rule 2.g.i.
//Inference Rule 2.h.i.
void TMetaInferrence::InferTableMeta_NameColumn_NavColumn(TableMeta *pTableMeta)
{
    unsigned long iInferredNavColumn = -1;//undefined
    unsigned long iFirstWCharPrimaryKeyThatsAlsoAForeignKey = -1;//undefined
    unsigned long iFirstWCharPrimaryKey = -1;//undefined
    unsigned long iFirstWCharColumn = -1;//undefined
    unsigned long iNavColumn  = -1;//undefined
    unsigned long iNameColumn = -1;//undefined

    for(unsigned long iColumnMeta=0; iColumnMeta<m_pFixup->UI4FromIndex(pTableMeta->CountOfColumns); ++iColumnMeta)
    {
        ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta + pTableMeta->iColumnMeta);
        if(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_NAMECOLUMN)//If the user specified the NameColumn flag then use it
        {
            //Inference Rule 3.g.iii.1
                //Only one NameColumn may be specified per table.
            if(-1 != iNameColumn)
            {
                m_pOut->printf(L"Error - Multiple NameColumns specified (Table %s, Column %s).\n\tOnly one Column should have the fCOLUMNMETA_NAMECOLUMN set.\n", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                THROW(ERROR - MULTIPLE NAME COLUMNS SPECIFIED);
            }
            iNameColumn = iColumnMeta;
        }
        if(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_NAVCOLUMN)
        {
            //Inference Rule 3.g.iv.1
                //Only one NavColumn may be specified per table.
            if(-1 != iNavColumn)
            {
                m_pOut->printf(L"Error - Multiple NavColumns specified (Table %s, Column %s).\n\tOnly one Column should have the fCOLUMNMETA_NAVCOLUMN set.\n", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                THROW(ERROR - MULTIPLE NAV COLUMNS SPECIFIED);
            }
            iNavColumn = iColumnMeta;
        }
        //If we haven't already reached the first PRIMARYKEY that is not a FOREIGNKEY, then use this to infer the Name and Nav Columns
        if(-1 == iInferredNavColumn && m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY && 0==(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_FOREIGNKEY))
            iInferredNavColumn  = iColumnMeta;
        if(-1 == iFirstWCharColumn && m_pFixup->UI4FromIndex(pColumnMeta->Type) == DBTYPE_WSTR)
            iFirstWCharColumn = iColumnMeta;
        if(-1 == iFirstWCharPrimaryKey && m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY && 0==(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_FOREIGNKEY) && m_pFixup->UI4FromIndex(pColumnMeta->Type) == DBTYPE_WSTR)
            iFirstWCharPrimaryKey = iColumnMeta;
        if(-1 == iFirstWCharPrimaryKeyThatsAlsoAForeignKey && m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY && m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_FOREIGNKEY && m_pFixup->UI4FromIndex(pColumnMeta->Type) == DBTYPE_WSTR)
            iFirstWCharPrimaryKeyThatsAlsoAForeignKey = iColumnMeta;
    }
    if(-1 == iInferredNavColumn)//ALL Table should have at least one primary key that is NOT a foreign key
    {
        m_pOut->printf(L"Warning - Table (%s) contains no PRIMARYKEY that is not also a FOREIGNKEY.\n", m_pFixup->StringFromIndex(pTableMeta->InternalName));
        iInferredNavColumn = (-1 == iFirstWCharPrimaryKeyThatsAlsoAForeignKey) ? 0 : iFirstWCharPrimaryKeyThatsAlsoAForeignKey;
    }
    if(-1 == iNavColumn)
        iNavColumn = iInferredNavColumn;
    if(-1 == iNameColumn)
    {
        if(-1 != iFirstWCharPrimaryKey)
            iNameColumn = iFirstWCharPrimaryKey;
        else if(-1 != iFirstWCharColumn)
            iNameColumn = iFirstWCharColumn;
        else
            iNameColumn = iNavColumn;
    }
    pTableMeta->NameColumn = m_pFixup->AddUI4ToList(iNameColumn);
    pTableMeta->NavColumn  = m_pFixup->AddUI4ToList(iNavColumn);
}


unsigned long TMetaInferrence::InferPublicRowName(unsigned long PublicName)
{
    LPCWSTR wszPublicName = m_pFixup->StringFromIndex(PublicName);
    SIZE_T  cwchPublicName = wcslen(wszPublicName);

    TSmartPointerArray<WCHAR> wszPublicRowName = new WCHAR [wcslen(wszPublicName)+2];
    if(0 == wszPublicRowName.m_p)
    {
        THROW(ERROR - OUT OF MEMORY);
    }

    //Very language specific, if PublicTableName ends in 's' or 'S' then Infer PublicRowName as PublicTableName without the 's'
    if(wszPublicName[cwchPublicName-1] == L's' || wszPublicName[cwchPublicName-1] == L'S')
    {
        wcscpy(wszPublicRowName, m_pFixup->StringFromIndex(PublicName));
        wszPublicRowName[cwchPublicName-1] = 0x00;
    }
    else //If PublicTableName does NOT end in 's' or 'S' then put 'A' in front of the PublicTableName
    {
        wcscpy(wszPublicRowName, L"A");
        wcscat(wszPublicRowName, m_pFixup->StringFromIndex(PublicName));
    }
    return m_pFixup->AddWCharToList(wszPublicRowName);
}

void TMetaInferrence::InferServerWiringMeta()
{
	ULONG lastTable = ULONG(-1); // -1 is not used for any table nr

    for(unsigned long iServerWiringMeta=0; iServerWiringMeta<m_pFixup->GetCountServerWiringMeta(); ++iServerWiringMeta)
    {
        ServerWiringMeta *pServerWiringMeta = m_pFixup->ServerWiringMetaFromIndex(iServerWiringMeta);

        //Inference Rule 8.a.i.
            //Table is a primarykey so it cannot be NULL
        if(0 == pServerWiringMeta->Table)
        {
            m_pOut->printf(L"Error in ServerWiringMeta row (%d) - NULL specified for Table.", iServerWiringMeta);
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 8.b.i.
            //Order is a primarykey so it cannot be NULL
        ASSERT(0 != pServerWiringMeta->Order);//This should have already been inferred

        //Inference Rule 8.c.i.
            //ReadPlugin is defatuled to RPNone (0) if none is specified.
        if(0 == pServerWiringMeta->ReadPlugin)
            pServerWiringMeta->ReadPlugin = m_iZero;

        //Inference Rule 8.d.i.
            //WritePlugin is defaulted to WPNone (0) if none is specified.
        if(0 == pServerWiringMeta->WritePlugin)
            pServerWiringMeta->WritePlugin = m_iZero;

        //Inference Rule 8.e.i.
            //Interceptor is defaulted to NoInterceptor (0) if none is specified.
        if(0 == pServerWiringMeta->Interceptor)
            pServerWiringMeta->Interceptor = m_iZero;

		//Inference Rule 8.j.i    
		if(0 == pServerWiringMeta->Merger)
            pServerWiringMeta->Merger= m_iZero;

		// Inference Rule 8.j.ii
		//Check that when a merger is defined, it is only defined in the first serverwiring
		//element for that table
		if (pServerWiringMeta->Table != lastTable)
		{
			lastTable    = pServerWiringMeta->Table;
		}
		else
		{
			// same table, so check that merger is not specified
			if (m_iZero != pServerWiringMeta->Merger)
			{
				m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - Merge Interceptor must be defined as first interceptor, and there can be only one merge interceptor.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
				THROW(ERROR - VALIDATION ERROR);
			}
		}

        //Inference Rule 8.e.ii.
            //At least one of the following must be non zero: ReadPlugin, WritePlugin, Interceptor.
        if( m_iZero == pServerWiringMeta->ReadPlugin  &&
            m_iZero == pServerWiringMeta->WritePlugin &&
            m_iZero == pServerWiringMeta->Interceptor)
        {
            m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - ReadPlugin, WritePlugin, Interceptor are all specified as NONE.  At least one of these must be specified.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

		// You cannot defined read plugins and write plugins when you have defined a merger
		if ((pServerWiringMeta->Merger != m_iZero) && 
			((pServerWiringMeta->ReadPlugin != m_iZero) || (pServerWiringMeta->WritePlugin != m_iZero)))
		{
			m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - You cannot define ReadPlugin or WritePlugin when a Merger is defined.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
			THROW(ERROR - VALIDATION ERROR);
		}

        //Inference Rule 8.f.i./8.k.i/8.l.i/8.m.i
        //If InterceptorDLLName of L"catalog.dll" is specified, it is replaced with the default value of 0.
		
        if(0 != pServerWiringMeta->ReadPluginDLLName &&  0 == _wcsicmp( m_pFixup->StringFromIndex(pServerWiringMeta->ReadPluginDLLName), L"catalog.dll"))
            THROW(ERROR - CATALOG.DLL SHOULD NEVER BE EXPLLICITLY SPECIFIED);
         
		if(0 != pServerWiringMeta->WritePluginDLLName &&  0 == _wcsicmp( m_pFixup->StringFromIndex(pServerWiringMeta->WritePluginDLLName), L"catalog.dll"))
            THROW(ERROR - CATALOG.DLL SHOULD NEVER BE EXPLLICITLY SPECIFIED);
         
		if(0 != pServerWiringMeta->InterceptorDLLName &&  0 == _wcsicmp( m_pFixup->StringFromIndex(pServerWiringMeta->InterceptorDLLName), L"catalog.dll"))
            THROW(ERROR - CATALOG.DLL SHOULD NEVER BE EXPLLICITLY SPECIFIED);
         
		if(0 != pServerWiringMeta->MergerDLLName &&  0 == _wcsicmp( m_pFixup->StringFromIndex(pServerWiringMeta->MergerDLLName), L"catalog.dll"))
            THROW(ERROR - CATALOG.DLL SHOULD NEVER BE EXPLLICITLY SPECIFIED);

        //Inference Rule 8.g.i.
            //Flags is defaulted to (First | NoNext | Last | WireOnReadWrite) or 0x2D if none is supplied.
        if(0 == pServerWiringMeta->Flags || 0 == m_pFixup->UI4FromIndex(pServerWiringMeta->Flags))
            pServerWiringMeta->Flags = m_pFixup->AddUI4ToList(0x2D);

        //Inference Rule 8.g.ii.
            //Flags can specify WireOnReadWrite or WireOnWriteOnly but not both.(fSERVERWIRINGMETA_WireOnReadWrite | fSERVERWIRINGMETA_WireOnWriteOnly) == 0x30
        if((m_pFixup->UI4FromIndex(pServerWiringMeta->Flags) & 0x30) == 0x30)
        {
            m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - WireOnReadWrite OR WireOnWriteOnly may be specified but not both.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 8.g.iii.
            //Flags can specify First or Next but not both.(fSERVERWIRINGMETA_First | fSERVERWIRINGMETA_Next)==0x03
        if((m_pFixup->UI4FromIndex(pServerWiringMeta->Flags) & 0x03) == 0x03)
        {
            m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - First OR Next may be specified but not both.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 8.g.i.
            //Reserved should be set to 0.
        if(0 == pServerWiringMeta->Reserved)
            pServerWiringMeta->Reserved = m_pFixup->AddUI4ToList(0L);
    }
}


void TMetaInferrence::ValidateStringAsLegalVariableName(LPCWSTR wszString, LPCWSTR wszLegalCharacters, bool bAllowNumericFirstCharacter)
{
    if(0 == wszLegalCharacters)
        wszLegalCharacters = m_szNameLegalCharacters;

    SIZE_T nStringLength = wcslen(wszString);
	// the string must start with a letter (WMI naming convention)
    if(!bAllowNumericFirstCharacter)
    {
        if((*wszString < L'a' || *wszString > L'z') && (*wszString < L'A' || *wszString > L'Z'))
        {
            m_pOut->printf(L"Error - Bogus String (%s).  This String must be a legal C++ variable name (begins with an alpha and contains only alpha (or '_') and numerics.\n", wszString);
            THROW(ERROR - BOGUS NAME);
        }
    }

	// WMI names cannot end with underscore.
	if (wszString[nStringLength - 1] == L'_')
	{
		m_pOut->printf(L"Error - Bogus String (%s).  This String must be a legal WMI name (cannot end with underscore).\n", wszString);
        THROW(ERROR - BOGUS NAME);
	}

    LPCWSTR wszIllegalCharacter = _wcsspnp(wszString, wszLegalCharacters);
    if(NULL != wszIllegalCharacter)
    {
        m_pOut->printf(L"Error - Bogus String (%s).  This string should not contain the character '%c'.\n", wszString, static_cast<char>(*wszIllegalCharacter));
        THROW(ERROR - BAD NAME);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tpefixup.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TPEFIXUP_H__
#define __TPEFIXUP_H__

#ifndef __XMLUTILITY_H__
    #include "XMLUtility.h"
#endif
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif


//TPEFixup class is the interface that all Schema compilation modules use to get at the meta and fixed tables.  TColumnMeta, TDatabaseMeta etc classes
//can be used to make this access easier (pasing in a TPEFixup class reference).
class TPEFixup
{
public:
    TPEFixup(){}

    virtual unsigned long       AddBytesToList(const unsigned char * pBytes, size_t cbBytes) =0;
    virtual unsigned long       AddGuidToList(const GUID &guid)                              =0;
    virtual unsigned long       AddUI4ToList(ULONG ui4)                                      =0;
    virtual unsigned long       AddULongToList(ULONG ulong)                                  =0;
    virtual unsigned long       AddWCharToList(LPCWSTR wsz, unsigned long cwchar=-1)         =0;
    virtual unsigned long       FindStringInPool(LPCWSTR wsz, unsigned long cwchar=-1) const =0;

    virtual unsigned long       AddColumnMetaToList         (ColumnMeta       *p, ULONG count=1) =0;
    virtual unsigned long       AddDatabaseMetaToList       (DatabaseMeta     *p, ULONG count=1) =0;
    virtual unsigned long       AddHashedIndexToList        (HashedIndex      *p, ULONG count=1) =0;
    virtual unsigned long       AddIndexMetaToList          (IndexMeta        *p, ULONG count=1) =0;
    virtual unsigned long       AddQueryMetaToList          (QueryMeta        *p, ULONG count=1) =0;
    virtual unsigned long       AddRelationMetaToList       (RelationMeta     *p, ULONG count=1) =0;
    virtual unsigned long       AddServerWiringMetaToList   (ServerWiringMeta *p, ULONG count=1) =0;
    virtual unsigned long       AddTableMetaToList          (TableMeta        *p, ULONG count=1) =0;
    virtual unsigned long       AddTagMetaToList            (TagMeta          *p, ULONG count=1) =0;
    virtual unsigned long       AddULongToList              (ULONG            *p, ULONG count)   =0;
                                                                                                 
    virtual const BYTE       *  ByteFromIndex               (ULONG i) const =0;
    virtual const GUID       *  GuidFromIndex               (ULONG i) const =0;
    virtual const WCHAR      *  StringFromIndex             (ULONG i) const =0;
    virtual       ULONG         UI4FromIndex                (ULONG i) const =0;
    virtual const ULONG      *  UI4pFromIndex               (ULONG i) const =0;
                                                                           
    virtual unsigned long       BufferLengthFromIndex       (ULONG i) const =0;
                                                                           
    virtual ColumnMeta       *  ColumnMetaFromIndex         (ULONG i=0)     =0;
    virtual DatabaseMeta     *  DatabaseMetaFromIndex       (ULONG i=0)     =0;
    virtual HashedIndex      *  HashedIndexFromIndex        (ULONG i=0)     =0;
    virtual IndexMeta        *  IndexMetaFromIndex          (ULONG i=0)     =0;
    virtual QueryMeta        *  QueryMetaFromIndex          (ULONG i=0)     =0;
    virtual RelationMeta     *  RelationMetaFromIndex       (ULONG i=0)     =0;
    virtual ServerWiringMeta *  ServerWiringMetaFromIndex   (ULONG i=0)     =0;
    virtual TableMeta        *  TableMetaFromIndex          (ULONG i=0)     =0;
    virtual TagMeta          *  TagMetaFromIndex            (ULONG i=0)     =0;
    virtual ULONG            *  ULongFromIndex              (ULONG i=0)     =0;
    virtual unsigned char    *  PooledDataPointer           ()              =0;

    virtual unsigned long       GetCountColumnMeta          ()        const =0;
    virtual unsigned long       GetCountDatabaseMeta        ()        const =0;
    virtual unsigned long       GetCountHashedIndex         ()        const =0;
    virtual unsigned long       GetCountIndexMeta           ()        const =0;
    virtual unsigned long       GetCountQueryMeta           ()        const =0;
    virtual unsigned long       GetCountRelationMeta        ()        const =0;
    virtual unsigned long       GetCountServerWiringMeta    ()        const =0;
    virtual unsigned long       GetCountTableMeta           ()        const =0;
    virtual unsigned long       GetCountTagMeta             ()        const =0;
    virtual unsigned long       GetCountULONG               ()        const =0;
    virtual unsigned long       GetCountOfBytesPooledData   ()        const =0;

    virtual unsigned long       FindTableBy_TableName(ULONG Table, bool bCaseSensitive=false)           =0;
    virtual unsigned long       FindTableBy_TableName(LPCWSTR wszTable)                                 =0;
    virtual unsigned long       FindColumnBy_Table_And_Index(unsigned long Table, unsigned long Index, bool bCaseSensitive=false)               =0;
    virtual unsigned long       FindColumnBy_Table_And_InternalName(unsigned long Table, unsigned long  InternalName, bool bCaseSensitive=false)=0;
    virtual unsigned long       FindTagBy_Table_And_Index(ULONG iTableName, ULONG iColumnIndex, bool bCaseSensitive=false)                      =0;
};

class TMetaTableBase
{
public:
    TMetaTableBase() {}
    virtual ~TMetaTableBase(){}

    virtual bool    Next()      = 0;
    virtual void    First()     = 0;
    virtual bool    Previous()  = 0;
    virtual void    Reset()     = 0;

    virtual ULONG * Get_pulMetaTable() = 0;
    virtual unsigned long GetCount() const =0;
};

template <class T> class TMetaTable : public TMetaTableBase
{
public:
    TMetaTable(TPEFixup &fixup, ULONG i=0) :
          m_Fixup(fixup),
          m_iCurrent(i),
          m_iFirst(i)
    {
    }
    virtual ~TMetaTable(){}

    virtual bool    Next(){++m_iCurrent;return (m_iCurrent < static_cast<long>(GetCount()));}
    virtual void    First(){m_iCurrent = 0;}
    virtual bool    Previous(){--m_iCurrent; return (m_iCurrent >= 0);}
    virtual void    Reset(){m_iCurrent = m_iFirst;}

    virtual ULONG * Get_pulMetaTable() {return reinterpret_cast<ULONG *>(Get_pMetaTable());}
    virtual T * Get_pMetaTable() = 0;
    virtual unsigned long GetCount() const =0;

protected:
    TPEFixup &  m_Fixup;
    long        m_iCurrent;
    long        m_iFirst;
};


#endif //__TPEFIXUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tpopulatetableschema.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TPOPULATETABLESCHEMA_H__
#define __TPOPULATETABLESCHEMA_H__

//The only non-standard header that we need for the class declaration is TOutput
#ifndef __OUTPUT_H__
    #include "Output.h"
#endif
#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif

//The TableSchemaHeap is layed out as follows, the fixed length data comes first
/*
    ULONG           TableSchemaHeapSignature0
    ULONG           TableSchemaHeapSignature1
    ULONG           CountOfTables                       This is interesting only when no query is supplied and we want to walk through every table (this won't be efficient)
    ULONG           EndOfaTableSchema                   This is the byte offset just beyond the last TableSchema entry.
    HashTableHeader TableNameHashHeader                 This is the hash table that map a TableID to its aTableSchema byte offset (from the beginning of TableSchemaHeap)
    HashedIndex     aHashedIndex[kMaxHashTableSize]     The HashTableHeader contains the modulo (503 is the largest prime less than kMaxHashTableSize) for the hash table; but the table can never grow beyond this pre-allocated space.
                                                        This size was chosen so that the entire hash table would fit into the same page in memory.
---------------------------<Page Boundary>---------------------------
    unsigned char   aTableSchema[]                      This is where each Table's TableSchema goes.  FirstTableID (4096) == &aTableSchema[0] - &TableSchemaHeap, LastTableID == &aTableSchema[CountOfTables-1] - &TableSchemaHeap

One optimization we could do is to make sure that every table's schema (whose size is <=4096) fits into one page.  In other words, minimize TableSchema crossing a page boundary
*/


//This class takes the meta from the old format (TableMeta, ColumnMeta etc.) and puts it into the new format (TableSchema
//which includes CollectionMeta, PropertyMeta etc.)
class TPopulateTableSchema : public ICompilationPlugin, public THeap<ULONG>
{
public:                                                                                                               //cbHeap is the starting size, it will grow if necessary
    TPopulateTableSchema();
    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    TOutput     *   m_pOut;
    TPEFixup    *   m_pFixup;
    SimpleColumnMeta m_scmCollectionMeta[kciTableMetaPublicColumns];
    SimpleColumnMeta m_scmPropertyMeta[kciColumnMetaPublicColumns];
    SimpleColumnMeta m_scmServerWiringMeta[kciServerWiringMetaPublicColumns];
    SimpleColumnMeta m_scmTagMeta[kciTagMetaPublicColumns];

    //This doesn't actually fill in the hash table, it just determines whether the tables will fit into the hashtable and what the modulo is.
    ULONG AddSimpleColumnMetaHeap();
    void DetermineHashTableModulo(ULONG &modulo) const;
    void FillInThePublicColumns(ULONG * o_dest, TTableMeta &i_tablemeta, ULONG * i_source, TPooledHeap &io_pooledHeap, SimpleColumnMeta *o_aSimpleColumnMeta);
};




#endif //__TPOPULATETABLESCHEMA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tquerymeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TQUERYMETA_H__
#define __TQUERYMETA_H__

#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif

/*
struct QueryMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Index;                  //UI4
    ULONG                       CellName;               //String
    ULONG                       Operator;               //UI4
    ULONG                       MetaFlags;              //UI4
};
*/

class TQueryMeta : public TMetaTable<QueryMeta>
{
public:
    TQueryMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<QueryMeta>(fixup,i){}
    const WCHAR *Get_Table           () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Table);}
    const WCHAR *Get_InternalName    () const {return m_Fixup.StringFromIndex(   Get_MetaTable().InternalName);}
    const WCHAR *Get_PublicName      () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicName);}
    const ULONG * Get_Index           () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().Index);}
    const WCHAR *Get_CellName        () const {return m_Fixup.StringFromIndex(   Get_MetaTable().CellName);}
    const ULONG * Get_Operator        () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().Operator);}
    const ULONG * Get_MetaFlags       () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().MetaFlags);}

    virtual QueryMeta * Get_pMetaTable  ()       {return m_Fixup.QueryMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount      () const {return m_Fixup.GetCountQueryMeta();};
    const QueryMeta & Get_MetaTable () const {return *m_Fixup.QueryMetaFromIndex(m_iCurrent);}
};


#endif // __TQUERYMETA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tmetabasemetaxmlfile.h ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMetabaseMetaXmlFile.h
// Author:          Stephenr
// Date Created:    9/22/00
// Description:     This class builds the meta heaps from the MetabaseMeta.XML file and the shipped meta located in the Fixed Tables.
//                  The shipped meta is un alterable.  So if discrepencies appear between the MetabaseMeta.XML file and the shipped
//                  schema, the meta reverts back to what was 'shipped'.
//

#pragma once

#ifndef __STDAFX_H__
    #include "stdafx.h"
#endif
#ifndef __catalog_h__
    #include "catalog.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __TXMLPARSEDFILE_H__
    #include "TXmlParsedFile.h"
#endif
#ifndef __TMSXMLBASE_H__
    #include "TMSXMLBase.h"
#endif
#ifndef _IISCNFG_H_
    #include "iiscnfg.h"
#endif

class TMetabaseMetaXmlFile :
    public  TFixupHeaps,
    public  TMSXMLBase,
    public  TXmlParsedFileNodeFactory
{
public:
    TMetabaseMetaXmlFile(const FixedTableHeap *pShippedSchemaHeap, LPCWSTR wszXmlFile, ISimpleTableDispenser2 *pISTDispenser, TOutput &out);

//TXmlParsedFileNodeFactory
    virtual HRESULT  CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const {return TMSXMLBase::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);}
    virtual HRESULT  CreateNode      (const TElement &Element);

private:
    //
    //Private types
    //

    //This private class is designed to deal with strings returned from NodeFactory.
    //These strings are NOT NULL terminated.  We need a way of passing them around easily
    //and as one entity.  Also we need to do alot of comparing.
    struct TSizedString
    {
        TSizedString() : m_str(0), m_cch(0){}
        TSizedString(const WCHAR *wsz) : m_str(wsz)
        {
            ASSERT(0 != wsz);
            m_cch = (DWORD) wcslen(wsz);
        }
        void operator =(const WCHAR *wsz)
        {
            ASSERT(0 != wsz);
            m_str = wsz;
            m_cch = (DWORD) wcslen(wsz);
        }
        bool IsEqualCaseInsensitive(const WCHAR *wsz) const
        {
            ASSERT(0 != wsz);

            const WCHAR *pstr = m_str;
            ULONG i;
            for(i=0;i<m_cch;++i, ++pstr, ++wsz)
            {
                if(ToLower(*wsz) != ToLower(*pstr))
                    return false;
            }
            return (0 == *wsz);//if the next character in the wsz is the terminating NULL then we have a match.
        }
        bool IsEqual(const WCHAR *wsz, ULONG cch) const
        {
            return (m_cch==cch && 0==memcmp(wsz, m_str, m_cch*sizeof(WCHAR)));
        }
        bool IsEqual(const WCHAR *wsz) const
        {
            ASSERT(0 != wsz);
            ULONG cch = (ULONG) wcslen(wsz);
            return (m_cch==cch && 0==memcmp(wsz, m_str, m_cch*sizeof(WCHAR)));
        }
        bool IsEqual(const TSizedString &str) const
        {
            return (m_cch==str.m_cch && 0==memcmp(str.m_str, m_str, m_cch*sizeof(WCHAR)));
        }
        bool IsEqual(const TElement &element) const
        {
            return (m_cch==element.m_ElementNameLength && 0==memcmp(element.m_ElementName, m_str, m_cch*sizeof(WCHAR)));
        }
        ULONG ToUI4() const
        {
            if(0 == m_str)
                return 0;
            return _wtol(m_str);//m_str is always of the form 123"  
        }
        bool IsNULL() const
        {
            return (0 == m_str);
        }
        //The members are public so I didn't have to declare a bunch of casting operators
        //or accessor functions.  It is useful to say if(0!=mystring.m_str)memcpy(pFoo, mystring.m_str, mystring.m_cch*sizeof(WCHAR));
        LPCWSTR GetString() const
        {
            return m_str;
        }
        DWORD GetStringLength() const
        {
            return m_cch;
        }
    private:
        DWORD   m_cch;
        LPCWSTR m_str;
    };

    struct TAttr : public TAttribute
    {
        TAttr(){}
        const TSizedString & Name()  const {return *reinterpret_cast<const TSizedString *>(this);}
        const TSizedString & Value() const {return *(reinterpret_cast<const TSizedString *>(this)+1);}
        bool  IsNULL() const {return Name().IsNULL();}
    };


    //
    //Private consts
    //
    enum eParsingState
    {
        eLookingForTheMetabaseDatabase,
        eLookingForTheIIsConfigObjectTable,
        eLookingForGlobalProperties,
        eLookingForCollectionOrInheritedProperties
    };
    enum eParsedLevel
    {
        eConfigurationLevel,
        eDatabaseMetaLevel,
        eCollectionLevel,
        eProperytLevel,
        eTagLevel
    };
    enum
    {
        kcStaticUI4HeapEntries  = 429,
        kPrimeModulo            = 4831,
        kLargestReservedID      = IIS_MD_ADSI_METAID_BEGIN
    };

    const TSizedString    m_Attributes;
    const TSizedString    m_BaseVersion;
    const TSizedString    m_CharacterSet;
    const TSizedString    m_Collection;
    const TSizedString    m_ContainerClassList;
    const TSizedString    m_DatabaseMeta;
    const TSizedString    m_DefaultValue;
	const TSizedString	m_Description;
    const TSizedString    m_EndingNumber;
    const TSizedString    m_Enum;
    const TSizedString    m_ExtendedVersion;
    const TSizedString    m_Flag;
    const TSizedString    m_ID;
    const TSizedString    m_IIsConfigObject;
    const TSizedString    m_InheritsPropertiesFrom;
    const TSizedString    m_InternalName;
    const TSizedString    m_Meta;
    const TSizedString    m_Metabase;
    const TSizedString    m_MetabaseBaseClass;
    const TSizedString    m_MetaFlags;
    const TSizedString    m_NameColumn;
    const TSizedString    m_NavColumn;
    const TSizedString    m_Property;
    const TSizedString    m_PublicName;
	const TSizedString    m_PublicColumnName;
    const TSizedString    m_PublicRowName;
    const TSizedString    m_SchemaGeneratorFlags;
    const TSizedString    m_Size;
    const TSizedString    m_StartingNumber;
    const TSizedString    m_Type;
    const TSizedString    m_UserType;
    const TSizedString    m_Value;


    //
    //Private non const variables
    //
    TSmartPointerArray <bool>   m_aBoolShippedTables;
    ULONG                       m_aiUI4[kcStaticUI4HeapEntries];
    ULONG                       m_iColumnMeta_Location;
    ULONG                       m_iCurrentColumnIndex;
    ULONG                       m_iCurrentDatabaseName;
    ULONG                       m_iCurrentTableName;
    ULONG                       m_iCurrentTableMeta;
    ULONG                       m_iTableName_IIsConfigObject;
    ULONG                       m_iLastShippedCollection;
    ULONG                       m_iLastShippedProperty;
    ULONG                       m_iLastShippedTag;
    ULONG                       m_LargestID;
    ULONG                       m_NextColumnIndex;
    TOutput &                   m_out;
    const FixedTableHeap *      m_pShippedSchemaHeap;
    eParsingState               m_State;

    CComQIPtr<IAdvancedTableDispenser, &IID_IAdvancedTableDispenser> m_spISTAdvancedDispenser;
    CComPtr<ISimpleTableRead2>      m_spISTTagMeta;
    CComPtr<ISimpleTableRead2>      m_spISTColumnMeta;
    CComPtr<ISimpleTableRead2>      m_spISTColumnMetaByID;
    CComPtr<ISimpleTableRead2>      m_spISTTableMeta;

    TPooledHeap                 m_HeapPooledUserDefinedID;
    ULONG                       m_ipoolPrevUserDefinedID;
    LPCWSTR                     m_wszXmlFile;

    //
    //Private methods
    //
    void            AddColumnMetaByReference(ULONG iColumnMeta_Source);
    void            AddColumnMetaToHeap(const TElement &i_Element, ULONG i_iColumnInternalName);
    void            AddColumnMetaViaReferenceToHeap(const TElement &i_Element);
    ULONG           AddMergedContainerClassListToList(const TSizedString *i_pContainerClassList, LPCWSTR i_wszContainerClassListShipped, ULONG i_cchContainerClassListShipped, bool &o_bExtended);
    void            AddServerWiringMetaToHeap(ULONG iTableName, bool i_bFixedInterceptor=false);
    void            AddShippedColumnMetaToHeap(ULONG i_iTableName, const ColumnMeta *i_pColumnMeta);
    void            AddShippedIndexMetaToHeap(ULONG i_iTableName, const IndexMeta *i_pIndexMeta);
    void            AddShippedTableMetaToHeap(const TableMeta *i_pTableMeta, bool i_bFixedInterceptor=false, const TSizedString *i_pContainerClassList=0);
    void            AddShippedTagMetaToHeap(ULONG i_iTableName, ULONG i_iColumnIndex, const TagMeta *i_pTagMeta);
    ULONG           AddStringToHeap(const TSizedString &i_str);
    void            AddTableMetaToHeap(const TElement &i_Element);
    void            AddTagMetaToHeap(const TElement &i_Element);
    unsigned long   AddUI4ToList(ULONG ui4);
    unsigned long   AddWCharToList(LPCWSTR wsz, unsigned long cwchar=-1);
    void            BuildDatabaseMeta(const DatabaseMeta * &o_pDatabaseMeta_METABASE);
    void            CheckForOverrridingColumnMeta(const TElement &i_Element, ULONG i_iColumnMetaToOverride);
    void            ConvertWideCharsToBytes(LPCWSTR string, unsigned char *pBytes, unsigned long length);
    ULONG           FindUserDefinedPropertyBy_Table_And_InternalName(unsigned long Table, unsigned long  InternalName);
    const TOLEDataTypeToXMLDataType * Get_OLEDataTypeToXMLDataType(const TSizedString &i_str);
    const TAttr &   GetAttribute(const TElement &i_Element, const TSizedString &i_AttrName);
    ULONG           GetDefaultValue(const TElement &i_Element, ColumnMeta & columnmeta);
    void            PresizeHeaps();
    bool            ShouldAddColumnMetaToHeap(const TElement &Element, ULONG iColumnInternalName);
    ULONG           StringToEnumValue(const TSizedString &i_strValue, LPCWSTR i_wszTable, ULONG i_iColumn, bool bAllowNumeric=false);
    ULONG           StringToFlagValue(const TSizedString &i_strValue, LPCWSTR i_wszTable, ULONG i_iColumn);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tregistermachineconfigdirectory.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TREGISTERMACHINECONFIGDIRECTORY_H__
#define __TREGISTERMACHINECONFIGDIRECTORY_H__

class TRegisterMachineConfigDirectory
{
public:
    TRegisterMachineConfigDirectory(LPCWSTR wszProductName, LPCWSTR wszMachineConfigDir, TOutput &out);

};

#endif// __TREGISTERMACHINECONFIGDIRECTORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tregisterproductname.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TREGISTERPRODUCTNAME_H__
    #include "TRegisterProductName.h"
#endif


TRegisterProductName::TRegisterProductName(LPCWSTR wszProductName, LPCWSTR wszCatalogDll, TOutput &out)
{
    WCHAR wszFullyQualifiedCatalogDll[4096];
    //VerifyFileExists
    if(NULL == wcsrchr(wszCatalogDll, L':') && !(wszCatalogDll[0]==L'\\' && wszCatalogDll[1]==L'\\'))
    {//If we didn't find a L':' and the filename isn't a UNC then we need to turn the DLL into a fully qualified filename
        GetModuleFileName(NULL, wszFullyQualifiedCatalogDll, sizeof(wszFullyQualifiedCatalogDll)/sizeof(WCHAR));
        *(wcsrchr(wszFullyQualifiedCatalogDll, L'\\')+1)= 0x00;
        wcscat(wszFullyQualifiedCatalogDll, wszCatalogDll);
    }
    else
    {
        wcscpy(wszFullyQualifiedCatalogDll, wszCatalogDll);
    }
    if(-1 == GetFileAttributes(wszFullyQualifiedCatalogDll))
    {
        out.printf(L"Error - Catalog DLL file not found (%s).\n", wszCatalogDll);
        THROW(ERROR - FILE NOT FOUND);
    }

    HKEY        hkeyCatalog42;
	HKEY        hkeyProduct;
	LPCWSTR     wszCatalogDllKey = L"Dll";
 
    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Catalog42", &hkeyCatalog42))
    {
        out.printf(L"Error - Unable to open registry key HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Catalog42\n");
        THROW(ERROR - UNABLE TO OPEN REGISTRY KEY);
    }
    if(ERROR_SUCCESS != RegCreateKey(hkeyCatalog42, wszProductName, &hkeyProduct))
    {
        out.printf(L"Error - Unable to create registry key HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Catalog42\\%s\n", wszProductName);
        THROW(ERROR - UNABLE TO CREATE REGISTRY KEY);
    }
    if(ERROR_SUCCESS != RegSetValueEx(hkeyProduct, wszCatalogDllKey, 0, REG_SZ, reinterpret_cast<CONST BYTE *>(wszFullyQualifiedCatalogDll), sizeof(WCHAR)*((ULONG)wcslen(wszFullyQualifiedCatalogDll)+1)))
    {
        out.printf(L"Error - Unable to Set HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Catalog42\\%s\\%s to %s\n", wszProductName, wszCatalogDllKey, wszFullyQualifiedCatalogDll);
        THROW(ERROR - UNABLE TO SET REGISTRY VALUE);
    }
    out.printf(L"Product(%s) associated wih Catalog Dll:\n\t(%s).\n", wszProductName, wszFullyQualifiedCatalogDll);

	RegCloseKey(hkeyProduct);
	RegCloseKey(hkeyCatalog42);

    RegisterEventLogSource(wszProductName, wszFullyQualifiedCatalogDll, out);
}

void TRegisterProductName::RegisterEventLogSource(LPCWSTR wszProductName, LPCWSTR wszFullyQualifiedCatalogDll, TOutput &out) const
{
	LPCWSTR     wszEventMessageFile = L"EventMessageFile";
    LPCWSTR     wszTypesSupported   = L"TypesSupported";
    DWORD       seven               = 7;
 

    HKEY        hkeySystemLog;
    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System", &hkeySystemLog))
    {
        out.printf(L"Error - Unable to open registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\n");
        THROW(ERROR - UNABLE TO OPEN REGISTRY KEY);
    }

    HKEY        hkeyCOMConfigSystemLog;
    //@@@This mechanism doesn't support side by side operation (SR 11/08/99)
    //In the future, 'COM+ Config' will probaby change to 'ProductName:COM+ Config' so that more than one Config DLL can be in the system.
    if(ERROR_SUCCESS != RegCreateKey(hkeySystemLog, L"COM+ Config", &hkeyCOMConfigSystemLog))
    {
        out.printf(L"Error - Unable to create registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\%s\n", L"COM+ Config");
        THROW(ERROR - UNABLE TO CREATE REGISTRY KEY);
    }
    if(ERROR_SUCCESS != RegSetValueEx(hkeyCOMConfigSystemLog, wszEventMessageFile, 0, REG_SZ, reinterpret_cast<CONST BYTE *>(wszFullyQualifiedCatalogDll), sizeof(WCHAR)*((ULONG)wcslen(wszFullyQualifiedCatalogDll)+1)))
    {
        out.printf(L"Error - Unable to Set HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\%s\\%s to %s\n", L"COM+ Config", wszEventMessageFile, wszFullyQualifiedCatalogDll);
        THROW(ERROR - UNABLE TO SET REGISTRY VALUE);
    }
    if(ERROR_SUCCESS != RegSetValueEx(hkeyCOMConfigSystemLog, wszTypesSupported, 0, REG_DWORD, reinterpret_cast<CONST BYTE *>(&seven), sizeof(DWORD)))
    {
        out.printf(L"Error - Unable to Set HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\%s\\%s to %d\n", L"COM+ Config", wszTypesSupported, seven);
        THROW(ERROR - UNABLE TO SET REGISTRY VALUE);
    }

    out.printf(L"Product(%s) registered with the system event log.\n", wszProductName, wszFullyQualifiedCatalogDll);

	RegCloseKey(hkeyCOMConfigSystemLog);





    HKEY        hkeyApplicationLog;
    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application", &hkeyApplicationLog))
    {
        out.printf(L"Error - Unable to open registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\n");
        THROW(ERROR - UNABLE TO OPEN REGISTRY KEY);
    }

    HKEY        hkeyCOMConfigApplicationLog;
    //@@@This mechanism doesn't support side by side operation (SR 11/08/99)
    //In the future, 'COM+ Config' will probaby change to 'ProductName:COM+ Config' so that more than one Config DLL can be in the system.
    if(ERROR_SUCCESS != RegCreateKey(hkeyApplicationLog, L"COM+ Config", &hkeyCOMConfigApplicationLog))
    {
        out.printf(L"Error - Unable to create registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\%s\n", L"COM+ Config");
        THROW(ERROR - UNABLE TO CREATE REGISTRY KEY);
    }
    if(ERROR_SUCCESS != RegSetValueEx(hkeyCOMConfigApplicationLog, wszEventMessageFile, 0, REG_SZ, reinterpret_cast<CONST BYTE *>(wszFullyQualifiedCatalogDll), sizeof(WCHAR)*((ULONG)wcslen(wszFullyQualifiedCatalogDll)+1)))
    {
        out.printf(L"Error - Unable to Set HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\%s\\%s to %s\n", L"COM+ Config", wszEventMessageFile, wszFullyQualifiedCatalogDll);
        THROW(ERROR - UNABLE TO SET REGISTRY VALUE);
    }
    if(ERROR_SUCCESS != RegSetValueEx(hkeyCOMConfigApplicationLog, wszTypesSupported, 0, REG_DWORD, reinterpret_cast<CONST BYTE *>(&seven), sizeof(DWORD)))
    {
        out.printf(L"Error - Unable to Set HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\%s\\%s to %d\n", L"COM+ Config", wszTypesSupported, seven);
        THROW(ERROR - UNABLE TO SET REGISTRY VALUE);
    }

    out.printf(L"Product(%s) registered with the application event log.\n", wszProductName, wszFullyQualifiedCatalogDll);

	RegCloseKey(hkeyCOMConfigApplicationLog);
	RegCloseKey(hkeySystemLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tregisterproductname.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TREGISTERPRODUCTNAME_H__
#define __TREGISTERPRODUCTNAME_H__

class TRegisterProductName
{
public:
    TRegisterProductName(LPCWSTR wszProductName, LPCWSTR wszCatalogDll, TOutput &out);

    void RegisterEventLogSource(LPCWSTR wszProductName, LPCWSTR wszFullyQualifiedCatalogDll, TOutput &out) const;
};

#endif// __TREGISTERPRODUCTNAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tregistermachineconfigdirectory.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TREGISTERMACHINECONFIGDIRECTORY_H__
    #include "TRegisterMachineConfigDirectory.h"
#endif


TRegisterMachineConfigDirectory::TRegisterMachineConfigDirectory(LPCWSTR wszProductName, LPCWSTR wszMachineConfigDir, TOutput &out)
{
 
    HKEY		hkeyCatalog42;
	HKEY		hkeyProduct;
	LPCWSTR		wszMachineConfigDirKey = L"MachineConfigDirectory";
 
    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Catalog42", &hkeyCatalog42))
    {
        out.printf(L"Error - Unable to open registry key HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Catalog42\n");
        THROW(ERROR - UNABLE TO OPEN REGISTRY KEY);
    }
    if(ERROR_SUCCESS != RegCreateKey(hkeyCatalog42, wszProductName, &hkeyProduct))
    {
        out.printf(L"Error - Unable to open registry key HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Catalog42\\%s\n", wszProductName);
        THROW(ERROR - UNABLE TO OPEN REGISTRY KEY);
    }
    if(wszMachineConfigDir && wszMachineConfigDir[0])
    {
        if(ERROR_SUCCESS != RegSetValueEx(hkeyProduct, wszMachineConfigDirKey, 0, REG_SZ, reinterpret_cast<CONST BYTE *>(wszMachineConfigDir), sizeof(WCHAR)*((ULONG)wcslen(wszMachineConfigDir)+1)))
        {
            out.printf(L"Error - Unable to Set HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Catalog42\\%s\\%s to %s\n", wszProductName, wszMachineConfigDirKey, wszMachineConfigDir);
            THROW(ERROR - UNABLE TO SET REGISTRY VALUE);
        }
        out.printf(L"Product(%s) associated wih Machine Config Directory:\n\t(%s).\n", wszProductName, wszMachineConfigDir);
    }
    else
    {
        if(ERROR_SUCCESS != RegDeleteValue(hkeyProduct, wszMachineConfigDirKey))
        {
            out.printf(L"Warning - Unable to Remove HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Catalog42\\%s\\%s to %s\nThe value may not have existed.\n", wszProductName, wszMachineConfigDirKey, wszMachineConfigDir);
        }
     }

	RegCloseKey(hkeyProduct);
	RegCloseKey(hkeyCatalog42);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tschemageneration.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TSCHEMAGENERATION_H__
#define __TSCHEMAGENERATION_H__


class TSchemaGeneration
{
public:
    TSchemaGeneration(LPCWSTR wszSchemaFilename, TPEFixup &fixup, TOutput &out);
private:
    LPCWSTR         m_wszSchemaFilename;
    TPEFixup      & m_Fixup;
    TOutput       & m_out;
    const LPCWSTR   m_szComCatDataVersion;

    void ProcessMetaXML() const;
    void ProcessMetaTable(TTableMeta &TableMeta, wstring &wstrBeginning) const;
};



#endif // __TSCHEMAGENERATION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\trelationmeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TRELATIONMETA_H__
#define __TRELATIONMETA_H__

#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif

/*
struct RelationMeta
{
    ULONG PRIMARYKEY FOREIGNKEY PrimaryTable;           //String
    ULONG                       PrimaryColumns;         //Bytes
    ULONG PRIMARYKEY FOREIGNKEY ForeignTable;           //String
    ULONG                       ForeignColumns;         //Bytes
    ULONG                       MetaFlags;
};
*/

class TRelationMeta : public TMetaTable<RelationMeta>
{
public:
    TRelationMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<RelationMeta>(fixup,i){}
    const WCHAR *Get_PrimaryTable    () const {return m_Fixup.StringFromIndex(Get_MetaTable().PrimaryTable);}
    const BYTE  * Get_PrimaryColumns  () const {return m_Fixup.ByteFromIndex( Get_MetaTable().PrimaryColumns);}
    const WCHAR *Get_ForeignTable    () const {return m_Fixup.StringFromIndex(Get_MetaTable().ForeignTable);}
    const BYTE  * Get_ForeignColumns  () const {return m_Fixup.ByteFromIndex( Get_MetaTable().ForeignColumns);}
    const ULONG * Get_MetaFlags       () const {return m_Fixup.UI4pFromIndex( Get_MetaTable().MetaFlags);}

    virtual RelationMeta * Get_pMetaTable   ()       {return m_Fixup.RelationMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount          () const {return m_Fixup.GetCountRelationMeta();};
    const RelationMeta & Get_MetaTable () const {return *m_Fixup.RelationMetaFromIndex(m_iCurrent);}
};



#endif // __TRELATIONMETA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\tschemageneration.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TSCHEMAGENERATION_H__
    #include "TSchemaGeneration.h"
#endif
#ifndef __TTABLEMETA_H__
    #include "TTableMeta.h"
#endif
#ifndef __TCOLUMNMETA_H__
    #include "TColumnMeta.h"
#endif
#ifndef __TRELATIONMETA_H__
    #include "TRelationMeta.h"
#endif



TSchemaGeneration::TSchemaGeneration(LPCWSTR wszSchemaFilename, TPEFixup &fixup, TOutput &out) :
                m_Fixup(fixup),
                m_out(out),
                m_szComCatDataVersion(L"ComCatData_v6"),
                m_wszSchemaFilename(wszSchemaFilename)
{
    ProcessMetaXML();
}


void TSchemaGeneration::ProcessMetaXML() const
{
    //<?xml version ="1.0"?>
    //<Schema name = "ComCatData_v5"
    //  xmlns="urn:schemas-microsoft-com:xml-data"
    //  xmlns:dt="urn:schemas-microsoft-com:datatypes"
    //  >
    //
    //  <ElementType name = "configuration" content = "eltOnly" order = "many" model="closed">
    //      <element minOccurs = "0"  maxOccurs = "1"  type = "WIRING"/>
    //      <element minOccurs = "0"  maxOccurs = "1"  type = "BASICCLIENTWIRING"/>
    //  </ElementType>
    //</Schema>

    static wchar_t *wszSchemaBeginning[]={
    L"<?xml version =\"1.0\"?>\n",
    L"<Schema name = \"%s\"\n",
    L"  xmlns=\"urn:schemas-microsoft-com:xml-data\"\n",
    L"  xmlns:dt=\"urn:schemas-microsoft-com:datatypes\">\n\n",
    L"  <ElementType name = \"webconfig\" content = \"eltOnly\" order = \"many\" model=\"open\"/>\n",
    0
    };
    static wchar_t *wszSchemaMiddle[]={
    L"  \n\n",
    L"  <ElementType name = \"configuration\" content = \"eltOnly\" order = \"many\" model=\"open\">\n",
    L"      <element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"%s\"/>\n",
    L"      <element minOccurs = \"0\"  maxOccurs = \"*\"  type = \"%s\"/>\n",
    0
    };
    static wchar_t *wszSchemaEnding[]={
    L"      <element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"webconfig\"/>\n",
    L"  </ElementType>\n",
    L"</Schema>\n",
    0
    };

    //<ColumnMetaTable>
    //    <TableMeta      tidGuidID="_BCD79B13-0DDA-11D2-8A9A-00A0C96B9BB4_"  didInternalName="didCOMCLASSIC"     tidInternalName="tidCOMCLASSIC_PROGIDS"/>
    //    <ColumnMeta     colInternalName="ProgID"                            dbType="WSTR"   cbSize="-1"     ColumnMetaFlags="fCOLUMNMETA_PRIMARYKEY"/>
    //    <ColumnMeta     colInternalName="CLSID"                             dbType="GUID"/>
    //</ColumnMetaTable>

    bool                        bAnyTablesXMLable = false;
    wstring                     wstrBeginning;
    wstring                     wstrMiddle;
    wstring                     wstrEnding;
    wchar_t                     wszTemp[1024];

    int i=0;
    wstrBeginning = wszSchemaBeginning[i++];  //<?xml version =\"1.0\"?>
    wsprintf(wszTemp, wszSchemaBeginning[i++], m_szComCatDataVersion);
    wstrBeginning += wszTemp;               //<Schema name = "ComCatData_v5"
    while(wszSchemaBeginning[i])
        wstrBeginning += wszSchemaBeginning[i++];

    wstrMiddle     = wszSchemaMiddle[0];
    wstrMiddle    += wszSchemaMiddle[1];

    wstrEnding    = L"";
    for(i=0; wszSchemaEnding[i]; i++)
        wstrEnding    += wszSchemaEnding[i];

    TTableMeta TableMeta(m_Fixup);
    for(unsigned long iTable=0; iTable < TableMeta.GetCount(); iTable++, TableMeta.Next())
    {
        if(0 == (*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_EMITXMLSCHEMA))
            continue;//No schema gen for this table

        bAnyTablesXMLable = true;

        if(!TableMeta.IsTableMetaOfColumnMetaTable())
            continue;//There is TableMeta for fixed tables that are NOT ColumnMeta AND there is TableMeta that has no columns (for GUID gen only)

        if(0 == (*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_ISCONTAINED))
        {
            ASSERT(0 != TableMeta.Get_PublicName());
            if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTSCOPEDBYTABLENAME)
                                       //      <element minOccurs = \"0\"  maxOccurs = \"*\"  type = \"PublicRowName\"/>\n",
                wsprintf(wszTemp, wszSchemaMiddle[3], TableMeta.Get_PublicRowName());//if not encapsulated by the TableName then make maxOccurs="*" and use PublicRowName
            else                       //      <element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"tidCOMCLASSIC_PROGIDS\"/>\n",
                wsprintf(wszTemp, wszSchemaMiddle[2], TableMeta.Get_PublicName());
            wstrMiddle    += wszTemp;  
        }

        //Now create a tid*.Schema file for this table
        ProcessMetaTable(TableMeta, wstrBeginning);
    }

    //Only need to create a ComCatData.Schema if one or more tables were flagged as emitXMLSchema
    if(bAnyTablesXMLable)
    {
        wstrBeginning += wstrMiddle;//Cat the Beginning Middle and Ending
        wstrBeginning += wstrEnding;

        TFile(m_wszSchemaFilename, m_out).Write(wstrBeginning, (ULONG) wstrBeginning.length());
        m_out.printf(L"%s Generated.\n", m_wszSchemaFilename);

        m_out.printf(L"Parsing & Validating %s.\n", m_wszSchemaFilename);

        TXmlFile xml;
        xml.Parse(m_wszSchemaFilename, true);
    }
}


void TSchemaGeneration::ProcessMetaTable(TTableMeta &TableMeta, wstring &wstrBeginning) const
{
    ASSERT(TableMeta.IsTableMetaOfColumnMetaTable());//This shouldn't be called unless there are rows in the ColumnMeta table

    //  <ElementType name = "PublicTableName" content = "eltOnly" order = "seq" model="closed">
    //      <element type = "PublicRowName" minOccurs = "0" maxOccurs = "*"/>
    //  </ElementType>
    //  <ElementType name = "PublicRowName" content = "empty" model="closed">
    //      <AttributeType name = "iBTW_TID" dt:type="uuid" required = "yes"/>
    //      <attribute type = "iBTW_TID"/>
    //      <AttributeType name = "iBTW_DTDISPENSER" dt:type="uuid" required = "no"/>
    //      <attribute type = "iBTW_DTDISPENSER"/>
    //      <AttributeType name = "iBTW_DTLOCATOR" dt:type="string" required = "no"/>
    //      <attribute type = "iBTW_DTLOCATOR"/>
    //      <AttributeType name = "iBTW_LTDISPENSER" dt:type="idref" required = "no"/>
    //      <attribute type = "iBTW_LTDISPENSER"/>
    //      <AttributeType name = "iBTW_FLAGS" dt:type="ui4" required = "yes"/>
    //      <attribute type = "iBTW_FLAGS"/>
    //      <AttributeType name = "iBTW_CATSRVIID" dt:type="idref" required = "no"/>
    //      <attribute type = "iBTW_CATSRVIID"/>
    //  </ElementType>

    static wchar_t *wszSchemaBeginning[]={
    L"  <ElementType name = \"%s\" content = \"eltOnly\" order = \"seq\" model=\"closed\">\n",
    L"      <element type = \"%s\" minOccurs = \"0\" maxOccurs = \"*\"/>\n",
    L"  </ElementType>\n",
    L"  <ElementType name = \"%s\" content = \"%s\" order = \"many\" model=\"closed\">\n",
    L"  <ElementType name = \"%s\" content = \"empty\" order = \"seq\" model=\"open\"/>\n",
    L"      <element type = \"%s\" minOccurs = \"0\" maxOccurs = \"1\"/>\n",
    0
    };

    static wchar_t *wszSchemaMiddle[]={
    L"      <AttributeType name = \"%s\" dt:type=\"%s\" required = \"%s\"/><attribute type = \"%s\"/>\n",
	L"      <AttributeType name = \"%s\" dt:type=\"enumeration\" dt:values=\"%s\" required = \"%s\"/><attribute type = \"%s\"/>\n",
	L"      <AttributeType name = \"%s\" dt:type=\"enumeration\" dt:values=\"0 1 False True false true FALSE TRUE No Yes no yes NO YES\" required = \"no\" default=\"0\"/><attribute type = \"%s\"/>\n"
    };

    static wchar_t *wszSchemaEnding[]={
    L"      <element minOccurs = \"0\"  maxOccurs = \"*\"  type = \"%s\"/>\n",
    L"      <element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"%s\"/>\n",
    L"  </ElementType>\n",
    0
    };

    wstring                         wstrMiddle;
    wstring                         wstrEnding;
    wstring                         wstrSparseElement;
    wchar_t                         wszTemp[1024];

    int i=0;

    if(0 == (*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTSCOPEDBYTABLENAME))
    {   //We only have the TableName element if the fTABLEMETA_NOTSCOPEDBYTABLENAME bit is NOT set.
        if(-1 != *TableMeta.Get_PublicRowNameColumn())
        {
            wsprintf(wszTemp, wszSchemaBeginning[4], TableMeta.Get_PublicName());
            wstrBeginning += wszTemp;                              //<ElementType name = \"%s\" content = \"empty\" order = \"seq\" model=\"open\"/>
            return;//This is all we want to do if the table uses and enum as the PublicRowName, since we won't be able to validate it with XML schema.
        }
        wsprintf(wszTemp, wszSchemaBeginning[i++], TableMeta.Get_PublicName());
        wstrBeginning += wszTemp;                              //<ElementType name = "PublicTableName" content = "eltOnly" order = "seq" model="closed">
        ASSERT(0 != TableMeta.Get_PublicRowName());
        wsprintf(wszTemp, wszSchemaBeginning[i++], TableMeta.Get_PublicRowName());
        wstrBeginning += wszTemp;                              //    <element type = "PublicRowName" minOccurs = "0" maxOccurs = "*"/>
#if 0        
        if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NAMEVALUEPAIRTABLE)
        {//If this is a name value pair table, it may have a corresponding Sparse table.  If so, we need to declare the GROUP elements here
            TTableMeta TableMetaSparse(m_Fixup);                             //It's OK to compare pointers here since the strings are pooled (like strings have like pointers).
            ULONG iTableMetaSparse;
            for(iTableMetaSparse=0;iTableMetaSparse<TableMetaSparse.GetCount();++iTableMetaSparse,TableMetaSparse.Next())
                if(0 == wcscmp(TableMetaSparse.Get_Database(), L"NAMEVALUE") && TableMetaSparse.Get_PublicName()==TableMeta.Get_PublicName())
                    break;
            if(iTableMetaSparse != TableMetaSparse.GetCount())
            {
                TColumnMeta ColumnMetaSparse(m_Fixup, TableMetaSparse.Get_iColumnMeta() + *TableMetaSparse.Get_PublicRowNameColumn());

                TTagMeta    TagMetaGroupColumn(ColumnMetaSparse.Get_iTagMeta(), m_Fixup);
                for(ULONG iTabMetaGroupColumn=0; iTabMetaGroupColumn<ColumnMetaSparse.Get_ciTagMeta(); ++iTabMetaGroupColumn, TagMetaGroupColumn.Next())
                {
                    wsprintf(wszTemp, wszSchemaBeginning[i], TagMetaGroupColumn.Get_PublicName());//maxOccurs is 1 since the Group is the ONLY primarykey
                    wstrBeginning += wszTemp;                              //    <element type = "EnumPublicRowName" minOccurs = "0" maxOccurs = "1"/>


                    //Now define the element as it's used in the Sparse table
                    wsprintf(wszTemp, wszSchemaBeginning[4], TagMetaGroupColumn.Get_PublicName(), L"empty");//No tables may be contained beneath a Sparse table.
                    wstrSparseElement += wszTemp;

                    //OK, now we need to find out which of the columns may exist within this element.  This is defined by the NameValueMeta.
                    //Those well-known names whose GROUP column equals this enum
                    {
                        //First, figure out which column index represents the NAME column
                        TColumnMeta ColumnMeta(m_Fixup, TableMeta.Get_iColumnMeta());
                        ULONG iGroupColumn = -1;
                        ULONG iNameColumn = -1;
                        ULONG iTypeColumn = -1;
                        for(ULONG iColumn=0; (iNameColumn == -1) && (iGroupColumn == -1) && iColumn<*TableMeta.Get_CountOfColumns(); ++iColumn, ColumnMeta.Next())
                        {
                            if(fCOLUMNMETA_USEASGROUPOFNVPAIR & ColumnMeta.Get_SchemaGeneratorFlags())
                                iGroupColumn = iColumn;
                            if(fCOLUMNMETA_USEASNAMEOFNVPAIR & ColumnMeta.Get_SchemaGeneratorFlags())
                                iNameColumn = iColumn;
                            if(fCOLUMNMETA_USEASTYPEOFNVPAIR & ColumnMeta.Get_SchemaGeneratorFlags())
                                iTypeColumn = iColumn;
                        }
                        
                        TTableMeta TableMeta_WellKnownName(iTableMetaSparse-1, m_Fixup);
                        for(ULONG iRow=0; iRow<TableMeta_WellKnownName.Get_ciRows(); ++iRow)
                        {
                            if(m_Fixup.UI4FromIndex(m_Fixup.aULong[iRow + iGroupColumn]) == *TagMetaGroupColumn.Get_Value())
                            {//If the group column == the value of the current tag, then this well-known name need an attribute declared for it.

                                wsprintf(wszTemp, wszSchemaBeginning[5], TagMetaGroupColumn.Get_PublicName());//maxOccurs is 1 since the Group is the ONLY primarykey

                                for(int iOLEDataType=0;OLEDataTypeToXMLDataType[iOLEDataType].MappedString != 0;iOLEDataType++)
                                {   //map the well-known's type to the XML type
                                    if(OLEDataTypeToXMLDataType[iOLEDataType].dbType == m_Fixup.UI4FromIndex(m_Fixup.aULong[iRow + iTypeColumn]))
                                        break;
                                }
                                ASSERT(OLEDataTypeToXMLDataType[iOLEDataType].MappedString != 0);//we should never make it through the list

                                //<AttributeType name = \"ProgID\" dt:type=\"string\" required = \"no\"/><attribute type = \"ProgID\"/>
                                wsprintf(wszTemp, wszSchemaMiddle[0], TagMetaGroupColumn.Get_PublicName(), OLEDataTypeToXMLDataType[iOLEDataType].MappedString, L"no", TagMetaGroupColumn.Get_PublicName());
                                wstrSparseElement += wszTemp;
                            }
                        }
                    }
                }

                ++i;
            }
        }
#endif
        wstrBeginning += wszSchemaBeginning[i++];                     //</ElementType>
    }
    else
    {
        if(-1 != *TableMeta.Get_PublicRowNameColumn())//EnumPublicRowName that aren't scoped by their table name are ignored and the parent table MUST change the namespace to NULL to turn off validation
            return;
    }

    bool bHasContainment = false;
    //Before we put the end tag, we need to see if there are any tables that are contained under this element.
    //We search the relation meta for foreign keys that point to this table's primary key first, then check that table's MetaFlags for ISCONTAINED
    TRelationMeta RelationMeta(m_Fixup);
    unsigned long iRelationMeta=0;
    for(; iRelationMeta<RelationMeta.GetCount(); ++iRelationMeta, RelationMeta.Next())
    {
        if(RelationMeta.Get_PrimaryTable() == TableMeta.Get_InternalName() && (fRELATIONMETA_USECONTAINMENT & *RelationMeta.Get_MetaFlags()))//No need for string compares, the pointer compare will suffice
        {//If this is our table then we obviously have another table that points to us via foreign key containment.
            TTableMeta ForeignTableMeta(m_Fixup);
            unsigned long iTable=0;
            for(; iTable < ForeignTableMeta.GetCount(); iTable++, ForeignTableMeta.Next())
            {
                if(RelationMeta.Get_ForeignTable() == ForeignTableMeta.Get_InternalName())
                    break;//No need for string compares, the pointer compare will suffice
            }
            ASSERT(iTable < ForeignTableMeta.GetCount());//We should never make it through the list
            ASSERT(0 != (*ForeignTableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_ISCONTAINED));

	        if(-1 == *ForeignTableMeta.Get_PublicRowNameColumn())//EnumPublicRowName can't be validated so don't do anything for them
			{
				bHasContainment = true;

				if(*ForeignTableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTSCOPEDBYTABLENAME)
				{
					if(ForeignTableMeta.Get_PublicRowName())//If EnumPublicRowName then this will be NULL, but the encapsulating element must be namespaced as NULL anyway so it won't be validated
					{
						wsprintf(wszTemp, wszSchemaEnding[0], ForeignTableMeta.Get_PublicRowName());//<element minOccurs = \"0\"  maxOccurs = \"*\"  type = \"PublicRowName\"/>\n",
						wstrEnding += wszTemp;
					}
				}
				else
				{
					wsprintf(wszTemp, wszSchemaEnding[1], ForeignTableMeta.Get_PublicName());//<element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"PublicName\"/>\n",
					wstrEnding += wszTemp;
				}
			}
        }
    }
    //If this table is contained then some of the attributes will be omitted from this table, since they are implied from the PrimaryTable they point to.
    if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_ISCONTAINED)
    {
        RelationMeta.Reset();
        for(iRelationMeta=0; iRelationMeta<RelationMeta.GetCount(); ++iRelationMeta, RelationMeta.Next())
        {
            if((fRELATIONMETA_USECONTAINMENT & *RelationMeta.Get_MetaFlags()) && (RelationMeta.Get_ForeignTable() == TableMeta.Get_InternalName()))
                break;
        }
        ASSERT(iRelationMeta<RelationMeta.GetCount() && "Chewbacca!  We didn't find the RelationMeta with this table as the foreign table");
    }//So we stopped on the relationship of interest:  if this table ISCONTAINED then we need the RelationMeta to find out which Attributes DON'T exist at this element


    wstrEnding    += wszSchemaEnding[2];                   //</ElementType>
    wsprintf(wszTemp, wszSchemaBeginning[3], TableMeta.Get_PublicRowName(), bHasContainment ? L"eltOnly" : L"empty");
    wstrBeginning += wszTemp;                              //<ElementType name = "PublicRowName" content = "empty" model="closed">

    wstrMiddle    = L"";

    int     iOLEDataTypeIndex;
    bool    bColumnMetaFound = false;

    TColumnMeta ColumnMeta(m_Fixup, TableMeta.Get_iColumnMeta());
    for(unsigned long iColumn=0; iColumn < *TableMeta.Get_CountOfColumns(); iColumn++, ColumnMeta.Next())
    {
        //AddAttributeDeclaration(TableMeta, ColumnMeta, RelationMeta, wstrMiddle);

        //If one of the column meta flags indicated is NOTPERSISTABLE then we can bail on this one.
        if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTPERSISTABLE)
            continue;
        if((*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_ISCONTAINED) && (*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FOREIGNKEY))
        {
            bool bColumnFound = false;
            const ULONG * pForeignColumns = reinterpret_cast<const ULONG *>(RelationMeta.Get_ForeignColumns());
            for(unsigned int i=0; i<pForeignColumns[-1]/4 && !bColumnFound; ++i)//I happen to know that the byte pool store the length (in bytes) as a ULONG preceeding the bytes.
            {
                bColumnFound = (pForeignColumns[i] == iColumn);
            }
            if(bColumnFound)//If this column is one of the foreign key inferred from containment then move on to the next column
                continue;
        }
        bColumnMetaFound = true;

        for(int iOLEDataType=0;OLEDataTypeToXMLDataType[iOLEDataType].MappedString != 0;iOLEDataType++)
        {
            if(OLEDataTypeToXMLDataType[iOLEDataType].dbType == *ColumnMeta.Get_Type())
                break;
        }
        ASSERT(OLEDataTypeToXMLDataType[iOLEDataType].MappedString != 0);//we should never make it through the list

        //<AttributeType name = \"ProgID\" dt:type=\"string\" required = \"no\"/><attribute type = \"ProgID\"/>
        if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_ENUM)
        {
            wstring wstrEnumValues;
            unsigned int cTags=ColumnMeta.Get_ciTagMeta();
            
            TTagMeta TagMeta(m_Fixup, ColumnMeta.Get_iTagMeta());

            while(cTags--)//This builds a string of the enums separated by a space
            {
                wstrEnumValues += TagMeta.Get_PublicName();
                wstrEnumValues += L" ";
                TagMeta.Next();
            }

            wsprintf(wszTemp, wszSchemaMiddle[1], ColumnMeta.Get_PublicName(), wstrEnumValues.c_str(), ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue()) ? L"yes" : L"no", ColumnMeta.Get_PublicName());
            wstrMiddle += wszTemp;
        }
        else if(*ColumnMeta.Get_MetaFlags() & (fCOLUMNMETA_FLAG | fCOLUMNMETA_BOOL))
        {
            wsprintf(wszTemp, wszSchemaMiddle[0], ColumnMeta.Get_PublicName(), L"string", ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue()) ? L"yes" : L"no", ColumnMeta.Get_PublicName());
            wstrMiddle += wszTemp;
        }
        else
        {
            wsprintf(wszTemp, wszSchemaMiddle[0], ColumnMeta.Get_PublicName(), OLEDataTypeToXMLDataType[iOLEDataType].MappedString, OLEDataTypeToXMLDataType[iOLEDataType].bImplicitlyRequired || ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue()) ? L"yes" : L"no", ColumnMeta.Get_PublicName());
            wstrMiddle += wszTemp;
        }

    }
    if(!bColumnMetaFound)
    {
        if(bHasContainment)
            m_out.printf(L"Warning! Emit XML Schema was specified but no column meta found for '%s'.\r\n",
                        TableMeta.Get_PublicName());
        else
        {
            m_out.printf(L"Emit XML Schema was specified but no column meta found for '%s'.  At least one persistable column must exist in uncontained tables.\r\n",
                        TableMeta.Get_PublicName());
            THROW(Emit XML Schema was set but no ColumnMeta found.);
        }
    }

    wstrBeginning += wstrMiddle;
    wstrBeginning += wstrEnding;
    wstrBeginning += wstrSparseElement;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\ttableinfogeneration.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TTABLEINFOGENERATION_H__
#define __TTABLEINFOGENERATION_H__


class TTableInfoGeneration
{
public:
    TTableInfoGeneration(LPCWSTR szFilename, TPEFixup &fixup, TOutput &out);
private:
    TPEFixup      & m_Fixup;
    TOutput       & m_out;
    LPCWSTR         m_szFilename;
    LPCWSTR         m_szTableInfoDefine;

    void GetColumnEnumFromColumnNameAndTagName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPCWSTR wszTagName, LPWSTR wszEnumName) const;
    void GetColumnFlagFromColumnNameAndTagName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPCWSTR wszTagName, LPWSTR wszEnumName) const;
    void GetEnumFromColumnName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPWSTR wszEnumName) const;
    void GetStructElementFromColumnName(ULONG i_Type, LPCWSTR i_wszColumnName, LPWSTR o_szStructElement) const;
    void TableInfoHeaderFromMeta(wstring &header_filename) const;
    void WriteTableInfoHeaderDatabaseIDs(wstring &wstrPreprocessor, wstring &wstrDatabaseIDs) const;
    void WriteTableInfoHeaderEnums(wstring &wstr) const;
    void WriteTableInfoHeaderTableIDs(wstring &wstrPreprocessor, wstring &wstrTableIDs) const;
    void WriteTableInfoHeaderPostamble(wstring &wstr) const;
    void WriteTableInfoHeaderPreamble(wstring &wstr, wstring &wstrFileName) const;
};


#endif // __TTABLEINFOGENERATION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\twriteschemabin.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TWRITESCHEMABIN_H__
#define __TWRITESCHEMABIN_H__

//The only non-standard header that we need for the class declaration is TOutput
#ifndef __OUTPUT_H__
    #include "Output.h"
#endif
#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif


class TWriteSchemaBin : public TFixedTableHeapBuilder
{
public:
    TWriteSchemaBin(LPCWSTR wszSchemaBinFileName);
    ~TWriteSchemaBin();
    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    PACL    m_paclDiscretionary;
    PSID    m_psdStorage;
    PSID    m_psidAdmin;
    PSID    m_psidSystem;
    LPCWSTR m_szFilename;

    void SetSecurityDescriptor();
};




#endif //__TWRITESCHEMABIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\twriteschemabin.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TWRITESCHEMABIN_H__
    #include "TWriteSchemaBin.h"
#endif
#include "svcmsg.h"

#define THROW_ERROR0(x)                     {LOG_ERROR(Interceptor, (0, 0, E_ST_COMPILEFAILED,           ID_CAT_CONFIG_SCHEMA_COMPILE, x,                 L"",  L"",  L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR_WIN32(win32err, call)   {LOG_ERROR(Interceptor, (0, 0, HRESULT_FROM_WIN32(win32err), ID_CAT_CONFIG_SCHEMA_COMPILE, IDS_COMCAT_WIN32, call,  L"",  L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}


TWriteSchemaBin::TWriteSchemaBin(LPCWSTR szFilename) :
                m_paclDiscretionary(0)
                ,m_psdStorage(0)
                ,m_psidAdmin(0)
                ,m_psidSystem(0)
                ,m_szFilename(szFilename)
{
}

TWriteSchemaBin::~TWriteSchemaBin()
{
	if( m_paclDiscretionary != NULL )
		LocalFree( m_paclDiscretionary );

	if( m_psidAdmin != NULL )
		FreeSid( m_psidAdmin );

	if( m_psidSystem != NULL )
		FreeSid( m_psidSystem );

	if( m_psdStorage != NULL )
		LocalFree( m_psdStorage );
}

void TWriteSchemaBin::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    BuildMetaTableHeap();

    SECURITY_ATTRIBUTES saStorage;
    PSECURITY_ATTRIBUTES psaStorage = NULL;

	SetSecurityDescriptor();

    saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
    saStorage.lpSecurityDescriptor = m_psdStorage;
    saStorage.bInheritHandle = FALSE;
    psaStorage = &saStorage;

    TFile schemabin(m_szFilename, out, true, psaStorage);

    //Write the header
    //We don't want the signature bytes to appear twice in the DLL so we'll write them to the file one byte at a time.
    //#define      kFixedTableHeapSignature0   (0x207be016)
    schemabin.Write(static_cast<unsigned char>(0x16));
    schemabin.Write(static_cast<unsigned char>(0xe0));
    schemabin.Write(static_cast<unsigned char>(0x7b));
    schemabin.Write(static_cast<unsigned char>(0x20));

    //#define      kFixedTableHeapSignature1   (0xe0182086)
    schemabin.Write(static_cast<unsigned char>(0x86));
    schemabin.Write(static_cast<unsigned char>(0x20));
    schemabin.Write(static_cast<unsigned char>(0x18));
    schemabin.Write(static_cast<unsigned char>(0xe0));

    schemabin.Write(kFixedTableHeapKey);
    schemabin.Write(kFixedTableHeapVersion);
    schemabin.Write(m_FixedTableHeap.GetEndOfHeap());

    //Write the FixedTableHeap (minus the header).  The header is not
    schemabin.Write(m_FixedTableHeap.GetHeapPointer() + 5*sizeof(ULONG), m_FixedTableHeap.GetEndOfHeap() - 5*sizeof(ULONG));
}

void TWriteSchemaBin::SetSecurityDescriptor()
{
    DWORD                    dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    m_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

    if(m_psdStorage == NULL)
    {
        THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
    }

    //
    // Initialize the security descriptor.
    //
    if( !InitializeSecurityDescriptor(m_psdStorage, SECURITY_DESCRIPTOR_REVISION))
    {
        THROW_ERROR_WIN32(GetLastError(), L"InitializeSecurityDescriptor");
    }

    //
    // Create the SIDs for the local system and admin group.
    //
    if( !AllocateAndInitializeSid(&ntAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &m_psidSystem))
    {
        THROW_ERROR_WIN32(GetLastError(), L"AllocateAndInitializeSid");
    }

    if( !AllocateAndInitializeSid(&ntAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &m_psidAdmin))
    {
        THROW_ERROR_WIN32(GetLastError(), L"AllocateAndInitializeSid");
    }

    //
    // Create the DACL containing an access-allowed ACE
    // for the local system and admin SIDs.
    //
    dwDaclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(m_psidAdmin) + sizeof(ACCESS_ALLOWED_ACE)
                   + GetLengthSid(m_psidSystem) - sizeof(DWORD);

    m_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

    if( m_paclDiscretionary == NULL )
    {
        THROW_ERROR0(IDS_COMCAT_OUTOFMEMORY);
    }

    if( !InitializeAcl(m_paclDiscretionary, dwDaclSize, ACL_REVISION))
    {
        THROW_ERROR_WIN32(GetLastError(), L"InitializeAcl");
    }

    if( !AddAccessAllowedAce(m_paclDiscretionary, ACL_REVISION, FILE_ALL_ACCESS, m_psidSystem))
    {
        THROW_ERROR_WIN32(GetLastError(), L"AddAccessAllowedAce");
    }

    if( !AddAccessAllowedAce(m_paclDiscretionary, ACL_REVISION, FILE_ALL_ACCESS, m_psidAdmin))
    {
        THROW_ERROR_WIN32(GetLastError(), L"AddAccessAllowedAce");
    }

    //
    // Set the DACL into the security descriptor.
    //
    if( !SetSecurityDescriptorDacl(m_psdStorage, TRUE, m_paclDiscretionary, FALSE))
    {
        THROW_ERROR_WIN32(GetLastError(), L"SetSecurityDescriptorDacl");
    }

}//TWriteSchemaBin::SetSecurityDescriptor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\ttableinfogeneration.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TTABLEINFOGENERATION_H__
    #include "TTableInfoGeneration.h"
#endif



TTableInfoGeneration::TTableInfoGeneration(LPCWSTR szFilename, TPEFixup &fixup, TOutput &out) :
                m_Fixup(fixup),
                m_out(out),
                m_szFilename(szFilename),
                m_szTableInfoDefine(L"TABLEINFO")
{
    wstring wstrTemp = m_szFilename;
    wstrTemp += L".temp";
    TableInfoHeaderFromMeta(wstrTemp);

    bool bUpToDate = false;
    if(-1 != GetFileAttributes(m_szFilename))//if we can't GetFileAttributes then there must not be a table)info file already.
    {
        TMetaFileMapping OldTableInfo(m_szFilename);//false means the file doesn't have to exist.
        TMetaFileMapping NewTableInfo(wstrTemp.c_str());
        LPCSTR szOldTableInfo = strstr(reinterpret_cast<const char *>(OldTableInfo.Mapping()), "Copyright");//Before copyright is the date and time the file was
        LPCSTR szNewTableInfo = strstr(reinterpret_cast<const char *>(NewTableInfo.Mapping()), "Copyright");//generated.  We don't care about that, so compare after the word 'copyright'
        bUpToDate = (OldTableInfo.Size() == NewTableInfo.Size() &&//sizes are the same
                    szOldTableInfo &&                            //and 'Copyright' was 
                    szNewTableInfo &&
                    0 == strcmp(szOldTableInfo, szNewTableInfo));
    }

    if(bUpToDate)
        m_out.printf(L"%s is up to date.\n", m_szFilename);
    else
    {
        if(0 == CopyFile(wstrTemp.c_str(), m_szFilename, FALSE))//copy the temp file over top of the header file that might already exist
            THROW(ERROR - COPY FILE FAILED);
        m_out.printf(L"%s Generated.\n", m_szFilename);
    }

    if(0 == DeleteFile(wstrTemp.c_str()))
        m_out.printf(L"Warning - Failed to delete temporary file (%s).\n",wstrTemp.c_str());
}


//
// Private Member Functions
//
void TTableInfoGeneration::GetColumnEnumFromColumnNameAndTagName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPCWSTR wszTagName, LPWSTR wszEnumName) const
{
    wsprintf(wszEnumName, L"e%s_%s", wszTableName, wszTagName);
}


void TTableInfoGeneration::GetColumnFlagFromColumnNameAndTagName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPCWSTR wszTagName, LPWSTR wszEnumName) const
{
    wsprintf(wszEnumName, L"f%s_%s", wszTableName, wszTagName);
}


void TTableInfoGeneration::GetEnumFromColumnName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPWSTR wszEnumName) const
{
    wsprintf(wszEnumName, L"i%s_%s", wszTableName, wszColumnName);
}

void TTableInfoGeneration::GetStructElementFromColumnName(ULONG i_Type, LPCWSTR i_wszColumnName, LPWSTR o_szStructElement) const
{
    static WCHAR * wszType[0x10]  ={L"unsigned char *", 0, L"WCHAR *", L"ULONG *", 0, L"UINT64 *", 0, L"void *", L"GUID *", 0, 0, 0, 0, 0, 0, 0};
//@@@The follwing line is useful if we want to add hungarian type information
//    static WCHAR * wszPrefix[0x10]={L"by"             , 0, L"wsz"    , L"ul"     , 0, 0, 0, 0, L"guid"  , 0, 0, 0, 0, 0, 0, 0};
    ASSERT(0 != wszType[i_Type&0x0F]);//we should only get these types for now.
    wsprintf(o_szStructElement, L"%16s     p%s", wszType[i_Type&0x0F], i_wszColumnName);
}

void TTableInfoGeneration::TableInfoHeaderFromMeta(wstring &header_filename) const
{
    //Write preamble
    wstring     wstrPreamble;
    WriteTableInfoHeaderPreamble(wstrPreamble, header_filename);

    //TableEnums
    wstring     wstrTableEnums;
    WriteTableInfoHeaderEnums(wstrTableEnums);

    //TableID_Preprocessor & TableID_DEFINE_GUIDs
    wstring     wstrTableID_Preprocessor;
    wstring     wstrTableID_DEFINE_GUIDs;
    //This writes the DatabaseIDs first then the TableIDs
    WriteTableInfoHeaderTableIDs(wstrTableID_Preprocessor, wstrTableID_DEFINE_GUIDs);

    //Write postamble
    wstring     wstrPostamble;
    WriteTableInfoHeaderPostamble(wstrPostamble);

    wstrPreamble += wstrTableID_Preprocessor;
    wstrPreamble += wstrTableID_DEFINE_GUIDs;
    wstrPreamble += wstrTableEnums;
    wstrPreamble += wstrPostamble;

    TFile(header_filename.c_str(), m_out).Write(wstrPreamble, (ULONG) wstrPreamble.length());
}


void TTableInfoGeneration::WriteTableInfoHeaderDatabaseIDs(wstring &wstrPreprocessor, wstring &wstrDatabaseIDs) const
{
/*
    static wchar_t *wszTableID_Preprocessor[]={
    L"#	define DEFINE_GUID_FOR_%s  \n",
    };
    static wchar_t *wszDEFINE_GUIDs[]={
    L"\n",
    L"#ifdef DEFINE_GUID_FOR_%s  \n",
    L"DEFINE_GUID(%40s,    0x%08x, 0x%04x, 0x%04x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x); // {%s}\n",
    L"#endif  \n",
    L"\n", 0
    };
*/
    static wchar_t *wszDatabaseName[]={
    L"//------------------------------DatabaseName---------------------------   \n",
    L"#define wszDATABASE_%-30s          L\"%s\"\n",
    L"\n", 0
    };
    WCHAR szTemp[256];

    TDatabaseMeta DatabaseMeta(m_Fixup);

    wstrDatabaseIDs += wszDatabaseName[0];

    for(unsigned int iDatabaseMeta=0; iDatabaseMeta < DatabaseMeta.GetCount(); iDatabaseMeta++, DatabaseMeta.Next())
    {
        wsprintf(szTemp, wszDatabaseName[1], DatabaseMeta.Get_InternalName(), DatabaseMeta.Get_InternalName());
        wstrDatabaseIDs += szTemp;
        /*
        GUID &guid= *DatabaseMeta.Get_iGuidDid();
        WCHAR didInternalNameALLCAPS[255];
        wcscpy(didInternalNameALLCAPS, DatabaseMeta.Get_iInternalName());
        //Convert to uppercase and prepend DEFINE_GUID_FOR_
        _wcsupr(didInternalNameALLCAPS);

        WCHAR *szDidGuidTemp;
        WCHAR szDidGuid[40];
        StringFromCLSID(guid, &szDidGuidTemp);
        wcscpy(szDidGuid, szDidGuidTemp);//This will keep us from having to do a try-catch
        CoTaskMemFree(szDidGuidTemp);

        //Write #define DEFINE_GUID_FOR_### to the list of all DEFINE_TID_GUIDS
        wsprintf(szTemp, wszTableID_Preprocessor[0], didInternalNameALLCAPS);
        wstrPreprocessor += szTemp;

        //Write the DEFINE_GUID entry (this includes the $ifdef DEFINE_GUID_FOR_###)
        wstrDatabaseIDs += wszDEFINE_GUIDs[0];
        wsprintf(szTemp, wszDEFINE_GUIDs[1], didInternalNameALLCAPS);
        wstrDatabaseIDs += szTemp;
        didInternalNameALLCAPS[0] = L'd';
        didInternalNameALLCAPS[1] = L'i';
        didInternalNameALLCAPS[2] = L'd';
        wsprintf(szTemp, wszDEFINE_GUIDs[2], didInternalNameALLCAPS, guid.Data1, guid.Data2, guid.Data3,
                    guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7], szDidGuid);
        wstrDatabaseIDs += szTemp;
        wstrDatabaseIDs += wszDEFINE_GUIDs[3];
        */
    }
    wstrDatabaseIDs += wszDatabaseName[2];
}


void TTableInfoGeneration::WriteTableInfoHeaderEnums(wstring &wstr) const
{
    static wchar_t *wszTableName[]={
    L"\n\n\n\n//-------------------------------TableName-----------------------------   \n",
    L"#define wszTABLE_%-30s          L\"%s\"\n",
    L"#define TABLEID_%-30s           (0x%08xL)\n",
    L"\n", 0
    };

    static wchar_t *wszTableVersion[]={
    L"\n\n\n\n//-------------------------------Table Versions-------------------------\n",
    L"#define BaseVersion_%-30s       (%dL)\n",
    L"#define ExtendedVersion_%-30s   (%dL)\n",
    L"\n", 0
    };

    static wchar_t *wszEnums[]={
    L"//-----------------Column Index Enums--------------   \n",
    L"enum e%s {\n",
    L"    %s,  \n",
    L"    c%s_NumberOfColumns\n",
    L"};\n",
    L"\n", 0
    };

    static wchar_t *wszStruct[]={
    L"//-----------------Columns as Struct---------------   \n",
    L"struct t%sRow {\n",
    L"%s;\n",
    L"};\n",
    L"\n", 0
    };

    static wchar_t *wszColumnTags[]={
    L"enum e%s_%s {\n",
    L"    %-30s\t=\t%8d,\t//(0x%08x)\n",         //This one for enums
    L"    %-30s\t=\t0x%08x,\t//(%d decimal)\n", //This one for flags
    L"    %-30s\t=\t%8d\t//(0x%08x)\n",         //This one for last enum
    L"    f%s_%s_Mask\t= 0x%08x\n",               //This one for flag mask
    L"};\n",
    L"\n", 0
    };

    static wchar_t *wszDefineIndexName[]={
    L"//----------------IndexMeta------------------------   \n",
    L"#define %s_%s L\"%s\"\n",
    L"\n", 0
    };

    wstr = L"";

    TTableMeta TableMeta(m_Fixup);

    //While pNode_MetaTableID is not 0
    WCHAR szTemp[1024];
    WCHAR szEnum[1024];
    WCHAR szStruct[1024];
    for(unsigned int iTableMeta=0; iTableMeta< TableMeta.GetCount(); iTableMeta++, TableMeta.Next())
    {
        wstr += wszTableName[0];//-------------------------------TableName-----------------------------
        wsprintf(szTemp, wszTableName[1], TableMeta.Get_InternalName(), TableMeta.Get_InternalName());
        wstr += szTemp;         //#define tidTableName L"tidTableName"
        wsprintf(szTemp, wszTableName[2], TableMeta.Get_InternalName(), TableMeta.Get_nTableID());
        wstr += szTemp;         //#define TABLEID_TableName (0xabcdef00L)
        wstr += wszTableName[3];

        wstr += wszTableVersion[0];//-------------------------------Table Versions-------------------------
        wsprintf(szTemp, wszTableVersion[1], TableMeta.Get_InternalName(), *TableMeta.Get_BaseVersion());
        wstr += szTemp;         //#define BaseVersion_%-30s       (%dL)\n",
        wsprintf(szTemp, wszTableVersion[2], TableMeta.Get_InternalName(), *TableMeta.Get_ExtendedVersion());
        wstr += szTemp;         //#define ExtendedVersion_%-30s   (%dL)\n",
        wstr += wszTableVersion[3];

        if(!TableMeta.IsTableMetaOfColumnMetaTable())
            continue;

        if(TableMeta.Get_cIndexMeta())//If there are any IndexMeta entries
        {
            //Make a little section for the IndexMeta names
            wstr += wszDefineIndexName[0];

            TIndexMeta IndexMeta(m_Fixup, TableMeta.Get_iIndexMeta());
            LPCWSTR szPrev_IndexMeta_InternalName=0;
            for(unsigned int cIndexMeta=0; cIndexMeta<TableMeta.Get_cIndexMeta(); ++cIndexMeta, IndexMeta.Next())
            {   //put a #define in for every IndexMeta name in the IndexMeta for this table
                if(szPrev_IndexMeta_InternalName != IndexMeta.Get_InternalName())//Only define the name once per index name
                {                                                                 //We don't have to do a string compare since all identical strings share the same index into Pool
                    wsprintf(szTemp, wszDefineIndexName[1], TableMeta.Get_InternalName(), IndexMeta.Get_InternalName(), IndexMeta.Get_InternalName());
                    wstr += szTemp;
                    szPrev_IndexMeta_InternalName = IndexMeta.Get_InternalName();
                }
            }
            wstr += wszDefineIndexName[2];
        }

        //Create an enum
        wstr += wszEnums[0];
        wsprintf(szTemp, wszEnums[1], TableMeta.Get_InternalName());//enum enumTableName
        wstr += szTemp;

        TColumnMeta     ColumnMeta(m_Fixup, TableMeta.Get_iColumnMeta());
        unsigned int    cTags=0;
        unsigned int    iColumnMeta;
        for(iColumnMeta=0; iColumnMeta< *TableMeta.Get_CountOfColumns(); iColumnMeta++, ColumnMeta.Next())
        {
            //Write the ColumnName as the next enum value
            GetEnumFromColumnName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), szEnum);
            wsprintf(szTemp, wszEnums[2], szEnum);//iTableName_ColumnInternalName
            wstr += szTemp;

            if(*ColumnMeta.Get_MetaFlags() & (fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM))
                ++cTags;
        }
        //End the enum
        wsprintf(szTemp, wszEnums[3], TableMeta.Get_InternalName());//nTableName_NumberOfColumns
        wstr += szTemp;
        wstr += wszEnums[4];//end the enum
        wstr += wszEnums[5];//add a newline


        //Create the struct
        wstr += wszStruct[0];
        wsprintf(szTemp, wszStruct[1], TableMeta.Get_InternalName());//struct tTableName
        wstr += szTemp;

        ColumnMeta.Reset();
        for(iColumnMeta=0; iColumnMeta< *TableMeta.Get_CountOfColumns(); iColumnMeta++, ColumnMeta.Next())
        {
            //Write the ColumnName as the next element of the struct
            GetStructElementFromColumnName(*ColumnMeta.Get_Type(), ColumnMeta.Get_InternalName(), szStruct);
            wsprintf(szTemp, wszStruct[2], szStruct);//ColumnInternalName
            wstr += szTemp;
        }
        //End the struct
        wstr += wszStruct[3];
        wstr += wszStruct[4];//add a newline


        ColumnMeta.Reset();
        //After we've finished the column struct, check to see if there are any ColumnEnums or Flags
        bool bBoolean = false;//We only declare one enum for booleans per table
        for(iColumnMeta=0; cTags && iColumnMeta< *TableMeta.Get_CountOfColumns(); iColumnMeta++, ColumnMeta.Next())
        {
            if(*ColumnMeta.Get_MetaFlags() & (fCOLUMNMETA_ENUM | fCOLUMNMETA_FLAG))
            {
                if(*ColumnMeta.Get_SchemaGeneratorFlags() & fCOLUMNMETA_PROPERTYISINHERITED)
                    continue;//If the property is inherited, then don't generate enum, the user can use the enum from the parent table.
                if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_BOOL)
                    if(bBoolean)//If we've already seen a boolean for this table then skip it and move on.
                        continue;
                    else
                        bBoolean = true;//if this is the first bool we've seen then declare the enum.

                ASSERT(0 != ColumnMeta.Get_ciTagMeta());

                bool bFlag = (0 != (*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FLAG));

                TTagMeta TagMeta(m_Fixup, ColumnMeta.Get_iTagMeta());

                wsprintf(szTemp, wszColumnTags[0], TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName());//enum Tablename_ColumnName 
                wstr += szTemp;

                for(unsigned int cTagMeta=0; cTagMeta < ColumnMeta.Get_ciTagMeta()-1; ++cTagMeta, TagMeta.Next())
                {
                    ASSERT(*TagMeta.Get_ColumnIndex() == iColumnMeta); 
                    if(bFlag)
                    {
                        GetColumnFlagFromColumnNameAndTagName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), TagMeta.Get_InternalName(), szEnum);
                        wsprintf(szTemp, wszColumnTags[2], szEnum, *TagMeta.Get_Value(), *TagMeta.Get_Value());//iTableName_colInternalName_TagNameInternal = 0x0000000f,    //(15 decimal)
                    }
                    else
                    {
                        GetColumnEnumFromColumnNameAndTagName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), TagMeta.Get_InternalName(), szEnum);
                        wsprintf(szTemp, wszColumnTags[1], szEnum, *TagMeta.Get_Value(), *TagMeta.Get_Value());//iTableName_colInternalName_TagNameInternal = 15,  //(0x0000000f)
                    }
                    wstr += szTemp;
                }
                if(bFlag)
                {
                    GetColumnFlagFromColumnNameAndTagName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), TagMeta.Get_InternalName(), szEnum);
                    wsprintf(szTemp, wszColumnTags[2], szEnum, *TagMeta.Get_Value(), *TagMeta.Get_Value());//iTableName_colInternalName_TagNameInternal = 0x0000000f,    //(15 decimal)
                }
                else
                {    //The last enum doesn't have a comma
                    GetColumnEnumFromColumnNameAndTagName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), TagMeta.Get_InternalName(), szEnum);
                    wsprintf(szTemp, wszColumnTags[3], szEnum, *TagMeta.Get_Value(), *TagMeta.Get_Value());//iTableName_colInternalName_TagNameInternal = 15,  //(0x0000000f)
                }
                wstr += szTemp;
                if(bFlag)
                {   //The last flag is followed by the flag mask
                    wsprintf(szTemp, wszColumnTags[4], TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), *ColumnMeta.Get_FlagMask());
                    wstr += szTemp;
                }
                wstr += wszColumnTags[5];//end the enum
                wstr += wszColumnTags[6];//add a newline

            }
        }
    }
}


void TTableInfoGeneration::WriteTableInfoHeaderTableIDs(wstring &wstrPreprocessor, wstring &wstrTableIDs) const
{
/*
    static wchar_t *wszTableID_Preprocessor[]={
    L"\n",
    L"\n",
    L"//--------------------------------------------------------------------\n",
    L"// Database and table ids:                                            \n",
    L"//--------------------------------------------------------------------\n",
    L"\n",
    L"\n",
    L"// NOTE: Turn on conditional inclusion for your did or tid here, then.\n",
    L"#ifndef %s_SELECT  \n",
    L"    #define DEFINE_GUID_FOR_%s  \n",
    L"#endif\n",
    L"\n", 0
    };
    static wchar_t *wszTableID_DEFINE_GUIDs[]={
    L"\n",
    L"#ifdef DEFINE_GUID_FOR_%s  \n",
    L"DEFINE_GUID(%40s,    0x%08x, 0x%04x, 0x%04x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x); // %s\n",
    L"#endif  \n",
    L"\n", 0
    };
*/
    wstrPreprocessor    = L"";
    wstrTableIDs        = L"";
/*
    for(int iPreprocessor=0;iPreprocessor<8;iPreprocessor++)//The preprocessor first several lines don't require modification
        wstrPreprocessor += wszTableID_Preprocessor[iPreprocessor];

    WCHAR szTemp[1024];
    wsprintf(szTemp, wszTableID_Preprocessor[iPreprocessor++], m_szTableInfoDefine);
    wstrPreprocessor += szTemp;
*/
    WriteTableInfoHeaderDatabaseIDs(wstrPreprocessor, wstrTableIDs);
/*
    TTableMeta TableMeta(1,m_Fixup);
    for(unsigned int iTableMeta=1; iTableMeta < *m_Fixup.pciTableMetas; iTableMeta++, TableMeta.Next())
    {
        WCHAR tidInternalNameALLCAPS[255];
        wcscpy(tidInternalNameALLCAPS, TableMeta.Get_iInternalName());
        //Convert to uppercase and prepend DEFINE_GUID_FOR_
        _wcsupr(tidInternalNameALLCAPS);

        //Write #define DEFINE_GUID_FOR_### to the list of all DEFINE_TID_GUIDS
        wsprintf(szTemp, wszTableID_Preprocessor[iPreprocessor], tidInternalNameALLCAPS);
        wstrPreprocessor += szTemp;

        //Write the DEFINE_GUID entry (this includes the $ifdef DEFINE_GUID_FOR_###)
        wstrTableIDs += wszTableID_DEFINE_GUIDs[0];
        wsprintf(szTemp, wszTableID_DEFINE_GUIDs[1], tidInternalNameALLCAPS);
        wstrTableIDs += szTemp;
        tidInternalNameALLCAPS[0] = L't';
        tidInternalNameALLCAPS[1] = L'i';
        tidInternalNameALLCAPS[2] = L'd';

        GUID &guid= *TableMeta.Get_iGuidTid();
        WCHAR *szTidGuidTemp;
        WCHAR szTidGuid[40];
        StringFromCLSID(guid, &szTidGuidTemp);
        wcscpy(szTidGuid, szTidGuidTemp);//This will keep us from having to do a try-catch
        CoTaskMemFree(szTidGuidTemp);

        wsprintf(szTemp, wszTableID_DEFINE_GUIDs[2], tidInternalNameALLCAPS, guid.Data1, guid.Data2, guid.Data3,
                    guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7], szTidGuid);
        wstrTableIDs += szTemp;
        wstrTableIDs += wszTableID_DEFINE_GUIDs[3];
    }

    wstrPreprocessor += wszTableID_Preprocessor[++iPreprocessor];//end the #ifndef
*/
}


void TTableInfoGeneration::WriteTableInfoHeaderPostamble(wstring &wstr) const
{
    static wchar_t *wszPostamble[]={
    L"\n",
    L"#endif //__%s_H__ \n",
    L"\n"
    };

    wstr = wszPostamble[0];

    WCHAR szTemp[1024];
    wsprintf(szTemp, wszPostamble[1], m_szTableInfoDefine);//#endif __wszDefineName_H__
    wstr += szTemp;

    wstr += wszPostamble[2];
}


void TTableInfoGeneration::WriteTableInfoHeaderPreamble(wstring &wstr, wstring &wstrFileName) const
{
    static wchar_t *wszPreamble[]={
    L"//  %s - Table Names and Helper enums and flags.  \n",
    L"//  Generated %02d/%02d/%04d %02d:%02d:%02d by %s \n",
    L"//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved. \n",
    L"\n",
    L"#ifndef __%s_H__  \n",
    L"#define __%s_H__  \n",
    L"\n",
    L"#ifndef _OBJBASE_H_\n",
    L"    #include <objbase.h>\n",
    L"#endif\n",
    L"#ifdef REGSYSDEFNS_DEFINE\n",
    L"    #include <initguid.h>\n",
    L"#endif\n",
    L"\n",
    L"// -----------------------------------------                             \n",
    L"// PRODUCT constants:                                                    \n",
    L"// -----------------------------------------                             \n",
    L"#define WSZ_PRODUCT_APPCENTER	                L\"ApplicationCenter\"     \n",
    L"#define WSZ_PRODUCT_IIS			            L\"IIS\"                   \n",
    L"#define WSZ_PRODUCT_NETFRAMEWORKV1            L\"NetFrameworkv1\"        \n",
    L"\n",
    L"//The Meta flags exist in two places.  When a new flag is added it needs \n",
    L"//into the following:                                                    \n",
    L"//XMLUtility.h                                                           \n",
    L"//CatMeta.xml                                                            \n",
    L"\n",
    L"//These macros are needed for the metabase\n",
    L"#define SynIDFromMetaFlagsEx(MetaFlagsEx) ((MetaFlagsEx>>2)&0x0F)\n",
    L"#define kInferredColumnMetaFlags   (fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE)\n",
    L"#define kInferredColumnMetaFlagsEx (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED)\n",
    L"\n",
    L"\n", 0
    };

    WCHAR szTemp[1024];
    int i=0;

    wstr = L"";

    WCHAR szFileName[MAX_PATH];
    _wsplitpath(wstrFileName.c_str(), 0, 0, szFileName, 0);
    wsprintf(szTemp, wszPreamble[i++], szFileName);//Comment includes the filename
    wstr += szTemp;

    SYSTEMTIME time;
    GetLocalTime(&time); 
    wsprintf(szTemp, wszPreamble[i++], time.wMonth, time.wDay, time.wYear, time.wHour, time.wMinute, time.wSecond, g_szProgramVersion); //Date Generated line
    wstr += szTemp;

    wstr += wszPreamble[i++];
    wstr += wszPreamble[i++];
    wsprintf(szTemp, wszPreamble[i++], m_szTableInfoDefine);//#ifndef __wszDefineName_H__
    wstr += szTemp;
    wsprintf(szTemp, wszPreamble[i++], m_szTableInfoDefine);//#define __wszDefineName_H__
    wstr += szTemp;

    while(wszPreamble[i])//The rest of the preamble is const strings
        wstr += wszPreamble[i++];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\ttablemeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TTABLEMETA_H__
#define __TTABLEMETA_H__

#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif
#ifndef __TCOLUMNMETA_H__
    #include "TColumnMeta.h"
#endif

/*
struct TableMeta
{
    ULONG FOREIGNKEY            Database;               //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       PublicRowName;          //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       NameColumn;             //UI4       iOrder of the NameColumn
    ULONG                       NavColumn;              //UI4       iOrder of the NavColumn
    union
    {
    ULONG                       CountOfColumns;         //UI4       Count of Columns
    ULONG                       CountOfProperties;      //UI4       Count of Columns
    };
    ULONG                       MetaFlags;              //UI4       TableMetaFlags are defined in CatInpro.meta
    ULONG                       SchemaGeneratorFlags;   //UI4       SchemaGenFlags are defined in CatInpro.meta
    ULONG                       ConfigItemName;         //String
    ULONG                       ConfigCollectionName;   //String
    ULONG                       PublicRowNameColumn;    //UI4       If PublicRowName is NULL, this specifies the column whose enum values represent possible PublicRowNames
    ULONG                       ContainerClassList;     //String    This is a comma delimited list of classes
    ULONG                       Description;            //String
    ULONG                       ChildElementName;       //String    This should be NULL unless one or more columns has the VALUEINCHILDELEMENT flag set on it.
    ULONG PRIVATE               ciRows;                 //Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
    ULONG PRIVATE_INDEX         iColumnMeta;            //Index into ColumnMeta
    ULONG PRIVATE_INDEX         iFixedTable;            //Index into g_aFixedTable
    ULONG PRIVATE               cPrivateColumns;        //This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
    ULONG PRIVATE               cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG PRIVATE_INDEX         iIndexMeta;             //Index into IndexMeta
    ULONG PRIVATE_INDEX         iHashTableHeader;       //If the table is a fixed table, then it will have a hash table.
    ULONG PRIVATE               nTableID;               //This is a 24 bit Hash of the Table name.
    ULONG PRIVATE_INDEX         iServerWiring;          //Index into the ServerWiringHeap (this is a temporary hack for CatUtil)
    ULONG PRIVATE               cServerWiring;          //Count of ServerWiring (this is a temporary hack for CatUtil)
};
*/

class TTableMeta : public TMetaTable<TableMeta>
{
public:
    TTableMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<TableMeta>(fixup,i){}
    bool    IsTableMetaOfColumnMetaTable() const {return (Get_MetaTable().InternalName && m_Fixup.UI4FromIndex(Get_MetaTable().CountOfColumns)>0);}

    const WCHAR * Get_Database            () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Database              );}
    const WCHAR * Get_InternalName        () const {return m_Fixup.StringFromIndex(   Get_MetaTable().InternalName          );}
    const WCHAR * Get_PublicName          () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicName            );}
    const WCHAR * Get_PublicRowName       () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicRowName         );}
    const ULONG * Get_BaseVersion         () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().BaseVersion           );}
    const ULONG * Get_ExtendedVersion     () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().ExtendedVersion       );}
    const ULONG * Get_NameColumn          () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().NameColumn            );}
    const ULONG * Get_NavColumn           () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().NavColumn             );}
    const ULONG * Get_CountOfColumns      () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().CountOfColumns        );}
    const ULONG * Get_MetaFlags           () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().MetaFlags             );}
    const ULONG * Get_SchemaGeneratorFlags() const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().SchemaGeneratorFlags  );}
    const WCHAR * Get_ConfigItemName      () const {return m_Fixup.StringFromIndex(   Get_MetaTable().ConfigItemName        );}
    const WCHAR * Get_ConfigCollectionName() const {return m_Fixup.StringFromIndex(   Get_MetaTable().ConfigCollectionName  );}
    const ULONG * Get_PublicRowNameColumn () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().PublicRowNameColumn   );}
    const WCHAR * Get_ContainerClassList  () const {return m_Fixup.StringFromIndex(   Get_MetaTable().ContainerClassList    );}
    const WCHAR * Get_Description         () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Description           );}
    const WCHAR * Get_ChildElementName    () const {return m_Fixup.StringFromIndex(   Get_MetaTable().ChildElementName      );}
          ULONG   Get_ciRows              () const {return Get_MetaTable().ciRows;}
          ULONG   Get_iColumnMeta         () const {return Get_MetaTable().iColumnMeta;}
          ULONG   Get_iFixedTable         () const {return Get_MetaTable().iFixedTable;}
          ULONG   Get_cPrivateColumns     () const {return Get_MetaTable().cPrivateColumns;}
          ULONG   Get_cIndexMeta          () const {return Get_MetaTable().cIndexMeta;}
          ULONG   Get_iIndexMeta          () const {return Get_MetaTable().iIndexMeta;}
          ULONG   Get_iHashTableHeader    () const {return Get_MetaTable().iHashTableHeader;}
          ULONG   Get_nTableID            () const {return Get_MetaTable().nTableID;}
          ULONG   Get_iServerWiring       () const {return Get_MetaTable().iServerWiring;}
          ULONG   Get_cServerWiring       () const {return Get_MetaTable().cServerWiring;}
       
    //Warning!! Users should not rely on this pointer once a Table is added, since the add could cause a relocation of the data.
    virtual TableMeta *Get_pMetaTable   ()       {return m_Fixup.TableMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount      () const {return m_Fixup.GetCountTableMeta();};
    const TableMeta & Get_MetaTable () const {return *m_Fixup.TableMetaFromIndex(m_iCurrent);}
};



#endif // __TTABLEMETA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\txmlfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "XMLUtility.h"
#ifndef __TXMLFILE_H__
    #include "TXmlFile.h"
#endif

TXmlFile::TXmlFile() : m_bValidated(false), m_bAlternateErrorReporting(false), m_szXMLFileName(NULL)
{
    m_errorOutput = &m_outScreen;
    m_infoOutput = &m_outScreen;
}

TXmlFile::~TXmlFile()
{
}

void TXmlFile::SetAlternateErrorReporting()
{
    m_errorOutput = &m_outException;
    m_infoOutput = &m_outDebug;
    m_bAlternateErrorReporting = true;
}

TCHAR * TXmlFile::GetLatestError()
{
    if(m_bAlternateErrorReporting)
        return ((TExceptionOutput *)m_errorOutput)->GetString();
    else
        return NULL;
}

bool TXmlFile::GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, CComVariant &var, bool bMustExist) const
{
    ASSERT(0 != pMap);

    CComPtr<IXMLDOMNode>    pNode;
    XIF(pMap->getNamedItem(bstr, &pNode));
    if(0 == pNode.p)
        if(bMustExist)
        {
            m_errorOutput->printf(L"Attribute %s does not exist.\n", bstr);
            THROW(ERROR - ATTRIBUTE DOES NOT EXIST);
        }
        else //If the attribute doesn't have to exist then just return false
        {
            var.Clear();
            return false;
        }

    XIF(pNode->get_nodeValue(&var));
    ASSERT(var.vt == VT_BSTR);
    return true;
}


//There are three possibilities for guids: uuid, guidID (guid with '_' instead of '{' & '}') of guid as idref
bool TXmlFile::GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, GUID &guid, bool bMustExist) const
{
    CComVariant var_Guid;
    if(!GetNodeValue(pMap, bstr, var_Guid, bMustExist))
    {
        memset(&guid, 0x00, sizeof(guid));
        return false;
    }
    if(var_Guid.bstrVal[0] == L'_' && var_Guid.bstrVal[37] == L'_')//if the first character is an '_' then it must be a GuidID
        GuidFromGuidID(var_Guid.bstrVal, guid);
    else if(var_Guid.bstrVal[8]  == L'-' && 
            var_Guid.bstrVal[13] == L'-' &&
            var_Guid.bstrVal[18] == L'-' &&
            var_Guid.bstrVal[23] == L'-')//if these are '-' then it's a guid
    {
        if(FAILED(UuidFromString(var_Guid.bstrVal, &guid)))//validate that it is in fact a GUID
        {
            m_errorOutput->printf(L"Logical Error:\n\tguid (%s) is not a valid GUID.\n", var_Guid.bstrVal);
            THROW(Logical Error);
        }

        SIZE_T nStringLength = wcslen(var_Guid.bstrVal);
        while(nStringLength--)//Then make sure it is all upper case
        {
            if(var_Guid.bstrVal[nStringLength] >= L'a' && var_Guid.bstrVal[nStringLength] <= L'z')
            {
                m_errorOutput->printf(L"Logical Error:\n\tguid %s contains a lower case\n\tcharacter '%c',GUIDs MUST be all caps by convention.\nNOTE: guidgen sometimes produces lowercase characters.\n", var_Guid.bstrVal, static_cast<char>(var_Guid.bstrVal[nStringLength]));
                THROW(Logical Error);
            }
        }
    }
    else //otherwise it's guid as idref
    {
        //Get the node with the matching ID
        CComPtr<IXMLDOMNode>    pNodeGuid;
        XIF((m_pXMLDoc.p)->nodeFromID(var_Guid.bstrVal, &pNodeGuid));
        if(0 == pNodeGuid.p)
        {
            m_errorOutput->printf(L"Logical Error:\n\tguid (%s) is not a valid idref.\n", var_Guid.bstrVal);
            THROW(Logical Error);
        }

        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement = pNodeGuid;
        ASSERT(0 != pElement.p);//Get the IXMLDOMElement interface pointer

        CComBSTR                bstr_guid     = L"guid";
        CComVariant             var_Guid_;
        XIF(pElement->getAttribute(bstr_guid, &var_Guid_));

        if(FAILED(UuidFromString(var_Guid_.bstrVal, &guid)))//validate that it is in fact a GUID
        {
            m_errorOutput->printf(L"Logical Error:\n\tguid (%s) is not a valid GUID.\n", var_Guid_.bstrVal);
            THROW(Logical Error);
        }
    }
    return true;
}


bool TXmlFile::GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, unsigned long &ul, bool bMustExist) const
{
    CComVariant var_ul;
    if(!GetNodeValue(pMap, bstr, var_ul, bMustExist))
        return false;

    ul = _wtol(var_ul.bstrVal);
    return true;
}


void TXmlFile::GuidFromGuidID(LPCWSTR wszGuidID, GUID &guid) const
{
    WCHAR wszGuid[39];

    SIZE_T nStringLength = wcslen(wszGuidID);
    if(nStringLength != 38)//Check the string length first
    {
        m_errorOutput->printf(L"Logical Error:\n\tGuidID %s is not a valid.\n\tThe guidid must be of the form\n\t_BDC31734-08A1-11D3-BABE-00C04F68DDC0_\n", wszGuidID);
        THROW(Logical Error in Data Table);
    }

    wcscpy(wszGuid, wszGuidID);
    wszGuid[0] = L'{';
    wszGuid[37] = L'}';//replace the '_'s (presumably) with '{' & '}'
    if(FAILED(CLSIDFromString(wszGuid, &guid)))//Now see if it's a real GUID
    {
        m_errorOutput->printf(L"Logical Error:\n\tGuidID %s is not a valid.\n\tThe guidid must be of the form\n\t_BDC31734-08A1-11D3-BABE-00C04F68DDC0_\n", wszGuidID);
        THROW(Logical Error in Data Table);
    }

    while(nStringLength--)//now verify that it is all upper case
    {
        if(wszGuidID[nStringLength] >= L'a' && wszGuidID[nStringLength] <= L'z')
        {
            m_errorOutput->printf(L"Logical Error:\n\t%s contains a lower case\n\tcharacter '%c',guidids MUST be all caps by convention.\n\tNOTE: guidgen sometimes produces lowercase characters.\n", wszGuidID, static_cast<char>(wszGuidID[nStringLength]));
            THROW(Logical Error in Data Table);
        }
    }
}


bool TXmlFile::IsSchemaEqualTo(LPCWSTR szSchema) const
{
    if(!m_bValidated)//It does not make sense to check the schema if the XML file wasn't validated
        return false;//so we always return unless the xml was validated against a schema.

    wstring wstrSchema;
    GetSchema(wstrSchema);

    return (wstrSchema == szSchema);
}


bool TXmlFile::NextSibling(CComPtr<IXMLDOMNode> &pNode) const
{
    IXMLDOMNode *pnextSibling = 0;
    if(SUCCEEDED(pNode->get_nextSibling(&pnextSibling)) && pnextSibling)
    {
        pNode.Release();
        pNode = pnextSibling;
        pnextSibling->Release();//This is necessary because get_nextSibling add ref'd and the 'pNode = pnextSibling' add ref'd again  
                                //Also we can't call pNode.Release because CComPtr will NULL p out after the release
    }
    else
        pNode.Release();
    return (0!=pnextSibling);
}


//XML parse and XML validation (validation must be done before IsSchemaEqualTo can be called.
void TXmlFile::Parse(LPCWSTR szFilename, bool bValidate)
{
    if(-1 == GetFileAttributes(szFilename))//if GetFileAttributes fails then the file does not exist
    {
        m_errorOutput->printf(L"File not found (%s).\n", szFilename);
        THROW(ERROR - FILE NOT FOUND);
    }
	CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&m_pXMLDoc);


	XIF(m_pXMLDoc->put_validateOnParse(bValidate ? kvboolTrue : kvboolFalse));//Tell parser whether to validate according to an XML schema or DTD
    XIF(m_pXMLDoc->put_async(kvboolFalse));
    XIF(m_pXMLDoc->put_resolveExternals(kvboolTrue));

    VARIANT_BOOL bSuccess;
	CComVariant  xml(szFilename);
    XIF(m_pXMLDoc->load(xml,&bSuccess));

    if(bSuccess == kvboolFalse)
	{
		CComPtr<IXMLDOMParseError> pXMLParseError;
		XIF(m_pXMLDoc->get_parseError(&pXMLParseError));

        long lErrorCode;
		XIF(pXMLParseError->get_errorCode(&lErrorCode));

        long lFilePosition;
		XIF(pXMLParseError->get_filepos(&lFilePosition));

        long lLineNumber;
		XIF(pXMLParseError->get_line(&lLineNumber));

		long lLinePosition;
		XIF(pXMLParseError->get_linepos(&lLinePosition));

		CComBSTR bstrReasonString;		
        XIF(pXMLParseError->get_reason(&bstrReasonString));

		CComBSTR bstrSourceString;		
        XIF(pXMLParseError->get_srcText(&bstrSourceString));

        CComBSTR bstrURLString;		
		XIF(pXMLParseError->get_url(&bstrURLString));

		m_errorOutput->printf(
                        L"\n-----ERROR PARSING: Details Follow-----\nError Code     0x%08x\nFile Position    %8d\nLine Number      %8d\nLine Position    %8d\n Reason:    %s\nSource:    %s\nURL:       %s\n-----ERROR PARSING: End Details-------\n\n"
                       , lErrorCode, lFilePosition, lLineNumber, lLinePosition
                       , bstrReasonString, bstrSourceString.m_str ? bstrSourceString : "{EMPTY}", bstrURLString);

		THROW(ERROR PARSING XML FILE);
	}

    if(!bValidate)
    {
        m_infoOutput->printf(L"XML is well formed\n");
        return;
    }
    else
        m_infoOutput->printf(L"XML well formed & valid according to all schema\n");

    m_bValidated = bValidate;
}


//
//Private member functions
//

extern LPWSTR g_wszDefaultProduct;//this can be changed by CatInProc or whomever knows best what the default product ID is.

void TXmlFile::CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID * ppv) const
{
	ASSERT(NULL != ppv);
	*ppv = NULL;
	
    HINSTANCE hInstSHLWAPI = LoadLibrary(L"shlwapi.dll");//if we don't explicitly load this dll, MSXML will get it out of the system32 directory
#ifdef _IA64_
    HINSTANCE hInstMSXML = LoadLibrary(L"msxml3.dll");//This assumes MSXML.DLL for the object, leave the instance dangling
#else
    HINSTANCE hInstMSXML = LoadLibrary(0==wcscmp(g_wszDefaultProduct, WSZ_PRODUCT_NETFRAMEWORKV1) ? L"msxml.dll" : L"msxml3.dll");//This assumes MSXML.DLL for the object, leave the instance dangling
#endif
    FreeLibrary(hInstSHLWAPI);

    typedef HRESULT( __stdcall *DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);
    DLLGETCLASSOBJECT       DllGetClassObject = reinterpret_cast<DLLGETCLASSOBJECT>(GetProcAddress(hInstMSXML, "DllGetClassObject"));
	CComPtr<IClassFactory>  pClassFactory;
	XIF(DllGetClassObject(rclsid, IID_IClassFactory, (LPVOID*) &pClassFactory));// get the class factory object

	XIF(pClassFactory->CreateInstance (NULL, riid, (LPVOID*) ppv));// create a instance of the object we want
}


void TXmlFile::GetSchema(wstring &wstrSchema) const
{
    //This is kind of a long road to get to the XML Schema name but here goes...
    CComPtr<IXMLDOMElement>     pRootNodeOfXMLDocument;
    XIF((m_pXMLDoc.p)->get_documentElement(&pRootNodeOfXMLDocument)); //Get the XML Root Node

    CComPtr<IXMLDOMNode>        pDefinitionNode;
    XIF(pRootNodeOfXMLDocument->get_definition(&pDefinitionNode));//From that get the Definition node
    if(0 == pDefinitionNode.p)//This is legal, it just means there's no schema
    {
        wstrSchema = L"";
        return;
    }

    CComPtr<IXMLDOMDocument>    pSchemaDocument;
    XIF(pDefinitionNode->get_ownerDocument(&pSchemaDocument));//From that we get the DOMDocument of the schema

    CComPtr<IXMLDOMElement>     pSchemaRootElement;
    XIF(pSchemaDocument->get_documentElement(&pSchemaRootElement));//Get the schema's root element

    CComBSTR                    bstrAttributeName(L"name");
    CComVariant                 XMLSchemaName;
    XIF(pSchemaRootElement->getAttribute(bstrAttributeName, &XMLSchemaName));//get the Name attribute
    ASSERT(XMLSchemaName.vt == VT_BSTR);

    wstrSchema = XMLSchemaName.bstrVal;

    if(wstrSchema == L"")
        m_infoOutput->printf(L"No schema detected\n");
    else
        m_infoOutput->printf(L"XML Schema %s detected\n", wstrSchema.c_str());
}


static LPCWSTR kwszHexLegalCharacters = L"abcdefABCDEF0123456789";

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

//This converts the string to bytes (an L'A' gets translated to 0x0a NOT 'A')
void TXmlFile::ConvertWideCharsToBytes(LPCWSTR wsz, unsigned char *pBytes, unsigned long length) const
{
    LPCWSTR wszIllegalCharacter = _wcsspnp(wsz, kwszHexLegalCharacters);
    if(wszIllegalCharacter)
    {
        m_errorOutput->printf(L"Error - Illegal character (%c) in Byte string.\n", static_cast<unsigned char>(*wszIllegalCharacter));
        THROW(ERROR - BAD HEX CHARACTER);
    }
    
    memset(pBytes, 0x00, length);
    for(;length && *wsz; --length, ++pBytes)//while length is non zero and wsz is not at the terminating NULL
    {
        *pBytes =  kWcharToNibble[(*wsz++)&0x007f]<<4;//The first character is the high nibble
        *pBytes |= kWcharToNibble[(*wsz++)&0x007f];   //The second is the low nibble
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\txmlfile.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TXMLFILE_H__
#define __TXMLFILE_H__

//The only non-standard header that we need for the class declaration is TOutput
#ifndef __OUTPUT_H__
    #include "Output.h"
#endif

class TXmlFile
{
public:
    enum
    {
        kvboolTrue = -1,
        kvboolFalse = 0,
    };

    TXmlFile();
    ~TXmlFile();

    void                ConvertWideCharsToBytes(LPCWSTR wsz, unsigned char *pBytes, unsigned long length) const;
    bool                GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, CComVariant &var, bool bMustExist=true) const;
    bool                GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, GUID &guid, bool bMustExist=true) const;
    bool                GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, unsigned long &ul, bool bMustExist=true) const;
    IXMLDOMDocument *   GetXMLDOMDocument() const {return m_pXMLDoc.p;}
    void                GuidFromGuidID(LPCWSTR wszGuidID, GUID &guid) const;
    bool                IsSchemaEqualTo(LPCWSTR szSchema) const;
    bool                NextSibling(CComPtr<IXMLDOMNode> &pNode) const;
    void                Parse(LPCWSTR szFilename, bool bValidate=true);//XML parse and XML validation (validation must be done before IsSchemaEqualTo can be called.
    void                SetAlternateErrorReporting();
    TCHAR *             GetLatestError();

protected:
    CComPtr<IXMLDOMDocument>    m_pXMLDoc;
    TOutput *                   m_errorOutput;
    TOutput *                   m_infoOutput;
    const LPCWSTR               m_szXMLFileName;

private:
    bool                        m_bValidated;
    TScreenOutput               m_outScreen;
    TExceptionOutput            m_outException;
    TDebugOutput                m_outDebug;
    bool                        m_bAlternateErrorReporting;

    void                CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID * ppv) const;
    void                GetSchema(wstring &wstrSchema) const;
};


#endif // __TXMLFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\ttagmeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TTAGMETA_H__
#define __TTAGMETA_H__

#ifndef __TPEFIXUP_H__
    #include "TPEFixup.h"
#endif

/*
typedef struct
{
    ULONG PRIMARYKEY    Table               //Index into Pool
    ULONG PRIMARYKEY    ColumnIndex         //This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY    InternalName        //Index into Pool
    ULONG               PublicName          //Index into Pool
    ULONG               Value 
    ULONG               ID                  //Index into Pool
}TagMeta;
*/

class TTagMeta : public TMetaTable<TagMeta>
{
public:
    TTagMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<TagMeta>(fixup,i){}
    const WCHAR * Get_Table               () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Table         );}
    const ULONG * Get_ColumnIndex         () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().ColumnIndex   );}
    const WCHAR * Get_InternalName        () const {return m_Fixup.StringFromIndex(   Get_MetaTable().InternalName  );}
    const WCHAR * Get_PublicName          () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicName    );}
    const ULONG * Get_Value               () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().Value         );}
    const ULONG * Get_ID                  () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().ID            );}

    virtual TagMeta *Get_pMetaTable ()       {return m_Fixup.TagMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount  () const {return m_Fixup.GetCountTagMeta();};
    const TagMeta & Get_MetaTable () const {return *m_Fixup.TagMetaFromIndex(m_iCurrent);}
};



#endif // __TTAGMETA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\xmlutility.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __XMLUTILITY_H__
#define __XMLUTILITY_H__

#ifndef __STDAFX_H__
    #include "stdafx.h"
#endif
#ifndef __OUTPUT_H__
    #include "Output.h"
#endif
#ifndef __TEXCEPTION_H__
    #include "TException.h"
#endif
#ifndef __WSTRING_H__
    #include "wstring.h"
#endif
#ifndef __TCOM_H__
    #include "TCom.h"
#endif
#ifndef __TFILE_H__
    #include "TFile.h"
#endif

DEFINE_GUID (_CLSID_DOMDocument,    0x2933BF90, 0x7B36, 0x11d2, 0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60);
DEFINE_GUID (_IID_IXMLDOMDocument,  0x2933BF81, 0x7B36, 0x11d2, 0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60);
DEFINE_GUID (_IID_IXMLDOMElement,   0x2933BF86, 0x7B36, 0x11d2, 0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60);

#ifndef ASSERT
#ifdef _DEBUG
#define ASSERT(q) {if(!static_cast<bool>(q)){TDebugOutput().printf(TEXT("Assertion failed:\n\tFile:\t%s\n\tLine Number:\t%d\n\tCode:\t%s\n"), TEXT(__FILE__), __LINE__, TEXT(#q));DebugBreak();exit(0);}}
#else
#define ASSERT(q)
#endif
#endif

extern wchar_t g_szProgramVersion[];

struct TOLEDataTypeToXMLDataType
{
    LPCWSTR String;
    LPCWSTR MappedString;
    bool    bImplicitlyRequired;//if true, we assume NOTNULLABLE thus the attribute is required
    DWORD   dbType;
    ULONG   cbSize;
    ULONG   fCOLUMNMETA;
    ULONG   fCOLUMNSCHEMAGENERATOR;
};
extern TOLEDataTypeToXMLDataType OLEDataTypeToXMLDataType[];


//I've listed these in decimal rather than hex because they are just pasted from XML
//and XML doesn't know about hex.
#define fCOLUMNMETA_PRIMARYKEY                  (           1)
#define fCOLUMNMETA_FOREIGNKEY                  (           2)
#define fCOLUMNMETA_NAMECOLUMN                  (           4)
#define fCOLUMNMETA_NAVCOLUMN                   (           8)
#define fCOLUMNMETA_DIRECTIVE                   (          16)
#define fCOLUMNMETA_BOOL                        (          32)
#define fCOLUMNMETA_FLAG                        (          64)
#define fCOLUMNMETA_ENUM                        (         128)
#define fCOLUMNMETA_WRITENEVER                  (         256)
#define fCOLUMNMETA_WRITEONCHANGE               (         512)
#define fCOLUMNMETA_WRITEONINSERT               (        1024)
#define fCOLUMNMETA_NOTPUBLIC                   (        2048)
#define fCOLUMNMETA_NOTDOCD                     (        4096)
#define fCOLUMNMETA_PUBLICREADONLY              (        8192)
#define fCOLUMNMETA_PUBLICWRITEONLY             (       16384)
#define fCOLUMNMETA_INSERTDEFAULT               (       32768)
#define fCOLUMNMETA_INSERTGENERATE              (       65536)
#define fCOLUMNMETA_INSERTUNIQUE                (      131072)
#define fCOLUMNMETA_INSERTPARENT                (      262144)
#define fCOLUMNMETA_NOTNULLABLE                 (      524288)
#define fCOLUMNMETA_FIXEDLENGTH                 (     1048576)
#define fCOLUMNMETA_HASNUMERICRANGE             (     2097152)
#define fCOLUMNMETA_LEGALCHARSET                (     4194304)
#define fCOLUMNMETA_ILLEGALCHARSET              (     8388608)
#define fCOLUMNMETA_NOTPERSISTABLE              (    16777216)
#define fCOLUMNMETA_MULTISTRING                 (    33554432)
#define fCOLUMNMETA_EXPANDSTRING                (    67108864)
#define fCOLUMNMETA_UNKNOWNSIZE                 (   134217728)
#define fCOLUMNMETA_VARIABLESIZE                (   268435456)
#define fCOLUMNMETA_CASEINSENSITIVE             (   536870912)
#define fCOLUMNMETA_TOLOWERCASE                 (  1073741824)
#define fCOLUMNMETA_METAFLAGS_MASK              (  0xFFFFFFFF)

#define fCOLUMNMETA_CACHE_PROPERTY_MODIFIED     (           1)
#define fCOLUMNMETA_CACHE_PROPERTY_CLEARED      (           2)
#define fCOLUMNMETA_EXTENDEDTYPE0               (           4)
#define fCOLUMNMETA_EXTENDEDTYPE1               (           8)
#define fCOLUMNMETA_EXTENDEDTYPE2               (          16)
#define fCOLUMNMETA_EXTENDEDTYPE3               (          32)
#define fCOLUMNMETA_PROPERTYISINHERITED         (          64)
#define fCOLUMNMETA_USEASPUBLICROWNAME          (         128)
#define fCOLUMNMETA_EXTENDED                    (         256)
#define fCOLUMNMETA_MANDATORY                   (         512)
#define fCOLUMNMETA_USERDEFINED                 (        1024)
#define fCOLUMNMETA_WAS_NOTIFICATION            (        2048)
#define fCOLUMNMETA_XMLBLOB                     (        4096)
#define fCOLUMNMETA_WAS_NOTIFICATION_ON_NO_CHANGE_IN_VALUE (8192)
#define fCOLUMNMETA_VALUEINCHILDELEMENT         (       16384)
#define fCOLUMNMETA_HIDDEN                      (       65536)
#define fCOLUMNMETA_SCHEMAGENERATORFLAGS_MASK   (  0x00017FFF)

               
#define fTABLEMETA_INTERNAL                     (           1)
#define fTABLEMETA_NOLISTENING                  (           2)
#define fTABLEMETA_RELATIONINTEGRITY            (           4)
#define fTABLEMETA_ROWINTEGRITY                 (           8)
#define fTABLEMETA_HASUNKNOWNSIZES              (          16)
#define fTABLEMETA_NOPUBLICINSERT               (          32)
#define fTABLEMETA_NOPUBLICUPDATE               (          64)
#define fTABLEMETA_NOPUBLICDELETE               (         128)
#define fTABLEMETA_REQUIRESQUERY                (         256)
#define fTABLEMETA_HASDIRECTIVES                (         512)
#define fTABLEMETA_STOREDELTAS                  (        1024)
#define fTABLEMETA_AUTOGENITEMCLASS             (        2048)
#define fTABLEMETA_AUTOGENCOLLECTIONCLASS       (        4096)
#define fTABLEMETA_OVERRIDEITEMCLASS            (        8192)
#define fTABLEMETA_OVERRIDECOLLECTIONCLASS      (       16384)
#define fTABLEMETA_NAMEVALUEPAIRTABLE           (       32768)
#define fTABLEMETA_HIDDEN                       (       65536)
#define fTABLEMETA_OVERWRITEALLROWS             (      131072)
#define fTABLEMETA_METAFLAGS_MASK               (  0x8003FFFF)
                                              
#define fTABLEMETA_EMITXMLSCHEMA                (       1)
#define fTABLEMETA_EMITCLBBLOB                  (       2)
#define fTABLEMETA_ISCONTAINED                  (       4)
#define fTABLEMETA_NOTSCOPEDBYTABLENAME         (       8)
#define fTABLEMETA_GENERATECONFIGOBJECTS        (      16) 
#define fTABLEMETA_NOTABLESCHEMAHEAPENTRY       (      32)
#define fTABLEMETA_CONTAINERCLASS               (      64)
#define fTABLEMETA_EXTENDED                     (     256)
#define fTABLEMETA_SCHEMAGENERATORFLAGS_MASK    (  0x017f)

                                                        
#define fINDEXMETA_UNIQUE                       (       1)
#define fINDEXMETA_SORTED                       (       2)
#define fINDEXMETA_METAFLAGS_MASK               (    0x03)

#define fRELATIONMETA_CASCADEDELETE             (       1)
#define fRELATIONMETA_PRIMARYREQUIRED           (       2)
#define fRELATIONMETA_USECONTAINMENT            (       4)
#define fRELATIONMETA_CONTAINASSIBLING          (       8)
#define fRELATIONMETA_HIDDEN                    (   65536)
#define fRELATIONMETA_METAFLAGS_MASK            ( 0x10007)


#define fSERVERWIRINGMETA_First                 (       1)
#define fSERVERWIRINGMETA_Next                  (       2)
#define fSERVERWIRINGMETA_Last                  (       4)
#define fSERVERWIRINGMETA_NoNext                (       8)
#define fSERVERWIRINGMETA_WireOnWriteOnly       (      16)
#define fSERVERWIRINGMETA_WireOnReadWrite       (      32)
#define fSERVERWIRINGMETA_ReadOnly              (      64)
#define fSERVERWIRINGMETA_FLAGS_MASK            (    0x7f)

                                                         
//In addition to DBTYPE_UI4, DBTYPE_BYTES, DBTYPE_WSTR, and DBTYPE_DBTIMESTAMP, we also support the following
//defines for specifying data types.  These come from the metabase; and like the DBTYPEs, their values cannot be changed.
#define DWORD_METADATA                          (     0x01)
#define STRING_METADATA                         (     0x02)
#define BINARY_METADATA                         (     0x03)
#define EXPANDSZ_METADATA                       (     0x04)
#define MULTISZ_METADATA                        (     0x05)
                                                      


const unsigned int  kLargestPrime = 5279;

//These are the strings read from CatMeta XML files.  Any chagnes to the PublicNames of the meta tables requires a change here.
//Example: SchemaGeneratorFlags was renamed to MetaFlagsEx.  The constant is still kszSchemaGenFlags, but its value is L"MetaFlagsEx".
#define kszAttributes           (L"Attributes")
#define kszBaseVersion          (L"BaseVersion")
#define kszcbSize               (L"Size")
#define kszCellName             (L"CellName")
#define kszCharacterSet         (L"CharacterSet")
#define kszChildElementName     (L"ChildElementName")
#define kszColumnInternalName   (L"ColumnInternalName")
#define kszColumnMeta           (L"Property")
#define kszColumnMetaFlags      (L"MetaFlags")
#define kszConfigItemName       (L"ItemClass")
#define kszConfigCollectionName (L"ItemCollection")
#define kszContainerClassList   (L"ContainerClassList")
#define kszDatabaseInternalName (L"InternalName")
#define kszDatabaseMeta         (L"DatabaseMeta")
#define kszDescription          (L"Description")
#define kszdbType               (L"Type")
#define kszDefaultValue         (L"DefaultValue")
#define kszEnumMeta             (L"Enum")
#define kszExtendedVersion      (L"ExtendedVersion")
#define kszFlagMeta             (L"Flag")
#define kszForeignTable         (L"ForeignTable")
#define kszForeignColumns       (L"ForeignColumns")
#define kszID                   (L"ID")
#define kszIndexMeta            (L"IndexMeta")
#define kszInheritsColumnMeta   (L"InheritsPropertiesFrom")
#define kszInterceptor          (L"Interceptor")
#define kszInterceptorDLLName   (L"InterceptorDLLName")
#define kszInternalName         (L"InternalName")
#define kszLocator              (L"Locator")
#define kszMaximumValue         (L"EndingNumber")
#define kszMerger               (L"Merger")
#define kszMergerDLLName        (L"MergerDLLName")
#define kszMetaFlags            (L"MetaFlags")
#define kszMinimumValue         (L"StartingNumber")
#define kszNameColumn           (L"NameColumn")
#define kszNameValueMeta        (L"NameValue")
#define kszNavColumn            (L"NavColumn")
#define kszOperator             (L"Operator")
#define kszPrimaryTable         (L"PrimaryTable")
#define kszPrimaryColumns       (L"PrimaryColumns")
#define kszPublicName           (L"PublicName")
#define kszPublicColumnName     (L"PublicColumnName")
#define kszPublicRowName        (L"PublicRowName")
#define kszQueryMeta            (L"QueryMeta")
#define kszReadPlugin           (L"ReadPlugin")
#define kszReadPluginDLLName    (L"ReadPluginDLLName")
#define kszRelationMeta         (L"RelationMeta")
#define kszSchemaGenFlags       (L"MetaFlagsEx")
#define kszServerWiring         (L"ServerWiring")
#define kszTableMeta            (L"Collection")
#define kszTableMetaFlags       (L"MetaFlags")
#define kszUserType             (L"UserType")
#define kszValue                (L"Value")
#define kszWritePlugin          (L"WritePlugin")
#define kszWritePluginDLLName   (L"WritePluginDLLName")


#ifndef __TXMLFILE_H__
    #include "TXmlFile.h"
#endif
#ifndef __TCOLUMNMETA_H__
    #include "TColumnMeta.h"
#endif
#ifndef __TCOMCATMETAXMLFILE_H__
    #include "TComCatMetaXmlFile.h"
#endif
#ifndef __TDATABASEMETA_H__
    #include "TDatabaseMeta.h"
#endif
#ifndef __TRELATIONMETA_H__
    #include "TRelationMeta.h"
#endif
#ifndef __TTABLEMETA_H__
    #include "TTableMeta.h"
#endif
#ifndef __TTAGMETA_H__
    #include "TTagMeta.h"
#endif
#ifndef __TINDEXMETA_H__
    #include "TIndexMeta.h"
#endif
#ifndef __TSCHEMAGENERATION_H__
    #include "TSchemaGeneration.h"
#endif
#ifndef __TTABLEINFOGENERATION_H__
    #include "TTableInfoGeneration.h"
#endif
#ifndef __TFIXUPDLL_H__
    #include "TFixupDLL.h"
#endif
#ifndef __TCOMCATDATAXMLFILE_H__
    #include "TComCatDataXmlFile.h"
#endif
#ifndef __TREGISTERPRODUCTNAME_H__
    #include "TRegisterProductName.h"
#endif
#ifndef __TREGISTERMACHINECONFIGDIRECTORY_H__
    #include "TRegisterMachineConfigDirectory.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __HASH_H__
    #include "Hash.h"
#endif

#ifndef __TPOPULATETABLESCHEMA_H__
    #include "TPopulateTableSchema.h"
#endif
#ifndef __TMETAINFERRENCE_H__
    #include "TMetaInferrence.h"
#endif
#ifndef __THASHEDPKINDEXES_H__
    #include "THashedPKIndexes.h"
#endif
#ifndef __TCOMPLIBCOMPILATIONPLUGIN_H__
    #include "TComplibCompilationPlugin.h"
#endif
#ifndef __THASHEDUNIQUEINDEXES_H__
    #include "THashedUniqueIndexes.h"
#endif
#ifndef __TMETABASEMETAXMLFILE_H__
    #include "TMetabaseMetaXmlFile.h"
#endif
#ifndef __TWRITESCHEMABIN_H__
    #include "TWriteSchemaBin.h"
#endif
#ifndef __TMBSCHEMAGENERATION_H__
    #include "TMBSchemaGeneration.h"
#endif
#ifndef __TLATESCHEMAVALIDATE_H__
    #include "TLateSchemaValidate.h"
#endif


#endif //__XMLUTILITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\core\schemagen\wstring.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __WSTRING_H__
#define __WSTRING_H__

#ifndef __TEXCEPTION_H__
    #include "TException.h"
#endif

// wstring class is a minimal version of std::wstring.  sdt::wstring requires the entire stl.
// Be warned! this class throws exceptions so wrap non-const calls in try-catch
class wstring
{
public:
    wstring() : pstr(0), cbbuffer(0), cbpstr(0){}
    wstring(wstring &str) : pstr(0){assign(str.c_str());}
    wstring(const wchar_t *psz) : pstr(0){assign(psz);}
    ~wstring(){if(pstr)CoTaskMemFree(pstr);}

    const wchar_t * c_str() const {return pstr;}
    operator const wchar_t*() const {return pstr;}

    wstring & operator =(const wstring &str){return assign(str.c_str());}
    wstring & operator +=(const wstring &str){return append(str.c_str());}
    wstring & operator =(const wchar_t *psz){return assign(psz);}
    wstring & operator +=(const wchar_t *psz){return append(psz);}
    bool      operator ==(const wstring &str) const {return isequal(str.c_str());}
    bool      operator ==(const wchar_t *psz) const {return isequal(psz);}
    bool      operator !=(const wstring &str) const {return !isequal(str.c_str());}
    bool      operator !=(const wchar_t *psz) const {return !isequal(psz);}

    size_t length()const {return (0==pstr) ? 0 : wcslen(pstr);}
    void   truncate(size_t i){if(i<length())pstr[i]=0x00;}
private:
    wchar_t *pstr;
    SIZE_T   cbbuffer;
    SIZE_T   cbpstr;

    wstring & append(const wchar_t *psz)
    {
        if(!pstr)
            assign(psz);
        else if(psz)
        {
            SIZE_T cbpsz = (wcslen(psz)+1)*sizeof(wchar_t);
            if((cbpstr+cbpsz-sizeof(wchar_t)) > cbbuffer)
            {
                cbbuffer = (cbpstr+cbpsz-sizeof(wchar_t)) * 2;
                pstr = reinterpret_cast<wchar_t *>(CoTaskMemRealloc(pstr, cbbuffer));
                if(0==pstr)
                    THROW(ERROR - OUTOFMEMORY);
            }
            memcpy(reinterpret_cast<char *>(pstr) + (cbpstr-sizeof(wchar_t)), psz, cbpsz);
            cbpstr += (cbpsz-sizeof(wchar_t));
        }
        return *this;
    }
    wstring & assign(const wchar_t *psz)
    {
        if(psz)
        {
            cbpstr = (wcslen(psz) + 1)*sizeof(wchar_t);
            cbbuffer = cbpstr * 2;//presume that strings will be appended
            pstr = reinterpret_cast<wchar_t *>(CoTaskMemRealloc(pstr, cbbuffer));
            if(0==pstr)
                THROW(ERROR - OUTOFMEMORY);
            memcpy(pstr, psz, cbpstr);
        }
        return *this;
    }
    bool      isequal(const wchar_t *psz) const {return (0==wcscmp(pstr, psz));}
};

#endif // __WSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\appcntadm.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for appcntadm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __appcntadm_h__
#define __appcntadm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAppCenterObj_FWD_DEFINED__
#define __IAppCenterObj_FWD_DEFINED__
typedef interface IAppCenterObj IAppCenterObj;
#endif 	/* __IAppCenterObj_FWD_DEFINED__ */


#ifndef __IAppCenterCol_FWD_DEFINED__
#define __IAppCenterCol_FWD_DEFINED__
typedef interface IAppCenterCol IAppCenterCol;
#endif 	/* __IAppCenterCol_FWD_DEFINED__ */


#ifndef __IAppCenterNotify_FWD_DEFINED__
#define __IAppCenterNotify_FWD_DEFINED__
typedef interface IAppCenterNotify IAppCenterNotify;
#endif 	/* __IAppCenterNotify_FWD_DEFINED__ */


#ifndef __AppCenterObj_FWD_DEFINED__
#define __AppCenterObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppCenterObj AppCenterObj;
#else
typedef struct AppCenterObj AppCenterObj;
#endif /* __cplusplus */

#endif 	/* __AppCenterObj_FWD_DEFINED__ */


#ifndef __AppCenterCol_FWD_DEFINED__
#define __AppCenterCol_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppCenterCol AppCenterCol;
#else
typedef struct AppCenterCol AppCenterCol;
#endif /* __cplusplus */

#endif 	/* __AppCenterCol_FWD_DEFINED__ */


#ifndef __AppCenterServer_FWD_DEFINED__
#define __AppCenterServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppCenterServer AppCenterServer;
#else
typedef struct AppCenterServer AppCenterServer;
#endif /* __cplusplus */

#endif 	/* __AppCenterServer_FWD_DEFINED__ */


#ifndef __AppCenterAdmin_FWD_DEFINED__
#define __AppCenterAdmin_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppCenterAdmin AppCenterAdmin;
#else
typedef struct AppCenterAdmin AppCenterAdmin;
#endif /* __cplusplus */

#endif 	/* __AppCenterAdmin_FWD_DEFINED__ */


#ifndef __AppCenterSystemApp_FWD_DEFINED__
#define __AppCenterSystemApp_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppCenterSystemApp AppCenterSystemApp;
#else
typedef struct AppCenterSystemApp AppCenterSystemApp;
#endif /* __cplusplus */

#endif 	/* __AppCenterSystemApp_FWD_DEFINED__ */


#ifndef __AppCenterDefaultReplApp_FWD_DEFINED__
#define __AppCenterDefaultReplApp_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppCenterDefaultReplApp AppCenterDefaultReplApp;
#else
typedef struct AppCenterDefaultReplApp AppCenterDefaultReplApp;
#endif /* __cplusplus */

#endif 	/* __AppCenterDefaultReplApp_FWD_DEFINED__ */


#ifndef __AppCenterAllSitesApp_FWD_DEFINED__
#define __AppCenterAllSitesApp_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppCenterAllSitesApp AppCenterAllSitesApp;
#else
typedef struct AppCenterAllSitesApp AppCenterAllSitesApp;
#endif /* __cplusplus */

#endif 	/* __AppCenterAllSitesApp_FWD_DEFINED__ */


#ifndef __AppCenterAppQueue_FWD_DEFINED__
#define __AppCenterAppQueue_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppCenterAppQueue AppCenterAppQueue;
#else
typedef struct AppCenterAppQueue AppCenterAppQueue;
#endif /* __cplusplus */

#endif 	/* __AppCenterAppQueue_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_appcntadm_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_appcntadm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_appcntadm_0000_v0_0_s_ifspec;

#ifndef __IAppCenterObj_INTERFACE_DEFINED__
#define __IAppCenterObj_INTERFACE_DEFINED__

/* interface IAppCenterObj */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IAppCenterObj;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D0F4830-4F1C-48A1-A960-C8314A9BC644")
    IAppCenterObj : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollectionName,
            /* [optional][in] */ BSTR bstrQualifier,
            /* [retval][out] */ IAppCenterCol **pCol) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR bstrCollectionName,
            /* [in] */ VARIANT varObjectId,
            /* [retval][out] */ IAppCenterObj **pObj) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ BSTR bstrActivityGuid) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Values( 
            /* [in] */ VARIANT varNames,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Values( 
            /* [in] */ VARIANT varNames,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [hidden][restricted][helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR bstrQualifier) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Xml( 
            /* [in] */ VARIANT varNames,
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppCenterObjVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppCenterObj * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppCenterObj * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppCenterObj * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAppCenterObj * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAppCenterObj * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAppCenterObj * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAppCenterObj * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IAppCenterObj * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            IAppCenterObj * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            IAppCenterObj * This,
            /* [in] */ BSTR bstrCollectionName,
            /* [optional][in] */ BSTR bstrQualifier,
            /* [retval][out] */ IAppCenterCol **pCol);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IAppCenterObj * This,
            /* [in] */ BSTR bstrCollectionName,
            /* [in] */ VARIANT varObjectId,
            /* [retval][out] */ IAppCenterObj **pObj);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IAppCenterObj * This,
            /* [optional][in] */ BSTR bstrActivityGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Values )( 
            IAppCenterObj * This,
            /* [in] */ VARIANT varNames,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Values )( 
            IAppCenterObj * This,
            /* [in] */ VARIANT varNames,
            /* [in] */ VARIANT newVal);
        
        /* [hidden][restricted][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAppCenterObj * This,
            /* [in] */ BSTR bstrQualifier);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            IAppCenterObj * This,
            /* [in] */ VARIANT varNames,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IAppCenterObjVtbl;

    interface IAppCenterObj
    {
        CONST_VTBL struct IAppCenterObjVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppCenterObj_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppCenterObj_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppCenterObj_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppCenterObj_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAppCenterObj_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAppCenterObj_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAppCenterObj_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAppCenterObj_get_Value(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_Value(This,bstrName,pVal)

#define IAppCenterObj_put_Value(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_Value(This,bstrName,newVal)

#define IAppCenterObj_GetCollection(This,bstrCollectionName,bstrQualifier,pCol)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollectionName,bstrQualifier,pCol)

#define IAppCenterObj_GetObject(This,bstrCollectionName,varObjectId,pObj)	\
    (This)->lpVtbl -> GetObject(This,bstrCollectionName,varObjectId,pObj)

#define IAppCenterObj_Save(This,bstrActivityGuid)	\
    (This)->lpVtbl -> Save(This,bstrActivityGuid)

#define IAppCenterObj_get_Values(This,varNames,pVal)	\
    (This)->lpVtbl -> get_Values(This,varNames,pVal)

#define IAppCenterObj_put_Values(This,varNames,newVal)	\
    (This)->lpVtbl -> put_Values(This,varNames,newVal)

#define IAppCenterObj_Initialize(This,bstrQualifier)	\
    (This)->lpVtbl -> Initialize(This,bstrQualifier)

#define IAppCenterObj_get_Xml(This,varNames,pVal)	\
    (This)->lpVtbl -> get_Xml(This,varNames,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_get_Value_Proxy( 
    IAppCenterObj * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IAppCenterObj_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_put_Value_Proxy( 
    IAppCenterObj * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IAppCenterObj_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_GetCollection_Proxy( 
    IAppCenterObj * This,
    /* [in] */ BSTR bstrCollectionName,
    /* [optional][in] */ BSTR bstrQualifier,
    /* [retval][out] */ IAppCenterCol **pCol);


void __RPC_STUB IAppCenterObj_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_GetObject_Proxy( 
    IAppCenterObj * This,
    /* [in] */ BSTR bstrCollectionName,
    /* [in] */ VARIANT varObjectId,
    /* [retval][out] */ IAppCenterObj **pObj);


void __RPC_STUB IAppCenterObj_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_Save_Proxy( 
    IAppCenterObj * This,
    /* [optional][in] */ BSTR bstrActivityGuid);


void __RPC_STUB IAppCenterObj_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_get_Values_Proxy( 
    IAppCenterObj * This,
    /* [in] */ VARIANT varNames,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IAppCenterObj_get_Values_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_put_Values_Proxy( 
    IAppCenterObj * This,
    /* [in] */ VARIANT varNames,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IAppCenterObj_put_Values_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_Initialize_Proxy( 
    IAppCenterObj * This,
    /* [in] */ BSTR bstrQualifier);


void __RPC_STUB IAppCenterObj_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppCenterObj_get_Xml_Proxy( 
    IAppCenterObj * This,
    /* [in] */ VARIANT varNames,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAppCenterObj_get_Xml_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppCenterObj_INTERFACE_DEFINED__ */


#ifndef __IAppCenterCol_INTERFACE_DEFINED__
#define __IAppCenterCol_INTERFACE_DEFINED__

/* interface IAppCenterCol */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IAppCenterCol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD6E90A3-646C-4E63-95A9-0F42B49737A8")
    IAppCenterCol : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ IAppCenterObj **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long celt,
            /* [retval][out] */ SAFEARRAY * *pElements) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IAppCenterCol **pCol) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lSkip) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ BSTR bstrName,
            /* [retval][out] */ IAppCenterObj **pNewObj) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varObjKey) = 0;
        
        virtual /* [hidden][restricted][helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR bstrQualifier) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Xml( 
            /* [in] */ long celt,
            /* [in] */ VARIANT varNames,
            /* [retval][out] */ BSTR *pXmlElements) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ VARIANT varId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Position( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddEx( 
            /* [in] */ SAFEARRAY * bstrIds,
            /* [retval][out] */ long *pAddCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NextEx( 
            /* [in] */ long celt,
            /* [in] */ VARIANT varNames,
            /* [retval][out] */ SAFEARRAY * *psaValues) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppCenterColVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppCenterCol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppCenterCol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppCenterCol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAppCenterCol * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAppCenterCol * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAppCenterCol * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAppCenterCol * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IAppCenterCol * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ IAppCenterObj **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAppCenterCol * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IAppCenterCol * This,
            /* [in] */ long celt,
            /* [retval][out] */ SAFEARRAY * *pElements);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAppCenterCol * This,
            /* [retval][out] */ IAppCenterCol **pCol);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAppCenterCol * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IAppCenterCol * This,
            /* [in] */ long lSkip);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IAppCenterCol * This,
            /* [optional][in] */ BSTR bstrName,
            /* [retval][out] */ IAppCenterObj **pNewObj);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IAppCenterCol * This,
            /* [in] */ VARIANT varObjKey);
        
        /* [hidden][restricted][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAppCenterCol * This,
            /* [in] */ BSTR bstrQualifier);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            IAppCenterCol * This,
            /* [in] */ long celt,
            /* [in] */ VARIANT varNames,
            /* [retval][out] */ BSTR *pXmlElements);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IAppCenterCol * This,
            /* [in] */ VARIANT varId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Position )( 
            IAppCenterCol * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddEx )( 
            IAppCenterCol * This,
            /* [in] */ SAFEARRAY * bstrIds,
            /* [retval][out] */ long *pAddCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NextEx )( 
            IAppCenterCol * This,
            /* [in] */ long celt,
            /* [in] */ VARIANT varNames,
            /* [retval][out] */ SAFEARRAY * *psaValues);
        
        END_INTERFACE
    } IAppCenterColVtbl;

    interface IAppCenterCol
    {
        CONST_VTBL struct IAppCenterColVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppCenterCol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppCenterCol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppCenterCol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppCenterCol_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAppCenterCol_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAppCenterCol_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAppCenterCol_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAppCenterCol_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IAppCenterCol_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IAppCenterCol_Next(This,celt,pElements)	\
    (This)->lpVtbl -> Next(This,celt,pElements)

#define IAppCenterCol_Clone(This,pCol)	\
    (This)->lpVtbl -> Clone(This,pCol)

#define IAppCenterCol_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAppCenterCol_Skip(This,lSkip)	\
    (This)->lpVtbl -> Skip(This,lSkip)

#define IAppCenterCol_Add(This,bstrName,pNewObj)	\
    (This)->lpVtbl -> Add(This,bstrName,pNewObj)

#define IAppCenterCol_Remove(This,varObjKey)	\
    (This)->lpVtbl -> Remove(This,varObjKey)

#define IAppCenterCol_Initialize(This,bstrQualifier)	\
    (This)->lpVtbl -> Initialize(This,bstrQualifier)

#define IAppCenterCol_get_Xml(This,celt,varNames,pXmlElements)	\
    (This)->lpVtbl -> get_Xml(This,celt,varNames,pXmlElements)

#define IAppCenterCol_Seek(This,varId)	\
    (This)->lpVtbl -> Seek(This,varId)

#define IAppCenterCol_get_Position(This,pVal)	\
    (This)->lpVtbl -> get_Position(This,pVal)

#define IAppCenterCol_AddEx(This,bstrIds,pAddCount)	\
    (This)->lpVtbl -> AddEx(This,bstrIds,pAddCount)

#define IAppCenterCol_NextEx(This,celt,varNames,psaValues)	\
    (This)->lpVtbl -> NextEx(This,celt,varNames,psaValues)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_get_Item_Proxy( 
    IAppCenterCol * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ IAppCenterObj **pVal);


void __RPC_STUB IAppCenterCol_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_get_Count_Proxy( 
    IAppCenterCol * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IAppCenterCol_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_Next_Proxy( 
    IAppCenterCol * This,
    /* [in] */ long celt,
    /* [retval][out] */ SAFEARRAY * *pElements);


void __RPC_STUB IAppCenterCol_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_Clone_Proxy( 
    IAppCenterCol * This,
    /* [retval][out] */ IAppCenterCol **pCol);


void __RPC_STUB IAppCenterCol_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_Reset_Proxy( 
    IAppCenterCol * This);


void __RPC_STUB IAppCenterCol_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_Skip_Proxy( 
    IAppCenterCol * This,
    /* [in] */ long lSkip);


void __RPC_STUB IAppCenterCol_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_Add_Proxy( 
    IAppCenterCol * This,
    /* [optional][in] */ BSTR bstrName,
    /* [retval][out] */ IAppCenterObj **pNewObj);


void __RPC_STUB IAppCenterCol_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_Remove_Proxy( 
    IAppCenterCol * This,
    /* [in] */ VARIANT varObjKey);


void __RPC_STUB IAppCenterCol_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_Initialize_Proxy( 
    IAppCenterCol * This,
    /* [in] */ BSTR bstrQualifier);


void __RPC_STUB IAppCenterCol_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_get_Xml_Proxy( 
    IAppCenterCol * This,
    /* [in] */ long celt,
    /* [in] */ VARIANT varNames,
    /* [retval][out] */ BSTR *pXmlElements);


void __RPC_STUB IAppCenterCol_get_Xml_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_Seek_Proxy( 
    IAppCenterCol * This,
    /* [in] */ VARIANT varId);


void __RPC_STUB IAppCenterCol_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_get_Position_Proxy( 
    IAppCenterCol * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IAppCenterCol_get_Position_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_AddEx_Proxy( 
    IAppCenterCol * This,
    /* [in] */ SAFEARRAY * bstrIds,
    /* [retval][out] */ long *pAddCount);


void __RPC_STUB IAppCenterCol_AddEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppCenterCol_NextEx_Proxy( 
    IAppCenterCol * This,
    /* [in] */ long celt,
    /* [in] */ VARIANT varNames,
    /* [retval][out] */ SAFEARRAY * *psaValues);


void __RPC_STUB IAppCenterCol_NextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppCenterCol_INTERFACE_DEFINED__ */


#ifndef __IAppCenterNotify_INTERFACE_DEFINED__
#define __IAppCenterNotify_INTERFACE_DEFINED__

/* interface IAppCenterNotify */
/* [helpstring][version][uuid][oleautomation][local][object] */ 


EXTERN_C const IID IID_IAppCenterNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25BDC24E-D545-4cfb-AC40-3258C269980C")
    IAppCenterNotify : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ BSTR bstrApps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyServer( 
            BOOL bServerAdded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppCenterNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppCenterNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppCenterNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppCenterNotify * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IAppCenterNotify * This,
            /* [in] */ BSTR bstrApps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyServer )( 
            IAppCenterNotify * This,
            BOOL bServerAdded);
        
        END_INTERFACE
    } IAppCenterNotifyVtbl;

    interface IAppCenterNotify
    {
        CONST_VTBL struct IAppCenterNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppCenterNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppCenterNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppCenterNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppCenterNotify_Notify(This,bstrApps)	\
    (This)->lpVtbl -> Notify(This,bstrApps)

#define IAppCenterNotify_NotifyServer(This,bServerAdded)	\
    (This)->lpVtbl -> NotifyServer(This,bServerAdded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAppCenterNotify_Notify_Proxy( 
    IAppCenterNotify * This,
    /* [in] */ BSTR bstrApps);


void __RPC_STUB IAppCenterNotify_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAppCenterNotify_NotifyServer_Proxy( 
    IAppCenterNotify * This,
    BOOL bServerAdded);


void __RPC_STUB IAppCenterNotify_NotifyServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppCenterNotify_INTERFACE_DEFINED__ */



#ifndef __APPCENTERADMLib_LIBRARY_DEFINED__
#define __APPCENTERADMLib_LIBRARY_DEFINED__

/* library APPCENTERADMLib */
/* [hidden][helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_APPCENTERADMLib;

EXTERN_C const CLSID CLSID_AppCenterObj;

#ifdef __cplusplus

class DECLSPEC_UUID("32D973BD-B935-4DE8-A881-6F1A9B697EA9")
AppCenterObj;
#endif

EXTERN_C const CLSID CLSID_AppCenterCol;

#ifdef __cplusplus

class DECLSPEC_UUID("B36311B9-D865-4332-8D62-427A8675C4A9")
AppCenterCol;
#endif

EXTERN_C const CLSID CLSID_AppCenterServer;

#ifdef __cplusplus

class DECLSPEC_UUID("1AEFE812-FB0B-41f4-892A-028E17681895")
AppCenterServer;
#endif

EXTERN_C const CLSID CLSID_AppCenterAdmin;

#ifdef __cplusplus

class DECLSPEC_UUID("200691B9-C444-4089-8C61-247621196B15")
AppCenterAdmin;
#endif

EXTERN_C const CLSID CLSID_AppCenterSystemApp;

#ifdef __cplusplus

class DECLSPEC_UUID("62A711CF-6729-4030-B47E-98600F68AE46")
AppCenterSystemApp;
#endif

EXTERN_C const CLSID CLSID_AppCenterDefaultReplApp;

#ifdef __cplusplus

class DECLSPEC_UUID("F14FBB0A-296D-4e2e-ADB2-041CC6E0960D")
AppCenterDefaultReplApp;
#endif

EXTERN_C const CLSID CLSID_AppCenterAllSitesApp;

#ifdef __cplusplus

class DECLSPEC_UUID("2E3D9AEB-26BD-4f33-8EC4-D6907F0F152D")
AppCenterAllSitesApp;
#endif

EXTERN_C const CLSID CLSID_AppCenterAppQueue;

#ifdef __cplusplus

class DECLSPEC_UUID("A5E079DF-79A6-401f-A2DF-7B40566C7704")
AppCenterAppQueue;
#endif
#endif /* __APPCENTERADMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\iis\metamigrate\metamigrate.cpp ===
// MetaMigrate.cpp

#define INITGUID
#define UNICODE
#define _UNICODE
#include "stdio.h"
#ifndef _INC_CONIO
    #include "conio.h"
#endif
#ifndef __ATLBASE_H__
    #include <atlbase.h>
#endif
#ifndef _OBJBASE_H_
    #include <objbase.h>
#endif
#ifndef __TABLEINFO_H__  
    #include "catmeta.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __WSTRING_H__
    #include "wstring.h"
#endif
#ifndef __iadmw_h__
    #include "iadmw.h"
#endif

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef _DEBUG
#define ASSERT(q) {if(!static_cast<bool>(q)){wprintf(TEXT("Assertion failed:\n\tFile:\t%s\n\tLine Number:\t%d\n\tCode:\t%s\n"), TEXT(__FILE__), __LINE__, TEXT(#q));DebugBreak();exit(0);}}
#else
#define ASSERT(q)
#endif


//We don't have "iiscnfg.x" so we'll define the values right here
#define IIS_MD_FILE_PROP_BASE           6000
#define MD_SCHEMA_CLASS_OPT_PROPERTIES        (IIS_MD_FILE_PROP_BASE+355 )
#define MD_SCHEMA_CLASS_MAND_PROPERTIES       (IIS_MD_FILE_PROP_BASE+356 )
#define IIS_MD_UT_SERVER                1   // Server configuration parameters



struct PropValue {
    DWORD dwMetaID;
    DWORD dwPropID;
    DWORD dwSynID;
    DWORD dwMaxRange;
    DWORD dwMinRange;
    DWORD dwMetaType;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwMetaFlags;
    DWORD dwUserGroup;
    BOOL fMultiValued;
    DWORD dwDefault;
    LPWSTR szDefault;
};

typedef IMSAdminBase * IMSAdminBasePtr;


class MetaHandle {
    METADATA_HANDLE h;
    IMSAdminBasePtr pmb;
public:
    MetaHandle(IMSAdminBasePtr _pmb);
    ~MetaHandle();

    operator METADATA_HANDLE*() { return &h;}
    operator METADATA_HANDLE() { return h;}
    void setpointer(IMSAdminBasePtr _pmb) {
        if (pmb)
            pmb->Release();
        pmb = _pmb;
        if (pmb)
            pmb->AddRef();
    }
    void close() {
        if (pmb != 0 && h != 0) {
            pmb->CloseKey(h);
            h = 0;
        }
    }
    
};

MetaHandle::MetaHandle(IMSAdminBasePtr _pmb) : pmb(_pmb) {
    if (pmb)
        pmb->AddRef();
    h = 0;
}
MetaHandle::~MetaHandle() {
    if (pmb) {
        if (h)
            pmb->CloseKey(h);
        pmb->Release();
    }
}

static HRESULT LoadAllData(IMSAdminBase *pmb, MetaHandle &root, WCHAR *subdir, BYTE *buf, DWORD size, DWORD *count);
static HRESULT MetaMigrate();
static void    WrapInQuotes(LPWSTR wszWrappedString, LPCWSTR wszUnwrappedString);
static void    WrapInQuotes(LPWSTR wszWrappedString, ULONG ul);

int __cdecl main(int argc, char *argv[], char *envp[])
{
    if(FAILED(CoInitialize (NULL)))return -1;

    HRESULT hr;
    if(FAILED(hr = MetaMigrate()))
    {
        wprintf(L"MetaMigrate failed with hr=0x%08x\n", hr);
    }
    CoUninitialize ();
    return 0;
}


HRESULT LoadAllData(IMSAdminBase *pmb, MetaHandle &root, WCHAR *subdir, BYTE *buf, DWORD size, DWORD *count)
{
    HRESULT hr;
    DWORD dataSet;
    DWORD neededSize;

    //
    // Try to get the property names.
    //
    if(FAILED(hr = pmb->GetAllData(root, subdir, METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, count, &dataSet, size, buf, &neededSize)))
        wprintf(L"Error returned from GetAllData (0x%08x) - NeededSize (%d).  Recompile required.\n", hr, neededSize);

    return hr;
}

class TSmartTagMeta
{
public:
    TSmartTagMeta(){}
    ~TSmartTagMeta(){}

    TSmartPointerArray<WCHAR>   pTable;
    ULONG                       ColumnIndex;
    TSmartPointerArray<WCHAR>   pInternalName;
    TSmartPointerArray<WCHAR>   pPublicName;
    ULONG                       Value;
};

class TSmartColumnMeta
{
public:
    TSmartColumnMeta(){}
    ~TSmartColumnMeta(){}

    TSmartPointerArray<WCHAR>   pTable;
    ULONG                       Index;
    TSmartPointerArray<WCHAR>   pInternalName;
    TSmartPointerArray<WCHAR>   pPublicName;
    ULONG                       Type;
    ULONG                       Size;
    ULONG                       MetaFlags;
    TSmartPointerArray<BYTE>    pDefaultValue;
    ULONG                       FlagMask;
    ULONG                       StartingNumber;
    ULONG                       EndingNumber;
    TSmartPointerArray<WCHAR>   pCharacterSet;
    ULONG                       SchemaGeneratorFlags;
    ULONG                       ID;
    ULONG                       UserType;
    ULONG                       Attributes;

//This is not part of ColumnMeta but is needed as a temporary variable
    ULONG                       MDIdentifier;

    TSmartPointerArray<TSmartTagMeta> aTagMeta;
};


HRESULT MetaMigrate()
{
    HRESULT     hr;

    DWORD i,j,k;

    COSERVERINFO    csiName;
    memset(&csiName, 0, sizeof(COSERVERINFO));
    csiName.pwszName =  L"Localhost";
    csiName.pAuthInfo = NULL;

/*
    CComPtr<IClassFactory>  pcsfFactory;
    if(FAILED(hr = CoGetClassObject(CLSID_MSAdminBase, CLSCTX_SERVER, &csiName, IID_IClassFactory, reinterpret_cast<void**>(&pcsfFactory))))return hr;

    CComPtr<IMSAdminBase>   pAdminBase;
    if(FAILED(hr = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, reinterpret_cast<void **>(&pAdminBase))))return hr;
*/
    CComPtr<IMSAdminBase>   pAdminBase;
    if(FAILED(hr = CoCreateInstance(CLSID_MSAdminBase,                // CLSID
                          NULL,                               // controlling unknown
                          CLSCTX_SERVER,                      // desired context
                          IID_IMSAdminBase,                   // IID
                          (VOID**) ( &pAdminBase ))))return hr;       // returned interface

    MetaHandle root(NULL);
    root.setpointer(pAdminBase);
    if(FAILED(hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE, L"/Schema/Properties", METADATA_PERMISSION_READ, 20, root)))return hr;

    const DWORD bufSize = 0x9000;
    BYTE        buf[bufSize];
    ULONG       cColumnMeta;
    if(FAILED(hr = LoadAllData(pAdminBase, root, L"Names", buf, bufSize, &cColumnMeta)))return hr;

    ASSERT(cColumnMeta > 0);
    TSmartPointerArray<TSmartColumnMeta> aColumnMeta = new TSmartColumnMeta[cColumnMeta];
    if(0 == aColumnMeta.m_p)return E_OUTOFMEMORY;

    wprintf(L"Loaded %d Properties\n", cColumnMeta);
    //
    // Now, here we've gotten the list of properties/names.
    // Create IIsSchemaProperty objects for each.  We then
    // Add the object to the two maps.  Later, we will load
    // all of the "Properties/Values" properties, look up (by
    // id) the object, and initialize the property value.
    //
    METADATA_GETALL_RECORD *pmd = (METADATA_GETALL_RECORD *)buf;
    DWORD dwLargestMDID=0;
    for(i=0;i < cColumnMeta; i++, pmd++)
    {
        if (pmd->dwMDDataType != STRING_METADATA)
        {
            wprintf(L"Error: Property name not a string, ignoring it.\n");
            continue;
        }
        LPWSTR name = reinterpret_cast<WCHAR *>(buf + pmd->dwMDDataOffset);
        wprintf(L"  Loading %s\n", name);

        aColumnMeta[i].pInternalName = new WCHAR[wcslen(name)+1];
        if(0 == aColumnMeta[i].pInternalName.m_p)return E_OUTOFMEMORY;
        wcscpy(aColumnMeta[i].pInternalName, name);

        aColumnMeta[i].MDIdentifier = pmd->dwMDIdentifier;//save the MDID in the ID

        if(aColumnMeta[i].MDIdentifier > dwLargestMDID)
            dwLargestMDID = aColumnMeta[i].MDIdentifier;
    }
    
    //(SR 7/17/00) I believe all the MDIDs are small enough that we can create mapping between MDID and index into the aColumnMeta
    if(dwLargestMDID > 1000000)
        wprintf(L"WARNING! dwLargestMDID is quite large (%u)\n", dwLargestMDID);

    TSmartPointerArray<ULONG> aMDIDtoArrayIndex = new ULONG[dwLargestMDID+1];
    if(0 == aMDIDtoArrayIndex.m_p)return E_OUTOFMEMORY;
    const kInvalid = ~0x00;
    memset(aMDIDtoArrayIndex.m_p, kInvalid, sizeof(ULONG) * (dwLargestMDID+1));
    for(i=0;i<cColumnMeta;++i)
    {
        //Not all array elements are initialized so we need to check each time before we access it (we'll standardize on checking the InternalName)
        if(0!=aColumnMeta[i].pInternalName.m_p)
            aMDIDtoArrayIndex[aColumnMeta[i].MDIdentifier] = i;
    }


    ULONG count;
    if(FAILED(hr = LoadAllData(pAdminBase, root, L"Types", buf, bufSize, &count)))return hr;

    //We need to walk the list and fill in additional ColumnMeta information returned from the Types node
    for(i=0;i < count; i++)
    {
        pmd = ((METADATA_GETALL_RECORD*)buf) + i;
        if(pmd->dwMDDataType != BINARY_METADATA  || pmd->dwMDDataLen != sizeof(PropValue))
        {
            wprintf(L"Error - Bad data returned\n");
            return E_FAIL;
        }
        PropValue *pPropValue = reinterpret_cast<PropValue *>(buf+pmd->dwMDDataOffset);


        if(kInvalid==aMDIDtoArrayIndex[pmd->dwMDIdentifier] || 0==aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName.m_p)
        {
            wprintf(L"Error finding prop value 0x%08x\n", pmd->dwMDIdentifier);
            continue;
        }
        if(pmd->dwMDIdentifier != pPropValue->dwPropID)
        {
            wprintf(L"WARNING! Property (%s) has a PropID of (%d)\n\tthat does NOT match the /Schema/Names tree MDIdentifier (%d).\n\tAssuming a PropID of (%d).\n", aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName, pPropValue->dwPropID, pmd->dwMDIdentifier, pmd->dwMDIdentifier);
            pPropValue->dwPropID = pmd->dwMDIdentifier;
        }

        if(pPropValue->dwMetaID == pPropValue->dwPropID)//This means we have an actual property (rather than a flag value)
        {
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pTable;                 not needed, xml infers from parent
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].Index;                  never supplied in xml
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName;          already initialized
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pPublicName;            Public name will always be inferred from InternalName
            aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].Type                      = pPropValue->dwSynID;
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].Size;                   size is always inferred, there is no fixed length in the metabase
            aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].MetaFlags                 = pPropValue->fMultiValued ? fCOLUMNMETA_MULTISTRING : 0;           
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pDefaultValue;          not used
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].FlagMask;               inferred by CatUtil
            aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].StartingNumber            = pPropValue->dwMinRange;      
            aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].EndingNumber              = pPropValue->dwMaxRange;      
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pCharacterSet;          not used by Metabase properties
            //aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].SchemaGeneratorFlags;   none is ever needed
            aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].ID                        = pPropValue->dwMetaID;
            aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].UserType                  = pPropValue->dwUserGroup;
            aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].Attributes                = pPropValue->dwMetaFlags;
        }
        else
        {
            //We have a flag value, we'll make another pass through the properies and deal with these after we've finished building the aColumnMeta
        }
    }

    //Every property name was stored as a ColumnMeta::InternalName; but some of these 'properties' are actaully flag names/values
    //This is where we deal with those (and zero out their aColumnMeta entry)
    for(i=0;i < count; i++)
    {
        pmd = ((METADATA_GETALL_RECORD*)buf) + i;
        if(pmd->dwMDDataType != BINARY_METADATA  || pmd->dwMDDataLen != sizeof(PropValue))
        {
            wprintf(L"Error - Bad data returned\n");
            return E_FAIL;
        }
        PropValue *pPropValue = reinterpret_cast<PropValue *>(buf+pmd->dwMDDataOffset);

        if(kInvalid==aMDIDtoArrayIndex[pmd->dwMDIdentifier] || 0==aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName.m_p)
            continue;

        if(pPropValue->dwMetaID == pPropValue->dwPropID)//This means we have an actual property (rather than a flag value)
        {
            //We've already done the actual properties
        }
        else
        {
            //We have a flag value
            //So scan the aColumnMeta for the matching MetaID
            ULONG j;
            for(j=0;j<cColumnMeta;++j)
            {
                if(0 != aColumnMeta[j].pInternalName.m_p && aColumnMeta[j].ID == pPropValue->dwMetaID)
                    break;
            }
            if(j==cColumnMeta)
            {
                wprintf(L"WARNING! Ignoring Flag value (%s) PropID (%d) that doesn't match up with any property.  Expected to find a Property with MetaID (%d)\n", aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName, pPropValue->dwPropID, pPropValue->dwMetaID);
                aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName.Delete();
            }
            else
            {

                if(0 == aColumnMeta[j].aTagMeta.m_p)//if we haven't already seen a tag, then allocate the aTagMeta
                {
                    aColumnMeta[j].aTagMeta = new TSmartTagMeta[32];//one for each possible flag bit
                    if(0 == aColumnMeta[j].aTagMeta.m_p)return E_OUTOFMEMORY;
                }
                ULONG k=0;
                while(0 != aColumnMeta[j].aTagMeta[k].pInternalName.m_p && k<32)
                {
                    if(pPropValue->dwMask == aColumnMeta[j].aTagMeta[k].Value)
                    {
                        wprintf(L"WARNING! Two flags (%s) & (%s) with the same value on the same property.\n", aColumnMeta[j].aTagMeta[k].pInternalName, aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName);
                    }
                    ++k;
                }
                if(32==k)
                {
                    wprintf(L"WARNING! Too many flags\n");
                }
                else
                {
                    aColumnMeta[j].aTagMeta[k].pInternalName = new WCHAR[wcslen(aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName)+1];
                    if(0 == aColumnMeta[j].aTagMeta[k].pInternalName.m_p)return E_OUTOFMEMORY;
                    wcscpy(aColumnMeta[j].aTagMeta[k].pInternalName, aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName);

                    aColumnMeta[j].aTagMeta[k].Value = pPropValue->dwMask;

                    //This ColumnMeta entry isn't really a property, it's a flag, so remove it from the ColumnMeta array by NULLing the pInternalName
                    aColumnMeta[aMDIDtoArrayIndex[pmd->dwMDIdentifier]].pInternalName.Delete();
                }
            }
        }
    }

    root.close();

    //printf formatting strings

    //This funky left indenting assumes tabs are replaced with 4 spaces, so with the indenting the column allignement you see is what you get.
    static wchar_t *wszBeginning[]=
    {
      L"<?xml version =\"1.0\"?>\n",
      L"<MetaData xmlns=\"x-schema:CatMeta.xms\">\n",
        L"\t<DatabaseMeta               InternalName =\"METABASE\">\n",
          L"\t\t<ServerWiring           Interceptor  =\"Core_XMLInterceptor\"/>\n",
            L"\t\t<Collection         InternalName =\"MetabaseBaseClass\"              MetaFlagsEx=\"NOTABLESCHEMAHEAPENTRY\">\n",
              L"\t\t\t<Property       InternalName =\"Location\"                       Type=\"WSTR\"   MetaFlags=\"PRIMARYKEY\"/>\n",
            L"\t\t</Collection>\n",
    0};

    static wchar_t *wszTableMeta[]=
    {
      L"\t\t<Collection         InternalName =\"%s\"    InheritsPropertiesFrom=\"MetabaseBaseClass\"    MetaFlagsEx=\"NOTABLESCHEMAHEAPENTRY\">\n",
      L"\t\t</Collection>\n",
      L"\t\t<Collection         InternalName =\"%s\">\n",
    0};

    static wchar_t *wszColumnMeta[]=
    {
      L"\t\t\t<Property       InternalName =%-44s",
      L"\tID=%-8s",
      L"\tType=%-12s",
      L"\tMetaFlags=%-12s",
      L"\tStartingNumber=%-14s",
      L"\tEndingNumber=%-16s",
      L"\tUserType=%-20s",
      L"\tAttributes=%s",
      L"\t>\n",
      L"\t/>\n",
      L"\t\t\t</Property>                                 \n",
    0};

    static wchar_t *wszInheritedColumnMeta[]=
    {
      L"\t\t\t<Property       InheritsPropertiesFrom =\"%s:%s\"/>\n",
    0};

    static wchar_t *wszTagMeta[]=
    {
      L"\t\t\t\t<Flag       InternalName =%-44s",
      L"\tValue=%-12s/>\n",
    0};

    static wchar_t *wszEnumMeta[]=
    {
      L"\t\t\t\t<Enum       InternalName =\"%s\"/>\n",
    0};

    static wchar_t *wszMBPropertyCollection[]=
    {
            L"\t\t<Collection         InternalName =\"MBProperty\">\n",
              L"\t\t\t<Property       InternalName =\"Name\"                           Type=\"WSTR\"   MetaFlags=\"PRIMARYKEY\"/>\n",
              L"\t\t\t<Property       InternalName =\"Type\"                           Type=\"UI4\">\n",
                L"\t\t\t\t<Enum       InternalName =\"DWORD\"                          Value=\"1\"/>\n",
                L"\t\t\t\t<Enum       InternalName =\"STRING\"                         Value=\"2\"/>\n",
                L"\t\t\t\t<Enum       InternalName =\"BINARY\"                         Value=\"3\"/>\n",
                L"\t\t\t\t<Enum       InternalName =\"EXPANDSZ\"                       Value=\"4\"/>\n",
                L"\t\t\t\t<Enum       InternalName =\"MULTISZ\"                        Value=\"5\"/>\n",
              L"\t\t\t</Property>\n",
              L"\t\t\t<Property       InternalName =\"Attributes\"                     Type=\"UI4\">\n",
                L"\t\t\t\t<Flag       InternalName =\"NO_ATTRIBUTES\"                  Value=\"0\"/>\n",
                L"\t\t\t\t<Flag       InternalName =\"INHERIT\"                        Value=\"1\"/>\n",
                L"\t\t\t\t<Flag       InternalName =\"PARTIAL_PATH\"                   Value=\"2\"/>\n",
                L"\t\t\t\t<Flag       InternalName =\"SECURE\"                         Value=\"4\"/>\n",
                L"\t\t\t\t<Flag       InternalName =\"REFERENCE\"                      Value=\"8\"/>\n",
                L"\t\t\t\t<Flag       InternalName =\"VOLATILE\"                       Value=\"16\"/>\n",
                L"\t\t\t\t<Flag       InternalName =\"ISINHERITED\"                    Value=\"32\"/>\n",
                L"\t\t\t\t<Flag       InternalName =\"INSERT_PATH\"                    Value=\"64\"/>\n",
                L"\t\t\t\t<Flag       InternalName =\"LOCAL_MACHINE_ONLY\"             Value=\"128\"/>\n",
              L"\t\t\t</Property>\n",
              L"\t\t\t<Property       InternalName =\"Value\"                          Type=\"BYTES\"/>\n",
              L"\t\t\t<Property       InternalName =\"Group\"                          Type=\"UI4\"    MetaFlags=\"PRIMARYKEY\">\n",
                L"\t\t\t\t<Enum       InternalName =\"IIsConfigObject\"/>\n",
    0};

    static wchar_t *wszEnding[]=
    {
                L"\t\t\t\t<Enum       InternalName =\"Custom\"/>\n",
              L"\t\t\t</Property>\n",
              L"\t\t\t<Property       InternalName =\"Location\"                       Type=\"WSTR\"   MetaFlags=\"PRIMARYKEY\"/>\n",
              L"\t\t\t<Property       InternalName =\"ID\"                             Type=\"UI4\"/>\n",
              L"\t\t\t<Property       InternalName =\"UserType\"                       Type=\"UI4\">\n",
                L"\t\t\t\t<Enum       InternalName =\"UNKNOWN_UserType\"               Value=\"0\"/>\n",
                L"\t\t\t\t<Enum       InternalName =\"IIS_MD_UT_SERVER\"               Value=\"1\"/>\n",
                L"\t\t\t\t<Enum       InternalName =\"IIS_MD_UT_FILE\"                 Value=\"2\"/>\n",
                L"\t\t\t\t<Enum       InternalName =\"IIS_MD_UT_WAM\"                  Value=\"100\"/>\n",
                L"\t\t\t\t<Enum       InternalName =\"ASP_MD_UT_APP\"                  Value=\"101\"/>\n",
              L"\t\t\t</Property>\n",
              L"\t\t\t<Property       InternalName =\"LocationID\"                     Type=\"UI4\"    MetaFlags=\"NOTPERSISTABLE\"/>\n",
              L"\t\t\t<ServerWiring   Interceptor =\"Core_MetabaseInterceptor\"/>\n",
            L"\t\t</Collection>\n",
            L"\t\t<Collection         InternalName =\"MBPropertyDiff\"                 InheritsPropertiesFrom=\"MBProperty\">\n",
              L"\t\t\t<Property       InternalName =\"Directive\"                      Type=\"UI4\"       >\n",
                L"\t\t\t\t<Enum       InternalName=\"Insert\"                          Value=\"1\"       />\n",
                L"\t\t\t\t<Enum       InternalName=\"Update\"                          Value=\"2\"       />\n",
                L"\t\t\t\t<Enum       InternalName=\"Delete\"                          Value=\"3\"       />\n",
                L"\t\t\t\t<Enum       InternalName=\"DeleteNode\"                      Value=\"4\"       />\n",
              L"\t\t\t</Property>\n",
              L"\t\t\t<ServerWiring   Interceptor =\"Core_MetabaseDifferencingInterceptor\"/>\n",
            L"\t\t</Collection>\n",
      L"\t</DatabaseMeta> \n",
      L"</MetaData>         \n",
    0};

    static wchar_t *wszType[]=
    {
      0,//invalid                 //From IISSynID.h                          
      L"DWORD",          //#define     IIS_SYNTAX_ID_DWORD         1
      L"STRING",         //#define     IIS_SYNTAX_ID_STRING        2
      L"EXPANDSZ",       //#define     IIS_SYNTAX_ID_EXPANDSZ      3
      L"MULTISZ",        //#define     IIS_SYNTAX_ID_MULTISZ       4
      L"BINARY",         //#define     IIS_SYNTAX_ID_BINARY        5
      L"DWORD",          //#define     IIS_SYNTAX_ID_BOOL          6
      L"DWORD",          //#define     IIS_SYNTAX_ID_BOOL_BITMASK  7
      L"MULTISZ",        //#define     IIS_SYNTAX_ID_MIMEMAP       8
      L"MULTISZ",        //#define     IIS_SYNTAX_ID_IPSECLIST     9
      L"BINARY",         //#define     IIS_SYNTAX_ID_NTACL        10
      L"MULTISZ",        //#define     IIS_SYNTAX_ID_HTTPERRORS   11
      L"MULTISZ",        //#define     IIS_SYNTAX_ID_HTTPHEADERS  12
      0
    };

    static wchar_t *wszUserType[]=
    {
      L"UNKNOWN_UserType",
      L"IIS_MD_UT_SERVER",
      L"IIS_MD_UT_FILE"  ,
      0                  ,
      L"IIS_MD_UT_WAM"   ,
      L"ASP_MD_UT_APP"
    };

    static wchar_t *wszAttributes[]=
    {
      L"INHERIT",
      L"PARTIAL_PATH",
      L"SECURE",
      L"REFERENCE",
      L"VOLATILE",
      L"ISINHERITED",
      L"INSERT_PATH",
      L"LOCAL_MACHINE_ONLY",
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    };

    static wchar_t *wszGlobalProertyList = L"IIsConfigObject";

    try
    {   //wstring throws exceptions so wrap this code in a try-catch block
        wstring wstrCatMeta;

        for(i=0;wszBeginning[i];++i)
            wstrCatMeta += wszBeginning[i];

        WCHAR wszTemp[4096];
        wsprintf(wszTemp, wszTableMeta[2], wszGlobalProertyList);//<Collection InternalName="classname">
        wstrCatMeta += wszTemp;


        wprintf(L"Building GlobalPropertyList");

        WCHAR wszWrappedString[4096];
        for(i=0;i<cColumnMeta;++i)
        {
            if(0 == aColumnMeta[i].pInternalName.m_p)
                continue;
            wprintf(L".");

            TSmartColumnMeta *pColumnMeta = &aColumnMeta[i];

            //Wrap the string in quotes
            WrapInQuotes(wszWrappedString, aColumnMeta[i].pInternalName);
            wsprintf(wszTemp, wszColumnMeta[0], wszWrappedString);
            wstrCatMeta += wszTemp;

            WrapInQuotes(wszWrappedString, aColumnMeta[i].ID);
            wsprintf(wszTemp, wszColumnMeta[1], wszWrappedString);
            wstrCatMeta += wszTemp;

            ASSERT(aColumnMeta[i].Type <= 10);
            ASSERT(0 != wszType[aColumnMeta[i].Type]);
            WrapInQuotes(wszWrappedString, wszType[aColumnMeta[i].Type]);
            wsprintf(wszTemp, wszColumnMeta[2], wszWrappedString);
            wstrCatMeta += wszTemp;

            if(aColumnMeta[i].MetaFlags & fCOLUMNMETA_MULTISTRING)
            {
                //@@@ wsprintf(wszTemp, wszColumnMeta[3], L"\"MULTISTRING\"");
                //@@@ wstrCatMeta += wszTemp;
            }
            else if(aColumnMeta[i].ID == 1002)
            {
                ASSERT(0 == wcscmp(aColumnMeta[i].pInternalName, L"KeyType"));//1002 should be KeyType
                wsprintf(wszTemp, wszColumnMeta[3], L"\"PRIMARYKEY\"");
                wstrCatMeta += wszTemp;
            }

            if(DWORD_METADATA == aColumnMeta[i].Type)
            {
                if(0 != aColumnMeta[i].StartingNumber)//if not the default StartingNumber
                {
                    WrapInQuotes(wszWrappedString, aColumnMeta[i].StartingNumber);
                    wsprintf(wszTemp, wszColumnMeta[4], wszWrappedString);
                    wstrCatMeta += wszTemp;
                }
                if(~0 != aColumnMeta[i].EndingNumber && 0 != aColumnMeta[i].EndingNumber)//if not the default EndingNumber
                {
                    WrapInQuotes(wszWrappedString, aColumnMeta[i].EndingNumber);
                    wsprintf(wszTemp, wszColumnMeta[5], wszWrappedString);
                    wstrCatMeta += wszTemp;
                }
            }
            ASSERT((aColumnMeta[i].UserType&0x0F) <6);
            ASSERT((aColumnMeta[i].UserType&0x0F) != 3);
            if(0 != aColumnMeta[i].UserType)
            {
                WrapInQuotes(wszWrappedString, wszUserType[aColumnMeta[i].UserType&0x0F]);
                wsprintf(wszTemp, wszColumnMeta[6], wszWrappedString);
                wstrCatMeta += wszTemp;
            }


            wstring wstrFlags;
            wstrFlags = L"";

            DWORD Attr = aColumnMeta[i].Attributes;
            bool bFirstAttributeFlag = true;
            for(j=0;0!=Attr && j<32;++j)
            {
                if( (1<<j) & Attr)
                {
                    ASSERT(wszAttributes[j]);
                    if(!bFirstAttributeFlag)
                        wstrFlags += L" ";//All flags are separated by a space, but we don't prepend the first flag with a space
                    else
                        bFirstAttributeFlag = false;
                    wstrFlags += wszAttributes[j];
                    Attr ^= (1<<j);//reset the bit
                }
            }

            if(0 == aColumnMeta[i].aTagMeta.m_p)
            {
                if(0 != wstrFlags[0])//If no Attributes, then it leave off
                {
                    WrapInQuotes(wszWrappedString, wstrFlags);
                    wsprintf(wszTemp, wszColumnMeta[7], wszWrappedString);
                    wstrCatMeta += wszTemp;//  Attributes ="%s"/>
                }
                wstrCatMeta += wszColumnMeta[9];
            }
            else
            {
                WrapInQuotes(wszWrappedString, wstrFlags);
                wsprintf(wszTemp, wszColumnMeta[7], wszWrappedString);
                wstrCatMeta += wszTemp;//  Attributes ="%s"

                wstrCatMeta += wszColumnMeta[8];

                //TagMeta
                for(j=0;0!=aColumnMeta[i].aTagMeta[j].pInternalName.m_p && j<32;++j)
                {
                    WrapInQuotes(wszWrappedString, aColumnMeta[i].aTagMeta[j].pInternalName);
                    wsprintf(wszTemp, wszTagMeta[0], wszWrappedString);
                    wstrCatMeta += wszTemp;

                    WrapInQuotes(wszWrappedString, aColumnMeta[i].aTagMeta[j].Value);
                    wsprintf(wszTemp, wszTagMeta[1], wszWrappedString);
                    wstrCatMeta += wszTemp;
                }
            
                wstrCatMeta += wszColumnMeta[10];//</Property>
            }
        }
        wprintf(L"\n");


        wstrCatMeta += wszTableMeta[1];//</Collection>

        //The MBProperty collection needs a Group column with each of the classes as enums
        wstring wstrMBPropertyCollection;
        for(i=0;wszMBPropertyCollection[i];++i)
            wstrMBPropertyCollection += wszMBPropertyCollection[i];

        // Next, we need to initialize the class map.
        WCHAR className[METADATA_MAX_NAME_LEN];

        if(FAILED(hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE, L"/Schema/Classes", METADATA_PERMISSION_READ, 20, root)))return hr;

        DWORD       dwData      = 0;
        WCHAR       wszContainment[4096];
        WCHAR       wszMandProp   [4096];
        WCHAR       wszOptProp    [4096];

        wprintf(L"Building Class list");
        for(i=0; true; i++)
        {
            hr = pAdminBase->EnumKeys(root, L"", (LPWSTR)className, i);
            if(!SUCCEEDED(hr))
                break;
            wprintf(L".");

            wsprintf(wszTemp, wszTableMeta[0], className);//<Collection InternalName="classname">
            wstrCatMeta += wszTemp;

            wsprintf(wszTemp, wszEnumMeta[0], className);//<Enum InternalName="classname"/>
            wstrMBPropertyCollection += wszTemp;

            METADATA_RECORD mdr;
            mdr.dwMDIdentifier  = MD_SCHEMA_CLASS_OPT_PROPERTIES;
            mdr.dwMDAttributes  = METADATA_NO_ATTRIBUTES;
            mdr.dwMDUserType    = IIS_MD_UT_SERVER;  
            mdr.dwMDDataType    = STRING_METADATA;  
            mdr.dwMDDataLen     = sizeof(wszOptProp);   
            mdr.pbMDData        = reinterpret_cast<unsigned char *>(wszOptProp);
            mdr.dwMDDataTag     = 0;   

            DWORD dwBufferSize;
            if(FAILED(hr = pAdminBase->GetData(root, className, &mdr, &dwBufferSize)))return hr;

            mdr.dwMDIdentifier  = MD_SCHEMA_CLASS_MAND_PROPERTIES;
            mdr.dwMDDataLen     = sizeof(wszMandProp);   
            mdr.pbMDData        = reinterpret_cast<unsigned char *>(wszMandProp);
            if(FAILED(hr = pAdminBase->GetData(root, className, &mdr, &dwBufferSize)))return hr;

            static LPCWSTR wszSeparator = L",";
            wchar_t *       pszProperty;
            pszProperty = wcstok(wszOptProp, wszSeparator);
            while(pszProperty != 0)
            {
                wsprintf(wszTemp, wszInheritedColumnMeta[0], wszGlobalProertyList, pszProperty);
                wstrCatMeta += wszTemp;//<Property InheritsPropertiesFrom="GlobalPropertyList:property"/>

                pszProperty = wcstok(0, wszSeparator);
            }
        
            pszProperty = wcstok(wszMandProp, wszSeparator);
            while(pszProperty != 0)
            {
                wsprintf(wszTemp, wszInheritedColumnMeta[0], wszGlobalProertyList, pszProperty);
                wstrCatMeta += wszTemp;//<Property InheritsPropertiesFrom="GlobalPropertyList:property"/>

                pszProperty = wcstok(0, wszSeparator);
            }

            wstrCatMeta += wszTableMeta[1];//</Collection>
        }
        wprintf(L"\n");


        wstrCatMeta += wstrMBPropertyCollection;//close the MBProperty collection

        i=0;
        while(wszEnding[i])
        {
            wstrCatMeta += wszEnding[i];
            ++i;
        }


        ULONG cch = wstrCatMeta.length();
        //@@@TODO Should probably convert to UTF8
        long cbToWrite = WideCharToMultiByte(CP_ACP, 0, wstrCatMeta.c_str(), cch, 0, 0, 0, 0);

        TSmartPointerArray<char> szCatMeta = new char [cbToWrite];
        if(0 == szCatMeta.m_p)
            return E_OUTOFMEMORY;

        if(cbToWrite != WideCharToMultiByte(CP_ACP, 0, wstrCatMeta.c_str(), cch, szCatMeta, cbToWrite, 0, 0))
        {
            wprintf(L"ERROR! WideCharToMultiByte returned bogus value.\n");
        }
 
        //Create the file
        FILE *pFile = _wfopen(L"CatMeta_Metabase.xml", L"wt");
        fwrite(reinterpret_cast<void *>(szCatMeta.m_p), sizeof(char), cbToWrite, pFile);
        fclose(pFile);
    }
    catch(...)
    {
        wprintf(L"Error!\n");
    }
    return S_OK;
}

void WrapInQuotes(LPWSTR wszWrappedString, LPCWSTR wszUnwrappedString)
{
    wsprintf(wszWrappedString, L"\"%s\"", wszUnwrappedString);
}

void WrapInQuotes(LPWSTR wszWrappedString, ULONG ul)
{
    wsprintf(wszWrappedString, L"\"%u\"", ul);;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\appexpstructs.h ===
//*****************************************************************************
// Structures for AppExpStructs.h
// 4/23/1999  16:29:50
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
#include "icmprecs.h"


// Script supplied data.





#define AppExpTABLENAMELIST() \
	TABLENAME( ApplicationExp ) \
	TABLENAME( ClassExp ) \
	TABLENAME( ClassInterfaceExp ) \
	TABLENAME( ClassInterfaceDispIDExp ) \
	TABLENAME( ClassItfMethodExp ) \
	TABLENAME( RoleDefExp ) \
	TABLENAME( RoleConfigExp ) \
	TABLENAME( RoleSDCacheExp ) \
	TABLENAME( RoleSetExp ) \
	TABLENAME( DllNameExp ) \
	TABLENAME( Subscriptions ) \
	TABLENAME( PublisherProperties ) \
	TABLENAME( SubscriberProperties ) 


#undef TABLENAME
#define TABLENAME( TblName ) TABLENUM_AppExp_##TblName, 
enum
{
	AppExpTABLENAMELIST()
};

#define AppExp_TABLE_COUNT 13
extern const GUID DECLSPEC_SELECTANY SCHEMA_AppExp = { 0x00100200, 0x0000, 0x0000, {  0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }};
extern const COMPLIBSCHEMA DECLSPEC_SELECTANY AppExpSchema = 
{
	&SCHEMA_AppExp,
	5
};


#define SCHEMA_AppExp_Name "AppExp"


#include "pshpack1.h"


//*****************************************************************************
//  AppExp.ApplicationExp
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID ApplID;
    ULONG cbApplNameLen;
    wchar_t ApplName[260];
    unsigned long Flags;
    ULONG cbServerNameLen;
    wchar_t ServerName[260];
    unsigned long ProcessType;
    ULONG cbCommandLineLen;
    wchar_t CommandLine[260];
    ULONG cbServiceNameLen;
    wchar_t ServiceName[256];
    unsigned long RunAsUserType;
    ULONG cbRunAsUserLen;
    wchar_t RunAsUser[260];
    ULONG cbAccessPermissionLen;
    BYTE AccessPermission[260];
    ULONG cbDescriptionLen;
    wchar_t Description[260];
    ULONG cbIsSystemLen;
    wchar_t IsSystem[2];
    unsigned long Authentication;
    unsigned long ShutdownAfter;
    ULONG cbRunForeverLen;
    wchar_t RunForever[2];
    ULONG cbReserved1Len;
    wchar_t Reserved1[81];
    BYTE pad00 [2];
    ULONG cbActivationLen;
    wchar_t Activation[21];
    BYTE pad01 [2];
    ULONG cbChangeableLen;
    wchar_t Changeable[2];
    ULONG cbDeleteableLen;
    wchar_t Deleteable[2];
    ULONG cbCreatedByLen;
    wchar_t CreatedBy[256];
    ULONG cbQueueBlobLen;
    BYTE QueueBlob[260];
    unsigned long RoleBasedSecuritySupported;
    unsigned long RoleBasedSecurityEnabled;
    ULONG cbSecurityDescriptorLen;
    BYTE SecurityDescriptor[260];
    unsigned long ImpersonationLevel;
    unsigned long AuthenticationCapability;
    unsigned long CRMEnabled;
    unsigned long Enable3GigSupport;
    unsigned long IsQueued;
    ULONG cbQCListenerEnabledLen;
    wchar_t QCListenerEnabled[2];
    unsigned long EventsEnabled;
    unsigned long ProcessFlags;
    unsigned long ThreadMax;
    unsigned long IsProxyApp;
    ULONG cbCRMLogFileLen;
    wchar_t CRMLogFile[260];

	inline int IsCRMLogFileNull(void)
	{ return (GetBit(fNullFlags, 35)); }

	inline void SetCRMLogFileNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 35, nullBitVal); }

	inline int IsQCListenerEnabledNull(void)
	{ return (GetBit(fNullFlags, 30)); }

	inline void SetQCListenerEnabledNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 30, nullBitVal); }

	inline int IsSecurityDescriptorNull(void)
	{ return (GetBit(fNullFlags, 24)); }

	inline void SetSecurityDescriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 24, nullBitVal); }

	inline int IsQueueBlobNull(void)
	{ return (GetBit(fNullFlags, 21)); }

	inline void SetQueueBlobNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 21, nullBitVal); }

	inline int IsCreatedByNull(void)
	{ return (GetBit(fNullFlags, 20)); }

	inline void SetCreatedByNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 20, nullBitVal); }

	inline int IsActivationNull(void)
	{ return (GetBit(fNullFlags, 17)); }

	inline void SetActivationNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 17, nullBitVal); }

	inline int IsReserved1Null(void)
	{ return (GetBit(fNullFlags, 16)); }

	inline void SetReserved1Null(int nullBitVal = true)
	{ SetBit(fNullFlags, 16, nullBitVal); }

	inline int IsRunForeverNull(void)
	{ return (GetBit(fNullFlags, 15)); }

	inline void SetRunForeverNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 15, nullBitVal); }

	inline int IsIsSystemNull(void)
	{ return (GetBit(fNullFlags, 12)); }

	inline void SetIsSystemNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 12, nullBitVal); }

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 11)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 11, nullBitVal); }

	inline int IsAccessPermissionNull(void)
	{ return (GetBit(fNullFlags, 10)); }

	inline void SetAccessPermissionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 10, nullBitVal); }

	inline int IsRunAsUserNull(void)
	{ return (GetBit(fNullFlags, 9)); }

	inline void SetRunAsUserNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 9, nullBitVal); }

	inline int IsServiceNameNull(void)
	{ return (GetBit(fNullFlags, 7)); }

	inline void SetServiceNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 7, nullBitVal); }

	inline int IsCommandLineNull(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetCommandLineNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsServerNameNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetServerNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsApplNameNull(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetApplNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_ApplicationExp));
         fNullFlags = (ULONG) -1;
    }

} AppExp_ApplicationExp;

#define COLID_AppExp_ApplicationExp_ApplID 1
#define COLID_AppExp_ApplicationExp_ApplName 2
#define COLID_AppExp_ApplicationExp_Flags 3
#define COLID_AppExp_ApplicationExp_ServerName 4
#define COLID_AppExp_ApplicationExp_ProcessType 5
#define COLID_AppExp_ApplicationExp_CommandLine 6
#define COLID_AppExp_ApplicationExp_ServiceName 7
#define COLID_AppExp_ApplicationExp_RunAsUserType 8
#define COLID_AppExp_ApplicationExp_RunAsUser 9
#define COLID_AppExp_ApplicationExp_AccessPermission 10
#define COLID_AppExp_ApplicationExp_Description 11
#define COLID_AppExp_ApplicationExp_IsSystem 12
#define COLID_AppExp_ApplicationExp_Authentication 13
#define COLID_AppExp_ApplicationExp_ShutdownAfter 14
#define COLID_AppExp_ApplicationExp_RunForever 15
#define COLID_AppExp_ApplicationExp_Reserved1 16
#define COLID_AppExp_ApplicationExp_Activation 17
#define COLID_AppExp_ApplicationExp_Changeable 18
#define COLID_AppExp_ApplicationExp_Deleteable 19
#define COLID_AppExp_ApplicationExp_CreatedBy 20
#define COLID_AppExp_ApplicationExp_QueueBlob 21
#define COLID_AppExp_ApplicationExp_RoleBasedSecuritySupported 22
#define COLID_AppExp_ApplicationExp_RoleBasedSecurityEnabled 23
#define COLID_AppExp_ApplicationExp_SecurityDescriptor 24
#define COLID_AppExp_ApplicationExp_ImpersonationLevel 25
#define COLID_AppExp_ApplicationExp_AuthenticationCapability 26
#define COLID_AppExp_ApplicationExp_CRMEnabled 27
#define COLID_AppExp_ApplicationExp_Enable3GigSupport 28
#define COLID_AppExp_ApplicationExp_IsQueued 29
#define COLID_AppExp_ApplicationExp_QCListenerEnabled 30
#define COLID_AppExp_ApplicationExp_EventsEnabled 31
#define COLID_AppExp_ApplicationExp_ProcessFlags 32
#define COLID_AppExp_ApplicationExp_ThreadMax 33
#define COLID_AppExp_ApplicationExp_IsProxyApp 34
#define COLID_AppExp_ApplicationExp_CRMLogFile 35




//*****************************************************************************
//  AppExp.ClassExp
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID CLSID;
    ULONG cbInprocServer32Len;
    wchar_t InprocServer32[260];
    unsigned long ThreadingModel;
    ULONG cbProgIDLen;
    wchar_t ProgID[260];
    ULONG cbDescriptionLen;
    wchar_t Description[260];
    ULONG cbVIProgIDLen;
    wchar_t VIProgID[260];
    GUID ApplID;
    GUID ImplCLSID;
    unsigned long VersionMajor;
    unsigned long VersionMinor;
    unsigned long VersionBuild;
    unsigned long VersionSubBuild;
    unsigned long Locale;
    unsigned long ClassCtx;
    unsigned long Transaction;
    unsigned long Syncronization;
    unsigned long LoadBalanced;
    unsigned long IISIntrinsics;
    unsigned long ComTIIntrinsics;
    unsigned long JITActivation;
    unsigned long RoleBasedSecurityEnabled;
    ULONG cbSecurityDescriptorLen;
    BYTE SecurityDescriptor[260];
    GUID RoleSetID;
    unsigned long MinPoolSize;
    unsigned long MaxPoolSize;
    unsigned long CreationTimeout;
    ULONG cbConstructStringLen;
    wchar_t ConstructString[260];
    unsigned long ClassFlags;
    GUID DefaultInterface;
    unsigned long NoSetCompleteEtAlOption;
    ULONG cbSavedProgIDLen;
    wchar_t SavedProgID[260];
    GUID RegistrarCLSID;
    ULONG cbExceptionClassLen;
    wchar_t ExceptionClass[260];
    unsigned long IsSelfRegComponent;
    ULONG cbSelfRegInprocServerLen;
    wchar_t SelfRegInprocServer[260];
    unsigned long SelfRegThreadinModel;
    ULONG cbSelfRegProgIDLen;
    wchar_t SelfRegProgID[260];
    ULONG cbSelfRegDescriptionLen;
    wchar_t SelfRegDescription[260];
    ULONG cbSelfRegVIProgIDLen;
    wchar_t SelfRegVIProgID[260];
    unsigned long VbDebuggingFlags;
    unsigned long IsPublisher;
    ULONG cbPublisherIDLen;
    wchar_t PublisherID[260];
    GUID MIPFilterCLSID;
    unsigned long AllowInprocSubscribers;
    unsigned long FireInParalel;
    unsigned long SavedThreadinModel;
    ULONG cbSavedSelfRegVIProgIdLen;
    wchar_t SavedSelfRegVIProgId[260];

	inline int IsSavedSelfRegVIProgIdNull(void)
	{ return (GetBit(fNullFlags, 47)); }

	inline void SetSavedSelfRegVIProgIdNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 47, nullBitVal); }

	inline int IsMIPFilterCLSIDNull(void)
	{ return (GetBit(fNullFlags, 43)); }

	inline void SetMIPFilterCLSIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 43, nullBitVal); }

	inline int IsPublisherIDNull(void)
	{ return (GetBit(fNullFlags, 42)); }

	inline void SetPublisherIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 42, nullBitVal); }

	inline int IsSelfRegVIProgIDNull(void)
	{ return (GetBit(fNullFlags, 39)); }

	inline void SetSelfRegVIProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 39, nullBitVal); }

	inline int IsSelfRegDescriptionNull(void)
	{ return (GetBit(fNullFlags, 38)); }

	inline void SetSelfRegDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 38, nullBitVal); }

	inline int IsSelfRegProgIDNull(void)
	{ return (GetBit(fNullFlags, 37)); }

	inline void SetSelfRegProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 37, nullBitVal); }

	inline int IsSelfRegInprocServerNull(void)
	{ return (GetBit(fNullFlags, 35)); }

	inline void SetSelfRegInprocServerNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 35, nullBitVal); }

	inline int IsExceptionClassNull(void)
	{ return (GetBit(fNullFlags, 33)); }

	inline void SetExceptionClassNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 33, nullBitVal); }

	inline int IsRegistrarCLSIDNull(void)
	{ return (GetBit(fNullFlags, 32)); }

	inline void SetRegistrarCLSIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 32, nullBitVal); }

	inline int IsSavedProgIDNull(void)
	{ return (GetBit(fNullFlags, 31)); }

	inline void SetSavedProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 31, nullBitVal); }

	inline int IsDefaultInterfaceNull(void)
	{ return (GetBit(fNullFlags, 29)); }

	inline void SetDefaultInterfaceNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 29, nullBitVal); }

	inline int IsConstructStringNull(void)
	{ return (GetBit(fNullFlags, 27)); }

	inline void SetConstructStringNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 27, nullBitVal); }

	inline int IsRoleSetIDNull(void)
	{ return (GetBit(fNullFlags, 23)); }

	inline void SetRoleSetIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 23, nullBitVal); }

	inline int IsSecurityDescriptorNull(void)
	{ return (GetBit(fNullFlags, 22)); }

	inline void SetSecurityDescriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 22, nullBitVal); }

	inline int IsImplCLSIDNull(void)
	{ return (GetBit(fNullFlags, 8)); }

	inline void SetImplCLSIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 8, nullBitVal); }

	inline int IsApplIDNull(void)
	{ return (GetBit(fNullFlags, 7)); }

	inline void SetApplIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 7, nullBitVal); }

	inline int IsVIProgIDNull(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetVIProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 5)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 5, nullBitVal); }

	inline int IsProgIDNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsInprocServer32Null(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetInprocServer32Null(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_ClassExp));
         fNullFlags = (ULONG) -1;
    }

} AppExp_ClassExp;

#define COLID_AppExp_ClassExp_CLSID 1
#define COLID_AppExp_ClassExp_InprocServer32 2
#define COLID_AppExp_ClassExp_ThreadingModel 3
#define COLID_AppExp_ClassExp_ProgID 4
#define COLID_AppExp_ClassExp_Description 5
#define COLID_AppExp_ClassExp_VIProgID 6
#define COLID_AppExp_ClassExp_ApplID 7
#define COLID_AppExp_ClassExp_ImplCLSID 8
#define COLID_AppExp_ClassExp_VersionMajor 9
#define COLID_AppExp_ClassExp_VersionMinor 10
#define COLID_AppExp_ClassExp_VersionBuild 11
#define COLID_AppExp_ClassExp_VersionSubBuild 12
#define COLID_AppExp_ClassExp_Locale 13
#define COLID_AppExp_ClassExp_ClassCtx 14
#define COLID_AppExp_ClassExp_Transaction 15
#define COLID_AppExp_ClassExp_Syncronization 16
#define COLID_AppExp_ClassExp_LoadBalanced 17
#define COLID_AppExp_ClassExp_IISIntrinsics 18
#define COLID_AppExp_ClassExp_ComTIIntrinsics 19
#define COLID_AppExp_ClassExp_JITActivation 20
#define COLID_AppExp_ClassExp_RoleBasedSecurityEnabled 21
#define COLID_AppExp_ClassExp_SecurityDescriptor 22
#define COLID_AppExp_ClassExp_RoleSetID 23
#define COLID_AppExp_ClassExp_MinPoolSize 24
#define COLID_AppExp_ClassExp_MaxPoolSize 25
#define COLID_AppExp_ClassExp_CreationTimeout 26
#define COLID_AppExp_ClassExp_ConstructString 27
#define COLID_AppExp_ClassExp_ClassFlags 28
#define COLID_AppExp_ClassExp_DefaultInterface 29
#define COLID_AppExp_ClassExp_NoSetCompleteEtAlOption 30
#define COLID_AppExp_ClassExp_SavedProgID 31
#define COLID_AppExp_ClassExp_RegistrarCLSID 32
#define COLID_AppExp_ClassExp_ExceptionClass 33
#define COLID_AppExp_ClassExp_IsSelfRegComponent 34
#define COLID_AppExp_ClassExp_SelfRegInprocServer 35
#define COLID_AppExp_ClassExp_SelfRegThreadinModel 36
#define COLID_AppExp_ClassExp_SelfRegProgID 37
#define COLID_AppExp_ClassExp_SelfRegDescription 38
#define COLID_AppExp_ClassExp_SelfRegVIProgID 39
#define COLID_AppExp_ClassExp_VbDebuggingFlags 40
#define COLID_AppExp_ClassExp_IsPublisher 41
#define COLID_AppExp_ClassExp_PublisherID 42
#define COLID_AppExp_ClassExp_MIPFilterCLSID 43
#define COLID_AppExp_ClassExp_AllowInprocSubscribers 44
#define COLID_AppExp_ClassExp_FireInParalel 45
#define COLID_AppExp_ClassExp_SavedThreadinModel 46
#define COLID_AppExp_ClassExp_SavedSelfRegVIProgId 47




//*****************************************************************************
//  AppExp.ClassInterfaceExp
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID ConfigClass;
    GUID Interface;
    ULONG cbInterfaceNameLen;
    wchar_t InterfaceName[260];
    ULONG cbSecurityDecriptorLen;
    BYTE SecurityDecriptor[260];
    GUID RoleSetId;
    unsigned long IsDispatchable;
    unsigned long IsQueueable;
    unsigned long IsQueueingSupported;
    ULONG cbDescriptionLen;
    wchar_t Description[260];

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 9)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 9, nullBitVal); }

	inline int IsRoleSetIdNull(void)
	{ return (GetBit(fNullFlags, 5)); }

	inline void SetRoleSetIdNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 5, nullBitVal); }

	inline int IsSecurityDecriptorNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetSecurityDecriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsInterfaceNameNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetInterfaceNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_ClassInterfaceExp));
         fNullFlags = (ULONG) -1;
    }

} AppExp_ClassInterfaceExp;

#define COLID_AppExp_ClassInterfaceExp_ConfigClass 1
#define COLID_AppExp_ClassInterfaceExp_Interface 2
#define COLID_AppExp_ClassInterfaceExp_InterfaceName 3
#define COLID_AppExp_ClassInterfaceExp_SecurityDecriptor 4
#define COLID_AppExp_ClassInterfaceExp_RoleSetId 5
#define COLID_AppExp_ClassInterfaceExp_IsDispatchable 6
#define COLID_AppExp_ClassInterfaceExp_IsQueueable 7
#define COLID_AppExp_ClassInterfaceExp_IsQueueingSupported 8
#define COLID_AppExp_ClassInterfaceExp_Description 9

#define Index_AppExp_MPK_ClassInterfaceExp "AppExp.MPK_ClassInterfaceExp"



//*****************************************************************************
//  AppExp.ClassInterfaceDispIDExp
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID ConfigClass;
    GUID Interface;
    unsigned long DispID;
    ULONG cbSecurityDecriptorLen;
    BYTE SecurityDecriptor[260];

	inline int IsSecurityDecriptorNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetSecurityDecriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_ClassInterfaceDispIDExp));
         fNullFlags = (ULONG) -1;
    }

} AppExp_ClassInterfaceDispIDExp;

#define COLID_AppExp_ClassInterfaceDispIDExp_ConfigClass 1
#define COLID_AppExp_ClassInterfaceDispIDExp_Interface 2
#define COLID_AppExp_ClassInterfaceDispIDExp_DispID 3
#define COLID_AppExp_ClassInterfaceDispIDExp_SecurityDecriptor 4

#define Index_AppExp_MPK_ClassInterfaceDispIDExp "AppExp.MPK_ClassInterfaceDispIDExp"



//*****************************************************************************
//  AppExp.ClassItfMethodExp
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID ConfigClass;
    GUID Interface;
    unsigned long MethodIndex;
    ULONG cbSecurityDecriptorLen;
    BYTE SecurityDecriptor[260];
    GUID RoleSetID;
    ULONG cbMethodNameLen;
    wchar_t MethodName[260];
    unsigned long DispID;
    unsigned long Flags;
    unsigned long AutoComplete;
    ULONG cbDescriptionLen;
    wchar_t Description[260];

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 10)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 10, nullBitVal); }

	inline int IsFlagsNull(void)
	{ return (GetBit(fNullFlags, 8)); }

	inline void SetFlagsNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 8, nullBitVal); }

	inline int IsMethodNameNull(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetMethodNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsRoleSetIDNull(void)
	{ return (GetBit(fNullFlags, 5)); }

	inline void SetRoleSetIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 5, nullBitVal); }

	inline int IsSecurityDecriptorNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetSecurityDecriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_ClassItfMethodExp));
         fNullFlags = (ULONG) -1;
    }

} AppExp_ClassItfMethodExp;

#define COLID_AppExp_ClassItfMethodExp_ConfigClass 1
#define COLID_AppExp_ClassItfMethodExp_Interface 2
#define COLID_AppExp_ClassItfMethodExp_MethodIndex 3
#define COLID_AppExp_ClassItfMethodExp_SecurityDecriptor 4
#define COLID_AppExp_ClassItfMethodExp_RoleSetID 5
#define COLID_AppExp_ClassItfMethodExp_MethodName 6
#define COLID_AppExp_ClassItfMethodExp_DispID 7
#define COLID_AppExp_ClassItfMethodExp_Flags 8
#define COLID_AppExp_ClassItfMethodExp_AutoComplete 9
#define COLID_AppExp_ClassItfMethodExp_Description 10

#define Index_AppExp_MPK_ClassItfMethodExp "AppExp.MPK_ClassItfMethodExp"



//*****************************************************************************
//  AppExp.RoleDefExp
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID Application;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    ULONG cbDescriptionLen;
    wchar_t Description[260];

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_RoleDefExp));
         fNullFlags = (ULONG) -1;
    }

} AppExp_RoleDefExp;

#define COLID_AppExp_RoleDefExp_Application 1
#define COLID_AppExp_RoleDefExp_RoleName 2
#define COLID_AppExp_RoleDefExp_Description 3

#define Index_AppExp_MPK_RoleDefExp "AppExp.MPK_RoleDefExp"



//*****************************************************************************
//  AppExp.RoleConfigExp
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID Application;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    ULONG cbRoleMembersLen;
    wchar_t RoleMembers[260];
    ULONG cbUserSIDLen;
    BYTE UserSID[260];

	inline int IsUserSIDNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetUserSIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_RoleConfigExp));
         fNullFlags = (ULONG) -1;
    }

} AppExp_RoleConfigExp;

#define COLID_AppExp_RoleConfigExp_Application 1
#define COLID_AppExp_RoleConfigExp_RoleName 2
#define COLID_AppExp_RoleConfigExp_RoleMembers 3
#define COLID_AppExp_RoleConfigExp_UserSID 4

#define Index_AppExp_MPK_RoleConfigExp "AppExp.MPK_RoleConfigExp"



//*****************************************************************************
//  AppExp.RoleSDCacheExp
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID Application;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    ULONG cbSecurityDescriptorLen;
    BYTE SecurityDescriptor[260];

	inline int IsSecurityDescriptorNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetSecurityDescriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_RoleSDCacheExp));
         fNullFlags = (ULONG) -1;
    }

} AppExp_RoleSDCacheExp;

#define COLID_AppExp_RoleSDCacheExp_Application 1
#define COLID_AppExp_RoleSDCacheExp_RoleName 2
#define COLID_AppExp_RoleSDCacheExp_SecurityDescriptor 3

#define Index_AppExp_MPK_RoleSDCacheExp "AppExp.MPK_RoleSDCacheExp"



//*****************************************************************************
//  AppExp.RoleSetExp
//*****************************************************************************
typedef struct
{
    GUID RoleSetID;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    GUID Application;

    void Init()
    {
         memset(this, 0, sizeof(AppExp_RoleSetExp));
    }

} AppExp_RoleSetExp;

#define COLID_AppExp_RoleSetExp_RoleSetID 1
#define COLID_AppExp_RoleSetExp_RoleName 2
#define COLID_AppExp_RoleSetExp_Application 3

#define Index_AppExp_MPK_RoleSetExp "AppExp.MPK_RoleSetExp"



//*****************************************************************************
//  AppExp.DllNameExp
//*****************************************************************************
typedef struct
{
    GUID ApplicationID;
    ULONG cbDllNameLen;
    wchar_t DllName[260];

    void Init()
    {
         memset(this, 0, sizeof(AppExp_DllNameExp));
    }

} AppExp_DllNameExp;

#define COLID_AppExp_DllNameExp_ApplicationID 1
#define COLID_AppExp_DllNameExp_DllName 2

#define Index_AppExp_MPK_DllNameExp "AppExp.MPK_DllNameExp"



//*****************************************************************************
//  AppExp.Subscriptions
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID SubscriptionID;
    ULONG cbSubscriptionNameLen;
    wchar_t SubscriptionName[260];
    GUID EventClassID;
    ULONG cbMethodNameLen;
    wchar_t MethodName[260];
    GUID SubscriberCLSID;
    unsigned long PerUser;
    ULONG cbUserNameLen;
    wchar_t UserName[260];
    unsigned long Enabled;
    ULONG cbDescriptionLen;
    wchar_t Description[260];
    ULONG cbMachineNameLen;
    wchar_t MachineName[260];
    ULONG cbPublisherIDLen;
    wchar_t PublisherID[260];
    GUID InterfaceID;
    ULONG cbFilterCriteriaLen;
    wchar_t FilterCriteria[260];
    ULONG cbSubsystemLen;
    wchar_t Subsystem[260];
    ULONG cbSubscriberMonikerLen;
    wchar_t SubscriberMoniker[260];
    unsigned long Queued;
    ULONG cbSubscriberInterfaceLen;
    BYTE SubscriberInterface[9];
    BYTE pad00 [3];

	inline int IsSubscriberInterfaceNull(void)
	{ return (GetBit(fNullFlags, 17)); }

	inline void SetSubscriberInterfaceNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 17, nullBitVal); }

	inline int IsQueuedNull(void)
	{ return (GetBit(fNullFlags, 16)); }

	inline void SetQueuedNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 16, nullBitVal); }

	inline int IsSubscriberMonikerNull(void)
	{ return (GetBit(fNullFlags, 15)); }

	inline void SetSubscriberMonikerNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 15, nullBitVal); }

	inline int IsSubsystemNull(void)
	{ return (GetBit(fNullFlags, 14)); }

	inline void SetSubsystemNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 14, nullBitVal); }

	inline int IsFilterCriteriaNull(void)
	{ return (GetBit(fNullFlags, 13)); }

	inline void SetFilterCriteriaNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 13, nullBitVal); }

	inline int IsInterfaceIDNull(void)
	{ return (GetBit(fNullFlags, 12)); }

	inline void SetInterfaceIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 12, nullBitVal); }

	inline int IsPublisherIDNull(void)
	{ return (GetBit(fNullFlags, 11)); }

	inline void SetPublisherIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 11, nullBitVal); }

	inline int IsMachineNameNull(void)
	{ return (GetBit(fNullFlags, 10)); }

	inline void SetMachineNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 10, nullBitVal); }

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 9)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 9, nullBitVal); }

	inline int IsEnabledNull(void)
	{ return (GetBit(fNullFlags, 8)); }

	inline void SetEnabledNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 8, nullBitVal); }

	inline int IsUserNameNull(void)
	{ return (GetBit(fNullFlags, 7)); }

	inline void SetUserNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 7, nullBitVal); }

	inline int IsPerUserNull(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetPerUserNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsMethodNameNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetMethodNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsEventClassIDNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetEventClassIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_Subscriptions));
         fNullFlags = (ULONG) -1;
    }

} AppExp_Subscriptions;

#define COLID_AppExp_Subscriptions_SubscriptionID 1
#define COLID_AppExp_Subscriptions_SubscriptionName 2
#define COLID_AppExp_Subscriptions_EventClassID 3
#define COLID_AppExp_Subscriptions_MethodName 4
#define COLID_AppExp_Subscriptions_SubscriberCLSID 5
#define COLID_AppExp_Subscriptions_PerUser 6
#define COLID_AppExp_Subscriptions_UserName 7
#define COLID_AppExp_Subscriptions_Enabled 8
#define COLID_AppExp_Subscriptions_Description 9
#define COLID_AppExp_Subscriptions_MachineName 10
#define COLID_AppExp_Subscriptions_PublisherID 11
#define COLID_AppExp_Subscriptions_InterfaceID 12
#define COLID_AppExp_Subscriptions_FilterCriteria 13
#define COLID_AppExp_Subscriptions_Subsystem 14
#define COLID_AppExp_Subscriptions_SubscriberMoniker 15
#define COLID_AppExp_Subscriptions_Queued 16
#define COLID_AppExp_Subscriptions_SubscriberInterface 17

#define Index_AppExp_MPK_Subscriptions "AppExp.MPK_Subscriptions"



//*****************************************************************************
//  AppExp.PublisherProperties
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID SubscriptionID;
    ULONG cbNameLen;
    wchar_t Name[260];
    unsigned long Type;
    ULONG cbDataLen;
    BYTE Data[260];

	inline int IsDataNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetDataNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_PublisherProperties));
         fNullFlags = (ULONG) -1;
    }

} AppExp_PublisherProperties;

#define COLID_AppExp_PublisherProperties_SubscriptionID 1
#define COLID_AppExp_PublisherProperties_Name 2
#define COLID_AppExp_PublisherProperties_Type 3
#define COLID_AppExp_PublisherProperties_Data 4

#define Index_AppExp_MPK_PublisherProperties "AppExp.MPK_PublisherProperties"



//*****************************************************************************
//  AppExp.SubscriberProperties
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID SubscriptionID;
    ULONG cbNameLen;
    wchar_t Name[260];
    unsigned long Type;
    ULONG cbDataLen;
    BYTE Data[260];

	inline int IsDataNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetDataNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(AppExp_SubscriberProperties));
         fNullFlags = (ULONG) -1;
    }

} AppExp_SubscriberProperties;

#define COLID_AppExp_SubscriberProperties_SubscriptionID 1
#define COLID_AppExp_SubscriberProperties_Name 2
#define COLID_AppExp_SubscriberProperties_Type 3
#define COLID_AppExp_SubscriberProperties_Data 4

#define Index_AppExp_MPK_SubscriberProperties "AppExp.MPK_SubscriberProperties"



#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\iis\metamigrate\wstring.h ===
#ifndef __WSTRING_H__
#define __WSTRING_H__


// wstring class is a minimal version of std::wstring.  sdt::wstring requires the entire stl.
// Be warned! this class throws exceptions so wrap non-const calls in try-catch
class wstring
{
public:
    wstring() : pstr(0){}
    wstring(wstring &str) : pstr(0){assign(str.c_str());}
    wstring(const wchar_t *psz) : pstr(0){assign(psz);}
    ~wstring(){if(pstr)free(pstr);}

    const wchar_t * c_str() const {return pstr;}
    operator const wchar_t*() const {return pstr;}

    wstring & operator =(const wstring &str){return assign(str.c_str());}
    wstring & operator +=(const wstring &str){return append(str.c_str());}
    wstring & operator =(const wchar_t *psz){return assign(psz);}
    wstring & operator +=(const wchar_t *psz){return append(psz);}
    bool      operator ==(const wstring &str) const {return isequal(str.c_str());}
    bool      operator ==(const wchar_t *psz) const {return isequal(psz);}
    bool      operator !=(const wstring &str) const {return !isequal(str.c_str());}
    bool      operator !=(const wchar_t *psz) const {return !isequal(psz);}

    size_t length()const {return wcslen(pstr);}
    void   truncate(size_t i){if(i<length())pstr[i]=0x00;}
private:
    wchar_t *pstr;

    wstring & append(const wchar_t *psz){if(!pstr){assign(psz);}else if(psz){pstr = reinterpret_cast<wchar_t *>(realloc(pstr, sizeof(wchar_t)*(wcslen(pstr)+wcslen(psz)+1)));wcscat(pstr, psz);}return *this;}
    wstring & assign(const wchar_t *psz)
    {
        if(psz)
        {
            pstr = reinterpret_cast<wchar_t *>(realloc(pstr, sizeof(wchar_t)*(wcslen(psz)+1)));
            wcscpy(pstr, psz);
        }
        return *this;
    }
    bool      isequal(const wchar_t *psz) const {return (0==wcscmp(pstr, psz));}
};

#endif // __WSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\appexpblobs.h ===
//*****************************************************************************
// Structures for AppExp.clb
// 4/23/1999  16:29:50
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
extern const DECLSPEC_SELECTANY int g_iAppExpTables = 13;
extern const BYTE DECLSPEC_SELECTANY g_rgAppExpSchemaDataRW[] = 
{
	0x0D,0x00,0x00,0x00,0x20,0x0B,0x00,0x00,0x3C,0x00,0x00,0x00,0x90,0x02,0x00,0x00,0xA4,0x05,0x00,0x00,
	0x58,0x06,0x00,0x00,0xBC,0x06,0x00,0x00,0x80,0x07,0x00,0x00,0xD4,0x07,0x00,0x00,0x38,0x08,0x00,0x00,
	0x8C,0x08,0x00,0x00,0xE0,0x08,0x00,0x00,0x24,0x09,0x00,0x00,0x58,0x0A,0x00,0x00,0xBC,0x0A,0x00,0x00,
	0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x28,0x23,0x10,0x00,0x54,0x00,0x00,0xFF,0xFF,0x90,0x00,0x54,0x02,
	0x17,0x00,0x00,0x00,0x01,0x04,0x48,0x00,0x40,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1E,0x00,0x00,0x00,
	0x02,0x01,0x82,0x00,0x44,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x27,0x00,0x00,0x00,0x03,0x00,0x13,0x00,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2D,0x00,0x00,0x00,0x04,0x01,0x82,0x00,0x48,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x38,0x00,0x00,0x00,0x05,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x44,0x00,0x00,0x00,0x06,0x01,0x82,0x00,0x4C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x50,0x00,0x00,0x00,
	0x07,0x01,0x82,0x00,0x50,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x5C,0x00,0x00,0x00,0x08,0x00,0x13,0x00,
	0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x6A,0x00,0x00,0x00,0x09,0x01,0x82,0x00,0x54,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x74,0x00,0x00,0x00,0x0A,0x01,0x80,0x00,0x58,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x85,0x00,0x00,0x00,0x0B,0x01,0x82,0x00,0x5C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x91,0x00,0x00,0x00,
	0x0C,0x01,0x82,0x00,0x60,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0x9A,0x00,0x00,0x00,0x0D,0x00,0x13,0x00,
	0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xA9,0x00,0x00,0x00,0x0E,0x00,0x13,0x00,0x10,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xB7,0x00,0x00,0x00,0x0F,0x01,0x82,0x00,0x64,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,
	0xC2,0x00,0x00,0x00,0x10,0x01,0x82,0x00,0x68,0x00,0x04,0x00,0x50,0x00,0xFF,0x43,0xCC,0x00,0x00,0x00,
	0x11,0x01,0x82,0x00,0x6C,0x00,0x04,0x00,0x14,0x00,0xFF,0x43,0xD7,0x00,0x00,0x00,0x12,0x00,0x82,0x00,
	0x70,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0xE2,0x00,0x00,0x00,0x13,0x00,0x82,0x00,0x74,0x00,0x04,0x00,
	0x01,0x00,0xFF,0x43,0xED,0x00,0x00,0x00,0x14,0x01,0x82,0x00,0x78,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,
	0xF7,0x00,0x00,0x00,0x15,0x01,0x80,0x00,0x7C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x01,0x01,0x00,0x00,
	0x16,0x00,0x13,0x00,0x14,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1C,0x01,0x00,0x00,0x17,0x00,0x13,0x00,
	0x18,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x35,0x01,0x00,0x00,0x18,0x01,0x80,0x00,0x80,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x48,0x01,0x00,0x00,0x19,0x00,0x13,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x5B,0x01,0x00,0x00,0x1A,0x00,0x13,0x00,0x20,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x74,0x01,0x00,0x00,
	0x1B,0x00,0x13,0x00,0x24,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x7F,0x01,0x00,0x00,0x1C,0x00,0x13,0x00,
	0x28,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x91,0x01,0x00,0x00,0x1D,0x00,0x13,0x00,0x2C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x9A,0x01,0x00,0x00,0x1E,0x01,0x82,0x00,0x84,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,
	0xAC,0x01,0x00,0x00,0x1F,0x00,0x13,0x00,0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xBA,0x01,0x00,0x00,
	0x20,0x00,0x13,0x00,0x34,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC7,0x01,0x00,0x00,0x21,0x00,0x13,0x00,
	0x38,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xD1,0x01,0x00,0x00,0x22,0x00,0x13,0x00,0x3C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xDC,0x01,0x00,0x00,0x23,0x01,0x82,0x00,0x88,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xE7,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x8C,0x00,0x01,0x01,0x00,0x58,0x03,0x02,0x00,0x00,
	0x01,0x00,0x01,0x28,0x2F,0x14,0x00,0x54,0x00,0x00,0xFF,0xFF,0xC0,0x00,0x14,0x03,0x13,0x02,0x00,0x00,
	0x01,0x04,0x48,0x00,0x68,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x19,0x02,0x00,0x00,0x02,0x01,0x82,0x00,
	0x6C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x28,0x02,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x37,0x02,0x00,0x00,0x04,0x01,0x82,0x00,0x70,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x85,0x00,0x00,0x00,0x05,0x01,0x82,0x00,0x74,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x3E,0x02,0x00,0x00,
	0x06,0x01,0x82,0x00,0x78,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x17,0x00,0x00,0x00,0x07,0x01,0x48,0x00,
	0x7C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x47,0x02,0x00,0x00,0x08,0x01,0x48,0x00,0x80,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x51,0x02,0x00,0x00,0x09,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x5E,0x02,0x00,0x00,0x0A,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x6B,0x02,0x00,0x00,
	0x0B,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x78,0x02,0x00,0x00,0x0C,0x00,0x13,0x00,
	0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x88,0x02,0x00,0x00,0x0D,0x00,0x13,0x00,0x14,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x8F,0x02,0x00,0x00,0x0E,0x00,0x13,0x00,0x18,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x98,0x02,0x00,0x00,0x0F,0x00,0x13,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xA4,0x02,0x00,0x00,
	0x10,0x00,0x13,0x00,0x20,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xB3,0x02,0x00,0x00,0x11,0x00,0x13,0x00,
	0x24,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC0,0x02,0x00,0x00,0x12,0x00,0x13,0x00,0x28,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xCE,0x02,0x00,0x00,0x13,0x00,0x13,0x00,0x2C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xDE,0x02,0x00,0x00,0x14,0x00,0x13,0x00,0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1C,0x01,0x00,0x00,
	0x15,0x00,0x13,0x00,0x34,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x35,0x01,0x00,0x00,0x16,0x01,0x80,0x00,
	0x84,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xEC,0x02,0x00,0x00,0x17,0x01,0x48,0x00,0x88,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xF6,0x02,0x00,0x00,0x18,0x00,0x13,0x00,0x38,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x02,0x03,0x00,0x00,0x19,0x00,0x13,0x00,0x3C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0E,0x03,0x00,0x00,
	0x1A,0x00,0x13,0x00,0x40,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1E,0x03,0x00,0x00,0x1B,0x01,0x82,0x00,
	0x8C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x2E,0x03,0x00,0x00,0x1C,0x00,0x13,0x00,0x44,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x39,0x03,0x00,0x00,0x1D,0x01,0x48,0x00,0x90,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x4A,0x03,0x00,0x00,0x1E,0x00,0x13,0x00,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x62,0x03,0x00,0x00,
	0x1F,0x01,0x82,0x00,0x94,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x6E,0x03,0x00,0x00,0x20,0x01,0x48,0x00,
	0x98,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x7D,0x03,0x00,0x00,0x21,0x01,0x82,0x00,0x9C,0x00,0x04,0x00,
	0xF4,0x01,0xFF,0x43,0x8C,0x03,0x00,0x00,0x22,0x00,0x13,0x00,0x4C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x9F,0x03,0x00,0x00,0x23,0x01,0x82,0x00,0xA0,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xB3,0x03,0x00,0x00,
	0x24,0x00,0x13,0x00,0x50,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC8,0x03,0x00,0x00,0x25,0x01,0x82,0x00,
	0xA4,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xD6,0x03,0x00,0x00,0x26,0x01,0x82,0x00,0xA8,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0xE9,0x03,0x00,0x00,0x27,0x01,0x82,0x00,0xAC,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xF9,0x03,0x00,0x00,0x28,0x00,0x13,0x00,0x54,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0A,0x04,0x00,0x00,
	0x29,0x00,0x13,0x00,0x58,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x16,0x04,0x00,0x00,0x2A,0x01,0x82,0x00,
	0xB0,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x22,0x04,0x00,0x00,0x2B,0x01,0x48,0x00,0xB4,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x31,0x04,0x00,0x00,0x2C,0x00,0x13,0x00,0x5C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x48,0x04,0x00,0x00,0x2D,0x00,0x13,0x00,0x60,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x56,0x04,0x00,0x00,
	0x2E,0x00,0x13,0x00,0x64,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x69,0x04,0x00,0x00,0x2F,0x01,0x82,0x00,
	0xB8,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x7E,0x04,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0xBC,0x00,
	0x01,0x01,0x00,0x58,0x94,0x04,0x00,0x00,0x02,0x00,0x01,0x20,0x09,0x04,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x28,0x00,0xB4,0x00,0xAD,0x04,0x00,0x00,0x01,0x82,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xB9,0x04,0x00,0x00,0x02,0x82,0x48,0x00,0x10,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xC3,0x04,0x00,0x00,
	0x03,0x01,0x82,0x00,0x14,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xD1,0x04,0x00,0x00,0x04,0x01,0x80,0x00,
	0x18,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xE3,0x04,0x00,0x00,0x05,0x01,0x48,0x00,0x1C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xED,0x04,0x00,0x00,0x06,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xFC,0x04,0x00,0x00,0x07,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x08,0x05,0x00,0x00,
	0x08,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x85,0x00,0x00,0x00,0x09,0x01,0x82,0x00,
	0x20,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x1C,0x05,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x24,0x00,
	0x02,0x01,0x02,0x58,0x39,0x05,0x00,0x00,0x03,0x00,0x01,0x20,0x04,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x14,0x00,0x64,0x00,0xAD,0x04,0x00,0x00,0x01,0x82,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xB9,0x04,0x00,0x00,0x02,0x82,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x58,0x05,0x00,0x00,
	0x03,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xD1,0x04,0x00,0x00,0x04,0x01,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x5F,0x05,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x10,0x00,
	0x03,0x01,0x02,0x03,0x82,0x05,0x00,0x00,0x04,0x00,0x01,0x20,0x0A,0x05,0x01,0x54,0x00,0x00,0x28,0x00,
	0x30,0x00,0xC4,0x00,0xAD,0x04,0x00,0x00,0x01,0x82,0x48,0x00,0x10,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xB9,0x04,0x00,0x00,0x02,0x82,0x48,0x00,0x14,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9B,0x05,0x00,0x00,
	0x03,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xD1,0x04,0x00,0x00,0x04,0x01,0x80,0x00,
	0x18,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xEC,0x02,0x00,0x00,0x05,0x01,0x48,0x00,0x1C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xA7,0x05,0x00,0x00,0x06,0x01,0x82,0x00,0x20,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x58,0x05,0x00,0x00,0x07,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x27,0x00,0x00,0x00,
	0x08,0x01,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x00,0x43,0xB2,0x05,0x00,0x00,0x09,0x00,0x13,0x00,
	0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x85,0x00,0x00,0x00,0x0A,0x01,0x82,0x00,0x24,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0xBF,0x05,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x2C,0x00,0x03,0x01,0x02,0x03,
	0xDC,0x05,0x00,0x00,0x05,0x00,0x01,0x20,0x03,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,
	0xEE,0x05,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFA,0x05,0x00,0x00,
	0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x85,0x00,0x00,0x00,0x03,0x01,0x82,0x00,
	0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x03,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,
	0x02,0x01,0x02,0x58,0x19,0x06,0x00,0x00,0x06,0x00,0x01,0x20,0x04,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x14,0x00,0x64,0x00,0xEE,0x05,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xFA,0x05,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x2E,0x06,0x00,0x00,
	0x03,0x82,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x3A,0x06,0x00,0x00,0x04,0x01,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x42,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x10,0x00,
	0x03,0x01,0x02,0x03,0x5B,0x06,0x00,0x00,0x07,0x00,0x01,0x20,0x03,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x10,0x00,0x54,0x00,0xEE,0x05,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xFA,0x05,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x35,0x01,0x00,0x00,
	0x03,0x01,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x71,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0x8B,0x06,0x00,0x00,0x08,0x00,0x01,0x20,0x03,0x00,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0xEC,0x02,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xFA,0x05,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xEE,0x05,0x00,0x00,0x03,0x00,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9D,0x06,0x00,0x00,
	0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0xB3,0x06,0x00,0x00,0x09,0x00,0x01,0x20,
	0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x0C,0x00,0x44,0x00,0xC5,0x06,0x00,0x00,0x01,0x82,0x48,0x00,
	0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xD3,0x06,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0xDB,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x08,0x00,0x02,0x01,0x02,0x58,
	0xF1,0x06,0x00,0x00,0x0A,0x00,0x01,0x20,0x11,0x0E,0x03,0x54,0x00,0x00,0x44,0x00,0x4C,0x00,0x34,0x01,
	0x06,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x15,0x07,0x00,0x00,
	0x02,0x00,0x82,0x00,0x10,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x26,0x07,0x00,0x00,0x03,0x01,0x48,0x00,
	0x14,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xA7,0x05,0x00,0x00,0x04,0x01,0x82,0x00,0x18,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x33,0x07,0x00,0x00,0x05,0x00,0x48,0x00,0x1C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x43,0x07,0x00,0x00,0x06,0x01,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x43,0x4B,0x07,0x00,0x00,
	0x07,0x01,0x82,0x00,0x20,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x54,0x07,0x00,0x00,0x08,0x01,0x13,0x00,
	0x04,0x00,0x04,0x00,0x04,0x00,0x01,0x43,0x85,0x00,0x00,0x00,0x09,0x01,0x82,0x00,0x24,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x5C,0x07,0x00,0x00,0x0A,0x01,0x82,0x00,0x28,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x16,0x04,0x00,0x00,0x0B,0x01,0x82,0x00,0x2C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x68,0x07,0x00,0x00,
	0x0C,0x01,0x48,0x00,0x30,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x74,0x07,0x00,0x00,0x0D,0x01,0x82,0x00,
	0x34,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x83,0x07,0x00,0x00,0x0E,0x01,0x82,0x00,0x38,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x8D,0x07,0x00,0x00,0x0F,0x01,0x82,0x00,0x3C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x9F,0x07,0x00,0x00,0x10,0x01,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x43,0xA6,0x07,0x00,0x00,
	0x11,0x01,0x80,0x00,0x40,0x00,0x04,0x00,0x08,0x00,0xFF,0x43,0xBA,0x07,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x48,0x00,0x01,0x01,0x00,0x58,0xD3,0x07,0x00,0x00,0x0B,0x00,0x01,0x20,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x06,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x04,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xEE,0x07,0x00,0x00,0x02,0x82,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xF3,0x07,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xF8,0x07,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFD,0x07,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x10,0x00,0x02,0x01,0x02,0x58,0x1C,0x08,0x00,0x00,0x0C,0x00,0x01,0x20,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x06,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x04,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xEE,0x07,0x00,0x00,0x02,0x82,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xF3,0x07,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xF8,0x07,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x38,0x08,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x10,0x00,0x02,0x01,0x02,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbAppExpSchemaRW = 2848;
extern const DECLSPEC_SELECTANY BYTE g_rgAppExpSchemaStringHeap[] = 
{
	0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x41,0x70,0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x45,
	0x78,0x70,0x00,0x41,0x70,0x70,0x6C,0x49,0x44,0x00,0x41,0x70,0x70,0x6C,0x4E,0x61,0x6D,0x65,0x00,0x46,
	0x6C,0x61,0x67,0x73,0x00,0x53,0x65,0x72,0x76,0x65,0x72,0x4E,0x61,0x6D,0x65,0x00,0x50,0x72,0x6F,0x63,
	0x65,0x73,0x73,0x54,0x79,0x70,0x65,0x00,0x43,0x6F,0x6D,0x6D,0x61,0x6E,0x64,0x4C,0x69,0x6E,0x65,0x00,
	0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x4E,0x61,0x6D,0x65,0x00,0x52,0x75,0x6E,0x41,0x73,0x55,0x73,0x65,
	0x72,0x54,0x79,0x70,0x65,0x00,0x52,0x75,0x6E,0x41,0x73,0x55,0x73,0x65,0x72,0x00,0x41,0x63,0x63,0x65,
	0x73,0x73,0x50,0x65,0x72,0x6D,0x69,0x73,0x73,0x69,0x6F,0x6E,0x00,0x44,0x65,0x73,0x63,0x72,0x69,0x70,
	0x74,0x69,0x6F,0x6E,0x00,0x49,0x73,0x53,0x79,0x73,0x74,0x65,0x6D,0x00,0x41,0x75,0x74,0x68,0x65,0x6E,
	0x74,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x00,0x53,0x68,0x75,0x74,0x64,0x6F,0x77,0x6E,0x41,0x66,0x74,
	0x65,0x72,0x00,0x52,0x75,0x6E,0x46,0x6F,0x72,0x65,0x76,0x65,0x72,0x00,0x52,0x65,0x73,0x65,0x72,0x76,
	0x65,0x64,0x31,0x00,0x41,0x63,0x74,0x69,0x76,0x61,0x74,0x69,0x6F,0x6E,0x00,0x43,0x68,0x61,0x6E,0x67,
	0x65,0x61,0x62,0x6C,0x65,0x00,0x44,0x65,0x6C,0x65,0x74,0x65,0x61,0x62,0x6C,0x65,0x00,0x43,0x72,0x65,
	0x61,0x74,0x65,0x64,0x42,0x79,0x00,0x51,0x75,0x65,0x75,0x65,0x42,0x6C,0x6F,0x62,0x00,0x52,0x6F,0x6C,
	0x65,0x42,0x61,0x73,0x65,0x64,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x53,0x75,0x70,0x70,0x6F,0x72,
	0x74,0x65,0x64,0x00,0x52,0x6F,0x6C,0x65,0x42,0x61,0x73,0x65,0x64,0x53,0x65,0x63,0x75,0x72,0x69,0x74,
	0x79,0x45,0x6E,0x61,0x62,0x6C,0x65,0x64,0x00,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x44,0x65,0x73,
	0x63,0x72,0x69,0x70,0x74,0x6F,0x72,0x00,0x49,0x6D,0x70,0x65,0x72,0x73,0x6F,0x6E,0x61,0x74,0x69,0x6F,
	0x6E,0x4C,0x65,0x76,0x65,0x6C,0x00,0x41,0x75,0x74,0x68,0x65,0x6E,0x74,0x69,0x63,0x61,0x74,0x69,0x6F,
	0x6E,0x43,0x61,0x70,0x61,0x62,0x69,0x6C,0x69,0x74,0x79,0x00,0x43,0x52,0x4D,0x45,0x6E,0x61,0x62,0x6C,
	0x65,0x64,0x00,0x45,0x6E,0x61,0x62,0x6C,0x65,0x33,0x47,0x69,0x67,0x53,0x75,0x70,0x70,0x6F,0x72,0x74,
	0x00,0x49,0x73,0x51,0x75,0x65,0x75,0x65,0x64,0x00,0x51,0x43,0x4C,0x69,0x73,0x74,0x65,0x6E,0x65,0x72,
	0x45,0x6E,0x61,0x62,0x6C,0x65,0x64,0x00,0x45,0x76,0x65,0x6E,0x74,0x73,0x45,0x6E,0x61,0x62,0x6C,0x65,
	0x64,0x00,0x50,0x72,0x6F,0x63,0x65,0x73,0x73,0x46,0x6C,0x61,0x67,0x73,0x00,0x54,0x68,0x72,0x65,0x61,
	0x64,0x4D,0x61,0x78,0x00,0x49,0x73,0x50,0x72,0x6F,0x78,0x79,0x41,0x70,0x70,0x00,0x43,0x52,0x4D,0x4C,
	0x6F,0x67,0x46,0x69,0x6C,0x65,0x00,0x23,0x23,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x41,0x70,0x70,0x6C,
	0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x45,0x78,0x70,0x5F,0x44,0x65,0x78,0x00,0x41,0x70,0x70,0x45,0x78,
	0x70,0x2E,0x43,0x6C,0x61,0x73,0x73,0x45,0x78,0x70,0x00,0x43,0x4C,0x53,0x49,0x44,0x00,0x49,0x6E,0x70,
	0x72,0x6F,0x63,0x53,0x65,0x72,0x76,0x65,0x72,0x33,0x32,0x00,0x54,0x68,0x72,0x65,0x61,0x64,0x69,0x6E,
	0x67,0x4D,0x6F,0x64,0x65,0x6C,0x00,0x50,0x72,0x6F,0x67,0x49,0x44,0x00,0x56,0x49,0x50,0x72,0x6F,0x67,
	0x49,0x44,0x00,0x49,0x6D,0x70,0x6C,0x43,0x4C,0x53,0x49,0x44,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,
	0x4D,0x61,0x6A,0x6F,0x72,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,0x4D,0x69,0x6E,0x6F,0x72,0x00,0x56,
	0x65,0x72,0x73,0x69,0x6F,0x6E,0x42,0x75,0x69,0x6C,0x64,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,0x53,
	0x75,0x62,0x42,0x75,0x69,0x6C,0x64,0x00,0x4C,0x6F,0x63,0x61,0x6C,0x65,0x00,0x43,0x6C,0x61,0x73,0x73,
	0x43,0x74,0x78,0x00,0x54,0x72,0x61,0x6E,0x73,0x61,0x63,0x74,0x69,0x6F,0x6E,0x00,0x53,0x79,0x6E,0x63,
	0x72,0x6F,0x6E,0x69,0x7A,0x61,0x74,0x69,0x6F,0x6E,0x00,0x4C,0x6F,0x61,0x64,0x42,0x61,0x6C,0x61,0x6E,
	0x63,0x65,0x64,0x00,0x49,0x49,0x53,0x49,0x6E,0x74,0x72,0x69,0x6E,0x73,0x69,0x63,0x73,0x00,0x43,0x6F,
	0x6D,0x54,0x49,0x49,0x6E,0x74,0x72,0x69,0x6E,0x73,0x69,0x63,0x73,0x00,0x4A,0x49,0x54,0x41,0x63,0x74,
	0x69,0x76,0x61,0x74,0x69,0x6F,0x6E,0x00,0x52,0x6F,0x6C,0x65,0x53,0x65,0x74,0x49,0x44,0x00,0x4D,0x69,
	0x6E,0x50,0x6F,0x6F,0x6C,0x53,0x69,0x7A,0x65,0x00,0x4D,0x61,0x78,0x50,0x6F,0x6F,0x6C,0x53,0x69,0x7A,
	0x65,0x00,0x43,0x72,0x65,0x61,0x74,0x69,0x6F,0x6E,0x54,0x69,0x6D,0x65,0x6F,0x75,0x74,0x00,0x43,0x6F,
	0x6E,0x73,0x74,0x72,0x75,0x63,0x74,0x53,0x74,0x72,0x69,0x6E,0x67,0x00,0x43,0x6C,0x61,0x73,0x73,0x46,
	0x6C,0x61,0x67,0x73,0x00,0x44,0x65,0x66,0x61,0x75,0x6C,0x74,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,
	0x65,0x00,0x4E,0x6F,0x53,0x65,0x74,0x43,0x6F,0x6D,0x70,0x6C,0x65,0x74,0x65,0x45,0x74,0x41,0x6C,0x4F,
	0x70,0x74,0x69,0x6F,0x6E,0x00,0x53,0x61,0x76,0x65,0x64,0x50,0x72,0x6F,0x67,0x49,0x44,0x00,0x52,0x65,
	0x67,0x69,0x73,0x74,0x72,0x61,0x72,0x43,0x4C,0x53,0x49,0x44,0x00,0x45,0x78,0x63,0x65,0x70,0x74,0x69,
	0x6F,0x6E,0x43,0x6C,0x61,0x73,0x73,0x00,0x49,0x73,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x43,0x6F,0x6D,
	0x70,0x6F,0x6E,0x65,0x6E,0x74,0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x49,0x6E,0x70,0x72,0x6F,0x63,
	0x53,0x65,0x72,0x76,0x65,0x72,0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x54,0x68,0x72,0x65,0x61,0x64,
	0x69,0x6E,0x4D,0x6F,0x64,0x65,0x6C,0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x50,0x72,0x6F,0x67,0x49,
	0x44,0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x44,0x65,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6F,0x6E,
	0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x56,0x49,0x50,0x72,0x6F,0x67,0x49,0x44,0x00,0x56,0x62,0x44,
	0x65,0x62,0x75,0x67,0x67,0x69,0x6E,0x67,0x46,0x6C,0x61,0x67,0x73,0x00,0x49,0x73,0x50,0x75,0x62,0x6C,
	0x69,0x73,0x68,0x65,0x72,0x00,0x50,0x75,0x62,0x6C,0x69,0x73,0x68,0x65,0x72,0x49,0x44,0x00,0x4D,0x49,
	0x50,0x46,0x69,0x6C,0x74,0x65,0x72,0x43,0x4C,0x53,0x49,0x44,0x00,0x41,0x6C,0x6C,0x6F,0x77,0x49,0x6E,
	0x70,0x72,0x6F,0x63,0x53,0x75,0x62,0x73,0x63,0x72,0x69,0x62,0x65,0x72,0x73,0x00,0x46,0x69,0x72,0x65,
	0x49,0x6E,0x50,0x61,0x72,0x61,0x6C,0x65,0x6C,0x00,0x53,0x61,0x76,0x65,0x64,0x54,0x68,0x72,0x65,0x61,
	0x64,0x69,0x6E,0x4D,0x6F,0x64,0x65,0x6C,0x00,0x53,0x61,0x76,0x65,0x64,0x53,0x65,0x6C,0x66,0x52,0x65,
	0x67,0x56,0x49,0x50,0x72,0x6F,0x67,0x49,0x64,0x00,0x23,0x23,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x43,
	0x6C,0x61,0x73,0x73,0x45,0x78,0x70,0x5F,0x44,0x65,0x78,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x43,
	0x6C,0x61,0x73,0x73,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x45,0x78,0x70,0x00,0x43,0x6F,0x6E,
	0x66,0x69,0x67,0x43,0x6C,0x61,0x73,0x73,0x00,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x00,0x49,
	0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x4E,0x61,0x6D,0x65,0x00,0x53,0x65,0x63,0x75,0x72,0x69,0x74,
	0x79,0x44,0x65,0x63,0x72,0x69,0x70,0x74,0x6F,0x72,0x00,0x52,0x6F,0x6C,0x65,0x53,0x65,0x74,0x49,0x64,
	0x00,0x49,0x73,0x44,0x69,0x73,0x70,0x61,0x74,0x63,0x68,0x61,0x62,0x6C,0x65,0x00,0x49,0x73,0x51,0x75,
	0x65,0x75,0x65,0x61,0x62,0x6C,0x65,0x00,0x49,0x73,0x51,0x75,0x65,0x75,0x65,0x69,0x6E,0x67,0x53,0x75,
	0x70,0x70,0x6F,0x72,0x74,0x65,0x64,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x4D,0x50,0x4B,0x5F,0x43,
	0x6C,0x61,0x73,0x73,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x45,0x78,0x70,0x00,0x41,0x70,0x70,
	0x45,0x78,0x70,0x2E,0x43,0x6C,0x61,0x73,0x73,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x44,0x69,
	0x73,0x70,0x49,0x44,0x45,0x78,0x70,0x00,0x44,0x69,0x73,0x70,0x49,0x44,0x00,0x41,0x70,0x70,0x45,0x78,
	0x70,0x2E,0x4D,0x50,0x4B,0x5F,0x43,0x6C,0x61,0x73,0x73,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,
	0x44,0x69,0x73,0x70,0x49,0x44,0x45,0x78,0x70,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x43,0x6C,0x61,
	0x73,0x73,0x49,0x74,0x66,0x4D,0x65,0x74,0x68,0x6F,0x64,0x45,0x78,0x70,0x00,0x4D,0x65,0x74,0x68,0x6F,
	0x64,0x49,0x6E,0x64,0x65,0x78,0x00,0x4D,0x65,0x74,0x68,0x6F,0x64,0x4E,0x61,0x6D,0x65,0x00,0x41,0x75,
	0x74,0x6F,0x43,0x6F,0x6D,0x70,0x6C,0x65,0x74,0x65,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x4D,0x50,
	0x4B,0x5F,0x43,0x6C,0x61,0x73,0x73,0x49,0x74,0x66,0x4D,0x65,0x74,0x68,0x6F,0x64,0x45,0x78,0x70,0x00,
	0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x52,0x6F,0x6C,0x65,0x44,0x65,0x66,0x45,0x78,0x70,0x00,0x41,0x70,
	0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x00,0x52,0x6F,0x6C,0x65,0x4E,0x61,0x6D,0x65,0x00,0x41,
	0x70,0x70,0x45,0x78,0x70,0x2E,0x4D,0x50,0x4B,0x5F,0x52,0x6F,0x6C,0x65,0x44,0x65,0x66,0x45,0x78,0x70,
	0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x52,0x6F,0x6C,0x65,0x43,0x6F,0x6E,0x66,0x69,0x67,0x45,0x78,
	0x70,0x00,0x52,0x6F,0x6C,0x65,0x4D,0x65,0x6D,0x62,0x65,0x72,0x73,0x00,0x55,0x73,0x65,0x72,0x53,0x49,
	0x44,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x4D,0x50,0x4B,0x5F,0x52,0x6F,0x6C,0x65,0x43,0x6F,0x6E,
	0x66,0x69,0x67,0x45,0x78,0x70,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x52,0x6F,0x6C,0x65,0x53,0x44,
	0x43,0x61,0x63,0x68,0x65,0x45,0x78,0x70,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x4D,0x50,0x4B,0x5F,
	0x52,0x6F,0x6C,0x65,0x53,0x44,0x43,0x61,0x63,0x68,0x65,0x45,0x78,0x70,0x00,0x41,0x70,0x70,0x45,0x78,
	0x70,0x2E,0x52,0x6F,0x6C,0x65,0x53,0x65,0x74,0x45,0x78,0x70,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,
	0x4D,0x50,0x4B,0x5F,0x52,0x6F,0x6C,0x65,0x53,0x65,0x74,0x45,0x78,0x70,0x00,0x41,0x70,0x70,0x45,0x78,
	0x70,0x2E,0x44,0x6C,0x6C,0x4E,0x61,0x6D,0x65,0x45,0x78,0x70,0x00,0x41,0x70,0x70,0x6C,0x69,0x63,0x61,
	0x74,0x69,0x6F,0x6E,0x49,0x44,0x00,0x44,0x6C,0x6C,0x4E,0x61,0x6D,0x65,0x00,0x41,0x70,0x70,0x45,0x78,
	0x70,0x2E,0x4D,0x50,0x4B,0x5F,0x44,0x6C,0x6C,0x4E,0x61,0x6D,0x65,0x45,0x78,0x70,0x00,0x41,0x70,0x70,
	0x45,0x78,0x70,0x2E,0x53,0x75,0x62,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6F,0x6E,0x73,0x00,0x53,0x75,
	0x62,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6F,0x6E,0x49,0x44,0x00,0x53,0x75,0x62,0x73,0x63,0x72,0x69,
	0x70,0x74,0x69,0x6F,0x6E,0x4E,0x61,0x6D,0x65,0x00,0x45,0x76,0x65,0x6E,0x74,0x43,0x6C,0x61,0x73,0x73,
	0x49,0x44,0x00,0x53,0x75,0x62,0x73,0x63,0x72,0x69,0x62,0x65,0x72,0x43,0x4C,0x53,0x49,0x44,0x00,0x50,
	0x65,0x72,0x55,0x73,0x65,0x72,0x00,0x55,0x73,0x65,0x72,0x4E,0x61,0x6D,0x65,0x00,0x45,0x6E,0x61,0x62,
	0x6C,0x65,0x64,0x00,0x4D,0x61,0x63,0x68,0x69,0x6E,0x65,0x4E,0x61,0x6D,0x65,0x00,0x49,0x6E,0x74,0x65,
	0x72,0x66,0x61,0x63,0x65,0x49,0x44,0x00,0x46,0x69,0x6C,0x74,0x65,0x72,0x43,0x72,0x69,0x74,0x65,0x72,
	0x69,0x61,0x00,0x53,0x75,0x62,0x73,0x79,0x73,0x74,0x65,0x6D,0x00,0x53,0x75,0x62,0x73,0x63,0x72,0x69,
	0x62,0x65,0x72,0x4D,0x6F,0x6E,0x69,0x6B,0x65,0x72,0x00,0x51,0x75,0x65,0x75,0x65,0x64,0x00,0x53,0x75,
	0x62,0x73,0x63,0x72,0x69,0x62,0x65,0x72,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x00,0x41,0x70,
	0x70,0x45,0x78,0x70,0x2E,0x4D,0x50,0x4B,0x5F,0x53,0x75,0x62,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6F,
	0x6E,0x73,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x50,0x75,0x62,0x6C,0x69,0x73,0x68,0x65,0x72,0x50,
	0x72,0x6F,0x70,0x65,0x72,0x74,0x69,0x65,0x73,0x00,0x4E,0x61,0x6D,0x65,0x00,0x54,0x79,0x70,0x65,0x00,
	0x44,0x61,0x74,0x61,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x4D,0x50,0x4B,0x5F,0x50,0x75,0x62,0x6C,
	0x69,0x73,0x68,0x65,0x72,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x69,0x65,0x73,0x00,0x41,0x70,0x70,0x45,
	0x78,0x70,0x2E,0x53,0x75,0x62,0x73,0x63,0x72,0x69,0x62,0x65,0x72,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,
	0x69,0x65,0x73,0x00,0x41,0x70,0x70,0x45,0x78,0x70,0x2E,0x4D,0x50,0x4B,0x5F,0x53,0x75,0x62,0x73,0x63,
	0x72,0x69,0x62,0x65,0x72,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x69,0x65,0x73,0x00,
};
extern const DECLSPEC_SELECTANY BYTE * g_pbAppExpSchemaStringHeap = g_rgAppExpSchemaStringHeap;
extern const DECLSPEC_SELECTANY int g_cbAppExpSchemaStringHeap = 2136;
extern const BYTE DECLSPEC_SELECTANY g_rgAppExpSchemaDataRO[] = 
{
	0x0D,0x00,0x00,0x00,0x20,0x0B,0x00,0x00,0x3C,0x00,0x00,0x00,0x90,0x02,0x00,0x00,0xA4,0x05,0x00,0x00,
	0x58,0x06,0x00,0x00,0xBC,0x06,0x00,0x00,0x80,0x07,0x00,0x00,0xD4,0x07,0x00,0x00,0x38,0x08,0x00,0x00,
	0x8C,0x08,0x00,0x00,0xE0,0x08,0x00,0x00,0x24,0x09,0x00,0x00,0x58,0x0A,0x00,0x00,0xBC,0x0A,0x00,0x00,
	0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x28,0x23,0x10,0x00,0x54,0x00,0x00,0xFF,0xFF,0x90,0x00,0x54,0x02,
	0x17,0x00,0x00,0x00,0x01,0x04,0x48,0x00,0x40,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1E,0x00,0x00,0x00,
	0x02,0x01,0x82,0x00,0x44,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x27,0x00,0x00,0x00,0x03,0x00,0x13,0x00,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2D,0x00,0x00,0x00,0x04,0x01,0x82,0x00,0x48,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x38,0x00,0x00,0x00,0x05,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x44,0x00,0x00,0x00,0x06,0x01,0x82,0x00,0x4C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x50,0x00,0x00,0x00,
	0x07,0x01,0x82,0x00,0x50,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x5C,0x00,0x00,0x00,0x08,0x00,0x13,0x00,
	0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x6A,0x00,0x00,0x00,0x09,0x01,0x82,0x00,0x54,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x74,0x00,0x00,0x00,0x0A,0x01,0x80,0x00,0x58,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x85,0x00,0x00,0x00,0x0B,0x01,0x82,0x00,0x5C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x91,0x00,0x00,0x00,
	0x0C,0x01,0x82,0x00,0x60,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0x9A,0x00,0x00,0x00,0x0D,0x00,0x13,0x00,
	0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xA9,0x00,0x00,0x00,0x0E,0x00,0x13,0x00,0x10,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xB7,0x00,0x00,0x00,0x0F,0x01,0x82,0x00,0x64,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,
	0xC2,0x00,0x00,0x00,0x10,0x01,0x82,0x00,0x68,0x00,0x04,0x00,0x50,0x00,0xFF,0x43,0xCC,0x00,0x00,0x00,
	0x11,0x01,0x82,0x00,0x6C,0x00,0x04,0x00,0x14,0x00,0xFF,0x43,0xD7,0x00,0x00,0x00,0x12,0x00,0x82,0x00,
	0x70,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0xE2,0x00,0x00,0x00,0x13,0x00,0x82,0x00,0x74,0x00,0x04,0x00,
	0x01,0x00,0xFF,0x43,0xED,0x00,0x00,0x00,0x14,0x01,0x82,0x00,0x78,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,
	0xF7,0x00,0x00,0x00,0x15,0x01,0x80,0x00,0x7C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x01,0x01,0x00,0x00,
	0x16,0x00,0x13,0x00,0x14,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1C,0x01,0x00,0x00,0x17,0x00,0x13,0x00,
	0x18,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x35,0x01,0x00,0x00,0x18,0x01,0x80,0x00,0x80,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x48,0x01,0x00,0x00,0x19,0x00,0x13,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x5B,0x01,0x00,0x00,0x1A,0x00,0x13,0x00,0x20,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x74,0x01,0x00,0x00,
	0x1B,0x00,0x13,0x00,0x24,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x7F,0x01,0x00,0x00,0x1C,0x00,0x13,0x00,
	0x28,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x91,0x01,0x00,0x00,0x1D,0x00,0x13,0x00,0x2C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x9A,0x01,0x00,0x00,0x1E,0x01,0x82,0x00,0x84,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,
	0xAC,0x01,0x00,0x00,0x1F,0x00,0x13,0x00,0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xBA,0x01,0x00,0x00,
	0x20,0x00,0x13,0x00,0x34,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC7,0x01,0x00,0x00,0x21,0x00,0x13,0x00,
	0x38,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xD1,0x01,0x00,0x00,0x22,0x00,0x13,0x00,0x3C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xDC,0x01,0x00,0x00,0x23,0x01,0x82,0x00,0x88,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xE7,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x8C,0x00,0x01,0x01,0x00,0x58,0x03,0x02,0x00,0x00,
	0x01,0x00,0x01,0x28,0x2F,0x14,0x00,0x54,0x00,0x00,0xFF,0xFF,0xC0,0x00,0x14,0x03,0x13,0x02,0x00,0x00,
	0x01,0x04,0x48,0x00,0x68,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x19,0x02,0x00,0x00,0x02,0x01,0x82,0x00,
	0x6C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x28,0x02,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x37,0x02,0x00,0x00,0x04,0x01,0x82,0x00,0x70,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x85,0x00,0x00,0x00,0x05,0x01,0x82,0x00,0x74,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x3E,0x02,0x00,0x00,
	0x06,0x01,0x82,0x00,0x78,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x17,0x00,0x00,0x00,0x07,0x01,0x48,0x00,
	0x7C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x47,0x02,0x00,0x00,0x08,0x01,0x48,0x00,0x80,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x51,0x02,0x00,0x00,0x09,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x5E,0x02,0x00,0x00,0x0A,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x6B,0x02,0x00,0x00,
	0x0B,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x78,0x02,0x00,0x00,0x0C,0x00,0x13,0x00,
	0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x88,0x02,0x00,0x00,0x0D,0x00,0x13,0x00,0x14,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x8F,0x02,0x00,0x00,0x0E,0x00,0x13,0x00,0x18,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x98,0x02,0x00,0x00,0x0F,0x00,0x13,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xA4,0x02,0x00,0x00,
	0x10,0x00,0x13,0x00,0x20,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xB3,0x02,0x00,0x00,0x11,0x00,0x13,0x00,
	0x24,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC0,0x02,0x00,0x00,0x12,0x00,0x13,0x00,0x28,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xCE,0x02,0x00,0x00,0x13,0x00,0x13,0x00,0x2C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xDE,0x02,0x00,0x00,0x14,0x00,0x13,0x00,0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1C,0x01,0x00,0x00,
	0x15,0x00,0x13,0x00,0x34,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x35,0x01,0x00,0x00,0x16,0x01,0x80,0x00,
	0x84,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xEC,0x02,0x00,0x00,0x17,0x01,0x48,0x00,0x88,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xF6,0x02,0x00,0x00,0x18,0x00,0x13,0x00,0x38,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x02,0x03,0x00,0x00,0x19,0x00,0x13,0x00,0x3C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0E,0x03,0x00,0x00,
	0x1A,0x00,0x13,0x00,0x40,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1E,0x03,0x00,0x00,0x1B,0x01,0x82,0x00,
	0x8C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x2E,0x03,0x00,0x00,0x1C,0x00,0x13,0x00,0x44,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x39,0x03,0x00,0x00,0x1D,0x01,0x48,0x00,0x90,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x4A,0x03,0x00,0x00,0x1E,0x00,0x13,0x00,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x62,0x03,0x00,0x00,
	0x1F,0x01,0x82,0x00,0x94,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x6E,0x03,0x00,0x00,0x20,0x01,0x48,0x00,
	0x98,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x7D,0x03,0x00,0x00,0x21,0x01,0x82,0x00,0x9C,0x00,0x04,0x00,
	0xF4,0x01,0xFF,0x43,0x8C,0x03,0x00,0x00,0x22,0x00,0x13,0x00,0x4C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x9F,0x03,0x00,0x00,0x23,0x01,0x82,0x00,0xA0,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xB3,0x03,0x00,0x00,
	0x24,0x00,0x13,0x00,0x50,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC8,0x03,0x00,0x00,0x25,0x01,0x82,0x00,
	0xA4,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xD6,0x03,0x00,0x00,0x26,0x01,0x82,0x00,0xA8,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0xE9,0x03,0x00,0x00,0x27,0x01,0x82,0x00,0xAC,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xF9,0x03,0x00,0x00,0x28,0x00,0x13,0x00,0x54,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0A,0x04,0x00,0x00,
	0x29,0x00,0x13,0x00,0x58,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x16,0x04,0x00,0x00,0x2A,0x01,0x82,0x00,
	0xB0,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x22,0x04,0x00,0x00,0x2B,0x01,0x48,0x00,0xB4,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x31,0x04,0x00,0x00,0x2C,0x00,0x13,0x00,0x5C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x48,0x04,0x00,0x00,0x2D,0x00,0x13,0x00,0x60,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x56,0x04,0x00,0x00,
	0x2E,0x00,0x13,0x00,0x64,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x69,0x04,0x00,0x00,0x2F,0x01,0x82,0x00,
	0xB8,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x7E,0x04,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0xBC,0x00,
	0x01,0x01,0x00,0x58,0x94,0x04,0x00,0x00,0x02,0x00,0x01,0x20,0x09,0x04,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x28,0x00,0xB4,0x00,0xAD,0x04,0x00,0x00,0x01,0x82,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xB9,0x04,0x00,0x00,0x02,0x82,0x48,0x00,0x10,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xC3,0x04,0x00,0x00,
	0x03,0x01,0x82,0x00,0x14,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xD1,0x04,0x00,0x00,0x04,0x01,0x80,0x00,
	0x18,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xE3,0x04,0x00,0x00,0x05,0x01,0x48,0x00,0x1C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xED,0x04,0x00,0x00,0x06,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xFC,0x04,0x00,0x00,0x07,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x08,0x05,0x00,0x00,
	0x08,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x85,0x00,0x00,0x00,0x09,0x01,0x82,0x00,
	0x20,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x1C,0x05,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x24,0x00,
	0x02,0x01,0x02,0x58,0x39,0x05,0x00,0x00,0x03,0x00,0x01,0x20,0x04,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x14,0x00,0x64,0x00,0xAD,0x04,0x00,0x00,0x01,0x82,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xB9,0x04,0x00,0x00,0x02,0x82,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x58,0x05,0x00,0x00,
	0x03,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xD1,0x04,0x00,0x00,0x04,0x01,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x5F,0x05,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x10,0x00,
	0x03,0x01,0x02,0x03,0x82,0x05,0x00,0x00,0x04,0x00,0x01,0x20,0x0A,0x05,0x01,0x54,0x00,0x00,0x28,0x00,
	0x30,0x00,0xC4,0x00,0xAD,0x04,0x00,0x00,0x01,0x82,0x48,0x00,0x10,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xB9,0x04,0x00,0x00,0x02,0x82,0x48,0x00,0x14,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9B,0x05,0x00,0x00,
	0x03,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xD1,0x04,0x00,0x00,0x04,0x01,0x80,0x00,
	0x18,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xEC,0x02,0x00,0x00,0x05,0x01,0x48,0x00,0x1C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xA7,0x05,0x00,0x00,0x06,0x01,0x82,0x00,0x20,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x58,0x05,0x00,0x00,0x07,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x27,0x00,0x00,0x00,
	0x08,0x01,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x00,0x43,0xB2,0x05,0x00,0x00,0x09,0x00,0x13,0x00,
	0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x85,0x00,0x00,0x00,0x0A,0x01,0x82,0x00,0x24,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0xBF,0x05,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x2C,0x00,0x03,0x01,0x02,0x03,
	0xDC,0x05,0x00,0x00,0x05,0x00,0x01,0x20,0x03,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,
	0xEE,0x05,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFA,0x05,0x00,0x00,
	0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x85,0x00,0x00,0x00,0x03,0x01,0x82,0x00,
	0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x03,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,
	0x02,0x01,0x02,0x58,0x19,0x06,0x00,0x00,0x06,0x00,0x01,0x20,0x04,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x14,0x00,0x64,0x00,0xEE,0x05,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xFA,0x05,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x2E,0x06,0x00,0x00,
	0x03,0x82,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x3A,0x06,0x00,0x00,0x04,0x01,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x42,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x10,0x00,
	0x03,0x01,0x02,0x03,0x5B,0x06,0x00,0x00,0x07,0x00,0x01,0x20,0x03,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x10,0x00,0x54,0x00,0xEE,0x05,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xFA,0x05,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x35,0x01,0x00,0x00,
	0x03,0x01,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x71,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0x8B,0x06,0x00,0x00,0x08,0x00,0x01,0x20,0x03,0x00,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0xEC,0x02,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xFA,0x05,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xEE,0x05,0x00,0x00,0x03,0x00,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9D,0x06,0x00,0x00,
	0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0xB3,0x06,0x00,0x00,0x09,0x00,0x01,0x20,
	0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x0C,0x00,0x44,0x00,0xC5,0x06,0x00,0x00,0x01,0x82,0x48,0x00,
	0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xD3,0x06,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0xDB,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x08,0x00,0x02,0x01,0x02,0x58,
	0xF1,0x06,0x00,0x00,0x0A,0x00,0x01,0x20,0x11,0x0E,0x03,0x54,0x00,0x00,0x44,0x00,0x4C,0x00,0x34,0x01,
	0x06,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x15,0x07,0x00,0x00,
	0x02,0x00,0x82,0x00,0x10,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x26,0x07,0x00,0x00,0x03,0x01,0x48,0x00,
	0x14,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xA7,0x05,0x00,0x00,0x04,0x01,0x82,0x00,0x18,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x33,0x07,0x00,0x00,0x05,0x00,0x48,0x00,0x1C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x43,0x07,0x00,0x00,0x06,0x01,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x43,0x4B,0x07,0x00,0x00,
	0x07,0x01,0x82,0x00,0x20,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x54,0x07,0x00,0x00,0x08,0x01,0x13,0x00,
	0x04,0x00,0x04,0x00,0x04,0x00,0x01,0x43,0x85,0x00,0x00,0x00,0x09,0x01,0x82,0x00,0x24,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x5C,0x07,0x00,0x00,0x0A,0x01,0x82,0x00,0x28,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x16,0x04,0x00,0x00,0x0B,0x01,0x82,0x00,0x2C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x68,0x07,0x00,0x00,
	0x0C,0x01,0x48,0x00,0x30,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x74,0x07,0x00,0x00,0x0D,0x01,0x82,0x00,
	0x34,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x83,0x07,0x00,0x00,0x0E,0x01,0x82,0x00,0x38,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x8D,0x07,0x00,0x00,0x0F,0x01,0x82,0x00,0x3C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x9F,0x07,0x00,0x00,0x10,0x01,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x43,0xA6,0x07,0x00,0x00,
	0x11,0x01,0x80,0x00,0x40,0x00,0x04,0x00,0x08,0x00,0xFF,0x43,0xBA,0x07,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x48,0x00,0x01,0x01,0x00,0x58,0xD3,0x07,0x00,0x00,0x0B,0x00,0x01,0x20,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x06,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x04,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xEE,0x07,0x00,0x00,0x02,0x82,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xF3,0x07,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xF8,0x07,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFD,0x07,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x10,0x00,0x02,0x01,0x02,0x58,0x1C,0x08,0x00,0x00,0x0C,0x00,0x01,0x20,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x06,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x04,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xEE,0x07,0x00,0x00,0x02,0x82,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xF3,0x07,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xF8,0x07,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x38,0x08,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x10,0x00,0x02,0x01,0x02,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbAppExpSchemaRO = 2848;
extern const COMPLIBSCHEMABLOB DECLSPEC_SELECTANY AppExpSchemaBlob = 
{
	&AppExpSchema,
	AppExp_TABLE_COUNT,
	0,
	g_rgAppExpSchemaDataRW,
	g_cbAppExpSchemaRW,
	g_rgAppExpSchemaDataRO,
	g_cbAppExpSchemaRO,
	g_rgAppExpSchemaStringHeap,
	g_cbAppExpSchemaStringHeap
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\catalogcollectionwriter.h ===
#ifndef _CATALOGCOLLECTIONWRITER_H_
#define _CATALOGCOLLECTIONWRITER_H_

class CCatalogCollectionWriter
{
	public:
		
		CCatalogCollectionWriter();
		~CCatalogCollectionWriter();

		void Initialize(tTABLEMETARow*	i_pCollection,
			            CWriter*		i_pcWriter);

		HRESULT GetPropertyWriter(tCOLUMNMETARow*			i_pProperty,
                                  ULONG*                    i_aPropertySize,
								  CCatalogPropertyWriter**	o_pProperty);
		HRESULT WriteCollection();

	private:

		HRESULT ReAllocate();
		HRESULT BeginWriteCollection();
		HRESULT EndWriteCollection();

		CWriter*					m_pCWriter;
		tTABLEMETARow				m_Collection;
		CCatalogPropertyWriter**	m_apProperty;
		ULONG						m_cProperty;
		ULONG						m_iProperty;

}; // CCatalogCollectionWriter

#endif // _CATALOGCOLLECTIONWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\catalogpropertywriter.h ===
#ifndef _CATALOGPROPERTYWRITER_H_
#define _CATALOGPROPERTYWRITER_H_

class CCatalogCollectionWriter;

class CCatalogPropertyWriter
{
	public:
		
		CCatalogPropertyWriter();
		~CCatalogPropertyWriter();

		void Initialize(tCOLUMNMETARow*		i_pProperty,
                        ULONG*              i_aPropertySize,
			            tTABLEMETARow*		i_pCollection,
			            CWriter*			i_pcWriter);

		HRESULT AddFlag(tTAGMETARow*		    i_pFlag);

		HRESULT WriteProperty();

	private:
	
		HRESULT WritePropertyLong();
		HRESULT WritePropertyShort();
		HRESULT BeginWritePropertyLong();
		HRESULT EndWritePropertyLong();
		HRESULT WriteFlag(ULONG		i_Flag);
		HRESULT ReAllocate();
		DWORD   MetabaseTypeFromColumnMetaType();

		CWriter*		m_pCWriter;
		tCOLUMNMETARow	m_Property;
        ULONG           m_PropertySize[cCOLUMNMETA_NumberOfColumns];
        tTABLEMETARow*	m_pCollection;


		tTAGMETARow*				m_aFlag;
		ULONG						m_cFlag;
		ULONG						m_iFlag;

}; // CCatalogPropertyWriter


#endif // _CATALOGPROPERTYWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\array_t.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
//  Updated 3/06/01 Stephenr - Added exceptions on out of memory conditions.  This class should only throw HRESULTs.
//
#ifndef __ARRAY_INCLUDED__
#define __ARRAY_INCLUDED__

#ifndef __SHARED_INCLUDED__
#include <shared.h>
#endif

#ifndef __BUFFER_INCLUDED__
#include <buffer_t.h>
#endif

#ifndef _HRESULT_DEFINED
#include "ntdef.h"
#endif

#ifndef _WINERROR_
#include "WinError.h"
#endif

template <class T> inline void swap(T& t1, T& t2) {
	T t = t1;
	t1 = t2;
	t2 = t;
}

#ifndef self
#define self (*this)
#endif

template <class T> class Array {
	T* rgt;
	unsigned itMac;
	unsigned itMax;
	enum { itMaxMax = (1<<29) };
public:
	Array() {
		rgt = 0;
		itMac = itMax = 0;
	}
	Array(unsigned itMac_) {
		itMac = itMax = itMac_;
		rgt = new T[itMax];
        if(0 == rgt)
            throw(static_cast<HRESULT>(E_OUTOFMEMORY));
	}
	~Array() {
		if (rgt)
			delete [] rgt;
	}
	Array& operator=(const Array& a) {
		if (&a != this) {
			if (a.itMac > itMax) {
				if (rgt)
					delete [] rgt;
				itMax = a.itMac;
				rgt = new T[itMax];
                if(0 == rgt)
                    throw(static_cast<HRESULT>(E_OUTOFMEMORY));
			}
			itMac = a.itMac;
			for (unsigned it = 0; it < itMac; it++)
				rgt[it] = a.rgt[it];
		}
		return *this;
	}
	BOOL isValidSubscript(unsigned it) const {
		return 0 <= it && it < itMac;
	}
	unsigned size() const {
		return itMac;
	}
	T* pEnd() const {
		return &rgt[itMac];
	}
	BOOL getAt(unsigned it, T** ppt) const {
		if (isValidSubscript(it)) {
			*ppt = &rgt[it];
			return TRUE;
		}
		else
			return FALSE;
	}
	BOOL putAt(unsigned it, const T& t) {
		if (isValidSubscript(it)) {
			rgt[it] = t;
			return TRUE;
		}
		else
			return FALSE;
	}
	T& operator[](unsigned it) const {
		precondition(isValidSubscript(it));
		return rgt[it];
	}
    void append(const T& t) {
		setSize(size() + 1);
		self[size() - 1] = t;
	}
	void swap(Array& a) {
		::swap(rgt,   a.rgt);
		::swap(itMac, a.itMac);
		::swap(itMax, a.itMax);
	}
	void reset() {
		setSize(0);
	}
	void fill(const T& t) {
		for (unsigned it = 0; it < size(); it++)
			self[it] = t;
	}
	void insertAt(unsigned itInsert, const T& t);
	void deleteAt(unsigned it);
	void deleteRunAt(unsigned it, int ct);
	void setSize(unsigned itMacNew);
	BOOL findFirstEltSuchThat(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const;
	BOOL findFirstEltSuchThat_Rover(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const;
	unsigned binarySearch(BOOL (*pfnLE)(T*, void*), void* pArg) const;
    unsigned binarySearch(T &t) const;
	void reload(PB* ppb);
private:
	Array(const Array&); // not implemented
	void save(Buffer* pbuf) const;//I've made this private because the Buffer class does not handle out of memory condition
                                  //and I want to make sure that no one is calling this method (without actually removing it).
};

template <class T> inline void Array<T>::insertAt(unsigned it, const T& t) {
	precondition(isValidSubscript(it) || it == size());

	setSize(size() + 1);
    for(unsigned int i=(size()-1); i>it; --i)
        rgt[i] = rgt[i-1];
	//memmove(&rgt[it + 1], &rgt[it], (size() - (it + 1)) * sizeof(T));
	rgt[it] = t;
}

template <class T> inline void Array<T>::deleteAt(unsigned it) {
	precondition(isValidSubscript(it));

    for(unsigned int i=it; i<(size()-1); ++i)
        rgt[i] = rgt[i+1];
// 	memmove(&rgt[it], &rgt[it + 1], (size() - (it + 1)) * sizeof(T));
	rgt[size() - 1] = T();
	setSize(size() - 1);
}

template <class T> inline void Array<T>::deleteRunAt(unsigned it, int ct) {
	unsigned itMacNew = it + ct;
	precondition(isValidSubscript(it) && isValidSubscript(itMacNew - 1));

    for(unsigned int i=it; i<(size()-ct); ++i)
        rgt[i] = rgt[i+ct];
// 	memmove(&rgt[it], &rgt[itMacNew], (size() - itMacNew) * sizeof(T));
	for ( ; it < itMacNew; it++)
		rgt[it] = T();
	setSize(size() - ct);
}

// Grow the array to a new size.
template <class T> inline
void Array<T>::setSize(unsigned itMacNew) {
	precondition(0 <= itMacNew && itMacNew <= itMaxMax);

	if (itMacNew > itMax) {
		// Ensure growth is by at least 50% of former size.
		unsigned itMaxNew = __max(itMacNew, 3*itMax/2);
 		ASSERT(itMaxNew <= itMaxMax);

		T* rgtNew = new T[itMaxNew];
        if(0 == rgtNew)
            throw(static_cast<HRESULT>(E_OUTOFMEMORY));
		if (rgt) {
			for (unsigned it = 0; it < itMac; it++)
				rgtNew[it] = rgt[it];
			delete [] rgt;
		}
		rgt = rgtNew;
		itMax = itMaxNew;
	}
	itMac = itMacNew;
}

template <class T> inline
void Array<T>::save(Buffer* pbuf) const {
	pbuf->Append((PB)&itMac, sizeof itMac);
    if (itMac > 0)
        pbuf->Append((PB)rgt, itMac*sizeof(T));
}

template <class T> inline
void Array<T>::reload(PB* ppb) {
	unsigned itMacNew = *((unsigned UNALIGNED *&)*ppb)++;
	setSize(itMacNew);
	memcpy(rgt, *ppb, itMac*sizeof(T));
	*ppb += itMac*sizeof(T);
}

template <class T> inline
BOOL Array<T>::findFirstEltSuchThat(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const
{
	for (unsigned it = 0; it < size(); ++it) {
		if ((*pfn)(&rgt[it], pArg)) {
			*pit = it;
			return TRUE;
		}
	}
	return FALSE;
}

template <class T> inline
BOOL Array<T>::findFirstEltSuchThat_Rover(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const
{
	precondition(pit);

	if (!(0 <= *pit && *pit < size()))
		*pit = 0;

	for (unsigned it = *pit; it < size(); ++it) {
		if ((*pfn)(&rgt[it], pArg)) {
			*pit = it;
			return TRUE;
		}
	}

	for (it = 0; it < *pit; ++it) {
		if ((*pfn)(&rgt[it], pArg)) {
			*pit = it;
			return TRUE;
		}
	}

	return FALSE;
}

template <class T> inline
unsigned Array<T>::binarySearch(BOOL (*pfnLE)(T*, void*), void* pArg) const
{
	unsigned itLo = 0;
	unsigned itHi = size(); 
	while (itLo < itHi) {
		// (low + high) / 2 might overflow
		unsigned itMid = itLo + (itHi - itLo) / 2;
		if ((*pfnLE)(&rgt[itMid], pArg))
			itHi = itMid;
		else
			itLo = itMid + 1;
	}
	postcondition(itLo == 0      || !(*pfnLE)(&rgt[itLo - 1], pArg));
	postcondition(itLo == size() ||  (*pfnLE)(&rgt[itLo], pArg));
	return itLo;
}

template <class T> inline
unsigned Array<T>::binarySearch(T &t) const
{
	unsigned itLo = 0;
	unsigned itHi = size(); 
	while (itLo < itHi) {
		// (low + high) / 2 might overflow
		unsigned itMid = itLo + (itHi - itLo) / 2;
		if (rgt[itMid] > t)
			itHi = itMid;
		else
			itLo = itMid + 1;
	}
	postcondition(itLo == 0      || !(rgt[itLo - 1] > t));
	postcondition(itLo == size() ||  (rgt[itLo] > t));
	return itLo;
}

#endif // !__ARRAY_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\catalogschemawriter.h ===
#ifndef _CATALOGSCHEMAWRITER_H_
#define _CATALOGSCHEMAWRITER_H_

class CCatalogSchemaWriter
{
	public:
		
		CCatalogSchemaWriter(CWriter*	i_pcWriter);
		~CCatalogSchemaWriter();

		HRESULT GetCollectionWriter(tTABLEMETARow*				i_pCollection,
									CCatalogCollectionWriter**	o_pCollectionWriter);

		HRESULT WriteSchema();

	private:

		HRESULT ReAllocate();
		HRESULT BeginWriteSchema();
		HRESULT EndWriteSchema();

		CCatalogCollectionWriter**	m_apCollection;
		ULONG						m_cCollection;
		ULONG						m_iCollection;
		CWriter*					m_pCWriter;

}; // CCatalogSchemaWriter

#endif // _CATALOGSCHEMAWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\buffer_t.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __BUFFER_INCLUDED__
#define __BUFFER_INCLUDED__

// implementation of class Buffer
#include <stdlib.h>
#include "shared.h"

class Buffer {
public:
	Buffer(void (*pfn)(void*, void*, void*) = 0, void* pfnArg = 0)
		: cb(0), pbStart(0), pbEnd(0), pfnMove(pfn), pfnMoveArg(pfnArg) {}
	~Buffer();
	void Alloc(CB cbIn); 
	void Append(PB pbIn, CB cbIn, OUT PB* ppbOut = 0);
	void AppendNoCheck(BYTE b);
	void AppendNoCheck(short s);
	void AppendNoCheck(long l);
	void AppendNoCheck(float& f);
	void AppendNoCheck(double& d);
	void AppendNoCheck(PB pbIn, CB cbIn);
//x	BOOL CDECL AppendFmt(SZ szFmt, ...);
	void Reserve(CB cbIn, OUT PB* ppbOut = 0);
	void Ensure(CB cbIn, PB* ppbOut);
	void Ensure(CB cbIn);
	PB Start() const { return pbStart; }
	PB End() const { return pbEnd; }
	CB Size() const { return (CB) (pbEnd - pbStart); }
	void Free();
	void Reset()
	{
		pbEnd = pbStart;
	}

	void Clear()
	{
		if (pbStart)
		{
			ZeroMemory(pbStart, pbEnd - pbStart);
			Reset();
		}
	}
private:
	enum { cbPage = 4096 };
	CB   cbRoundUp(CB cb, CB cbMult) { return (cb + cbMult-1) & ~(cbMult-1); }
	inline void grow(CB dcbGrow);
	void setPbExtent(PB pbStartNew, PB pbEndNew) {
		if (!pbStartNew)
			return;
		PB pbStartOld = pbStart;
		pbStart = pbStartNew;
		pbEnd = pbEndNew;
		if (pbStartOld != pbStartNew && pfnMove)
			(*pfnMove)(pfnMoveArg, pbStartOld, pbStartNew);
	}
	
	PB	pbStart;
	PB	pbEnd;
	CB	cb;
	void (*pfnMove)(void* pArg, void* pOld, void* pNew);
	void* pfnMoveArg;
};

inline Buffer::~Buffer()
{
	if (pbStart) {
		Free();
	}
}


inline void Buffer::Alloc(CB cbNew)
{
	ASSERT(cbNew > 0);

	if (pbStart)
		return;

	PB pbNew = new BYTE[cbNew];
    memset(pbNew, 0, cbNew);

    setPbExtent(pbNew, pbNew);
    cb = cbNew;
}

inline void Buffer::Free()
{
	delete [] pbStart;
    pbStart = pbEnd = 0;
	cb = 0;
}

inline void Buffer::Ensure(CB cbIn) 
{
	if (cbIn < 0)
		return;

	if (pbEnd + cbIn > pbStart + cb) {
#pragma inline_depth(0)
		grow(cbIn);
#pragma inline_depth()
	}
}

inline void Buffer::Ensure(CB cbIn, PB* ppbOut)
{
	Ensure(cbIn);

	if (ppbOut)
		*ppbOut = pbEnd;
}

inline void Buffer::Reserve(CB cbIn, OUT PB* ppbOut) 
{
	Ensure(cbIn, ppbOut);
	setPbExtent(pbStart, pbEnd + cbIn);
}

inline void Buffer::Append(PB pbIn, CB cbIn, OUT PB* ppbOut) 
{
    if (pbIn) {
	    PB pb;
	    Reserve(cbIn, &pb);
 
 	    if (ppbOut)
		    *ppbOut = pb;

	    memcpy(pb, pbIn, cbIn);
    }
}

#if 0 //x
inline BOOL CDECL Buffer::AppendFmt(SZ szFmt, ...)
{
	va_list args;
	va_start(args, szFmt);

	for (;;) {
		switch (*szFmt++) {
		case 0:
			va_end(args);
			return TRUE;
		case 'b': {
			BYTE b = va_arg(args, BYTE);
			if (!Append(&b, sizeof b, 0))
				goto fail;
			break;
		}
		case 's': {
			USHORT us = va_arg(args, USHORT);
			if (!Append((PB)&us, sizeof us, 0))
				goto fail;
			break;
		}
		case 'l': {
			ULONG ul = va_arg(args, ULONG);
			if (!Append((PB)&ul, sizeof ul, 0))
				goto fail;
			break;
		}
		case 'f': {
			static BYTE zeroes[3] = { 0, 0, 0 };
			int cb = va_arg(args, int);
			ASSERT(cb <= sizeof(zeroes));
			if (cb != 0 && !Append(zeroes, cb, 0))
				goto fail;
			break;
		}
		case 'z': {
			SZ sz = va_arg(args, SZ);
			int cb = strlen(sz);
			if (!Append((PB)sz, cb, 0))
				goto fail;
			break;
		}
		default:
			ASSERT(0);
			break;
		}
	}

fail:
	va_end(args);
	return FALSE;
}

#endif

inline void Buffer::AppendNoCheck(BYTE b)
{
	*pbEnd++ = b;
}

inline void Buffer::AppendNoCheck(short s)
{
	*(UNALIGNED short *)pbEnd = s;
	pbEnd += sizeof(short);
}

inline void Buffer::AppendNoCheck(long l)
{
	*(UNALIGNED long *)pbEnd = l;
	pbEnd += sizeof(long);
}

inline void Buffer::AppendNoCheck(float& f)
{
	*(UNALIGNED float *)pbEnd = f;
	pbEnd += sizeof(float);
}

inline void Buffer::AppendNoCheck(double& d)
{
	*(UNALIGNED double *)pbEnd = d;
	pbEnd += sizeof(double);
}

inline void Buffer::AppendNoCheck(PB pbIn, CB cbIn)
{
	memcpy(pbEnd, pbIn, cbIn);
	pbEnd += cbIn;
}

inline void Buffer::grow(CB dcbGrow)
{
	CB cbNew = cbRoundUp(cb + __max(cbPage + dcbGrow, cb/2), cbPage);
	PB pbNew = new BYTE[cbNew];

	cb = cbNew;
	CB cbUsed = (CB) (pbEnd - pbStart);
	memcpy(pbNew, pbStart, cbUsed);
	memset(pbNew + cbUsed, 0, cb - cbUsed);

	delete [] pbStart;
	setPbExtent(pbNew, pbNew + cbUsed);
}

#endif // !__BUFFER_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\catsess.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef CATSESSION_CONSTANTS_H_FILE
#define CATSESSION_CONSTANTS_H_FILE

#define flVER_CATSESS_1			1.0
#define flVER_CATSESS_2BETA2	2.0
#define flVER_CATSESS_2BETA3	((float) 2.01)
#define flVER_CATSESS_3BETA1	((float) 2.90)
#define flVER_CATSESS_3BETA2	((float) 2.91)
#define flVER_CATSESS_3RTM		((float) 3.00)

#define flVER_CATSESS_CATSRV_LOWER	(flVER_CATSESS_3RTM) //3.00
#define flVER_CATSESS_CATSRV_UPPER	(flVER_CATSESS_3RTM) //3.00

#define flVER_CATSESS_CLIENT_LOWER	(flVER_CATSESS_3RTM) //3.00
#define flVER_CATSESS_CLIENT_UPPER	(flVER_CATSESS_3RTM) //3.00

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\catmacros.h ===
#ifndef _CATALOGMACROS
#define _CATALOGMACROS

#pragma message("_CATALOGMACROS included")

#include "winwrap.h"
#ifndef __COREMACROS_H__
    #include "CoreMacros.h"
#endif
#ifndef __catalog_h__
    #include "catalog.h"
#endif
#ifndef __TABLEINFO_H__  
    #include "catmeta.h"
#endif
#ifndef _INC_CRTDBG
    #include "crtdbg.h"
#endif
#include <stdio.h>
#include <wchar.h>

#define SAVETRACE(x)
#define DbgWrite        TRACE0
#define DbgWriteEx      TRACE0

#ifdef _DEBUG
    #define  DEBUG_STMT(x) x
#else //_RELASE build
    #define  DEBUG_STMT(x)
#endif

//-------------------------------------------------------------------------
//
// WRITE_TO_LOG()		This macro is handy if you choose to construct your
//						own CError objects. This just calls WriteToLog passing
//						in the __FILE__ and __LINE__.
//
// LOG_ERROR(type,args)	Constructs an error object and writes it to the log.
//						The "type" tells which derived error object you want
//						to construct and "args" become the parameters to the
//						constructor for that class. The type is only the
//						trailing portion of the class name (e.g. Simple, HR, Win32).
//						Extra parens are required around the constructor
//						parameters.
//
//-------------------------------------------------------------------------

// Examples: 
// LOG_ERROR(Simple, (ID_CAT_MTSTOCOM, IDS_I_MTSTOCOM_LAUNCH_STARTED));
// LOG_ERROR(HR,(hr, ID_CAT_CAT, ID_COMCAT_REGDBSVR_INITFAILED));
// LOG_ERROR(Win32, (GetLastError(), ID_CAT_ASP, ID_COMSVCS_IDENTIFY_CALLER	, L"CopySid"));

#define	WRITE_TO_LOG()	        WriteToLog(W(__FILE__), __LINE__)

#define	LOG_ERROR(t,a)		    {CError ## t _e_ a; _e_.WRITE_TO_LOG();}
#define LOG_ERROR_LOS(los,t,a)  {CError ## t _e_ a; _e_.WriteToLog(W(__FILE__), __LINE__, los);}
#define LOG_WARNING(t,a)        {CWarning ## t _e_ a; _e_.WRITE_TO_LOG();}


//-------------------------------------------------------------------------
// helper classes and functions
//-------------------------------------------------------------------------
class CSemExclusive;

//
// CError - universal error-handling class for COM+ Services
//

#define MSGBUFSIZE 4096

class CError {

private:    // protected member data

    WORD        m_wCat;                 // event log message category
    DWORD       m_dwMsgId;              // event log message id

    HRESULT     m_hr;                   // error code to report

    PVOID       m_pvData;               // extended data to log
    size_t      m_cbData;               // size of extended data

    BOOL        m_fFailFast;            // fail-fast after logging error?

    // If related to a customer method call, log information pertinent to
    // the call.
    GUID        m_clsid;
    GUID        m_iid;
    long        m_lMethId;
    long        m_lDispId;

    // The message buffer is a static because we want to minimize the per-
    // instance overhead here. These objects will almost always be on the
    // stack and must be as reliable as possible - we don't want to get a
    // stack overflow while trying to log an error! A critical section
    // protects the shared message buffer.

    static WCHAR            m_szMsg[MSGBUFSIZE];    // formatted error msg
    static CSemExclusive    m_semBuffer;            // serialize use of buf

    BOOL        m_fBufferUsed;          // note whether we used the buffer

public:

    CError (
        HRESULT     hr,
        WORD        wCat,
        DWORD       dwMsgId,
        LPWSTR      szMsg,
        BOOL        fFailFast,
        PVOID       pvData,
        unsigned    cbData,
        REFGUID     rclsid,
        REFGUID     riid,
        long        lMethId,
        long        lDispId
    );

    void SetMethod(REFGUID rclsid, REFGUID riid, long lMethId, long lDispId)
    {
        m_clsid = rclsid;
        m_iid = riid;
        m_lMethId = lMethId;
        m_lDispId = lDispId;
    }

    void SetExtData(PVOID pvData, size_t cbData)
    {
        m_pvData = pvData;
        m_cbData = cbData;
    }

    void SetFailFast(BOOL fFailFast)
    {
        m_fFailFast = fFailFast;
    }

    void SetHRESULT(HRESULT hr)
    {
        m_hr = hr;
    }

    void SetError(WORD wCat, DWORD dwMsgId)
    {
        m_wCat = wCat;
        m_dwMsgId = dwMsgId;
    }

    void SetMessage(LPWSTR msg, ...);

    void WriteToLog(LPWSTR szFile, unsigned uLine);
};

DEFINE_GUID(GUID_NULL, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

// Derived error class for constructing simple errors w/ no HRESULT
class CErrorSimple : public CError {
public:
    CErrorSimple (
        WORD        wCat,
        DWORD       dwMsgId,
        LPWSTR      szMsg = NULL,
        PVOID       pvData = NULL,
        unsigned    cbData = 0,
        BOOL        fFailFast = FALSE
    )
    :   CError (S_OK, wCat, dwMsgId, szMsg, fFailFast, pvData, cbData,
                GUID_NULL, GUID_NULL, -1, -1)
    {}
};

// Derived error class for constructing complete errors with all fields
class CErrorFull : public CError {
public:
    CErrorFull (
        HRESULT     hr,
        WORD        wCat,
        DWORD       dwMsgId,
        LPWSTR      szMsg = NULL,
        PVOID       pvData = NULL,
        unsigned    cbData = 0,
        REFGUID     rclsid = GUID_NULL,
        REFGUID     riid = GUID_NULL,
        long        lMethId = -1,
        long        lDispId = -1,
        BOOL        fFailFast = FALSE
    )
    :   CError (hr, wCat, dwMsgId, szMsg, fFailFast, pvData, cbData,
                rclsid, riid, lMethId, lDispId)
    {}
};

// Derived error class for constructing errors with an HRESULT
class CErrorHR : public CError {
public:
    CErrorHR (
        HRESULT     hr,
        WORD        wCat,
        DWORD       dwMsgId,
        LPWSTR      szMsg = NULL,
        PVOID       pvData = NULL,
        unsigned    cbData = 0,
        BOOL        fFailFast = FALSE
    )
    :   CError (hr, wCat, dwMsgId, szMsg, fFailFast, pvData, cbData,
                GUID_NULL, GUID_NULL, -1, -1)
    {}
};


// Derived error class for constructing errors with a string
class CErrorString : public CError {
public:
    CErrorString (
        LPWSTR      szMsg,
        WORD        wCat,
        DWORD       dwMsgId,
        PVOID       pvData = NULL,
        unsigned    cbData = 0,
        BOOL        fFailFast = FALSE
    )
    :   CError (S_OK, wCat, dwMsgId, szMsg, fFailFast, pvData, cbData,
                GUID_NULL, GUID_NULL, -1, -1)
    {}
};


/////////////////////////////////////////////////////
//
// CErrorInterceptor
//
// This object is like the other CError objects.  It
// takes some parameters and either builds a DetailedErrors
// table or it writes an entry into the event log (and
// into the CatalogEventLog XML file).
//
class CErrorInterceptor
{
public://This first ctor is so we can replace CErrorWin32
    CErrorInterceptor(  HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1=0,
                        LPCWSTR                         szString2=0,
                        LPCWSTR                         szString3=0,
                        LPCWSTR                         szString4=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        BOOL                            bNotUsed=false);
    CErrorInterceptor(  ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        ULONG                           ulInterceptor=0,
                        LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        ULONG                           ulRow=-1,
                        ULONG                           ulColumn=-1,
                        LPCWSTR                         szConfigurationSource=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        ULONG                           MajorVersion=-1,
                        ULONG                           MinorVersion=-1);
    CErrorInterceptor(  ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        ULONG                           ulInterceptor=0,
                        LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        ULONG                           ulRow=-1,
                        ULONG                           ulColumn=-1,
                        LPCWSTR                         szConfigurationSource=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        ULONG                           MajorVersion=-1,
                        ULONG                           MinorVersion=-1);
    CErrorInterceptor(  ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        ULONG                           ulInterceptor=0,
                        LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        ULONG                           ulRow=-1,
                        ULONG                           ulColumn=-1,
                        LPCWSTR                         szConfigurationSource=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        ULONG                           MajorVersion=-1,
                        ULONG                           MinorVersion=-1);
    CErrorInterceptor(  ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        LPCWSTR                         szString4,
                        ULONG                           ulInterceptor=0,
                        LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        ULONG                           ulRow=-1,
                        ULONG                           ulColumn=-1,
                        LPCWSTR                         szConfigurationSource=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        ULONG                           MajorVersion=-1,
                        ULONG                           MinorVersion=-1);
    ~CErrorInterceptor()
    {
        delete m_pStorage;
    }
    HRESULT WriteToLog(LPCWSTR szSource, ULONG Line, ULONG los=fST_LOS_DETAILED_ERROR_TABLE);

    enum
    {
         cchCategoryString   =64
        ,cchComputerName     =256
        ,cchDate             =256
        ,cchDescription      =4096
        ,cchInterceptorSource=256
        ,cchSource           =64
        ,cchSourceFileName   =256
        ,cchMessageString    =1024 //Per documentation on FormatMessage.
        ,cchString1          =1024 //No single insertion string may exceed 1023 characters in length.  
        ,cchString2          =1024
        ,cchString3          =1024
        ,cchString4          =1024
        ,cchString5          =1024
        ,cchTime             =256
        ,cchUserName         =256
    };
private:
    static ULONG cError;

    
    class ErrorInterceptorStorage
    {
    public:     //these are the only two that need to be explicitly 
        ErrorInterceptorStorage() : m_pISTControllerError(0), m_pIErrorInfo(0){}
        ~ErrorInterceptorStorage()
        {
            if(m_pISTControllerError)
                m_pISTControllerError->Release();
            if(m_pIErrorInfo)
                m_pIErrorInfo->Release();
        }

        ULONG                       m_Category;
        ULONG                       m_Column;
        ULONG                       m_ErrorCode;
        ULONG                       m_ErrorID;
        tDETAILEDERRORSRow          m_errRow;
        ULONG                       m_Event;
        ULONG                       m_Interceptor;
        ULONG                       m_MajorVersion;
        ULONG                       m_MinorVersion;
        ULONG                       m_OperationType;
        IAdvancedTableDispenser *   m_pDispenser;//This one is passed in by the user and does NOT need to be released
        IErrorInfo *                m_pIErrorInfo;//This interface DOES need to be released
        ISimpleTableWrite2 *        m_pISTWriteError;//This one is exactly what we return to the user, so we don't have a ref to this
        ISimpleTableController *    m_pISTControllerError;//This interface DOES need to be released
        ULONG                       m_Row;
        WCHAR                       m_szCategoryString[cchCategoryString];
        WCHAR                       m_szComputerName[cchComputerName];
        WCHAR                       m_szDate[cchDate];
        WCHAR                       m_szDescription[cchDescription];
        WCHAR                       m_szInterceptorSource[cchInterceptorSource];
        WCHAR                       m_szMessageString[cchMessageString];
        WCHAR                       m_szSource[cchSource];
        WCHAR                       m_szSourceFileName[cchSourceFileName];
        WCHAR                       m_szString1[cchString1];
        WCHAR                       m_szString2[cchString2];
        WCHAR                       m_szString3[cchString3];
        WCHAR                       m_szString4[cchString4];
        WCHAR                       m_szString5[cchString5];
        WCHAR                       m_szTime[cchTime];
        WCHAR                       m_szUserName[cchUserName];
        ULONG                       m_Type;
    };

    HRESULT                     m_hr;
    ErrorInterceptorStorage *   m_pStorage;

    void Init(  ISimpleTableWrite2 **           ppErrInterceptor,
                IAdvancedTableDispenser *       pDisp,
                HRESULT                         hrErrorCode,
                ULONG                           ulCategory,
                ULONG                           ulEvent,
                LPCWSTR                         szString1=0,
                LPCWSTR                         szString2=0,
                LPCWSTR                         szString3=0,
                LPCWSTR                         szString4=0,
                ULONG                           ulInterceptor=0,
                LPCWSTR                         szTable=0,
                eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                ULONG                           ulRow=-1,
                ULONG                           ulColumn=-1,
                LPCWSTR                         szConfigurationSource=0,
                eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                unsigned char *                 pData=0,
                ULONG                           cbData=0,
                ULONG                           MajorVersion=-1,
                ULONG                           MinorVersion=-1);
    void SetCategory(ULONG ulCategory);
    void SetColumn(ULONG ulColumn);
    void SetComputer();
    void SetConfigurationSource(LPWSTR wszConfigurationSource);
    void SetDate(SYSTEMTIME &systime);
    void SetData();
    void SetDescription();//Must be called after SetString5 since FormatString will rely on String1-5.
    void SetErrorCode(HRESULT hr);
    void SetErrorID(SYSTEMTIME &systime);
    void SetEvent(ULONG ulEvent);
    void SetInterceptor(ULONG ulInterceptor);
    void SetInterceptorSource(LPCWSTR file, ULONG line);
    void SetMajorVersion(ULONG ulMajorVersion);
    void SetMessageString();//Must be called before SetDescription
    void SetMinorVersion(ULONG ulMinorVersion);
    void SetOperationType(eDETAILEDERRORS_OperationType OperationType);
    void SetRow(ULONG ulRow);
    void SetSource(IAdvancedTableDispenser *pDisp);
    void SetSourceFileName();//comes from g_hModule
    void SetString1(LPWSTR wsz);
    void SetString2(LPWSTR wsz);
    void SetString3(LPWSTR wsz);
    void SetString4(LPWSTR wsz);
    void SetString5();//This string is formed from the column values and must be called after all the dependant columns have been set
    void SetTable(LPWSTR wszTable);
    void SetTime(SYSTEMTIME &systime);
    void SetType(HRESULT hrErrorCode, eDETAILEDERRORS_Type eType);
    void SetUser();
};


/////////////////////////////////////////////////////
//
// CErrorWin32 
//
// This CError object replaces the old CErrorWin32.
// It bahaves to the caller in the same way but it writes
// to the CatalogEventLog XML as well as the NT EventLog.
//
class CErrorWin32 : public CErrorInterceptor
{
public:
    CErrorWin32(HRESULT hrErrorCode,
                ULONG   ulCategory,
                ULONG   ulEvent,
                LPCWSTR szString1=0,
                LPCWSTR szString2=0,
                LPCWSTR szString3=0,
                LPCWSTR szString4=0) : CErrorInterceptor(hrErrorCode, ulCategory, ulEvent, szString1, szString2, szString3, szString4){}

};

/////////////////////////////////////////////////////
//
// CWarningWin32 
//
// It bahaves to the caller in the same way as but it writes
// CErrorWin32 but logs warnings
//

class CWarningWin32 : public CErrorInterceptor
{
public:
    CWarningWin32(HRESULT hrErrorCode,
                  ULONG   ulCategory,
                  ULONG   ulEvent,
                  LPCWSTR szString1=0,
                  LPCWSTR szString2=0,
                  LPCWSTR szString3=0,
                  LPCWSTR szString4=0) : CErrorInterceptor(hrErrorCode, ulCategory, ulEvent, szString1, szString2, szString3, szString4, eDETAILEDERRORS_WARNING){}

};

inline void FillInInsertionString5(LPWSTR wszString5Buffer, ULONG cchString5Buffer, tDETAILEDERRORSRow & errRow)
{
    if(errRow.pString5)
        return;//nothing to do, it's already Not NULL

    if(0 == wszString5Buffer)
        return;
    if(0 == cchString5Buffer)
        return;

    //Generate pString5 from columns.  pString5 contains all the columns after pString4
    //    iDETAILEDERRORS_ErrorCode,  
    //    iDETAILEDERRORS_Interceptor,  
    //    iDETAILEDERRORS_InterceptorSource,  
    //    iDETAILEDERRORS_OperationType,  
    //    iDETAILEDERRORS_Table,  
    //    iDETAILEDERRORS_ConfigurationSource,  
    //    iDETAILEDERRORS_Row,  
    //    iDETAILEDERRORS_Column,  

    //cDETAILEDERRORS_NumberOfColumns

    //We could make this process meta driven; but this object WILL need to be modified
    //if the meta for the DetailedErrors table changes, so why bother.
    static LPCWSTR pwszOperationType[3]={L"Unspecified", L"Populate", L"UpdateStore"};

    WCHAR *pString=wszString5Buffer;

    pString[0] = 0x00;//start with 0 length string
    long size;
    if(errRow.pErrorCode)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: 0x%08X", L"ErrorCode",           *errRow.pErrorCode);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pInterceptor)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"Interceptor",         *errRow.pInterceptor);
        pString += (size<0 ? size*-1 : size);
    }

#ifdef _DEBUG
    //We're not going to put the Source file and line number since it might confuse some user.
    if(errRow.pInterceptorSource)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %s",   L"InterceptorSource",   errRow.pInterceptorSource);
        pString += (size<0 ? size*-1 : size);
    }
#endif

    if(errRow.pOperationType && *errRow.pOperationType<3)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %s",   L"OperationType",       pwszOperationType[*errRow.pOperationType]);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pTable)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %s",   L"Table",               errRow.pTable);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pConfigurationSource)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %s",   L"ConfigurationSource", errRow.pConfigurationSource);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pRow)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"Row",                 *errRow.pRow);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pColumn)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"Column",              *errRow.pColumn);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pMajorVersion)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"MajorVersion",        *errRow.pMajorVersion);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pMinorVersion)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"MinorVersion",        *errRow.pMinorVersion);
        pString += (size<0 ? size*-1 : size);
    }

    wszString5Buffer[cchString5Buffer-1] = 0x00;//make sure it's NULL terminated
    errRow.pString5 = wszString5Buffer;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\cmpxchg.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// cmpxchg.h : Safe InterlockedCompareExchange functions

#ifndef __CMPXCHG_H__
#define __CMPXCHG_H__

#ifdef _M_IX86
		#pragma comment( lib, "txfaux" ) // this function exported in txfaux.dll
        extern "C" BOOL __stdcall CanUseCompareExchange64();
#else
        inline BOOL CanUseCompareExchange64() { return TRUE; }
#endif


class CInterlockedCompareExchange
{
public:

	virtual __int64 InterlockedCompareExchange64(volatile __int64* pDestination, __int64 exchange, __int64 comperand) = 0;

//	// Same as above, using ListRoot's as parameters
//	inline ListRoot InterlockedCompareExchange64  (volatile ListRoot* pDestination, ListRoot exchange, ListRoot comperand)
//	{
//		return (ListRoot) InterlockedCompareExchange64 ((volatile __int64*)pDestination, (__int64)exchange, (__int64)comperand);
//	}
};

CInterlockedCompareExchange * GetSafeInterlockedExchange64();

class CSlowCompareExchange : public CInterlockedCompareExchange
{
private: 
	CSemExclusive m_semCritical;

public:
	CSlowCompareExchange(){}
	virtual __int64 InterlockedCompareExchange64(volatile __int64* pDestination, __int64 exchange, __int64 comperand)
	{
		LOCK();
		if (comperand == *pDestination)
		{
		   *pDestination = exchange;		
		   return comperand;
		}
		return *pDestination;
	}

};
#if (!defined(_M_IX86) && !defined(_M_IA64))
	extern "C" __int64 AlphaInterlockedCompareExchange64 (volatile __int64* pDestination, __int64 exchange, __int64 comperand);
#endif

#pragma warning (disable: 4035)		// function doesn't return value warning.
class CHWInterlockedCompareExchange
{
public:
		CHWInterlockedCompareExchange(){}

#ifdef _M_IX86

   virtual __int64 InterlockedCompareExchange64  (volatile __int64* pDestination, __int64 exchange, __int64 comperand)
	{
		__asm
		{
			mov esi, pDestination

			mov eax, DWORD PTR comperand[0]
			mov edx, DWORD PTR comperand[4]

			mov ebx, DWORD PTR exchange[0]
			mov ecx, DWORD PTR exchange[4]

			_emit 0xF0		// lock
			_emit 0x0F		// cmpxchg8b [esi]
			_emit 0xC7
			_emit 0x0E

			// result is in DX,AX
		}
	}

#elif defined(_M_IA64)

   __int64 virtual InterlockedCompareExchange64 (volatile __int64* pDestination, __int64 exchange, __int64 comperand)
	{
	   // we already have a InterlockedCompareExchangePointer defined in this case, just use that
	   return (__int64)InterlockedCompareExchangePointer((PVOID*)pDestination, (PVOID)exchange, (PVOID)comperand);
	}

#else

	__int64 virtual InterlockedCompareExchange64 (volatile __int64* pDestination, __int64 exchange, __int64 comperand)
	{

		return AlphaInterlockedCompareExchange64(pDestination,exchange,comperand);
	}
	
	// implemented in assembler
#endif

};
#pragma warning (default: 4035)		// function doesn't return value warning


#endif // __CMPXCHG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\comacros.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __COMACROS_H
#define __COMACROS_H

#ifdef USE_NONCRTNEW
// use the services memory allocator
#define DO_NOT_USE_FAILFAST_ALLOCATIONS
#include "svcmem.h"
#endif

#ifdef USE_ADMINASSERT
// ie. we are going to pull in our version of asserts

#ifdef USE_NULLADMINASSERT
#define COMACROSASSERT(bool) 
#define DISPLAYHR(hr)
#define ADMINASSERT(bool) COMACROSASSERT(bool)

#else //! USE_NULLADMINASSERT
//copied form svcserr.h
#define JIMBORULES(x) L ## x
#define W(x) JIMBORULES(x)

void FailFastStr(const wchar_t * szString, const wchar_t * szFile, int nLine);

#define COMACROSASSERT(bool) \
		    { if(!(bool)) FailFastStr(W(#bool), W(__FILE__), __LINE__); }

#define ADMINASSERT(bool) COMACROSASSERT(bool)

void AdminAssert(const wchar_t * szString, const wchar_t * szFile, int nLine);
void DisplayHR(const HRESULT hr, const wchar_t * szFile, int nLine);
#endif //USE_NULLADMINASSERT

#else //! USE_ADMINASSERT
// use msvcrt's assert
#define COMACROSASSERT(bool) assert(bool)
//#define DISPLAYHR(hr) assert(S_OK == hr)
#endif //USE_ADMINASSERT


// Error-handling return and goto macros:
#define return_on_bad_hr(hr) if (FAILED (hr)) { return hr; }
#define areturn_on_bad_hr(hr)					\
if (FAILED (hr))								\
{												\
	if(E_OUTOFMEMORY != hr)						\
	{											\
		COMACROSASSERT (hr == S_OK);			\
	}											\
	return hr;									\
}
											
#define goto_on_bad_hr(hr, label) if (FAILED (hr)) { goto label; }
#define agoto_on_bad_hr(hr, label)				\
{												\
	if (FAILED (hr))							\
	{											\
		if(E_OUTOFMEMORY != hr)					\
		{										\
			COMACROSASSERT (hr == S_OK);		\
		}										\
		goto label;								\
	};											\
}

#define return_on_fail(assertion, hr) if (!(assertion)) { return hr; }
#define areturn_on_fail(assertion, hr) COMACROSASSERT (assertion); if (!(assertion)) { return hr; }
#define goto_on_fail(assertion, hr, ecode, label) if (!(assertion)) { hr = ecode; goto label; }
#define agoto_on_fail(assertion, hr, ecode, label) COMACROSASSERT (assertion); if (!(assertion)) { hr = ecode; goto label; }

#define return_on_bad_lr(lr, hr) if (ERROR_SUCCESS != lr) { return hr; }
#define areturn_on_bad_lr(lr, hr) COMACROSASSERT (ERROR_SUCCESS == lr); if (ERROR_SUCCESS != lr) { return hr; }
#define goto_on_bad_lr(lr, hr, ecode, label) if (ERROR_SUCCESS != lr) { hr = ecode; goto label; }
#define agoto_on_bad_lr(lr, hr, ecode, label) COMACROSASSERT (ERROR_SUCCESS == lr); if (ERROR_SUCCESS != lr) { hr = ecode; goto label; }

// Pointer declaration macros (single items, arrays, com memory, and interfaces):
#define ptr_item(t, p) t* p = NULL;
#define ptr_array(t, p) t* p = NULL;
#define ptr_comem(t, p) t* p = NULL;
#define ptr_interface(t, p) t* p = NULL;

// Pointer creation macros (single items, arrays):
#define new_item(p, t) \
{								\
	COMACROSASSERT (NULL == p); \
	p = new t;					\
	if(NULL == p) return E_OUTOFMEMORY; \
}
#define new_array(p, t, c) \
{								\
	COMACROSASSERT (NULL == p); \
	p = new t[c];				\
	if(NULL == p) return E_OUTOFMEMORY; \
}
#define new_comem(p, t, c)		\
{								\
	COMACROSASSERT (NULL == p);	\
	p = (t*) CoTaskMemAlloc ((c) * sizeof (t)); \
	if(NULL == p) return E_OUTOFMEMORY; \
}

// Pointer destruction macros (single items, arrays, com memory, and interfaces):
#define delete_item(p) if (NULL != p) { delete p; p = NULL; }
#define delete_array(p) if (NULL != p) { delete[] p; p = NULL; }
#define release_comem(p) if (NULL != p) { CoTaskMemFree (p); p = NULL; }
#define release_interface(p) if (NULL != p) { p->Release (); p = NULL; }

// Memory declaration, creation, and destruction macros:
#define mem_null(t, p) t* p = NULL;
#define mem_realloc(p, cb) \
{									\
	p = CoTaskMemRealloc (p, cb);	\
	if(NULL == p) return E_OUTOFMEMORY; \
}
#define mem_free(p) if (NULL != p) { CoTaskMemFree (p); p = NULL; }

#endif // __COMACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\cfgarray.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    cfgarray.h

$Header: $

Abstract:

Author:
    marcelv     5/9/2001 12:28:08       Initial Release

Revision History:

--**************************************************************************/

#ifndef __CFGARRAY_H__
#define __CFGARRAY_H__

#pragma once

#include <catalog.h>
#include "catmacros.h"

template <class T> 
class CCfgArray
{
public:
    CCfgArray () : m_aData(0), m_cElements(0), m_cSize(0) {}
    ~CCfgArray ()
    {
        delete [] m_aData;
        m_aData = 0;
    }

    ULONG Count () const
    {
        return m_cElements;
    }

    ULONG AllocSize () const
    {
        return m_cSize;
    }

    HRESULT SetAllocSize (ULONG i_iNewSize)
    {
        ASSERT (i_iNewSize > m_cSize);

        return AllocNewSize (i_NewSize);
    }

    HRESULT Append (const T& i_NewElement)
    {
        return InsertAt (i_NewElement, m_cElements);
    }

    HRESULT Prepend (const T& i_NewElement)
    {
       return InsertAt (i_NewElement, 0);
    }

    HRESULT InsertAt (const T& i_NewElement, ULONG i_idx)
    {
        ASSERT (i_idx >=0 && i_idx <= m_cElements);
        HRESULT hr = S_OK;
        if (m_cElements==m_cSize)
        {
            hr = AllocNewSize (m_cSize==0?1:2*m_cSize);
            if (FAILED (hr))
            {
                return hr;
            }
        }

        memmove (m_aData + i_idx + 1, m_aData + i_idx, sizeof (T) * (m_cElements - i_idx));
        m_aData[i_idx] = i_NewElement;
        m_cElements++;

        return hr;
    }

    T& operator[] (ULONG idx) const
    {
        ASSERT (idx >= 0 && idx < m_cElements);
        return m_aData[idx];
    };

//=================================================================================
// The Iterator class is used to navigate through the elements in the linked list. Call
// List::Begin to get an iterator pointing to the first element in the list, and call
// Next to get the next element in the list. List::End can be used if we are at the end
// of the list
//=================================================================================
	class Iterator
	{
		friend class CCfgArray<T>;
	public:
		
		//=================================================================================
		// Function: Next
		//
		// Synopsis: get iterator to next element in the list
		//=================================================================================
		void Next () { m_curIdx++;}

		//=================================================================================
		// Function: Value
		//
		// Synopsis: Returns value of element that iterator points to
		//=================================================================================
		T& Value () const 
        {
            return m_aData[m_curIdx];
        }
		
		bool operator== (const Iterator& rhs) const	{return m_curIdx == rhs.m_curIdx;}
		bool operator!= (const Iterator& rhs) const {return m_curIdx != rhs.m_curIdx;}

	private:
        Iterator (const CCfgArray<T> * i_paData, ULONG iStart) : m_aData(*i_paData), m_curIdx (iStart) {} // only list can create these
		ULONG m_curIdx;
        const CCfgArray<T>& m_aData;
	};

    //=================================================================================
	// Function: Begin
	//
	// Synopsis: Returns an iterator to the beginning of the list
	//=================================================================================
	const Iterator Begin () const
	{
		return Iterator (this, 0);
	}

	//=================================================================================
	// Function: End
	//
	// Synopsis: Returns an iterator one past the end of the list (like STL does)
	//=================================================================================
	const Iterator End () const
	{
		return Iterator (this, m_cElements);
	}

    // returns index of place to insert element in sorted array
    ULONG BinarySearch (const T& i_ElemToSearch) const
    {
        ULONG iLow = 0;
        ULONG iHigh = m_cElements;
        while (iLow < iHigh) 
        {
            // (low + high) / 2 might overflow
            ULONG iMid = iLow + (iHigh - iLow) / 2;
            if (m_aData[iMid] > i_ElemToSearch)
            {
                iHigh = iMid;
            }
            else
            {
                iLow = iMid + 1;
            }
        }

        return iLow;
    }

private:
    HRESULT AllocNewSize (ULONG i_NewSize)
    {
        ASSERT (i_NewSize > m_cSize);

        T * aNewData = new T [i_NewSize];
        if (aNewData == 0)
        {
            return E_OUTOFMEMORY;
        }
        memcpy (aNewData, m_aData, m_cSize * sizeof (T));

        delete[] m_aData;
        m_aData = aNewData;
        m_cSize = i_NewSize;

        return S_OK;
    }

    // we don't allow copies
    CCfgArray (const CCfgArray<T>& );
    CCfgArray<T>& operator=(const CCfgArray<T>& );

    T *     m_aData;
    ULONG   m_cSize;
    ULONG   m_cElements;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\comregblobs.h ===
//*****************************************************************************
// Structures for comreg.clb
// 4/23/1999  16:29:46
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
extern const DECLSPEC_SELECTANY int g_iCOMRegTables = 16;
extern const BYTE DECLSPEC_SELECTANY g_rgCOMRegSchemaDataRW[] = 
{
	0x10,0x00,0x00,0x00,0x18,0x0C,0x00,0x00,0x48,0x00,0x00,0x00,0x9C,0x02,0x00,0x00,0xD0,0x02,0x00,0x00,
	0x44,0x03,0x00,0x00,0x78,0x04,0x00,0x00,0x5C,0x07,0x00,0x00,0xB0,0x07,0x00,0x00,0x14,0x08,0x00,0x00,
	0x68,0x08,0x00,0x00,0x3C,0x09,0x00,0x00,0xB0,0x09,0x00,0x00,0x74,0x0A,0x00,0x00,0xC8,0x0A,0x00,0x00,
	0x1C,0x0B,0x00,0x00,0x90,0x0B,0x00,0x00,0xE4,0x0B,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x28,
	0x23,0x10,0x00,0x54,0x00,0x00,0xFF,0xFF,0x90,0x00,0x54,0x02,0x14,0x00,0x00,0x00,0x01,0x04,0x48,0x00,
	0x40,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1B,0x00,0x00,0x00,0x02,0x01,0x82,0x00,0x44,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x24,0x00,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x2A,0x00,0x00,0x00,0x04,0x01,0x82,0x00,0x48,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x35,0x00,0x00,0x00,
	0x05,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x41,0x00,0x00,0x00,0x06,0x01,0x82,0x00,
	0x4C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x4D,0x00,0x00,0x00,0x07,0x01,0x82,0x00,0x50,0x00,0x04,0x00,
	0xFF,0x00,0xFF,0x43,0x59,0x00,0x00,0x00,0x08,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x67,0x00,0x00,0x00,0x09,0x01,0x82,0x00,0x54,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x71,0x00,0x00,0x00,
	0x0A,0x01,0x80,0x00,0x58,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x82,0x00,0x00,0x00,0x0B,0x01,0x82,0x00,
	0x5C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x8E,0x00,0x00,0x00,0x0C,0x01,0x82,0x00,0x60,0x00,0x04,0x00,
	0x01,0x00,0xFF,0x43,0x97,0x00,0x00,0x00,0x0D,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xA6,0x00,0x00,0x00,0x0E,0x00,0x13,0x00,0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xB4,0x00,0x00,0x00,
	0x0F,0x01,0x82,0x00,0x64,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0xBF,0x00,0x00,0x00,0x10,0x01,0x82,0x00,
	0x68,0x00,0x04,0x00,0x50,0x00,0xFF,0x43,0xC9,0x00,0x00,0x00,0x11,0x01,0x82,0x00,0x6C,0x00,0x04,0x00,
	0x14,0x00,0xFF,0x43,0xD4,0x00,0x00,0x00,0x12,0x00,0x82,0x00,0x70,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,
	0xDF,0x00,0x00,0x00,0x13,0x00,0x82,0x00,0x74,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0xEA,0x00,0x00,0x00,
	0x14,0x01,0x82,0x00,0x78,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0xF4,0x00,0x00,0x00,0x15,0x01,0x80,0x00,
	0x7C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFE,0x00,0x00,0x00,0x16,0x00,0x13,0x00,0x14,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x19,0x01,0x00,0x00,0x17,0x00,0x13,0x00,0x18,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x32,0x01,0x00,0x00,0x18,0x01,0x80,0x00,0x80,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x45,0x01,0x00,0x00,
	0x19,0x00,0x13,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x58,0x01,0x00,0x00,0x1A,0x00,0x13,0x00,
	0x20,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x71,0x01,0x00,0x00,0x1B,0x00,0x13,0x00,0x24,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x7C,0x01,0x00,0x00,0x1C,0x00,0x13,0x00,0x28,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x8E,0x01,0x00,0x00,0x1D,0x00,0x13,0x00,0x2C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x97,0x01,0x00,0x00,
	0x1E,0x01,0x82,0x00,0x84,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0xA9,0x01,0x00,0x00,0x1F,0x00,0x13,0x00,
	0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xB7,0x01,0x00,0x00,0x20,0x00,0x13,0x00,0x34,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xC4,0x01,0x00,0x00,0x21,0x00,0x13,0x00,0x38,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xCE,0x01,0x00,0x00,0x22,0x00,0x13,0x00,0x3C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xD9,0x01,0x00,0x00,
	0x23,0x01,0x82,0x00,0x88,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xE4,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x8C,0x00,0x01,0x01,0x00,0x58,0xFD,0x01,0x00,0x00,0x01,0x00,0x01,0x28,0x01,0x00,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x08,0x00,0x34,0x00,0x11,0x02,0x00,0x00,0x01,0x04,0x82,0x00,0x00,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x16,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x04,0x00,0x01,0x01,0x00,0x58,
	0x30,0x02,0x00,0x00,0x02,0x00,0x02,0x20,0x04,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x18,0x00,0x74,0x00,
	0x47,0x02,0x00,0x00,0x01,0x82,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x51,0x02,0x00,0x00,
	0x02,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x57,0x02,0x00,0x00,0x03,0x82,0x13,0x00,
	0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x5D,0x02,0x00,0x00,0x04,0x00,0x48,0x00,0x0C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x6C,0x02,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x10,0x00,0x03,0x01,0x02,0x03,
	0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x01,0x00,0x58,0x97,0x02,0x00,0x00,
	0x03,0x00,0x01,0x28,0x11,0x09,0x00,0x54,0x00,0x00,0xFF,0xFF,0x48,0x00,0x34,0x01,0x11,0x02,0x00,0x00,
	0x01,0x04,0x82,0x00,0x18,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x82,0x00,0x00,0x00,0x02,0x01,0x82,0x00,
	0x1C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xAC,0x02,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xBF,0x02,0x00,0x00,0x04,0x01,0x82,0x00,0x20,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xD2,0x02,0x00,0x00,0x05,0x00,0x82,0x00,0x24,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xE9,0x02,0x00,0x00,
	0x06,0x01,0x82,0x00,0x28,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xFA,0x02,0x00,0x00,0x07,0x01,0x82,0x00,
	0x2C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x0B,0x03,0x00,0x00,0x08,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x1A,0x03,0x00,0x00,0x09,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x31,0x03,0x00,0x00,0x0A,0x01,0x82,0x00,0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x4B,0x03,0x00,0x00,
	0x0B,0x01,0x82,0x00,0x34,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x54,0x03,0x00,0x00,0x0C,0x01,0x82,0x00,
	0x38,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x5F,0x03,0x00,0x00,0x0D,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x7A,0x03,0x00,0x00,0x0E,0x00,0x13,0x00,0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x94,0x03,0x00,0x00,0x0F,0x01,0x82,0x00,0x3C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xAB,0x03,0x00,0x00,
	0x10,0x00,0x13,0x00,0x14,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xBB,0x03,0x00,0x00,0x11,0x01,0x82,0x00,
	0x40,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC7,0x03,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x44,0x00,
	0x01,0x01,0x00,0x58,0xE2,0x03,0x00,0x00,0x04,0x00,0x03,0x28,0x2A,0x10,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0xB4,0x00,0xE4,0x02,0xF9,0x03,0x00,0x00,0x01,0x04,0x48,0x00,0x64,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x14,0x00,0x00,0x00,0x02,0x01,0x48,0x00,0x68,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFF,0x03,0x00,0x00,
	0x03,0x01,0x48,0x00,0x6C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x09,0x04,0x00,0x00,0x04,0x00,0x13,0x00,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x16,0x04,0x00,0x00,0x05,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x23,0x04,0x00,0x00,0x06,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x30,0x04,0x00,0x00,0x07,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x40,0x04,0x00,0x00,
	0x08,0x00,0x13,0x00,0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x47,0x04,0x00,0x00,0x09,0x00,0x13,0x00,
	0x14,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x50,0x04,0x00,0x00,0x0A,0x00,0x13,0x00,0x18,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x5C,0x04,0x00,0x00,0x0B,0x00,0x13,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x6B,0x04,0x00,0x00,0x0C,0x00,0x13,0x00,0x20,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x78,0x04,0x00,0x00,
	0x0D,0x00,0x13,0x00,0x24,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x86,0x04,0x00,0x00,0x0E,0x00,0x13,0x00,
	0x28,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x96,0x04,0x00,0x00,0x0F,0x00,0x13,0x00,0x2C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x19,0x01,0x00,0x00,0x10,0x00,0x13,0x00,0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x32,0x01,0x00,0x00,0x11,0x01,0x80,0x00,0x70,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xA4,0x04,0x00,0x00,
	0x12,0x01,0x48,0x00,0x74,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xAE,0x04,0x00,0x00,0x13,0x00,0x13,0x00,
	0x34,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xBA,0x04,0x00,0x00,0x14,0x00,0x13,0x00,0x38,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xC6,0x04,0x00,0x00,0x15,0x00,0x13,0x00,0x3C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xD6,0x04,0x00,0x00,0x16,0x01,0x82,0x00,0x78,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xE6,0x04,0x00,0x00,
	0x17,0x00,0x13,0x00,0x40,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xF1,0x04,0x00,0x00,0x18,0x01,0x48,0x00,
	0x7C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x02,0x05,0x00,0x00,0x19,0x00,0x13,0x00,0x44,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x1A,0x05,0x00,0x00,0x1A,0x01,0x82,0x00,0x80,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x26,0x05,0x00,0x00,0x1B,0x01,0x48,0x00,0x84,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x35,0x05,0x00,0x00,
	0x1C,0x01,0x82,0x00,0x88,0x00,0x04,0x00,0xF4,0x01,0xFF,0x43,0x44,0x05,0x00,0x00,0x1D,0x00,0x13,0x00,
	0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x57,0x05,0x00,0x00,0x1E,0x01,0x82,0x00,0x8C,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x6B,0x05,0x00,0x00,0x1F,0x00,0x13,0x00,0x4C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x80,0x05,0x00,0x00,0x20,0x03,0x82,0x00,0x90,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x8E,0x05,0x00,0x00,
	0x21,0x01,0x82,0x00,0x94,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xA1,0x05,0x00,0x00,0x22,0x03,0x82,0x00,
	0x98,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xB1,0x05,0x00,0x00,0x23,0x00,0x13,0x00,0x50,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xC2,0x05,0x00,0x00,0x24,0x00,0x13,0x00,0x54,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xCE,0x05,0x00,0x00,0x25,0x01,0x82,0x00,0x9C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xDA,0x05,0x00,0x00,
	0x26,0x01,0x48,0x00,0xA0,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xE9,0x05,0x00,0x00,0x27,0x00,0x13,0x00,
	0x58,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x00,0x06,0x00,0x00,0x28,0x00,0x13,0x00,0x5C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x0E,0x06,0x00,0x00,0x29,0x00,0x13,0x00,0x60,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x21,0x06,0x00,0x00,0x2A,0x01,0x82,0x00,0xA4,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x36,0x06,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0xA8,0x00,0x01,0x01,0x00,0x58,0x53,0x06,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0xAC,0x00,0x01,0x20,0x00,0x58,0x64,0x06,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0xB0,0x00,
	0x01,0x22,0x00,0x58,0x75,0x06,0x00,0x00,0x05,0x00,0x01,0x20,0x03,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x10,0x00,0x54,0x00,0x84,0x06,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x90,0x06,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x82,0x00,0x00,0x00,
	0x03,0x01,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x99,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0xAC,0x06,0x00,0x00,0x06,0x00,0x01,0x20,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x84,0x06,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x90,0x06,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xBE,0x06,0x00,0x00,0x03,0x82,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xCA,0x06,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0x2B,0x00,0xFF,0x43,0xD2,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x10,0x00,0x03,0x01,0x02,0x03,0xE8,0x06,0x00,0x00,0x07,0x00,0x01,0x20,0x03,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0x84,0x06,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x90,0x06,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x32,0x01,0x00,0x00,0x03,0x01,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFB,0x06,0x00,0x00,
	0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0x12,0x07,0x00,0x00,0x08,0x00,0x02,0x20,
	0x0A,0x05,0x01,0x54,0x00,0x00,0x28,0x00,0x34,0x00,0xD4,0x00,0x28,0x07,0x00,0x00,0x01,0x82,0x48,0x00,
	0x10,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x34,0x07,0x00,0x00,0x02,0x82,0x48,0x00,0x14,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x3E,0x07,0x00,0x00,0x03,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x4A,0x07,0x00,0x00,0x04,0x01,0x80,0x00,0x18,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xA4,0x04,0x00,0x00,
	0x05,0x01,0x48,0x00,0x1C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x5C,0x07,0x00,0x00,0x06,0x01,0x82,0x00,
	0x20,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x67,0x07,0x00,0x00,0x07,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x24,0x00,0x00,0x00,0x08,0x01,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x00,0x43,
	0x6E,0x07,0x00,0x00,0x09,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x82,0x00,0x00,0x00,
	0x0A,0x01,0x82,0x00,0x24,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x7B,0x07,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x2C,0x00,0x03,0x01,0x02,0x03,0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x30,0x00,
	0x01,0x01,0x00,0x58,0x95,0x07,0x00,0x00,0x09,0x00,0x02,0x20,0x04,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x18,0x00,0x74,0x00,0x28,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x34,0x07,0x00,0x00,0x02,0x82,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x67,0x07,0x00,0x00,
	0x03,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x4A,0x07,0x00,0x00,0x04,0x01,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xB1,0x07,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x10,0x00,
	0x03,0x01,0x02,0x03,0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x01,0x00,0x58,
	0xD1,0x07,0x00,0x00,0x0A,0x00,0x02,0x20,0x09,0x04,0x00,0x54,0x00,0x00,0xFF,0xFF,0x2C,0x00,0xC4,0x00,
	0x28,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x34,0x07,0x00,0x00,
	0x02,0x82,0x48,0x00,0x10,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xE7,0x07,0x00,0x00,0x03,0x01,0x82,0x00,
	0x14,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x4A,0x07,0x00,0x00,0x04,0x01,0x80,0x00,0x18,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xF5,0x07,0x00,0x00,0x05,0x01,0x48,0x00,0x1C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xFF,0x07,0x00,0x00,0x06,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0E,0x08,0x00,0x00,
	0x07,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1A,0x08,0x00,0x00,0x08,0x00,0x13,0x00,
	0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x82,0x00,0x00,0x00,0x09,0x01,0x82,0x00,0x20,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x2E,0x08,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x24,0x00,0x02,0x01,0x02,0x58,
	0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x28,0x00,0x01,0x01,0x00,0x58,0x48,0x08,0x00,0x00,
	0x0B,0x00,0x01,0x20,0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0xA4,0x04,0x00,0x00,
	0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x90,0x06,0x00,0x00,0x02,0x82,0x82,0x00,
	0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x84,0x06,0x00,0x00,0x03,0x00,0x48,0x00,0x08,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x57,0x08,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,
	0x6A,0x08,0x00,0x00,0x0C,0x00,0x02,0x20,0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,
	0x7F,0x08,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x8F,0x08,0x00,0x00,
	0x02,0x82,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9C,0x08,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x08,0x00,0x02,0x01,0x02,0x58,0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x0C,0x00,
	0x01,0x01,0x00,0x58,0xB5,0x08,0x00,0x00,0x0D,0x00,0x01,0x28,0x05,0x04,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x18,0x00,0x74,0x00,0xCC,0x08,0x00,0x00,0x01,0x04,0x82,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,
	0xD7,0x08,0x00,0x00,0x02,0x01,0x82,0x00,0x04,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0xE9,0x08,0x00,0x00,
	0x03,0x01,0x82,0x00,0x08,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0xF0,0x08,0x00,0x00,0x04,0x01,0x82,0x00,
	0x0C,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0xF9,0x08,0x00,0x00,0x05,0x01,0x82,0x00,0x10,0x00,0x04,0x00,
	0x02,0x02,0xFF,0x43,0x12,0x09,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x14,0x00,0x01,0x01,0x00,0x58,
	0x2F,0x09,0x00,0x00,0x0E,0x00,0x01,0x20,0x03,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,
	0x3B,0x09,0x00,0x00,0x01,0x82,0x82,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0xCC,0x08,0x00,0x00,
	0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0x45,0x09,0x00,0x00,0x03,0x01,0x82,0x00,
	0x08,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0x50,0x09,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,
	0x02,0x01,0x02,0x58,0x60,0x09,0x00,0x00,0x0F,0x00,0x01,0x28,0x01,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x08,0x00,0x34,0x00,0x2A,0x00,0x00,0x00,0x01,0x04,0x82,0x00,0x00,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x73,0x09,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x04,0x00,0x01,0x01,0x00,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbCOMRegSchemaRW = 3096;
extern const DECLSPEC_SELECTANY BYTE g_rgCOMRegSchemaStringHeap[] = 
{
	0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x41,0x70,0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x00,
	0x41,0x70,0x70,0x6C,0x49,0x44,0x00,0x41,0x70,0x70,0x6C,0x4E,0x61,0x6D,0x65,0x00,0x46,0x6C,0x61,0x67,
	0x73,0x00,0x53,0x65,0x72,0x76,0x65,0x72,0x4E,0x61,0x6D,0x65,0x00,0x50,0x72,0x6F,0x63,0x65,0x73,0x73,
	0x54,0x79,0x70,0x65,0x00,0x43,0x6F,0x6D,0x6D,0x61,0x6E,0x64,0x4C,0x69,0x6E,0x65,0x00,0x53,0x65,0x72,
	0x76,0x69,0x63,0x65,0x4E,0x61,0x6D,0x65,0x00,0x52,0x75,0x6E,0x41,0x73,0x55,0x73,0x65,0x72,0x54,0x79,
	0x70,0x65,0x00,0x52,0x75,0x6E,0x41,0x73,0x55,0x73,0x65,0x72,0x00,0x41,0x63,0x63,0x65,0x73,0x73,0x50,
	0x65,0x72,0x6D,0x69,0x73,0x73,0x69,0x6F,0x6E,0x00,0x44,0x65,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6F,
	0x6E,0x00,0x49,0x73,0x53,0x79,0x73,0x74,0x65,0x6D,0x00,0x41,0x75,0x74,0x68,0x65,0x6E,0x74,0x69,0x63,
	0x61,0x74,0x69,0x6F,0x6E,0x00,0x53,0x68,0x75,0x74,0x64,0x6F,0x77,0x6E,0x41,0x66,0x74,0x65,0x72,0x00,
	0x52,0x75,0x6E,0x46,0x6F,0x72,0x65,0x76,0x65,0x72,0x00,0x52,0x65,0x73,0x65,0x72,0x76,0x65,0x64,0x31,
	0x00,0x41,0x63,0x74,0x69,0x76,0x61,0x74,0x69,0x6F,0x6E,0x00,0x43,0x68,0x61,0x6E,0x67,0x65,0x61,0x62,
	0x6C,0x65,0x00,0x44,0x65,0x6C,0x65,0x74,0x65,0x61,0x62,0x6C,0x65,0x00,0x43,0x72,0x65,0x61,0x74,0x65,
	0x64,0x42,0x79,0x00,0x51,0x75,0x65,0x75,0x65,0x42,0x6C,0x6F,0x62,0x00,0x52,0x6F,0x6C,0x65,0x42,0x61,
	0x73,0x65,0x64,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x53,0x75,0x70,0x70,0x6F,0x72,0x74,0x65,0x64,
	0x00,0x52,0x6F,0x6C,0x65,0x42,0x61,0x73,0x65,0x64,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x45,0x6E,
	0x61,0x62,0x6C,0x65,0x64,0x00,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x44,0x65,0x73,0x63,0x72,0x69,
	0x70,0x74,0x6F,0x72,0x00,0x49,0x6D,0x70,0x65,0x72,0x73,0x6F,0x6E,0x61,0x74,0x69,0x6F,0x6E,0x4C,0x65,
	0x76,0x65,0x6C,0x00,0x41,0x75,0x74,0x68,0x65,0x6E,0x74,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x43,0x61,
	0x70,0x61,0x62,0x69,0x6C,0x69,0x74,0x79,0x00,0x43,0x52,0x4D,0x45,0x6E,0x61,0x62,0x6C,0x65,0x64,0x00,
	0x45,0x6E,0x61,0x62,0x6C,0x65,0x33,0x47,0x69,0x67,0x53,0x75,0x70,0x70,0x6F,0x72,0x74,0x00,0x49,0x73,
	0x51,0x75,0x65,0x75,0x65,0x64,0x00,0x51,0x43,0x4C,0x69,0x73,0x74,0x65,0x6E,0x65,0x72,0x45,0x6E,0x61,
	0x62,0x6C,0x65,0x64,0x00,0x45,0x76,0x65,0x6E,0x74,0x73,0x45,0x6E,0x61,0x62,0x6C,0x65,0x64,0x00,0x50,
	0x72,0x6F,0x63,0x65,0x73,0x73,0x46,0x6C,0x61,0x67,0x73,0x00,0x54,0x68,0x72,0x65,0x61,0x64,0x4D,0x61,
	0x78,0x00,0x49,0x73,0x50,0x72,0x6F,0x78,0x79,0x41,0x70,0x70,0x00,0x43,0x72,0x6D,0x4C,0x6F,0x67,0x46,
	0x69,0x6C,0x65,0x00,0x23,0x23,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x41,0x70,0x70,0x6C,0x69,0x63,0x61,
	0x74,0x69,0x6F,0x6E,0x5F,0x44,0x65,0x78,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x43,0x6F,0x6D,0x70,
	0x75,0x74,0x65,0x72,0x4C,0x69,0x73,0x74,0x00,0x4E,0x61,0x6D,0x65,0x00,0x23,0x23,0x43,0x4F,0x4D,0x52,
	0x65,0x67,0x2E,0x43,0x6F,0x6D,0x70,0x75,0x74,0x65,0x72,0x4C,0x69,0x73,0x74,0x5F,0x44,0x65,0x78,0x00,
	0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x43,0x75,0x73,0x74,0x6F,0x6D,0x41,0x63,0x74,0x69,0x76,0x61,0x74,
	0x6F,0x72,0x00,0x43,0x6F,0x6D,0x70,0x43,0x4C,0x53,0x49,0x44,0x00,0x53,0x74,0x61,0x67,0x65,0x00,0x4F,
	0x72,0x64,0x65,0x72,0x00,0x41,0x63,0x74,0x69,0x76,0x61,0x74,0x6F,0x72,0x43,0x4C,0x53,0x49,0x44,0x00,
	0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4D,0x50,0x4B,0x5F,0x43,0x75,0x73,0x74,0x6F,0x6D,0x41,0x63,0x74,
	0x69,0x76,0x61,0x74,0x6F,0x72,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x44,0x65,0x78,0x5F,0x43,0x6F,
	0x6C,0x30,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4C,0x6F,0x63,0x61,0x6C,0x43,0x6F,0x6D,0x70,0x75,
	0x74,0x65,0x72,0x00,0x54,0x72,0x61,0x6E,0x73,0x61,0x63,0x74,0x69,0x6F,0x6E,0x54,0x69,0x6D,0x65,0x6F,
	0x75,0x74,0x00,0x50,0x61,0x63,0x6B,0x61,0x67,0x65,0x49,0x6E,0x73,0x74,0x61,0x6C,0x6C,0x50,0x61,0x74,
	0x68,0x00,0x52,0x65,0x73,0x6F,0x75,0x72,0x63,0x65,0x50,0x6F,0x6F,0x6C,0x69,0x6E,0x67,0x45,0x6E,0x61,
	0x62,0x6C,0x65,0x64,0x00,0x52,0x65,0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x53,0x68,0x61,0x72,
	0x65,0x00,0x52,0x65,0x6D,0x6F,0x74,0x65,0x53,0x65,0x72,0x76,0x65,0x72,0x4E,0x61,0x6D,0x65,0x00,0x49,
	0x4D,0x44,0x42,0x4D,0x65,0x6D,0x6F,0x72,0x79,0x53,0x69,0x7A,0x65,0x00,0x49,0x4D,0x44,0x42,0x52,0x65,
	0x73,0x65,0x72,0x76,0x65,0x64,0x42,0x6C,0x6F,0x62,0x4D,0x65,0x6D,0x6F,0x72,0x79,0x00,0x49,0x4D,0x44,
	0x42,0x4C,0x6F,0x61,0x64,0x54,0x61,0x62,0x6C,0x65,0x73,0x44,0x79,0x6E,0x61,0x6D,0x69,0x63,0x61,0x6C,
	0x6C,0x79,0x00,0x49,0x73,0x52,0x6F,0x75,0x74,0x65,0x72,0x00,0x45,0x6E,0x61,0x62,0x6C,0x65,0x44,0x43,
	0x4F,0x4D,0x00,0x44,0x65,0x66,0x61,0x75,0x6C,0x74,0x41,0x75,0x74,0x68,0x65,0x6E,0x74,0x69,0x63,0x61,
	0x74,0x69,0x6F,0x6E,0x4C,0x65,0x76,0x65,0x6C,0x00,0x44,0x65,0x66,0x61,0x75,0x6C,0x74,0x49,0x6D,0x70,
	0x65,0x72,0x73,0x6F,0x6E,0x61,0x74,0x69,0x6F,0x6E,0x4C,0x65,0x76,0x65,0x6C,0x00,0x45,0x6E,0x61,0x62,
	0x6C,0x65,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x54,0x72,0x61,0x63,0x6B,0x69,0x6E,0x67,0x00,0x41,
	0x63,0x74,0x69,0x76,0x69,0x74,0x79,0x54,0x69,0x6D,0x65,0x6F,0x75,0x74,0x00,0x49,0x4D,0x44,0x42,0x45,
	0x6E,0x61,0x62,0x6C,0x65,0x64,0x00,0x23,0x23,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4C,0x6F,0x63,0x61,
	0x6C,0x43,0x6F,0x6D,0x70,0x75,0x74,0x65,0x72,0x5F,0x44,0x65,0x78,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,
	0x2E,0x43,0x6C,0x61,0x73,0x73,0x65,0x73,0x49,0x6E,0x74,0x65,0x72,0x6E,0x61,0x6C,0x00,0x43,0x4C,0x53,
	0x49,0x44,0x00,0x49,0x6D,0x70,0x6C,0x43,0x4C,0x53,0x49,0x44,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,
	0x4D,0x61,0x6A,0x6F,0x72,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,0x4D,0x69,0x6E,0x6F,0x72,0x00,0x56,
	0x65,0x72,0x73,0x69,0x6F,0x6E,0x42,0x75,0x69,0x6C,0x64,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,0x53,
	0x75,0x62,0x42,0x75,0x69,0x6C,0x64,0x00,0x4C,0x6F,0x63,0x61,0x6C,0x65,0x00,0x43,0x6C,0x61,0x73,0x73,
	0x43,0x74,0x78,0x00,0x54,0x72,0x61,0x6E,0x73,0x61,0x63,0x74,0x69,0x6F,0x6E,0x00,0x53,0x79,0x6E,0x63,
	0x72,0x6F,0x6E,0x69,0x7A,0x61,0x74,0x69,0x6F,0x6E,0x00,0x4C,0x6F,0x61,0x64,0x42,0x61,0x6C,0x61,0x6E,
	0x63,0x65,0x64,0x00,0x49,0x49,0x53,0x49,0x6E,0x74,0x72,0x69,0x6E,0x73,0x69,0x63,0x73,0x00,0x43,0x6F,
	0x6D,0x54,0x49,0x49,0x6E,0x74,0x72,0x69,0x6E,0x73,0x69,0x63,0x73,0x00,0x4A,0x49,0x54,0x41,0x63,0x74,
	0x69,0x76,0x61,0x74,0x69,0x6F,0x6E,0x00,0x52,0x6F,0x6C,0x65,0x53,0x65,0x74,0x49,0x44,0x00,0x4D,0x69,
	0x6E,0x50,0x6F,0x6F,0x6C,0x53,0x69,0x7A,0x65,0x00,0x4D,0x61,0x78,0x50,0x6F,0x6F,0x6C,0x53,0x69,0x7A,
	0x65,0x00,0x43,0x72,0x65,0x61,0x74,0x69,0x6F,0x6E,0x54,0x69,0x6D,0x65,0x6F,0x75,0x74,0x00,0x43,0x6F,
	0x6E,0x73,0x74,0x72,0x75,0x63,0x74,0x53,0x74,0x72,0x69,0x6E,0x67,0x00,0x43,0x6C,0x61,0x73,0x73,0x46,
	0x6C,0x61,0x67,0x73,0x00,0x44,0x65,0x66,0x61,0x75,0x6C,0x74,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,
	0x65,0x00,0x4E,0x6F,0x53,0x65,0x74,0x43,0x6F,0x6D,0x70,0x6C,0x65,0x74,0x65,0x45,0x74,0x41,0x6C,0x4F,
	0x70,0x74,0x69,0x6F,0x6E,0x00,0x53,0x61,0x76,0x65,0x64,0x50,0x72,0x6F,0x67,0x49,0x64,0x00,0x52,0x65,
	0x67,0x69,0x73,0x74,0x72,0x61,0x72,0x43,0x4C,0x53,0x49,0x44,0x00,0x45,0x78,0x63,0x65,0x70,0x74,0x69,
	0x6F,0x6E,0x43,0x6C,0x61,0x73,0x73,0x00,0x49,0x73,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x43,0x6F,0x6D,
	0x70,0x6F,0x6E,0x65,0x6E,0x74,0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x49,0x6E,0x70,0x72,0x6F,0x63,
	0x53,0x65,0x72,0x76,0x65,0x72,0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x54,0x68,0x72,0x65,0x61,0x64,
	0x69,0x6E,0x4D,0x6F,0x64,0x65,0x6C,0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x50,0x72,0x6F,0x67,0x49,
	0x44,0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x44,0x65,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6F,0x6E,
	0x00,0x53,0x65,0x6C,0x66,0x52,0x65,0x67,0x56,0x49,0x50,0x72,0x6F,0x67,0x49,0x44,0x00,0x56,0x62,0x44,
	0x65,0x62,0x75,0x67,0x67,0x69,0x6E,0x67,0x46,0x6C,0x61,0x67,0x73,0x00,0x49,0x73,0x50,0x75,0x62,0x6C,
	0x69,0x73,0x68,0x65,0x72,0x00,0x50,0x75,0x62,0x6C,0x69,0x73,0x68,0x65,0x72,0x49,0x44,0x00,0x4D,0x49,
	0x50,0x46,0x69,0x6C,0x74,0x65,0x72,0x43,0x4C,0x53,0x49,0x44,0x00,0x41,0x6C,0x6C,0x6F,0x77,0x49,0x6E,
	0x70,0x72,0x6F,0x63,0x53,0x75,0x62,0x73,0x63,0x72,0x69,0x62,0x65,0x72,0x73,0x00,0x46,0x69,0x72,0x65,
	0x49,0x6E,0x50,0x61,0x72,0x61,0x6C,0x65,0x6C,0x00,0x53,0x61,0x76,0x65,0x64,0x54,0x68,0x72,0x65,0x61,
	0x64,0x69,0x6E,0x4D,0x6F,0x64,0x65,0x6C,0x00,0x53,0x61,0x76,0x65,0x64,0x53,0x65,0x6C,0x66,0x52,0x65,
	0x67,0x56,0x49,0x50,0x72,0x6F,0x67,0x49,0x64,0x00,0x23,0x23,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x43,
	0x6C,0x61,0x73,0x73,0x65,0x73,0x49,0x6E,0x74,0x65,0x72,0x6E,0x61,0x6C,0x5F,0x44,0x65,0x78,0x00,0x43,
	0x4F,0x4D,0x52,0x65,0x67,0x2E,0x44,0x65,0x78,0x5F,0x43,0x6F,0x6C,0x33,0x31,0x00,0x43,0x4F,0x4D,0x52,
	0x65,0x67,0x2E,0x44,0x65,0x78,0x5F,0x43,0x6F,0x6C,0x33,0x33,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,
	0x52,0x6F,0x6C,0x65,0x44,0x65,0x66,0x00,0x41,0x70,0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x00,
	0x52,0x6F,0x6C,0x65,0x4E,0x61,0x6D,0x65,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4D,0x50,0x4B,0x5F,
	0x52,0x6F,0x6C,0x65,0x44,0x65,0x66,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x52,0x6F,0x6C,0x65,0x43,
	0x6F,0x6E,0x66,0x69,0x67,0x00,0x52,0x6F,0x6C,0x65,0x4D,0x65,0x6D,0x62,0x65,0x72,0x73,0x00,0x55,0x73,
	0x65,0x72,0x53,0x49,0x44,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4D,0x50,0x4B,0x5F,0x52,0x6F,0x6C,
	0x65,0x43,0x6F,0x6E,0x66,0x69,0x67,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x52,0x6F,0x6C,0x65,0x53,
	0x44,0x43,0x61,0x63,0x68,0x65,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4D,0x50,0x4B,0x5F,0x52,0x6F,
	0x6C,0x65,0x53,0x44,0x43,0x61,0x63,0x68,0x65,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x43,0x6C,0x61,
	0x73,0x73,0x49,0x74,0x66,0x4D,0x65,0x74,0x68,0x6F,0x64,0x00,0x43,0x6F,0x6E,0x66,0x69,0x67,0x43,0x6C,
	0x61,0x73,0x73,0x00,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x00,0x4D,0x65,0x74,0x68,0x6F,0x64,
	0x49,0x6E,0x64,0x65,0x78,0x00,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x44,0x65,0x63,0x72,0x69,0x70,
	0x74,0x6F,0x72,0x00,0x4D,0x65,0x74,0x68,0x6F,0x64,0x4E,0x61,0x6D,0x65,0x00,0x44,0x69,0x73,0x70,0x49,
	0x44,0x00,0x41,0x75,0x74,0x6F,0x43,0x6F,0x6D,0x70,0x6C,0x65,0x74,0x65,0x00,0x43,0x4F,0x4D,0x52,0x65,
	0x67,0x2E,0x4D,0x50,0x4B,0x5F,0x43,0x6C,0x61,0x73,0x73,0x49,0x74,0x66,0x4D,0x65,0x74,0x68,0x6F,0x64,
	0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x43,0x6C,0x61,0x73,0x73,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,
	0x63,0x65,0x44,0x69,0x73,0x70,0x49,0x44,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4D,0x50,0x4B,0x5F,
	0x43,0x6C,0x61,0x73,0x73,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x44,0x69,0x73,0x70,0x49,0x44,
	0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x43,0x6C,0x61,0x73,0x73,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,
	0x63,0x65,0x00,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x4E,0x61,0x6D,0x65,0x00,0x52,0x6F,0x6C,
	0x65,0x53,0x65,0x74,0x49,0x64,0x00,0x49,0x73,0x44,0x69,0x73,0x70,0x61,0x74,0x63,0x68,0x61,0x62,0x6C,
	0x65,0x00,0x49,0x73,0x51,0x75,0x65,0x75,0x65,0x61,0x62,0x6C,0x65,0x00,0x49,0x73,0x51,0x75,0x65,0x75,
	0x65,0x69,0x6E,0x67,0x53,0x75,0x70,0x70,0x6F,0x72,0x74,0x65,0x64,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,
	0x2E,0x4D,0x50,0x4B,0x5F,0x43,0x6C,0x61,0x73,0x73,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x00,
	0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x52,0x6F,0x6C,0x65,0x53,0x65,0x74,0x00,0x43,0x4F,0x4D,0x52,0x65,
	0x67,0x2E,0x4D,0x50,0x4B,0x5F,0x52,0x6F,0x6C,0x65,0x53,0x65,0x74,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,
	0x2E,0x53,0x74,0x61,0x72,0x74,0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x73,0x00,0x41,0x70,0x70,0x6C,0x4F,
	0x72,0x50,0x72,0x6F,0x63,0x65,0x73,0x73,0x49,0x64,0x00,0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x43,0x4C,
	0x53,0x49,0x44,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4D,0x50,0x4B,0x5F,0x53,0x74,0x61,0x72,0x74,
	0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x73,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x49,0x4D,0x44,0x42,
	0x44,0x61,0x74,0x61,0x53,0x6F,0x75,0x72,0x63,0x65,0x73,0x00,0x44,0x61,0x74,0x61,0x53,0x6F,0x75,0x72,
	0x63,0x65,0x00,0x4F,0x4C,0x45,0x44,0x42,0x50,0x72,0x6F,0x76,0x69,0x64,0x65,0x72,0x4E,0x61,0x6D,0x65,
	0x00,0x53,0x65,0x72,0x76,0x65,0x72,0x00,0x44,0x61,0x74,0x61,0x62,0x61,0x73,0x65,0x00,0x50,0x72,0x6F,
	0x76,0x69,0x64,0x65,0x72,0x53,0x70,0x65,0x63,0x69,0x66,0x69,0x63,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,
	0x79,0x00,0x23,0x23,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x49,0x4D,0x44,0x42,0x44,0x61,0x74,0x61,0x53,
	0x6F,0x75,0x72,0x63,0x65,0x73,0x5F,0x44,0x65,0x78,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x49,0x4D,
	0x44,0x42,0x00,0x54,0x61,0x62,0x6C,0x65,0x4E,0x61,0x6D,0x65,0x00,0x42,0x4C,0x4F,0x42,0x6F,0x6E,0x4C,
	0x6F,0x61,0x64,0x00,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x4D,0x50,0x4B,0x5F,0x49,0x4D,0x44,0x42,0x00,
	0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x53,0x65,0x72,0x76,0x65,0x72,0x47,0x72,0x6F,0x75,0x70,0x00,0x23,
	0x23,0x43,0x4F,0x4D,0x52,0x65,0x67,0x2E,0x53,0x65,0x72,0x76,0x65,0x72,0x47,0x72,0x6F,0x75,0x70,0x5F,
	0x44,0x65,0x78,0x00,
};
extern const DECLSPEC_SELECTANY BYTE * g_pbCOMRegSchemaStringHeap = g_rgCOMRegSchemaStringHeap;
extern const DECLSPEC_SELECTANY int g_cbCOMRegSchemaStringHeap = 2444;
extern const BYTE DECLSPEC_SELECTANY g_rgCOMRegSchemaDataRO[] = 
{
	0x10,0x00,0x00,0x00,0x18,0x0C,0x00,0x00,0x48,0x00,0x00,0x00,0x9C,0x02,0x00,0x00,0xD0,0x02,0x00,0x00,
	0x44,0x03,0x00,0x00,0x78,0x04,0x00,0x00,0x5C,0x07,0x00,0x00,0xB0,0x07,0x00,0x00,0x14,0x08,0x00,0x00,
	0x68,0x08,0x00,0x00,0x3C,0x09,0x00,0x00,0xB0,0x09,0x00,0x00,0x74,0x0A,0x00,0x00,0xC8,0x0A,0x00,0x00,
	0x1C,0x0B,0x00,0x00,0x90,0x0B,0x00,0x00,0xE4,0x0B,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x28,
	0x23,0x10,0x00,0x54,0x00,0x00,0xFF,0xFF,0x90,0x00,0x54,0x02,0x14,0x00,0x00,0x00,0x01,0x04,0x48,0x00,
	0x40,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1B,0x00,0x00,0x00,0x02,0x01,0x82,0x00,0x44,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x24,0x00,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x2A,0x00,0x00,0x00,0x04,0x01,0x82,0x00,0x48,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x35,0x00,0x00,0x00,
	0x05,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x41,0x00,0x00,0x00,0x06,0x01,0x82,0x00,
	0x4C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x4D,0x00,0x00,0x00,0x07,0x01,0x82,0x00,0x50,0x00,0x04,0x00,
	0xFF,0x00,0xFF,0x43,0x59,0x00,0x00,0x00,0x08,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x67,0x00,0x00,0x00,0x09,0x01,0x82,0x00,0x54,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x71,0x00,0x00,0x00,
	0x0A,0x01,0x80,0x00,0x58,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x82,0x00,0x00,0x00,0x0B,0x01,0x82,0x00,
	0x5C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x8E,0x00,0x00,0x00,0x0C,0x01,0x82,0x00,0x60,0x00,0x04,0x00,
	0x01,0x00,0xFF,0x43,0x97,0x00,0x00,0x00,0x0D,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xA6,0x00,0x00,0x00,0x0E,0x00,0x13,0x00,0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xB4,0x00,0x00,0x00,
	0x0F,0x01,0x82,0x00,0x64,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0xBF,0x00,0x00,0x00,0x10,0x01,0x82,0x00,
	0x68,0x00,0x04,0x00,0x50,0x00,0xFF,0x43,0xC9,0x00,0x00,0x00,0x11,0x01,0x82,0x00,0x6C,0x00,0x04,0x00,
	0x14,0x00,0xFF,0x43,0xD4,0x00,0x00,0x00,0x12,0x00,0x82,0x00,0x70,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,
	0xDF,0x00,0x00,0x00,0x13,0x00,0x82,0x00,0x74,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0xEA,0x00,0x00,0x00,
	0x14,0x01,0x82,0x00,0x78,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0xF4,0x00,0x00,0x00,0x15,0x01,0x80,0x00,
	0x7C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFE,0x00,0x00,0x00,0x16,0x00,0x13,0x00,0x14,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x19,0x01,0x00,0x00,0x17,0x00,0x13,0x00,0x18,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x32,0x01,0x00,0x00,0x18,0x01,0x80,0x00,0x80,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x45,0x01,0x00,0x00,
	0x19,0x00,0x13,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x58,0x01,0x00,0x00,0x1A,0x00,0x13,0x00,
	0x20,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x71,0x01,0x00,0x00,0x1B,0x00,0x13,0x00,0x24,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x7C,0x01,0x00,0x00,0x1C,0x00,0x13,0x00,0x28,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x8E,0x01,0x00,0x00,0x1D,0x00,0x13,0x00,0x2C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x97,0x01,0x00,0x00,
	0x1E,0x01,0x82,0x00,0x84,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0xA9,0x01,0x00,0x00,0x1F,0x00,0x13,0x00,
	0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xB7,0x01,0x00,0x00,0x20,0x00,0x13,0x00,0x34,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xC4,0x01,0x00,0x00,0x21,0x00,0x13,0x00,0x38,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xCE,0x01,0x00,0x00,0x22,0x00,0x13,0x00,0x3C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xD9,0x01,0x00,0x00,
	0x23,0x01,0x82,0x00,0x88,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xE4,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x8C,0x00,0x01,0x01,0x00,0x58,0xFD,0x01,0x00,0x00,0x01,0x00,0x01,0x28,0x01,0x00,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x08,0x00,0x34,0x00,0x11,0x02,0x00,0x00,0x01,0x04,0x82,0x00,0x00,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x16,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x04,0x00,0x01,0x01,0x00,0x58,
	0x30,0x02,0x00,0x00,0x02,0x00,0x02,0x20,0x04,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x18,0x00,0x74,0x00,
	0x47,0x02,0x00,0x00,0x01,0x82,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x51,0x02,0x00,0x00,
	0x02,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x57,0x02,0x00,0x00,0x03,0x82,0x13,0x00,
	0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x5D,0x02,0x00,0x00,0x04,0x00,0x48,0x00,0x0C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x6C,0x02,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x10,0x00,0x03,0x01,0x02,0x03,
	0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x01,0x00,0x58,0x97,0x02,0x00,0x00,
	0x03,0x00,0x01,0x28,0x11,0x09,0x00,0x54,0x00,0x00,0xFF,0xFF,0x48,0x00,0x34,0x01,0x11,0x02,0x00,0x00,
	0x01,0x04,0x82,0x00,0x18,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x82,0x00,0x00,0x00,0x02,0x01,0x82,0x00,
	0x1C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xAC,0x02,0x00,0x00,0x03,0x00,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xBF,0x02,0x00,0x00,0x04,0x01,0x82,0x00,0x20,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xD2,0x02,0x00,0x00,0x05,0x00,0x82,0x00,0x24,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xE9,0x02,0x00,0x00,
	0x06,0x01,0x82,0x00,0x28,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xFA,0x02,0x00,0x00,0x07,0x01,0x82,0x00,
	0x2C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x0B,0x03,0x00,0x00,0x08,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x1A,0x03,0x00,0x00,0x09,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x31,0x03,0x00,0x00,0x0A,0x01,0x82,0x00,0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x4B,0x03,0x00,0x00,
	0x0B,0x01,0x82,0x00,0x34,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x54,0x03,0x00,0x00,0x0C,0x01,0x82,0x00,
	0x38,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x5F,0x03,0x00,0x00,0x0D,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x7A,0x03,0x00,0x00,0x0E,0x00,0x13,0x00,0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x94,0x03,0x00,0x00,0x0F,0x01,0x82,0x00,0x3C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xAB,0x03,0x00,0x00,
	0x10,0x00,0x13,0x00,0x14,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xBB,0x03,0x00,0x00,0x11,0x01,0x82,0x00,
	0x40,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC7,0x03,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x44,0x00,
	0x01,0x01,0x00,0x58,0xE2,0x03,0x00,0x00,0x04,0x00,0x03,0x28,0x2A,0x10,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0xB4,0x00,0xE4,0x02,0xF9,0x03,0x00,0x00,0x01,0x04,0x48,0x00,0x64,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x14,0x00,0x00,0x00,0x02,0x01,0x48,0x00,0x68,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFF,0x03,0x00,0x00,
	0x03,0x01,0x48,0x00,0x6C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x09,0x04,0x00,0x00,0x04,0x00,0x13,0x00,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x16,0x04,0x00,0x00,0x05,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x23,0x04,0x00,0x00,0x06,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x30,0x04,0x00,0x00,0x07,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x40,0x04,0x00,0x00,
	0x08,0x00,0x13,0x00,0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x47,0x04,0x00,0x00,0x09,0x00,0x13,0x00,
	0x14,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x50,0x04,0x00,0x00,0x0A,0x00,0x13,0x00,0x18,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x5C,0x04,0x00,0x00,0x0B,0x00,0x13,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x6B,0x04,0x00,0x00,0x0C,0x00,0x13,0x00,0x20,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x78,0x04,0x00,0x00,
	0x0D,0x00,0x13,0x00,0x24,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x86,0x04,0x00,0x00,0x0E,0x00,0x13,0x00,
	0x28,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x96,0x04,0x00,0x00,0x0F,0x00,0x13,0x00,0x2C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x19,0x01,0x00,0x00,0x10,0x00,0x13,0x00,0x30,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x32,0x01,0x00,0x00,0x11,0x01,0x80,0x00,0x70,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xA4,0x04,0x00,0x00,
	0x12,0x01,0x48,0x00,0x74,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xAE,0x04,0x00,0x00,0x13,0x00,0x13,0x00,
	0x34,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xBA,0x04,0x00,0x00,0x14,0x00,0x13,0x00,0x38,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xC6,0x04,0x00,0x00,0x15,0x00,0x13,0x00,0x3C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xD6,0x04,0x00,0x00,0x16,0x01,0x82,0x00,0x78,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xE6,0x04,0x00,0x00,
	0x17,0x00,0x13,0x00,0x40,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xF1,0x04,0x00,0x00,0x18,0x01,0x48,0x00,
	0x7C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x02,0x05,0x00,0x00,0x19,0x00,0x13,0x00,0x44,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x1A,0x05,0x00,0x00,0x1A,0x01,0x82,0x00,0x80,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x26,0x05,0x00,0x00,0x1B,0x01,0x48,0x00,0x84,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x35,0x05,0x00,0x00,
	0x1C,0x01,0x82,0x00,0x88,0x00,0x04,0x00,0xF4,0x01,0xFF,0x43,0x44,0x05,0x00,0x00,0x1D,0x00,0x13,0x00,
	0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x57,0x05,0x00,0x00,0x1E,0x01,0x82,0x00,0x8C,0x00,0x04,0x00,
	0x00,0x02,0xFF,0x43,0x6B,0x05,0x00,0x00,0x1F,0x00,0x13,0x00,0x4C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x80,0x05,0x00,0x00,0x20,0x03,0x82,0x00,0x90,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x8E,0x05,0x00,0x00,
	0x21,0x01,0x82,0x00,0x94,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xA1,0x05,0x00,0x00,0x22,0x03,0x82,0x00,
	0x98,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xB1,0x05,0x00,0x00,0x23,0x00,0x13,0x00,0x50,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xC2,0x05,0x00,0x00,0x24,0x00,0x13,0x00,0x54,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xCE,0x05,0x00,0x00,0x25,0x01,0x82,0x00,0x9C,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0xDA,0x05,0x00,0x00,
	0x26,0x01,0x48,0x00,0xA0,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xE9,0x05,0x00,0x00,0x27,0x00,0x13,0x00,
	0x58,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x00,0x06,0x00,0x00,0x28,0x00,0x13,0x00,0x5C,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x0E,0x06,0x00,0x00,0x29,0x00,0x13,0x00,0x60,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x21,0x06,0x00,0x00,0x2A,0x01,0x82,0x00,0xA4,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x36,0x06,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0xA8,0x00,0x01,0x01,0x00,0x58,0x53,0x06,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0xAC,0x00,0x01,0x20,0x00,0x58,0x64,0x06,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0xB0,0x00,
	0x01,0x22,0x00,0x58,0x75,0x06,0x00,0x00,0x05,0x00,0x01,0x20,0x03,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x10,0x00,0x54,0x00,0x84,0x06,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x90,0x06,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x82,0x00,0x00,0x00,
	0x03,0x01,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x99,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0xAC,0x06,0x00,0x00,0x06,0x00,0x01,0x20,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x84,0x06,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x90,0x06,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xBE,0x06,0x00,0x00,0x03,0x82,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xCA,0x06,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0x2B,0x00,0xFF,0x43,0xD2,0x06,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x10,0x00,0x03,0x01,0x02,0x03,0xE8,0x06,0x00,0x00,0x07,0x00,0x01,0x20,0x03,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0x84,0x06,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x90,0x06,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x32,0x01,0x00,0x00,0x03,0x01,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFB,0x06,0x00,0x00,
	0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0x12,0x07,0x00,0x00,0x08,0x00,0x02,0x20,
	0x0A,0x05,0x01,0x54,0x00,0x00,0x28,0x00,0x34,0x00,0xD4,0x00,0x28,0x07,0x00,0x00,0x01,0x82,0x48,0x00,
	0x10,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x34,0x07,0x00,0x00,0x02,0x82,0x48,0x00,0x14,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x3E,0x07,0x00,0x00,0x03,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x4A,0x07,0x00,0x00,0x04,0x01,0x80,0x00,0x18,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xA4,0x04,0x00,0x00,
	0x05,0x01,0x48,0x00,0x1C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x5C,0x07,0x00,0x00,0x06,0x01,0x82,0x00,
	0x20,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x67,0x07,0x00,0x00,0x07,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x24,0x00,0x00,0x00,0x08,0x01,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x00,0x43,
	0x6E,0x07,0x00,0x00,0x09,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x82,0x00,0x00,0x00,
	0x0A,0x01,0x82,0x00,0x24,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x7B,0x07,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x2C,0x00,0x03,0x01,0x02,0x03,0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x30,0x00,
	0x01,0x01,0x00,0x58,0x95,0x07,0x00,0x00,0x09,0x00,0x02,0x20,0x04,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x18,0x00,0x74,0x00,0x28,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x34,0x07,0x00,0x00,0x02,0x82,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x67,0x07,0x00,0x00,
	0x03,0x82,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x4A,0x07,0x00,0x00,0x04,0x01,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xB1,0x07,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x10,0x00,
	0x03,0x01,0x02,0x03,0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x01,0x00,0x58,
	0xD1,0x07,0x00,0x00,0x0A,0x00,0x02,0x20,0x09,0x04,0x00,0x54,0x00,0x00,0xFF,0xFF,0x2C,0x00,0xC4,0x00,
	0x28,0x07,0x00,0x00,0x01,0x82,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x34,0x07,0x00,0x00,
	0x02,0x82,0x48,0x00,0x10,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xE7,0x07,0x00,0x00,0x03,0x01,0x82,0x00,
	0x14,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x4A,0x07,0x00,0x00,0x04,0x01,0x80,0x00,0x18,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xF5,0x07,0x00,0x00,0x05,0x01,0x48,0x00,0x1C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xFF,0x07,0x00,0x00,0x06,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0E,0x08,0x00,0x00,
	0x07,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1A,0x08,0x00,0x00,0x08,0x00,0x13,0x00,
	0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x82,0x00,0x00,0x00,0x09,0x01,0x82,0x00,0x20,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x2E,0x08,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x24,0x00,0x02,0x01,0x02,0x58,
	0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x28,0x00,0x01,0x01,0x00,0x58,0x48,0x08,0x00,0x00,
	0x0B,0x00,0x01,0x20,0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0xA4,0x04,0x00,0x00,
	0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x90,0x06,0x00,0x00,0x02,0x82,0x82,0x00,
	0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,0x84,0x06,0x00,0x00,0x03,0x00,0x48,0x00,0x08,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x57,0x08,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,
	0x6A,0x08,0x00,0x00,0x0C,0x00,0x02,0x20,0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,
	0x7F,0x08,0x00,0x00,0x01,0x82,0x48,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x8F,0x08,0x00,0x00,
	0x02,0x82,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9C,0x08,0x00,0x00,0x0E,0x10,0x01,0x01,
	0x11,0x05,0x08,0x00,0x02,0x01,0x02,0x58,0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x0C,0x00,
	0x01,0x01,0x00,0x58,0xB5,0x08,0x00,0x00,0x0D,0x00,0x01,0x28,0x05,0x04,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x18,0x00,0x74,0x00,0xCC,0x08,0x00,0x00,0x01,0x04,0x82,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,
	0xD7,0x08,0x00,0x00,0x02,0x01,0x82,0x00,0x04,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0xE9,0x08,0x00,0x00,
	0x03,0x01,0x82,0x00,0x08,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0xF0,0x08,0x00,0x00,0x04,0x01,0x82,0x00,
	0x0C,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0xF9,0x08,0x00,0x00,0x05,0x01,0x82,0x00,0x10,0x00,0x04,0x00,
	0x02,0x02,0xFF,0x43,0x12,0x09,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x14,0x00,0x01,0x01,0x00,0x58,
	0x2F,0x09,0x00,0x00,0x0E,0x00,0x01,0x20,0x03,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,
	0x3B,0x09,0x00,0x00,0x01,0x82,0x82,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0xCC,0x08,0x00,0x00,
	0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x82,0x00,0xFF,0x43,0x45,0x09,0x00,0x00,0x03,0x01,0x82,0x00,
	0x08,0x00,0x04,0x00,0x01,0x00,0xFF,0x43,0x50,0x09,0x00,0x00,0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,
	0x02,0x01,0x02,0x58,0x60,0x09,0x00,0x00,0x0F,0x00,0x01,0x28,0x01,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x08,0x00,0x34,0x00,0x2A,0x00,0x00,0x00,0x01,0x04,0x82,0x00,0x00,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x73,0x09,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x04,0x00,0x01,0x01,0x00,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbCOMRegSchemaRO = 3096;
extern const COMPLIBSCHEMABLOB DECLSPEC_SELECTANY COMRegSchemaBlob = 
{
	&COMRegSchema,
	COMReg_TABLE_COUNT,
	0,
	g