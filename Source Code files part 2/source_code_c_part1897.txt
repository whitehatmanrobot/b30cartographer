   if (Trim == 0) {
                    Trim = VmSupport->WorkingSetSize - VmSupport->MinimumWorkingSetSize;
                }
            }
            Criteria->TrimAge = MI_PASS4_TRIM_AGE;
            Criteria->DoAging = TRUE;
        }

        break;
    }

    if (Trim > MaxTrim) {
        Trim = MaxTrim;
    }

#if DBG
    if ((MmDebug & MM_DBG_WS_EXPANSION) && (Trim != 0)) {
        if (VmSupport->Flags.SessionSpace == 0) {
            ProcessToTrim = CONTAINING_RECORD (VmSupport, EPROCESS, Vm);
            DbgPrintEx (DPFLTR_MM_ID, DPFLTR_TRACE_LEVEL, 
                "           Trimming        Process %16s, WS %6d, Trimming %5d ==> %5d\n",
                ProcessToTrim ? ProcessToTrim->ImageFileName : (PUCHAR)"System Cache",
                VmSupport->WorkingSetSize,
                Trim,
                VmSupport->WorkingSetSize-Trim);
        }
        else {
            SessionSpace = CONTAINING_RECORD (VmSupport,
                                              MM_SESSION_SPACE,
                                              Vm);
            DbgPrintEx (DPFLTR_MM_ID, DPFLTR_TRACE_LEVEL, 
                "           Trimming        Session 0x%x (id %d), WS %6d, Trimming %5d ==> %5d\n",
                SessionSpace,
                SessionSpace->SessionId,
                VmSupport->WorkingSetSize,
                Trim,
                VmSupport->WorkingSetSize-Trim);
        }
    }
#endif

    return Trim;
}

VOID
MiCaptureAndResetWorkingSetAccessBits (
    IN PMMSUPPORT WsInfo,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine is called to reset the accessed bits on all the
    working set entries in the specified working set.

Arguments:

    WsInfo - Supplies the working set to clear the access bits in.

    Flags - Supplies flags to determine whether the access bits need clearing.

Return Value:

    None.

Environment:

    Kernel mode.  The working set pushlock is held exclusive.

--*/

{
    BOOLEAN AllProcessors;
    PMMWSL WorkingSetList;
    PMMWSLE Wsle;
    PMMWSLE LastWsle;
    PMMPTE PointerPte;
    ULONG FlushCount;
    PVOID VaFlushList[MM_MAXIMUM_FLUSH_COUNT];

    FlushCount = 0;

    WorkingSetList = WsInfo->VmWorkingSetList;
    Wsle = WorkingSetList->Wsle;
    LastWsle = Wsle + WorkingSetList->LastEntry;

    while (Wsle <= LastWsle) {

        if (Wsle->u1.e1.Valid) {
            
            PointerPte = MiGetPteAddress (Wsle->u1.VirtualAddress);

            if (MI_GET_ACCESSED_IN_PTE (PointerPte) == 1) {

                //
                // Log the VA since the accessed bit is set.
                //

                MI_PTE_LOG_ACCESS (PointerPte);

                if (Flags & MI_CAPTURE_AND_RESET_ALL_ACCESS_BITS) {

                    //
                    // Clear the accessed bit and the WSLE age so that new
                    // references can be easily tracked.
                    //
    
                    MI_SET_ACCESSED_IN_PTE (PointerPte, 0);
                    MI_RESET_WSLE_AGE (PointerPte, Wsle);
    
                    if (FlushCount < MM_MAXIMUM_FLUSH_COUNT) {
                        VaFlushList[FlushCount] = Wsle->u1.VirtualAddress;
                        FlushCount += 1;
                    }
                }
            }
        }

        Wsle += 1;
    }

    if (FlushCount != 0) {

        if (WorkingSetList->Wsle == MmWsle) {
            AllProcessors = FALSE;
        }
        else {

            //
            // Must be session space or the system cache, flush all processors.
            //

            AllProcessors = TRUE;
        }

        if (FlushCount == 1) {
            MI_FLUSH_SINGLE_TB (VaFlushList[0], AllProcessors);
        }
        else if (FlushCount < MM_MAXIMUM_FLUSH_COUNT) {
            MI_FLUSH_MULTIPLE_TB (FlushCount, &VaFlushList[0], AllProcessors);
        }
        else {
            if (AllProcessors == TRUE) {
                MI_FLUSH_ENTIRE_TB (0x18);
            }
            else {
                MI_FLUSH_PROCESS_TB (FALSE);
            }
        }
    }

    return;
}


VOID
MiAgeWorkingSet (
    IN PMMSUPPORT VmSupport,
    IN LOGICAL DoAging,
    IN PWSLE_NUMBER WslesScanned,
    IN OUT PPFN_NUMBER TotalClaim,
    IN OUT PPFN_NUMBER TotalEstimatedAvailable
    )

/*++

Routine Description:

    Age pages (clear the access bit or if the page hasn't been
    accessed, increment the age) for a portion of the working
    set.  Also, walk through a sample of the working set
    building a set of counts of how old the pages are.

    The counts are used to create a claim of the amount
    the system can steal from this process if memory
    becomes tight.

Arguments:

    VmSupport - Supplies the VM support structure to age and estimate.

    DoAging - TRUE if pages are to be aged.  Regardless, the pages will be
              added to the availability estimation.

    WslesScanned - Total numbers of WSLEs scanned on this sweep, used as a
                   control to prevent excessive aging on large systems with
                   many processes.

    TotalClaim - Supplies a pointer to system wide claim to update.

    TotalEstimatedAvailable - Supplies a pointer to system wide estimate
                              to update.

Return Value:

    None

Environment:

    Kernel mode, APCs disabled, working set mutex.  PFN lock NOT held.

--*/

{
    LOGICAL RecalculateShift;
    WSLE_NUMBER LastEntry;
    WSLE_NUMBER StartEntry;
    WSLE_NUMBER FirstDynamic;
    WSLE_NUMBER CurrentEntry;
    PMMWSL WorkingSetList;
    PMMWSLE Wsle;
    PMMPTE PointerPte;
    WSLE_NUMBER NumberToExamine;
    WSLE_NUMBER Claim;
    ULONG Estimate;
    ULONG SampledAgeCounts[MI_USE_AGE_COUNT] = {0};
    MI_NEXT_ESTIMATION_SLOT_CONST NextConst;
    WSLE_NUMBER SampleSize;
    WSLE_NUMBER AgeSize;
    ULONG CounterShift;
    WSLE_NUMBER Temp;
    ULONG i;

    WorkingSetList = VmSupport->VmWorkingSetList;
    Wsle = WorkingSetList->Wsle;
    AgeSize = 0;

    LastEntry = WorkingSetList->LastEntry;
    FirstDynamic = WorkingSetList->FirstDynamic;

    if (DoAging == TRUE) {

        //
        // Clear the used bits or increment the age of a portion of the
        // working set.
        //
        // Try to walk the entire working set every 2^MI_AGE_AGING_SHIFT
        // seconds.
        //

        if (VmSupport->WorkingSetSize > WorkingSetList->FirstDynamic) {
            NumberToExamine = (VmSupport->WorkingSetSize - WorkingSetList->FirstDynamic) >> MiAgingShift;

            //
            // Bigger machines can easily have working sets that span
            // terabytes so limit the absolute walk.
            //

            if (NumberToExamine > MI_MAXIMUM_SAMPLE) {
                NumberToExamine = MI_MAXIMUM_SAMPLE;
            }

            //
            // In addition to large working sets, bigger machines may also
            // have huge numbers of processes - checking the aggregate number
            // of working set list entries scanned prevents this situation
            // from triggering excessive scanning.
            //

            if ((WslesScanned != NULL) &&
                (*WslesScanned >= MiMaximumWslesPerSweep)) {

                NumberToExamine = 64;
            }

            AgeSize = NumberToExamine;
            CurrentEntry = VmSupport->NextAgingSlot;

            if (CurrentEntry > LastEntry || CurrentEntry < FirstDynamic) {
                CurrentEntry = FirstDynamic;
            }

            if (Wsle[CurrentEntry].u1.e1.Valid == 0) {
                MI_NEXT_VALID_AGING_SLOT(CurrentEntry, FirstDynamic, LastEntry, Wsle);
            }

            while (NumberToExamine != 0) {

                PointerPte = MiGetPteAddress (Wsle[CurrentEntry].u1.VirtualAddress);

                if (MI_GET_ACCESSED_IN_PTE(PointerPte) == 1) {
                    MI_PTE_LOG_ACCESS (PointerPte);
                    MI_SET_ACCESSED_IN_PTE(PointerPte, 0);
                    MI_RESET_WSLE_AGE(PointerPte, &Wsle[CurrentEntry]);
                }
                else {
                    MI_INC_WSLE_AGE(PointerPte, &Wsle[CurrentEntry]);
                }

                NumberToExamine -= 1;
                MI_NEXT_VALID_AGING_SLOT(CurrentEntry, FirstDynamic, LastEntry, Wsle);
            }

            VmSupport->NextAgingSlot = CurrentEntry + 1; // Start here next time
        }
    }

    //
    // Estimate the number of unused pages in the working set.
    //
    // The working set may have shrunk or the non-paged portion may have
    // grown since the last time.  Put the next counter at the FirstDynamic
    // if so.
    //

    CurrentEntry = VmSupport->NextEstimationSlot;

    if (CurrentEntry > LastEntry || CurrentEntry < FirstDynamic) {
        CurrentEntry = FirstDynamic;
    }

    //
    // When aging, walk the entire working set every 2^MiEstimationShift
    // seconds.
    //

    CounterShift = 0;
    SampleSize = 0;

    if (VmSupport->WorkingSetSize > WorkingSetList->FirstDynamic) {

        RecalculateShift = FALSE;
        SampleSize = VmSupport->WorkingSetSize - WorkingSetList->FirstDynamic;
        NumberToExamine = SampleSize >> MiEstimationShift;

        //
        // Bigger machines may have huge numbers of processes - checking the
        // aggregate number of working set list entries scanned prevents this
        // situation from triggering excessive scanning.
        //

        if ((WslesScanned != NULL) &&
            (*WslesScanned >= MiMaximumWslesPerSweep)) {
            RecalculateShift = TRUE;
        }
        else if (NumberToExamine > MI_MAXIMUM_SAMPLE) {

            //
            // Bigger machines can easily have working sets that span
            // terabytes so limit the absolute walk.
            //

            NumberToExamine = MI_MAXIMUM_SAMPLE;

            Temp = SampleSize >> MI_MINIMUM_SAMPLE_SHIFT;

            SampleSize = MI_MAXIMUM_SAMPLE;

            //
            // Calculate the necessary counter shift to estimate pages
            // in use.
            //

            for ( ; Temp != 0; Temp = Temp >> 1) {
                CounterShift += 1;
            }
        }
        else if (NumberToExamine >= MI_MINIMUM_SAMPLE) {

            //
            // Ensure that NumberToExamine is at least the minimum size.
            //

            SampleSize = NumberToExamine;
            CounterShift = MiEstimationShift;
        }
        else if (SampleSize > MI_MINIMUM_SAMPLE) {
            RecalculateShift = TRUE;
        }

        if (RecalculateShift == TRUE) {
            Temp = SampleSize >> MI_MINIMUM_SAMPLE_SHIFT;
            SampleSize = MI_MINIMUM_SAMPLE;

            //
            // Calculate the necessary counter shift to estimate pages
            // in use.
            //

            for ( ; Temp != 0; Temp = Temp >> 1) {
                CounterShift += 1;
            }
        }

        ASSERT (SampleSize != 0);

        MI_CALC_NEXT_ESTIMATION_SLOT_CONST(NextConst, WorkingSetList);

        StartEntry = FirstDynamic;

        if (Wsle[CurrentEntry].u1.e1.Valid == 0) {

            MI_NEXT_VALID_ESTIMATION_SLOT (CurrentEntry,
                                           StartEntry,
                                           FirstDynamic,
                                           LastEntry,
                                           NextConst,
                                           Wsle);
        }

        for (i = 0; i < SampleSize; i += 1) {

            PointerPte = MiGetPteAddress (Wsle[CurrentEntry].u1.VirtualAddress);

            if (MI_GET_ACCESSED_IN_PTE(PointerPte) == 0) {
                MI_UPDATE_USE_ESTIMATE (PointerPte,
                                        &Wsle[CurrentEntry],
                                        SampledAgeCounts);
            }

            if (i == NumberToExamine - 1) {

                //
                // Start estimation here next time.
                //

                VmSupport->NextEstimationSlot = CurrentEntry + 1;
            }

            MI_NEXT_VALID_ESTIMATION_SLOT (CurrentEntry,
                                           StartEntry,
                                           FirstDynamic,
                                           LastEntry,
                                           NextConst,
                                           Wsle);
        }
    }

    if (SampleSize < AgeSize) {
        SampleSize = AgeSize;
    }

    if (WslesScanned != NULL) {
        *WslesScanned += SampleSize;
    }

    Estimate = MI_CALCULATE_USAGE_ESTIMATE(SampledAgeCounts, CounterShift);

    Claim = VmSupport->Claim + MI_CLAIM_INCR;

    if (Claim > Estimate) {
        Claim = Estimate;
    }

    VmSupport->Claim = Claim;
    VmSupport->EstimatedAvailable = Estimate;

    VmSupport->GrowthSinceLastEstimate = 0;
    *TotalClaim += Claim >> ((VmSupport->Flags.MemoryPriority == MEMORY_PRIORITY_FOREGROUND)
                                ? MI_FOREGROUND_CLAIM_AVAILABLE_SHIFT
                                : MI_BACKGROUND_CLAIM_AVAILABLE_SHIFT);

    *TotalEstimatedAvailable += Estimate;
    return;
}

ULONG MiClaimAdjustmentThreshold[8] = { 0, 0, 4000, 8000, 12000, 24000, 32000, 32000};

VOID
MiAdjustClaimParameters (
    IN LOGICAL EnoughPages
    )

/*++

Routine Description:

    Adjust the rate at which we walk through working sets.  If we have
    enough pages (we aren't trimming pages that aren't considered young),
    then we check to see whether we should decrease the aging rate and
    vice versa.

    The limits for the aging rate are 1/8 and 1/128 of the working sets.
    This means that the finest age granularities are 8 to 128 seconds in
    these cases.  With the current 2 bit counter, at the low end we would
    start trimming pages > 16 seconds old and at the high end > 4 minutes.

Arguments:

    EnoughPages - Supplies whether to increase the rate or decrease it.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    LARGE_INTEGER CurrentTime;

    KeQuerySystemTime (&CurrentTime);

    if (EnoughPages == TRUE &&
        ((MmTotalClaim + MmAvailablePages) > MiClaimAdjustmentThreshold[MiAgingShift])) {

        //
        // Don't adjust the rate too frequently, don't go over the limit, and
        // make sure there are enough claimed and/or available.
        //

        if (((CurrentTime.QuadPart - MiLastAdjustmentOfClaimParams.QuadPart) >
                MmClaimParameterAdjustUpTime.QuadPart) &&
            (MiAgingShift < MI_MAXIMUM_AGING_SHIFT ) ) {

            //
            // Set the time only when we change the rate.
            //

            MiLastAdjustmentOfClaimParams.QuadPart = CurrentTime.QuadPart;

            MiAgingShift += 1;
            MiEstimationShift += 1;
        }
    }
    else if ((EnoughPages == FALSE) ||
             (MmTotalClaim + MmAvailablePages) < MiClaimAdjustmentThreshold[MiAgingShift - 1]) {

        //
        // Don't adjust the rate down too frequently.
        //

        if ((CurrentTime.QuadPart - MiLastAdjustmentOfClaimParams.QuadPart) >
                MmClaimParameterAdjustDownTime.QuadPart) {

            //
            // Always set the time so we don't adjust up too soon after
            // a 2nd pass trim.
            //

            MiLastAdjustmentOfClaimParams.QuadPart = CurrentTime.QuadPart;

            //
            // Don't go under the limit.
            //

            if (MiAgingShift > 3) {
                MiAgingShift -= 1;
                MiEstimationShift -= 1;
            }
        }
    }
}

#define MM_WS_REORG_BUCKETS_MAX 7

#if DBG
ULONG MiSessionIdleBuckets[MM_WS_REORG_BUCKETS_MAX];
#endif

VOID
MiRearrangeWorkingSetExpansionList (
    VOID
    )

/*++

Routine Description:

    This function arranges the working set list into different
    groups based upon the claim.  This is done so the working set
    trimming will take place on fat processes first.

    The working sets are sorted into buckets and then linked back up.

    Swapped out sessions and processes are put at the front.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode, no locks held.

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY ListEntry;
    PMMSUPPORT VmSupport;
    int Size;
    int PreviousNonEmpty;
    int NonEmpty;
    LIST_ENTRY ListHead[MM_WS_REORG_BUCKETS_MAX];
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER SessionIdleTime;
    ULONG IdleTime;
    PMM_SESSION_SPACE SessionGlobal;

    KeQuerySystemTime (&CurrentTime);

    if (IsListEmpty (&MmWorkingSetExpansionHead.ListHead)) {
        return;
    }

    for (Size = 0 ; Size < MM_WS_REORG_BUCKETS_MAX; Size++) {
        InitializeListHead (&ListHead[Size]);
    }

    LOCK_EXPANSION (OldIrql);

    while (!IsListEmpty (&MmWorkingSetExpansionHead.ListHead)) {
        ListEntry = RemoveHeadList (&MmWorkingSetExpansionHead.ListHead);

        VmSupport = CONTAINING_RECORD(ListEntry,
                                          MMSUPPORT,
                                          WorkingSetExpansionLinks);

        IdleTime = 0;

        if (VmSupport->Flags.SessionSpace == 1) {

            SessionGlobal = CONTAINING_RECORD (VmSupport,
                                               MM_SESSION_SPACE,
                                               Vm);

            if (SessionGlobal->ResidentProcessCount == 0) {

                SessionIdleTime.QuadPart = CurrentTime.QuadPart - SessionGlobal->LastProcessSwappedOutTime.QuadPart;

#if DBG
                if (MmDebug & MM_DBG_SESSIONS) {
                    DbgPrintEx (DPFLTR_MM_ID, DPFLTR_TRACE_LEVEL, 
                        "Mm: Session %d heavily trim/aged - all its processes (%d) swapped out %d seconds ago\n",
                        SessionGlobal->SessionId,
                        SessionGlobal->ReferenceCount,
                        (ULONG)(SessionIdleTime.QuadPart / 10000000));
                }
#endif

                if (SessionIdleTime.QuadPart < 0) {

                    //
                    // The administrator has moved the system time backwards.
                    // Give this session a fresh start.
                    //

                    SessionIdleTime.QuadPart = 0;
                    KeQuerySystemTime (&SessionGlobal->LastProcessSwappedOutTime);
                }

                IdleTime = (ULONG) (SessionIdleTime.QuadPart / 10000000);
            }
        }

        if (VmSupport->Flags.MemoryPriority == MEMORY_PRIORITY_FOREGROUND) {

            //
            // Put the foreground processes at the end of the list,
            // to give them priority.
            //

            Size = 6;
        }
        else {

            if (VmSupport->Claim > 400) {
                Size = 0;
            }
            else if (IdleTime > 30) {
                Size = 0;
#if DBG
                MiSessionIdleBuckets[Size] += 1;
#endif
            }
            else if (VmSupport->Claim > 200) {
                Size = 1;
            }
            else if (IdleTime > 20) {
                Size = 1;
#if DBG
                MiSessionIdleBuckets[Size] += 1;
#endif
            }
            else if (VmSupport->Claim > 100) {
                Size = 2;
            }
            else if (IdleTime > 10) {
                Size = 2;
#if DBG
                MiSessionIdleBuckets[Size] += 1;
#endif
            }
            else if (VmSupport->Claim > 50) {
                Size = 3;
            }
            else if (IdleTime) {
                Size = 3;
#if DBG
                MiSessionIdleBuckets[Size] += 1;
#endif
            }
            else if (VmSupport->Claim > 25) {
                Size = 4;
            }
            else {
                Size = 5;
#if DBG
                if (VmSupport->Flags.SessionSpace == 1) {
                    MiSessionIdleBuckets[Size] += 1;
                }
#endif
            }
        }

#if DBG
        if (MmDebug & MM_DBG_WS_EXPANSION) {
            DbgPrintEx (DPFLTR_MM_ID, DPFLTR_TRACE_LEVEL, 
                "MM-rearrange: TrimHard = %d, WS Size = 0x%x, Claim 0x%x, Bucket %d\n",
                    VmSupport->Flags.TrimHard,
                    VmSupport->WorkingSetSize,
                    VmSupport->Claim,
                    Size);
        }
#endif //DBG

        //
        // Note: this reverses the bucket order each time we
        // reorganize the lists.  This may be good or bad -
        // if you change it you may want to think about it.
        //

        InsertHeadList (&ListHead[Size],
                        &VmSupport->WorkingSetExpansionLinks);
    }

    //
    // Find the first non-empty list.
    //

    for (NonEmpty = 0 ; NonEmpty < MM_WS_REORG_BUCKETS_MAX ; NonEmpty += 1) {
        if (!IsListEmpty (&ListHead[NonEmpty])) {
            break;
        }
    }

    //
    // Put the head of first non-empty list at the beginning
    // of the MmWorkingSetExpansion list.
    //

    MmWorkingSetExpansionHead.ListHead.Flink = ListHead[NonEmpty].Flink;
    ListHead[NonEmpty].Flink->Blink = &MmWorkingSetExpansionHead.ListHead;

    PreviousNonEmpty = NonEmpty;

    //
    // Link the rest of the lists together.
    //

    for (NonEmpty += 1; NonEmpty < MM_WS_REORG_BUCKETS_MAX; NonEmpty += 1) {

        if (!IsListEmpty (&ListHead[NonEmpty])) {

            ListHead[PreviousNonEmpty].Blink->Flink = ListHead[NonEmpty].Flink;
            ListHead[NonEmpty].Flink->Blink = ListHead[PreviousNonEmpty].Blink;
            PreviousNonEmpty = NonEmpty;
        }
    }

    //
    // Link the tail of last non-empty to the MmWorkingSetExpansion list.
    //

    MmWorkingSetExpansionHead.ListHead.Blink = ListHead[PreviousNonEmpty].Blink;
    ListHead[PreviousNonEmpty].Blink->Flink = &MmWorkingSetExpansionHead.ListHead;

    UNLOCK_EXPANSION (OldIrql);

    return;
}


VOID
MiQueueWorkingSetRequest (
    IN ULONG RequestFlags
    )

/*++

Routine Description:

    This routine queues working set requests to the working set manager thread.

Arguments:

    RequestFlags - Supplies the request flags bitfield.

Return Value:

    None.  On return, the request has been processed.

Environment:

    Kernel mode.  No locks held.  APC level or below.

--*/

{
    KIRQL OldIrql;

    ASSERT (KeGetCurrentIrql () <= APC_LEVEL);
    ASSERT (PsGetCurrentThread () != MmWorkingSetThread);

    ASSERT (RequestFlags != 0);
    ASSERT ((RequestFlags & ~MI_WORKING_SET_FLAGS) == 0);
    ASSERT ((RequestFlags & (MI_TRIM_ALL_WORKING_SETS | MI_AGE_ALL_WORKING_SETS)) == 0);

    //
    // For session working sets, we cannot attach directly to the session
    // space to be trimmed because it would result in session space
    // references by other threads in this process to the attached session
    // instead of the (currently) correct one.  In fact, we cannot even queue
    // this to a worker thread because the working set manager
    // (who shares the same page directory) may be attaching or
    // detaching from a session (any session).  So this must be queued
    // to the working set manager.
    //

    LOCK_EXPANSION (OldIrql);

    if (MiWorkingSetRequestFlags == 0) {
        KeClearEvent (&MiWorkingSetRequestEvent);
    }

    MiWorkingSetRequestFlags |= RequestFlags;

    UNLOCK_EXPANSION (OldIrql);

    KeSetEvent (&MmWorkingSetManagerEvent, 0, FALSE);

    KeWaitForSingleObject (&MiWorkingSetRequestEvent,
                           WrVirtualMemory,
                           KernelMode,
                           FALSE,
                           NULL);

    return;
}

VOID
MmEmptyAllWorkingSets (
    VOID
    )

/*++

Routine Description:

    This routine attempts to empty all the working sets on the
    expansion list.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.  No locks held.  APC level or below.

--*/

{
    if (MiFullyInitialized != 0) {
        MiQueueWorkingSetRequest (MI_EMPTY_ALL_WORKING_SETS);
    }

    return;
}


VOID
MmCaptureAllWorkingSetAccessBits (
    IN LOGICAL ResetAccessed
    )

/*++

Routine Description:

    This routine captures accessed filesystem-backed working set entries.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.  No locks held.  APC level or below.

--*/

{
    if (ResetAccessed == TRUE) {
        MiQueueWorkingSetRequest (MI_CAPTURE_AND_RESET_ALL_ACCESS_BITS);
    }
    else {
        MiQueueWorkingSetRequest (MI_CAPTURE_ALL_ACCESS_BITS);
    }

    return;
}

//
// This is deliberately initialized to 1 and only cleared when we have
// initialized enough of the system working set to support a trim.
//

LONG MiTrimInProgressCount = 1;

ULONG MiTrimAllPageFaultCount;


LOGICAL
MmTrimAllSystemPageableMemory (
    __in LOGICAL PurgeTransition
    )

/*++

Routine Description:

    This routine unmaps all pageable system memory.  This does not unmap user
    memory or locked down kernel memory.  Thus, the memory being unmapped
    resides in paged pool, pageable kernel/driver code & data, special pool
    and the system cache.

    Note that pages with a reference count greater than 1 are skipped (ie:
    they remain valid, as they are assumed to be locked down).  This prevents
    us from unmapping all of the system cache entries, etc.

    Non-locked down kernel stacks must be outpaged by modifying the balance
    set manager to operate in conjunction with a support routine.  This is not
    done here.

Arguments:

    PurgeTransition - Supplies whether to purge all the clean pages from the
                      transition list.

Return Value:

    TRUE if accomplished, FALSE if not.

Environment:

    Kernel mode.  APC_LEVEL or below.

--*/

{
    return MiTrimAllSystemPageableMemory (MI_SYSTEM_GLOBAL, PurgeTransition);
}
#if DBG

LOGICAL
MmTrimProcessMemory (
    IN LOGICAL PurgeTransition
    )

/*++

Routine Description:

    This routine unmaps all of the current process' user memory.

Arguments:

    PurgeTransition - Supplies whether to purge all the clean pages from the
                      transition list.

Return Value:

    TRUE if accomplished, FALSE if not.

Environment:

    Kernel mode.  APC_LEVEL or below.

--*/

{
    return MiTrimAllSystemPageableMemory (MI_USER_LOCAL, PurgeTransition);
}
#endif


LOGICAL
MiTrimAllSystemPageableMemory (
    IN ULONG MemoryType,
    IN LOGICAL PurgeTransition
    )

/*++

Routine Description:

    This routine unmaps all pageable memory of the type specified.

    Note that pages with a reference count greater than 1 are skipped (ie:
    they remain valid, as they are assumed to be locked down).  This prevents
    us from unmapping all of the system cache entries, etc.

    Non-locked down kernel stacks must be outpaged by modifying the balance
    set manager to operate in conjunction with a support routine.  This is not
    done here.

Arguments:

    MemoryType - Supplies the type of memory to unmap.

    PurgeTransition - Supplies whether to purge all the clean pages from the
                      transition list.

Return Value:

    TRUE if accomplished, FALSE if not.

Environment:

    Kernel mode.  APC_LEVEL or below.

--*/

{
    LOGICAL Status;
    KIRQL OldIrql;
    PMMSUPPORT VmSupport;
    WSLE_NUMBER PagesInUse;
    LOGICAL LockAvailable;
    PETHREAD CurrentThread;
    PEPROCESS Process;
    PMM_SESSION_SPACE SessionGlobal;

#if defined(_X86_)
    ULONG flags;
#endif

    //
    // It's ok to check this without acquiring the system WS lock.
    //

    if (MemoryType == MI_SYSTEM_GLOBAL) {
        if (MiTrimAllPageFaultCount == MmSystemCacheWs.PageFaultCount) {
            return FALSE;
        }
    }
    else if (MemoryType == MI_USER_LOCAL) {
    }
    else {
        ASSERT (MemoryType == MI_SESSION_LOCAL);
    }

    //
    // Working set mutexes will be acquired which require APC_LEVEL or below.
    //

    if (KeGetCurrentIrql () > APC_LEVEL) {
        return FALSE;
    }

    //
    // Just return if it's too early during system initialization or if
    // another thread/processor is racing here to do the work for us.
    //

    if (InterlockedIncrement (&MiTrimInProgressCount) > 1) {
        InterlockedDecrement (&MiTrimInProgressCount);
        return FALSE;
    }

#if defined(_X86_)

    _asm {
        pushfd
        pop     eax
        mov     flags, eax
    }

    if ((flags & EFLAGS_INTERRUPT_MASK) == 0) {
        InterlockedDecrement (&MiTrimInProgressCount);
        return FALSE;
    }

#endif

#if defined(_AMD64_)
    if ((GetCallersEflags () & EFLAGS_IF_MASK) == 0) {
        InterlockedDecrement (&MiTrimInProgressCount);
        return FALSE;
    }
#endif

    CurrentThread = PsGetCurrentThread ();

    //
    // Don't acquire mutexes if the thread is at priority 0 (ie: zeropage
    // thread) because this priority is not boosted - so a preemption that
    // occurs after a WS mutex is acquired can result in the thread never
    // running again and then all the other threads will be denied the mutex.
    //

    if (CurrentThread->Tcb.Priority == 0) {
        InterlockedDecrement (&MiTrimInProgressCount);
        return FALSE;
    }

    //
    // If the WS mutex is not readily available then just return.
    //

    if (MemoryType == MI_SYSTEM_GLOBAL) {

        Process = NULL;
        VmSupport = &MmSystemCacheWs;

        KeEnterGuardedRegionThread (&CurrentThread->Tcb);

        if (ExTryAcquirePushLockExclusive (&VmSupport->WorkingSetMutex) == FALSE) {
            KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
            InterlockedDecrement (&MiTrimInProgressCount);
            return FALSE;
        }

        CurrentThread->OwnsSystemWorkingSetExclusive = 1;
        MM_SYSTEM_WS_LOCK_TIMESTAMP ();
    }
    else if (MemoryType == MI_USER_LOCAL) {

        Process = PsGetCurrentProcessByThread (CurrentThread);
        VmSupport = &Process->Vm;

        KeEnterGuardedRegionThread (&CurrentThread->Tcb);

        if (ExTryAcquirePushLockExclusive (&VmSupport->WorkingSetMutex) == FALSE) {
            KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
            InterlockedDecrement (&MiTrimInProgressCount);
            return FALSE;
        }

        CurrentThread->OwnsProcessWorkingSetExclusive = 1;
        LOCK_WS_TIMESTAMP (Process);

        //
        // If the process is exiting then just return.
        //

        if (Process->Flags & PS_PROCESS_FLAGS_VM_DELETED) {
            UNLOCK_WS (CurrentThread, Process);
            InterlockedDecrement (&MiTrimInProgressCount);
            return FALSE;
        }

        ASSERT (!MI_IS_WS_UNSAFE(Process));
    }
    else {
        ASSERT (MemoryType == MI_SESSION_LOCAL);

        Process = PsGetCurrentProcessByThread (CurrentThread);

        if (((Process->Flags & PS_PROCESS_FLAGS_IN_SESSION) == 0) ||
            (Process->Vm.Flags.SessionLeader == 1)) {

            InterlockedDecrement (&MiTrimInProgressCount);
            return FALSE;
        }

        SessionGlobal = SESSION_GLOBAL (MmSessionSpace);

        //
        // If the WS mutex is not readily available then just return.
        //

        VmSupport = &SessionGlobal->Vm;

        KeEnterGuardedRegionThread (&CurrentThread->Tcb);

        if (ExTryAcquirePushLockExclusive (&VmSupport->WorkingSetMutex) == FALSE) {
            KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
            InterlockedDecrement (&MiTrimInProgressCount);
            return FALSE;
        }
        CurrentThread->OwnsSessionWorkingSetExclusive = 1;
    }

    Status = FALSE;

    //
    // If the expansion lock is not available then just return.
    //

    LockAvailable = KeTryToAcquireSpinLock (&MmExpansionLock, &OldIrql);

    if (LockAvailable == FALSE) {
        goto Bail;
    }

    MM_SET_EXPANSION_OWNER ();

    if (VmSupport->WorkingSetExpansionLinks.Flink <= MM_WS_SWAPPED_OUT) {
        UNLOCK_EXPANSION (OldIrql);
        goto Bail;
    }

    RemoveEntryList (&VmSupport->WorkingSetExpansionLinks);

    VmSupport->WorkingSetExpansionLinks.Flink = MM_WS_TRIMMING;
    VmSupport->WorkingSetExpansionLinks.Blink = NULL;

    if (MemoryType == MI_SYSTEM_GLOBAL) {
        MiTrimAllPageFaultCount = VmSupport->PageFaultCount;
    }

    PagesInUse = VmSupport->WorkingSetSize;

    //
    // There are 2 issues here that are carefully dealt with :
    //
    // 1.  APCs must be disabled while any resources are held to prevent
    //     suspend APCs from deadlocking the system.
    //
    // 2.  Once the working set has been marked MM_WS_TRIMMING,
    //     either the thread must not be preempted or the working
    //     set mutex must be held throughout.  Otherwise a high priority thread
    //     can fault on a system code and data address and the two pages will
    //     thrash forever (at high priority) because no system working set
    //     expansion is allowed while TRIMMING is set.
    //
    // Thus, the decision was to hold the working set mutex throughout.
    //

    UNLOCK_EXPANSION (OldIrql);

    MiEmptyWorkingSet (VmSupport, FALSE);

    LOCK_EXPANSION (OldIrql);

    ASSERT (VmSupport->WorkingSetExpansionLinks.Flink == MM_WS_TRIMMING);

    if (VmSupport->WorkingSetExpansionLinks.Blink == NULL) {

        //
        // Reinsert this working set at the tail of the list.
        //

        InsertTailList (&MmWorkingSetExpansionHead.ListHead,
                        &VmSupport->WorkingSetExpansionLinks);
    }
    else {

        //
        // The process is terminating - the value in the blink
        // is the address of an event to set.
        //

        ASSERT (VmSupport != &MmSystemCacheWs);

        VmSupport->WorkingSetExpansionLinks.Flink = MM_WS_NOT_LISTED;

        KeSetEvent ((PKEVENT)VmSupport->WorkingSetExpansionLinks.Blink,
                    0,
                    FALSE);
    }

    UNLOCK_EXPANSION (OldIrql);

    Status = TRUE;

Bail:

    UNLOCK_WORKING_SET (CurrentThread, VmSupport);

    ASSERT (KeGetCurrentIrql() <= APC_LEVEL);

    if ((PurgeTransition == TRUE) && (Status == TRUE)) {
        MiPurgeTransitionList ();
    }

    InterlockedDecrement (&MiTrimInProgressCount);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\wstree.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   wstree.c

Abstract:

    This module contains the routines which manipulate the working
    set list tree.

--*/

#include "mi.h"

extern ULONG MmSystemCodePage;
extern ULONG MmSystemCachePage;
extern ULONG MmPagedPoolPage;
extern ULONG MmSystemDriverPage;

#if DBG
ULONG MmNumberOfInserts;
#endif

#if defined (_WIN64)
ULONG MiWslePteLoops = 16;
#endif

VOID
MiRepointWsleHashIndex (
    IN MMWSLE WsleEntry,
    IN PMMWSL WorkingSetList,
    IN WSLE_NUMBER NewWsIndex
    );

VOID
MiCheckWsleHash (
    IN PMMWSL WorkingSetList
    );


VOID
FASTCALL
MiInsertWsleHash (
    IN WSLE_NUMBER Entry,
    IN PMMSUPPORT WsInfo
    )

/*++

Routine Description:

    This routine inserts a Working Set List Entry (WSLE) into the
    hash list for the specified working set.

Arguments:

    Entry - The index number of the WSLE to insert.

    WorkingSetInfo - Supplies the working set structure to insert into.

Return Value:

    None.

Environment:

    Kernel mode, APCs disabled, Working Set Mutex held.

--*/

{
    ULONG Tries;
    PMMWSLE Wsle;
    WSLE_NUMBER Hash;
    PMMWSLE_HASH Table;
    WSLE_NUMBER j;
    WSLE_NUMBER Index;
    ULONG HashTableSize;
    PMMWSL WorkingSetList;
    PMMPTE PointerPte;
    WSLE_NUMBER EntriesExamined;
    WSLE_NUMBER CurrentVictimHashIndex;
    MMWSLE CurrentVictimWsleContents;
    ULONG CurrentVictimAccessed;

    WorkingSetList = WsInfo->VmWorkingSetList;

    Wsle = WorkingSetList->Wsle;

    ASSERT (Wsle[Entry].u1.e1.Valid == 1);
    ASSERT (Wsle[Entry].u1.e1.Direct != 1);
    ASSERT (Wsle[Entry].u1.e1.Hashed == 0);

    Table = WorkingSetList->HashTable;

    if (Table == NULL) {
        return;
    }

#if DBG
    MmNumberOfInserts += 1;
#endif

    Hash = MI_WSLE_HASH (Wsle[Entry].u1.Long, WorkingSetList);

    HashTableSize = WorkingSetList->HashTableSize;

    //
    // Check hash table size and see if there is enough room to
    // hash or if the table should be grown.
    //

    if ((WorkingSetList->NonDirectCount + 10 + (HashTableSize >> 4)) >
                HashTableSize) {

        if ((Table + HashTableSize + ((2*PAGE_SIZE) / sizeof (MMWSLE_HASH)) <= (PMMWSLE_HASH)WorkingSetList->HighestPermittedHashAddress)) {

            WsInfo->Flags.GrowWsleHash = 1;
        }

        if ((WorkingSetList->NonDirectCount + (HashTableSize >> 4)) >
                HashTableSize) {

            //
            // Look for a free entry (or repurpose one if necessary) in the
            // hash table, space is tight.
            //

            j = Hash;
            Tries = 0;
            EntriesExamined = 16;
            if (EntriesExamined > HashTableSize) {
                EntriesExamined = HashTableSize;
            }
            CurrentVictimHashIndex = WSLE_NULL_INDEX;
            CurrentVictimWsleContents.u1.Long = 0;
            CurrentVictimAccessed = 0;

            do {

                if (Table[j].Key == 0) {

                    //
                    // This one's free so just use it.
                    //

                    Hash = j;
                    goto GotHash;
                }

                //
                // Examine this in-use one.  We're looking for the least
                // recently accessed one to use as a victim.  Use the WSLE
                // age bits and the PTE access bit to compute this.
                //

                Index = Table[j].Index;
                ASSERT (Wsle[Index].u1.e1.Direct == 0);
                ASSERT (Wsle[Index].u1.e1.Valid == 1);

                ASSERT (Table[j].Key == MI_GENERATE_VALID_WSLE (&Wsle[Index]));

                if (CurrentVictimHashIndex == WSLE_NULL_INDEX) {
                    CurrentVictimHashIndex = j;
                    CurrentVictimWsleContents = Wsle[Index];
                    CurrentVictimAccessed = (ULONG) MI_GET_ACCESSED_IN_PTE (
                                                MiGetPteAddress (Table[j].Key));
                }
                else {
                    if (Wsle[Index].u1.e1.Age > CurrentVictimWsleContents.u1.e1.Age) {
                        CurrentVictimHashIndex = j;
                        CurrentVictimWsleContents = Wsle[Index];
                        CurrentVictimAccessed = (ULONG) MI_GET_ACCESSED_IN_PTE (
                                                MiGetPteAddress (Table[j].Key));
                    }
                    else if (Wsle[Index].u1.e1.Age == CurrentVictimWsleContents.u1.e1.Age) {
                        if (CurrentVictimAccessed) {
                            PointerPte = MiGetPteAddress (Table[j].Key);
                            if (MI_GET_ACCESSED_IN_PTE (PointerPte) == 0) {
                                CurrentVictimHashIndex = j;
                                CurrentVictimWsleContents = Wsle[Index];
                                CurrentVictimAccessed = 0;
                            }
                        }
                    }
                }

                EntriesExamined -= 1;
                if (EntriesExamined == 0) {

                    //
                    // We've searched enough, take what we've got.
                    //

                    Index = Table[CurrentVictimHashIndex].Index;

                    if (CurrentVictimWsleContents.u1.e1.Age >= MI_PASS0_TRIM_AGE) {
                        //
                        // This address hasn't been accessed in a while, so
                        // take the WSLE and the hash entry.
                        //

                        if (MiFreeWsle (Index,
                                        WsInfo,
                                        MiGetPteAddress (Table[CurrentVictimHashIndex].Key))) {

                            //
                            // The previous entry (WSLE & hash) has been
                            // eliminated, so take it.
                            //

                            ASSERT (Table[CurrentVictimHashIndex].Key == 0);
                            Hash = CurrentVictimHashIndex;
                            goto GotHash;
                        }

                        //
                        // Fall through to take just the hash entry.
                        //
                    }

                    //
                    // Purge the previous entry's hash index (but not WSLE) so
                    // it can be reused for the new entry.  This is nice
                    // because it preserves both entries in the working set
                    // (although it is a bit more costly to remove the original
                    // entry later since it won't have a hash entry).
                    //

                    ASSERT (Wsle[Index].u1.e1.Hashed == 1);
                    Wsle[Index].u1.e1.Hashed = 0;

                    Table[CurrentVictimHashIndex].Key = 0;
                    Hash = CurrentVictimHashIndex;
                    goto GotHash;
                }

                j += 1;

                if (j >= HashTableSize) {
                    j = 0;
                    ASSERT (Tries == 0);
                    Tries = 1;
                }

            } while (TRUE);
        }
    }

    //
    // Add to the hash table if there is space.
    //

    Tries = 0;
    j = Hash;

    while (Table[Hash].Key != 0) {
        Hash += 1;
        if (Hash >= HashTableSize) {
            ASSERT (Tries == 0);
            Hash = 0;
            Tries = 1;
        }
        if (j == Hash) {
            ASSERT (Wsle[Entry].u1.e1.Hashed == 0);
            return;
        }
    }

GotHash:

    ASSERT (Table[Hash].Key == 0);
    ASSERT (Hash < HashTableSize);
    Wsle[Entry].u1.e1.Hashed = 1;

    //
    // Or in the valid bit so subsequent searches below can compare in
    // one instruction for both the virtual address and the valid bit.
    //

    Table[Hash].Key = MI_GENERATE_VALID_WSLE (&Wsle[Entry]);
    Table[Hash].Index = Entry;

#if DBG
    if ((MmNumberOfInserts % 1000) == 0) {
        MiCheckWsleHash (WorkingSetList);
    }
#endif
    return;
}

VOID
MiFillWsleHash (
    IN PMMWSL WorkingSetList
    )

/*++

Routine Description:

    This function fills the hash table with all the indirect WSLEs.
    This is typically called after the hash table has been freshly grown.

Arguments:

    WorkingSetList - Supplies a pointer to the working set list structure.

Return Value:

    None.

Environment:

    Kernel mode, APCs disabled, working set lock held.

--*/

{
    LONG Size;
    PMMWSLE Wsle;
    PMMPTE PointerPte;
    PMMWSLE_HASH Table;
    PMMWSLE_HASH OriginalTable;
    PMMWSLE_HASH StartTable;
    PMMWSLE_HASH EndTable;
    PFN_NUMBER PageFrameIndex;
    WSLE_NUMBER Count;
    WSLE_NUMBER Index;
    PMMPFN Pfn1;

    Table = WorkingSetList->HashTable;
    Count = WorkingSetList->NonDirectCount;
    Size = WorkingSetList->HashTableSize;

    StartTable = Table;
    EndTable = Table + Size;

    Index = 0;
    for (Wsle = WorkingSetList->Wsle; TRUE; Wsle += 1, Index += 1) {

        ASSERT (Wsle <= WorkingSetList->Wsle + WorkingSetList->LastEntry);

        if (Wsle->u1.e1.Valid == 0) {
            continue;
        }

        if (Wsle->u1.e1.Direct == 0) {

            Wsle->u1.e1.Hashed = 0;

            PointerPte = MiGetPteAddress (Wsle->u1.VirtualAddress);
            ASSERT (PointerPte->u.Hard.Valid);
            PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
            Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

            if (Pfn1->u1.WsIndex == Index) {

                //
                // Even though this working set is not the direct owner, it
                // was able to share the direct owner's index.  So don't
                // bother hashing it for now.  This index will remain
                // valid for us unless the direct owner swaps this WSL
                // entry or our working set gets compressed.
                //

                goto DidOne;
            }

            //
            // Hash this.
            //

            Table = &StartTable[MI_WSLE_HASH (Wsle->u1.Long, WorkingSetList)];
            OriginalTable = Table;

            while (Table->Key != 0) {
                Table += 1;
                ASSERT (Table <= EndTable);
                if (Table == EndTable) {
                    Table = StartTable;
                }
                if (Table == OriginalTable) {

                    //
                    // Not enough space to hash everything but that's ok.
                    // Just bail out, we'll do linear walks to lookup this
                    // entry until the hash can be further expanded later.
                    //
                    // Mark any remaining entries as having no hash entry.
                    //

                    do {
                        ASSERT (Wsle <= WorkingSetList->Wsle + WorkingSetList->LastEntry);
                        if ((Wsle->u1.e1.Valid == 1) &&
                            (Wsle->u1.e1.Direct == 0)) {

                            Wsle->u1.e1.Hashed = 0;
                            Count -= 1;
                        }
                        Wsle += 1;
                    } while (Count != 0);

                    return;
                }
            }

            Table->Key = MI_GENERATE_VALID_WSLE (Wsle);
            Table->Index = Index;

            Wsle->u1.e1.Hashed = 1;

DidOne:
            Count -= 1;
            if (Count == 0) {
                break;
            }
        }
        else {
            ASSERT ((Wsle->u1.e1.Hashed == 0) ||
                    (Wsle->u1.e1.LockedInWs == 1) ||
                    (Wsle->u1.e1.LockedInMemory == 1));
        }
    }

#if DBG
    MiCheckWsleHash (WorkingSetList);
#endif
    return;
}

#if DBG
VOID
MiCheckWsleHash (
    IN PMMWSL WorkingSetList
    )
{
    ULONG i;
    ULONG found;
    PMMWSLE Wsle;

    found = 0;
    Wsle = WorkingSetList->Wsle;

    for (i = 0; i < WorkingSetList->HashTableSize; i += 1) {
        if (WorkingSetList->HashTable[i].Key != 0) {
            found += 1;
            ASSERT (WorkingSetList->HashTable[i].Key ==
                MI_GENERATE_VALID_WSLE (&Wsle[WorkingSetList->HashTable[i].Index]));
        }
    }
    if (found > WorkingSetList->NonDirectCount) {
        DbgPrintEx (DPFLTR_MM_ID, DPFLTR_ERROR_LEVEL, 
            "MMWSLE: Found %lx, nondirect %lx\n",
                    found, WorkingSetList->NonDirectCount);
        DbgBreakPoint ();
    }
}
#endif



WSLE_NUMBER
FASTCALL
MiLocateWsle (
    IN PVOID VirtualAddress,
    IN PMMWSL WorkingSetList,
    IN WSLE_NUMBER WsPfnIndex,
    IN LOGICAL Deletion
    )

/*++

Routine Description:

    This function locates the specified virtual address within the
    working set list.

Arguments:

    VirtualAddress - Supplies the virtual address to locate within the working
                     set list.

    WorkingSetList - Supplies the working set list to search.

    WsPfnIndex - Supplies a hint to try before hashing or walking linearly.

    Deletion - Supplies TRUE if the WSLE is going to be deleted by the caller.
               This is used as a hint to remove the WSLE hash so that it does
               not have to be searched for twice.

Return Value:

    Returns the index into the working set list which contains the entry.

Environment:

    Kernel mode, APCs disabled, Working Set Mutex held.

--*/

{
    PMMWSLE Wsle;
    PMMWSLE LastWsle;
    WSLE_NUMBER Hash;
    WSLE_NUMBER StartHash;
    PMMWSLE_HASH Table;
    ULONG Tries;
#if defined (_WIN64)
    ULONG LoopCount;
    WSLE_NUMBER WsPteIndex;
    PMMPTE PointerPte;
#endif

    Wsle = WorkingSetList->Wsle;
    VirtualAddress = PAGE_ALIGN (VirtualAddress);

    //
    // Or in the valid bit so the compares in the loops below can be done in
    // one instruction for both the virtual address and the valid bit.
    //

    VirtualAddress = (PVOID)((ULONG_PTR)VirtualAddress | 0x1);

    if ((WsPfnIndex <= WorkingSetList->LastInitializedWsle) &&
        (MI_GENERATE_VALID_WSLE (&Wsle[WsPfnIndex]) == VirtualAddress)) {

        return WsPfnIndex;
    }

#if defined (_WIN64)
    PointerPte = MiGetPteAddress (VirtualAddress);
    WsPteIndex = MI_GET_WORKING_SET_FROM_PTE (PointerPte);

    if (WsPteIndex != 0) {

        LoopCount = MiWslePteLoops;

        while (WsPteIndex <= WorkingSetList->LastInitializedWsle) {

            if (MI_GENERATE_VALID_WSLE (&Wsle[WsPteIndex]) == VirtualAddress) {
                return WsPteIndex;
            }

            LoopCount -= 1;

            //
            // No working set index so far for this PTE.  Since the working
            // set may be very large (8TB would mean up to half a million loops)
            // just fall back to the hash instead.
            //

            if (LoopCount == 0) {
                break;
            }

            WsPteIndex += MI_MAXIMUM_PTE_WORKING_SET_INDEX;
        }
    }
#endif

    if (WorkingSetList->HashTable != NULL) {
        Tries = 0;
        Table = WorkingSetList->HashTable;

        Hash = MI_WSLE_HASH (VirtualAddress, WorkingSetList);
        StartHash = Hash;

        while (Table[Hash].Key != VirtualAddress) {
            Hash += 1;
            if (Hash >= WorkingSetList->HashTableSize) {
                ASSERT (Tries == 0);
                Hash = 0;
                Tries = 1;
            }
            if (Hash == StartHash) {
                Tries = 2;
                break;
            }
        }
        if (Tries < 2) {
            WsPfnIndex = Table[Hash].Index;
            ASSERT (Wsle[WsPfnIndex].u1.e1.Hashed == 1);
            ASSERT (Wsle[WsPfnIndex].u1.e1.Direct == 0);
            ASSERT (MI_GENERATE_VALID_WSLE (&Wsle[WsPfnIndex]) == Table[Hash].Key);
            if (Deletion) {
                Wsle[WsPfnIndex].u1.e1.Hashed = 0;
                Table[Hash].Key = 0;
            }
            return WsPfnIndex;
        }
    }

    LastWsle = Wsle + WorkingSetList->LastInitializedWsle;

    do {
        if (MI_GENERATE_VALID_WSLE (Wsle) == VirtualAddress) {

            ASSERT ((Wsle->u1.e1.Hashed == 0) ||
                    (WorkingSetList->HashTable == NULL));

            ASSERT (Wsle->u1.e1.Direct == 0);
            return (WSLE_NUMBER)(Wsle - WorkingSetList->Wsle);
        }
        Wsle += 1;

    } while (Wsle <= LastWsle);

    KeBugCheckEx (MEMORY_MANAGEMENT,
                  0x41284,
                  (ULONG_PTR) VirtualAddress,
                  WsPfnIndex,
                  (ULONG_PTR) WorkingSetList);
}


VOID
FASTCALL
MiRemoveWsle (
    IN WSLE_NUMBER Entry,
    IN PMMWSL WorkingSetList
    )

/*++

Routine Description:

    This routine removes a Working Set List Entry (WSLE) from the
    working set.

Arguments:

    Entry - The index number of the WSLE to remove.


Return Value:

    None.

Environment:

    Kernel mode, APCs disabled, Working Set Mutex held.

--*/
{
    PMMWSLE Wsle;
    PVOID VirtualAddress;
    PMMWSLE_HASH Table;
    MMWSLE WsleContents;
    WSLE_NUMBER Hash;
    WSLE_NUMBER StartHash;
    ULONG Tries;

    Wsle = WorkingSetList->Wsle;

    //
    // Locate the entry in the tree.
    //

    if (Entry > WorkingSetList->LastInitializedWsle) {
        KeBugCheckEx (MEMORY_MANAGEMENT,
                      0x41785,
                      (ULONG_PTR)WorkingSetList,
                      Entry,
                      0);
    }

    WsleContents = Wsle[Entry];

    ASSERT (WsleContents.u1.e1.Valid == 1);

    VirtualAddress = PAGE_ALIGN (WsleContents.u1.VirtualAddress);

    if (WorkingSetList == MmSystemCacheWorkingSetList) {

        //
        // Count system space inserts and removals.
        //

        if ((VirtualAddress >= MmPagedPoolStart) && (VirtualAddress <= MmPagedPoolEnd)) {
            MmPagedPoolPage -= 1;
        }
        else if (MI_IS_SYSTEM_CACHE_ADDRESS (VirtualAddress)) {
            MmSystemCachePage -= 1;
        }
        else if ((VirtualAddress <= MmSpecialPoolEnd) && (VirtualAddress >= MmSpecialPoolStart)) {
            MmPagedPoolPage -= 1;
        }
        else if (VirtualAddress >= MiLowestSystemPteVirtualAddress) {
            MmSystemDriverPage -= 1;
        }
        else {
            MmSystemCodePage -= 1;
        }
    }

    WsleContents.u1.e1.Valid = 0;

    MI_LOG_WSLE_CHANGE (WorkingSetList, Entry, WsleContents);

    Wsle[Entry].u1.e1.Valid = 0;

    //
    // Skip entries that cannot possibly be hashed ...
    //

    if (WsleContents.u1.e1.Direct == 0) {

        WorkingSetList->NonDirectCount -= 1;

        if (WsleContents.u1.e1.Hashed == 0) {
#if DBG
            if (WorkingSetList->HashTable != NULL) {
    
                //
                // Or in the valid bit so virtual address 0 is handled
                // properly (instead of matching a free hash entry).
                //

                VirtualAddress = (PVOID)((ULONG_PTR)VirtualAddress | 0x1);

                Table = WorkingSetList->HashTable;
                for (Hash = 0; Hash < WorkingSetList->HashTableSize; Hash += 1) {
                    ASSERT (Table[Hash].Key != VirtualAddress);
                }
            }
#endif
            return;
        }

        if (WorkingSetList->HashTable != NULL) {

            Hash = MI_WSLE_HASH (WsleContents.u1.Long, WorkingSetList);
            Table = WorkingSetList->HashTable;
            Tries = 0;
            StartHash = Hash;

            //
            // Or in the valid bit so virtual address 0 is handled
            // properly (instead of matching a free hash entry).
            //

            VirtualAddress = (PVOID)((ULONG_PTR)VirtualAddress | 0x1);

            while (Table[Hash].Key != VirtualAddress) {
                Hash += 1;
                if (Hash >= WorkingSetList->HashTableSize) {
                    ASSERT (Tries == 0);
                    Hash = 0;
                    Tries = 1;
                }
                if (Hash == StartHash) {

                    //
                    // The entry could not be found in the hash, it must
                    // never have been inserted.  This is ok, we don't
                    // need to do anything more in this case.
                    //

                    ASSERT (WsleContents.u1.e1.Hashed == 0);
                    return;
                }
            }

            ASSERT (WsleContents.u1.e1.Hashed == 1);
            Table[Hash].Key = 0;
        }
    }

    return;
}


VOID
MiSwapWslEntries (
    IN WSLE_NUMBER SwapEntry,
    IN WSLE_NUMBER Entry,
    IN PMMSUPPORT WsInfo,
    IN LOGICAL EntryNotInHash
    )

/*++

Routine Description:

    This routine swaps the working set list entries Entry and SwapEntry
    in the specified working set list.

Arguments:

    SwapEntry - Supplies the first entry to swap.  This entry must be
                valid, i.e. in the working set at the current time.

    Entry - Supplies the other entry to swap.  This entry may be valid
            or invalid.

    WsInfo - Supplies the working set list.

    EntryNotInHash - Supplies TRUE if the Entry cannot possibly be in the hash
                     table (ie, it is newly allocated), so the hash table
                     search can be skipped.

Return Value:

    None.

Environment:

    Kernel mode, Working set lock and PFN lock held (if system cache),
                 APCs disabled.

--*/

{
    MMWSLE WsleEntry;
    MMWSLE WsleSwap;
    PMMPTE PointerPte;
    PMMPFN Pfn1;
    PMMWSLE Wsle;
    PMMWSL WorkingSetList;
    PMMWSLE_HASH Table;

    WorkingSetList = WsInfo->VmWorkingSetList;
    Wsle = WorkingSetList->Wsle;

    WsleSwap = Wsle[SwapEntry];

    ASSERT (WsleSwap.u1.e1.Valid != 0);

    WsleEntry = Wsle[Entry];

    Table = WorkingSetList->HashTable;

    if (WsleEntry.u1.e1.Valid == 0) {

        //
        // Entry is not on any list. Remove it from the free list.
        //

        MiRemoveWsleFromFreeList (Entry, Wsle, WorkingSetList);

        //
        // Copy the entry to this free one.
        //

        MI_LOG_WSLE_CHANGE (WorkingSetList, Entry, WsleSwap);

        Wsle[Entry] = WsleSwap;

        PointerPte = MiGetPteAddress (WsleSwap.u1.VirtualAddress);

        if (PointerPte->u.Hard.Valid == 0) {
#if (_MI_PAGING_LEVELS < 3)
            if (!NT_SUCCESS (MiCheckPdeForPagedPool (WsleSwap.u1.VirtualAddress))) {
#endif

                KeBugCheckEx (MEMORY_MANAGEMENT,
                              0x41289,
                              (ULONG_PTR) WsleSwap.u1.VirtualAddress,
                              (ULONG_PTR) PointerPte->u.Long,
                              (ULONG_PTR) WorkingSetList);
#if (_MI_PAGING_LEVELS < 3)
            }
#endif
        }

        ASSERT (PointerPte->u.Hard.Valid == 1);

        if (WsleSwap.u1.e1.Direct) {
            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
            ASSERT (Pfn1->u1.WsIndex == SwapEntry);
            Pfn1->u1.WsIndex = Entry;
        }
        else {

            //
            // Update hash table.
            //

            if (Table != NULL) {
                MiRepointWsleHashIndex (WsleSwap, WorkingSetList, Entry);
            }
        }

        MI_SET_PTE_IN_WORKING_SET (PointerPte, Entry);

        //
        // Put entry on free list.
        //

        ASSERT ((WorkingSetList->FirstFree <= WorkingSetList->LastInitializedWsle) ||
                (WorkingSetList->FirstFree == WSLE_NULL_INDEX));

        Wsle[SwapEntry].u1.Long = WorkingSetList->FirstFree << MM_FREE_WSLE_SHIFT;
        WorkingSetList->FirstFree = SwapEntry;
        ASSERT ((WorkingSetList->FirstFree <= WorkingSetList->LastInitializedWsle) ||
            (WorkingSetList->FirstFree == WSLE_NULL_INDEX));

    }
    else {

        //
        // Both entries are valid.
        //

        MI_LOG_WSLE_CHANGE (WorkingSetList, SwapEntry, WsleEntry);
        Wsle[SwapEntry] = WsleEntry;

        PointerPte = MiGetPteAddress (WsleEntry.u1.VirtualAddress);

        if (PointerPte->u.Hard.Valid == 0) {
#if (_MI_PAGING_LEVELS < 3)
            if (!NT_SUCCESS (MiCheckPdeForPagedPool (WsleEntry.u1.VirtualAddress))) {
#endif
                KeBugCheckEx (MEMORY_MANAGEMENT,
                              0x4128A,
                              (ULONG_PTR) WsleEntry.u1.VirtualAddress,
                              (ULONG_PTR) PointerPte->u.Long,
                              (ULONG_PTR) WorkingSetList);
#if (_MI_PAGING_LEVELS < 3)
              }
#endif
        }

        ASSERT (PointerPte->u.Hard.Valid == 1);

        if (WsleEntry.u1.e1.Direct) {

            //
            // Swap the PFN WsIndex element to point to the new slot.
            //

            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
            ASSERT (Pfn1->u1.WsIndex == Entry);
            Pfn1->u1.WsIndex = SwapEntry;
        }
        else if (Table != NULL) {

            //
            // Update hash table.
            //

            if (EntryNotInHash == TRUE) {
#if DBG
                WSLE_NUMBER Hash;
                PVOID VirtualAddress;
                    
                VirtualAddress = MI_GENERATE_VALID_WSLE (&WsleEntry);

                for (Hash = 0; Hash < WorkingSetList->HashTableSize; Hash += 1) {
                    ASSERT (Table[Hash].Key != VirtualAddress);
                }
#endif
            }
            else {
                MiRepointWsleHashIndex (WsleEntry, WorkingSetList, SwapEntry);
            }
        }

        MI_SET_PTE_IN_WORKING_SET (PointerPte, SwapEntry);

        MI_LOG_WSLE_CHANGE (WorkingSetList, Entry, WsleSwap);
        Wsle[Entry] = WsleSwap;

        PointerPte = MiGetPteAddress (WsleSwap.u1.VirtualAddress);

        if (PointerPte->u.Hard.Valid == 0) {
#if (_MI_PAGING_LEVELS < 3)
            if (!NT_SUCCESS (MiCheckPdeForPagedPool (WsleSwap.u1.VirtualAddress))) {
#endif
                KeBugCheckEx (MEMORY_MANAGEMENT,
                              0x4128B,
                              (ULONG_PTR) WsleSwap.u1.VirtualAddress,
                              (ULONG_PTR) PointerPte->u.Long,
                              (ULONG_PTR) WorkingSetList);
#if (_MI_PAGING_LEVELS < 3)
              }
#endif
        }

        ASSERT (PointerPte->u.Hard.Valid == 1);

        if (WsleSwap.u1.e1.Direct) {

            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
            ASSERT (Pfn1->u1.WsIndex == SwapEntry);
            Pfn1->u1.WsIndex = Entry;
        }
        else {
            if (Table != NULL) {
                MiRepointWsleHashIndex (WsleSwap, WorkingSetList, Entry);
            }
        }
        MI_SET_PTE_IN_WORKING_SET (PointerPte, Entry);
    }

    return;
}


VOID
FASTCALL
MiTerminateWsle (
    IN PVOID VirtualAddress,
    IN PMMSUPPORT WsInfo,
    IN WSLE_NUMBER WsPfnIndex
    )

/*++

Routine Description:

    This function locates the specified virtual address within the
    working set list and then removes it, performing any necessary structure
    updates.

Arguments:

    VirtualAddress - Supplies the virtual address to locate within the working
                     set list.

    WsInfo - Supplies the working set structure to search.

    WsPfnIndex - Supplies a hint to try before hashing or walking linearly.

Return Value:

    None.

Environment:

    Kernel mode, APCs disabled, Working Set Mutex held.

--*/

{
    MMWSLE WsleContents;
    PMMWSL WorkingSetList;
    WSLE_NUMBER WorkingSetIndex;

    WorkingSetList = WsInfo->VmWorkingSetList;

    WorkingSetIndex = MiLocateWsle (VirtualAddress,
                                    WorkingSetList,
                                    WsPfnIndex,
                                    TRUE);

    ASSERT (WorkingSetIndex != WSLE_NULL_INDEX);

    WsleContents.u1.Long = WorkingSetList->Wsle[WorkingSetIndex].u1.Long;

    ASSERT (PAGE_ALIGN (VirtualAddress) == PAGE_ALIGN (WsleContents.u1.VirtualAddress));
    ASSERT (WsleContents.u1.e1.Valid == 1);

    MiRemoveWsle (WorkingSetIndex, WorkingSetList);

    //
    // Add this entry to the list of free working set entries
    // and adjust the working set count.
    //

    MiReleaseWsle (WorkingSetIndex, WsInfo);

    //
    // If the entry was locked in the working set, then adjust the locked
    // list so it is contiguous by reusing this entry.
    //

    if ((WsleContents.u1.e1.LockedInWs == 1) ||
        (WsleContents.u1.e1.LockedInMemory == 1)) {

        //
        // This entry is locked.
        //

        ASSERT (WorkingSetIndex < WorkingSetList->FirstDynamic);
        WorkingSetList->FirstDynamic -= 1;

        if (WorkingSetIndex != WorkingSetList->FirstDynamic) {

            ASSERT (WorkingSetList->Wsle[WorkingSetList->FirstDynamic].u1.e1.Valid);

            MiSwapWslEntries (WorkingSetList->FirstDynamic,
                              WorkingSetIndex,
                              WsInfo,
                              FALSE);
        }
    }
    else {
        ASSERT (WorkingSetIndex >= WorkingSetList->FirstDynamic);
    }

    return;
}

VOID
MiRepointWsleHashIndex (
    IN MMWSLE WsleEntry,
    IN PMMWSL WorkingSetList,
    IN WSLE_NUMBER NewWsIndex
    )

/*++

Routine Description:

    This routine re-points the working set list hash entry for the supplied
    address so it points at the new working set index.

Arguments:

    WsleEntry - Supplies the virtual address to look up.

    WorkingSetList - Supplies the working set list to operate on.

    NewWsIndex - Supplies the new working set list index to use.

Return Value:

    None.

Environment:

    Kernel mode, Working set mutex held.

--*/

{
    WSLE_NUMBER Hash;
    WSLE_NUMBER StartHash;
    PVOID VirtualAddress;
    PMMWSLE_HASH Table;
    ULONG Tries;
    
    if (WsleEntry.u1.e1.Hashed == 0) {
#if DBG
        if (WorkingSetList->HashTable != NULL) {

            VirtualAddress = MI_GENERATE_VALID_WSLE (&WsleEntry);

            Table = WorkingSetList->HashTable;
            for (Hash = 0; Hash < WorkingSetList->HashTableSize; Hash += 1) {
                ASSERT (Table[Hash].Key != VirtualAddress);
            }
        }
#endif
        return;
    }

    Tries = 0;
    Table = WorkingSetList->HashTable;

    VirtualAddress = MI_GENERATE_VALID_WSLE (&WsleEntry);

    Hash = MI_WSLE_HASH (WsleEntry.u1.VirtualAddress, WorkingSetList);
    StartHash = Hash;

    while (Table[Hash].Key != VirtualAddress) {

        Hash += 1;

        if (Hash >= WorkingSetList->HashTableSize) {
            ASSERT (Tries == 0);
            Hash = 0;
            Tries = 1;
        }

        if (StartHash == Hash) {

            //
            // Didn't find the hash entry, so this virtual address must
            // not have one.  That's ok, just return as nothing needs to
            // be done in this case.
            //

            return;
        }
    }

    Table[Hash].Index = NewWsIndex;

    return;
}

VOID
MiRemoveWsleFromFreeList (
    IN WSLE_NUMBER Entry,
    IN PMMWSLE Wsle,
    IN PMMWSL WorkingSetList
    )

/*++

Routine Description:

    This routine removes a working set list entry from the free list.
    It is used when the entry required is not the first element
    in the free list.

Arguments:

    Entry - Supplies the index of the entry to remove.

    Wsle - Supplies a pointer to the array of WSLEs.

    WorkingSetList - Supplies a pointer to the working set list.

Return Value:

    None.

Environment:

    Kernel mode, Working set lock and PFN lock held, APCs disabled.

--*/

{
    WSLE_NUMBER Free;
    WSLE_NUMBER ParentFree;

    Free = WorkingSetList->FirstFree;

    if (Entry == Free) {

        ASSERT (((Wsle[Entry].u1.Long >> MM_FREE_WSLE_SHIFT) <= WorkingSetList->LastInitializedWsle) ||
                ((Wsle[Entry].u1.Long >> MM_FREE_WSLE_SHIFT) == WSLE_NULL_INDEX));

        WorkingSetList->FirstFree = (WSLE_NUMBER)(Wsle[Entry].u1.Long >> MM_FREE_WSLE_SHIFT);

    }
    else {

        //
        // See if the entry is conveniently pointed to by the previous or
        // next entry to avoid walking the singly linked list when possible.
        //

        ParentFree = (WSLE_NUMBER)-1;

        if ((Entry != 0) && (Wsle[Entry - 1].u1.e1.Valid == 0)) {
            if ((Wsle[Entry - 1].u1.Long >> MM_FREE_WSLE_SHIFT) == Entry) {
                ParentFree = Entry - 1;
            }
        }
        else if ((Entry != WorkingSetList->LastInitializedWsle) && (Wsle[Entry + 1].u1.e1.Valid == 0)) {
            if ((Wsle[Entry + 1].u1.Long >> MM_FREE_WSLE_SHIFT) == Entry) {
                ParentFree = Entry + 1;
            }
        }

        if (ParentFree == (WSLE_NUMBER)-1) {
            do {
                ParentFree = Free;
                ASSERT (Wsle[Free].u1.e1.Valid == 0);
                Free = (WSLE_NUMBER)(Wsle[Free].u1.Long >> MM_FREE_WSLE_SHIFT);
            } while (Free != Entry);
        }

        Wsle[ParentFree].u1.Long = Wsle[Entry].u1.Long;
    }
    ASSERT ((WorkingSetList->FirstFree <= WorkingSetList->LastInitializedWsle) ||
            (WorkingSetList->FirstFree == WSLE_NULL_INDEX));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\zeropage.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    zeropage.c

Abstract:

    This module contains the zero page thread for memory management.

--*/

#include "mi.h"

#define MM_ZERO_PAGE_OBJECT     0
#define PO_SYS_IDLE_OBJECT      1
#define NUMBER_WAIT_OBJECTS     2

#define MACHINE_ZERO_PAGE(ZeroBase,NumberOfBytes) KeZeroPagesFromIdleThread(ZeroBase,NumberOfBytes)

LOGICAL MiZeroingDisabled = FALSE;

#if DBG
ULONG MiInitialZeroNoPtes = 0;
#endif

#if !defined(NT_UP)

LONG MiNextZeroProcessor = (LONG)-1;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,MiStartZeroPageWorkers)
#endif

#endif

VOID
MmZeroPageThread (
    VOID
    )

/*++

Routine Description:

    Implements the NT zeroing page thread.  This thread runs
    at priority zero and removes a page from the free list,
    zeroes it, and places it on the zeroed page list.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    KIRQL OldIrql;
    PFN_NUMBER PageFrame1;
    LOGICAL ZeroedAlready;
    PFN_NUMBER PageFrame;
    PMMPFN Pfn1;
    PVOID ZeroBase;
    PVOID WaitObjects[NUMBER_WAIT_OBJECTS];
    NTSTATUS Status;
    PVOID StartVa;
    PVOID EndVa;
    PFN_COUNT PagesToZero;
    PFN_COUNT MaximumPagesToZero;
    ULONG Color;
    ULONG StartColor;
    PMMPFN PfnAllocation;
    ULONG SecondaryColorMask;
    PMMCOLOR_TABLES FreePagesByColor;

#if defined(MI_MULTINODE)

    ULONG i;
    ULONG n;
    ULONG LastNodeZeroing;
    KAFFINITY ProcessorMask;

    n = 0;
    LastNodeZeroing = 0;
#endif

    //
    // Make local copies of globals so they don't have to be wastefully
    // refetched while holding the PFN lock.
    //

    FreePagesByColor = MmFreePagesByColor[FreePageList];
    SecondaryColorMask = MmSecondaryColorMask;

    //
    // Before this becomes the zero page thread, free the kernel
    // initialization code.
    //

    MiFindInitializationCode (&StartVa, &EndVa);

    if (StartVa != NULL) {
        MiFreeInitializationCode (StartVa, EndVa);
    }

    MaximumPagesToZero = 1;

#if !defined(NT_UP)

    //
    // Zero groups of pages at once to reduce PFN lock contention.
    // Charge commitment as well as resident available up front since
    // zeroing may get starved priority-wise.
    //
    // Note using MmSecondaryColors here would be excessively wasteful
    // on NUMA systems.  MmSecondaryColorMask + 1 is correct for all platforms.
    //

    PagesToZero = SecondaryColorMask + 1;

    if (PagesToZero > NUMBER_OF_ZEROING_PTES) {
        PagesToZero = NUMBER_OF_ZEROING_PTES;
    }

    if (MiChargeCommitment (PagesToZero, NULL) == TRUE) {

        LOCK_PFN (OldIrql);

        //
        // Check to make sure the physical pages are available.
        //

        if (MI_NONPAGEABLE_MEMORY_AVAILABLE() > (SPFN_NUMBER)(PagesToZero)) {
            MI_DECREMENT_RESIDENT_AVAILABLE (PagesToZero,
                                    MM_RESAVAIL_ALLOCATE_ZERO_PAGE_CLUSTERS);
            MaximumPagesToZero = PagesToZero;
        }

        UNLOCK_PFN (OldIrql);
    }

#endif

    //
    // The following code sets the current thread's base priority to zero
    // and then sets its current priority to zero. This ensures that the
    // thread always runs at a priority of zero.
    //

    KeSetPriorityZeroPageThread (0);

    //
    // Initialize wait object array for multiple wait
    //

    WaitObjects[MM_ZERO_PAGE_OBJECT] = &MmZeroingPageEvent;
    WaitObjects[PO_SYS_IDLE_OBJECT] = &PoSystemIdleTimer;

    Color = 0;
    PfnAllocation = (PMMPFN) MM_EMPTY_LIST;

    //
    // Loop forever zeroing pages.
    //

    do {

        //
        // Wait until there are at least MmZeroPageMinimum pages
        // on the free list.
        //

        Status = KeWaitForMultipleObjects (NUMBER_WAIT_OBJECTS,
                                           WaitObjects,
                                           WaitAny,
                                           WrFreePage,
                                           KernelMode,
                                           FALSE,
                                           NULL,
                                           NULL);

        if (Status == PO_SYS_IDLE_OBJECT) {

            //
            // Raise the priority and base priority of the current thread
            // above zero so it can participate in priority boosts provided
            // during the ready thread scan performed by the balance set
            // manager.
            //

            KeSetPriorityZeroPageThread (1);
            PoSystemIdleWorker (TRUE);

            //
            // Lower the priority and base priority of the current thread
            // back to zero so it will not participate in ready thread scan
            // priority boosts.
            //

            KeSetPriorityZeroPageThread (0);
            continue;
        }

        PagesToZero = 0;

        LOCK_PFN (OldIrql);

        do {

            if (MmFreePageListHead.Total == 0) {

                //
                // No pages on the free list at this time, wait for
                // some more.
                //

                MmZeroingPageThreadActive = FALSE;
                UNLOCK_PFN (OldIrql);
                break;
            }

            if (MiZeroingDisabled == TRUE) {
                MmZeroingPageThreadActive = FALSE;
                UNLOCK_PFN (OldIrql);
                KeDelayExecutionThread (KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER)&MmHalfSecond);
                break;
            }

#if defined(MI_MULTINODE)

            //
            // In a multinode system, zero pages by node.  Resume on
            // the last node examined, find a node with free pages that
            // need to be zeroed.
            //

            if (KeNumberNodes > 1) {

                n = LastNodeZeroing;

                for (i = 0; i < KeNumberNodes; i += 1) {
                    if (KeNodeBlock[n]->FreeCount[FreePageList] != 0) {
                        break;
                    }
                    n = (n + 1) % KeNumberNodes;
                }

                ASSERT (i != KeNumberNodes);
                ASSERT (KeNodeBlock[n]->FreeCount[FreePageList] != 0);

                if (n != LastNodeZeroing) {
                    Color = KeNodeBlock[n]->MmShiftedColor;
                }
            }
#endif
                
            ASSERT (PagesToZero == 0);

            StartColor = Color;

            do {
                            
                PageFrame = FreePagesByColor[Color].Flink;

                if (PageFrame != MM_EMPTY_LIST) {

                    Pfn1 = MI_PFN_ELEMENT (PageFrame);

                    //
                    // Check the frame carefully because a single bit (hardware)
                    // error causing us to zero the wrong frame is very hard
                    // to reconstruct after the fact.
                    //

                    if ((Pfn1->u3.e1.PageLocation != FreePageList) ||
                        (Pfn1->u3.e2.ReferenceCount != 0)) {

                        //
                        // Someone has removed a page from the colored lists
                        // chain without updating the freelist chain.
                        //

                        KeBugCheckEx (PFN_LIST_CORRUPT,
                                      0x8D,
                                      PageFrame,
                                      (Pfn1->u3.e2.ShortFlags << 16) |
                                        Pfn1->u3.e2.ReferenceCount,
                                      (ULONG_PTR) Pfn1->PteAddress);
                    }

                    PageFrame1 = MiRemoveAnyPage (Color);

                    if (PageFrame != PageFrame1) {

                        //
                        // Someone has removed a page from the colored lists
                        // chain without updating the freelist chain.
                        //

                        KeBugCheckEx (PFN_LIST_CORRUPT,
                                      0x8E,
                                      PageFrame,
                                      PageFrame1,
                                      0);
                    }

                    Pfn1->u1.Flink = (PFN_NUMBER) PfnAllocation;


                    //
                    // Temporarily mark the page as bad so that contiguous
                    // memory allocators won't steal it when we release
                    // the PFN lock below.  This also prevents the
                    // MiIdentifyPfn code from trying to identify it as
                    // we haven't filled in all the fields yet.
                    //

                    Pfn1->u3.e1.PageLocation = BadPageList;

                    PfnAllocation = Pfn1;

                    PagesToZero += 1;
                }

                //
                // March to the next color - this will be used to finish
                // filling the current chunk or to start the next one.
                //

                Color = (Color & ~SecondaryColorMask) |
                        ((Color + 1) & SecondaryColorMask);

                if (PagesToZero == MaximumPagesToZero) {
                    break;
                }

                if (Color == StartColor) {
                    break;
                }

            } while (TRUE);

            ASSERT (PfnAllocation != (PMMPFN) MM_EMPTY_LIST);

            UNLOCK_PFN (OldIrql);

#if defined(MI_MULTINODE)

            //
            // If a node switch is in order, do it now that the PFN
            // lock has been released.
            //

            if ((KeNumberNodes > 1) && (n != LastNodeZeroing)) {
                LastNodeZeroing = n;

                ProcessorMask = KeNodeBlock[n]->ProcessorMask;

                //
                // Only affinitize if the node has a processor.  Otherwise
                // just stay with the last ideal processor that was set.
                //

                if (ProcessorMask != 0) {

                    KeFindFirstSetLeftAffinity (ProcessorMask, &i);

                    if (i != NO_BITS_FOUND) {
                        KeSetIdealProcessorThread (KeGetCurrentThread(), (UCHAR)i);
                    }
                }
            }

#endif

            ZeroedAlready = FALSE;

            if (ZeroedAlready == FALSE) {
                ZeroBase = MiMapPagesToZeroInHyperSpace (PfnAllocation, PagesToZero);

                MACHINE_ZERO_PAGE (ZeroBase, PagesToZero << PAGE_SHIFT);

                MiUnmapPagesInZeroSpace (ZeroBase, PagesToZero);
            }

            PagesToZero = 0;

            Pfn1 = PfnAllocation;

            LOCK_PFN (OldIrql);

            do {

                PageFrame = MI_PFN_ELEMENT_TO_INDEX (Pfn1);

                Pfn1 = (PMMPFN) Pfn1->u1.Flink;

                MiInsertPageInList (&MmZeroedPageListHead, PageFrame);

            } while (Pfn1 != (PMMPFN) MM_EMPTY_LIST);

            //
            // We just finished processing a cluster of pages - briefly
            // release the PFN lock to allow other threads to make progress.
            //

            UNLOCK_PFN (OldIrql);

            PfnAllocation = (PMMPFN) MM_EMPTY_LIST;

            LOCK_PFN (OldIrql);

        } while (TRUE);

    } while (TRUE);
}

#if !defined(NT_UP)


VOID
MiZeroPageWorker (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is the worker routine executed by all processors so that
    initial page zeroing occurs in parallel.

Arguments:

    Context - Supplies a pointer to the workitem.

Return Value:

    None.

Environment:

    Kernel mode initialization time, PASSIVE_LEVEL.  Because this is INIT
    only code, don't bother charging commit for the pages.

--*/

{
    MMPTE TempPte;
    MMPTE DefaultCachedPte;
    PMMPTE PointerPte;
    KAFFINITY Affinity;
    KIRQL OldIrql;
    PVOID ZeroBase;
    PKTHREAD Thread;
    CCHAR OldProcessor;
    SCHAR OldBasePriority;
    KPRIORITY OldPriority;
    PWORK_QUEUE_ITEM WorkItem;
    PMMPFN Pfn1;
    PFN_COUNT PagesToZero;
    PFN_COUNT MaximumPagesToZero;
    PFN_NUMBER PageFrame;
    PFN_NUMBER PageFrame1;
    PMMPFN PfnAllocation;
    ULONG Color;
    ULONG StartColor;
    LOGICAL ZeroedAlready;
    PMMCOLOR_TABLES FreePagesByColor;
    ULONG SecondaryColorMask;

    WorkItem = (PWORK_QUEUE_ITEM) Context;

    ExFreePool (WorkItem);

    DefaultCachedPte = ValidKernelPte;

    //
    // Make local copies of globals so they don't have to be wastefully
    // refetched while holding the PFN lock.
    //

    FreePagesByColor = MmFreePagesByColor[FreePageList];
    SecondaryColorMask = MmSecondaryColorMask;

    //
    // The following code sets the current thread's base and current priorities
    // to one so all other code (except the zero page thread) can preempt it.
    //

    Thread = KeGetCurrentThread ();
    OldBasePriority = Thread->BasePriority;
    Thread->BasePriority = 1;
    OldPriority = KeSetPriorityThread (Thread, 1);

    //
    // Dispatch each worker thread to the next processor in line.
    //

    OldProcessor = (CCHAR) InterlockedIncrement (&MiNextZeroProcessor);

    Affinity = AFFINITY_MASK (OldProcessor);

    KeSetSystemAffinityThread (Affinity);

    Color = 0;

#if !defined(NT_UP)

    //
    // Make an attempt to stagger the processors ...
    //

    Color = (MmSecondaryColors / KeNumberProcessors) * OldProcessor;
    Color &= SecondaryColorMask;
#endif

#if defined(MI_MULTINODE)
    if (KeNumberNodes > 1) {
        Color = KeGetCurrentNode()->MmShiftedColor;
    }
#endif

    //
    // Zero groups of local pages at once to reduce PFN lock contention.
    //
    // Note using MmSecondaryColors here would be excessively wasteful
    // on NUMA systems.  MmSecondaryColorMask + 1 is correct for all platforms.
    //

    MaximumPagesToZero = SecondaryColorMask + 1;


    //
    // Zero a maximum of 64k at a time since 64k is the largest binned
    // system PTE size (for systems that need to use PTEs for zeroing).
    //

    if (MaximumPagesToZero > (64 * 1024) / PAGE_SIZE) {
        MaximumPagesToZero = (64 * 1024) / PAGE_SIZE;
    }

    PagesToZero = 0;

    PfnAllocation = (PMMPFN) MM_EMPTY_LIST;

    LOCK_PFN (OldIrql);

    do {

        StartColor = Color;

        ASSERT (PagesToZero == 0);
        ASSERT (PfnAllocation == (PMMPFN) MM_EMPTY_LIST);

        do {
                        
            PageFrame = FreePagesByColor[Color].Flink;

            if (PageFrame != MM_EMPTY_LIST) {

                Pfn1 = MI_PFN_ELEMENT (PageFrame);

                //
                // Check the frame carefully because a single bit (hardware)
                // error causing us to zero the wrong frame is very hard
                // to reconstruct after the fact.
                //

                if ((Pfn1->u3.e1.PageLocation != FreePageList) ||
                    (Pfn1->u3.e2.ReferenceCount != 0)) {

                    //
                    // Someone has removed a page from the colored lists
                    // chain without updating the freelist chain.
                    //

                    KeBugCheckEx (PFN_LIST_CORRUPT,
                                  0x8D,
                                  PageFrame,
                                  (Pfn1->u3.e2.ShortFlags << 16) |
                                    Pfn1->u3.e2.ReferenceCount,
                                  (ULONG_PTR) Pfn1->PteAddress);
                }

                PageFrame1 = MiRemoveAnyPage (Color);

                if (PageFrame != PageFrame1) {

                    //
                    // Someone has removed a page from the colored lists
                    // chain without updating the freelist chain.
                    //

                    KeBugCheckEx (PFN_LIST_CORRUPT,
                                  0x8E,
                                  PageFrame,
                                  PageFrame1,
                                  0);
                }

                Pfn1->u1.Flink = (PFN_NUMBER) PfnAllocation;

                //
                // Temporarily mark the page as bad so that contiguous
                // memory allocators won't steal it when we release
                // the PFN lock below.  This also prevents the
                // MiIdentifyPfn code from trying to identify it as
                // we haven't filled in all the fields yet.
                //

                Pfn1->u3.e1.PageLocation = BadPageList;

                PfnAllocation = Pfn1;

                PagesToZero += 1;
            }

            //
            // March to the next color - this will be used to finish
            // filling the current chunk or to start the next one.
            //

            Color = (Color & ~SecondaryColorMask) |
                    ((Color + 1) & SecondaryColorMask);

            if (PagesToZero == MaximumPagesToZero) {
                break;
            }

            if (Color == StartColor) {

                if (PagesToZero == 0) {

                    //
                    // All of the pages for this node have been zeroed, bail.
                    //

                    ASSERT (PfnAllocation == (PMMPFN) MM_EMPTY_LIST);
                    UNLOCK_PFN (OldIrql);
                    goto ZeroingComplete;
                }

                break;
            }

        } while (TRUE);

        ASSERT (PagesToZero != 0);
        ASSERT (PfnAllocation != (PMMPFN) MM_EMPTY_LIST);

        //
        // Use system PTEs instead of hyperspace to zero the page so that
        // a spinlock (ie: interrupts blocked) is not held while zeroing.
        // Since system PTE acquisition is lock free and the TB lazy flushed,
        // this is perhaps the best path regardless.
        //

        UNLOCK_PFN (OldIrql);

        ZeroedAlready = FALSE;

        if (ZeroedAlready == FALSE) {

            Pfn1 = PfnAllocation;

            PointerPte = MiReserveSystemPtes (PagesToZero, SystemPteSpace);
    
            if (PointerPte == NULL) {
    
#if DBG
                MiInitialZeroNoPtes += 1;
#endif

                //
                // Put these pages back on the freelist.
                //
    
                LOCK_PFN (OldIrql);
    
                do {

                    PageFrame = MI_PFN_ELEMENT_TO_INDEX (Pfn1);

                    Pfn1 = (PMMPFN) Pfn1->u1.Flink;

                    MiInsertPageInFreeList (PageFrame);

                } while (Pfn1 != (PMMPFN) MM_EMPTY_LIST);
    
                UNLOCK_PFN (OldIrql);
    
                break;
            }
    
            ZeroBase = MiGetVirtualAddressMappedByPte (PointerPte);
    
            do {

                ASSERT (PointerPte->u.Hard.Valid == 0);

                PageFrame = MI_PFN_ELEMENT_TO_INDEX (Pfn1);

                TempPte = DefaultCachedPte;

                if (Pfn1->u3.e1.CacheAttribute == MiWriteCombined) {
                    MI_SET_PTE_WRITE_COMBINE (TempPte);
                }
                else if (Pfn1->u3.e1.CacheAttribute == MiNonCached) {
                    MI_DISABLE_CACHING (TempPte);
                }

                TempPte.u.Hard.PageFrameNumber = PageFrame;

                MI_WRITE_VALID_PTE (PointerPte, TempPte);

                PointerPte += 1;
    
                Pfn1 = (PMMPFN) Pfn1->u1.Flink;

            } while (Pfn1 != (PMMPFN) MM_EMPTY_LIST);

            KeZeroPages (ZeroBase, PagesToZero << PAGE_SHIFT);
    
            PointerPte -= PagesToZero;

            MiReleaseSystemPtes (PointerPte, PagesToZero, SystemPteSpace);
        }

        PagesToZero = 0;

        Pfn1 = PfnAllocation;

        PfnAllocation = (PMMPFN) MM_EMPTY_LIST;

        LOCK_PFN (OldIrql);

        do {

            PageFrame = MI_PFN_ELEMENT_TO_INDEX (Pfn1);

            Pfn1 = (PMMPFN) Pfn1->u1.Flink;

            MiInsertZeroListAtBack (PageFrame);

        } while (Pfn1 != (PMMPFN) MM_EMPTY_LIST);

    } while (TRUE);

ZeroingComplete:

    //
    // Restore the entry thread priority and processor affinity.
    //

    KeRevertToUserAffinityThread ();

    KeSetPriorityThread (Thread, OldPriority);

    Thread->BasePriority = OldBasePriority;

    return;
}


VOID
MiStartZeroPageWorkers (
    VOID
    )

/*++

Routine Description:

    This routine starts the zero page worker threads.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode initialization phase 1, PASSIVE_LEVEL.

--*/

{
    ULONG i;
    PWORK_QUEUE_ITEM WorkItem;

    for (i = 0; i < (ULONG) KeNumberProcessors; i += 1) {

        WorkItem = ExAllocatePoolWithTag (NonPagedPool,
                                          sizeof (WORK_QUEUE_ITEM),
                                          'wZmM');

        if (WorkItem == NULL) {
            break;
        }

        ExInitializeWorkItem (WorkItem, MiZeroPageWorker, (PVOID) WorkItem);

        ExQueueWorkItem (WorkItem, CriticalWorkQueue);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\amd64\dataamd.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    dataamd.c

Abstract:

    This module contains the private hardware specific global storage for
    the memory management subsystem.

--*/

#include "mi.h"

//
// A zero Pte.
//

const MMPTE ZeroPte = { 0 };

//
// A kernel zero PTE.
//

const MMPTE ZeroKernelPte = {0x0};

MMPTE ValidKernelPte = { MM_PTE_VALID_MASK |
                         MM_PTE_WRITE_MASK |
                         MM_PTE_GLOBAL_MASK |
                         MM_PTE_DIRTY_MASK |
                         MM_PTE_ACCESS_MASK };

const MMPTE ValidKernelPteLocal = { MM_PTE_VALID_MASK |
                                    MM_PTE_WRITE_MASK |
                                    MM_PTE_DIRTY_MASK |
                                    MM_PTE_ACCESS_MASK };


MMPTE ValidUserPte = { MM_PTE_VALID_MASK |
                       MM_PTE_WRITE_MASK |
                       MM_PTE_OWNER_MASK |
                       MM_PTE_DIRTY_MASK |
                       MM_PTE_ACCESS_MASK };


const MMPTE ValidPtePte = { MM_PTE_VALID_MASK |
                            MM_PTE_WRITE_MASK |
                            MM_PTE_DIRTY_MASK |
                            MM_PTE_ACCESS_MASK };


const MMPTE ValidPdePde = { MM_PTE_VALID_MASK |
                            MM_PTE_WRITE_MASK |
                            MM_PTE_DIRTY_MASK |
                            MM_PTE_ACCESS_MASK };


MMPTE ValidKernelPde = { MM_PTE_VALID_MASK |
                         MM_PTE_WRITE_MASK |
                         MM_PTE_GLOBAL_MASK |
                         MM_PTE_DIRTY_MASK |
                         MM_PTE_ACCESS_MASK };

const MMPTE ValidKernelPdeLocal = { MM_PTE_VALID_MASK |
                                    MM_PTE_WRITE_MASK |
                                    MM_PTE_DIRTY_MASK |
                                    MM_PTE_ACCESS_MASK };


MMPTE DemandZeroPde = { MM_READWRITE << MM_PROTECT_FIELD_SHIFT };


const MMPTE DemandZeroPte = { MM_READWRITE << MM_PROTECT_FIELD_SHIFT };


const MMPTE TransitionPde = { MM_PTE_WRITE_MASK |
                              MM_PTE_OWNER_MASK |
                              MM_PTE_TRANSITION_MASK |
                              MM_READWRITE << MM_PROTECT_FIELD_SHIFT };

MMPTE PrototypePte = { (MI_PTE_LOOKUP_NEEDED << 32) |
                       MM_PTE_PROTOTYPE_MASK |
                       MM_READWRITE << MM_PROTECT_FIELD_SHIFT };

//
// PTE which generates an access violation when referenced.
//

const MMPTE NoAccessPte = {MM_NOACCESS << MM_PROTECT_FIELD_SHIFT };

//
// Pool start and end.
//

PVOID MmNonPagedPoolStart;

PVOID MmNonPagedPoolEnd = (PVOID)MM_NONPAGED_POOL_END;

PVOID MmPagedPoolStart =  (PVOID)MM_PAGED_POOL_START;

PVOID MmPagedPoolEnd;

//
// Color tables for free and zeroed pages.
//

PMMCOLOR_TABLES MmFreePagesByColor[2];

//
// Color tables for modified pages destined for the paging file.
//

MMPFNLIST MmModifiedPageListByColor[MM_MAXIMUM_NUMBER_OF_COLORS] = {
                            0, ModifiedPageList, MM_EMPTY_LIST, MM_EMPTY_LIST};

//
// Count of the number of modified pages destined for the paging file.
//

PFN_NUMBER MmTotalPagesForPagingFile = 0;

//
// PTE reserved for mapping pages for the debugger.
//

PMMPTE MmDebugPte;
PVOID MmDebugVa;

//
// 16 PTEs reserved for mapping MDLs (64k max).
//

PMMPTE MmCrashDumpPte;
PVOID MmCrashDumpVa;

ULONG_PTR MmBootImageSize;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\amd64\initamd.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    initamd.c

Abstract:

    This module contains the machine dependent initialization for the
    memory management component. It is specifically tailored to the
    AMD64 architecture.

--*/

#include "mi.h"

PFN_NUMBER
MxGetNextPage (
    IN PFN_NUMBER PagesNeeded,
    IN LOGICAL UseSlush
    );

PFN_NUMBER
MxPagesAvailable (
    VOID
    );

VOID
MxConvertToLargePage (
    IN PVOID VirtualAddress,
    IN PVOID EndVirtualAddress
    );

VOID
MxPopulatePageDirectories (
    IN PMMPTE StartPde,
    IN PMMPTE EndPde
    );

VOID
MiComputeInitialLargePage (
    VOID
    );

LOGICAL
MiIsRegularMemory (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_NUMBER PageFrameIndex
    );

PMEMORY_ALLOCATION_DESCRIPTOR
MiFindDescriptor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_NUMBER PageFrameIndex
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,MiInitMachineDependent)
#pragma alloc_text(INIT,MxGetNextPage)
#pragma alloc_text(INIT,MxPagesAvailable)
#pragma alloc_text(INIT,MxConvertToLargePage)
#pragma alloc_text(INIT,MiReportPhysicalMemory)
#pragma alloc_text(INIT,MxPopulatePageDirectories)
#pragma alloc_text(INIT,MiComputeInitialLargePage)
#pragma alloc_text(INIT,MiIsRegularMemory)
#pragma alloc_text(INIT,MiFindDescriptor)
#endif

#define MM_LARGE_PAGE_MINIMUM  ((255*1024*1024) >> PAGE_SHIFT)

#define _x1mb (1024*1024)
#define _x1mbnp ((1024*1024) >> PAGE_SHIFT)
#define _x16mb (1024*1024*16)
#define _x16mbnp ((1024*1024*16) >> PAGE_SHIFT)
#define _x4gb (0x100000000UI64)

#define MI_IS_PTE_VALID(PTE) ((PTE)->u.Hard.Valid == 1)

//
// Local data.
//

PFN_NUMBER MiInitialLargePage;
PFN_NUMBER MiInitialLargePageSize;

PFN_NUMBER MxPfnAllocation;
PFN_NUMBER MxTotalFreePages;

PFN_NUMBER MiSlushDescriptorBase;
PFN_NUMBER MiSlushDescriptorCount;

PMEMORY_ALLOCATION_DESCRIPTOR MxFreeDescriptor;
MEMORY_ALLOCATION_DESCRIPTOR MxOldFreeDescriptor;

PMEMORY_ALLOCATION_DESCRIPTOR MxSlushDescriptor1;
MEMORY_ALLOCATION_DESCRIPTOR MxOldSlushDescriptor1;

PMEMORY_ALLOCATION_DESCRIPTOR MxSlushDescriptor2;
MEMORY_ALLOCATION_DESCRIPTOR MxOldSlushDescriptor2;

typedef struct _MI_LARGE_VA_RANGES {
    PVOID VirtualAddress;
    PVOID EndVirtualAddress;
} MI_LARGE_VA_RANGES, *PMI_LARGE_VA_RANGES;

//
// There are potentially 3 large page ranges:
//
// 1. PFN database & initial nonpaged pool
// 2. Kernel code/data
// 3. HAL code/data
//

ULONG MxMapLargePages = 1;

#define MI_MAX_LARGE_VA_RANGES 3

ULONG MiLargeVaRangeIndex;
MI_LARGE_VA_RANGES MiLargeVaRanges[MI_MAX_LARGE_VA_RANGES];

#define MM_PFN_MAPPED_BY_PDE (MM_VA_MAPPED_BY_PDE >> PAGE_SHIFT)


PFN_NUMBER
MxGetNextPage (
    IN PFN_NUMBER PagesNeeded,
    IN LOGICAL UseSlush
    )

/*++

Routine Description:

    This function returns the next physical page number from the largest
    largest free descriptor.  If there are not enough physical pages left
    to satisfy the request then a bugcheck is executed since the system
    cannot be initialized.

Arguments:

    PagesNeeded - Supplies the number of pages needed.

    UseSlush - Supplies TRUE if the slush descriptor can be used (ie, the
               allocation will never be freed and will always be cachable).

Return Value:

    The base of the range of physically contiguous pages.

Environment:

    Kernel mode, Phase 0 only.

--*/

{
    PFN_NUMBER PageFrameIndex;

    if (UseSlush == TRUE) {

        if ((MxSlushDescriptor1 != NULL) &&
            (PagesNeeded <= MxSlushDescriptor1->PageCount)) {

            PageFrameIndex = MxSlushDescriptor1->BasePage;

            MxSlushDescriptor1->BasePage += (ULONG) PagesNeeded;
            MxSlushDescriptor1->PageCount -= (ULONG) PagesNeeded;

            return PageFrameIndex;
        }

        if ((MxSlushDescriptor2 != NULL) &&
            (PagesNeeded <= MxSlushDescriptor2->PageCount)) {

            PageFrameIndex = MxSlushDescriptor2->BasePage;

            MxSlushDescriptor2->BasePage += (ULONG) PagesNeeded;
            MxSlushDescriptor2->PageCount -= (ULONG) PagesNeeded;

            return PageFrameIndex;
        }
    }

    //
    // Examine the free descriptor to see if enough usable memory is available.
    //

    if (PagesNeeded > MxFreeDescriptor->PageCount) {

        KeBugCheckEx (INSTALL_MORE_MEMORY,
                      MmNumberOfPhysicalPages,
                      MxFreeDescriptor->PageCount,
                      MxOldFreeDescriptor.PageCount,
                      PagesNeeded);
    }

    PageFrameIndex = MxFreeDescriptor->BasePage;

    MxFreeDescriptor->BasePage += (ULONG) PagesNeeded;
    MxFreeDescriptor->PageCount -= (ULONG) PagesNeeded;

    return PageFrameIndex;
}

PFN_NUMBER
MxPagesAvailable (
    VOID
    )

/*++

Routine Description:

    This function returns the number of pages available.
    
Arguments:

    None.

Return Value:

    The number of physically contiguous pages currently available.

Environment:

    Kernel mode, Phase 0 only.

--*/

{
    return MxFreeDescriptor->PageCount;
}


VOID
MxConvertToLargePage (
    IN PVOID VirtualAddress,
    IN PVOID EndVirtualAddress
    )

/*++

Routine Description:

    This function converts the backing for the supplied virtual address range
    to a large page mapping.
    
Arguments:

    VirtualAddress - Supplies the virtual address to convert to a large page.

    EndVirtualAddress - Supplies the end virtual address to convert to a
                        large page.

Return Value:

    None.

Environment:

    Kernel mode, Phase 1 only.

--*/

{
    ULONG i;
    MMPTE TempPde;
    PMMPTE PointerPde;
    PMMPTE LastPde;
    PMMPTE PointerPte;
    KIRQL OldIrql;
    PMMPFN Pfn1;
    PFN_NUMBER PageFrameIndex;
    LOGICAL ValidPteFound;
    PFN_NUMBER LargePageBaseFrame;

    ASSERT (MxMapLargePages != 0);

    PointerPde = MiGetPdeAddress (VirtualAddress);
    LastPde = MiGetPdeAddress (EndVirtualAddress);

    TempPde = ValidKernelPde;
    TempPde.u.Hard.LargePage = 1;
    TempPde.u.Hard.Global = 1;

    LOCK_PFN (OldIrql);

    for ( ; PointerPde <= LastPde; PointerPde += 1) {

        ASSERT (PointerPde->u.Hard.Valid == 1);

        if (PointerPde->u.Hard.LargePage == 1) {
            continue;
        }

        PointerPte = MiGetVirtualAddressMappedByPte (PointerPde);

        //
        // Here's a nasty little hack - the page table page mapping the kernel
        // and HAL (built by the loader) does not necessarily fill all the
        // page table entries (ie: any number of leading entries may be zero).
        //
        // To deal with this, walk forward until a nonzero entry is found
        // and re-index the large page based on this.
        //

        ValidPteFound = FALSE;
        LargePageBaseFrame = (ULONG)-1;
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
    
        ASSERT ((PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) == 0);

        for (i = 0; i < PTE_PER_PAGE; i += 1) {

            ASSERT ((PointerPte->u.Long == 0) ||
                    (ValidPteFound == FALSE) ||
                    (PageFrameIndex == MI_GET_PAGE_FRAME_FROM_PTE (PointerPte)));
            if (PointerPte->u.Hard.Valid == 1) {
                if (ValidPteFound == FALSE) {
                    ValidPteFound = TRUE;
                    PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                    LargePageBaseFrame = PageFrameIndex - i;
                }
            }
            PointerPte += 1;
            PageFrameIndex += 1;
        }
    
        if (ValidPteFound == FALSE) {
            continue;
        }

        TempPde.u.Hard.PageFrameNumber = LargePageBaseFrame;

        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPde);

        MI_WRITE_VALID_PTE_NEW_PAGE (PointerPde, TempPde);

        MI_FLUSH_ENTIRE_TB (0xF);

        if (((PageFrameIndex >= MxOldSlushDescriptor1.BasePage) &&
            (PageFrameIndex < MxOldSlushDescriptor1.BasePage + MxOldSlushDescriptor1.PageCount)) ||

            ((PageFrameIndex >= MxOldSlushDescriptor2.BasePage) &&
             (PageFrameIndex < MxOldSlushDescriptor2.BasePage + MxOldSlushDescriptor2.PageCount))) {

            //
            // Excess slush is given to expansion nonpaged pool here to
            // ensure that it is always mapped fully cached since the
            // rest of the large page is inserted as fully cached into
            // the TB.
            //

            MiAddExpansionNonPagedPool (PageFrameIndex, 1, TRUE);
        }
        else {
            Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
            Pfn1->u2.ShareCount = 0;
            Pfn1->u3.e2.ReferenceCount = 1;
            Pfn1->u3.e1.PageLocation = StandbyPageList;
            MI_SET_PFN_DELETED (Pfn1);
            MiDecrementReferenceCount (Pfn1, PageFrameIndex);
        }
    }

    UNLOCK_PFN (OldIrql);
}
LOGICAL
MiIsRegularMemory (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_NUMBER PageFrameIndex
    )

/*++

Routine Description:

    This routine checks whether the argument page frame index represents
    regular memory in the loader descriptor block.  It is only used very
    early during Phase0 init because the MmPhysicalMemoryBlock is not yet
    initialized.

Arguments:

    LoaderBlock  - Supplies a pointer to the firmware setup loader block.

    PageFrameIndex  - Supplies the page frame index to check.

Return Value:

    TRUE if the frame represents regular memory, FALSE if not.

Environment:

    Kernel mode.

--*/

{
    PLIST_ENTRY NextMd;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD (NextMd,
                                              MEMORY_ALLOCATION_DESCRIPTOR,
                                              ListEntry);

        if (PageFrameIndex >= MemoryDescriptor->BasePage) {

            if (PageFrameIndex < MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) {

                if ((MemoryDescriptor->MemoryType == LoaderFirmwarePermanent) ||
                    (MemoryDescriptor->MemoryType == LoaderBBTMemory) ||
                    (MemoryDescriptor->MemoryType == LoaderSpecialMemory)) {

                    //
                    // This page lies in a memory descriptor for which we will
                    // never create PFN entries, hence return FALSE.
                    //

                    break;
                }

                return TRUE;
            }
        }
        else {

            //
            // Since the loader memory list is sorted in ascending order,
            // the requested page must not be in the loader list at all.
            //

            break;
        }

        NextMd = MemoryDescriptor->ListEntry.Flink;
    }

    //
    // The final check before returning FALSE is to ensure that the requested
    // page wasn't one of the ones we used to normal-map the loader mappings,
    // etc.
    //

    if ((PageFrameIndex >= MxOldFreeDescriptor.BasePage) &&
        (PageFrameIndex < MxOldFreeDescriptor.BasePage + MxOldFreeDescriptor.PageCount)) {

        return TRUE;
    }

    if ((PageFrameIndex >= MxOldSlushDescriptor1.BasePage) &&
        (PageFrameIndex < MxOldSlushDescriptor1.BasePage + MxOldSlushDescriptor1.PageCount)) {

        return TRUE;
    }

    if ((PageFrameIndex >= MxOldSlushDescriptor2.BasePage) &&
        (PageFrameIndex < MxOldSlushDescriptor2.BasePage + MxOldSlushDescriptor2.PageCount)) {

        return TRUE;
    }

    if ((PageFrameIndex >= MiSlushDescriptorBase) &&
        (PageFrameIndex < MiSlushDescriptorBase + MiSlushDescriptorCount)) {

        return TRUE;
    }

    return FALSE;
}

VOID
MiReportPhysicalMemory (
    VOID
    )

/*++

Routine Description:

    This routine is called during Phase 0 initialization once the
    MmPhysicalMemoryBlock has been constructed.  It's job is to decide
    which large page ranges to enable later and also to construct a
    large page comparison list so any requests which are not fully cached
    can check this list in order to refuse conflicting requests.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.  Phase 0 only.

    This is called before any non-MmCached allocations are made.

--*/

{
    ULONG i, j;
    PMMPTE PointerPte;
    LOGICAL EntryFound;
    PFN_NUMBER count;
    PFN_NUMBER Page;
    PFN_NUMBER LastPage;
    PFN_NUMBER PageFrameIndex;
    PFN_NUMBER LastPageFrameIndex;

    //
    // Examine the physical memory block to see whether large pages should
    // be enabled.  The key point is that all the physical pages within a
    // given large page range must have the same cache attributes (MmCached)
    // in order to maintain TB coherency.  This can be done provided all
    // the pages within the large page range represent real RAM (as described
    // by the loader) so that memory management can control it.  If any
    // portion of the large page range is not RAM, it is possible that it
    // may get used as noncached or writecombined device memory and
    // therefore large pages cannot be used.
    //

    if (MxMapLargePages == 0) {
        return;
    }

    for (i = 0; i < MiLargeVaRangeIndex; i += 1) {
        PointerPte = MiGetPteAddress (MiLargeVaRanges[i].VirtualAddress);
        ASSERT (PointerPte->u.Hard.Valid == 1);
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

        PointerPte = MiGetPteAddress (MiLargeVaRanges[i].EndVirtualAddress);
        ASSERT (PointerPte->u.Hard.Valid == 1);
        LastPageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

        //
        // Round the start down to a page directory boundary and the end to
        // the last page directory entry before the next boundary.
        //

        PageFrameIndex &= ~(MM_PFN_MAPPED_BY_PDE - 1);
        LastPageFrameIndex |= (MM_PFN_MAPPED_BY_PDE - 1);

        EntryFound = FALSE;

        j = 0;
        do {

            count = MmPhysicalMemoryBlock->Run[j].PageCount;
            Page = MmPhysicalMemoryBlock->Run[j].BasePage;

            LastPage = Page + count;

            if ((PageFrameIndex >= Page) && (LastPageFrameIndex < LastPage)) {
                EntryFound = TRUE;
                break;
            }

            j += 1;

        } while (j != MmPhysicalMemoryBlock->NumberOfRuns);

        if (EntryFound == FALSE) {

            //
            // No entry was found that completely spans this large page range.
            // Zero it so this range will not be converted into large pages
            // later.
            //

            DbgPrintEx (DPFLTR_MM_ID, DPFLTR_WARNING_LEVEL, 
                "MM: Loader/HAL memory block indicates large pages cannot be used\n");

            MiLargeVaRanges[i].VirtualAddress = NULL;

            //
            // Don't use large pages for anything if any individual range
            // could not be used.  This is because 2 separate ranges may
            // share a straddling large page.  If the first range was unable
            // to use large pages, but the second one does ... then only part
            // of the first range will get large pages if we enable large
            // pages for the second range.  This would be very bad as we use
            // the MI_IS_PHYSICAL macro everywhere and assume the entire
            // range is in or out, so disable all large pages here instead.
            //

            while (i != 0) {

                i -= 1;

                if (MiLargeVaRanges[i].VirtualAddress != NULL) {

                    PointerPte = MiGetPteAddress (MiLargeVaRanges[i].VirtualAddress);
                    ASSERT (PointerPte->u.Hard.Valid == 1);
                    PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

                    PointerPte = MiGetPteAddress (MiLargeVaRanges[i].EndVirtualAddress);
                    ASSERT (PointerPte->u.Hard.Valid == 1);
                    LastPageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

                    //
                    // Round the start down to a page directory boundary and
                    // the end to the last page directory entry before the
                    // next boundary.
                    //

                    PageFrameIndex &= ~(MM_PFN_MAPPED_BY_PDE - 1);
                    LastPageFrameIndex |= (MM_PFN_MAPPED_BY_PDE - 1);

                    MiRemoveCachedRange (PageFrameIndex, LastPageFrameIndex);
                }
            }

            MiLargeVaRangeIndex = 0;
            break;
        }
        else {
            MiAddCachedRange (PageFrameIndex, LastPageFrameIndex);
        }
    }
}

VOID
MxPopulatePageDirectories (
    IN PMMPTE StartPde,
    IN PMMPTE EndPde
    )

/*++

Routine Description:

    This routine allocates page parents, directories and tables as needed.
    Note any new page tables needed to map the range get zero filled.

Arguments:

    StartPde - Supplies the PDE to begin the population at.

    EndPde - Supplies the PDE to end the population at.

Return Value:

    None.

Environment:

    Kernel mode.  Phase 0 initialization.

--*/

{
    PMMPTE StartPxe;
    PMMPTE StartPpe;
    MMPTE TempPte;
    LOGICAL First;

    First = TRUE;
    TempPte = ValidKernelPte;

    while (StartPde <= EndPde) {

        if (First == TRUE || MiIsPteOnPdeBoundary(StartPde)) {
            First = FALSE;

            StartPxe = MiGetPdeAddress(StartPde);
            if (StartPxe->u.Hard.Valid == 0) {

                //
                // Map in a page directory parent page, using the
                // slush descriptor if one exists.
                //

                TempPte.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);
                *StartPxe = TempPte;
                RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPxe),
                               PAGE_SIZE);
            }

            StartPpe = MiGetPteAddress(StartPde);
            if (StartPpe->u.Hard.Valid == 0) {

                //
                // Map in a page directory, using the
                // slush descriptor if one exists.
                //

                TempPte.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);
                *StartPpe = TempPte;
                RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPpe),
                               PAGE_SIZE);
            }
        }

        if (StartPde->u.Hard.Valid == 0) {

            //
            // Map in a page table page, using the
            // slush descriptor if one exists.
            //

            TempPte.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);
            *StartPde = TempPte;
            RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPde),
                           PAGE_SIZE);
        }
        StartPde += 1;
    }
}

VOID
MiComputeInitialLargePage (
    VOID
    )

/*++

Routine Description:

    This function computes the number of bytes needed to span the initial
    nonpaged pool and PFN database plus the color arrays.  It rounds this up
    to a large page boundary and carves the memory from the free descriptor.

    If the physical memory is too sparse to use large pages for this, then
    fall back to using small pages.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode, INIT only.

--*/

{
    PFN_NUMBER i;
    PFN_NUMBER BasePage;
    PFN_NUMBER LastPage;
    UCHAR Associativity;
    SIZE_T NumberOfBytes;
    SIZE_T PfnAllocation;
    SIZE_T MaximumNonPagedPoolInBytesLimit;

    MaximumNonPagedPoolInBytesLimit = 0;

    //
    // Non-paged pool comprises 2 chunks.  The initial nonpaged pool grows
    // up and the expansion nonpaged pool expands downward.
    //
    // Initial non-paged pool is constructed so virtual addresses
    // are also physically contiguous.
    //

    if ((MmSizeOfNonPagedPoolInBytes >> PAGE_SHIFT) >
                        (7 * (MxTotalFreePages >> 3))) {

        //
        // More than 7/8 of memory allocated to nonpagedpool, reset to 0.
        //

        MmSizeOfNonPagedPoolInBytes = 0;
    }

    if (MmSizeOfNonPagedPoolInBytes < MmMinimumNonPagedPoolSize) {

        //
        // Calculate the size of nonpaged pool.
        // Use the minimum size, then for every MB above 16mb add extra pages.
        //

        MmSizeOfNonPagedPoolInBytes = MmMinimumNonPagedPoolSize;

        MmSizeOfNonPagedPoolInBytes +=
            ((MxTotalFreePages - _x16mbnp)/_x1mbnp) *
            MmMinAdditionNonPagedPoolPerMb;
    }

    if (MmSizeOfNonPagedPoolInBytes > MM_MAX_INITIAL_NONPAGED_POOL) {
        MmSizeOfNonPagedPoolInBytes = MM_MAX_INITIAL_NONPAGED_POOL;
    }

    //
    // If the registry specifies a total nonpaged pool percentage cap, enforce
    // it here.
    //

    if (MmMaximumNonPagedPoolPercent != 0) {

        if (MmMaximumNonPagedPoolPercent < 5) {
            MmMaximumNonPagedPoolPercent = 5;
        }
        else if (MmMaximumNonPagedPoolPercent > 80) {
            MmMaximumNonPagedPoolPercent = 80;
        }

        //
        // Use the registry-expressed percentage value.
        //
    
        MaximumNonPagedPoolInBytesLimit =
            ((MxTotalFreePages * MmMaximumNonPagedPoolPercent) / 100);

        MaximumNonPagedPoolInBytesLimit *= PAGE_SIZE;

        if (MaximumNonPagedPoolInBytesLimit < 6 * 1024 * 1024) {
            MaximumNonPagedPoolInBytesLimit = 6 * 1024 * 1024;
        }

        if (MmSizeOfNonPagedPoolInBytes > MaximumNonPagedPoolInBytesLimit) {
            MmSizeOfNonPagedPoolInBytes = MaximumNonPagedPoolInBytesLimit;
        }
    }
    
    MmSizeOfNonPagedPoolInBytes = MI_ROUND_TO_SIZE (MmSizeOfNonPagedPoolInBytes,
                                                    PAGE_SIZE);

    //
    // Don't let the initial nonpaged pool choice exceed what's actually
    // available.
    //

    if ((MmSizeOfNonPagedPoolInBytes >> PAGE_SHIFT) > MxFreeDescriptor->PageCount / 2) {
        MmSizeOfNonPagedPoolInBytes = (MxFreeDescriptor->PageCount / 2) << PAGE_SHIFT;
    }

    //
    // Compute the secondary color value, allowing overrides from the registry.
    // This is because the color arrays are going to be allocated at the end
    // of the PFN database.
    //
    // Get secondary color value from:
    //
    // (a) from the registry (already filled in) or
    // (b) from the PCR or
    // (c) default value.
    //

    if (MmSecondaryColors == 0) {

        Associativity = KeGetPcr()->SecondLevelCacheAssociativity;

        MmSecondaryColors = KeGetPcr()->SecondLevelCacheSize;

        if (Associativity != 0) {
            MmSecondaryColors /= Associativity;
        }
    }

    MmSecondaryColors = MmSecondaryColors >> PAGE_SHIFT;

    if (MmSecondaryColors == 0) {
        MmSecondaryColors = MM_SECONDARY_COLORS_DEFAULT;
    }
    else {

        //
        // Make sure the value is power of two and within limits.
        //

        if (MmSecondaryColors > MM_SECONDARY_COLORS_MAX) {
            MmSecondaryColors = MM_SECONDARY_COLORS_MAX;
        }
        else if (((MmSecondaryColors & (MmSecondaryColors - 1)) != 0) ||
                 (MmSecondaryColors < MM_SECONDARY_COLORS_MIN)) {

            MmSecondaryColors = MM_SECONDARY_COLORS_DEFAULT;
        }
    }

    MmSecondaryColorMask = MmSecondaryColors - 1;

    //
    // Set the secondary color mask on the boot processor since it is needed
    // very early.
    //

    KeGetCurrentPrcb()->SecondaryColorMask = MmSecondaryColorMask;

    //
    // Determine number of bits in MmSecondayColorMask. This
    // is the number of bits the Node color must be shifted
    // by before it is included in colors.
    //

    i = MmSecondaryColorMask;
    MmSecondaryColorNodeShift = 0;
    while (i) {
        i >>= 1;
        MmSecondaryColorNodeShift += 1;
    }

    //
    // Adjust the number of secondary colors by the number of nodes
    // in the machine.  The secondary color mask is NOT adjusted
    // as it is used to control coloring within a node.  The node
    // color is added to the color AFTER normal color calculations
    // are performed.
    //

    MmSecondaryColors *= KeNumberNodes;

    for (i = 0; i < KeNumberNodes; i += 1) {
        KeNodeBlock[i]->Color = (UCHAR)i;
        KeNodeBlock[i]->MmShiftedColor = (ULONG)(i << MmSecondaryColorNodeShift);
        InitializeSListHead(&KeNodeBlock[i]->DeadStackList);
    }

    //
    // Add in the PFN database size and the array for tracking secondary colors.
    //

    PfnAllocation = MI_ROUND_TO_SIZE (((MmHighestPossiblePhysicalPage + 1) * sizeof(MMPFN)) +
                    (MmSecondaryColors * sizeof(MMCOLOR_TABLES)*2),
                    PAGE_SIZE);

    NumberOfBytes = MmSizeOfNonPagedPoolInBytes + PfnAllocation;

    //
    // Align to large page size boundary, donating any extra to the nonpaged
    // pool.
    //

    NumberOfBytes = MI_ROUND_TO_SIZE (NumberOfBytes, MM_MINIMUM_VA_FOR_LARGE_PAGE);

    MmSizeOfNonPagedPoolInBytes = NumberOfBytes - PfnAllocation;

    MxPfnAllocation = PfnAllocation >> PAGE_SHIFT;

    //
    // Calculate the maximum size of pool.
    //

    if (MmMaximumNonPagedPoolInBytes == 0) {

        //
        // Calculate the size of nonpaged pool, adding extra pages for
        // every MB above 16mb.
        //

        MmMaximumNonPagedPoolInBytes = MmDefaultMaximumNonPagedPool;

        ASSERT (BYTE_OFFSET (MmMaximumNonPagedPoolInBytes) == 0);

        MmMaximumNonPagedPoolInBytes +=
            ((SIZE_T)((MxTotalFreePages - _x16mbnp)/_x1mbnp) *
            MmMaxAdditionNonPagedPoolPerMb);

        if ((MmMaximumNonPagedPoolPercent != 0) &&
            (MmMaximumNonPagedPoolInBytes > MaximumNonPagedPoolInBytesLimit)) {
                MmMaximumNonPagedPoolInBytes = MaximumNonPagedPoolInBytesLimit;
        }
    }

    MmMaximumNonPagedPoolInBytes = MI_ROUND_TO_SIZE (MmMaximumNonPagedPoolInBytes,
                                                  MM_MINIMUM_VA_FOR_LARGE_PAGE);

    MmMaximumNonPagedPoolInBytes += NumberOfBytes;

    if (MmMaximumNonPagedPoolInBytes > MM_MAX_ADDITIONAL_NONPAGED_POOL) {
        MmMaximumNonPagedPoolInBytes = MM_MAX_ADDITIONAL_NONPAGED_POOL;
    }

    MiInitialLargePageSize = NumberOfBytes >> PAGE_SHIFT;

    if ((MmProtectFreedNonPagedPool == FALSE) &&
        (MxMapLargePages != 0) &&
        (MxPfnAllocation <= MxFreeDescriptor->PageCount / 2)) {

        //
        // See if the free descriptor has enough pages of large page alignment
        // to satisfy our calculation.
        //

        BasePage = MI_ROUND_TO_SIZE (MxFreeDescriptor->BasePage,
                                 MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT);

        LastPage = MxFreeDescriptor->BasePage + MxFreeDescriptor->PageCount;

        if ((BasePage < MxFreeDescriptor->BasePage) ||
            (BasePage + (NumberOfBytes >> PAGE_SHIFT) > LastPage)) {

            KeBugCheckEx (INSTALL_MORE_MEMORY,
                          NumberOfBytes >> PAGE_SHIFT,
                          MxFreeDescriptor->BasePage,
                          MxFreeDescriptor->PageCount,
                          2);
        }

        if (BasePage == MxFreeDescriptor->BasePage) {

            //
            // The descriptor starts on a large page aligned boundary so
            // remove the large page span from the bottom of the free descriptor.
            //

            MiInitialLargePage = BasePage;

            MxFreeDescriptor->BasePage += (ULONG) MiInitialLargePageSize;
            MxFreeDescriptor->PageCount -= (ULONG) MiInitialLargePageSize;
        }
        else {

            if ((LastPage & ((MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT) - 1)) == 0) {
                //
                // The descriptor ends on a large page aligned boundary so
                // remove the large page span from the top of the free descriptor.
                //

                MiInitialLargePage = LastPage - MiInitialLargePageSize;

                MxFreeDescriptor->PageCount -= (ULONG) MiInitialLargePageSize;
            }
            else {

                //
                // The descriptor does not start or end on a large page aligned
                // address so chop the descriptor.  The excess slush is added to
                // the freelist by our caller.
                //

                MiSlushDescriptorBase = MxFreeDescriptor->BasePage;
                MiSlushDescriptorCount = BasePage - MxFreeDescriptor->BasePage;

                MiInitialLargePage = BasePage;

                MxFreeDescriptor->PageCount -= (ULONG) (MiInitialLargePageSize + MiSlushDescriptorCount);

                MxFreeDescriptor->BasePage = (ULONG) (BasePage + MiInitialLargePageSize);
            }
        }

        MiAddCachedRange (MiInitialLargePage,
                          MiInitialLargePage + MiInitialLargePageSize - 1);
    }
    else {

        //
        // Not enough contiguous physical memory in this machine to use large
        // pages for the PFN database and color heads so fall back to small.
        //
        // Continue to march on so the virtual sizes can still be computed
        // properly.
        //
        // Note this is not large page aligned so it can never be confused with
        // a valid large page start.
        //

        MiInitialLargePage = (PFN_NUMBER) -1;
    }

    MmPfnDatabase = (PMMPFN) ((PCHAR)MmNonPagedPoolEnd - MmMaximumNonPagedPoolInBytes);

    MmNonPagedPoolStart = (PVOID)((PCHAR) MmPfnDatabase + PfnAllocation);

    ASSERT (BYTE_OFFSET (MmNonPagedPoolStart) == 0);

    MmNonPagedPoolExpansionStart = (PVOID)((PCHAR) MmPfnDatabase +
                                        (MiInitialLargePageSize << PAGE_SHIFT));

    MmMaximumNonPagedPoolInBytes = ((PCHAR) MmNonPagedPoolEnd - (PCHAR) MmNonPagedPoolStart);

    MmMaximumNonPagedPoolInPages = (MmMaximumNonPagedPoolInBytes >> PAGE_SHIFT);

    return;
}

PMEMORY_ALLOCATION_DESCRIPTOR
MiFindDescriptor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_NUMBER PageFrameIndex
    )
{
    PLIST_ENTRY NextMd;
    PFN_NUMBER PageCount;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;

    PageCount = MM_PFN_MAPPED_BY_PDE - (PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1));

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD (NextMd,
                                              MEMORY_ALLOCATION_DESCRIPTOR,
                                              ListEntry);

        if (MemoryDescriptor->BasePage == PageFrameIndex) {

            //
            // Found the descriptor following the image.  If
            // it is marked firmware temporary and it spans
            // to the *next* large page boundary, then it's good.
            //

            if ((MemoryDescriptor->MemoryType == LoaderFirmwareTemporary) &&
                (MemoryDescriptor->PageCount == PageCount) &&
                (MemoryDescriptor != MxFreeDescriptor)) {

                return MemoryDescriptor;
            }

            break;
        }

        NextMd = MemoryDescriptor->ListEntry.Flink;
    }

    return NULL;
}


VOID
MiInitMachineDependent (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine performs the necessary operations to enable virtual
    memory. This includes building the page directory parent pages and
    the page directories for the system, building page table pages to map
    the code section, the data section, the stack section and the trap handler.

    It also initializes the PFN database and populates the free list.

Arguments:

    LoaderBlock - Supplies the address of the loader block.

Return Value:

    None.

Environment:

    Kernel mode.

    N.B.  This routine uses memory from the loader block descriptors, but
    the descriptors themselves must be restored prior to return as our caller
    walks them to create the MmPhysicalMemoryBlock.

--*/

{
    PHYSICAL_ADDRESS MaxHotPlugMemoryAddress;
    PVOID EndVirtualAddress;
    PVOID va;
    PVOID SystemPteStart;
    ULONG UseGlobal;
    PFN_NUMBER BasePage;
    PFN_NUMBER PageCount;
    PFN_NUMBER NextPhysicalPage;
    PFN_COUNT FreeNumberOfPages;
    ULONG_PTR DirBase;
    LOGICAL First;
    PMMPFN BasePfn;
    PMMPFN BottomPfn;
    PMMPFN TopPfn;
    PFN_NUMBER i;
    PFN_NUMBER j;
    PFN_NUMBER PdePageNumber;
    PFN_NUMBER PxePage;
    PFN_NUMBER PpePage;
    PFN_NUMBER PdePage;
    PFN_NUMBER PtePage;
    PEPROCESS CurrentProcess;
    PFN_NUMBER MostFreePage;
    PLIST_ENTRY NextMd;
    SIZE_T MaxPool;
    KIRQL OldIrql;
    MMPTE TempPte;
    MMPTE TempPde;
    PMMPTE PointerPde;
    PMMPTE PointerPte;
    PMMPTE LastPte;
    PMMPTE Pde;
    PMMPTE StartPxe;
    PMMPTE EndPxe;
    PMMPTE StartPpe;
    PMMPTE EndPpe;
    PMMPTE StartPde;
    PMMPTE EndPde;
    PMMPTE StartPte;
    PMMPTE EndPte;
    PMMPFN Pfn1;
    PFN_NUMBER PageFrameIndex;
    PMMPFN Pfn2;
    PMMPFN Pfn3;
    PMMPFN Pfn4;
    ULONG_PTR Range;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    PLIST_ENTRY NextEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR TempSlushDescriptor;
    ULONG ReturnedLength;
    NTSTATUS status;
    PMMPTE Kseg0StartPte;
    PMMPTE Kseg0EndPte;
    ULONG DummyFlags;

    if (InitializationPhase == 1) {

        //
        // If the number of physical pages is greater than 255mb and the
        // verifier is not enabled, then map the kernel and HAL images
        // with large pages.
        //
        // The PFN database and initial nonpaged pool are already
        // mapped with large pages.
        //

        if (MxMapLargePages != 0) {
            for (i = 0; i < MiLargeVaRangeIndex; i += 1) {
                if (MiLargeVaRanges[i].VirtualAddress != NULL) {
                    MxConvertToLargePage (MiLargeVaRanges[i].VirtualAddress,
                                          MiLargeVaRanges[i].EndVirtualAddress);
                }
            }
        }

        return;
    }

    ASSERT (InitializationPhase == 0);

    //
    // All AMD64 processors support PAT mode and global pages.
    //

    ASSERT (KeFeatureBits & KF_PAT);
    ASSERT (KeFeatureBits & KF_GLOBAL_PAGE);

    MostFreePage = 0;

    ASSERT (KeFeatureBits & KF_LARGE_PAGE);

    ValidKernelPte.u.Long = ValidKernelPteLocal.u.Long;
    ValidKernelPde.u.Long = ValidKernelPdeLocal.u.Long;

    //
    // Note that the PAE mode of the processor does not support the
    // global bit in PDEs which map 4K page table pages.
    //

    TempPte = ValidKernelPte;
    TempPde = ValidKernelPde;

    //
    // Set the directory base for the system process.
    //

    PointerPte = MiGetPxeAddress (PXE_BASE);
    PdePageNumber = MI_GET_PAGE_FRAME_FROM_PTE(PointerPte);

    DirBase = MI_GET_PAGE_FRAME_FROM_PTE(PointerPte) << PAGE_SHIFT;

    PsGetCurrentProcess()->Pcb.DirectoryTableBase[0] = DirBase;
    KeSweepDcache (FALSE);

    //
    // Unmap the user memory space.
    //

    PointerPde = MiGetPxeAddress (0);
    LastPte = MiGetPxeAddress (MM_SYSTEM_RANGE_START);

    MiZeroMemoryPte (PointerPde, LastPte - PointerPde);

    //
    // Get the lower bound of the free physical memory and the number of
    // physical pages by walking the memory descriptor lists.
    //

    MxFreeDescriptor = NULL;
    ASSERT (MxTotalFreePages == 0);
    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(NextMd,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        if ((MemoryDescriptor->MemoryType != LoaderFirmwarePermanent) &&
            (MemoryDescriptor->MemoryType != LoaderBBTMemory) &&
            (MemoryDescriptor->MemoryType != LoaderHALCachedMemory) &&
            (MemoryDescriptor->MemoryType != LoaderSpecialMemory)) {

            //
            // This check results in /BURNMEMORY chunks not being counted.
            //

            if (MemoryDescriptor->MemoryType != LoaderBad) {
                MmNumberOfPhysicalPages += MemoryDescriptor->PageCount;
            }

            if (MemoryDescriptor->BasePage < MmLowestPhysicalPage) {
                MmLowestPhysicalPage = MemoryDescriptor->BasePage;
            }

            if ((MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) >
                                                             MmHighestPhysicalPage) {
                MmHighestPhysicalPage =
                        MemoryDescriptor->BasePage + MemoryDescriptor->PageCount - 1;
            }

            //
            // Locate the largest free descriptor.
            //

            if ((MemoryDescriptor->MemoryType == LoaderFree) ||
                (MemoryDescriptor->MemoryType == LoaderLoadedProgram) ||
                (MemoryDescriptor->MemoryType == LoaderFirmwareTemporary) ||
                (MemoryDescriptor->MemoryType == LoaderOsloaderStack)) {

                //
                // Deliberately use >= instead of just > to force our allocation
                // as high as physically possible.  This is to leave low pages
                // for drivers which may require them.
                //

                if (MemoryDescriptor->PageCount >= MostFreePage) {
                    MostFreePage = MemoryDescriptor->PageCount;
                    MxFreeDescriptor = MemoryDescriptor;
                }

                MxTotalFreePages += MemoryDescriptor->PageCount;
            }
        }

        NextMd = MemoryDescriptor->ListEntry.Flink;
    }

    //
    // This flag is registry-settable so check before overriding.
    //
    // Enabling special IRQL automatically disables mapping the kernel with
    // large pages so we can catch kernel and HAL code.
    //

    if (MmVerifyDriverBufferLength != (ULONG)-1) {
        MmLargePageMinimum = (ULONG)-2;
    }
    else if (MmLargePageMinimum == 0) {
        MmLargePageMinimum = MM_LARGE_PAGE_MINIMUM;
    }

    if (MmNumberOfPhysicalPages <= MmLargePageMinimum) {
        MxMapLargePages = 0;
    }

    //
    // MmDynamicPfn may have been initialized based on the registry to
    // a value representing the highest physical address in gigabytes.
    //

    MmDynamicPfn *= ((1024 * 1024 * 1024) / PAGE_SIZE);

    //
    // Retrieve highest hot plug memory range from the HAL if
    // available and not otherwise retrieved from the registry.
    //

    if (MmDynamicPfn == 0) {

        status = HalQuerySystemInformation(
                     HalQueryMaxHotPlugMemoryAddress,
                     sizeof(PHYSICAL_ADDRESS),
                     (PPHYSICAL_ADDRESS) &MaxHotPlugMemoryAddress,
                     &ReturnedLength);

        if (NT_SUCCESS(status)) {
            ASSERT (ReturnedLength == sizeof(PHYSICAL_ADDRESS));

            MmDynamicPfn = (PFN_NUMBER) (MaxHotPlugMemoryAddress.QuadPart / PAGE_SIZE);
        }
    }

    if (MmDynamicPfn != 0) {
        MmHighestPossiblePhysicalPage = MI_DTC_MAX_PAGES - 1;
        if (MmDynamicPfn - 1 < MmHighestPossiblePhysicalPage) {
            if (MmDynamicPfn - 1 < MmHighestPhysicalPage) {
                MmDynamicPfn = MmHighestPhysicalPage + 1;
            }
            MmHighestPossiblePhysicalPage = MmDynamicPfn - 1;
        }
    }
    else {
        MmHighestPossiblePhysicalPage = MmHighestPhysicalPage;
    }

    //
    // Only machines with at least 5GB of physical memory get to use this.
    //

    if (strstr(LoaderBlock->LoadOptions, "NOLOWMEM")) {
        if (MmNumberOfPhysicalPages >= ((ULONGLONG)5 * 1024 * 1024 * 1024 / PAGE_SIZE)) {
            MiNoLowMemory = (PFN_NUMBER)((ULONGLONG)_4gb / PAGE_SIZE);
        }
    }

    if (MiNoLowMemory != 0) {
        MmMakeLowMemory = TRUE;
    }

    //
    // Save the original descriptor value as everything must be restored
    // prior to this function returning.
    //

    *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldFreeDescriptor = *MxFreeDescriptor;

    if (MmNumberOfPhysicalPages < 2048) {
        KeBugCheckEx(INSTALL_MORE_MEMORY,
                     MmNumberOfPhysicalPages,
                     MmLowestPhysicalPage,
                     MmHighestPhysicalPage,
                     0);
    }

    //
    // Initialize no-execute access permissions.
    //

    for (i = 0; i < 32; i += 1) {
        j = i & 7;
        switch (j) {
            case MM_READONLY:
            case MM_READWRITE:
            case MM_WRITECOPY:
                MmProtectToPteMask[i] |= MmPaeMask;
                break;
            default:
                break;
        }
    }

    ValidUserPte.u.Long |= MmPaeMask;

    //
    // Compute the size of the initial nonpaged pool and the PFN database.
    // This is because we will remove this amount from the free descriptor
    // first and subsequently map it with large TB entries (so it requires
    // natural alignment & size, thus take it before other allocations chip
    // away at the descriptor).
    //

    MiComputeInitialLargePage ();

    //
    // Calculate the starting address for nonpaged system space rounded
    // down to a second level PDE mapping boundary.
    //

    MmNonPagedSystemStart = (PVOID)(((ULONG_PTR)MmPfnDatabase -
                                (((ULONG_PTR)MmNumberOfSystemPtes + 1) * PAGE_SIZE)) &
                                                        (~PAGE_DIRECTORY2_MASK));

    if (MmNonPagedSystemStart < MM_LOWEST_NONPAGED_SYSTEM_START) {
        MmNonPagedSystemStart = MM_LOWEST_NONPAGED_SYSTEM_START;
        MmNumberOfSystemPtes = (ULONG)(((ULONG_PTR)MmPfnDatabase -
                                (ULONG_PTR)MmNonPagedSystemStart) >> PAGE_SHIFT)-1;
        ASSERT (MmNumberOfSystemPtes > 1000);
    }

    //
    // Snap the system PTE start address as page directories and tables
    // will be preallocated for this range.
    //

    SystemPteStart = (PVOID) MmNonPagedSystemStart;

    //
    // If special pool and/or the driver verifier is enabled, reserve
    // extra virtual address space for special pooling now.  For now,
    // arbitrarily don't let it be larger than paged pool (128gb).
    //

    if ((MmVerifyDriverBufferLength != (ULONG)-1) ||
        ((MmSpecialPoolTag != 0) && (MmSpecialPoolTag != (ULONG)-1))) {

        if (MmNonPagedSystemStart > MM_LOWEST_NONPAGED_SYSTEM_START) {
            MaxPool = (ULONG_PTR)MmNonPagedSystemStart -
                      (ULONG_PTR)MM_LOWEST_NONPAGED_SYSTEM_START;
            if (MaxPool > MM_MAX_PAGED_POOL) {
                MaxPool = MM_MAX_PAGED_POOL;
            }
            MmNonPagedSystemStart = (PVOID)((ULONG_PTR)MmNonPagedSystemStart - MaxPool);
        }
        else {

            //
            // This is a pretty large machine.  Take some of the system
            // PTEs and reuse them for special pool.
            //

            MaxPool = (4 * _x4gb);
            ASSERT ((PVOID)MmPfnDatabase > (PVOID)((PCHAR)MmNonPagedSystemStart + MaxPool));
            SystemPteStart = (PVOID)((PCHAR)MmNonPagedSystemStart + MaxPool);

            MmNumberOfSystemPtes = (ULONG)(((ULONG_PTR)MmPfnDatabase -
                            (ULONG_PTR) SystemPteStart) >> PAGE_SHIFT)-1;

        }
        MmSpecialPoolStart = MmNonPagedSystemStart;
        MmSpecialPoolEnd = (PVOID)((ULONG_PTR)MmNonPagedSystemStart + MaxPool);
    }

    //
    // Set the global bit for all PDEs in system space.
    //

    StartPde = MiGetPdeAddress (MM_SYSTEM_SPACE_START);
    EndPde = MiGetPdeAddress (MM_SYSTEM_SPACE_END);
    First = TRUE;

    while (StartPde <= EndPde) {

        if (First == TRUE || MiIsPteOnPdeBoundary(StartPde)) {
            First = FALSE;

            StartPxe = MiGetPdeAddress(StartPde);
            if (StartPxe->u.Hard.Valid == 0) {
                StartPxe += 1;
                StartPpe = MiGetVirtualAddressMappedByPte (StartPxe);
                StartPde = MiGetVirtualAddressMappedByPte (StartPpe);
                continue;
            }

            StartPpe = MiGetPteAddress(StartPde);
            if (StartPpe->u.Hard.Valid == 0) {
                StartPpe += 1;
                StartPde = MiGetVirtualAddressMappedByPte (StartPpe);
                continue;
            }
        }

        TempPte = *StartPde;
        TempPte.u.Hard.Global = 1;
        *StartPde = TempPte;
        StartPde += 1;
    }

    MI_FLUSH_CURRENT_TB ();

    //
    // Allocate page directory parents, directories and page table pages for
    // system PTEs and expansion nonpaged pool.
    //

    TempPte = ValidKernelPte;
    StartPde = MiGetPdeAddress (SystemPteStart);
    EndPde = MiGetPdeAddress ((PCHAR)MmPfnDatabase - 1);

    MxPopulatePageDirectories (StartPde, EndPde);

    StartPde = MiGetPdeAddress ((PVOID)((ULONG_PTR)MmPfnDatabase +
                    (MiInitialLargePageSize << PAGE_SHIFT)));
    EndPde = MiGetPdeAddress ((PCHAR)MmNonPagedPoolEnd - 1);

    MxPopulatePageDirectories (StartPde, EndPde);

    //
    // If the number of physical pages is greater than 255mb and the
    // verifier is not enabled, then map the kernel and HAL images
    // with large pages.
    //

    if (MxMapLargePages != 0) {

        //
        // Add the kernel and HAL ranges to the large page ranges.
        //
        // Ensure any slush in the encompassing large page(s) is always mapped
        // as cached to prevent TB cache attribute conflicts.
        //
        // Note that the MxFreeDescriptor may already be pointing at the slush.
        //

        NextEntry = LoaderBlock->LoadOrderListHead.Flink;

        DataTableEntry = CONTAINING_RECORD (NextEntry,
                                            KLDR_DATA_TABLE_ENTRY,
                                            InLoadOrderLinks);

        //
        // Compute the physical page range spanned by the kernel and the HAL.
        // The potential large page ranges (which may be one single range,
        // or two distinct ranges which could potentially be both physically
        // and virtually discontiguous) these two images reside in must 
        // contain only each other and/or FirmwareTemporary spans.  If there
        // is anything else in the ranges then we cannot guarantee there
        // will be no cache attribute conflicts so don't use large pages.
        //

        TempSlushDescriptor = NULL;
        PointerPte = MiGetPteAddress (DataTableEntry->DllBase);
        ASSERT (MI_IS_PTE_VALID (PointerPte));
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

        if ((PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) == 0) {

            PFN_NUMBER PageFrameIndexLow;
            PKLDR_DATA_TABLE_ENTRY DataTableEntryLow;
            PKLDR_DATA_TABLE_ENTRY DataTableEntrySwap;
            PVOID VirtualAddressLow;

            PageFrameIndexLow = PageFrameIndex;
            DataTableEntryLow = DataTableEntry;

            //
            // The kernel starts on a large page boundary so that's good ...
            //

            VirtualAddressLow = DataTableEntry->DllBase;
            PageFrameIndex += (DataTableEntry->SizeOfImage >> PAGE_SHIFT);

            NextEntry = NextEntry->Flink;

            DataTableEntry = CONTAINING_RECORD (NextEntry,
                                                KLDR_DATA_TABLE_ENTRY,
                                                InLoadOrderLinks);

            PointerPte = MiGetPteAddress (DataTableEntry->DllBase);
            ASSERT (MI_IS_PTE_VALID (PointerPte));

            if (MI_GET_PAGE_FRAME_FROM_PTE (PointerPte) + (DataTableEntry->SizeOfImage >> PAGE_SHIFT) == PageFrameIndexLow) {

                //
                // The HAL actually came first followed by the kernel.
                // Invert our locals so we can finish up with a single check
                // below.
                //

                DataTableEntrySwap = DataTableEntryLow;
                DataTableEntryLow = DataTableEntry;
                DataTableEntry = DataTableEntrySwap;

                PointerPte = MiGetPteAddress (DataTableEntryLow->DllBase);
                ASSERT (MI_IS_PTE_VALID (PointerPte));
                PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                PageFrameIndexLow = PageFrameIndex;
                PageFrameIndex += (DataTableEntryLow->SizeOfImage >> PAGE_SHIFT);
                VirtualAddressLow = DataTableEntryLow->DllBase;

                PointerPte = MiGetPteAddress (DataTableEntry->DllBase);
                ASSERT (MI_IS_PTE_VALID (PointerPte));
            }

            if (PageFrameIndex == MI_GET_PAGE_FRAME_FROM_PTE (PointerPte)) {

                //
                // The kernel and HAL are contiguous, note they may span
                // more than one large page and usually (but not if the
                // second image ends on a large page boundary) has slush
                // on the end.
                //

                PageFrameIndex += (DataTableEntry->SizeOfImage >> PAGE_SHIFT);
                if (PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) {

                    //
                    // Locate the slush descriptor, if one is not found then
                    // do NOT use large pages.
                    //

                    ASSERT (MxSlushDescriptor1 == NULL);

                    TempSlushDescriptor = MiFindDescriptor (LoaderBlock,
                                                            PageFrameIndex);

                    if (TempSlushDescriptor != NULL) {

                        MxSlushDescriptor1 = TempSlushDescriptor;

                        *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor1 =
                                *MxSlushDescriptor1;
                    }
                }
                else {
                    TempSlushDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR) 1;

                    //
                    // The contiguous images end exactly on a large
                    // page boundary.
                    //

                }

                if (TempSlushDescriptor != NULL) {
                    EndVirtualAddress = (PVOID)((ULONG_PTR) DataTableEntry->DllBase + DataTableEntry->SizeOfImage - 1);

                    MiLargeVaRanges[MiLargeVaRangeIndex].VirtualAddress = VirtualAddressLow;
                    MiLargeVaRanges[MiLargeVaRangeIndex].EndVirtualAddress = EndVirtualAddress;
                    MiLargeVaRangeIndex += 1;
                }
            }
            else {

                //
                // The kernel and HAL are discontiguous, thus they span
                // more than one large page and usually (but not if the image
                // ends on a large page boundary) have slush after each image.
                //
                // Note there may also even be a gap between each large page.
                //
                // The HAL does not immediately follow the kernel so check
                // for a firmware temporary descriptor following each of them
                // that must consume the rest of each large page.  Anything
                // else is unexpected (ie, a downrev loader) and so don't use
                // large pages in that case.
                //

                if (PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) {

                    //
                    // Locate the slush descriptor, if one is not found then
                    // do NOT use large pages.
                    //

                    ASSERT (MxSlushDescriptor1 == NULL);

                    TempSlushDescriptor = MiFindDescriptor (LoaderBlock,
                                                            PageFrameIndex);

                    if (TempSlushDescriptor != NULL) {

                        MxSlushDescriptor1 = TempSlushDescriptor;
                        *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor1 =
                            *MxSlushDescriptor1;
                    }
                }
                else {
                    TempSlushDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR) 1;
                }

                if (TempSlushDescriptor != NULL) {

                    MiLargeVaRanges[MiLargeVaRangeIndex].VirtualAddress =
                                            DataTableEntryLow->DllBase;

                    EndVirtualAddress = (PVOID)((ULONG_PTR) DataTableEntryLow->DllBase + DataTableEntryLow->SizeOfImage - 1);

                    MiLargeVaRanges[MiLargeVaRangeIndex].EndVirtualAddress = EndVirtualAddress;
                    MiLargeVaRangeIndex += 1;
                }

                //
                // Now check the slush for the second image.
                //

                ASSERT (PointerPte == MiGetPteAddress (DataTableEntry->DllBase));
                ASSERT (MI_IS_PTE_VALID (PointerPte));

                PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                PageFrameIndex += (DataTableEntry->SizeOfImage >> PAGE_SHIFT);

                if (PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) {

                    //
                    // Locate the slush descriptor, if one is not found then
                    // do NOT use large pages.
                    //

                    ASSERT (MxSlushDescriptor2 == NULL);

                    TempSlushDescriptor = MiFindDescriptor (LoaderBlock,
                                                            PageFrameIndex);

                    if (TempSlushDescriptor != NULL) {

                        MxSlushDescriptor2 = TempSlushDescriptor;

                        *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor2 =
                            *MxSlushDescriptor2;
                    }
                }
                else {
                    TempSlushDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR) 1;
                }

                if (TempSlushDescriptor != NULL) {

                    MiLargeVaRanges[MiLargeVaRangeIndex].VirtualAddress =
                                            DataTableEntry->DllBase;

                    EndVirtualAddress = (PVOID)((ULONG_PTR) DataTableEntry->DllBase + DataTableEntry->SizeOfImage - 1);

                    MiLargeVaRanges[MiLargeVaRangeIndex].EndVirtualAddress = EndVirtualAddress;
                    MiLargeVaRangeIndex += 1;
                }
            }
        }
    }

    //
    // Allocate page directory pages for the initial large page allocation.
    // Initial nonpaged pool, the PFN database & the color arrays are placed
    // here.
    //

    TempPte = ValidKernelPte;
    TempPde = ValidKernelPde;

    PageFrameIndex = MiInitialLargePage;

    if (MiInitialLargePage != (PFN_NUMBER) -1) {

        StartPpe = MiGetPpeAddress (MmPfnDatabase);
        StartPde = MiGetPdeAddress (MmPfnDatabase);
        EndPde = MiGetPdeAddress ((PVOID)((ULONG_PTR)MmPfnDatabase +
                    (MiInitialLargePageSize << PAGE_SHIFT) - 1));

        MI_MAKE_PDE_MAP_LARGE_PAGE (&TempPde);
    }
    else {
        StartPpe = MiGetPpeAddress (MmNonPagedPoolStart);
        StartPde = MiGetPdeAddress (MmNonPagedPoolStart);
        EndPde = MiGetPdeAddress ((PVOID)((ULONG_PTR)MmNonPagedPoolStart +
                    (MmSizeOfNonPagedPoolInBytes - 1)));
    }

    First = TRUE;

    while (StartPde <= EndPde) {

        if (First == TRUE || MiIsPteOnPdeBoundary (StartPde)) {

            if (First == TRUE || MiIsPteOnPpeBoundary (StartPde)) {

                StartPxe = MiGetPdeAddress (StartPde);

                if (StartPxe->u.Hard.Valid == 0) {

                    //
                    // Map in a page directory parent page, using the
                    // slush descriptor if one exists.
                    //

                    NextPhysicalPage = MxGetNextPage (1, TRUE);
                    TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                    MI_WRITE_VALID_PTE (StartPxe, TempPte);
                    RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPxe),
                                   PAGE_SIZE);
                }
            }

            First = FALSE;

            StartPpe = MiGetPteAddress (StartPde);

            if (StartPpe->u.Hard.Valid == 0) {

                //
                // Map in a page directory page, using the
                // slush descriptor if one exists.
                //

                NextPhysicalPage = MxGetNextPage (1, TRUE);
                TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                MI_WRITE_VALID_PTE (StartPpe, TempPte);
                RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPpe),
                               PAGE_SIZE);
            }
        }

        ASSERT (StartPde->u.Hard.Valid == 0);

        if (MiInitialLargePage != (PFN_NUMBER) -1) {
            TempPde.u.Hard.PageFrameNumber = PageFrameIndex;
            PageFrameIndex += (MM_VA_MAPPED_BY_PDE >> PAGE_SHIFT);
            MI_WRITE_VALID_PTE (StartPde, TempPde);
        }
        else {

            //
            // Allocate a page table page here since we're not using large
            // pages, using the slush descriptor if one exists.
            //

            NextPhysicalPage = MxGetNextPage (1, TRUE);
            TempPde.u.Hard.PageFrameNumber = NextPhysicalPage;
            MI_WRITE_VALID_PTE (StartPde, TempPde);
            RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPde),
                           PAGE_SIZE);

            //
            // Allocate data pages here since we're not using large pages.
            //

            PointerPte = MiGetVirtualAddressMappedByPte (StartPde);

            for (i = 0; i < PTE_PER_PAGE; i += 1) {
                NextPhysicalPage = MxGetNextPage (1, FALSE);
                TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                MI_WRITE_VALID_PTE (PointerPte, TempPte);
                RtlZeroMemory (MiGetVirtualAddressMappedByPte (PointerPte),
                               PAGE_SIZE);
                PointerPte += 1;
            }
        }

        StartPde += 1;
    }

    MmFreePagesByColor[0] = (PMMCOLOR_TABLES)
                              &MmPfnDatabase[MmHighestPossiblePhysicalPage + 1];

    if (MiInitialLargePage != (PFN_NUMBER) -1) {
        RtlZeroMemory (MmPfnDatabase, MiInitialLargePageSize << PAGE_SHIFT);
    }
    else {

        //
        // Large pages were not used because this machine's physical memory
        // was not contiguous enough.
        //
        // Go through the memory descriptors and for each physical page make
        // sure the PFN database has a valid PTE to map it.  This allows
        // machines with sparse physical memory to have a minimal PFN database.
        //

        NextPhysicalPage = MxFreeDescriptor->BasePage;
        FreeNumberOfPages = MxFreeDescriptor->PageCount;

        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

            MemoryDescriptor = CONTAINING_RECORD(NextMd,
                                                 MEMORY_ALLOCATION_DESCRIPTOR,
                                                 ListEntry);

            if ((MemoryDescriptor->MemoryType == LoaderFirmwarePermanent) ||
                (MemoryDescriptor->MemoryType == LoaderBBTMemory) ||
                (MemoryDescriptor->MemoryType == LoaderSpecialMemory)) {

                //
                // Skip these ranges.
                //

                NextMd = MemoryDescriptor->ListEntry.Flink;
                continue;
            }

            //
            // Temporarily add back in the memory allocated since Phase 0
            // began so PFN entries for it will be created and mapped.
            //
            // Note actual PFN entry allocations must be done carefully as
            // memory from the descriptor itself could get used to map
            // the PFNs for the descriptor !
            //

            if (MemoryDescriptor == MxFreeDescriptor) {
                BasePage = MxOldFreeDescriptor.BasePage;
                PageCount = (PFN_COUNT) MxOldFreeDescriptor.PageCount;
            }
            else if (MemoryDescriptor == MxSlushDescriptor1) {
                BasePage = MxOldSlushDescriptor1.BasePage;
                PageCount = MxOldSlushDescriptor1.PageCount;
            }
            else if (MemoryDescriptor == MxSlushDescriptor2) {
                BasePage = MxOldSlushDescriptor2.BasePage;
                PageCount = MxOldSlushDescriptor2.PageCount;
            }
            else {
                BasePage = MemoryDescriptor->BasePage;
                PageCount = MemoryDescriptor->PageCount;
            }

            PointerPte = MiGetPteAddress (MI_PFN_ELEMENT(BasePage));

            LastPte = MiGetPteAddress (((PCHAR)(MI_PFN_ELEMENT(
                                            BasePage + PageCount))) - 1);

            while (PointerPte <= LastPte) {

                StartPxe = MiGetPpeAddress (PointerPte);

                if (StartPxe->u.Hard.Valid == 0) {
                    TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                    ASSERT (FreeNumberOfPages != 0);
                    NextPhysicalPage += 1;
                    FreeNumberOfPages -= 1;
                    if (FreeNumberOfPages == 0) {
                        KeBugCheckEx (INSTALL_MORE_MEMORY,
                                      MmNumberOfPhysicalPages,
                                      FreeNumberOfPages,
                                      MxOldFreeDescriptor.PageCount,
                                      3);
                    }
                    MI_WRITE_VALID_PTE (StartPxe, TempPte);
                    RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPxe),
                                   PAGE_SIZE);
                }

                StartPpe = MiGetPdeAddress (PointerPte);

                if (StartPpe->u.Hard.Valid == 0) {
                    TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                    ASSERT (FreeNumberOfPages != 0);
                    NextPhysicalPage += 1;
                    FreeNumberOfPages -= 1;
                    if (FreeNumberOfPages == 0) {
                        KeBugCheckEx (INSTALL_MORE_MEMORY,
                                      MmNumberOfPhysicalPages,
                                      FreeNumberOfPages,
                                      MxOldFreeDescriptor.PageCount,
                                      3);
                    }
                    MI_WRITE_VALID_PTE (StartPpe, TempPte);
                    RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPpe),
                                   PAGE_SIZE);
                }

                StartPde = MiGetPteAddress (PointerPte);

                if (StartPde->u.Hard.Valid == 0) {
                    TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                    ASSERT (FreeNumberOfPages != 0);
                    NextPhysicalPage += 1;
                    FreeNumberOfPages -= 1;
                    if (FreeNumberOfPages == 0) {
                        KeBugCheckEx (INSTALL_MORE_MEMORY,
                                      MmNumberOfPhysicalPages,
                                      FreeNumberOfPages,
                                      MxOldFreeDescriptor.PageCount,
                                      3);
                    }
                    MI_WRITE_VALID_PTE (StartPde, TempPte);
                    RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPde),
                                   PAGE_SIZE);
                }

                if (PointerPte->u.Hard.Valid == 0) {
                    TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                    ASSERT (FreeNumberOfPages != 0);
                    NextPhysicalPage += 1;
                    FreeNumberOfPages -= 1;
                    if (FreeNumberOfPages == 0) {
                        KeBugCheckEx (INSTALL_MORE_MEMORY,
                                      MmNumberOfPhysicalPages,
                                      FreeNumberOfPages,
                                      MxOldFreeDescriptor.PageCount,
                                      3);
                    }
                    MI_WRITE_VALID_PTE (PointerPte, TempPte);
                    RtlZeroMemory (MiGetVirtualAddressMappedByPte (PointerPte),
                                   PAGE_SIZE);
                }
                PointerPte += 1;
            }

            NextMd = MemoryDescriptor->ListEntry.Flink;
        }

        //
        // Ensure the color arrays are mapped.
        //

        PointerPte = MiGetPteAddress (MmFreePagesByColor[0]);
        LastPte = MiGetPteAddress ((PCHAR)MmFreePagesByColor[0] + (2 * MmSecondaryColors * sizeof (MMCOLOR_TABLES)) - 1);

        StartPxe = MiGetPdeAddress (PointerPte);
        StartPpe = MiGetPdeAddress (PointerPte);
        PointerPde = MiGetPteAddress (PointerPte);

        while (PointerPte <= LastPte) {

            if (StartPxe->u.Hard.Valid == 0) {
                TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                ASSERT (FreeNumberOfPages != 0);
                NextPhysicalPage += 1;
                FreeNumberOfPages -= 1;
                if (FreeNumberOfPages == 0) {
                    KeBugCheckEx (INSTALL_MORE_MEMORY,
                                  MmNumberOfPhysicalPages,
                                  FreeNumberOfPages,
                                  MxOldFreeDescriptor.PageCount,
                                  3);
                }
                MI_WRITE_VALID_PTE (StartPxe, TempPte);
                RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPxe), PAGE_SIZE);
            }

            if (StartPpe->u.Hard.Valid == 0) {
                TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                ASSERT (FreeNumberOfPages != 0);
                NextPhysicalPage += 1;
                FreeNumberOfPages -= 1;
                if (FreeNumberOfPages == 0) {
                    KeBugCheckEx (INSTALL_MORE_MEMORY,
                                  MmNumberOfPhysicalPages,
                                  FreeNumberOfPages,
                                  MxOldFreeDescriptor.PageCount,
                                  3);
                }
                MI_WRITE_VALID_PTE (StartPpe, TempPte);
                RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPpe), PAGE_SIZE);
            }

            if (PointerPde->u.Hard.Valid == 0) {
                TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                ASSERT (FreeNumberOfPages != 0);
                NextPhysicalPage += 1;
                FreeNumberOfPages -= 1;
                if (FreeNumberOfPages == 0) {
                    KeBugCheckEx (INSTALL_MORE_MEMORY,
                                  MmNumberOfPhysicalPages,
                                  FreeNumberOfPages,
                                  MxOldFreeDescriptor.PageCount,
                                  3);
                }
                MI_WRITE_VALID_PTE (PointerPde, TempPte);
                RtlZeroMemory (MiGetVirtualAddressMappedByPte (PointerPde), PAGE_SIZE);
            }

            if (PointerPte->u.Hard.Valid == 0) {
                TempPte.u.Hard.PageFrameNumber = NextPhysicalPage;
                ASSERT (FreeNumberOfPages != 0);
                NextPhysicalPage += 1;
                FreeNumberOfPages -= 1;
                if (FreeNumberOfPages == 0) {
                    KeBugCheckEx (INSTALL_MORE_MEMORY,
                                  MmNumberOfPhysicalPages,
                                  FreeNumberOfPages,
                                  MxOldFreeDescriptor.PageCount,
                                  3);
                }
                MI_WRITE_VALID_PTE (PointerPte, TempPte);
                RtlZeroMemory (MiGetVirtualAddressMappedByPte (PointerPte), PAGE_SIZE);
            }

            PointerPte += 1;
            if (MiIsPteOnPdeBoundary (PointerPte)) {
                PointerPde += 1;
                if (MiIsPteOnPdeBoundary (PointerPde)) {
                    StartPpe += 1;
                }
            }
        }

        //
        // Adjust the free descriptor for all the pages we just took.
        //

        MxFreeDescriptor->PageCount -= (LONG)(NextPhysicalPage - MxFreeDescriptor->BasePage);

        MxFreeDescriptor->BasePage = (PFN_COUNT) NextPhysicalPage;
    }

    //
    // Set subsection base to the address to zero as the PTE format allows the
    // complete address space to be spanned.
    //

    MmSubsectionBase = 0;

    //
    // There must be at least one page of system PTEs before the expanded
    // nonpaged pool.
    //

    ASSERT (MiGetPteAddress(SystemPteStart) < MiGetPteAddress(MmNonPagedPoolExpansionStart));

    //
    // Non-paged pages now exist, build the pool structures.
    //

    MiInitializeNonPagedPool ();
    MiInitializeNonPagedPoolThresholds ();

    //
    // Before nonpaged pool can be used, the PFN database must
    // be built.  This is due to the fact that the start and end of
    // allocation bits for nonpaged pool are maintained in the
    // PFN elements for the corresponding pages.
    //

    //
    // Initialize support for colored pages.
    //

    MmFreePagesByColor[1] = &MmFreePagesByColor[0][MmSecondaryColors];

    for (i = 0; i < MmSecondaryColors; i += 1) {
        MmFreePagesByColor[ZeroedPageList][i].Flink = MM_EMPTY_LIST;
        MmFreePagesByColor[ZeroedPageList][i].Blink = (PVOID) MM_EMPTY_LIST;
        MmFreePagesByColor[ZeroedPageList][i].Count = 0;
        MmFreePagesByColor[FreePageList][i].Flink = MM_EMPTY_LIST;
        MmFreePagesByColor[FreePageList][i].Blink = (PVOID) MM_EMPTY_LIST;
        MmFreePagesByColor[FreePageList][i].Count = 0;
    }

    //
    // Ensure the hyperspace and session spaces are not mapped so they don't
    // get made global by the loops below.
    //

    ASSERT (MiGetPxeAddress (HYPER_SPACE)->u.Hard.Valid == 0);
    ASSERT (MiGetPxeAddress (MM_SESSION_SPACE_DEFAULT)->u.Hard.Valid == 0);

    //
    // Go through the page table entries and for any page which is valid,
    // update the corresponding PFN database element.
    //
    // Skip anything in the 1TB physical range.
    //

    Kseg0StartPte = MiGetPteAddress (MM_KSEG0_BASE);
    Kseg0EndPte = MiGetPteAddress (MM_KSEG2_BASE);

    StartPxe = MiGetPxeAddress (NULL);
    EndPxe = StartPxe + PXE_PER_PAGE;

    for ( ; StartPxe < EndPxe; StartPxe += 1) {

        if (StartPxe->u.Hard.Valid == 0) {
            continue;
        }

        va = MiGetVirtualAddressMappedByPxe (StartPxe);
        ASSERT (va >= MM_SYSTEM_RANGE_START);
        if (MI_IS_PAGE_TABLE_ADDRESS (va)) {
            UseGlobal = 0;
        }
        else {
            UseGlobal = 1;
        }

        ASSERT (StartPxe->u.Hard.LargePage == 0);
        ASSERT (StartPxe->u.Hard.Owner == 0);
        ASSERT (StartPxe->u.Hard.Global == 0);

        PxePage = MI_GET_PAGE_FRAME_FROM_PTE(StartPxe);

        if (MiIsRegularMemory (LoaderBlock, PxePage)) {

            Pfn1 = MI_PFN_ELEMENT(PxePage);

            Pfn1->u4.PteFrame = (DirBase >> PAGE_SHIFT);
            Pfn1->PteAddress = StartPxe;
            Pfn1->u2.ShareCount += 1;
            Pfn1->u3.e2.ReferenceCount = 1;
            Pfn1->u3.e1.PageLocation = ActiveAndValid;
            Pfn1->u3.e1.CacheAttribute = MiCached;
            MiDetermineNode (PxePage, Pfn1);
        }
        else {
            Pfn1 = NULL;
        }

        StartPpe = MiGetVirtualAddressMappedByPte (StartPxe);
        EndPpe = StartPpe + PPE_PER_PAGE;

        for ( ; StartPpe < EndPpe; StartPpe += 1) {

            if (StartPpe->u.Hard.Valid == 0) {
                continue;
            }

            ASSERT (StartPpe->u.Hard.LargePage == 0);
            ASSERT (StartPpe->u.Hard.Owner == 0);
            ASSERT (StartPpe->u.Hard.Global == 0);

            PpePage = MI_GET_PAGE_FRAME_FROM_PTE (StartPpe);

            if (MiIsRegularMemory (LoaderBlock, PpePage)) {

                Pfn2 = MI_PFN_ELEMENT (PpePage);

                Pfn2->u4.PteFrame = PxePage;
                Pfn2->PteAddress = StartPpe;
                Pfn2->u2.ShareCount += 1;
                Pfn2->u3.e2.ReferenceCount = 1;
                Pfn2->u3.e1.PageLocation = ActiveAndValid;
                Pfn2->u3.e1.CacheAttribute = MiCached;
                MiDetermineNode (PpePage, Pfn2);
            }
            else {
                Pfn2 = NULL;
            }

            ASSERT (Pfn1 != NULL);
            Pfn1->u2.ShareCount += 1;

            StartPde = MiGetVirtualAddressMappedByPte (StartPpe);
            EndPde = StartPde + PDE_PER_PAGE;

            for ( ; StartPde < EndPde; StartPde += 1) {

                if (StartPde->u.Hard.Valid == 0) {
                    continue;
                }

                ASSERT (StartPde->u.Hard.Owner == 0);
                StartPde->u.Hard.Global = UseGlobal;

                PdePage = MI_GET_PAGE_FRAME_FROM_PTE (StartPde);

                if (MiIsRegularMemory (LoaderBlock, PdePage)) {

                    Pfn3 = MI_PFN_ELEMENT (PdePage);

                    Pfn3->u4.PteFrame = PpePage;
                    Pfn3->PteAddress = StartPde;
                    Pfn3->u2.ShareCount += 1;
                    Pfn3->u3.e2.ReferenceCount = 1;
                    Pfn3->u3.e1.PageLocation = ActiveAndValid;
                    Pfn3->u3.e1.CacheAttribute = MiCached;
                    MiDetermineNode (PdePage, Pfn3);
                }
                else {
                    Pfn3 = NULL;
                }

                ASSERT (Pfn2 != NULL);
                Pfn2->u2.ShareCount += 1;

                StartPte = MiGetVirtualAddressMappedByPte (StartPde);

                if (StartPde->u.Hard.LargePage == 1) {
                    if (Pfn3 != NULL) {
                        Pfn4 = Pfn3;
                        for (i = 0; i < PDE_PER_PAGE; i += 1) {
                            Pfn4->u4.PteFrame = PpePage;
                            Pfn4->PteAddress = StartPte;
                            Pfn4->u2.ShareCount += 1;
                            Pfn4->u3.e2.ReferenceCount = 1;
                            Pfn4->u3.e1.PageLocation = ActiveAndValid;
                            Pfn4->u3.e1.CacheAttribute = MiCached;
                            MiDetermineNode (PdePage + i, Pfn4);
                            StartPte += 1;
                            Pfn4 += 1;
                        }
                    }
                }
                else {

                    EndPte = StartPte + PDE_PER_PAGE;

                    for ( ; StartPte < EndPte; StartPte += 1) {

                        if (StartPte->u.Hard.Valid == 0) {
                            continue;
                        }

                        if (StartPte->u.Hard.LargePage == 1) {
                            continue;
                        }

                        ASSERT (StartPte->u.Hard.Owner == 0);
                        StartPte->u.Hard.Global = UseGlobal;

                        PtePage = MI_GET_PAGE_FRAME_FROM_PTE (StartPte);

                        ASSERT (Pfn3 != NULL);
                        Pfn3->u2.ShareCount += 1;

                        if (!MiIsRegularMemory (LoaderBlock, PtePage)) {
                            continue;
                        }

                        Pfn4 = MI_PFN_ELEMENT (PtePage);

                        if ((MmIsAddressValid(Pfn4)) &&
                             MmIsAddressValid((PUCHAR)(Pfn4+1)-1)) {

                            if ((StartPte >= Kseg0StartPte) && (StartPte < Kseg0EndPte)) {
                                if (Pfn4->u3.e1.PageLocation == ActiveAndValid) {
                                    //
                                    // Ignore stale KSEG0 mappings - the fact
                                    // that the page is valid means we have
                                    // already used it for a lower virtual
                                    // address (like the system cache WSLEs).
                                    //

                                    continue;
                                }
                            }

                            Pfn4->u4.PteFrame = PdePage;
                            Pfn4->PteAddress = StartPte;
                            Pfn4->u2.ShareCount += 1;
                            Pfn4->u3.e2.ReferenceCount = 1;
                            Pfn4->u3.e1.PageLocation = ActiveAndValid;
                            Pfn4->u3.e1.CacheAttribute = MiCached;
                            MiDetermineNode (PtePage, Pfn4);
                        }
                    }
                }
            }
        }
    }

    //
    // If the lowest physical page is zero and the page is still unused, mark
    // it as in use. This is because we want to find bugs where a physical
    // page is specified as zero.
    //

    Pfn1 = &MmPfnDatabase[MmLowestPhysicalPage];

    if ((MmLowestPhysicalPage == 0) && (Pfn1->u3.e2.ReferenceCount == 0)) {

        ASSERT (Pfn1->u3.e2.ReferenceCount == 0);

        //
        // Make the reference count non-zero and point it into a
        // page directory.
        //

        Pde = MiGetPxeAddress (0xFFFFFFFFB0000000);
        PdePage = MI_GET_PAGE_FRAME_FROM_PTE (Pde);
        Pfn1->u4.PteFrame = PdePage;
        Pfn1->PteAddress = Pde;
        Pfn1->u2.ShareCount += 1;
        Pfn1->u3.e2.ReferenceCount = 0xfff0;
        Pfn1->u3.e1.PageLocation = ActiveAndValid;
        Pfn1->u3.e1.CacheAttribute = MiCached;
        MiDetermineNode (0, Pfn1);
    }

    //
    // Walk through the memory descriptors and add pages to the
    // free list in the PFN database.
    //
    // Since the LoaderBlock memory descriptors are ordered
    // from low physical memory address to high, walk it backwards so the
    // high physical pages go to the front of the freelists.  The thinking
    // is that pages initially allocated by the system are less likely to be
    // freed so don't waste memory below 16mb (or 4gb) that may be needed
    // by ISA drivers later.
    //

    NextMd = LoaderBlock->MemoryDescriptorListHead.Blink;

    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD(NextMd,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        i = MemoryDescriptor->PageCount;
        PageFrameIndex = MemoryDescriptor->BasePage;

        if ((MemoryDescriptor == MxSlushDescriptor1) ||
            (MemoryDescriptor == MxSlushDescriptor2)) {

            //
            // Excess slush is given to expansion nonpaged pool here to ensure
            // that it is always mapped fully cached since the rest of the
            // large page is inserted as fully cached into the TB.
            //

            MiAddExpansionNonPagedPool (PageFrameIndex, i, FALSE);
            NextMd = MemoryDescriptor->ListEntry.Blink;
            continue;
        }

        switch (MemoryDescriptor->MemoryType) {
            case LoaderBad:

                if (PageFrameIndex > MmHighestPhysicalPage) {
                    i = 0;
                }
                else if (PageFrameIndex + i > MmHighestPhysicalPage + 1) {
                    i = MmHighestPhysicalPage + 1 - PageFrameIndex;
                }

                LOCK_PFN (OldIrql);

                while (i != 0) {
                    MiInsertPageInList (&MmBadPageListHead, PageFrameIndex);
                    i -= 1;
                    PageFrameIndex += 1;
                }

                UNLOCK_PFN (OldIrql);

                break;

            case LoaderFree:
            case LoaderLoadedProgram:
            case LoaderFirmwareTemporary:
            case LoaderOsloaderStack:

                PageFrameIndex += (i - 1);
                Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

                LOCK_PFN (OldIrql);

                while (i != 0) {
                    if (Pfn1->u3.e2.ReferenceCount == 0) {

                        //
                        // Set the PTE address to the physical page for
                        // virtual address alignment checking.
                        //

                        Pfn1->PteAddress =
                                        (PMMPTE)(PageFrameIndex << PTE_SHIFT);
                        Pfn1->u3.e1.CacheAttribute = MiCached;
                        MiDetermineNode (PageFrameIndex, Pfn1);
                        MiInsertPageInFreeList (PageFrameIndex);
                    }

                    Pfn1 -= 1;
                    i -= 1;
                    PageFrameIndex -= 1;
                }

                UNLOCK_PFN (OldIrql);

                break;

            case LoaderFirmwarePermanent:
            case LoaderSpecialMemory:
            case LoaderBBTMemory:

                //
                // Skip these ranges.
                //

                break;

            default:

                PointerPte = MiGetPteAddress (KSEG0_BASE +
                                            (PageFrameIndex << PAGE_SHIFT));

                Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

                while (i != 0) {

                    //
                    // Set page as in use.
                    //

                    PointerPde = MiGetPdeAddress (KSEG0_BASE +
                                             (PageFrameIndex << PAGE_SHIFT));

                    if (Pfn1->u3.e2.ReferenceCount == 0) {
                        Pfn1->u4.PteFrame = MI_GET_PAGE_FRAME_FROM_PTE(PointerPde);
                        Pfn1->PteAddress = PointerPte;
                        Pfn1->u2.ShareCount += 1;
                        Pfn1->u3.e2.ReferenceCount = 1;
                        Pfn1->u3.e1.PageLocation = ActiveAndValid;
                        Pfn1->u3.e1.CacheAttribute = MiCached;
                        MiDetermineNode (PageFrameIndex, Pfn1);

                        if (MemoryDescriptor->MemoryType == LoaderXIPRom) {
                            Pfn1->u1.Flink = 0;
                            Pfn1->u2.ShareCount = 0;
                            Pfn1->u3.e2.ReferenceCount = 0;
                            Pfn1->u3.e1.PageLocation = 0;
                            Pfn1->u3.e1.CacheAttribute = MiCached;
                            Pfn1->u3.e1.Rom = 1;
                            Pfn1->u4.InPageError = 0;
                            Pfn1->u3.e1.PrototypePte = 1;
                        }
                    }
                    Pfn1 += 1;
                    i -= 1;
                    PageFrameIndex += 1;
                    PointerPte += 1;
                }

                break;
        }

        NextMd = MemoryDescriptor->ListEntry.Blink;
    }

    //
    // If the large page chunk came from the middle of the free descriptor (due
    // to alignment requirements), then add the pages from the split bottom
    // portion of the free descriptor now.
    //

    i = MiSlushDescriptorCount;
    NextPhysicalPage = MiSlushDescriptorBase;
    Pfn1 = MI_PFN_ELEMENT (NextPhysicalPage);

    LOCK_PFN (OldIrql);

    while (i != 0) {
        if (Pfn1->u3.e2.ReferenceCount == 0) {

            //
            // Set the PTE address to the physical page for
            // virtual address alignment checking.
            //

            Pfn1->PteAddress = (PMMPTE)(NextPhysicalPage << PTE_SHIFT);
            Pfn1->u3.e1.CacheAttribute = MiCached;
            MiDetermineNode (NextPhysicalPage, Pfn1);
            MiInsertPageInFreeList (NextPhysicalPage);
        }
        Pfn1 += 1;
        i -= 1;
        NextPhysicalPage += 1;
    }

    UNLOCK_PFN (OldIrql);

    //
    // Mark all PFN entries for the PFN pages in use.
    //

    if (MiInitialLargePage != (PFN_NUMBER) -1) {

        //
        // All PFN entries for the PFN pages in use better be marked as such.
        //

        PointerPde = MiGetPdeAddress (MmPfnDatabase);
        ASSERT (PointerPde->u.Hard.LargePage == 1);
        PageFrameIndex = (PFN_NUMBER) PointerPde->u.Hard.PageFrameNumber;
        Pfn1 = MI_PFN_ELEMENT(PageFrameIndex);
        i = MxPfnAllocation;

        do {
            Pfn1->PteAddress = (PMMPTE)(PageFrameIndex << PTE_SHIFT);
            ASSERT (Pfn1->u3.e1.PageLocation == ActiveAndValid);
            ASSERT (Pfn1->u3.e1.CacheAttribute == MiCached);
            ASSERT (Pfn1->u3.e2.ReferenceCount == 1);
            PageFrameIndex += 1;
            Pfn1 += 1;
            i -= 1;
        } while (i != 0);

        if (MmDynamicPfn == 0) {

            //
            // Scan the PFN database backward for pages that are completely
            // zero.  These pages are unused and can be added to the free list.
            //
            // This allows machines with sparse physical memory to have a
            // minimal PFN database even when mapped with large pages.
            //

            BottomPfn = MI_PFN_ELEMENT(MmHighestPhysicalPage);

            do {

                //
                // Compute the address of the start of the page that is next
                // lower in memory and scan backwards until that page address
                // is reached or just crossed.
                //

                if (((ULONG_PTR)BottomPfn & (PAGE_SIZE - 1)) != 0) {
                    BasePfn = (PMMPFN)((ULONG_PTR)BottomPfn & ~(PAGE_SIZE - 1));
                    TopPfn = BottomPfn + 1;

                }
                else {
                    BasePfn = (PMMPFN)((ULONG_PTR)BottomPfn - PAGE_SIZE);
                    TopPfn = BottomPfn;
                }

                while (BottomPfn > BasePfn) {
                    BottomPfn -= 1;
                }

                //
                // If the entire range over which the PFN entries span is
                // completely zero and the PFN entry that maps the page is
                // not in the range, then add the page to the free list.
                //

                Range = (ULONG_PTR)TopPfn - (ULONG_PTR)BottomPfn;
                if (RtlCompareMemoryUlong ((PVOID)BottomPfn, Range, 0) == Range) {

                    //
                    // Set the PTE address to the physical page for virtual
                    // address alignment checking.
                    //

                    PointerPde = MiGetPdeAddress (BasePfn);
                    ASSERT (PointerPde->u.Hard.LargePage == 1);
                    PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPde) + MiGetPteOffset (BasePfn);

                    Pfn1 = MI_PFN_ELEMENT(PageFrameIndex);

                    ASSERT (Pfn1->u3.e2.ReferenceCount == 1);
                    ASSERT (Pfn1->PteAddress == (PMMPTE)(PageFrameIndex << PTE_SHIFT));
                    Pfn1->u3.e2.ReferenceCount = 0;
                    Pfn1->PteAddress = (PMMPTE)(PageFrameIndex << PTE_SHIFT);
                    Pfn1->u3.e1.CacheAttribute = MiCached;
                    MiDetermineNode (PageFrameIndex, Pfn1);
                    MiAddExpansionNonPagedPool (PageFrameIndex, 1, FALSE);
                }
            } while (BottomPfn > MmPfnDatabase);
        }
    }
    else {

        //
        // The PFN database is sparsely allocated in small pages.
        //

        PointerPte = MiGetPteAddress (MmPfnDatabase);

        LastPte = MiGetPteAddress (MmPfnDatabase + MmHighestPhysicalPage + 1);
        if (LastPte != PAGE_ALIGN (LastPte)) {
            LastPte += 1;
        }

        StartPxe = MiGetPpeAddress (PointerPte);
        StartPpe = MiGetPdeAddress (PointerPte);
        PointerPde = MiGetPteAddress (PointerPte);

        while (PointerPte < LastPte) {

            if (StartPxe->u.Hard.Valid == 0) {
                StartPxe += 1;
                StartPpe = MiGetVirtualAddressMappedByPte (StartPxe);
                PointerPde = MiGetVirtualAddressMappedByPte (StartPpe);
                PointerPte = MiGetVirtualAddressMappedByPte (PointerPde);
                continue;
            }

            if (StartPpe->u.Hard.Valid == 0) {
                StartPpe += 1;
                StartPxe = MiGetPteAddress (StartPpe);
                PointerPde = MiGetVirtualAddressMappedByPte (StartPpe);
                PointerPte = MiGetVirtualAddressMappedByPte (PointerPde);
                continue;
            }

            if (PointerPde->u.Hard.Valid == 0) {
                PointerPde += 1;
                PointerPte = MiGetVirtualAddressMappedByPte (PointerPde);
                if (MiIsPteOnPdeBoundary (PointerPde)) {
                    StartPpe += 1;
                    if (MiIsPteOnPdeBoundary (StartPpe)) {
                        StartPxe += 1;
                    }
                }
                continue;
            }

            if (PointerPte->u.Hard.Valid == 1) {

                PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

                Pfn1->PteAddress = PointerPte;
                Pfn1->u3.e1.PageColor = 0;
                Pfn1->u3.e2.ReferenceCount = 1;
                Pfn1->u3.e1.PageLocation = ActiveAndValid;
                Pfn1->u3.e1.CacheAttribute = MiCached;
            }

            PointerPte += 1;
            if (MiIsPteOnPdeBoundary (PointerPte)) {
                PointerPde += 1;
                if (MiIsPteOnPdeBoundary (PointerPde)) {
                    StartPpe += 1;
                    if (MiIsPteOnPdeBoundary (StartPpe)) {
                        StartPxe += 1;
                    }
                }
            }
        }
    }

    //
    // Initialize the nonpaged pool.
    //

    InitializePool (NonPagedPool, 0);

    //
    // Adjust the memory descriptor to indicate that free pool has
    // been used for nonpaged pool creation.
    //
    // N.B.  This is required because the descriptors are walked upon
    // return from this routine to create the MmPhysicalMemoryBlock.
    //

    *MxFreeDescriptor = *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldFreeDescriptor;

    if (MxSlushDescriptor1 != NULL) {
        *MxSlushDescriptor1 = *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor1;
    }

    if (MxSlushDescriptor2 != NULL) {
        *MxSlushDescriptor2 = *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor2;
    }

    //
    //
    // Initialize the system PTE pool now that nonpaged pool exists.
    //

    PointerPte = MiGetPteAddress (SystemPteStart);
    ASSERT (((ULONG_PTR)PointerPte & (PAGE_SIZE - 1)) == 0);

    MmNumberOfSystemPtes = (ULONG)(MiGetPteAddress (MmPfnDatabase) - PointerPte - 1);

    MiInitializeSystemPtes (PointerPte, MmNumberOfSystemPtes, SystemPteSpace);

    //
    // Initialize the debugger PTE.
    //

    MmDebugPte = MiReserveSystemPtes (1, SystemPteSpace);

    MmDebugPte->u.Long = 0;

    MmDebugVa = MiGetVirtualAddressMappedByPte (MmDebugPte);

    MmCrashDumpPte = MiReserveSystemPtes (16, SystemPteSpace);

    MmCrashDumpVa = MiGetVirtualAddressMappedByPte (MmCrashDumpPte);

    //
    // Allocate a page directory and a pair of page table pages.
    // Map the hyper space page directory page into the top level parent
    // directory & the hyper space page table page into the page directory
    // and map an additional page that will eventually be used for the
    // working set list.  Page tables after the first two are set up later
    // on during individual process working set initialization.
    //
    // The working set list page will eventually be a part of hyper space.
    // It is mapped into the second level page directory page so it can be
    // zeroed and so it will be accounted for in the PFN database. Later
    // the page will be unmapped, and its page frame number captured in the
    // system process object.
    //

    TempPte = ValidKernelPte;
    TempPte.u.Hard.Global = 0;

    StartPxe = MiGetPxeAddress (HYPER_SPACE);
    StartPpe = MiGetPpeAddress (HYPER_SPACE);
    StartPde = MiGetPdeAddress (HYPER_SPACE);

    LOCK_PFN (OldIrql);

    if (StartPxe->u.Hard.Valid == 0) {
        ASSERT (StartPxe->u.Long == 0);
        TempPte.u.Hard.PageFrameNumber = MiRemoveAnyPage (0);
        *StartPxe = TempPte;
        RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPxe), PAGE_SIZE);
    }
    else {
        ASSERT (StartPxe->u.Hard.Global == 0);
    }

    if (StartPpe->u.Hard.Valid == 0) {
        ASSERT (StartPpe->u.Long == 0);
        TempPte.u.Hard.PageFrameNumber = MiRemoveAnyPage (0);
        *StartPpe = TempPte;
        RtlZeroMemory (MiGetVirtualAddressMappedByPte (StartPpe), PAGE_SIZE);
    }
    else {
        ASSERT (StartPpe->u.Hard.Global == 0);
    }

    TempPte.u.Hard.PageFrameNumber = MiRemoveAnyPage (0);
    *StartPde = TempPte;

    //
    // Zero the hyper space page table page.
    //

    StartPte = MiGetPteAddress (HYPER_SPACE);
    RtlZeroMemory (StartPte, PAGE_SIZE);

    PageFrameIndex = MiRemoveAnyPage (0);

    UNLOCK_PFN (OldIrql);

    //
    // Hyper space now exists, set the necessary variables.
    //

    MmFirstReservedMappingPte = MiGetPteAddress (FIRST_MAPPING_PTE);
    MmLastReservedMappingPte = MiGetPteAddress (LAST_MAPPING_PTE);

    //
    // Create zeroing PTEs for the zero page thread.
    //

    MiFirstReservedZeroingPte = MiReserveSystemPtes (NUMBER_OF_ZEROING_PTES + 1, SystemPteSpace);

    RtlZeroMemory (MiFirstReservedZeroingPte,
                   (NUMBER_OF_ZEROING_PTES + 1) * sizeof(MMPTE));

    //
    // Use the page frame number field of the first PTE as an
    // offset into the available zeroing PTEs.
    //

    MiFirstReservedZeroingPte->u.Hard.PageFrameNumber = NUMBER_OF_ZEROING_PTES;

    //
    // Create the VAD bitmap for this process.
    //

    PointerPte = MiGetPteAddress (VAD_BITMAP_SPACE);

    //
    // Note the global bit must be off for the bitmap data.
    //

    TempPte = ValidKernelPteLocal;
    TempPte.u.Hard.PageFrameNumber = PageFrameIndex;
    MI_WRITE_VALID_PTE (PointerPte, TempPte);

    //
    // Point to the page we just created and zero it.
    //

    RtlZeroMemory (VAD_BITMAP_SPACE, PAGE_SIZE);

    MiLastVadBit = (ULONG)((((ULONG_PTR) MI_64K_ALIGN (MM_HIGHEST_VAD_ADDRESS))) / X64K);
    if (MiLastVadBit > PAGE_SIZE * 8 - 1) {
        MiLastVadBit = PAGE_SIZE * 8 - 1;
    }

    //
    // Initialize this process's memory management structures including
    // the working set list.
    //

    CurrentProcess = PsGetCurrentProcess ();

    //
    // The PFN element for the page directory has already been initialized,
    // zero the reference count and the share count so they won't be wrong.
    //

    Pfn1 = MI_PFN_ELEMENT (PdePageNumber);

    LOCK_PFN (OldIrql);

    Pfn1->u2.ShareCount = 0;
    Pfn1->u3.e2.ReferenceCount = 0;

    //
    // Get a page for the working set list and zero it.
    //

    PageFrameIndex = MiRemoveAnyPage (0);

    UNLOCK_PFN (OldIrql);

    TempPte.u.Hard.PageFrameNumber = PageFrameIndex;

    PointerPte = MiGetPteAddress (MmWorkingSetList);
    MI_WRITE_VALID_PTE (PointerPte, TempPte);

    RtlZeroMemory (MmWorkingSetList, PAGE_SIZE);

    CurrentProcess->WorkingSetPage = PageFrameIndex;

    CurrentProcess->Vm.MaximumWorkingSetSize = (ULONG)MmSystemProcessWorkingSetMax;
    CurrentProcess->Vm.MinimumWorkingSetSize = (ULONG)MmSystemProcessWorkingSetMin;

    DummyFlags = 0;
    MmInitializeProcessAddressSpace (CurrentProcess, NULL, NULL, &DummyFlags, NULL);

    return;
}

DECLSPEC_NOINLINE
VOID
MiGetStackPointer (
    OUT PULONG_PTR StackPointer
    )

/*++

Routine Description:

    This routine retrieves the stack pointer of the calling function.

Arguments:

    StackPointer - Supplies a pointer to the stack pointer return value.

Return Value:

    None.

Environment:

    Any.

--*/

{
    //
    // The AMD64 calling convention dictates that the home address of a
    // callee's first parameter is the caller's stack pointer.
    //

    *StackPointer = (ULONG_PTR)&StackPointer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\i386\data386.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   data386.c

Abstract:

    This module contains the private hardware specific global storage for
    the memory management subsystem.

--*/

#include "mi.h"

//
// A zero Pte.
//

const MMPTE ZeroPte = { 0 };

//
// A kernel zero PTE.
//

const MMPTE ZeroKernelPte = {0x0};

MMPTE MmPteGlobal = {0x0}; // Set global bit later if processor supports Global Page

//
// Note - MM_PTE_GLOBAL_MASK is or'ed into ValidKernelPte during
// initialization if the processor supports Global Page.  Use
// ValidKernelPteLocal if you don't want the global bit (ie: for session
// space).
//

MMPTE ValidKernelPte = { MM_PTE_VALID_MASK |
                         MM_PTE_WRITE_MASK |
                         MM_PTE_DIRTY_MASK |
                         MM_PTE_ACCESS_MASK };

const MMPTE ValidKernelPteLocal = { MM_PTE_VALID_MASK |
                                    MM_PTE_WRITE_MASK |
                                    MM_PTE_DIRTY_MASK |
                                    MM_PTE_ACCESS_MASK };


const MMPTE ValidUserPte = { MM_PTE_VALID_MASK |
                             MM_PTE_WRITE_MASK |
                             MM_PTE_OWNER_MASK |
                             MM_PTE_DIRTY_MASK |
                             MM_PTE_ACCESS_MASK };


const MMPTE ValidPtePte = { MM_PTE_VALID_MASK |
                            MM_PTE_WRITE_MASK |
                            MM_PTE_DIRTY_MASK |
                            MM_PTE_ACCESS_MASK };


const MMPTE ValidPdePde = { MM_PTE_VALID_MASK |
                            MM_PTE_WRITE_MASK |
                            MM_PTE_DIRTY_MASK |
                            MM_PTE_ACCESS_MASK };


MMPTE ValidKernelPde = { MM_PTE_VALID_MASK |
                         MM_PTE_WRITE_MASK |
                         MM_PTE_DIRTY_MASK |
                         MM_PTE_ACCESS_MASK };

const MMPTE ValidKernelPdeLocal = { MM_PTE_VALID_MASK |
                                    MM_PTE_WRITE_MASK |
                                    MM_PTE_DIRTY_MASK |
                                    MM_PTE_ACCESS_MASK };

// NOTE - MM_PTE_GLOBAL_MASK  or'ed in later if processor supports Global Page


MMPTE DemandZeroPde = { MM_READWRITE << 5 };


const MMPTE DemandZeroPte = { MM_READWRITE << 5 };


const MMPTE TransitionPde = { MM_PTE_WRITE_MASK |
                              MM_PTE_OWNER_MASK |
                              MM_PTE_TRANSITION_MASK |
                              MM_READWRITE << 5 };

#if !defined (_X86PAE_)
MMPTE PrototypePte = { 0xFFFFF000 |
                       MM_PTE_PROTOTYPE_MASK |
                       MM_READWRITE << 5 };
#else
MMPTE PrototypePte = { (MI_PTE_LOOKUP_NEEDED << 32) |
                       MM_PTE_PROTOTYPE_MASK |
                       MM_READWRITE << 5 };
#endif


//
// PTE which generates an access violation when referenced.
//

const MMPTE NoAccessPte = {MM_NOACCESS << 5};

//
// Pool start and end.
//

PVOID MmNonPagedPoolStart;

PVOID MmNonPagedPoolEnd = (PVOID) MM_NONPAGED_POOL_END;

PVOID MmPagedPoolStart = (PVOID) MM_DEFAULT_PAGED_POOL_START;

PVOID MmPagedPoolEnd;

PMMWSL MmWorkingSetList;

ULONG MiMaximumWorkingSet =
       ((ULONG)((ULONG)2*1024*1024*1024 - 64*1024) >> PAGE_SHIFT); //2Gb-64K.

//
// Color tables for free and zeroed pages.
//

PMMCOLOR_TABLES MmFreePagesByColor[2];

//
// Color tables for modified pages destined for the paging file.
//

MMPFNLIST MmModifiedPageListByColor[MM_MAXIMUM_NUMBER_OF_COLORS] = {
                            0, ModifiedPageList, MM_EMPTY_LIST, MM_EMPTY_LIST};


//
// Count of the number of modified pages destined for the paging file.
//

ULONG MmTotalPagesForPagingFile = 0;

//
// Pte reserved for mapping pages for the debugger.
//

PMMPTE MmDebugPte = (MiGetPteAddress(MM_DEBUG_VA));

//
// 16 PTEs reserved for mapping MDLs (64k max).
//

PMMPTE MmCrashDumpPte = (MiGetPteAddress(MM_CRASH_DUMP_VA));

//
// Number of additional system PTEs present.
//

ULONG_PTR MiUseMaximumSystemSpace;
ULONG_PTR MiUseMaximumSystemSpaceEnd;

//
// Size of extended system cache.
//

#if defined (_X86PAE_)
PMMPTE MmSystemCacheWorkingSetListPte;
#endif

ULONG MiMaximumSystemCacheSizeExtra;

PVOID MiSystemCacheStartExtra;

PVOID MiSystemCacheEndExtra;

ULONG_PTR MmBootImageSize;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\i386\pae.asm ===
title  "pae"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    pae.asm
;
; Abstract:
;
;    This module implements the code necessary to swap PTEs on a PAE system.
;
;--

.586p
        .xlist
include callconv.inc
FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, 0 )
endm
        .list

_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "Interlocked Swap PTE"

;++
;
; ULONGLONG
; InterlockedExchangePte (
;     IN OUT PMMPTE Destination,
;     IN ULONGLONG Exchange
;     )
;
; Routine Description:
;
;     This function performs an interlocked swap of a PTE.  This is only needed
;     for the PAE architecture where the PTE width is larger than the register
;     width.
;
;     Both PTEs must be valid or a careful write would have been done instead.
;
; Arguments:
;
;     PtePointer - Address of PTE to update with new value.
;
;     NewPteContents - The new value to put in the PTE.
;
; Return Value:
;
;     The old PTE contents (highpart in edx, lowpart in eax).
;
;--

cPublicProc _InterlockedExchangePte ,3

    push    ebx
    push    esi

    mov     ebx, [esp] + 16         ; ebx = NewPteContents lowpart
    mov     ecx, [esp] + 20         ; ecx = NewPteContents highpart

    mov     esi, [esp] + 12         ; esi = PtePointer

    mov     edx, [esi] + 4
    mov     eax, [esi]              ; edx:eax = OldPteContents

swapagain:

    ;
    ; cmpxchg loads edx:eax with the updated current contents of the
    ; target quadword in the event of success (or failure).
    ;

    lock cmpxchg8b qword ptr [esi]  ; compare and exchange

    jnz     short swapagain         ; if z clear, exchange failed

    pop     esi
    pop     ebx

    stdRET   _InterlockedExchangePte
stdENDP _InterlockedExchangePte

_TEXT$00   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\i386\mi386.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    mi386.h

Abstract:

    This module contains the private data structures and procedure
    prototypes for the hardware dependent portion of the
    memory management system.

    This module is specifically tailored for the x86.

--*/


/*++

    Virtual Memory Layout on x86 is:

                 +------------------------------------+
        00000000 |                                    |
                 |                                    |
                 |                                    |
                 | User Mode Addresses                |
                 |                                    |
                 |   All pages within this range      |
                 |   are potentially accessible while |
                 |   the CPU is in USER mode.         |
                 |                                    |
                 |                                    |
                 +------------------------------------+
        7ffff000 | 64k No Access Area                 |
                 +------------------------------------+
        80000000 |                                    |
                 | NTLDR loads the kernel, HAL and    |
                 | boot drivers here.  The kernel     |
                 | then relocates the drivers to the  |
                 | system PTE area.                   |
                 |                                    |
                 | Kernel mode access only.           |
                 |                                    |
                 | When possible, the PFN database &  |
                 | initial non paged pool is built    |
                 | here using large page mappings.    |
                 |                                    |
                 +------------------------------------+
                 |                                    |
                 | Additional system PTEs, system     |
                 | cache or special pooling           |
                 |                                    |
                 +------------------------------------+
                 |                                    |
                 | System mapped views.               |
                 |                                    |
                 +------------------------------------+
                 |                                    |
                 | Session space.                     |
                 |                                    |
                 +------------------------------------+
        C0000000 | Page Table Pages mapped through    |
                 |          this 4mb region           |
                 |   Kernel mode access only.         |
                 |                                    |
                 +------------------------------------+
        C0400000 | HyperSpace - working set lists     |
                 |  and per process memory management |
                 |  structures mapped in this 8mb     |
                 |  region.                           |
                 |  Kernel mode access only.          |
                 +------------------------------------+
        C0C00000 | System Cache Structures            |
                 |   reside in this 4mb region        |
                 |   Kernel mode access only.         |
                 +------------------------------------+
        C1000000 | System cache resides here.         |
                 |   Kernel mode access only.         |
                 |                                    |
                 |                                    |
                 +------------------------------------+
        E1000000 | Start of paged system area         |
                 |   Kernel mode access only.         |
                 |                                    |
                 |                                    |
                 +------------------------------------+
                 |                                    |
                 | System PTE area - for mapping      |
                 |   kernel thread stacks and MDLs    |
                 |   that require system VAs.         |
                 |   Kernel mode access only.         |
                 |                                    |
                 +------------------------------------+
                 |                                    |
                 | NonPaged System area               |
                 |   Kernel mode access only.         |
                 |                                    |
                 +------------------------------------+
        FFBE0000 | Crash Dump Driver area             |
                 |   Kernel mode access only.         |
                 +------------------------------------+
        FFC00000 | Last 4mb reserved for HAL usage    |
                 +------------------------------------+

--*/

#define _MI_PAGING_LEVELS 2

FORCEINLINE
MiGetStackPointer (
    OUT PULONG_PTR StackPointer
    )
{
    _asm {
        mov     ecx, StackPointer
        mov     [ecx], esp
    }
}

#if !defined(_X86PAE_)

//
// Define empty list markers.
//

#define MM_EMPTY_LIST ((ULONG)0xFFFFFFFF) //
#define MM_EMPTY_PTE_LIST ((ULONG)0xFFFFF) // N.B. tied to MMPTE definition

#define MI_PTE_BASE_FOR_LOWEST_KERNEL_ADDRESS (MiGetPteAddress (0x00000000))

#define MM_SESSION_SPACE_DEFAULT        (0xA0000000)
#define MM_SESSION_SPACE_DEFAULT_END    (0xC0000000)

//
// This is the size of the region used by the loader.
//

extern ULONG_PTR MmBootImageSize;

//
// PAGE_SIZE for x86 is 4k, virtual page is 20 bits with a PAGE_SHIFT
// byte offset.
//

#define MM_VIRTUAL_PAGE_FILLER 0
#define MM_VIRTUAL_PAGE_SIZE 20

//
// Address space layout definitions.
//

#define MM_KSEG0_BASE ((ULONG)0x80000000)

#define MM_KSEG2_BASE ((ULONG)0xA0000000)

#define MM_PAGES_IN_KSEG0 ((MM_KSEG2_BASE - MM_KSEG0_BASE) >> PAGE_SHIFT)

#define CODE_START MM_KSEG0_BASE

#define CODE_END   MM_KSEG2_BASE

#define MM_SYSTEM_SPACE_START ((ULONG_PTR)MmSystemCacheWorkingSetList)

#define MM_SYSTEM_SPACE_END (0xFFFFFFFF)

#define HYPER_SPACE ((PVOID)0xC0400000)

#define HYPER_SPACE_END (0xC07fffff)

extern PVOID MmHyperSpaceEnd;

#define MM_SYSTEM_VIEW_START (0xA0000000)

#define MM_SYSTEM_VIEW_SIZE (16*1024*1024)

#define MM_LOWEST_4MB_START ((32*1024*1024)/PAGE_SIZE) //32mb

#define MM_DEFAULT_4MB_START (((1024*1024)/PAGE_SIZE)*4096) //4gb

#define MM_HIGHEST_4MB_START (((1024*1024)/PAGE_SIZE)*4096) //4gb

#define MM_USER_ADDRESS_RANGE_LIMIT 0xFFFFFFFF // user address range limit
#define MM_MAXIMUM_ZERO_BITS 21         // maximum number of zero bits

//
// Define the start and maximum size for the system cache.
// Maximum size is normally 512MB, but can be up to 512MB + 448MB = 960MB for
// large system cache machines.
//

#define MM_SYSTEM_CACHE_WORKING_SET (0xC0C00000)

#define MM_SYSTEM_CACHE_START (0xC1000000)

#define MM_SYSTEM_CACHE_END (0xE1000000)

//
// Various resources like additional system PTEs or system cache views, etc,
// can be allocated out of this virtual address range.
//

extern ULONG_PTR MiUseMaximumSystemSpace;

extern ULONG_PTR MiUseMaximumSystemSpaceEnd;

extern ULONG MiMaximumSystemCacheSizeExtra;

extern PVOID MiSystemCacheStartExtra;

extern PVOID MiSystemCacheEndExtra;

#define MM_SYSTEM_CACHE_END_EXTRA (0xC0000000)

#define MM_PAGED_POOL_START (MmPagedPoolStart)

#define MM_DEFAULT_PAGED_POOL_START (0xE1000000)

#define MM_LOWEST_NONPAGED_SYSTEM_START ((PVOID)(0xEB000000))

#define MmProtopte_Base ((ULONG)MmPagedPoolStart)

#define MM_NONPAGED_POOL_END ((PVOID)(0xFFBE0000))

#define MM_CRASH_DUMP_VA ((PVOID)(0xFFBE0000))

#define MM_DEBUG_VA  ((PVOID)0xFFBFF000)

#define NON_PAGED_SYSTEM_END   ((ULONG)0xFFFFFFF0)  //quadword aligned.

extern BOOLEAN MiWriteCombiningPtes;

//
// Define absolute minimum and maximum count for system PTEs.
//

#define MM_MINIMUM_SYSTEM_PTES 7000

#define MM_MAXIMUM_SYSTEM_PTES 50000

#define MM_DEFAULT_SYSTEM_PTES 11000

//
// Pool limits
//

//
// The maximum amount of nonpaged pool that can be initially created.
//

#define MM_MAX_INITIAL_NONPAGED_POOL ((ULONG)(128*1024*1024))

//
// The total amount of nonpaged pool (initial pool + expansion).
//

#define MM_MAX_ADDITIONAL_NONPAGED_POOL ((ULONG)(128*1024*1024))

//
// The maximum amount of paged pool that can be created.
//

#define MM_MAX_PAGED_POOL ((ULONG)MM_NONPAGED_POOL_END - (ULONG)MM_PAGED_POOL_START)

#define MM_MAX_TOTAL_POOL (((ULONG)MM_NONPAGED_POOL_END) - ((ULONG)(MM_PAGED_POOL_START)))


//
// Structure layout definitions.
//

#define MM_PROTO_PTE_ALIGNMENT ((ULONG)PAGE_SIZE)

#define PAGE_DIRECTORY_MASK    ((ULONG)0x003FFFFF)

#define MM_VA_MAPPED_BY_PDE (0x400000)

#define MM_MINIMUM_VA_FOR_LARGE_PAGE MM_VA_MAPPED_BY_PDE

#define LOWEST_IO_ADDRESS 0xa0000

#define PTE_SHIFT 2

//
// The number of bits in a physical address.
//

#define PHYSICAL_ADDRESS_BITS 32

#define MM_MAXIMUM_NUMBER_OF_COLORS (1)

//
// i386 does not require support for colored pages.
//

#define MM_NUMBER_OF_COLORS (1)

//
// Mask for obtaining color from a physical page number.
//

#define MM_COLOR_MASK (0)

//
// Boundary for aligned pages of like color upon.
//

#define MM_COLOR_ALIGNMENT (0)

//
// Mask for isolating color from virtual address.
//

#define MM_COLOR_MASK_VIRTUAL (0)

//
//  Define 256k worth of secondary colors.
//

#define MM_SECONDARY_COLORS_DEFAULT (64)

#define MM_SECONDARY_COLORS_MIN (8)

#define MM_SECONDARY_COLORS_MAX (1024)

//
// Maximum number of paging files.
//

#define MAX_PAGE_FILES 16


//
// Hyper space definitions.
//

#define FIRST_MAPPING_PTE   ((ULONG)0xC0400000)

#define NUMBER_OF_MAPPING_PTES 255
#define LAST_MAPPING_PTE   \
     ((ULONG)((ULONG)FIRST_MAPPING_PTE + (NUMBER_OF_MAPPING_PTES * PAGE_SIZE)))

#define COMPRESSION_MAPPING_PTE   ((PMMPTE)((ULONG)LAST_MAPPING_PTE + PAGE_SIZE))

#define NUMBER_OF_ZEROING_PTES 32

//
// This bitmap consumes 4K when booted /2GB and 6K when booted /3GB, thus
// the working set list start is variable.
//

#define VAD_BITMAP_SPACE    ((PVOID)((ULONG)COMPRESSION_MAPPING_PTE + PAGE_SIZE))

#define WORKING_SET_LIST    MmWorkingSetList

#define MM_MAXIMUM_WORKING_SET MiMaximumWorkingSet

extern ULONG MiMaximumWorkingSet;

#define MmWsle ((PMMWSLE)((PUCHAR)WORKING_SET_LIST + sizeof(MMWSL)))

#define MM_WORKING_SET_END ((ULONG)0xC07FF000)


//
// Define masks for fields within the PTE.
///

#define MM_PTE_VALID_MASK         0x1
#if defined(NT_UP)
#define MM_PTE_WRITE_MASK         0x2
#else
#define MM_PTE_WRITE_MASK         0x800
#endif
#define MM_PTE_OWNER_MASK         0x4
#define MM_PTE_WRITE_THROUGH_MASK 0x8
#define MM_PTE_CACHE_DISABLE_MASK 0x10
#define MM_PTE_ACCESS_MASK        0x20
#if defined(NT_UP)
#define MM_PTE_DIRTY_MASK         0x40
#else
#define MM_PTE_DIRTY_MASK         0x42
#endif
#define MM_PTE_LARGE_PAGE_MASK    0x80
#define MM_PTE_GLOBAL_MASK        0x100
#define MM_PTE_COPY_ON_WRITE_MASK 0x200
#define MM_PTE_PROTOTYPE_MASK     0x400
#define MM_PTE_TRANSITION_MASK    0x800

//
// Bit fields to or into PTE to make a PTE valid based on the
// protection field of the invalid PTE.
//

#define MM_PTE_NOACCESS          0x0   // not expressible on i386
#define MM_PTE_READONLY          0x0
#define MM_PTE_READWRITE         MM_PTE_WRITE_MASK
#define MM_PTE_WRITECOPY         0x200 // read-only copy on write bit set.
#define MM_PTE_EXECUTE           0x0   // read-only on i386
#define MM_PTE_EXECUTE_READ      0x0
#define MM_PTE_EXECUTE_READWRITE MM_PTE_WRITE_MASK
#define MM_PTE_EXECUTE_WRITECOPY 0x200 // read-only copy on write bit set.
#define MM_PTE_NOCACHE           0x010
#define MM_PTE_WRITECOMBINE      0x010 // overridden in MmEnablePAT
#define MM_PTE_GUARD             0x0  // not expressible on i386
#define MM_PTE_CACHE             0x0

#define MM_PROTECT_FIELD_SHIFT 5

//
// Bits available for the software working set index within the hardware PTE.
//

#define MI_MAXIMUM_PTE_WORKING_SET_INDEX 0

//
// Zero PTE
//

#define MM_ZERO_PTE 0

//
// Zero Kernel PTE
//

#define MM_ZERO_KERNEL_PTE 0

//
// A demand zero PTE with a protection or PAGE_READWRITE.
//

#define MM_DEMAND_ZERO_WRITE_PTE (MM_READWRITE << MM_PROTECT_FIELD_SHIFT)


//
// A demand zero PTE with a protection or PAGE_READWRITE for system space.
//

#define MM_KERNEL_DEMAND_ZERO_PTE (MM_READWRITE << MM_PROTECT_FIELD_SHIFT)

//
// A no access PTE for system space.
//

#define MM_KERNEL_NOACCESS_PTE (MM_NOACCESS << MM_PROTECT_FIELD_SHIFT)

//
// Kernel stack alignment requirements.
//

#define MM_STACK_ALIGNMENT 0x0

#define MM_STACK_OFFSET 0x0

//
// System process definitions
//

#define PDE_PER_PAGE ((ULONG)1024)

#define PTE_PER_PAGE ((ULONG)1024)

#define PD_PER_SYSTEM ((ULONG)1)

//
// Number of page table pages for user addresses.
//

#define MM_USER_PAGE_TABLE_PAGES (768)


//++
// VOID
// MI_MAKE_VALID_USER_PTE (
//    OUT OUTPTE,
//    IN FRAME,
//    IN PMASK,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro makes a valid *USER* PTE from a page frame number,
//    protection mask, and owner.
//
//    THIS MUST ONLY BE USED FOR PAGE TABLE ENTRIES (NOT PAGE DIRECTORY
//    ENTRIES), MAPPING USER (NOT KERNEL OR SESSION) VIRTUAL ADDRESSES.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    FRAME - Supplies the page frame number for the PTE.
//
//    PMASK - Supplies the protection to set in the valid PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_VALID_USER_PTE(OUTPTE,FRAME,PMASK,PPTE)                     \
       ASSERT (PPTE <= MiHighestUserPte);                                   \
       (OUTPTE).u.Long = 0;                                                 \
       (OUTPTE).u.Hard.Valid = 1;                                           \
       (OUTPTE).u.Hard.Accessed = 1;                                        \
       (OUTPTE).u.Hard.Owner = 1;                                           \
       (OUTPTE).u.Hard.PageFrameNumber = FRAME;                             \
       (OUTPTE).u.Long |= MmProtectToPteMask[PMASK];

//++
// VOID
// MI_MAKE_VALID_KERNEL_PTE (
//    OUT OUTPTE,
//    IN FRAME,
//    IN PMASK,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro makes a valid *KERNEL* PTE from a page frame number,
//    protection mask, and owner.
//
//    THIS MUST ONLY BE USED FOR PAGE TABLE ENTRIES (NOT PAGE DIRECTORY
//    ENTRIES), MAPPING GLOBAL (NOT SESSION) VIRTUAL ADDRESSES.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    FRAME - Supplies the page frame number for the PTE.
//
//    PMASK - Supplies the protection to set in the valid PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_VALID_KERNEL_PTE(OUTPTE,FRAME,PMASK,PPTE)                   \
       ASSERT (PPTE > MiHighestUserPte);                                    \
       ASSERT (!MI_IS_SESSION_PTE (PPTE));                                  \
       ASSERT ((PPTE < (PMMPTE)PDE_BASE) || (PPTE > (PMMPTE)PDE_TOP));      \
       (OUTPTE).u.Long = 0;                                                 \
       (OUTPTE).u.Hard.Valid = 1;                                           \
       (OUTPTE).u.Hard.Accessed = 1;                                        \
       (OUTPTE).u.Hard.PageFrameNumber = FRAME;                             \
       (OUTPTE).u.Long |= MmPteGlobal.u.Long;                               \
       (OUTPTE).u.Long |= MmProtectToPteMask[PMASK];

//++
// VOID
// MI_MAKE_VALID_PTE (
//    OUT OUTPTE,
//    IN FRAME,
//    IN PMASK,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro makes a valid PTE from a page frame number, protection mask,
//    and owner.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    FRAME - Supplies the page frame number for the PTE.
//
//    PMASK - Supplies the protection to set in the valid PTE.
//
//    PPTE - Supplies a pointer to the PTE which is being made valid.
//           For prototype PTEs NULL should be specified.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_VALID_PTE(OUTPTE,FRAME,PMASK,PPTE)                            \
       (OUTPTE).u.Long = ((FRAME << 12) |                                     \
                         (MmProtectToPteMask[PMASK]) |                        \
                          MiDetermineUserGlobalPteMask ((PMMPTE)PPTE));

//++
// VOID
// MI_MAKE_VALID_PTE_TRANSITION (
//    IN OUT OUTPTE
//    IN PROTECT
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and turns it into a transition PTE.
//
// Arguments
//
//    OUTPTE - Supplies the current valid PTE.  This PTE is then
//             modified to become a transition PTE.
//
//    PROTECT - Supplies the protection to set in the transition PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_VALID_PTE_TRANSITION(OUTPTE,PROTECT) \
                (OUTPTE).u.Soft.Transition = 1;           \
                (OUTPTE).u.Soft.Valid = 0;                \
                (OUTPTE).u.Soft.Prototype = 0;            \
                (OUTPTE).u.Soft.Protection = PROTECT;

//++
// VOID
// MI_MAKE_TRANSITION_PTE (
//    OUT OUTPTE,
//    IN PAGE,
//    IN PROTECT,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and turns it into a transition PTE.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the transition PTE.
//
//    PAGE - Supplies the page frame number for the PTE.
//
//    PROTECT - Supplies the protection to set in the transition PTE.
//
//    PPTE - Supplies a pointer to the PTE, this is used to determine
//           the owner of the PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_TRANSITION_PTE(OUTPTE,PAGE,PROTECT,PPTE)   \
                (OUTPTE).u.Long = 0;                       \
                (OUTPTE).u.Trans.PageFrameNumber = PAGE;   \
                (OUTPTE).u.Trans.Transition = 1;           \
                (OUTPTE).u.Trans.Protection = PROTECT;     \
                (OUTPTE).u.Trans.Owner = MI_DETERMINE_OWNER(PPTE);


//++
// VOID
// MI_MAKE_TRANSITION_PTE_VALID (
//    OUT OUTPTE,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro takes a transition PTE and makes it a valid PTE.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    PPTE - Supplies a pointer to the transition PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_TRANSITION_PTE_VALID(OUTPTE,PPTE)                             \
        ASSERT (((PPTE)->u.Hard.Valid == 0) &&                                \
                ((PPTE)->u.Trans.Prototype == 0) &&                           \
                ((PPTE)->u.Trans.Transition == 1));                           \
               (OUTPTE).u.Long = (((PPTE)->u.Long & ~0xFFF) |                 \
                         (MmProtectToPteMask[(PPTE)->u.Trans.Protection]) |   \
                          MiDetermineUserGlobalPteMask ((PMMPTE)PPTE));

//++
// VOID
// MI_MAKE_TRANSITION_KERNELPTE_VALID (
//    OUT OUTPTE,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro takes a transition kernel PTE and makes it a valid PTE.
//
//    THIS MUST ONLY BE USED FOR PAGE TABLE ENTRIES (NOT PAGE DIRECTORY
//    ENTRIES), MAPPING GLOBAL (NOT SESSION) VIRTUAL ADDRESSES.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    PPTE - Supplies a pointer to the transition PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_TRANSITION_KERNELPTE_VALID(OUTPTE,PPTE)                       \
        ASSERT (PPTE > MiHighestUserPte);                                     \
        ASSERT (!MI_IS_SESSION_PTE (PPTE));                                   \
        ASSERT ((PPTE < (PMMPTE)PDE_BASE) || (PPTE > (PMMPTE)PDE_TOP));       \
        ASSERT ((PPTE)->u.Hard.Valid == 0);                                   \
        ASSERT ((PPTE)->u.Trans.Prototype == 0);                              \
        ASSERT ((PPTE)->u.Trans.Transition == 1);                             \
        (OUTPTE).u.Long = ((PPTE)->u.Long & ~0xFFF);                          \
        (OUTPTE).u.Long |= (MmProtectToPteMask[(PPTE)->u.Trans.Protection]);  \
        (OUTPTE).u.Hard.Valid = 1;                                            \
        (OUTPTE).u.Hard.Accessed = 1;                                         \
        (OUTPTE).u.Long |= MmPteGlobal.u.Long;

//++
// VOID
// MI_MAKE_TRANSITION_PROTOPTE_VALID (
//    OUT OUTPTE,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro takes a transition prototype PTE (in paged pool) and
//    makes it a valid PTE.  Because we know this is a prototype PTE and
//    not a pagetable PTE, this can directly or in the global bit.  This
//    makes a measurable performance gain since every instruction counts
//    when holding the PFN lock.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    PPTE - Supplies a pointer to the transition PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_TRANSITION_PROTOPTE_VALID(OUTPTE,PPTE)                        \
        ASSERT (((PPTE)->u.Hard.Valid == 0) &&                                \
                ((PPTE)->u.Trans.Prototype == 0) &&                           \
                ((PPTE)->u.Trans.Transition == 1));                           \
               (OUTPTE).u.Long = (((PPTE)->u.Long & ~0xFFF) |                 \
                         (MmProtectToPteMask[(PPTE)->u.Trans.Protection]) |   \
                         (MmPteGlobal.u.Long));                               \
               (OUTPTE).u.Hard.Valid = 1;                                     \
               (OUTPTE).u.Hard.Accessed = 1;

#define MI_FAULT_STATUS_INDICATES_EXECUTION(_FaultStatus)   0

#define MI_FAULT_STATUS_INDICATES_WRITE(_FaultStatus)   (_FaultStatus & 0x1)

#define MI_CLEAR_FAULT_STATUS(_FaultStatus)             (_FaultStatus = 0)

#define MI_IS_PTE_EXECUTABLE(_TempPte) (1)

//++
//++
// VOID
// MI_SET_PTE_IN_WORKING_SET (
//    OUT PMMPTE PTE,
//    IN ULONG WSINDEX
//    );
//
// Routine Description:
//
//    This macro inserts the specified working set index into the argument PTE.
//    Since the i386 PTE has no free bits nothing needs to be done on this
//    architecture.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to insert the working set index.
//
//    WSINDEX - Supplies the working set index for the PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_PTE_IN_WORKING_SET(PTE, WSINDEX)

//++
// ULONG WsIndex
// MI_GET_WORKING_SET_FROM_PTE(
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    This macro returns the working set index from the argument PTE.
//    Since the i386 PTE has no free bits nothing needs to be done on this
//    architecture.
//
// Arguments
//
//    PTE - Supplies the PTE to extract the working set index from.
//
// Return Value:
//
//    This macro returns the working set index for the argument PTE.
//
//--

#define MI_GET_WORKING_SET_FROM_PTE(PTE)  0

//++
// VOID
// MI_SET_PTE_WRITE_COMBINE (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and enables WriteCombining as the
//    caching state.  Note that the PTE bits may only be set this way
//    if the Page Attribute Table is present and the PAT has been
//    initialized to provide Write Combining.
//
//    If either of the above conditions is not satisfied, then
//    the macro enables WEAK UC (PCD = 1, PWT = 0) in the PTE.
//
// Arguments
//
//    PTE - Supplies a valid PTE.
//
// Return Value:
//
//     None.
//
//--
//

#define MI_SET_PTE_WRITE_COMBINE(PTE) \
            {                                                               \
                if (MiWriteCombiningPtes == TRUE) {                         \
                    ((PTE).u.Hard.CacheDisable = 0);                        \
                    ((PTE).u.Hard.WriteThrough = 1);                        \
                } else {                                                    \
                    ((PTE).u.Hard.CacheDisable = 1);                        \
                    ((PTE).u.Hard.WriteThrough = 0);                        \
                }                                                           \
            }

#define MI_SET_LARGE_PTE_WRITE_COMBINE(PTE) MI_SET_PTE_WRITE_COMBINE(PTE)

//++
// VOID
// MI_PREPARE_FOR_NONCACHED (
//    IN MI_PFN_CACHE_ATTRIBUTE CacheAttribute
//    );
//
// Routine Description:
//
//    This macro prepares the system prior to noncached PTEs being created.
//
//    Note the entire TB must be flushed on all processors because there may
//    be stale system PTE (or hyperspace or zeropage) mappings in the TB which
//    may refer to the same physical page but with a different cache attribute.
//
// Arguments
//
//    CacheAttribute - Supplies the cache attribute the PTEs will be filled
//                     with.
//
// Return Value:
//
//     None.
//
//--
#define MI_PREPARE_FOR_NONCACHED(_CacheAttribute)                           \
        if (_CacheAttribute != MiCached) {                                  \
            MI_FLUSH_ENTIRE_TB (0x20);                                      \
            KeInvalidateAllCaches ();                                       \
        }

//++
// VOID
// MI_FLUSH_TB_FOR_INDIVIDUAL_ATTRIBUTE_CHANGE (
//    IN PFN_NUMBER PageFrameIndex,
//    IN MI_PFN_CACHE_ATTRIBUTE CacheAttribute
//    );
//
// Routine Description:
//
//    The entire TB must be flushed if we are changing cache attributes.
//
//    KeFlushSingleTb cannot be used because we don't know
//    what virtual address(es) this physical frame was last mapped at.
//
//    Additionally, the cache must be flushed if we are switching from
//    write back to write combined (or noncached) because otherwise the
//    current data may live in the cache while the uc/wc mapping is used
//    and then when the uc/wc mapping is freed, the cache will hold stale
//    data that will be found when a normal write back mapping is reapplied.
//
// Arguments
//
//    PageFrameIndex - Supplies the page frame number that is going to be
//                     used with the new attribute.
//
//    CacheAttribute - Supplies the cache attribute the new PTEs will be filled
//                     with.
//
// Return Value:
//
//     None.
//
//--

#define MI_FLUSH_TB_FOR_INDIVIDUAL_ATTRIBUTE_CHANGE(_PageFrameIndex,_CacheAttribute)  \
            MiFlushTbForAttributeChange += 1;                               \
            MI_FLUSH_ENTIRE_TB (0x21);                                      \
            if (_CacheAttribute != MiCached) {                              \
                MiFlushCacheForAttributeChange += 1;                        \
                KeInvalidateAllCaches ();                                   \
            }

//++
// VOID
// MI_FLUSH_ENTIRE_TB_FOR_ATTRIBUTE_CHANGE (
//    IN MI_PFN_CACHE_ATTRIBUTE CacheAttribute
//    );
//
// Routine Description:
//
//    The entire TB must be flushed if we are changing cache attributes.
//
//    KeFlushSingleTb cannot be used because we don't know
//    what virtual address(es) this physical frame was last mapped at.
//
//    Additionally, the cache must be flushed if we are switching from
//    write back to write combined (or noncached) because otherwise the
//    current data may live in the cache while the uc/wc mapping is used
//    and then when the uc/wc mapping is freed, the cache will hold stale
//    data that will be found when a normal write back mapping is reapplied.
//
// Arguments
//
//    CacheAttribute - Supplies the cache attribute the new PTEs will be filled
//                     with.
//
// Return Value:
//
//     None.
//
//--

#define MI_FLUSH_ENTIRE_TB_FOR_ATTRIBUTE_CHANGE(_CacheAttribute)   \
            MiFlushTbForAttributeChange += 1;                      \
            MI_FLUSH_ENTIRE_TB (0x22);                             \
            if (_CacheAttribute != MiCached) {                     \
                MiFlushCacheForAttributeChange += 1;               \
                KeInvalidateAllCaches ();                          \
            }

//++
// VOID
// MI_FLUSH_TB_FOR_CACHED_ATTRIBUTE (
//    VOID
//    );
//
// Routine Description:
//
//    The entire TB must be flushed if we are changing cache attributes.
//
//    KeFlushSingleTb cannot be used because we don't know
//    what virtual address(es) a physical frame was last mapped at.
//
//    Note no cache flush is needed because the attribute-changing-pages
//    are going to be mapped fully cached.
//
// Arguments
//
//    None.
//
// Return Value:
//
//     None.
//
//--

#define MI_FLUSH_TB_FOR_CACHED_ATTRIBUTE()                         \
            MiFlushTbForAttributeChange += 1;                      \
            MI_FLUSH_ENTIRE_TB (0x23);

//++
// VOID
// MI_SET_PTE_DIRTY (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro sets the dirty bit(s) in the specified PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to set dirty.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_PTE_DIRTY(PTE) (PTE).u.Long |= HARDWARE_PTE_DIRTY_MASK


//++
// VOID
// MI_SET_PTE_CLEAN (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro clears the dirty bit(s) in the specified PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to set clear.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_PTE_CLEAN(PTE) (PTE).u.Long &= ~HARDWARE_PTE_DIRTY_MASK



//++
// VOID
// MI_IS_PTE_DIRTY (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro checks the dirty bit(s) in the specified PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to check.
//
// Return Value:
//
//    TRUE if the page is dirty (modified), FALSE otherwise.
//
//--

#define MI_IS_PTE_DIRTY(PTE) ((PTE).u.Hard.Dirty != 0)



//++
// VOID
// MI_SET_GLOBAL_BIT_IF_SYSTEM (
//    OUT OUTPTE,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro sets the global bit if the pointer PTE is within
//    system space.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    PPTE - Supplies a pointer to the PTE becoming valid.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_GLOBAL_BIT_IF_SYSTEM(OUTPTE,PPTE)                             \
   if ((((PMMPTE)PPTE) > MiHighestUserPte) &&                                \
       ((((PMMPTE)PPTE) <= MiGetPteAddress (PTE_BASE)) ||                    \
       (((PMMPTE)PPTE) >= MiGetPteAddress (MM_SYSTEM_CACHE_WORKING_SET)))) { \
           (OUTPTE).u.Long |= MmPteGlobal.u.Long;                            \
   }                                                                         \
   else {                                                                    \
           (OUTPTE).u.Long &= ~MmPteGlobal.u.Long;                           \
   }


//++
// VOID
// MI_SET_GLOBAL_STATE (
//    IN MMPTE PTE,
//    IN ULONG STATE
//    );
//
// Routine Description:
//
//    This macro sets the global bit in the PTE. if the pointer PTE is within
//
// Arguments
//
//    PTE - Supplies the PTE to set global state into.
//
//    STATE - Supplies 1 if global, 0 if not.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_GLOBAL_STATE(PTE,STATE)                              \
           if (STATE) {                                             \
               (PTE).u.Long |= MmPteGlobal.u.Long;                  \
           }                                                        \
           else {                                                   \
               (PTE).u.Long &= ~MmPteGlobal.u.Long;                 \
           }





//++
// VOID
// MI_ENABLE_CACHING (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and sets the caching state to be
//    enabled.  This is performed by clearing the PCD and PWT bits in the PTE.
//
//    Semantics of the overlap between PCD, PWT, and the
//    USWC memory type in the MTRR are:
//
//    PCD   PWT   Mtrr Mem Type      Effective Memory Type
//     1     0    USWC               USWC
//     1     1    USWC               UC
//
// Arguments
//
//    PTE - Supplies a valid PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_ENABLE_CACHING(PTE) \
            {                                                                \
                ((PTE).u.Hard.CacheDisable = 0);                             \
                ((PTE).u.Hard.WriteThrough = 0);                             \
            }



//++
// VOID
// MI_DISABLE_CACHING (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and sets the caching state to be
//    disabled.  This is performed by setting the PCD and PWT bits in the PTE.
//
//    Semantics of the overlap between PCD, PWT, and the
//    USWC memory type in the MTRR are:
//
//    PCD   PWT   Mtrr Mem Type      Effective Memory Type
//     1     0    USWC               USWC
//     1     1    USWC               UC
//
//    Since an effective memory type of UC is desired here,
//    the WT bit is set.
//
// Arguments
//
//    PTE - Supplies a pointer to the valid PTE.
//
// Return Value:
//
//     None.
//
//--


#define MI_DISABLE_CACHING(PTE) \
            {                                                                \
                ((PTE).u.Hard.CacheDisable = 1);                             \
                ((PTE).u.Hard.WriteThrough = 1);                             \
            }

#define MI_DISABLE_LARGE_PTE_CACHING(PTE) MI_DISABLE_CACHING(PTE)



//++
// BOOLEAN
// MI_IS_CACHING_DISABLED (
//    IN PMMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and returns TRUE if caching is
//    disabled.
//
// Arguments
//
//    PPTE - Supplies a pointer to the valid PTE.
//
// Return Value:
//
//     TRUE if caching is disabled, FALSE if it is enabled.
//
//--

#define MI_IS_CACHING_DISABLED(PPTE)   \
            ((PPTE)->u.Hard.CacheDisable == 1)


//++
// VOID
// MI_SET_PFN_DELETED (
//    IN PMMPFN PPFN
//    );
//
// Routine Description:
//
//    This macro takes a pointer to a PFN element and indicates that
//    the PFN is no longer in use.
//
// Arguments
//
//    PPTE - Supplies a pointer to the PFN element.
//
// Return Value:
//
//    none.
//
//--

#define MI_SET_PFN_DELETED(PPFN) \
    PPFN->PteAddress = (PMMPTE)(((ULONG_PTR)(PPFN->PteAddress)) | 0x1);


//++
// VOID
// MI_MARK_PFN_UNDELETED (
//    IN PMMPFN PPFN
//    );
//
// Routine Description:
//
//    This macro takes a pointer to a deleted PFN element and mark that
//    the PFN is not deleted.
//
// Arguments
//
//    PPTE - Supplies a pointer to the PFN element.
//
// Return Value:
//
//    none.
//
//--

#define MI_MARK_PFN_UNDELETED(PPFN) \
    PPFN->PteAddress = (PMMPTE)((ULONG_PTR)PPFN->PteAddress & ~0x1);


//++
// BOOLEAN
// MI_IS_PFN_DELETED (
//    IN PMMPFN PPFN
//    );
//
// Routine Description:
//
//    This macro takes a pointer to a PFN element and determines if
//    the PFN is no longer in use.
//
// Arguments
//
//    PPTE - Supplies a pointer to the PFN element.
//
// Return Value:
//
//     TRUE if PFN is no longer used, FALSE if it is still being used.
//
//--

#define MI_IS_PFN_DELETED(PPFN)   \
            ((ULONG_PTR)(PPFN)->PteAddress & 0x1)


//++
// VOID
// MI_CHECK_PAGE_ALIGNMENT (
//    IN ULONG PAGE,
//    IN PMMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro takes a PFN element number (Page) and checks to see
//    if the virtual alignment for the previous address of the page
//    is compatible with the new address of the page.  If they are
//    not compatible, the D cache is flushed.
//
// Arguments
//
//    PAGE - Supplies the PFN element.
//    PPTE - Supplies a pointer to the new PTE which will contain the page.
//
// Return Value:
//
//    none.
//
//--

// does nothing on i386.

#define MI_CHECK_PAGE_ALIGNMENT(PAGE,PPTE)




//++
// VOID
// MI_INITIALIZE_HYPERSPACE_MAP (
//    VOID
//    );
//
// Routine Description:
//
//    This macro initializes the PTEs reserved for double mapping within
//    hyperspace.
//
// Arguments
//
//    None.
//
// Return Value:
//
//    None.
//
//--

// does nothing on i386.

#define MI_INITIALIZE_HYPERSPACE_MAP(INDEX)


//++
// ULONG
// MI_GET_NEXT_COLOR (
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This macro returns the next color in the sequence.
//
// Arguments
//
//    COLOR - Supplies the color to return the next of.
//
// Return Value:
//
//    Next color in sequence.
//
//--

#define MI_GET_NEXT_COLOR(COLOR)  ((COLOR + 1) & MM_COLOR_MASK)


//++
// ULONG
// MI_GET_PREVIOUS_COLOR (
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This macro returns the previous color in the sequence.
//
// Arguments
//
//    COLOR - Supplies the color to return the previous of.
//
// Return Value:
//
//    Previous color in sequence.
//
//--

#define MI_GET_PREVIOUS_COLOR(COLOR)  (0)


#define MI_GET_SECONDARY_COLOR(PAGE,PFN) (PAGE & MmSecondaryColorMask)


#define MI_GET_COLOR_FROM_SECONDARY(SECONDARY_COLOR) (0)


//++
// VOID
// MI_GET_MODIFIED_PAGE_BY_COLOR (
//    OUT ULONG PAGE,
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This macro returns the first page destined for a paging
//    file with the desired color.  It does NOT remove the page
//    from its list.
//
// Arguments
//
//    PAGE - Returns the page located, the value MM_EMPTY_LIST is
//           returned if there is no page of the specified color.
//
//    COLOR - Supplies the color of page to locate.
//
// Return Value:
//
//    none.
//
//--

#define MI_GET_MODIFIED_PAGE_BY_COLOR(PAGE,COLOR) \
            PAGE = MmModifiedPageListByColor[COLOR].Flink


//++
// VOID
// MI_GET_MODIFIED_PAGE_ANY_COLOR (
//    OUT ULONG PAGE,
//    IN OUT ULONG COLOR
//    );
//
// Routine Description:
//
//    This macro returns the first page destined for a paging
//    file with the desired color.  If not page of the desired
//    color exists, all colored lists are searched for a page.
//    It does NOT remove the page from its list.
//
// Arguments
//
//    PAGE - Returns the page located, the value MM_EMPTY_LIST is
//           returned if there is no page of the specified color.
//
//    COLOR - Supplies the color of page to locate and returns the
//            color of the page located.
//
// Return Value:
//
//    none.
//
//--

#define MI_GET_MODIFIED_PAGE_ANY_COLOR(PAGE,COLOR) \
            {                                                                \
                if (MmTotalPagesForPagingFile == 0) {                        \
                    PAGE = MM_EMPTY_LIST;                                    \
                } else {                                                     \
                    PAGE = MmModifiedPageListByColor[COLOR].Flink;           \
                }                                                            \
            }



//++
// VOID
// MI_MAKE_VALID_PTE_WRITE_COPY (
//    IN OUT PMMPTE PTE
//    );
//
// Routine Description:
//
//    This macro checks to see if the PTE indicates that the
//    page is writable and if so it clears the write bit and
//    sets the copy-on-write bit.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     None.
//
//--

#if defined(NT_UP)
#define MI_MAKE_VALID_PTE_WRITE_COPY(PPTE) \
                    if ((PPTE)->u.Hard.Write == 1) {    \
                        (PPTE)->u.Hard.CopyOnWrite = 1; \
                        (PPTE)->u.Hard.Write = 0;       \
                    }
#else
#define MI_MAKE_VALID_PTE_WRITE_COPY(PPTE) \
                    if ((PPTE)->u.Hard.Write == 1) {    \
                        (PPTE)->u.Hard.CopyOnWrite = 1; \
                        (PPTE)->u.Hard.Write = 0;       \
                        (PPTE)->u.Hard.Writable = 0;    \
                    }
#endif


#define MI_PTE_OWNER_USER       1

#define MI_PTE_OWNER_KERNEL     0


//++
// ULONG
// MI_DETERMINE_OWNER (
//    IN MMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro examines the virtual address of the PTE and determines
//    if the PTE resides in system space or user space.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     1 if the owner is USER_MODE, 0 if the owner is KERNEL_MODE.
//
//--

#define MI_DETERMINE_OWNER(PPTE)   \
    ((((PPTE) <= MiHighestUserPte) ||                                       \
      ((PPTE) >= MiGetPdeAddress(NULL) &&                                   \
      ((PPTE) <= MiHighestUserPde))) ? MI_PTE_OWNER_USER : MI_PTE_OWNER_KERNEL)



//++
// VOID
// MI_SET_ACCESSED_IN_PTE (
//    IN OUT MMPTE PPTE,
//    IN ULONG ACCESSED
//    );
//
// Routine Description:
//
//    This macro sets the ACCESSED field in the PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     None
//
//--

#define MI_SET_ACCESSED_IN_PTE(PPTE,ACCESSED) \
                    ((PPTE)->u.Hard.Accessed = ACCESSED)

//++
// ULONG
// MI_GET_ACCESSED_IN_PTE (
//    IN OUT MMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro returns the state of the ACCESSED field in the PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     The state of the ACCESSED field.
//
//--

#define MI_GET_ACCESSED_IN_PTE(PPTE) ((PPTE)->u.Hard.Accessed)


//++
// VOID
// MI_SET_OWNER_IN_PTE (
//    IN PMMPTE PPTE
//    IN ULONG OWNER
//    );
//
// Routine Description:
//
//    This macro sets the owner field in the PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    None.
//
//--

#define MI_SET_OWNER_IN_PTE(PPTE,OWNER) ((PPTE)->u.Hard.Owner = OWNER)


//
// bit mask to clear out fields in a PTE to or in prototype PTE offset.
//

#define CLEAR_FOR_PROTO_PTE_ADDRESS ((ULONG)0x701)

//
// bit mask to clear out fields in a PTE to or in paging file location.
//

#define CLEAR_FOR_PAGE_FILE 0x000003E0


//++
// VOID
// MI_SET_PAGING_FILE_INFO (
//    OUT MMPTE OUTPTE,
//    IN MMPTE PPTE,
//    IN ULONG FILEINFO,
//    IN ULONG OFFSET
//    );
//
// Routine Description:
//
//    This macro sets into the specified PTE the supplied information
//    to indicate where the backing store for the page is located.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to store the result.
//
//    PTE - Supplies the PTE to operate upon.
//
//    FILEINFO - Supplies the number of the paging file.
//
//    OFFSET - Supplies the offset into the paging file.
//
// Return Value:
//
//    None.
//
//--

#define MI_SET_PAGING_FILE_INFO(OUTPTE,PPTE,FILEINFO,OFFSET)            \
       (OUTPTE).u.Long = (PPTE).u.Long;                                 \
       (OUTPTE).u.Long &= CLEAR_FOR_PAGE_FILE;                          \
       (OUTPTE).u.Long |= ((FILEINFO << 1) | (OFFSET << 12));


//++
// PMMPTE
// MiPteToProto (
//    IN OUT MMPTE lpte
//    );
//
// Routine Description:
//
//   This macro returns the address of the corresponding prototype which
//   was encoded earlier into the supplied PTE.
//
//    NOTE THAT A PROTOPTE CAN ONLY RESIDE IN PAGED POOL!!!!!!
//
//    MAX SIZE = 2^(2+7+21) = 2^30 = 1GB.
//
//    NOTE that the valid bit must be zero!
//
// Arguments
//
//    lpte - Supplies the PTE to operate upon.
//
// Return Value:
//
//    Pointer to the prototype PTE that backs this PTE.
//
//--

#define MiPteToProto(lpte) (PMMPTE)((PMMPTE)(((((lpte)->u.Long) >> 11) << 9) +  \
                (((((lpte)->u.Long)) << 24) >> 23) + \
                MmProtopte_Base))


//++
// ULONG
// MiProtoAddressForPte (
//    IN PMMPTE proto_va
//    );
//
// Routine Description:
//
//    This macro sets into the specified PTE the supplied information
//    to indicate where the backing store for the page is located.
//    MiProtoAddressForPte returns the bit field to OR into the PTE to
//    reference a prototype PTE.  And set the protoPTE bit,
//    MM_PTE_PROTOTYPE_MASK.
//
// Arguments
//
//    proto_va - Supplies the address of the prototype PTE.
//
// Return Value:
//
//    Mask to set into the PTE.
//
//--

#define MiProtoAddressForPte(proto_va)  \
   ((((((ULONG)proto_va - MmProtopte_Base) >> 1) & (ULONG)0x000000FE)   | \
    (((((ULONG)proto_va - MmProtopte_Base) << 2) & (ULONG)0xfffff800))) | \
    MM_PTE_PROTOTYPE_MASK)




//++
// ULONG
// MiProtoAddressForKernelPte (
//    IN PMMPTE proto_va
//    );
//
// Routine Description:
//
//    This macro sets into the specified PTE the supplied information
//    to indicate where the backing store for the page is located.
//    MiProtoAddressForPte returns the bit field to OR into the PTE to
//    reference a prototype PTE.  And set the protoPTE bit,
//    MM_PTE_PROTOTYPE_MASK.
//
//    This macro also sets any other information (such as global bits)
//    required for kernel mode PTEs.
//
// Arguments
//
//    proto_va - Supplies the address of the prototype PTE.
//
// Return Value:
//
//    Mask to set into the PTE.
//
//--

//  not different on x86.

#define MiProtoAddressForKernelPte(proto_va)  MiProtoAddressForPte(proto_va)


//++
// PSUBSECTION
// MiGetSubsectionAddress (
//    IN PMMPTE lpte
//    );
//
// Routine Description:
//
//   This macro takes a PTE and returns the address of the subsection that
//   the PTE refers to.  Subsections are quadword structures allocated
//   from nonpaged pool.
//
//   NOTE THIS MACRO LIMITS THE SIZE OF NONPAGED POOL!
//    MAXIMUM NONPAGED POOL = 2^(3+4+21) = 2^28 = 256mb.
//
//
// Arguments
//
//    lpte - Supplies the PTE to operate upon.
//
// Return Value:
//
//    A pointer to the subsection referred to by the supplied PTE.
//
//--

#define MiGetSubsectionAddress(lpte)                              \
    (((lpte)->u.Long & 0x80000000) ?                              \
            ((PSUBSECTION)((PCHAR)MmSubsectionBase +    \
                ((((lpte)->u.Long & 0x7ffff800) >> 4) |              \
                (((lpte)->u.Long<<2) & 0x78)))) \
      : \
            ((PSUBSECTION)((PCHAR)MmNonPagedPoolEnd -    \
                (((((lpte)->u.Long)>>11)<<7) |              \
                (((lpte)->u.Long<<2) & 0x78)))))



//++
// ULONG
// MiGetSubsectionAddressForPte (
//    IN PSUBSECTION VA
//    );
//
// Routine Description:
//
//    This macro takes the address of a subsection and encodes it for use
//    in a PTE.
//
//    NOTE - THE SUBSECTION ADDRESS MUST BE QUADWORD ALIGNED!
//
// Arguments
//
//    VA - Supplies a pointer to the subsection to encode.
//
// Return Value:
//
//     The mask to set into the PTE to make it reference the supplied
//     subsection.
//
//--


#define MiGetSubsectionAddressForPte(VA)                   \
            (((ULONG)(VA) < (ULONG)MmSubsectionBase + 128*1024*1024) ?                  \
   (((((ULONG)VA - (ULONG)MmSubsectionBase)>>2) & (ULONG)0x0000001E) |  \
   ((((((ULONG)VA - (ULONG)MmSubsectionBase)<<4) & (ULONG)0x7ffff800)))| \
   0x80000000) \
            : \
   (((((ULONG)MmNonPagedPoolEnd - (ULONG)VA)>>2) & (ULONG)0x0000001E) |  \
   ((((((ULONG)MmNonPagedPoolEnd - (ULONG)VA)<<4) & (ULONG)0x7ffff800)))))


//++
// PMMPTE
// MiGetPdeAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeAddress returns the address of the PDE which maps the
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PDE for.
//
// Return Value:
//
//    The address of the PDE.
//
//--

#define MiGetPdeAddress(va)  ((PMMPTE)(((((ULONG)(va)) >> 22) << 2) + PDE_BASE))


//++
// PMMPTE
// MiGetPteAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPteAddress returns the address of the PTE which maps the
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PTE for.
//
// Return Value:
//
//    The address of the PTE.
//
//--

#define MiGetPteAddress(va) ((PMMPTE)(((((ULONG)(va)) >> 12) << 2) + PTE_BASE))


//++
// ULONG
// MiGetPpeOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPpeOffset returns the offset into a page root
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page root table the corresponding PPE is at.
//
//--

#define MiGetPpeOffset(va) (0)

//++
// ULONG
// MiGetPdeOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeOffset returns the offset into a page directory
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page directory table the corresponding PDE is at.
//
//--

#define MiGetPdeOffset(va) (((ULONG)(va)) >> 22)

//++
// ULONG
// MiGetPdeIndex (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeIndex returns the page directory index
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The index into the page directory - ie: the virtual page table number.
//    This is different from the page directory offset because this spans
//    page directories on supported platforms.
//
//--

#define MiGetPdeIndex MiGetPdeOffset



//++
// ULONG
// MiGetPteOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPteOffset returns the offset into a page table page
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page table page table the corresponding PTE is at.
//
//--

#define MiGetPteOffset(va) ((((ULONG)(va)) << 10) >> 22)



//++
// PVOID
// MiGetVirtualAddressMappedByPpe (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPpe returns the virtual address
//    which is mapped by a given PPE address.
//
// Arguments
//
//    PPE - Supplies the PPE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PPE.
//
//--

#define MiGetVirtualAddressMappedByPpe(PPE) (NULL)

//++
// PVOID
// MiGetVirtualAddressMappedByPde (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPde returns the virtual address
//    which is mapped by a given PDE address.
//
// Arguments
//
//    PDE - Supplies the PDE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PDE.
//
//--

#define MiGetVirtualAddressMappedByPde(PDE) ((PVOID)((ULONG)(PDE) << 20))


//++
// PVOID
// MiGetVirtualAddressMappedByPte (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPte returns the virtual address
//    which is mapped by a given PTE address.
//
// Arguments
//
//    PTE - Supplies the PTE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PTE.
//
//--

#define MiGetVirtualAddressMappedByPte(PTE) ((PVOID)((ULONG)(PTE) << 10))


//++
// LOGICAL
// MiIsVirtualAddressOnPpeBoundary (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    MiIsVirtualAddressOnPpeBoundary returns TRUE if the virtual address is
//    on a page directory entry boundary.
//
// Arguments
//
//    VA - Supplies the virtual address to check.
//
// Return Value:
//
//    TRUE if on a boundary, FALSE if not.
//
//--

#define MiIsVirtualAddressOnPpeBoundary(VA) (FALSE)


//++
// LOGICAL
// MiIsVirtualAddressOnPdeBoundary (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    MiIsVirtualAddressOnPdeBoundary returns TRUE if the virtual address is
//    on a page directory entry boundary.
//
// Arguments
//
//    VA - Supplies the virtual address to check.
//
// Return Value:
//
//    TRUE if on a 4MB PDE boundary, FALSE if not.
//
//--

#define MiIsVirtualAddressOnPdeBoundary(VA) (((ULONG_PTR)(VA) & PAGE_DIRECTORY_MASK) == 0)

//++
// LOGICAL
// MiIsPteOnPdeBoundary (
//    IN PVOID PTE
//    );
//
// Routine Description:
//
//    MiIsPteOnPdeBoundary returns TRUE if the PTE is
//    on a page directory entry boundary.
//
// Arguments
//
//    PTE - Supplies the PTE to check.
//
// Return Value:
//
//    TRUE if on a 4MB PDE boundary, FALSE if not.
//
//--

#define MiIsPteOnPdeBoundary(PTE) (((ULONG_PTR)(PTE) & (PAGE_SIZE - 1)) == 0)


//++
//ULONG
//GET_PAGING_FILE_NUMBER (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro extracts the paging file number from a PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    The paging file number.
//
//--

#define GET_PAGING_FILE_NUMBER(PTE) ((((PTE).u.Long) >> 1) & 0x0000000F)



//++
//ULONG
//GET_PAGING_FILE_OFFSET (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro extracts the offset into the paging file from a PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    The paging file offset.
//
//--

#define GET_PAGING_FILE_OFFSET(PTE) ((((PTE).u.Long) >> 12) & 0x000FFFFF)




//++
//ULONG
//IS_PTE_NOT_DEMAND_ZERO (
//    IN PMMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro checks to see if a given PTE is NOT a demand zero PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     Returns 0 if the PTE is demand zero, non-zero otherwise.
//
//--

#define IS_PTE_NOT_DEMAND_ZERO(PTE) ((PTE).u.Long & (ULONG)0xFFFFFC01)

//++
// VOID
// MI_MAKE_PROTECT_WRITE_COPY (
//    IN OUT MMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro makes a writable PTE a writable-copy PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    NONE
//
//--

#define MI_MAKE_PROTECT_WRITE_COPY(PTE) \
        if ((PTE).u.Soft.Protection & MM_PROTECTION_WRITE_MASK) {      \
            (PTE).u.Long |= MM_PROTECTION_COPY_MASK << MM_PROTECT_FIELD_SHIFT;      \
        }


//++
// VOID
// MI_SET_PAGE_DIRTY(
//    IN PMMPTE PPTE,
//    IN PVOID VA,
//    IN PVOID PFNHELD
//    );
//
// Routine Description:
//
//    This macro sets the dirty bit (and release page file space).
//
// Arguments
//
//    TEMP - Supplies a temporary for usage.
//
//    PPTE - Supplies a pointer to the PTE that corresponds to VA.
//
//    VA - Supplies a the virtual address of the page fault.
//
//    PFNHELD - Supplies TRUE if the PFN lock is held.
//
// Return Value:
//
//    None.
//
//--

#if defined(NT_UP)
#define MI_SET_PAGE_DIRTY(PPTE,VA,PFNHELD)
#else
#define MI_SET_PAGE_DIRTY(PPTE,VA,PFNHELD)                          \
            if ((PPTE)->u.Hard.Dirty == 1) {                        \
                MiSetDirtyBit ((VA),(PPTE),(PFNHELD));              \
            }
#endif




//++
// VOID
// MI_NO_FAULT_FOUND(
//    IN FAULTSTATUS,
//    IN PMMPTE PPTE,
//    IN PVOID VA,
//    IN PVOID PFNHELD
//    );
//
// Routine Description:
//
//    This macro handles the case when a page fault is taken and no
//    PTE with the valid bit clear is found.
//
// Arguments
//
//    FAULTSTATUS - Supplies the fault status.
//
//    PPTE - Supplies a pointer to the PTE that corresponds to VA.
//
//    VA - Supplies a the virtual address of the page fault.
//
//    PFNHELD - Supplies TRUE if the PFN lock is held.
//
// Return Value:
//
//    None.
//
//--

#if defined(NT_UP)
#define MI_NO_FAULT_FOUND(FAULTSTATUS,PPTE,VA,PFNHELD)
#else
#define MI_NO_FAULT_FOUND(FAULTSTATUS,PPTE,VA,PFNHELD) \
        if ((MI_FAULT_STATUS_INDICATES_WRITE(FAULTSTATUS)) && ((PPTE)->u.Hard.Dirty == 0)) {  \
            MiSetDirtyBit ((VA),(PPTE),(PFNHELD));     \
        }
#endif




//++
// ULONG
// MI_CAPTURE_DIRTY_BIT_TO_PFN (
//    IN PMMPTE PPTE,
//    IN PMMPFN PPFN
//    );
//
// Routine Description:
//
//    This macro gets captures the state of the dirty bit to the PFN
//    and frees any associated page file space if the PTE has been
//    modified element.
//
//    NOTE - THE PFN LOCK MUST BE HELD!
//
// Arguments
//
//    PPTE - Supplies the PTE to operate upon.
//
//    PPFN - Supplies a pointer to the PFN database element that corresponds
//           to the page mapped by the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_CAPTURE_DIRTY_BIT_TO_PFN(PPTE,PPFN)                      \
         ASSERT (KeGetCurrentIrql() > APC_LEVEL);                   \
         if (((PPFN)->u3.e1.Modified == 0) &&                       \
            ((PPTE)->u.Hard.Dirty != 0)) {                          \
             MI_SET_MODIFIED (PPFN, 1, 0x18);                       \
             if (((PPFN)->OriginalPte.u.Soft.Prototype == 0) &&     \
                          ((PPFN)->u3.e1.WriteInProgress == 0)) {   \
                 MiReleasePageFileSpace ((PPFN)->OriginalPte);      \
                 (PPFN)->OriginalPte.u.Soft.PageFileHigh = 0;       \
             }                                                      \
         }


//++
// BOOLEAN
// MI_IS_PHYSICAL_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro determines if a given virtual address is really a
//    physical address.
//
// Arguments
//
//    VA - Supplies the virtual address.
//
// Return Value:
//
//    FALSE if it is not a physical address, TRUE if it is.
//
//--


#define MI_IS_PHYSICAL_ADDRESS(Va) \
    ((MiGetPdeAddress(Va)->u.Long & 0x81) == 0x81)

//++
// ULONG
// MI_CONVERT_PHYSICAL_TO_PFN (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro converts a physical address (see MI_IS_PHYSICAL_ADDRESS)
//    to its corresponding physical frame number.
//
// Arguments
//
//    VA - Supplies a pointer to the physical address.
//
// Return Value:
//
//    Returns the PFN for the page.
//
//--


#define MI_CONVERT_PHYSICAL_TO_PFN(Va)     \
    ((PFN_NUMBER)(MiGetPdeAddress(Va)->u.Hard.PageFrameNumber) + (MiGetPteOffset((ULONG)Va)))


typedef struct _MMCOLOR_TABLES {
    PFN_NUMBER Flink;
    PVOID Blink;
    PFN_NUMBER Count;
} MMCOLOR_TABLES, *PMMCOLOR_TABLES;

extern PMMCOLOR_TABLES MmFreePagesByColor[2];

extern ULONG MmTotalPagesForPagingFile;


//
// A VALID Page Table Entry on the x86 has the following definition.
//

#define MI_MAXIMUM_PAGEFILE_SIZE (((UINT64)1 * 1024 * 1024 - 1) * PAGE_SIZE)

#define MI_PTE_LOOKUP_NEEDED (0xfffff)

typedef struct _MMPTE_SOFTWARE {
    ULONG Valid : 1;
    ULONG PageFileLow : 4;
    ULONG Protection : 5;
    ULONG Prototype : 1;
    ULONG Transition : 1;
    ULONG PageFileHigh : 20;
} MMPTE_SOFTWARE;

typedef struct _MMPTE_TRANSITION {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Protection : 5;
    ULONG Prototype : 1;
    ULONG Transition : 1;
    ULONG PageFrameNumber : 20;
} MMPTE_TRANSITION;

typedef struct _MMPTE_PROTOTYPE {
    ULONG Valid : 1;
    ULONG ProtoAddressLow : 7;
    ULONG ReadOnly : 1;  // if set allow read only access.
    ULONG WhichPool : 1;
    ULONG Prototype : 1;
    ULONG ProtoAddressHigh : 21;
} MMPTE_PROTOTYPE;

typedef struct _MMPTE_SUBSECTION {
    ULONG Valid : 1;
    ULONG SubsectionAddressLow : 4;
    ULONG Protection : 5;
    ULONG Prototype : 1;
    ULONG SubsectionAddressHigh : 20;
    ULONG WhichPool : 1;
} MMPTE_SUBSECTION;

typedef struct _MMPTE_LIST {
    ULONG Valid : 1;
    ULONG OneEntry : 1;
    ULONG filler0 : 8;

    //
    // Note the Prototype bit must not be used for lists like freed nonpaged
    // pool because lookaside pops can legitimately reference bogus addresses
    // (since the pop is unsynchronized) and the fault handler must be able to
    // distinguish lists from protos so a retry status can be returned (vs a
    // fatal bugcheck).
    //

    ULONG Prototype : 1;            // MUST BE ZERO as per above comment.
    ULONG filler1 : 1;
    ULONG NextEntry : 20;
} MMPTE_LIST;

//
// A Page Table Entry on the x86 has the following definition.
// Note the MP version is to avoid stalls when flushing TBs across processors.
//

typedef struct _MMPTE_HARDWARE {
    ULONG Valid : 1;
#if defined(NT_UP)
    ULONG Write : 1;       // UP version
#else
    ULONG Writable : 1;    // changed for MP version
#endif
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG CopyOnWrite : 1; // software field
    ULONG Prototype : 1;   // software field
#if defined(NT_UP)
    ULONG reserved : 1;    // software field
#else
    ULONG Write : 1;       // software field - MP change
#endif
    ULONG PageFrameNumber : 20;
} MMPTE_HARDWARE, *PMMPTE_HARDWARE;

#if defined(NT_UP)
#define HARDWARE_PTE_DIRTY_MASK     0x40
#else
#define HARDWARE_PTE_DIRTY_MASK     0x42
#endif

#define MI_PDE_MAPS_LARGE_PAGE(PDE) ((PDE)->u.Hard.LargePage == 1)

#define MI_MAKE_PDE_MAP_LARGE_PAGE(PDE) ((PDE)->u.Hard.LargePage = 1)

#define MI_GET_PAGE_FRAME_FROM_PTE(PTE) ((PTE)->u.Hard.PageFrameNumber)
#define MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE(PTE) ((PTE)->u.Trans.PageFrameNumber)
#define MI_GET_PROTECTION_FROM_SOFT_PTE(PTE) ((PTE)->u.Soft.Protection)
#define MI_GET_PROTECTION_FROM_TRANSITION_PTE(PTE) ((PTE)->u.Trans.Protection)

typedef struct _MMPTE {
    union  {
        ULONG Long;
        HARDWARE_PTE Flush;
        MMPTE_HARDWARE Hard;
        MMPTE_PROTOTYPE Proto;
        MMPTE_SOFTWARE Soft;
        MMPTE_TRANSITION Trans;
        MMPTE_SUBSECTION Subsect;
        MMPTE_LIST List;
        } u;
} MMPTE;

typedef MMPTE *PMMPTE;

extern MMPTE MmPteGlobal; // Set if processor supports Global Page, else zero.

extern PMMPTE MiFirstReservedZeroingPte;

#define InterlockedCompareExchangePte(_PointerPte, _NewContents, _OldContents) \
        InterlockedCompareExchange ((PLONG)(_PointerPte), _NewContents, _OldContents)

#define InterlockedExchangePte(_PointerPte, _NewContents) InterlockedExchange((PLONG)(_PointerPte), _NewContents)

//++
// VOID
// MI_WRITE_VALID_PTE (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_VALID_PTE fills in the specified PTE making it valid with the
//    specified contents.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_VALID_PTE(_PointerPte, _PteContents)       \
            ASSERT ((_PointerPte)->u.Hard.Valid == 0);      \
            ASSERT ((_PteContents).u.Hard.Valid == 1);      \
            MI_INSERT_VALID_PTE(_PointerPte);               \
            MI_LOG_PTE_CHANGE (_PointerPte, _PteContents);  \
            (*(_PointerPte) = (_PteContents))

//++
// VOID
// MI_WRITE_INVALID_PTE (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_INVALID_PTE fills in the specified PTE making it invalid with the
//    specified contents.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_INVALID_PTE(_PointerPte, _PteContents)     \
            ASSERT ((_PteContents).u.Hard.Valid == 0);      \
            MI_REMOVE_PTE(_PointerPte);                     \
            MI_LOG_PTE_CHANGE (_PointerPte, _PteContents);  \
            (*(_PointerPte) = (_PteContents))

#define MI_WRITE_INVALID_PTE_WITHOUT_WS MI_WRITE_INVALID_PTE

//++
// VOID
// MI_WRITE_ZERO_PTE (
//    IN PMMPTE PointerPte
//    );
//
// Routine Description:
//
//    MI_WRITE_ZERO_PTE fills the specified PTE with zero, making it invalid.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_ZERO_PTE(_PointerPte)                      \
            MI_REMOVE_PTE(_PointerPte);                     \
            MI_LOG_PTE_CHANGE (_PointerPte, ZeroPte);       \
            (_PointerPte)->u.Long = 0;

//++
// VOID
// MI_WRITE_VALID_PTE_NEW_PROTECTION (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_VALID_PTE_NEW_PROTECTION fills in the specified PTE (which was
//    already valid) changing only the protection or the dirty bit.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_VALID_PTE_NEW_PROTECTION(_PointerPte, _PteContents)    \
            ASSERT ((_PointerPte)->u.Hard.Valid == 1);  \
            ASSERT ((_PteContents).u.Hard.Valid == 1);  \
            ASSERT ((_PointerPte)->u.Hard.PageFrameNumber == (_PteContents).u.Hard.PageFrameNumber); \
            MI_LOG_PTE_CHANGE (_PointerPte, _PteContents);  \
            (*(_PointerPte) = (_PteContents))

//++
// VOID
// MI_WRITE_VALID_PTE_NEW_PAGE (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_VALID_PTE_NEW_PAGE fills in the specified PTE (which was
//    already valid) changing the page and the protection.
//    Note that the contents are very carefully written.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_VALID_PTE_NEW_PAGE(_PointerPte, _PteContents)    \
            ASSERT ((_PointerPte)->u.Hard.Valid == 1);  \
            ASSERT ((_PteContents).u.Hard.Valid == 1);  \
            ASSERT ((_PointerPte)->u.Hard.PageFrameNumber != (_PteContents).u.Hard.PageFrameNumber); \
            MI_LOG_PTE_CHANGE (_PointerPte, _PteContents);  \
            (*(_PointerPte) = (_PteContents))

//++
// VOID
// MiFillMemoryPte (
//    IN PMMPTE Destination,
//    IN ULONG  NumberOfPtes,
//    IN MMPTE  Pattern,
//    };
//
// Routine Description:
//
//    This function fills memory with the specified PTE pattern.
//
// Arguments
//
//    Destination - Supplies a pointer to the memory to fill.
//
//    NumberOfPtes - Supplies the number of PTEs (not bytes!) to be filled.
//
//    Pattern     - Supplies the PTE fill pattern.
//
// Return Value:
//
//    None.
//
//--

#define MiFillMemoryPte(Destination, Length, Pattern) \
             RtlFillMemoryUlong ((Destination), (Length) * sizeof (MMPTE), (Pattern))

#define MiZeroMemoryPte(Destination, Length) \
             RtlZeroMemory ((Destination), (Length) * sizeof (MMPTE))

//++
// BOOLEAN
// MI_IS_WRITE_COMBINE_ENABLED (
//    IN PMMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and returns TRUE if write combine is
//    enabled.
//
// Arguments
//
//    PPTE - Supplies a pointer to the valid PTE.
//
// Return Value:
//
//     TRUE if write combine is enabled, FALSE if it is disabled.
//
//--

__forceinline
LOGICAL
MI_IS_WRITE_COMBINE_ENABLED (
    IN PMMPTE PointerPte
    )
{
    if (MiWriteCombiningPtes == TRUE) {
        if ((PointerPte->u.Hard.CacheDisable == 0) &&
            (PointerPte->u.Hard.WriteThrough == 1)) {

            return TRUE;
        }
    }
    else {
        if ((PointerPte->u.Hard.CacheDisable == 1) &&
            (PointerPte->u.Hard.WriteThrough == 0)) {

            return TRUE;
        }
    }

    return FALSE;
}

ULONG
FASTCALL
MiDetermineUserGlobalPteMask (
    IN PMMPTE Pte
    );

//++
// BOOLEAN
// MI_IS_PAGE_TABLE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a page table address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a page table address, FALSE if not.
//
//--

#define MI_IS_PAGE_TABLE_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)PTE_BASE && (PVOID)(VA) <= (PVOID)PTE_TOP)

//++
// BOOLEAN
// MI_IS_PAGE_TABLE_OR_HYPER_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a page table or hyperspace address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a page table or hyperspace address, FALSE if not.
//
//--

#define MI_IS_PAGE_TABLE_OR_HYPER_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)PTE_BASE && (PVOID)(VA) <= (PVOID)MmHyperSpaceEnd)

//++
// BOOLEAN
// MI_IS_KERNEL_PAGE_TABLE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a page table address for a kernel address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a kernel page table address, FALSE if not.
//
//--

#define MI_IS_KERNEL_PAGE_TABLE_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)MiGetPteAddress(MmSystemRangeStart) && (PVOID)(VA) <= (PVOID)PTE_TOP)


//++
// BOOLEAN
// MI_IS_PAGE_DIRECTORY_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a page directory address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a page directory address, FALSE if not.
//
//--

#define MI_IS_PAGE_DIRECTORY_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)PDE_BASE && (PVOID)(VA) <= (PVOID)PDE_TOP)


//++
// BOOLEAN
// MI_IS_HYPER_SPACE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a hyper space address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a hyper space address, FALSE if not.
//
//--

#define MI_IS_HYPER_SPACE_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)HYPER_SPACE && (PVOID)(VA) <= (PVOID)MmHyperSpaceEnd)


//++
// BOOLEAN
// MI_IS_PROCESS_SPACE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a process-specific address.  This is an address in user space
//    or page table pages or hyper space.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a process-specific address, FALSE if not.
//
//--

#define MI_IS_PROCESS_SPACE_ADDRESS(VA)   \
            (((PVOID)(VA) <= (PVOID)MM_HIGHEST_USER_ADDRESS) || \
             ((PVOID)(VA) >= (PVOID)PTE_BASE && (PVOID)(VA) <= (PVOID)MmHyperSpaceEnd))


//++
// BOOLEAN
// MI_IS_PTE_PROTOTYPE (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a PTE address and determines if it is a prototype PTE.
//
// Arguments
//
//    PTE - Supplies the virtual address of the PTE to check.
//
// Return Value:
//
//    TRUE if the PTE is in a segment (ie, a prototype PTE), FALSE if not.
//
//--

#define MI_IS_PTE_PROTOTYPE(PTE)   \
            ((PTE) > (PMMPTE)PTE_TOP)

//++
// BOOLEAN
// MI_IS_SYSTEM_CACHE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a system cache address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is in the system cache, FALSE if not.
//
//--

#define MI_IS_SYSTEM_CACHE_ADDRESS(VA)                            \
         (((PVOID)(VA) >= (PVOID)MmSystemCacheStart &&            \
		     (PVOID)(VA) <= (PVOID)MmSystemCacheEnd)  ||          \
          ((PVOID)(VA) >= (PVOID)MiSystemCacheStartExtra &&       \
			  (PVOID)(VA) <= (PVOID)MiSystemCacheEndExtra))

//++
// VOID
// MI_BARRIER_SYNCHRONIZE (
//    IN ULONG TimeStamp
//    );
//
// Routine Description:
//
//    MI_BARRIER_SYNCHRONIZE compares the argument timestamp against the
//    current IPI barrier sequence stamp.  When equal, all processors will
//    issue memory barriers to ensure that newly created pages remain coherent.
//
//    When a page is put in the zeroed or free page list the current
//    barrier sequence stamp is read (interlocked - this is necessary
//    to get the correct value - memory barriers won't do the trick)
//    and stored in the pfn entry for the page. The current barrier
//    sequence stamp is maintained by the IPI send logic and is
//    incremented (interlocked) when the target set of an IPI send
//    includes all processors, but the one doing the send. When a page
//    is needed its sequence number is compared against the current
//    barrier sequence number.  If it is equal, then the contents of
//    the page may not be coherent on all processors, and an IPI must
//    be sent to all processors to ensure a memory barrier is
//    executed (generic call can be used for this). Sending the IPI
//    automatically updates the barrier sequence number. The compare
//    is for equality as this is the only value that requires the IPI
//    (i.e., the sequence number wraps, values in both directions are
//    older). When a page is removed in this fashion and either found
//    to be coherent or made coherent, it cannot be modified between
//    that time and writing the PTE. If the page is modified between
//    these times, then an IPI must be sent.
//
// Arguments
//
//    TimeStamp - Supplies the timestamp at the time when the page was zeroed.
//
// Return Value:
//
//    None.
//
//--

// does nothing on i386.

#define MI_BARRIER_SYNCHRONIZE(TimeStamp)

//++
// VOID
// MI_BARRIER_STAMP_ZEROED_PAGE (
//    IN PULONG PointerTimeStamp
//    );
//
// Routine Description:
//
//    MI_BARRIER_STAMP_ZEROED_PAGE issues an interlocked read to get the
//    current IPI barrier sequence stamp.  This is called AFTER a page is
//    zeroed.
//
// Arguments
//
//    PointerTimeStamp - Supplies a timestamp pointer to fill with the
//                       current IPI barrier sequence stamp.
//
// Return Value:
//
//    None.
//
//--

// does nothing on i386.

#define MI_BARRIER_STAMP_ZEROED_PAGE(PointerTimeStamp)

//++
// LOGICAL
// MI_RESERVED_BITS_CANONICAL (
//    IN PVOID VirtualAddress
//    );
//
// Routine Description:
//
//    This routine checks whether all of the reserved bits are correct.
//
//    This does nothing on the x86.
//
// Arguments
//
//    VirtualAddress - Supplies the virtual address to check.
//
// Return Value:
//
//    None.
//
#define MI_RESERVED_BITS_CANONICAL(VirtualAddress)  TRUE

//++
// VOID
// MI_DISPLAY_TRAP_INFORMATION (
//    IN PVOID TrapInformation
//    );
//
// Routine Description:
//
//    Display any relevant trap information to aid debugging.
//
// Arguments
//
//    TrapInformation - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
#define MI_DISPLAY_TRAP_INFORMATION(TrapInformation)                    \
            KdPrint(("MM:***EIP %p, EFL %p\n",                          \
                     ((PKTRAP_FRAME) (TrapInformation))->Eip,           \
                     ((PKTRAP_FRAME) (TrapInformation))->EFlags));      \
            KdPrint(("MM:***EAX %p, ECX %p EDX %p\n",                   \
                     ((PKTRAP_FRAME) (TrapInformation))->Eax,           \
                     ((PKTRAP_FRAME) (TrapInformation))->Ecx,           \
                     ((PKTRAP_FRAME) (TrapInformation))->Edx));         \
            KdPrint(("MM:***EBX %p, ESI %p EDI %p\n",                   \
                     ((PKTRAP_FRAME) (TrapInformation))->Ebx,           \
                     ((PKTRAP_FRAME) (TrapInformation))->Esi,           \
                     ((PKTRAP_FRAME) (TrapInformation))->Edi));

#else
#include "i386\mipae.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\i386\init386.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    init386.c

Abstract:

    This module contains the machine dependent initialization for the
    memory management component.  It is specifically tailored to the
    INTEL x86 and PAE machines.

--*/

#include "mi.h"

PFN_NUMBER
MxGetNextPage (
    IN PFN_NUMBER PagesNeeded,
    IN LOGICAL UseSlush
    );

PFN_NUMBER
MxPagesAvailable (
    VOID
    );

VOID
MxConvertToLargePage (
    IN PVOID VirtualAddress,
    IN PVOID EndVirtualAddress
    );

LOGICAL
MiIsRegularMemory (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_NUMBER PageFrameIndex
    );

PMEMORY_ALLOCATION_DESCRIPTOR
MiFindDescriptor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_NUMBER PageFrameIndex
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,MiInitMachineDependent)
#pragma alloc_text(INIT,MxGetNextPage)
#pragma alloc_text(INIT,MxPagesAvailable)
#pragma alloc_text(INIT,MxConvertToLargePage)
#pragma alloc_text(INIT,MiReportPhysicalMemory)
#pragma alloc_text(INIT,MiIsRegularMemory)
#pragma alloc_text(INIT,MiFindDescriptor)
#endif

#define MM_LARGE_PAGE_MINIMUM  ((255*1024*1024) >> PAGE_SHIFT)

extern ULONG MmLargeSystemCache;
extern ULONG MmLargeStackSize;
extern LOGICAL MmMakeLowMemory;
extern LOGICAL MmPagedPoolMaximumDesired;

PVOID MmHyperSpaceEnd;

//
// Local data.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif

ULONG MxPfnAllocation;

PMEMORY_ALLOCATION_DESCRIPTOR MxFreeDescriptor;
PMEMORY_ALLOCATION_DESCRIPTOR MxSlushDescriptor1;
PMEMORY_ALLOCATION_DESCRIPTOR MxSlushDescriptor2;

PFN_NUMBER MiSlushDescriptorBase;
PFN_NUMBER MiSlushDescriptorCount;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

MEMORY_ALLOCATION_DESCRIPTOR MxOldFreeDescriptor;
MEMORY_ALLOCATION_DESCRIPTOR MxOldSlushDescriptor1;
MEMORY_ALLOCATION_DESCRIPTOR MxOldSlushDescriptor2;

typedef struct _MI_LARGE_VA_RANGES {
    PVOID VirtualAddress;
    PVOID EndVirtualAddress;
} MI_LARGE_VA_RANGES, *PMI_LARGE_VA_RANGES;

//
// There are potentially 3 large page ranges:
//
// 1. PFN database + initial nonpaged pool
// 2. Kernel code/data
// 3. HAL code/data
//

#define MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL     0x1
#define MI_LARGE_KERNEL_HAL                         0x2

#define MI_LARGE_ALL                                0x3

ULONG MxMapLargePages = MI_LARGE_ALL;

#define MI_MAX_LARGE_VA_RANGES 3

ULONG MiLargeVaRangeIndex;
MI_LARGE_VA_RANGES MiLargeVaRanges[MI_MAX_LARGE_VA_RANGES];

#define MM_PFN_MAPPED_BY_PDE (MM_VA_MAPPED_BY_PDE >> PAGE_SHIFT)


PFN_NUMBER
MxGetNextPage (
    IN PFN_NUMBER PagesNeeded,
    IN LOGICAL UseSlush
    )

/*++

Routine Description:

    This function returns the next physical page number from the largest
    largest free descriptor.  If there are not enough physical pages left
    to satisfy the request then a bugcheck is executed since the system
    cannot be initialized.

Arguments:

    PagesNeeded - Supplies the number of pages needed.

    UseSlush - Supplies TRUE if the slush descriptor can be used (ie, the
               allocation will never be freed and will always be cachable).

Return Value:

    The base of the range of physically contiguous pages.

Environment:

    Kernel mode, Phase 0 only.

--*/

{
    PFN_NUMBER PageFrameIndex;

    if (UseSlush == TRUE) {

        if ((MxSlushDescriptor1 != NULL) &&
            (PagesNeeded <= MxSlushDescriptor1->PageCount)) {

            PageFrameIndex = MxSlushDescriptor1->BasePage;

            MxSlushDescriptor1->BasePage += (ULONG) PagesNeeded;
            MxSlushDescriptor1->PageCount -= (ULONG) PagesNeeded;

            return PageFrameIndex;
        }

        if ((MxSlushDescriptor2 != NULL) &&
            (PagesNeeded <= MxSlushDescriptor2->PageCount)) {

            PageFrameIndex = MxSlushDescriptor2->BasePage;

            MxSlushDescriptor2->BasePage += (ULONG) PagesNeeded;
            MxSlushDescriptor2->PageCount -= (ULONG) PagesNeeded;

            return PageFrameIndex;
        }
    }

    //
    // Examine the free descriptor to see if enough usable memory is available.
    //

    if (PagesNeeded > MxFreeDescriptor->PageCount) {

        KeBugCheckEx (INSTALL_MORE_MEMORY,
                      MmNumberOfPhysicalPages,
                      MxFreeDescriptor->PageCount,
                      MxOldFreeDescriptor.PageCount,
                      PagesNeeded);
    }

    PageFrameIndex = MxFreeDescriptor->BasePage;

    MxFreeDescriptor->BasePage += PagesNeeded;
    MxFreeDescriptor->PageCount -= PagesNeeded;

    return PageFrameIndex;
}

PFN_NUMBER
MxPagesAvailable (
    VOID
    )

/*++

Routine Description:

    This function returns the number of pages available.
    
Arguments:

    None.

Return Value:

    The number of physically contiguous pages currently available.

Environment:

    Kernel mode, Phase 0 only.

--*/

{
    return MxFreeDescriptor->PageCount;
}


VOID
MxConvertToLargePage (
    IN PVOID VirtualAddress,
    IN PVOID EndVirtualAddress
    )

/*++

Routine Description:

    This function converts the backing for the supplied virtual address range
    to a large page mapping.
    
Arguments:

    VirtualAddress - Supplies the virtual address to convert to a large page.

    EndVirtualAddress - Supplies the end virtual address to convert to a
                        large page.

Return Value:

    None.

Environment:

    Kernel mode, Phase 1 only.

--*/

{
    ULONG i;
    MMPTE TempPde;
    PMMPTE PointerPde;
    PMMPTE LastPde;
    PMMPTE PointerPte;
    KIRQL OldIrql;
    PMMPFN Pfn1;
    PFN_NUMBER PageFrameIndex;
    LOGICAL ValidPteFound;
    PFN_NUMBER LargePageBaseFrame;

    ASSERT (MxMapLargePages != 0);

    PointerPde = MiGetPdeAddress (VirtualAddress);
    LastPde = MiGetPdeAddress (EndVirtualAddress);

    TempPde = ValidKernelPde;
    TempPde.u.Hard.LargePage = 1;

    MI_SET_GLOBAL_STATE (TempPde, 1);

    LOCK_PFN (OldIrql);

    do {
        ASSERT (PointerPde->u.Hard.Valid == 1);

        if (PointerPde->u.Hard.LargePage == 1) {
            goto skip;
        }

        PointerPte = MiGetVirtualAddressMappedByPte (PointerPde);

        //
        // Here's a nasty little hack - the page table page mapping the kernel
        // and HAL (built by the loader) does not necessarily fill all the
        // page table entries (ie: any number of leading entries may be zero).
        //
        // To deal with this, walk forward until a nonzero entry is found
        // and re-index the large page based on this.
        //

        ValidPteFound = FALSE;
        LargePageBaseFrame = (ULONG)-1;
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
    
        ASSERT ((PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) == 0);

        for (i = 0; i < PTE_PER_PAGE; i += 1) {

            ASSERT ((PointerPte->u.Long == 0) ||
                    (ValidPteFound == FALSE) ||
                    (PageFrameIndex == MI_GET_PAGE_FRAME_FROM_PTE (PointerPte)));
            if (PointerPte->u.Hard.Valid == 1) {
                if (ValidPteFound == FALSE) {
                    ValidPteFound = TRUE;
                    PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                    LargePageBaseFrame = PageFrameIndex - i;
                }
            }
            PointerPte += 1;
            PageFrameIndex += 1;
        }
    
        if (ValidPteFound == FALSE) {
            goto skip;
        }

        TempPde.u.Hard.PageFrameNumber = LargePageBaseFrame;

        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPde);

        MI_WRITE_VALID_PTE_NEW_PAGE (PointerPde, TempPde);

        //
        // Update the idle process to use the large page mapping also as
        // the page table page is going to be freed.
        //

        MmSystemPagePtes [((ULONG_PTR)PointerPde &
            (PD_PER_SYSTEM * (sizeof(MMPTE) * PDE_PER_PAGE) - 1)) / sizeof(MMPTE)] = TempPde;

        MI_FLUSH_ENTIRE_TB (0xF);

        //
        // If booted /3GB, then retain the original page table page because
        // there is a temporary alternate mapping at 8xxx.xxxx to the
        // kernel/HAL, registry and other boot loader stuff.
        //

        if (MmVirtualBias == 0) {

            if (((PageFrameIndex >= MxOldSlushDescriptor1.BasePage) &&
                (PageFrameIndex < MxOldSlushDescriptor1.BasePage + MxOldSlushDescriptor1.PageCount)) ||

                ((PageFrameIndex >= MxOldSlushDescriptor2.BasePage) &&
                 (PageFrameIndex < MxOldSlushDescriptor2.BasePage + MxOldSlushDescriptor2.PageCount))) {

                //
                // Excess slush is given to expansion nonpaged pool here to
                // ensure that it is always mapped fully cached since the
                // rest of the large page is inserted as fully cached into
                // the TB.
                //

                MiAddExpansionNonPagedPool (PageFrameIndex, 1, TRUE);
            }
            else {
                Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
                Pfn1->u2.ShareCount = 0;
                Pfn1->u3.e2.ReferenceCount = 1;
                Pfn1->u3.e1.PageLocation = StandbyPageList;
                MI_SET_PFN_DELETED (Pfn1);
                MiDecrementReferenceCount (Pfn1, PageFrameIndex);
            }
        }

skip:
        PointerPde += 1;
    } while (PointerPde <= LastPde);

    UNLOCK_PFN (OldIrql);
}

VOID
MiReportPhysicalMemory (
    VOID
    )

/*++

Routine Description:

    This routine is called during Phase 0 initialization once the
    MmPhysicalMemoryBlock has been constructed.  It's job is to decide
    which large page ranges to enable later and also to construct a
    large page comparison list so any requests which are not fully cached
    can check this list in order to refuse conflicting requests.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.  Phase 0 only.

    This is called before any non-MmCached allocations are made.

--*/

{
    ULONG i, j;
    PMMPTE PointerPte;
    LOGICAL EntryFound;
    PFN_NUMBER count;
    PFN_NUMBER Page;
    PFN_NUMBER LastPage;
    PFN_NUMBER PageFrameIndex;
    PFN_NUMBER LastPageFrameIndex;
    PFN_NUMBER PageFrameIndex2;

    //
    // Examine the physical memory block to see whether large pages should
    // be enabled.  The key point is that all the physical pages within a
    // given large page range must have the same cache attributes (MmCached)
    // in order to maintain TB coherency.  This can be done provided all
    // the pages within the large page range represent real RAM (as described
    // by the loader) so that memory management can control it.  If any
    // portion of the large page range is not RAM, it is possible that it
    // may get used as noncached or writecombined device memory and
    // therefore large pages cannot be used.
    //

    if (MxMapLargePages == 0) {
        return;
    }

    for (i = 0; i < MiLargeVaRangeIndex; i += 1) {
        PointerPte = MiGetPteAddress (MiLargeVaRanges[i].VirtualAddress);
        ASSERT (PointerPte->u.Hard.Valid == 1);
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

        PointerPte = MiGetPteAddress (MiLargeVaRanges[i].EndVirtualAddress);
        ASSERT (PointerPte->u.Hard.Valid == 1);
        LastPageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

        //
        // Round the start down to a page directory boundary and the end to
        // the last page directory entry before the next boundary.
        //

        PageFrameIndex &= ~(MM_PFN_MAPPED_BY_PDE - 1);
        LastPageFrameIndex |= (MM_PFN_MAPPED_BY_PDE - 1);

        EntryFound = FALSE;

        j = 0;
        do {

            count = MmPhysicalMemoryBlock->Run[j].PageCount;
            Page = MmPhysicalMemoryBlock->Run[j].BasePage;

            LastPage = Page + count;

            if ((PageFrameIndex >= Page) && (LastPageFrameIndex < LastPage)) {
                EntryFound = TRUE;
                break;
            }

            j += 1;

        } while (j != MmPhysicalMemoryBlock->NumberOfRuns);

        if (EntryFound == FALSE) {

            //
            // No entry was found that completely spans this large page range.
            // Zero it so this range will not be converted into large pages
            // later.
            //

            DbgPrintEx (DPFLTR_MM_ID, DPFLTR_WARNING_LEVEL, 
                "MM: Loader/HAL memory block indicates large pages cannot be used for %p->%p\n",
                MiLargeVaRanges[i].VirtualAddress,
                MiLargeVaRanges[i].EndVirtualAddress);

            MiLargeVaRanges[i].VirtualAddress = NULL;

            //
            // Don't use large pages for anything if this chunk overlaps any
            // others in the request list.  This is because 2 separate ranges
            // may share a straddling large page.  If the first range was unable
            // to use large pages, but the second one does ... then only part
            // of the first range will get large pages if we enable large
            // pages for the second range.  This would be vey bad as we use
            // the MI_IS_PHYSICAL macro everywhere and assume the entire
            // range is in or out, so disable all large pages here instead.
            //

            for (j = 0; j < MiLargeVaRangeIndex; j += 1) {

                //
                // Skip the range that is already being rejected.
                //

                if (i == j) {
                    continue;
                }

                //
                // Skip any range which has already been removed.
                //

                if (MiLargeVaRanges[j].VirtualAddress == NULL) {
                    continue;
                }

                PointerPte = MiGetPteAddress (MiLargeVaRanges[j].VirtualAddress);
                ASSERT (PointerPte->u.Hard.Valid == 1);
                PageFrameIndex2 = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

                if ((PageFrameIndex2 >= PageFrameIndex) &&
                    (PageFrameIndex2 <= LastPageFrameIndex)) {

                    DbgPrintEx (DPFLTR_MM_ID, DPFLTR_WARNING_LEVEL, 
                        "MM: Disabling large pages for all ranges due to overlap\n");

                    goto RemoveAllRanges;
                }

                //
                // Since it is not possible for any request chunk to completely
                // encompass another one, checking only the start and end
                // addresses is sufficient.
                //

                PointerPte = MiGetPteAddress (MiLargeVaRanges[j].EndVirtualAddress);
                ASSERT (PointerPte->u.Hard.Valid == 1);
                PageFrameIndex2 = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

                if ((PageFrameIndex2 >= PageFrameIndex) &&
                    (PageFrameIndex2 <= LastPageFrameIndex)) {

                    DbgPrintEx (DPFLTR_MM_ID, DPFLTR_WARNING_LEVEL, 
                        "MM: Disabling large pages for all ranges due to overlap\n");

                    goto RemoveAllRanges;
                }
            }

            //
            // No other ranges overlapped with this one, it is sufficient to
            // just disable this range and continue to attempt to use large
            // pages for any others.
            //

            continue;
        }

        MiAddCachedRange (PageFrameIndex, LastPageFrameIndex);
    }

    return;

RemoveAllRanges:

    while (i != 0) {

        i -= 1;

        if (MiLargeVaRanges[i].VirtualAddress != NULL) {

            PointerPte = MiGetPteAddress (MiLargeVaRanges[i].VirtualAddress);
            ASSERT (PointerPte->u.Hard.Valid == 1);
            PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

            PointerPte = MiGetPteAddress (MiLargeVaRanges[i].EndVirtualAddress);
            ASSERT (PointerPte->u.Hard.Valid == 1);
            LastPageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

            //
            // Round the start down to a page directory boundary and the end to
            // the last page directory entry before the next boundary.
            //

            PageFrameIndex &= ~(MM_PFN_MAPPED_BY_PDE - 1);
            LastPageFrameIndex |= (MM_PFN_MAPPED_BY_PDE - 1);

            MiRemoveCachedRange (PageFrameIndex, LastPageFrameIndex);
        }
    }

    MiLargeVaRangeIndex = 0;

    return;
}

LOGICAL
MiIsRegularMemory (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_NUMBER PageFrameIndex
    )

/*++

Routine Description:

    This routine checks whether the argument page frame index represents
    regular memory in the loader descriptor block.  It is only used very
    early during Phase0 init because the MmPhysicalMemoryBlock is not yet
    initialized.

Arguments:

    LoaderBlock  - Supplies a pointer to the firmware setup loader block.

    PageFrameIndex  - Supplies the page frame index to check.

Return Value:

    TRUE if the frame represents regular memory, FALSE if not.

Environment:

    Kernel mode.

--*/

{
    PLIST_ENTRY NextMd;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD (NextMd,
                                              MEMORY_ALLOCATION_DESCRIPTOR,
                                              ListEntry);

        if (PageFrameIndex >= MemoryDescriptor->BasePage) {

            if (PageFrameIndex < MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) {

                if ((MemoryDescriptor->MemoryType == LoaderFirmwarePermanent) ||
                    (MemoryDescriptor->MemoryType == LoaderBBTMemory) ||
                    (MemoryDescriptor->MemoryType == LoaderSpecialMemory)) {

                    //
                    // This page lies in a memory descriptor for which we will
                    // never create PFN entries, hence return FALSE.
                    //

                    break;
                }

                return TRUE;
            }
        }
        else {

            //
            // Since the loader memory list is sorted in ascending order,
            // the requested page must not be in the loader list at all.
            //

            break;
        }

        NextMd = MemoryDescriptor->ListEntry.Flink;
    }

    //
    // The final check before returning FALSE is to ensure that the requested
    // page wasn't one of the ones we used to normal-map the loader mappings,
    // etc.
    //

    if ((PageFrameIndex >= MxOldFreeDescriptor.BasePage) &&
        (PageFrameIndex < MxOldFreeDescriptor.BasePage + MxOldFreeDescriptor.PageCount)) {

        return TRUE;
    }

    if ((PageFrameIndex >= MxOldSlushDescriptor1.BasePage) &&
        (PageFrameIndex < MxOldSlushDescriptor1.BasePage + MxOldSlushDescriptor1.PageCount)) {

        return TRUE;
    }

    if ((PageFrameIndex >= MxOldSlushDescriptor2.BasePage) &&
        (PageFrameIndex < MxOldSlushDescriptor2.BasePage + MxOldSlushDescriptor2.PageCount)) {

        return TRUE;
    }

    if ((PageFrameIndex >= MiSlushDescriptorBase) &&
        (PageFrameIndex < MiSlushDescriptorBase + MiSlushDescriptorCount)) {

        return TRUE;
    }

    return FALSE;
}

PMEMORY_ALLOCATION_DESCRIPTOR
MiFindDescriptor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_NUMBER PageFrameIndex
    )
{
    PLIST_ENTRY NextMd;
    PFN_NUMBER PageCount;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;

    PageCount = MM_PFN_MAPPED_BY_PDE - (PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1));

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD (NextMd,
                                              MEMORY_ALLOCATION_DESCRIPTOR,
                                              ListEntry);

        if (MemoryDescriptor->BasePage == PageFrameIndex) {

            //
            // Found the descriptor following the image.  If
            // it is marked firmware temporary and it spans
            // to the *next* large page boundary, then it's good.
            //

            if ((MemoryDescriptor->MemoryType == LoaderFirmwareTemporary) &&
                (MemoryDescriptor->PageCount == PageCount) &&
                (MemoryDescriptor != MxFreeDescriptor)) {

                return MemoryDescriptor;
            }

            break;
        }

        NextMd = MemoryDescriptor->ListEntry.Flink;
    }

    return NULL;
}

#define MI_IS_PTE_VALID(PTE) ((PTE)->u.Hard.Valid == 1)


VOID
MiInitMachineDependent (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine performs the necessary operations to enable virtual
    memory.  This includes building the page directory page, building
    page table pages to map the code section, the data section, the
    stack section and the trap handler.

    It also initializes the PFN database and populates the free list.

Arguments:

    LoaderBlock  - Supplies a pointer to the firmware setup loader block.

Return Value:

    None.

Environment:

    Kernel mode.

    N.B.  This routine uses memory from the loader block descriptors, but
    the descriptors themselves must be restored prior to return as our caller
    walks them to create the MmPhysicalMemoryBlock.

--*/

{
    ULONG ExtraPtes1;
    PMMPTE ExtraPtes1Pointer;
    ULONG ExtraPtes2;
    PFN_NUMBER TotalFreePages;
    LOGICAL InitialNonPagedPoolSetViaRegistry;
    PMMPFN AlignedPfnDatabase;
    PHYSICAL_ADDRESS MaxHotPlugMemoryAddress;
    ULONG Bias;
    PMMPFN BasePfn;
    PMMPFN BottomPfn;
    PMMPFN TopPfn;
    PFN_NUMBER FirstPfnDatabasePage;
    ULONG BasePage;
    PFN_NUMBER PagesLeft;
    ULONG Range;
    PFN_NUMBER PageCount;
    ULONG i, j;
    PFN_NUMBER PdePageNumber;
    PFN_NUMBER PdePage;
    PFN_NUMBER PageFrameIndex;
    ULONG MaxPool;
    PEPROCESS CurrentProcess;
    ULONG DirBase;
    ULONG MostFreePage;
    PFN_NUMBER PagesNeeded;
    PLIST_ENTRY NextMd;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR TempSlushDescriptor;
    MMPTE TempPde;
    MMPTE TempPte;
    PMMPTE PointerPde;
    PMMPTE PointerPte;
    PMMPTE LastPte;
    PMMPTE Pde;
    PMMPTE StartPde;
    PMMPTE EndPde;
    PMMPFN Pfn1;
    PMMPFN Pfn2;
    ULONG PdeCount;
    ULONG va;
    KIRQL OldIrql;
    PVOID VirtualAddress;
    PVOID EndVirtualAddress;
    PVOID NonPagedPoolStartVirtual;
    PVOID NonPagedPoolStartLow;
    LOGICAL ExtraSystemCacheViews;
    SIZE_T MaximumNonPagedPoolInBytesLimit;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    PLIST_ENTRY NextEntry;
    ULONG ReturnedLength;
    NTSTATUS status;
    UCHAR Associativity;
    ULONG NonPagedSystemStart;
    LOGICAL PagedPoolMaximumDesired;
    SIZE_T NumberOfBytes;
    ULONG DummyFlags;

    if (InitializationPhase == 1) {

        //
        // If *ALL* the booted processors support large pages, and the
        // number of physical pages is greater than the threshold, then map
        // the kernel image, HAL, PFN database and initial nonpaged pool
        // with large pages.
        //

        if ((KeFeatureBits & KF_LARGE_PAGE) && (MxMapLargePages != 0)) {
            for (i = 0; i < MiLargeVaRangeIndex; i += 1) {
                if (MiLargeVaRanges[i].VirtualAddress != NULL) {
                    MxConvertToLargePage (MiLargeVaRanges[i].VirtualAddress,
                                          MiLargeVaRanges[i].EndVirtualAddress);
                }
            }
        }

        return;
    }

    ASSERT (InitializationPhase == 0);
    ASSERT (MxMapLargePages == MI_LARGE_ALL);

    ExtraPtes1 = 0;
    ExtraPtes2 = 0;
    ExtraPtes1Pointer = NULL;
    ExtraSystemCacheViews = FALSE;
    MostFreePage = 0;
    NonPagedPoolStartLow = NULL;
    PagedPoolMaximumDesired = FALSE;

    //
    // Initializing these is not needed for correctness, but without it
    // the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    FirstPfnDatabasePage = 0;
    MaximumNonPagedPoolInBytesLimit = 0;

    //
    // If the chip doesn't support large pages then disable large page support.
    //

    if ((KeFeatureBits & KF_LARGE_PAGE) == 0) {
        MxMapLargePages = 0;
    }

    //
    // This flag is registry-settable so check before overriding.
    //

    if (MmProtectFreedNonPagedPool == TRUE) {
        MxMapLargePages &= ~MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL;
    }

    //
    // Sanitize this registry-specifiable large stack size.  Note the registry
    // size is in 1K chunks, ie: 32 means 32k.  Note also that the registry
    // setting does not include the guard page and we don't want to burden
    // administrators with knowing about it so we automatically subtract one
    // page from their request.
    //

    if (MmLargeStackSize > (KERNEL_LARGE_STACK_SIZE / 1024)) {

        //
        // No registry override or the override is too high.
        // Set it to the default.
        //

        MmLargeStackSize = KERNEL_LARGE_STACK_SIZE;
    }
    else {

        //
        // Convert registry override from 1K units to bytes.  Note intelligent
        // choices are 16k or 32k because we bin those sizes in sysptes.
        //

        MmLargeStackSize *= 1024;
        MmLargeStackSize = MI_ROUND_TO_SIZE (MmLargeStackSize, PAGE_SIZE);
        MmLargeStackSize -= PAGE_SIZE;
        ASSERT (MmLargeStackSize <= KERNEL_LARGE_STACK_SIZE);
        ASSERT ((MmLargeStackSize & (PAGE_SIZE-1)) == 0);

        //
        // Don't allow a value that is too low either.
        //

        if (MmLargeStackSize < KERNEL_STACK_SIZE) {
            MmLargeStackSize = KERNEL_STACK_SIZE;
        }
    }

    //
    // If the host processor supports global bits, then set the global
    // bit in the template kernel PTE and PDE entries.
    //

    if (KeFeatureBits & KF_GLOBAL_PAGE) {
        ValidKernelPte.u.Long |= MM_PTE_GLOBAL_MASK;

#if !defined(_X86PAE_)

        //
        // Note that the PAE mode of the processor does not support the
        // global bit in PDEs which map 4K page table pages.
        //

        ValidKernelPde.u.Long |= MM_PTE_GLOBAL_MASK;
#endif
        MmPteGlobal.u.Long = MM_PTE_GLOBAL_MASK;
    }

    TempPte = ValidKernelPte;
    TempPde = ValidKernelPde;

    //
    // Set the directory base for the system process.
    //

    PointerPte = MiGetPdeAddress (PDE_BASE);
    PdePageNumber = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

    CurrentProcess = PsGetCurrentProcess ();

#if defined(_X86PAE_)

    PrototypePte.u.Soft.PageFileHigh = MI_PTE_LOOKUP_NEEDED;

    _asm {
        mov     eax, cr3
        mov     DirBase, eax
    }

    //
    // Note cr3 must be 32-byte aligned.
    //

    ASSERT ((DirBase & 0x1f) == 0);

    //
    // Initialize the PaeTop for this process right away.
    //

    RtlCopyMemory ((PVOID) &MiSystemPaeVa,
                   (PVOID) (KSEG0_BASE | DirBase),
                   sizeof (MiSystemPaeVa));

    CurrentProcess->PaeTop = &MiSystemPaeVa;

#else

    DirBase = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte) << PAGE_SHIFT;

#endif

    CurrentProcess->Pcb.DirectoryTableBase[0] = DirBase;
    KeSweepDcache (FALSE);

    //
    // Unmap the low 2Gb of memory.
    //

    PointerPde = MiGetPdeAddress (0);
    LastPte = MiGetPdeAddress (KSEG0_BASE);

    MiZeroMemoryPte (PointerPde, LastPte - PointerPde);

    //
    // Get the lower bound of the free physical memory and the
    // number of physical pages by walking the memory descriptor lists.
    //

    MxFreeDescriptor = NULL;
    TotalFreePages = 0;

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD (NextMd,
                                              MEMORY_ALLOCATION_DESCRIPTOR,
                                              ListEntry);

        if ((MemoryDescriptor->MemoryType != LoaderFirmwarePermanent) &&
            (MemoryDescriptor->MemoryType != LoaderBBTMemory) &&
            (MemoryDescriptor->MemoryType != LoaderHALCachedMemory) &&
            (MemoryDescriptor->MemoryType != LoaderSpecialMemory)) {

            //
            // This check results in /BURNMEMORY chunks not being counted.
            //

            if (MemoryDescriptor->MemoryType != LoaderBad) {
                MmNumberOfPhysicalPages += MemoryDescriptor->PageCount;
            }

            if (MemoryDescriptor->BasePage < MmLowestPhysicalPage) {
                MmLowestPhysicalPage = MemoryDescriptor->BasePage;
            }

            if ((MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) > MmHighestPhysicalPage) {

                MmHighestPhysicalPage =
                    MemoryDescriptor->BasePage + MemoryDescriptor->PageCount - 1;
            }

            //
            // Locate the largest free descriptor.
            //

            if ((MemoryDescriptor->MemoryType == LoaderFree) ||
                (MemoryDescriptor->MemoryType == LoaderLoadedProgram) ||
                (MemoryDescriptor->MemoryType == LoaderFirmwareTemporary) ||
                (MemoryDescriptor->MemoryType == LoaderOsloaderStack)) {

                if (MemoryDescriptor->PageCount > MostFreePage) {
                    MostFreePage = MemoryDescriptor->PageCount;
                    MxFreeDescriptor = MemoryDescriptor;
                }

                TotalFreePages += MemoryDescriptor->PageCount;
            }
        }

        NextMd = MemoryDescriptor->ListEntry.Flink;
    }

    if (MmLargeSystemCache != 0) {
        ExtraSystemCacheViews = TRUE;
    }

    //
    // This flag is registry-settable so check before overriding.
    //
    // Enabling special IRQL automatically disables mapping the kernel with
    // large pages so we can catch kernel and HAL code.
    //

    if (MmVerifyDriverBufferLength != (ULONG)-1) {
        MmLargePageMinimum = (ULONG)-2;
    }
    else if (MmLargePageMinimum == 0) {
        MmLargePageMinimum = MM_LARGE_PAGE_MINIMUM;
    }

    //
    // Capture the registry-specified initial nonpaged pool setting as we
    // will modify the variable later.
    //

    if ((MmSizeOfNonPagedPoolInBytes != 0) ||
        (MmMaximumNonPagedPoolPercent != 0)) {

        InitialNonPagedPoolSetViaRegistry = TRUE;
    }
    else {
        InitialNonPagedPoolSetViaRegistry = FALSE;
    }

    if (MmNumberOfPhysicalPages <= MmLargePageMinimum) {

        MxMapLargePages = 0;

        //
        // Reduce the size of the initial nonpaged pool on small configurations
        // as RAM is precious (unless the registry has overridden it).
        //

        if ((MmNumberOfPhysicalPages <= MM_LARGE_PAGE_MINIMUM) &&
            (MmSizeOfNonPagedPoolInBytes == 0)) {

            MmSizeOfNonPagedPoolInBytes = 2 * 1024 * 1024;
        }
    }

    //
    // MmDynamicPfn may have been initialized based on the registry to
    // a value representing the highest physical address in gigabytes.
    //

    MmDynamicPfn *= ((1024 * 1024 * 1024) / PAGE_SIZE);

    //
    // Retrieve highest hot plug memory range from the HAL if
    // available and not otherwise retrieved from the registry.
    //

    if (MmDynamicPfn == 0) {

        status = HalQuerySystemInformation (HalQueryMaxHotPlugMemoryAddress,
                                            sizeof(PHYSICAL_ADDRESS),
                                            (PPHYSICAL_ADDRESS) &MaxHotPlugMemoryAddress,
                                            &ReturnedLength);

        if (NT_SUCCESS (status)) {
            ASSERT (ReturnedLength == sizeof(PHYSICAL_ADDRESS));

            MmDynamicPfn = (PFN_NUMBER) (MaxHotPlugMemoryAddress.QuadPart / PAGE_SIZE);
        }
    }

    if (MmDynamicPfn != 0) {
#if defined(_X86PAE_)
        MmHighestPossiblePhysicalPage = MI_DTC_MAX_PAGES - 1;
        if (MmVirtualBias != 0) {
            MmHighestPossiblePhysicalPage = MI_DTC_BOOTED_3GB_MAX_PAGES - 1;
            if (MmDynamicPfn > MmHighestPossiblePhysicalPage + 1) {
                MmDynamicPfn = MmHighestPossiblePhysicalPage + 1;
            }
        }
#else
        MmHighestPossiblePhysicalPage = MI_DEFAULT_MAX_PAGES - 1;
#endif
        if (MmDynamicPfn - 1 < MmHighestPossiblePhysicalPage) {
            if (MmDynamicPfn - 1 < MmHighestPhysicalPage) {
                MmDynamicPfn = MmHighestPhysicalPage + 1;
            }
            MmHighestPossiblePhysicalPage = MmDynamicPfn - 1;
        }

        if (TotalFreePages < MmDynamicPfn / 16) {

            //
            // Don't use large pages for the PFN database as the number of
            // physical pages at boot is much smaller than would be needed
            // for the maximum configuration.  Using large pages for the
            // mostly sparse (at this time) PFN database can result in us
            // not booting due to nonpaged pool expansion reservations that
            // occur during initial pool creation.
            //

            MxMapLargePages &= ~MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL;
        }
    }
    else {
        MmHighestPossiblePhysicalPage = MmHighestPhysicalPage;
    }

    if (MmHighestPossiblePhysicalPage > 0x400000 - 1) {

        //
        // The PFN database is more than 112mb.  Force it to come from the
        // 2GB->3GB virtual address range.  Note the administrator cannot be
        // booting /3GB as when he does, the loader throws away memory
        // above the physical 16GB line, so this must be a hot-add
        // configuration.  Since the loader has already put the system at
        // 3GB, the highest possible hot add page must be reduced now.
        //

        if (MmVirtualBias != 0) {
            MmHighestPossiblePhysicalPage = 0x400000 - 1;

            if (MmHighestPhysicalPage > MmHighestPossiblePhysicalPage) {
                MmHighestPhysicalPage = MmHighestPossiblePhysicalPage;
            }
        }
        else {

            //
            // The virtual space between 2 and 3GB virtual is best used
            // for system PTEs when this much physical memory is present.
            //

            ExtraSystemCacheViews = FALSE;
        }
    }

    //
    // Don't enable extra system cache views as virtual addresses are limited.
    // Only a kernel-verifier special case can trigger this.
    //

    if ((KernelVerifier == TRUE) &&
        (MmVirtualBias == 0) &&
        (MmNumberOfPhysicalPages <= MmLargePageMinimum) &&
        (MmHighestPossiblePhysicalPage > 0x100000)) {

        ExtraSystemCacheViews = FALSE;
    }

#if defined(_X86PAE_)

    if (MmVirtualBias != 0) {

        //
        // User space is larger than 2GB, make extra room for the user space
        // working set list & associated hash tables.
        //

        MmSystemCacheWorkingSetList = (PMMWSL) ((ULONG_PTR) 
            MmSystemCacheWorkingSetList + MM_SYSTEM_CACHE_WORKING_SET_3GB_DELTA);
    }

    MmSystemCacheWorkingSetListPte = MiGetPteAddress (MmSystemCacheWorkingSetList);

    //
    // Only PAE machines with at least 5GB of physical memory get to use this.
    //

    if (strstr(LoaderBlock->LoadOptions, "NOLOWMEM")) {
        if (MmNumberOfPhysicalPages >= 5 * 1024 * 1024 / 4) {
            MiNoLowMemory = (PFN_NUMBER)((ULONGLONG)_4gb / PAGE_SIZE);
        }
    }

    if (MiNoLowMemory != 0) {
        MmMakeLowMemory = TRUE;
    }

#endif

    MmHyperSpaceEnd = (PVOID)((ULONG_PTR)MmSystemCacheWorkingSetList - 1);

    //
    // Build non-paged pool using the physical pages following the
    // data page in which to build the pool from.  Non-paged pool grows
    // from the high range of the virtual address space and expands
    // downward.
    //
    // At this time non-paged pool is constructed so virtual addresses
    // are also physically contiguous.
    //

    if ((MmSizeOfNonPagedPoolInBytes >> PAGE_SHIFT) >
                        (7 * (TotalFreePages >> 3))) {

        //
        // More than 7/8 of memory is allocated to nonpagedpool, reset to 0.
        //

        MmSizeOfNonPagedPoolInBytes = 0;
        if (MmMaximumNonPagedPoolPercent == 0) {
            InitialNonPagedPoolSetViaRegistry = FALSE;
        }
    }

    if (MmSizeOfNonPagedPoolInBytes < MmMinimumNonPagedPoolSize) {

        //
        // Calculate the size of nonpaged pool.
        // Use the minimum size, then for every MB above 4mb add extra
        // pages.
        //

        MmSizeOfNonPagedPoolInBytes = MmMinimumNonPagedPoolSize;

        MmSizeOfNonPagedPoolInBytes +=
                            ((TotalFreePages - 1024)/256) *
                            MmMinAdditionNonPagedPoolPerMb;
    }

    if (MmSizeOfNonPagedPoolInBytes > MM_MAX_INITIAL_NONPAGED_POOL) {
        MmSizeOfNonPagedPoolInBytes = MM_MAX_INITIAL_NONPAGED_POOL;
    }

    //
    // If the registry specifies a total nonpaged pool percentage cap, enforce
    // it here.
    //

    if (MmMaximumNonPagedPoolPercent != 0) {

        if (MmMaximumNonPagedPoolPercent < 5) {
            MmMaximumNonPagedPoolPercent = 5;
        }
        else if (MmMaximumNonPagedPoolPercent > 80) {
            MmMaximumNonPagedPoolPercent = 80;
        }

        //
        // Use the registry-expressed percentage value.
        //
    
        MaximumNonPagedPoolInBytesLimit =
            ((TotalFreePages * MmMaximumNonPagedPoolPercent) / 100);

        //
        // Carefully set the maximum keeping in mind that maximum PAE
        // machines can have 16*1024*1024 pages so care must be taken
        // that multiplying by PAGE_SIZE doesn't overflow here.
        //

        if (MaximumNonPagedPoolInBytesLimit > ((MM_MAX_INITIAL_NONPAGED_POOL + MM_MAX_ADDITIONAL_NONPAGED_POOL) / PAGE_SIZE)) {
            MaximumNonPagedPoolInBytesLimit = MM_MAX_INITIAL_NONPAGED_POOL + MM_MAX_ADDITIONAL_NONPAGED_POOL;
        }
        else {
            MaximumNonPagedPoolInBytesLimit *= PAGE_SIZE;
        }

        if (MaximumNonPagedPoolInBytesLimit < 6 * 1024 * 1024) {
            MaximumNonPagedPoolInBytesLimit = 6 * 1024 * 1024;
        }

        if (MmSizeOfNonPagedPoolInBytes > MaximumNonPagedPoolInBytesLimit) {
            MmSizeOfNonPagedPoolInBytes = MaximumNonPagedPoolInBytesLimit;
        }
    }
    
    //
    // Align to page size boundary.
    //

    MmSizeOfNonPagedPoolInBytes &= ~(PAGE_SIZE - 1);

    //
    // Calculate the maximum size of pool.
    //

    if (MmMaximumNonPagedPoolInBytes == 0) {

        //
        // Calculate the size of nonpaged pool.  If 4mb or less use
        // the minimum size, then for every MB above 4mb add extra
        // pages.
        //

        MmMaximumNonPagedPoolInBytes = MmDefaultMaximumNonPagedPool;

        //
        // Make sure enough expansion for the PFN database exists.
        //

        MmMaximumNonPagedPoolInBytes += (ULONG)PAGE_ALIGN (
                                      (MmHighestPossiblePhysicalPage + 1) * sizeof(MMPFN));

        //
        // Only use the new formula for autosizing nonpaged pool on machines
        // with at least 512MB.  The new formula allocates 1/2 as much nonpaged
        // pool per MB but scales much higher - machines with ~1.2GB or more
        // get 256MB of nonpaged pool.  Note that the old formula gave machines
        // with 512MB of RAM 128MB of nonpaged pool so this behavior is
        // preserved with the new formula as well.
        //

        if (TotalFreePages >= 0x1f000) {
            MmMaximumNonPagedPoolInBytes +=
                            ((TotalFreePages - 1024)/256) *
                            (MmMaxAdditionNonPagedPoolPerMb / 2);

            if (MmMaximumNonPagedPoolInBytes < MM_MAX_ADDITIONAL_NONPAGED_POOL) {
                MmMaximumNonPagedPoolInBytes = MM_MAX_ADDITIONAL_NONPAGED_POOL;
            }
        }
        else {
            MmMaximumNonPagedPoolInBytes +=
                            ((TotalFreePages - 1024)/256) *
                            MmMaxAdditionNonPagedPoolPerMb;
        }
        if ((MmMaximumNonPagedPoolPercent != 0) &&
            (MmMaximumNonPagedPoolInBytes > MaximumNonPagedPoolInBytesLimit)) {
                MmMaximumNonPagedPoolInBytes = MaximumNonPagedPoolInBytesLimit;
        }
    }

    MaxPool = MmSizeOfNonPagedPoolInBytes + PAGE_SIZE * 16 +
                                   (ULONG)PAGE_ALIGN (
                                        (MmHighestPossiblePhysicalPage + 1) * sizeof(MMPFN));

    if (MmMaximumNonPagedPoolInBytes < MaxPool) {
        MmMaximumNonPagedPoolInBytes = MaxPool;
    }

    //
    // Systems that are booted /3GB have a 128MB nonpaged pool maximum,
    //
    // Systems that have a full 2GB system virtual address space can enjoy an
    // extra 128MB of nonpaged pool in the upper GB of the address space.
    //

    MaxPool = MM_MAX_INITIAL_NONPAGED_POOL;

    if (MmVirtualBias == 0) {
        MaxPool += MM_MAX_ADDITIONAL_NONPAGED_POOL;
    }

    if (InitialNonPagedPoolSetViaRegistry == TRUE) {

        //
        // Make sure handling this initial setting won't push a /3GB
        // configuration past the maximum - note this cannot happen in
        // the normal non /3GB case.  The intent is for this setting to
        // allow configuration of *less* than the maximum amount of
        // nonpaged pool (to leave this VA space and/or physical pages
        // available for other resources).
        //

        if (MmSizeOfNonPagedPoolInBytes + MM_MAX_ADDITIONAL_NONPAGED_POOL < MaxPool) {
            MaxPool = MmSizeOfNonPagedPoolInBytes + MM_MAX_ADDITIONAL_NONPAGED_POOL;
        }
    }

    if (MmMaximumNonPagedPoolInBytes > MaxPool) {
        MmMaximumNonPagedPoolInBytes = MaxPool;
    }

    //
    // Grow the initial nonpaged pool if necessary so that the overall pool
    // will aggregate to the right size.
    //

    if ((MmMaximumNonPagedPoolInBytes > MM_MAX_INITIAL_NONPAGED_POOL) &&
        (InitialNonPagedPoolSetViaRegistry == FALSE)) {

        if (MmSizeOfNonPagedPoolInBytes < MmMaximumNonPagedPoolInBytes - MM_MAX_ADDITIONAL_NONPAGED_POOL) {

            //
            // Note the initial nonpaged pool can only be grown if there
            // is a sufficient contiguous physical memory chunk it can
            // be carved from immediately.
            //

            PagesLeft = MxPagesAvailable ();

            if (((MmMaximumNonPagedPoolInBytes - MM_MAX_ADDITIONAL_NONPAGED_POOL) >> PAGE_SHIFT) + ((32 * 1024 * 1024) >> PAGE_SHIFT) < PagesLeft) {

                MmSizeOfNonPagedPoolInBytes = MmMaximumNonPagedPoolInBytes - MM_MAX_ADDITIONAL_NONPAGED_POOL;
            }
            else {

                //
                // Since the initial nonpaged pool could not be grown, don't
                // leave any excess in the expansion nonpaged pool as we
                // cannot encode it into subsection format on non-pae
                // machines.
                //

                if (MmMaximumNonPagedPoolInBytes > MmSizeOfNonPagedPoolInBytes + MM_MAX_ADDITIONAL_NONPAGED_POOL) {
                    MmMaximumNonPagedPoolInBytes = MmSizeOfNonPagedPoolInBytes + MM_MAX_ADDITIONAL_NONPAGED_POOL;
                }
            }
        }
    }

    //
    // Get secondary color value from:
    //
    // (a) from the registry (already filled in) or
    // (b) from the PCR or
    // (c) default value.
    //

    if (MmSecondaryColors == 0) {

        Associativity = KeGetPcr()->SecondLevelCacheAssociativity;

        MmSecondaryColors = KeGetPcr()->SecondLevelCacheSize;

        if (Associativity != 0) {
            MmSecondaryColors /= Associativity;
        }
    }

    MmSecondaryColors = MmSecondaryColors >> PAGE_SHIFT;

    if (MmSecondaryColors == 0) {
        MmSecondaryColors = MM_SECONDARY_COLORS_DEFAULT;
    }
    else {

        //
        // Make sure the value is power of two and within limits.
        //

        if (MmSecondaryColors > MM_SECONDARY_COLORS_MAX) {
            MmSecondaryColors = MM_SECONDARY_COLORS_MAX;
        }
        else if (((MmSecondaryColors & (MmSecondaryColors - 1)) != 0) ||
                 (MmSecondaryColors < MM_SECONDARY_COLORS_MIN)) {

            MmSecondaryColors = MM_SECONDARY_COLORS_DEFAULT;
        }
    }

    MmSecondaryColorMask = MmSecondaryColors - 1;

    //
    // Set the secondary color mask on the boot processor since it is needed
    // very early.
    //

    KeGetCurrentPrcb()->SecondaryColorMask = MmSecondaryColorMask;

#if defined(MI_MULTINODE)

    //
    // Determine the number of bits in MmSecondaryColorMask. This
    // is the number of bits the Node color must be shifted
    // by before it is included in colors.
    //

    i = MmSecondaryColorMask;
    MmSecondaryColorNodeShift = 0;
    while (i != 0) {
        i >>= 1;
        MmSecondaryColorNodeShift += 1;
    }

    //
    // Adjust the number of secondary colors by the number of nodes
    // in the machine.   The secondary color mask is NOT adjusted
    // as it is used to control coloring within a node.  The node
    // color is added to the color AFTER normal color calculations
    // are performed.
    //

    MmSecondaryColors *= KeNumberNodes;

    for (i = 0; i < KeNumberNodes; i += 1) {
        KeNodeBlock[i]->Color = (UCHAR)i;
        KeNodeBlock[i]->MmShiftedColor = i << MmSecondaryColorNodeShift;
        InitializeSListHead(&KeNodeBlock[i]->DeadStackList);
    }

#endif

    MiMaximumSystemCacheSizeExtra = 0;

    //
    // Add in the PFN database size (based on the number of pages required
    // from page zero to the highest page).
    //
    // Get the number of secondary colors and add the array for tracking
    // secondary colors to the end of the PFN database.
    //

    MxPfnAllocation = 1 + ((((MmHighestPossiblePhysicalPage + 1) * sizeof(MMPFN)) +
                        (MmSecondaryColors * sizeof(MMCOLOR_TABLES)*2))
                            >> PAGE_SHIFT);

    if (MmVirtualBias == 0) {

        MmNonPagedPoolStart = (PVOID)((ULONG)MmNonPagedPoolEnd
                                      - MmMaximumNonPagedPoolInBytes
                                      + MmSizeOfNonPagedPoolInBytes);
    }
    else {

        ULONG Reduction;
        ULONG MaxExpansion;
        ULONG ExpansionBytes;

        MmNonPagedPoolStart = (PVOID)((ULONG) MmNonPagedPoolEnd -
                                      (MmMaximumNonPagedPoolInBytes +
                                       (MxPfnAllocation << PAGE_SHIFT)));

        //
        // Align the nonpaged pool start to a PDE boundary as both it and
        // the PFN database will generally be allocated from a large page.
        //

        Reduction = (ULONG)MmNonPagedPoolStart & (MM_VA_MAPPED_BY_PDE - 1);

        MmNonPagedPoolStart = (PVOID)((ULONG_PTR)MmNonPagedPoolStart - Reduction);
        ExpansionBytes = MmMaximumNonPagedPoolInBytes;
        ASSERT (ExpansionBytes <= MM_MAX_ADDITIONAL_NONPAGED_POOL);

        //
        // Grow the expansion pool to use any slush VA being created.
        //

        MaxExpansion = MM_MAX_ADDITIONAL_NONPAGED_POOL - ExpansionBytes;
        if (Reduction < MaxExpansion) {
            MaxExpansion = Reduction;
        }

        MmNonPagedPoolEnd = (PVOID)((ULONG_PTR)MmNonPagedPoolEnd - Reduction);
        MmNonPagedPoolEnd = (PVOID)((ULONG_PTR)MmNonPagedPoolEnd + MaxExpansion);
        MmMaximumNonPagedPoolInBytes += MaxExpansion;
    }

    MmNonPagedPoolStart = (PVOID) PAGE_ALIGN (MmNonPagedPoolStart);

    NonPagedPoolStartVirtual = MmNonPagedPoolStart;

    //
    // Sanitize the paged pool size if specified badly via the registry.
    //

    if ((MmSizeOfPagedPoolInBytes != 0) &&
        (MmSizeOfPagedPoolInBytes != (SIZE_T)-1)) {

        if (MI_ROUND_TO_SIZE (MmSizeOfPagedPoolInBytes, MM_VA_MAPPED_BY_PDE) <=
            MmSizeOfPagedPoolInBytes) {

            //
            // The size wrapped so the user must want the maximum.
            //

            MmSizeOfPagedPoolInBytes = (SIZE_T)-1;
        }
    }

    //
    // Allocate additional paged pool provided it can fit and either the
    // user asked for it or we decide 460MB of PTE space is sufficient.
    //
    // Note at 64GB of RAM, the PFN database spans 464mb.  Given that plus
    // initial nonpaged pool at 128mb and space for the loader's highest
    // page and session space, there may not be any room left to guarantee
    // we will be able to allocate system PTEs out of the virtual address
    // space below 3gb.  So don't crimp for more than 64GB.
    //

    if ((MmVirtualBias == 0) &&
        (MmHighestPossiblePhysicalPage <= 0x1000000)) {

        if (((MmLargeStackSize <= (32 * 1024 - PAGE_SIZE)) && (MiUseMaximumSystemSpace != 0)) ||
        ((MmSizeOfPagedPoolInBytes == (SIZE_T)-1) ||
         ((MmSizeOfPagedPoolInBytes == 0) &&
         (MmNumberOfPhysicalPages >= (1 * 1024 * 1024 * 1024 / PAGE_SIZE)) &&
         (MiRequestedSystemPtes != (ULONG)-1)))) {

            if ((ExpMultiUserTS == FALSE) || (MmSizeOfPagedPoolInBytes != 0)) {

                PagedPoolMaximumDesired = TRUE;
                MmPagedPoolMaximumDesired = TRUE;
            }
            else {

                //
                // This is a multiuser TS machine defaulting to
                // autoconfiguration.  These machines use approximately
                // 3.25x PTEs compared to paged pool per session.
                // If the stack size is halved, then 1.6x becomes the ratio.
                //
                // Estimate how many PTEs and paged pool virtual space
                // will be available and divide it up now.
                //

                ULONG LowVa;
                ULONG TotalVirtualSpace;
                ULONG PagedPoolPortion;
                ULONG PtePortion;

                TotalVirtualSpace = (ULONG) NonPagedPoolStartVirtual - (ULONG) MM_PAGED_POOL_START;
                LowVa = (MM_KSEG0_BASE | MmBootImageSize) + MxPfnAllocation * PAGE_SIZE + MmSizeOfNonPagedPoolInBytes;

                if (LowVa < MiSystemViewStart) {
                    TotalVirtualSpace += (MiSystemViewStart - LowVa);
                }

                PtePortion = 77;
                PagedPoolPortion = 100 - PtePortion;

                //
                // If the large stack size has been reduced, then adjust the
                // ratio automatically as well.
                //

                if (MmLargeStackSize != KERNEL_LARGE_STACK_SIZE) {
                    PtePortion = (PtePortion * MmLargeStackSize) / KERNEL_LARGE_STACK_SIZE;
                }

                MmSizeOfPagedPoolInBytes = (TotalVirtualSpace / (PagedPoolPortion + PtePortion)) * PagedPoolPortion;
            }
    
            //
            // Make sure we always allocate extra PTEs later as we have crimped
            // the initial allocation here.
            //
    
            ExtraSystemCacheViews = FALSE;
            MmNumberOfSystemPtes = 3000;
            MiRequestedSystemPtes = (ULONG)-1;
        }
    }

    //
    // Calculate the starting PDE for the system PTE pool which is
    // right below the nonpaged pool.
    //

    MmNonPagedSystemStart = (PVOID)(((ULONG)NonPagedPoolStartVirtual -
                                ((MmNumberOfSystemPtes + 1) * PAGE_SIZE)) &
                                 (~PAGE_DIRECTORY_MASK));

    if (MmNonPagedSystemStart < MM_LOWEST_NONPAGED_SYSTEM_START) {

        MmNonPagedSystemStart = MM_LOWEST_NONPAGED_SYSTEM_START;

        MmNumberOfSystemPtes = (((ULONG)NonPagedPoolStartVirtual -
                                 (ULONG)MmNonPagedSystemStart) >> PAGE_SHIFT)-1;

        ASSERT (MmNumberOfSystemPtes > 1000);
    }

    if ((MmVirtualBias == 0) &&
        (MmSizeOfPagedPoolInBytes > ((ULONG) MmNonPagedSystemStart - (ULONG) MM_PAGED_POOL_START)) &&
        (MmPagedPoolMaximumDesired == FALSE)) {
    
        ULONG OldNonPagedSystemStart;
        ULONG ExtraPtesNeeded;
        ULONG InitialPagedPoolSize;

        MmSizeOfPagedPoolInBytes = MI_ROUND_TO_SIZE (MmSizeOfPagedPoolInBytes, MM_VA_MAPPED_BY_PDE);

        //
        // Recalculate the starting PDE for the system PTE pool which is
        // right below the nonpaged pool.  Leave at least 3000 high
        // system PTEs.
        //

        OldNonPagedSystemStart = (ULONG) MmNonPagedSystemStart;

        NonPagedSystemStart = ((ULONG)NonPagedPoolStartVirtual -
                                    ((3000 + 1) * PAGE_SIZE)) &
                                     ~PAGE_DIRECTORY_MASK;

        if (NonPagedSystemStart < (ULONG) MM_LOWEST_NONPAGED_SYSTEM_START) {
            NonPagedSystemStart = (ULONG) MM_LOWEST_NONPAGED_SYSTEM_START;
        }

        InitialPagedPoolSize = NonPagedSystemStart - (ULONG) MM_PAGED_POOL_START;

        if (MmSizeOfPagedPoolInBytes > InitialPagedPoolSize) {
            MmSizeOfPagedPoolInBytes = InitialPagedPoolSize;
        }
        else {
            NonPagedSystemStart = ((ULONG) MM_PAGED_POOL_START +
                                        MmSizeOfPagedPoolInBytes);

            ASSERT ((NonPagedSystemStart & PAGE_DIRECTORY_MASK) == 0);

            ASSERT (NonPagedSystemStart >= (ULONG) MM_LOWEST_NONPAGED_SYSTEM_START);
        }
        
        ASSERT (NonPagedSystemStart >= OldNonPagedSystemStart);
        ExtraPtesNeeded = (NonPagedSystemStart - OldNonPagedSystemStart) >> PAGE_SHIFT;

        //
        // Note the PagedPoolMaximumDesired local is deliberately not set
        // because we don't want or need to delete PDEs later in this
        // routine.  The exact amount has been allocated here.
        // The global MmPagedPoolMaximumDesired is set because other parts
        // of memory management use it to finish sizing properly.
        //

        MmPagedPoolMaximumDesired = TRUE;

        MmNonPagedSystemStart = (PVOID) NonPagedSystemStart;
        MmNumberOfSystemPtes = (((ULONG)NonPagedPoolStartVirtual -
                                 (ULONG)NonPagedSystemStart) >> PAGE_SHIFT)-1;
    }
    
    //
    // If the host processor supports large pages, and the number of
    // physical pages is greater than the threshold, then map the kernel
    // image and HAL into a large page.
    //

    if (MxMapLargePages & MI_LARGE_KERNEL_HAL) {

        //
        // Add the kernel and HAL ranges to the large page ranges.
        //
        // Ensure any slush in the encompassing large page(s) is always mapped
        // as cached to prevent TB cache attribute conflicts.
        //
        // Note that the MxFreeDescriptor may already be pointing at the slush.
        //

        NextEntry = LoaderBlock->LoadOrderListHead.Flink;

        DataTableEntry = CONTAINING_RECORD (NextEntry,
                                            KLDR_DATA_TABLE_ENTRY,
                                            InLoadOrderLinks);

        //
        // Compute the physical page range spanned by the kernel and the HAL.
        // The potential large page ranges (which may be one single range,
        // or two distinct ranges which could potentially be both physically
        // and virtually discontiguous) these two images reside in must 
        // contain only each other and/or FirmwareTemporary spans.  If there
        // is anything else in the ranges then we cannot guarantee there
        // will be no cache attribute conflicts so don't use large pages.
        //

        TempSlushDescriptor = NULL;
        PointerPte = MiGetPteAddress (DataTableEntry->DllBase);
        ASSERT (MI_IS_PTE_VALID (PointerPte));
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

        if ((PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) == 0) {

            PFN_NUMBER PageFrameIndexLow;
            PKLDR_DATA_TABLE_ENTRY DataTableEntryLow;
            PKLDR_DATA_TABLE_ENTRY DataTableEntrySwap;
            PVOID VirtualAddressLow;

            PageFrameIndexLow = PageFrameIndex;
            DataTableEntryLow = DataTableEntry;

            //
            // The kernel starts on a large page boundary so that's good ...
            //

            VirtualAddressLow = DataTableEntry->DllBase;
            PageFrameIndex += (DataTableEntry->SizeOfImage >> PAGE_SHIFT);

            NextEntry = NextEntry->Flink;

            DataTableEntry = CONTAINING_RECORD (NextEntry,
                                                KLDR_DATA_TABLE_ENTRY,
                                                InLoadOrderLinks);

            PointerPte = MiGetPteAddress (DataTableEntry->DllBase);
            ASSERT (MI_IS_PTE_VALID (PointerPte));

            if (MI_GET_PAGE_FRAME_FROM_PTE (PointerPte) + (DataTableEntry->SizeOfImage >> PAGE_SHIFT) == PageFrameIndexLow) {

                //
                // The HAL actually came first followed by the kernel.
                // Invert our locals so we can finish up with a single check
                // below.
                //

                DataTableEntrySwap = DataTableEntryLow;
                DataTableEntryLow = DataTableEntry;
                DataTableEntry = DataTableEntrySwap;

                PointerPte = MiGetPteAddress (DataTableEntryLow->DllBase);
                ASSERT (MI_IS_PTE_VALID (PointerPte));
                PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                PageFrameIndexLow = PageFrameIndex;
                PageFrameIndex += (DataTableEntryLow->SizeOfImage >> PAGE_SHIFT);
                VirtualAddressLow = DataTableEntryLow->DllBase;

                PointerPte = MiGetPteAddress (DataTableEntry->DllBase);
                ASSERT (MI_IS_PTE_VALID (PointerPte));
            }

            if (PageFrameIndex == MI_GET_PAGE_FRAME_FROM_PTE (PointerPte)) {

                //
                // The kernel and HAL are contiguous, note they may span
                // more than one large page and usually (but not if the
                // second image ends on a large page boundary) has slush
                // on the end.
                //

                PageFrameIndex += (DataTableEntry->SizeOfImage >> PAGE_SHIFT);
                if (PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) {

                    //
                    // Locate the slush descriptor, if one is not found then
                    // do NOT use large pages.
                    //

                    ASSERT (MxSlushDescriptor1 == NULL);

                    TempSlushDescriptor = MiFindDescriptor (LoaderBlock,
                                                            PageFrameIndex);

                    if (TempSlushDescriptor != NULL) {

                        MxSlushDescriptor1 = TempSlushDescriptor;

                        *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor1 =
                                *MxSlushDescriptor1;
                    }
                }
                else {
                    TempSlushDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR) 1;

                    //
                    // The contiguous images end exactly on a large
                    // page boundary.
                    //

                }

                if (TempSlushDescriptor != NULL) {
                    EndVirtualAddress = (PVOID)((ULONG_PTR) DataTableEntry->DllBase + DataTableEntry->SizeOfImage - 1);

                    MiLargeVaRanges[MiLargeVaRangeIndex].VirtualAddress = VirtualAddressLow;
                    MiLargeVaRanges[MiLargeVaRangeIndex].EndVirtualAddress = EndVirtualAddress;
                    MiLargeVaRangeIndex += 1;
                }
            }
            else {

                //
                // The kernel and HAL are discontiguous, thus they span
                // more than one large page and usually (but not if the image
                // ends on a large page boundary) have slush after each image.
                //
                // Note there may also even be a gap between each large page.
                //
                // The HAL does not immediately follow the kernel so check
                // for a firmware temporary descriptor following each of them
                // that must consume the rest of each large page.  Anything
                // else is unexpected (ie, a downrev loader) and so don't use
                // large pages in that case.
                //

                if (PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) {

                    //
                    // Locate the slush descriptor, if one is not found then
                    // do NOT use large pages.
                    //

                    ASSERT (MxSlushDescriptor1 == NULL);

                    TempSlushDescriptor = MiFindDescriptor (LoaderBlock,
                                                            PageFrameIndex);

                    if (TempSlushDescriptor != NULL) {

                        MxSlushDescriptor1 = TempSlushDescriptor;
                        *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor1 =
                            *MxSlushDescriptor1;
                    }
                }
                else {
                    TempSlushDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR) 1;
                }

                if (TempSlushDescriptor != NULL) {

                    MiLargeVaRanges[MiLargeVaRangeIndex].VirtualAddress =
                                            DataTableEntryLow->DllBase;

                    EndVirtualAddress = (PVOID)((ULONG_PTR) DataTableEntryLow->DllBase + DataTableEntryLow->SizeOfImage - 1);

                    MiLargeVaRanges[MiLargeVaRangeIndex].EndVirtualAddress = EndVirtualAddress;
                    MiLargeVaRangeIndex += 1;
                }

                //
                // Now check the slush for the second image.
                //

                ASSERT (PointerPte == MiGetPteAddress (DataTableEntry->DllBase));
                ASSERT (MI_IS_PTE_VALID (PointerPte));

                PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                PageFrameIndex += (DataTableEntry->SizeOfImage >> PAGE_SHIFT);

                if (PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) {

                    //
                    // Locate the slush descriptor, if one is not found then
                    // do NOT use large pages.
                    //

                    ASSERT (MxSlushDescriptor2 == NULL);

                    TempSlushDescriptor = MiFindDescriptor (LoaderBlock,
                                                            PageFrameIndex);

                    if (TempSlushDescriptor != NULL) {

                        MxSlushDescriptor2 = TempSlushDescriptor;

                        *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor2 =
                            *MxSlushDescriptor2;
                    }
                }
                else {
                    TempSlushDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR) 1;
                }

                if (TempSlushDescriptor != NULL) {

                    MiLargeVaRanges[MiLargeVaRangeIndex].VirtualAddress =
                                            DataTableEntry->DllBase;

                    EndVirtualAddress = (PVOID)((ULONG_PTR) DataTableEntry->DllBase + DataTableEntry->SizeOfImage - 1);

                    MiLargeVaRanges[MiLargeVaRangeIndex].EndVirtualAddress = EndVirtualAddress;
                    MiLargeVaRangeIndex += 1;
                }
            }
        }
    }

    //
    // Save the original descriptor value as everything must be restored
    // prior to this function returning.
    //

    *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldFreeDescriptor = *MxFreeDescriptor;

    //
    // Ensure there are enough pages in the descriptor to satisfy the sizes.
    //

    PagesLeft = MxPagesAvailable ();

    PagesNeeded = MxPfnAllocation + (MmSizeOfNonPagedPoolInBytes >> PAGE_SHIFT);

    //
    // If we're going to try to use large pages to map it, then align pages
    // needed to a PDE multiple so that the large page can be completely filled.
    //

    if ((MxMapLargePages & MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL) &&
        ((PagesNeeded << PAGE_SHIFT) & (MM_MINIMUM_VA_FOR_LARGE_PAGE - 1))) {

        ULONG ReductionBytes;

        ReductionBytes =
            ((PagesNeeded << PAGE_SHIFT) & (MM_MINIMUM_VA_FOR_LARGE_PAGE - 1));

        ASSERT (MmSizeOfNonPagedPoolInBytes > ReductionBytes);
        MmSizeOfNonPagedPoolInBytes -= ReductionBytes;
        MmMaximumNonPagedPoolInBytes -= ReductionBytes;
        PagesNeeded -= (ReductionBytes >> PAGE_SHIFT);
    }

    if (PagesNeeded + ((32 * 1024 * 1024) >> PAGE_SHIFT) > PagesLeft) {
        MxMapLargePages &= ~MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL;
    }

    if (MmVirtualBias == 0) {

        //
        // Put the PFN database in low virtual memory just
        // above the loaded images.
        //

        MmPfnDatabase = (PMMPFN)(MM_KSEG0_BASE | MmBootImageSize);

        ASSERT (((ULONG_PTR)MmPfnDatabase & (MM_VA_MAPPED_BY_PDE - 1)) == 0);

        //
        // Systems with extremely large PFN databases (ie: spanning 64GB of RAM)
        // and bumped session space sizes may require a reduction in the initial
        // nonpaged pool size in order to fit.
        //

        NumberOfBytes = MiSystemViewStart - (ULONG_PTR) MmPfnDatabase;

        if (PagesNeeded > (NumberOfBytes >> PAGE_SHIFT)) {

            ULONG ReductionBytes;

            ReductionBytes = (PagesNeeded << PAGE_SHIFT) - NumberOfBytes;

            MmSizeOfNonPagedPoolInBytes -= ReductionBytes;
            MmMaximumNonPagedPoolInBytes -= ReductionBytes;
            PagesNeeded -= (ReductionBytes >> PAGE_SHIFT);
        }
    }
    else {

        //
        // Put the PFN database at the top of the system PTE range (where non
        // paged pool would have started) and slide the nonpaged pool start
        // upwards.
        //

        MmPfnDatabase = (PMMPFN) MmNonPagedPoolStart;

        MmNonPagedPoolStart = (PVOID)((PCHAR)MmPfnDatabase + (MxPfnAllocation << PAGE_SHIFT));

        NonPagedPoolStartVirtual = MmNonPagedPoolStart;
    }

    if (MxMapLargePages & MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL) {

        PFN_NUMBER LastPage;

        //
        // The PFN database and nonpaged pool must be allocated from a
        // large-page aligned chunk of memory in the free descriptor.
        // This is because all the pages in the large page range must
        // be mapped fully cached (to avoid TB attribute conflicts) so
        // it's easiest to ensure they are all consumed now.
        //
        // See if the free descriptor has enough pages of large page alignment
        // to satisfy our calculation.
        //

        ASSERT (((PagesNeeded << PAGE_SHIFT) & (MM_MINIMUM_VA_FOR_LARGE_PAGE - 1)) == 0);

        BasePage = MI_ROUND_TO_SIZE (MxFreeDescriptor->BasePage,
                                     MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT);

        LastPage = MxFreeDescriptor->BasePage + MxFreeDescriptor->PageCount;

        //
        // We can safely round up here because we checked earlier that the
        // free descriptor has at least 32mb (much more than a large page's
        // worth) more than we need.
        //

        if (BasePage < MxFreeDescriptor->BasePage) {
            BasePage += (MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT);
            ASSERT (BasePage >= MxFreeDescriptor->BasePage);
            ASSERT (BasePage < LastPage);
        }

        ASSERT (BasePage + PagesNeeded <= LastPage);

        //
        // Get the physical pages for the PFN database & initial nonpaged pool.
        //

        if (BasePage == MxFreeDescriptor->BasePage) {

            //
            // The descriptor starts on a large page aligned boundary so remove
            // the large page span from the bottom of the free descriptor.
            //

            FirstPfnDatabasePage = BasePage;
            ASSERT ((FirstPfnDatabasePage & (MM_PFN_MAPPED_BY_PDE - 1)) == 0);

            MxFreeDescriptor->BasePage += PagesNeeded;
            MxFreeDescriptor->PageCount -= (ULONG) PagesNeeded;
        }
        else {

            if ((LastPage & ((MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT) - 1)) == 0) {
                //
                // The descriptor ends on a large page aligned boundary so
                // remove the large page span from the top of the free
                // descriptor.
                //

                FirstPfnDatabasePage = LastPage - PagesNeeded;
                ASSERT ((FirstPfnDatabasePage & (MM_PFN_MAPPED_BY_PDE - 1)) == 0);

                MxFreeDescriptor->PageCount -= PagesNeeded;
            }
            else {

                //
                // The descriptor does not start or end on a large page aligned
                // address so chop the descriptor.  The excess slush is added to
                // the freelist later.
                //

                MiSlushDescriptorBase = MxFreeDescriptor->BasePage;
                MiSlushDescriptorCount = BasePage - MxFreeDescriptor->BasePage;

                FirstPfnDatabasePage = BasePage;
                ASSERT ((FirstPfnDatabasePage & (MM_PFN_MAPPED_BY_PDE - 1)) == 0);

                MxFreeDescriptor->PageCount -= (ULONG) (PagesNeeded + MiSlushDescriptorCount);

                MxFreeDescriptor->BasePage = (ULONG) (BasePage + PagesNeeded);
            }
        }
    
        ASSERT (((ULONG_PTR)MmPfnDatabase & (MM_VA_MAPPED_BY_PDE - 1)) == 0);

        //
        // Adjust the system PTEs top so no future PTE allocations get
        // to share the large page mapping.
        //

        if (MmVirtualBias != 0) {
            MmNumberOfSystemPtes = ((PCHAR) MmPfnDatabase - (PCHAR) MmNonPagedSystemStart) / PAGE_SIZE;
        }

        //
        // Add the PFN database and initial nonpaged pool combined range
        // to the large page ranges.
        //

        MiLargeVaRanges[MiLargeVaRangeIndex].VirtualAddress = MmPfnDatabase;
        MiLargeVaRanges[MiLargeVaRangeIndex].EndVirtualAddress =
                              (PVOID) ((ULONG_PTR)MmPfnDatabase + (MxPfnAllocation << PAGE_SHIFT) + MmSizeOfNonPagedPoolInBytes - 1);
        MiLargeVaRangeIndex += 1;
    }

    //
    // Initial nonpaged pool immediately follows the PFN database.
    //
    // Since the PFN database and the initial nonpaged pool are physically
    // adjacent, a single PDE is shared, thus reducing the number of pages
    // that otherwise might need to be marked as must-be-cachable.
    //

    MmNonPagedPoolStart = (PVOID)((ULONG_PTR)MmPfnDatabase + (MxPfnAllocation << PAGE_SHIFT));

    if ((ULONG_PTR)MmNonPagedPoolEnd - (ULONG_PTR)MmNonPagedPoolStart < MmMaximumNonPagedPoolInBytes) {
        ASSERT (MmVirtualBias != 0);
        MmMaximumNonPagedPoolInBytes = (ULONG_PTR)MmNonPagedPoolEnd - (ULONG_PTR)MmNonPagedPoolStart;
    }

    if (MxMapLargePages & MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL) {

        if (MmVirtualBias != 0) {
            NonPagedPoolStartVirtual = MmNonPagedPoolStart;
        }
    }

    if (PagedPoolMaximumDesired == TRUE) {
    
        ASSERT (MmVirtualBias == 0);

        //
        // Maximum paged pool was requested.  This means slice away most of
        // the system PTEs being used at the high end of the virtual address
        // space and use that address range for more paged pool instead.
        //

        ASSERT (MiIsVirtualAddressOnPdeBoundary (MmNonPagedSystemStart));

        PointerPde = MiGetPdeAddress ((PCHAR) MmNonPagedSystemStart + (MmNumberOfSystemPtes << PAGE_SHIFT));

        PointerPde -= 2;
#if defined (_X86PAE_)

        //
        // Since PAE needs twice as many PDEs to cover the same VA range ...
        //

        PointerPde -= 2;
#endif

        if (MiGetVirtualAddressMappedByPde (PointerPde) >= MM_LOWEST_NONPAGED_SYSTEM_START) {
            MmNonPagedSystemStart = MiGetVirtualAddressMappedByPde (PointerPde);
            MmNumberOfSystemPtes = (((ULONG)NonPagedPoolStartVirtual -
                                 (ULONG)MmNonPagedSystemStart) >> PAGE_SHIFT)-1;
        }
    }

    //
    // Allocate pages and fill in the PTEs for the initial nonpaged pool.
    //

    if ((MxMapLargePages & MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL) == 0) {

        //
        // The physical memory for the initial nonpaged pool was not allocated
        // above so do it now.
        //

        PagesNeeded = MmSizeOfNonPagedPoolInBytes >> PAGE_SHIFT;

        //
        // If needed, reduce our request to accommodate
        // physical memory fragmention.
        //

        PagesLeft = MxPagesAvailable ();

        if (PagesNeeded > PagesLeft) {
            MmSizeOfNonPagedPoolInBytes -= (PagesNeeded - PagesLeft) << PAGE_SHIFT;
            MmMaximumNonPagedPoolInBytes -= (MmSizeOfNonPagedPoolInBytes - ((PagesNeeded - PagesLeft) << PAGE_SHIFT));
            PagesNeeded = PagesLeft;
        }

        PageFrameIndex = MxGetNextPage (PagesNeeded, FALSE);
    }
    else {
        PageFrameIndex = FirstPfnDatabasePage + MxPfnAllocation;
    }

    MmMaximumNonPagedPoolInPages = (MmMaximumNonPagedPoolInBytes >> PAGE_SHIFT);

    //
    // Set up page table pages to map system PTEs and the expansion nonpaged
    // pool.  If the system was booted /3GB, then the initial nonpaged pool
    // is mapped here as well.
    //

    StartPde = MiGetPdeAddress (MmNonPagedSystemStart);
    EndPde = MiGetPdeAddress ((PVOID)((PCHAR)MmNonPagedPoolEnd - 1));

    while (StartPde <= EndPde) {

        ASSERT (StartPde->u.Hard.Valid == 0);

        //
        // Map in a page table page, using the
        // slush descriptor if one exists.
        //

        TempPde.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);
        *StartPde = TempPde;
        PointerPte = MiGetVirtualAddressMappedByPte (StartPde);
        RtlZeroMemory (PointerPte, PAGE_SIZE);
        StartPde += 1;
    }

    MI_ADD_EXECUTE_TO_VALID_PTE_IF_PAE (TempPte);

    if (MmVirtualBias == 0) {

        //
        // Allocate the page table pages to map the PFN database and the
        // initial nonpaged pool now.  If the system switches to large
        // pages in Phase 1, these pages will be discarded then.
        //

        StartPde = MiGetPdeAddress (MmPfnDatabase);

        VirtualAddress = (PVOID) ((ULONG_PTR)MmNonPagedPoolStart + MmSizeOfNonPagedPoolInBytes - 1);

        EndPde = MiGetPdeAddress (VirtualAddress);

        //
        // Use any extra virtual address space between the top of initial
        // nonpaged pool and session space for additional system PTEs or
        // caching.
        //

        PointerPde = EndPde + 1;
        EndPde = MiGetPdeAddress (MiSystemViewStart - 1);

        if (PointerPde <= EndPde) {

            //
            // There is available virtual space - consume everything up
            // to the system view area (which is always rounded to a page
            // directory boundary to avoid wasting valuable virtual
            // address space.
            //

            ULONG NumberOfExtraSystemPdes;

            VirtualAddress = MiGetVirtualAddressMappedByPde (PointerPde);
            NumberOfExtraSystemPdes = EndPde - PointerPde + 1;

            //
            // Mark the new range as PTEs iff maximum PTEs are requested,
            // TS in app server mode is selected or special pooling is
            // enabled.  Otherwise if large system caching was selected
            // then use it for that.  Finally default to PTEs if neither
            // of the above.
            //

            if ((MiRequestedSystemPtes == (ULONG)-1) ||
                (ExpMultiUserTS == TRUE) ||
                (MmVerifyDriverBufferLength != (ULONG)-1) ||
                ((MmSpecialPoolTag != 0) && (MmSpecialPoolTag != (ULONG)-1))) {

                ExtraSystemCacheViews = FALSE;
            }

            if (ExtraSystemCacheViews == TRUE) {

                //
                // The system is configured to favor large system caching,
                // so share the remaining virtual address space between the
                // system cache and system PTEs.
                //

                MiMaximumSystemCacheSizeExtra =
                                    (NumberOfExtraSystemPdes * 5) / 6;

                ExtraPtes1 = NumberOfExtraSystemPdes -
                                    MiMaximumSystemCacheSizeExtra;

                ExtraPtes1 *= (MM_VA_MAPPED_BY_PDE / PAGE_SIZE);

                MiMaximumSystemCacheSizeExtra *= MM_VA_MAPPED_BY_PDE;

                ExtraPtes1Pointer = MiGetPteAddress ((ULONG)VirtualAddress + 
                                            MiMaximumSystemCacheSizeExtra);

                MiMaximumSystemCacheSizeExtra >>= PAGE_SHIFT;

                MiSystemCacheStartExtra = VirtualAddress;
            }
            else {
                ExtraPtes1 = BYTES_TO_PAGES(MiSystemViewStart - (ULONG)VirtualAddress);
                ExtraPtes1Pointer = MiGetPteAddress (VirtualAddress);
            }
        }

        //
        // Allocate and initialize the page table pages.
        //

        while (StartPde <= EndPde) {

            ASSERT (StartPde->u.Hard.Valid == 0);
            if (StartPde->u.Hard.Valid == 0) {

                //
                // Map in a page directory page, using the
                // slush descriptor if one exists.
                //

                TempPde.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);
                *StartPde = TempPde;
                PointerPte = MiGetVirtualAddressMappedByPte (StartPde);
                RtlZeroMemory (PointerPte, PAGE_SIZE);
            }
            StartPde += 1;
        }

        if (MiUseMaximumSystemSpace != 0) {

            //
            // Use the 1GB->2GB virtual range for even more system PTEs.
            // Note the shared user data PTE (and PDE) must be left user
            // accessible, but everything else is kernelmode only.
            //

            ExtraPtes2 = BYTES_TO_PAGES(MiUseMaximumSystemSpaceEnd - MiUseMaximumSystemSpace);

            StartPde = MiGetPdeAddress (MiUseMaximumSystemSpace);
            EndPde = MiGetPdeAddress (MiUseMaximumSystemSpaceEnd);

            while (StartPde < EndPde) {

                ASSERT (StartPde->u.Hard.Valid == 0);

                //
                // Map in a page directory page, using the
                // slush descriptor if one exists.
                //

                TempPde.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);
                *StartPde = TempPde;
                PointerPte = MiGetVirtualAddressMappedByPte (StartPde);
                RtlZeroMemory (PointerPte, PAGE_SIZE);
                StartPde += 1;
            }
        }

        //
        // The virtual address, length and page tables to map the initial
        // nonpaged pool are already allocated - just fill in the mappings.
        //

        MmSubsectionBase = (ULONG)MmNonPagedPoolStart;

    }

    MmNonPagedPoolExpansionStart = NonPagedPoolStartVirtual;

    //
    // Make sure the scratch PTEs for the crash dump and debugger code
    // exist.  They may not if booted /3GB and alignment moved the PFN
    // database down and rippled the end of nonpaged pool down with it.
    //

    PointerPde = MiGetPdeAddress (MM_CRASH_DUMP_VA);
    ASSERT (PointerPde == MiGetPdeAddress (MM_DEBUG_VA));

    if (PointerPde->u.Hard.Valid == 0) {

        //
        // Map in a page table page, using the
        // slush descriptor if one exists.
        //

        TempPde.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);

        *PointerPde = TempPde;
        PointerPte = MiGetVirtualAddressMappedByPte (PointerPde);
        RtlZeroMemory (PointerPte, PAGE_SIZE);
    }

    //
    // Map the initial nonpaged pool.
    //

    PointerPte = MiGetPteAddress (MmNonPagedPoolStart);

    LastPte = MiGetPteAddress ((ULONG)MmNonPagedPoolStart +
                                        MmSizeOfNonPagedPoolInBytes - 1);

    if (MxMapLargePages & MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL) {
        ASSERT (MiIsPteOnPdeBoundary (LastPte + 1));
    }

    while (PointerPte <= LastPte) {
        TempPte.u.Hard.PageFrameNumber = PageFrameIndex;
        MI_WRITE_VALID_PTE (PointerPte, TempPte);
        PointerPte += 1;
        PageFrameIndex += 1;
    }

    if (MmVirtualBias != 0) {

        MmNonPagedPoolExpansionStart = (PVOID)((PCHAR)NonPagedPoolStartVirtual +
                    MmSizeOfNonPagedPoolInBytes);

        //
        // When booted /3GB, if /USERVA was specified then use any leftover
        // virtual space between 2 and 3gb for extra system PTEs.
        //

        if (MiUseMaximumSystemSpace != 0) {

            ExtraPtes2 = BYTES_TO_PAGES(MiUseMaximumSystemSpaceEnd - MiUseMaximumSystemSpace);

            StartPde = MiGetPdeAddress (MiUseMaximumSystemSpace);
            EndPde = MiGetPdeAddress (MiUseMaximumSystemSpaceEnd);

            while (StartPde < EndPde) {

                ASSERT (StartPde->u.Hard.Valid == 0);

                //
                // Map in a page directory page, using the
                // slush descriptor if one exists.
                //

                TempPde.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);
                *StartPde = TempPde;
                PointerPte = MiGetVirtualAddressMappedByPte (StartPde);
                RtlZeroMemory (PointerPte, PAGE_SIZE);
                StartPde += 1;
            }
        }
    }

    TempPte = ValidKernelPte;

    //
    // There must be at least one page of system PTEs before the expanded
    // nonpaged pool.
    //

    ASSERT (MiGetPteAddress (MmNonPagedSystemStart) < MiGetPteAddress (MmNonPagedPoolExpansionStart));

    //
    // Non-paged pages now exist, build the pool structures.
    //

    MiInitializeNonPagedPool ();

    MiInitializeNonPagedPoolThresholds ();

    //
    // Before nonpaged pool can be used, the PFN database must
    // be built.  This is due to the fact that the start and end of
    // allocation bits for nonpaged pool are maintained in the
    // PFN elements for the corresponding pages.
    //

    if (MxMapLargePages & MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL) {

        //
        // The physical pages to be used for the PFN database have already
        // been allocated.  Initialize the page table mappings (the
        // directory mappings are already initialized) for the PFN
        // database until the switch to large pages occurs in Phase 1.
        //

        PointerPte = MiGetPteAddress (MmPfnDatabase);

        LastPte = MiGetPteAddress ((ULONG_PTR)MmPfnDatabase + (MxPfnAllocation << PAGE_SHIFT));

        PageFrameIndex = FirstPfnDatabasePage;

        while (PointerPte < LastPte) {
            ASSERT ((PointerPte->u.Hard.Valid == 0) ||
                    (PointerPte->u.Hard.PageFrameNumber == PageFrameIndex));
            if (MiIsPteOnPdeBoundary (PointerPte)) {
                ASSERT ((PageFrameIndex & (MM_PFN_MAPPED_BY_PDE - 1)) == 0);
            }
            TempPte.u.Hard.PageFrameNumber = PageFrameIndex;

            if (PointerPte->u.Hard.Valid == 0) {
                MI_WRITE_VALID_PTE (PointerPte, TempPte);
            }
            else {
                MI_WRITE_VALID_PTE_NEW_PROTECTION (PointerPte, TempPte);
            }

            PointerPte += 1;
            PageFrameIndex += 1;
        }

        RtlZeroMemory (MmPfnDatabase, MxPfnAllocation << PAGE_SHIFT);
    }
    else {

        ULONG FreeNextPhysicalPage;
        ULONG FreeNumberOfPages;

        //
        // Go through the memory descriptors and for each physical page make
        // sure the PFN database has a valid PTE to map it.  This allows
        // machines with sparse physical memory to have a minimal PFN database.
        //

        FreeNextPhysicalPage = MxFreeDescriptor->BasePage;
        FreeNumberOfPages = MxFreeDescriptor->PageCount;

        PagesLeft = 0;
        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;
        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
            MemoryDescriptor = CONTAINING_RECORD (NextMd,
                                                  MEMORY_ALLOCATION_DESCRIPTOR,
                                                  ListEntry);

            if ((MemoryDescriptor->MemoryType == LoaderFirmwarePermanent) ||
                (MemoryDescriptor->MemoryType == LoaderBBTMemory) ||
                (MemoryDescriptor->MemoryType == LoaderSpecialMemory)) {

                //
                // Skip these ranges.
                //

                NextMd = MemoryDescriptor->ListEntry.Flink;
                continue;
            }

            //
            // Temporarily add back in the memory allocated since Phase 0
            // began so PFN entries for it will be created and mapped.
            //
            // Note actual PFN entry allocations must be done carefully as
            // memory from the descriptor itself could get used to map
            // the PFNs for the descriptor !
            //

            if (MemoryDescriptor == MxFreeDescriptor) {
                BasePage = MxOldFreeDescriptor.BasePage;
                PageCount = MxOldFreeDescriptor.PageCount;
            }
            else if (MemoryDescriptor == MxSlushDescriptor1) {
                BasePage = MxOldSlushDescriptor1.BasePage;
                PageCount = MxOldSlushDescriptor1.PageCount;
            }
            else if (MemoryDescriptor == MxSlushDescriptor2) {
                BasePage = MxOldSlushDescriptor2.BasePage;
                PageCount = MxOldSlushDescriptor2.PageCount;
            }
            else {
                BasePage = MemoryDescriptor->BasePage;
                PageCount = MemoryDescriptor->PageCount;
            }

            PointerPte = MiGetPteAddress (MI_PFN_ELEMENT(BasePage));

            LastPte = MiGetPteAddress (((PCHAR)(MI_PFN_ELEMENT(
                                            BasePage + PageCount))) - 1);

            while (PointerPte <= LastPte) {
                if (PointerPte->u.Hard.Valid == 0) {
                    TempPte.u.Hard.PageFrameNumber = FreeNextPhysicalPage;
                    ASSERT (FreeNumberOfPages != 0);
                    FreeNextPhysicalPage += 1;
                    FreeNumberOfPages -= 1;
                    if (FreeNumberOfPages == 0) {
                        KeBugCheckEx (INSTALL_MORE_MEMORY,
                                      MmNumberOfPhysicalPages,
                                      FreeNumberOfPages,
                                      MxOldFreeDescriptor.PageCount,
                                      1);
                    }
                    PagesLeft += 1;
                    MI_WRITE_VALID_PTE (PointerPte, TempPte);
                    RtlZeroMemory (MiGetVirtualAddressMappedByPte (PointerPte),
                                   PAGE_SIZE);
                }
                PointerPte += 1;
            }

            NextMd = MemoryDescriptor->ListEntry.Flink;
        }

        //
        // Update the global counts - this would have been tricky to do while
        // removing pages from them as we looped above.
        //
        // Later we will walk the memory descriptors and add pages to the free
        // list in the PFN database.
        //
        // To do this correctly:
        //
        // The FreeDescriptor fields must be updated so the PFN database
        // consumption isn't added to the freelist.
        //

        MxFreeDescriptor->BasePage = FreeNextPhysicalPage;
        MxFreeDescriptor->PageCount = FreeNumberOfPages;
    }

#if defined (_X86PAE_)

    for (i = 0; i < 32; i += 1) {
        j = i & 7;
        switch (j) {
            case MM_READONLY:
            case MM_READWRITE:
            case MM_WRITECOPY:
                MmProtectToPteMask[i] |= MmPaeMask;
                break;
            default:
                break;
        }
    }

#endif

    //
    // Initialize support for colored pages.
    //

    MmFreePagesByColor[0] = (PMMCOLOR_TABLES)
                              &MmPfnDatabase[MmHighestPossiblePhysicalPage + 1];

    //
    // Make sure the PTEs are mapped.
    //

    PointerPte = MiGetPteAddress (&MmFreePagesByColor[0][0]);

    LastPte = MiGetPteAddress ((PCHAR)MmFreePagesByColor[0] + (2 * MmSecondaryColors * sizeof (MMCOLOR_TABLES)) - 1);

    while (PointerPte <= LastPte) {
        if (PointerPte->u.Hard.Valid == 0) {
            TempPte.u.Hard.PageFrameNumber = MxGetNextPage (1, TRUE);
            MI_WRITE_VALID_PTE (PointerPte, TempPte);
            RtlZeroMemory (MiGetVirtualAddressMappedByPte (PointerPte),
                           PAGE_SIZE);
        }

        PointerPte += 1;
    }

    MmFreePagesByColor[1] = &MmFreePagesByColor[0][MmSecondaryColors];

    for (i = 0; i < MmSecondaryColors; i += 1) {
        MmFreePagesByColor[ZeroedPageList][i].Flink = MM_EMPTY_LIST;
        MmFreePagesByColor[ZeroedPageList][i].Blink = (PVOID) MM_EMPTY_LIST;
        MmFreePagesByColor[ZeroedPageList][i].Count = 0;
        MmFreePagesByColor[FreePageList][i].Flink = MM_EMPTY_LIST;
        MmFreePagesByColor[FreePageList][i].Blink = (PVOID) MM_EMPTY_LIST;
        MmFreePagesByColor[FreePageList][i].Count = 0;
    }

    //
    // Go through the page table entries and for any page which is valid,
    // update the corresponding PFN database element.
    //

    Pde = MiGetPdeAddress (NULL);
    va = 0;
    PdeCount = PD_PER_SYSTEM * PDE_PER_PAGE;

    for (i = 0; i < PdeCount; i += 1) {

        //
        // If the kernel image has been biased to allow for 3gb of user
        // address space, then the first several mb of memory is
        // double mapped to KSEG0_BASE and to ALTERNATE_BASE. Therefore,
        // the KSEG0_BASE entries must be skipped.
        //

        if (MmVirtualBias != 0) {
            if ((Pde >= MiGetPdeAddress(KSEG0_BASE)) &&
                (Pde < MiGetPdeAddress(KSEG0_BASE + MmBootImageSize))) {
                Pde += 1;
                va += (ULONG)PDE_PER_PAGE * (ULONG)PAGE_SIZE;
                continue;
            }
        }

        if ((Pde->u.Hard.Valid == 1) && (Pde->u.Hard.LargePage == 0)) {

            PdePage = MI_GET_PAGE_FRAME_FROM_PTE (Pde);

            if (MiIsRegularMemory (LoaderBlock, PdePage)) {

                Pfn1 = MI_PFN_ELEMENT(PdePage);
                Pfn1->u4.PteFrame = PdePageNumber;
                Pfn1->PteAddress = Pde;
                Pfn1->u2.ShareCount += 1;
                Pfn1->u3.e2.ReferenceCount = 1;
                Pfn1->u3.e1.PageLocation = ActiveAndValid;
                Pfn1->u3.e1.CacheAttribute = MiCached;
                MiDetermineNode (PdePage, Pfn1);
            }
            else {
                Pfn1 = NULL;
            }

            PointerPte = MiGetPteAddress (va);

            //
            // Set global bit.
            //

            TempPde.u.Long = MiDetermineUserGlobalPteMask (PointerPte) &
                                                           ~MM_PTE_ACCESS_MASK;

#if defined(_X86PAE_)

            //
            // Note that the PAE mode of the processor does not support the
            // global bit in PDEs which map 4K page table pages.
            //

            TempPde.u.Hard.Global = 0;
#endif

            Pde->u.Long |= TempPde.u.Long;

            for (j = 0 ; j < PTE_PER_PAGE; j += 1) {
                if (PointerPte->u.Hard.Valid == 1) {

                    PointerPte->u.Long |= MiDetermineUserGlobalPteMask (PointerPte) &
                                                            ~MM_PTE_ACCESS_MASK;

                    ASSERT (Pfn1 != NULL);
                    Pfn1->u2.ShareCount += 1;

                    if ((MiIsRegularMemory (LoaderBlock, (PFN_NUMBER) PointerPte->u.Hard.PageFrameNumber)) &&

                        ((va >= MM_KSEG2_BASE) &&
                         ((va < KSEG0_BASE + MmVirtualBias) ||
                          (va >= (KSEG0_BASE + MmVirtualBias + MmBootImageSize)))) ||
                        ((MmVirtualBias == 0) &&
                         (va >= (ULONG)MmNonPagedPoolStart) &&
                         (va < (ULONG)MmNonPagedPoolStart + MmSizeOfNonPagedPoolInBytes))) {

                        Pfn2 = MI_PFN_ELEMENT(PointerPte->u.Hard.PageFrameNumber);

                        if (MmIsAddressValid (Pfn2) &&
                             MmIsAddressValid ((PUCHAR)(Pfn2+1)-1)) {

                            Pfn2->u4.PteFrame = PdePage;
                            Pfn2->PteAddress = PointerPte;
                            Pfn2->u2.ShareCount += 1;
                            Pfn2->u3.e2.ReferenceCount = 1;
                            Pfn2->u3.e1.PageLocation = ActiveAndValid;
                            Pfn2->u3.e1.CacheAttribute = MiCached;
                            MiDetermineNode (
                                (PFN_NUMBER)PointerPte->u.Hard.PageFrameNumber,
                                Pfn2);
                        }
                    }
                }

                va += PAGE_SIZE;
                PointerPte += 1;
            }

        }
        else {
            va += (ULONG)PDE_PER_PAGE * (ULONG)PAGE_SIZE;
        }

        Pde += 1;
    }

    MI_FLUSH_CURRENT_TB ();

    //
    // If the lowest physical page is zero and the page is still unused, mark
    // it as in use. This is because we want to find bugs where a physical
    // page is specified as zero.
    //

    Pfn1 = &MmPfnDatabase[MmLowestPhysicalPage];

    if ((MmLowestPhysicalPage == 0) && (Pfn1->u3.e2.ReferenceCount == 0)) {

        ASSERT (Pfn1->u3.e2.ReferenceCount == 0);

        //
        // Make the reference count non-zero and point it into a
        // page directory.
        //

        Pde = MiGetPdeAddress (0xffffffff);
        PdePage = MI_GET_PAGE_FRAME_FROM_PTE (Pde);
        Pfn1->u4.PteFrame = PdePageNumber;
        Pfn1->PteAddress = Pde;
        Pfn1->u2.ShareCount += 1;
        Pfn1->u3.e2.ReferenceCount = 0xfff0;
        Pfn1->u3.e1.PageLocation = ActiveAndValid;
        Pfn1->u3.e1.CacheAttribute = MiCached;
        MiDetermineNode (0, Pfn1);
    }

    Bias = 0;

    if (MmVirtualBias != 0) {

        //
        // This is nasty.  You don't want to know.  Cleanup needed.
        //

        Bias = ALTERNATE_BASE - KSEG0_BASE;
    }

    //
    // Walk through the memory descriptors and add pages to the
    // free list in the PFN database.  Before doing this, adjust the
    // two descriptors we used so they only contain memory that can be
    // freed now (ie: any memory we removed from them earlier in this routine
    // without updating the descriptor for must be updated now).
    //

    //
    // We may have taken memory out of the MxFreeDescriptor - but
    // that's ok because we wouldn't want to free that memory right now
    // (or ever) anyway.
    //

    //
    // Since the LoaderBlock memory descriptors are ordered
    // from low physical memory address to high, walk it backwards so the
    // high physical pages go to the front of the freelists.  The thinking
    // is that pages initially allocated by the system are less likely to be
    // freed so don't waste memory below 16mb (or 4gb) that may be needed
    // by ISA drivers later.
    //

    NextMd = LoaderBlock->MemoryDescriptorListHead.Blink;

    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD (NextMd,
                                              MEMORY_ALLOCATION_DESCRIPTOR,
                                              ListEntry);

        i = MemoryDescriptor->PageCount;
        PageFrameIndex = MemoryDescriptor->BasePage;

        //
        // Ensure no frames are inserted beyond the end of the PFN
        // database.  This can happen for example if the system
        // has > 16GB of RAM and is booted /3GB - the top of this
        // routine reduces the highest physical page and then
        // creates the PFN database.  But the loader block still
        // contains descriptions of the pages above 16GB.
        //

        if (PageFrameIndex > MmHighestPhysicalPage) {
            NextMd = MemoryDescriptor->ListEntry.Blink;
            continue;
        }

        if (PageFrameIndex + i > MmHighestPhysicalPage + 1) {
            i = MmHighestPhysicalPage + 1 - PageFrameIndex;
            MemoryDescriptor->PageCount = i;
            if (i == 0) {
                NextMd = MemoryDescriptor->ListEntry.Blink;
                continue;
            }
        }

        if ((MemoryDescriptor == MxSlushDescriptor1) ||
            (MemoryDescriptor == MxSlushDescriptor2)) {

            //
            // Excess slush is given to expansion nonpaged pool here to ensure
            // that it is always mapped fully cached since the rest of the
            // large page is inserted as fully cached into the TB.
            //

            MiAddExpansionNonPagedPool (PageFrameIndex, i, FALSE);
            NextMd = MemoryDescriptor->ListEntry.Blink;
            continue;
        }

        switch (MemoryDescriptor->MemoryType) {
            case LoaderBad:
                while (i != 0) {
                    MiInsertPageInList (&MmBadPageListHead, PageFrameIndex);
                    i -= 1;
                    PageFrameIndex += 1;
                }
                break;

            case LoaderFree:
            case LoaderLoadedProgram:
            case LoaderFirmwareTemporary:
            case LoaderOsloaderStack:

                PageFrameIndex += (i - 1);
                Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
                LOCK_PFN (OldIrql);
                while (i != 0) {
                    if (Pfn1->u3.e2.ReferenceCount == 0) {

                        //
                        // Set the PTE address to the physical page for
                        // virtual address alignment checking.
                        //

                        Pfn1->u3.e1.CacheAttribute = MiCached;
                        MiDetermineNode (PageFrameIndex, Pfn1);
                        MiInsertPageInFreeList (PageFrameIndex);
                    }

                    Pfn1 -= 1;
                    i -= 1;
                    PageFrameIndex -= 1;
                }
                UNLOCK_PFN (OldIrql);

                break;

            case LoaderFirmwarePermanent:
            case LoaderSpecialMemory:
            case LoaderBBTMemory:

                //
                // Skip these ranges.
                //

                break;

            default:

                PointerPte = MiGetPteAddress (KSEG0_BASE + Bias +
                                            (PageFrameIndex << PAGE_SHIFT));

                Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
                while (i != 0) {

                    //
                    // Set page as in use.
                    //

                    PointerPde = MiGetPdeAddress (KSEG0_BASE + Bias +
                                             (PageFrameIndex << PAGE_SHIFT));

                    if (Pfn1->u3.e2.ReferenceCount == 0) {
                        Pfn1->u4.PteFrame = MI_GET_PAGE_FRAME_FROM_PTE (PointerPde);
                        Pfn1->PteAddress = PointerPte;
                        Pfn1->u2.ShareCount += 1;
                        Pfn1->u3.e2.ReferenceCount = 1;
                        Pfn1->u3.e1.PageLocation = ActiveAndValid;
                        MiDetermineNode (PageFrameIndex, Pfn1);

                        if (MemoryDescriptor->MemoryType == LoaderXIPRom) {
                            Pfn1->u1.Flink = 0;
                            Pfn1->u2.ShareCount = 0;
                            Pfn1->u3.e2.ReferenceCount = 0;
                            Pfn1->u3.e1.PageLocation = 0;
                            Pfn1->u3.e1.Rom = 1;
                            Pfn1->u4.InPageError = 0;
                            Pfn1->u3.e1.PrototypePte = 1;
                        }
                        Pfn1->u3.e1.CacheAttribute = MiCached;
                    }
                    Pfn1 += 1;
                    i -= 1;
                    PageFrameIndex += 1;
                    PointerPte += 1;
                }
                break;
        }

        NextMd = MemoryDescriptor->ListEntry.Blink;
    }

    if ((MxMapLargePages & MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL) == 0) {

        //
        // When booted /3GB, the PTEs mapping the PFN database were already
        // scanned above as part of scanning the entire VA space, and the
        // PFNs updated then.  For non-3GB, the PFNs must be updated now.
        //

        if (MmVirtualBias == 0) {
            PointerPte = MiGetPteAddress (&MmPfnDatabase[MmLowestPhysicalPage]);
            LastPte = MiGetPteAddress (&MmPfnDatabase[MmHighestPossiblePhysicalPage]);
            while (PointerPte <= LastPte) {
                if (PointerPte->u.Hard.Valid == 1) {
                    Pfn1 = MI_PFN_ELEMENT(PointerPte->u.Hard.PageFrameNumber);
                    Pfn1->u2.ShareCount = 1;
                    Pfn1->u3.e2.ReferenceCount = 1;
                }
                PointerPte += 1;
            }
        }
    }
    else {

        //
        // The PFN database is allocated using large pages.
        //
        // If the large page chunk came from the middle of the free descriptor
        // (due to alignment requirements), then add the pages from the split
        // bottom portion of the free descriptor now.
        //
    
        i = MiSlushDescriptorCount;
        PageFrameIndex = MiSlushDescriptorBase;
        Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
    
        PointerPte = MiGetPteAddress (KSEG0_BASE + Bias +
                                    (PageFrameIndex << PAGE_SHIFT));

        while (i != 0) {
            if (Pfn1->u3.e2.ReferenceCount == 0) {
    
                //
                // Set the PTE address to the physical page for
                // virtual address alignment checking.
                //
    
                LOCK_PFN (OldIrql);
                Pfn1->PteAddress = PointerPte;
                Pfn1->u3.e1.CacheAttribute = MiCached;
                MiDetermineNode (PageFrameIndex, Pfn1);
                MiInsertPageInFreeList (PageFrameIndex);
                UNLOCK_PFN (OldIrql);
            }
            Pfn1 += 1;
            i -= 1;
            PageFrameIndex += 1;
            PointerPte += 1;
        }

        //
        // Mark all PFN entries for the PFN database pages as in use.
        //

        PointerPte = MiGetPteAddress (MmPfnDatabase);
        PageFrameIndex = (PFN_NUMBER) PointerPte->u.Hard.PageFrameNumber;
        Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
        i = MxPfnAllocation;

        do {
            Pfn1->u3.e1.CacheAttribute = MiCached;
            MiDetermineNode (PageFrameIndex, Pfn1);
            Pfn1->u3.e2.ReferenceCount = 1;
            PageFrameIndex += 1;
            Pfn1 += 1;
            i -= 1;
        } while (i != 0);

        if (MmDynamicPfn == 0) {

            //
            // Scan the PFN database backward for pages that are completely
            // zero.  These pages are unused and can be added to the free list.
            //

            BottomPfn = MI_PFN_ELEMENT (MmHighestPhysicalPage);
            do {

                //
                // Compute the address of the start of the page that is next
                // lower in memory and scan backwards until that page address
                // is reached or just crossed.
                //

                if (BYTE_OFFSET (BottomPfn)) {
                    BasePfn = (PMMPFN) PAGE_ALIGN (BottomPfn);
                    TopPfn = BottomPfn + 1;
                }
                else {
                    BasePfn = (PMMPFN) PAGE_ALIGN (BottomPfn - 1);
                    TopPfn = BottomPfn;
                }

                while (BottomPfn > BasePfn) {
                    BottomPfn -= 1;
                }

                //
                // If the entire range over which the PFN entries span is
                // completely zero and the PFN entry that maps the page is
                // not in the range, then add the page to the appropriate
                // free list.
                //

                Range = (ULONG)TopPfn - (ULONG)BottomPfn;
                if (RtlCompareMemoryUlong((PVOID)BottomPfn, Range, 0) == Range) {

                    //
                    // Set the PTE address to the physical page for virtual
                    // address alignment checking.
                    //

                    PointerPte = MiGetPteAddress (BasePfn);
                    PageFrameIndex = (PFN_NUMBER)PointerPte->u.Hard.PageFrameNumber;
                    Pfn1 = MI_PFN_ELEMENT(PageFrameIndex);

                    ASSERT (Pfn1->u3.e2.ReferenceCount == 1);
                    Pfn1->u3.e2.ReferenceCount = 0;
                    Pfn1->u3.e1.CacheAttribute = MiCached;

                    MiDetermineNode (PageFrameIndex, Pfn1);
                    MiAddExpansionNonPagedPool (PageFrameIndex, 1, FALSE);
                }
            } while (BottomPfn > MmPfnDatabase);
        }
    }

    //
    // Adjust the memory descriptor to indicate that free pool has
    // been used for nonpaged pool creation.
    //
    // N.B.  This is required because the descriptors are walked upon
    // return from this routine to create the MmPhysicalMemoryBlock.
    //

    *MxFreeDescriptor = *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldFreeDescriptor;

    if (MxSlushDescriptor1 != NULL) {
        *MxSlushDescriptor1 = *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor1;
    }

    if (MxSlushDescriptor2 != NULL) {
        *MxSlushDescriptor2 = *(PMEMORY_ALLOCATION_DESCRIPTOR)&MxOldSlushDescriptor2;
    }

    //
    // Initialize the nonpaged pool.
    //

    InitializePool (NonPagedPool, 0);

    //
    // Initialize the system PTE pool now that nonpaged pool exists.
    // This is used for mapping I/O space, driver images and kernel stacks.
    // Note this expands the initial PTE allocation to use all possible
    // available virtual space by reclaiming the initial nonpaged
    // pool range (in non /3GB systems) because that range has already been
    // moved into the 2GB virtual range.
    //

    PointerPte = MiGetPteAddress (MmNonPagedSystemStart);
    ASSERT (((ULONG)PointerPte & (PAGE_SIZE - 1)) == 0);

    if (MmVirtualBias == 0) {
        MmNumberOfSystemPtes = MiGetPteAddress (NonPagedPoolStartVirtual) - PointerPte - 1;
    }
    else {
        if (MxMapLargePages & MI_LARGE_PFN_DATABASE_AND_NONPAGED_POOL) {
            AlignedPfnDatabase = (PMMPFN) ((ULONG) MmPfnDatabase & ~(MM_VA_MAPPED_BY_PDE - 1));
            MmNumberOfSystemPtes = MiGetPteAddress (AlignedPfnDatabase) - PointerPte;
            //
            // Reduce the system PTE space by one PTE to create a guard page.
            //

            MmNumberOfSystemPtes -= 1;
        }
        else {
            MmNumberOfSystemPtes = MiGetPteAddress (MmPfnDatabase) - PointerPte - 1;
        }
    }

    MiInitializeSystemPtes (PointerPte, MmNumberOfSystemPtes, SystemPteSpace);

    //
    // Now that the system PTE chain has been initialized, add any additional
    // ranges to the reserve.
    //

    if (ExtraPtes1 != 0) {

        //
        // Increment the system PTEs (for autoconfiguration purposes) and put
        // the PTE chain into reserve so it isn't used until needed (to
        // prevent fragmentation).
        //

        MiIncrementSystemPtes (ExtraPtes1);

        MiAddExtraSystemPteRanges (ExtraPtes1Pointer, ExtraPtes1);
    }

    if (ExtraPtes2 != 0) {

        //
        // Increment the system PTEs (for autoconfiguration purposes) and put
        // the PTE chain into reserve so it isn't used until needed (to
        // prevent fragmentation).
        //

        if (MM_SHARED_USER_DATA_VA > MiUseMaximumSystemSpace) {
            if (MiUseMaximumSystemSpaceEnd > MM_SHARED_USER_DATA_VA) {
                ExtraPtes2 = BYTES_TO_PAGES(MM_SHARED_USER_DATA_VA - MiUseMaximumSystemSpace);
            }
        }
        else {
            ASSERT (MmVirtualBias != 0);
        }

        if (ExtraPtes2 != 0) {

            //
            // Increment the system PTEs (for autoconfiguration purposes) but
            // don't actually add the PTEs till later (to prevent
            // fragmentation).
            //

            PointerPte = MiGetPteAddress (MiUseMaximumSystemSpace);

            MiAddExtraSystemPteRanges (PointerPte, ExtraPtes2);

            MiIncrementSystemPtes (ExtraPtes2);
        }
    }

    //
    // Initialize memory management structures for this process.
    //
    // Build the working set list.  This requires the creation of a PDE
    // to map hyperspace and the page table page pointed to
    // by the PDE must be initialized.
    //
    // Note we can't remove a zeroed page as hyperspace does not
    // exist and we map non-zeroed pages into hyperspace to zero them.
    //

    TempPde = ValidKernelPdeLocal;

    PointerPde = MiGetPdeAddress (HYPER_SPACE);

    LOCK_PFN (OldIrql);

    PageFrameIndex = MiRemoveAnyPage (0);
    TempPde.u.Hard.PageFrameNumber = PageFrameIndex;

    MI_WRITE_VALID_PTE (PointerPde, TempPde);

    MI_FLUSH_CURRENT_TB ();

    UNLOCK_PFN (OldIrql);

    //
    // Point to the page table page we just created and zero it.
    //

    PointerPte = MiGetPteAddress (HYPER_SPACE);
    RtlZeroMemory ((PVOID)PointerPte, PAGE_SIZE);

    //
    // Hyper space now exists, set the necessary variables.
    //

    MmFirstReservedMappingPte = MiGetPteAddress (FIRST_MAPPING_PTE);
    MmLastReservedMappingPte = MiGetPteAddress (LAST_MAPPING_PTE);

    MmFirstReservedMappingPte->u.Hard.PageFrameNumber = NUMBER_OF_MAPPING_PTES;

    MmWorkingSetList = (PMMWSL) ((ULONG_PTR)VAD_BITMAP_SPACE + PAGE_SIZE);

    //
    // Create zeroing PTEs for the zero page thread.
    //

    MiFirstReservedZeroingPte = MiReserveSystemPtes (NUMBER_OF_ZEROING_PTES + 1, SystemPteSpace);

    RtlZeroMemory (MiFirstReservedZeroingPte,
                   (NUMBER_OF_ZEROING_PTES + 1) * sizeof(MMPTE));

    //
    // Use the page frame number field of the first PTE as an
    // offset into the available zeroing PTEs.
    //

    MiFirstReservedZeroingPte->u.Hard.PageFrameNumber = NUMBER_OF_ZEROING_PTES;

    //
    // Create the VAD bitmap for this process.
    //

    PointerPte = MiGetPteAddress (VAD_BITMAP_SPACE);

    LOCK_PFN (OldIrql);
    PageFrameIndex = MiRemoveAnyPage (0);
    UNLOCK_PFN (OldIrql);

    //
    // Note the global bit must be off for the bitmap data.
    //

    TempPte = ValidKernelPteLocal;
    TempPte.u.Hard.PageFrameNumber = PageFrameIndex;
    MI_WRITE_VALID_PTE (PointerPte, TempPte);

    //
    // Point to the page we just created and zero it.
    //

    RtlZeroMemory (VAD_BITMAP_SPACE, PAGE_SIZE);

    //
    // If booted /3GB, then the bitmap needs to be 2K bigger, shift
    // the working set accordingly as well.
    //
    // Note the 2K expansion portion of the bitmap is automatically
    // carved out of the working set page allocated below.
    //

    if (MmVirtualBias != 0) {
        MmWorkingSetList = (PMMWSL) ((ULONG_PTR)MmWorkingSetList + PAGE_SIZE / 2);
    }

    MiLastVadBit = (((ULONG_PTR) MI_64K_ALIGN (MM_HIGHEST_VAD_ADDRESS))) / X64K;

#if defined (_X86PAE_)

    //
    // Only bitmap the first 2GB of the PAE address space when booted /3GB.
    // This is because PAE has twice as many pagetable pages as non-PAE which
    // causes the MMWSL structure to be larger than 2K.  If we bitmapped the
    // entire user address space in this configuration then we'd need a 6K
    // bitmap and this would cause the initial MMWSL structure to overflow
    // into a second page.  This would require a bunch of extra code throughout
    // process support and other areas so just limit the bitmap for now.
    //

    if (MiLastVadBit > PAGE_SIZE * 8 - 1) {
        ASSERT (MmVirtualBias != 0);
        MiLastVadBit = PAGE_SIZE * 8 - 1;
        MmWorkingSetList = (PMMWSL) ((ULONG_PTR)VAD_BITMAP_SPACE + PAGE_SIZE);
    }

#endif

    //
    // Initialize this process's memory management structures including
    // the working set list.
    //
    // The PFN element for the page directory has already been initialized,
    // zero the reference count and the share count so they won't be
    // wrong.
    //

    Pfn1 = MI_PFN_ELEMENT (PdePageNumber);

    LOCK_PFN (OldIrql);

    Pfn1->u2.ShareCount = 0;
    Pfn1->u3.e2.ReferenceCount = 0;

#if defined (_X86PAE_)
    PointerPte = MiGetPteAddress (PDE_BASE);
    for (i = 0; i < PD_PER_SYSTEM; i += 1) {

        PdePageNumber = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

        Pfn1 = MI_PFN_ELEMENT (PdePageNumber);
        Pfn1->u2.ShareCount = 0;
        Pfn1->u3.e2.ReferenceCount = 0;

        PointerPte += 1;
    }
#endif

    //
    // Get a page for the working set list and zero it.
    //

    TempPte = ValidKernelPteLocal;
    PageFrameIndex = MiRemoveAnyPage (0);
    TempPte.u.Hard.PageFrameNumber = PageFrameIndex;

    PointerPte = MiGetPteAddress (MmWorkingSetList);
    MI_WRITE_VALID_PTE (PointerPte, TempPte);

    //
    // Note that when booted /3GB, MmWorkingSetList is not page aligned, so
    // always start zeroing from the start of the page regardless.
    //

    RtlZeroMemory (MiGetVirtualAddressMappedByPte (PointerPte), PAGE_SIZE);

    CurrentProcess->WorkingSetPage = PageFrameIndex;

#if defined (_X86PAE_)
    MiPaeInitialize ();
#endif

    MI_FLUSH_CURRENT_TB ();

    UNLOCK_PFN (OldIrql);

    CurrentProcess->Vm.MaximumWorkingSetSize = MmSystemProcessWorkingSetMax;
    CurrentProcess->Vm.MinimumWorkingSetSize = MmSystemProcessWorkingSetMin;

    DummyFlags = 0;
    MmInitializeProcessAddressSpace (CurrentProcess, NULL, NULL, &DummyFlags, NULL);

    //
    // Ensure the secondary page structures are marked as in use.
    //

    if (MmVirtualBias == 0) {

        ASSERT (MmFreePagesByColor[0] < (PMMCOLOR_TABLES)MM_SYSTEM_CACHE_END_EXTRA);

        PointerPde = MiGetPdeAddress(MmFreePagesByColor[0]);
        ASSERT (PointerPde->u.Hard.Valid == 1);

        PointerPte = MiGetPteAddress (MmFreePagesByColor[0]);
        ASSERT (PointerPte->u.Hard.Valid == 1);

        LastPte = MiGetPteAddress ((ULONG)&MmFreePagesByColor[1][MmSecondaryColors] - 1);
        ASSERT (LastPte->u.Hard.Valid == 1);

        LOCK_PFN (OldIrql);

        while (PointerPte <= LastPte) {
            PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
            Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

            if (Pfn1->u3.e2.ReferenceCount == 0) {
                Pfn1->u4.PteFrame = MI_GET_PAGE_FRAME_FROM_PTE (PointerPde);
                Pfn1->PteAddress = PointerPte;
                Pfn1->u2.ShareCount += 1;
                Pfn1->u3.e2.ReferenceCount = 1;
                Pfn1->u3.e1.PageLocation = ActiveAndValid;
                Pfn1->u3.e1.CacheAttribute = MiCached;
                MiDetermineNode (PageFrameIndex, Pfn1);
            }
            PointerPte += 1;
        }
        UNLOCK_PFN (OldIrql);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\amd64\miamd.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    miamd.h

Abstract:

    This module contains the private data structures and procedure
    prototypes for the hardware dependent portion of the
    memory management system.

    This module is specifically tailored for the AMD 64-bit processor.

--*/

/*++

    Virtual Memory Layout on the AMD64 is:

                 +------------------------------------+
0000000000000000 | User mode addresses - 8tb minus 64k|
                 |                                    |
                 |                                    |
000007FFFFFEFFFF |                                    | MM_HIGHEST_USER_ADDRESS
                 +------------------------------------+
000007FFFFFF0000 | 64k No Access Region               | MM_USER_PROBE_ADDRESS
000007FFFFFFFFFF |                                    |
                 +------------------------------------+

                                   .
                 +------------------------------------+
FFFF080000000000 | Start of System space              | MM_SYSTEM_RANGE_START
                 +------------------------------------+
FFFFF68000000000 | 512gb four level page table map.   | PTE_BASE
                 +------------------------------------+
FFFFF70000000000 | HyperSpace - working set lists     | HYPER_SPACE
                 | and per process memory management  |
                 | structures mapped in this 512gb    |
                 | region.                            | HYPER_SPACE_END
                 +------------------------------------+     MM_WORKING_SET_END
FFFFF78000000000 | Shared system page                 | KI_USER_SHARED_DATA
                 +------------------------------------+
FFFFF78000001000 | The system cache working set       | MM_SYSTEM_CACHE_WORKING_SET
                 | information resides in this        |
                 | 512gb-4k region.                   |
                 |                                    |
                 +------------------------------------+
                                   .
                                   .
Note the ranges below are sign extended for > 43 bits and therefore
can be used with interlocked slists.  The system address space above is NOT.
                                   .
                                   .
                 +------------------------------------+
FFFFF80000000000 |                                    | MM_KSEG0_BASE
                 | Mappings initialized by the loader.| MM_KSEG2_BASE
                 +------------------------------------+
FFFFF90000000000 | win32k.sys                         |
                 |                                    |
                 | Hydra configurations have session  |
                 | data structures here.              |
                 |                                    |
                 | This is a 512gb region.            |
                 +------------------------------------+
                 |                                    | MM_SYSTEM_SPACE_START
FFFFF98000000000 | System cache resides here.         | MM_SYSTEM_CACHE_START
                 |  Kernel mode access only.          |
                 |  1tb.                              |
                 |                                    | MM_SYSTEM_CACHE_END
                 +------------------------------------+
FFFFFA8000000000 | Start of paged system area.        | MM_PAGED_POOL_START
                 |  Kernel mode access only.          |
                 |  128gb.                            |
                 +------------------------------------+
                 | System mapped views start just     |
                 | after paged pool.  Default is      |
                 | 104MB, can be registry-overridden. |
                 | 8GB maximum.                       |
                 |                                    |
                 +------------------------------------+
FFFFFAA000000000 | System PTE pool.                   | MM_LOWEST_NONPAGED_SYSTEM_START
                 |  Kernel mode access only.          |
                 |  128gb.                            |
                 +------------------------------------+
FFFFFAC000000000 | NonPaged pool.                     | MM_NON_PAGED_POOL_START
                 |  Kernel mode access only.          |
                 |  128gb.                            |
                 |                                    |
FFFFFADFFFFFFFFF |  NonPaged System area              | MM_NONPAGED_POOL_END
                 +------------------------------------+
                                   .
                                   .
                                   .
                                   .
                 +------------------------------------+
FFFFFFFF80000000 |                                    |
                 | Reserved for the HAL. 2gb.         |
FFFFFFFFFFFFFFFF |                                    | MM_SYSTEM_SPACE_END
                 +------------------------------------+

--*/

#define _MI_PAGING_LEVELS 4

#define _MI_MORE_THAN_4GB_ 1

#define _MI_USE_BIT_INTRINSICS 1

//
// Top level PXE mapping allocations:
//
// 0x0->0xF:        0x10 user entries
// 0x1ed:           0x1 for selfmaps
// 0x1ee:           0x1 hyperspace entry
// 0x1ef:           0x1 entry for syscache WSL & shared user data
// 0x1f0->0x1ff:    0x10 kernel entries
//

//
// Define empty list markers.
//

#define MM_EMPTY_LIST ((ULONG_PTR)-1)              //
#define MM_EMPTY_PTE_LIST 0xFFFFFFFFUI64 // N.B. tied to MMPTE definition

#define MI_PTE_BASE_FOR_LOWEST_KERNEL_ADDRESS (MiGetPteAddress (MM_KSEG0_BASE))

#define MI_PTE_BASE_FOR_LOWEST_SESSION_ADDRESS (MiGetPteAddress (MM_SESSION_SPACE_DEFAULT))

//
// This is the size of the region used by the loader.
//

extern ULONG_PTR MmBootImageSize;

//
// PAGE_SIZE for AMD64 is 4k, virtual page is 36 bits with a PAGE_SHIFT
// byte offset.
//

#define MM_VIRTUAL_PAGE_FILLER 0
#define MM_VIRTUAL_PAGE_SIZE (64 - 12)

//
// Address space layout definitions.
//

#define MM_KSEG2_BASE  0xFFFFF90000000000UI64

#define MM_PAGES_IN_KSEG0 ((MM_KSEG2_BASE - MM_KSEG0_BASE) >> PAGE_SHIFT)

#define MM_SYSTEM_SPACE_START 0xFFFFF98000000000UI64

#define MM_USER_ADDRESS_RANGE_LIMIT    0xFFFFFFFFFFFFFFFF // user address range limit
#define MM_MAXIMUM_ZERO_BITS 53         // maximum number of zero bits

//
// Define the start and maximum size for the system cache.
//

#define MM_SYSTEM_CACHE_START 0xFFFFF98000000000UI64

#define MM_SYSTEM_CACHE_END   0xFFFFFA8000000000UI64

#define MM_MAXIMUM_SYSTEM_CACHE_SIZE \
    ((MM_SYSTEM_CACHE_END - MM_SYSTEM_CACHE_START) >> PAGE_SHIFT)

#define MM_SYSTEM_CACHE_WORKING_SET 0xFFFFF78000001000UI64

//
// Define area for mapping views into system space.
//

#define MM_SESSION_SPACE_DEFAULT_END    0xFFFFF98000000000UI64
#define MM_SESSION_SPACE_DEFAULT        (MM_SESSION_SPACE_DEFAULT_END - MI_SESSION_SPACE_MAXIMUM_TOTAL_SIZE)

#define MM_SYSTEM_VIEW_SIZE (104 * 1024 * 1024)

//
// Various system resource locations.
//

#define MM_PAGED_POOL_START ((PVOID)0xFFFFFA8000000000)

#define MM_LOWEST_NONPAGED_SYSTEM_START ((PVOID)0xFFFFFAA000000000)

#define MM_NONPAGED_POOL_END ((PVOID)(0xFFFFFAE000000000)) 

extern PVOID MmDebugVa;
#define MM_DEBUG_VA MmDebugVa

extern PVOID MmCrashDumpVa;
#define MM_CRASH_DUMP_VA MmCrashDumpVa

#define NON_PAGED_SYSTEM_END ((PVOID)0xFFFFFFFFFFFFFFF0)

extern BOOLEAN MiWriteCombiningPtes;

//
// Define absolute minimum and maximum count for system PTEs.
//

#define MM_MINIMUM_SYSTEM_PTES 7000

#define MM_MAXIMUM_SYSTEM_PTES (16*1024*1024)

#define MM_DEFAULT_SYSTEM_PTES 11000

//
// Pool limits.
//
// The maximum amount of nonpaged pool that can be initially created.
//

#define MM_MAX_INITIAL_NONPAGED_POOL (128 * 1024 * 1024)

//
// The total amount of nonpaged pool (initial pool + expansion).
//

#define MM_MAX_ADDITIONAL_NONPAGED_POOL (((SIZE_T)128 * 1024 * 1024 * 1024))

//
// The maximum amount of paged pool that can be created.
//

#define MM_MAX_PAGED_POOL ((SIZE_T)128 * 1024 * 1024 * 1024)

#define MM_MAX_DEFAULT_NONPAGED_POOL ((SIZE_T)8 * 1024 * 1024 * 1024)


//
// Structure layout definitions.
//

#define MM_PROTO_PTE_ALIGNMENT ((ULONG)MM_MAXIMUM_NUMBER_OF_COLORS * (ULONG)PAGE_SIZE)

//
// Define the address bits mapped by one PXE/PPE/PDE/PTE entry.
//

#define MM_VA_MAPPED_BY_PTE ((ULONG_PTR)PAGE_SIZE)
#define MM_VA_MAPPED_BY_PDE (PTE_PER_PAGE * MM_VA_MAPPED_BY_PTE)
#define MM_VA_MAPPED_BY_PPE (PDE_PER_PAGE * MM_VA_MAPPED_BY_PDE)
#define MM_VA_MAPPED_BY_PXE (PPE_PER_PAGE * MM_VA_MAPPED_BY_PPE)

//
// Define the address bits mapped by PPE and PDE entries.
//
// A PXE entry maps 9+9+9+12 = 39 bits of address space.
// A PPE entry maps 9+9+12 = 30 bits of address space.
// A PDE entry maps 9+12 = 21 bits of address space.
//

#define PAGE_DIRECTORY0_MASK (MM_VA_MAPPED_BY_PXE - 1)
#define PAGE_DIRECTORY1_MASK (MM_VA_MAPPED_BY_PPE - 1)
#define PAGE_DIRECTORY2_MASK (MM_VA_MAPPED_BY_PDE - 1)

#define PTE_SHIFT 3

#define MM_MINIMUM_VA_FOR_LARGE_PAGE MM_VA_MAPPED_BY_PDE

//
// The number of bits in a virtual address.
//

#define VIRTUAL_ADDRESS_BITS 48
#define VIRTUAL_ADDRESS_MASK ((((ULONG_PTR)1) << VIRTUAL_ADDRESS_BITS) - 1)

//
// The number of bits in a physical address.
//

#define PHYSICAL_ADDRESS_BITS 40

#define MM_MAXIMUM_NUMBER_OF_COLORS (1)

//
// AMD64 does not require support for colored pages.
//

#define MM_NUMBER_OF_COLORS (1)

//
// Mask for obtaining color from a physical page number.
//

#define MM_COLOR_MASK (0)

//
// Boundary for aligned pages of like color upon.
//

#define MM_COLOR_ALIGNMENT (0)

//
// Mask for isolating color from virtual address.
//

#define MM_COLOR_MASK_VIRTUAL (0)

//
//  Define 256k worth of secondary colors.
//

#define MM_SECONDARY_COLORS_DEFAULT (64)

#define MM_SECONDARY_COLORS_MIN (8)

#define MM_SECONDARY_COLORS_MAX (1024)

//
// Maximum number of paging files.
//

#define MAX_PAGE_FILES 16


//
// Hyper space definitions.
//

#define HYPER_SPACE     ((PVOID)0xFFFFF70000000000)
#define HYPER_SPACE_END         0xFFFFF77FFFFFFFFFUI64

#define FIRST_MAPPING_PTE    0xFFFFF70000000000

#define NUMBER_OF_MAPPING_PTES 126

#define LAST_MAPPING_PTE   \
    (FIRST_MAPPING_PTE + (NUMBER_OF_MAPPING_PTES * PAGE_SIZE))

#define COMPRESSION_MAPPING_PTE   ((PMMPTE)((ULONG_PTR)LAST_MAPPING_PTE + PAGE_SIZE))

#define NUMBER_OF_ZEROING_PTES 256

#define VAD_BITMAP_SPACE    ((PVOID)((ULONG_PTR)COMPRESSION_MAPPING_PTE + PAGE_SIZE))

#define WORKING_SET_LIST   ((PVOID)((ULONG_PTR)VAD_BITMAP_SPACE + PAGE_SIZE))

#define MM_MAXIMUM_WORKING_SET \
    ((((ULONG_PTR)8 * 1024 * 1024 * 1024 * 1024) - (64 * 1024 * 1024)) >> PAGE_SHIFT) //8Tb-64Mb

#define MmWorkingSetList ((PMMWSL)WORKING_SET_LIST)

#define MmWsle ((PMMWSLE)((PUCHAR)WORKING_SET_LIST + sizeof(MMWSL)))

#define MM_WORKING_SET_END (HYPER_SPACE_END + 1)

//
// Define masks for fields within the PTE.
//

#define MM_PTE_VALID_MASK         0x1
#if defined(NT_UP)
#define MM_PTE_WRITE_MASK         0x2
#else
#define MM_PTE_WRITE_MASK         0x800
#endif
#define MM_PTE_OWNER_MASK         0x4
#define MM_PTE_WRITE_THROUGH_MASK 0x8
#define MM_PTE_CACHE_DISABLE_MASK 0x10
#define MM_PTE_ACCESS_MASK        0x20
#if defined(NT_UP)
#define MM_PTE_DIRTY_MASK         0x40
#else
#define MM_PTE_DIRTY_MASK         0x42
#endif
#define MM_PTE_LARGE_PAGE_MASK    0x80
#define MM_PTE_GLOBAL_MASK        0x100
#define MM_PTE_COPY_ON_WRITE_MASK 0x200
#define MM_PTE_PROTOTYPE_MASK     0x400
#define MM_PTE_TRANSITION_MASK    0x800

//
// Bit fields to or into PTE to make a PTE valid based on the
// protection field of the invalid PTE.
//

#define MM_PTE_NOACCESS          0x0   // not expressible on AMD64
#define MM_PTE_READONLY          0x0
#define MM_PTE_READWRITE         MM_PTE_WRITE_MASK
#define MM_PTE_WRITECOPY         0x200 // read-only copy on write bit set.
#define MM_PTE_EXECUTE           0x0   // read-only on AMD64
#define MM_PTE_EXECUTE_READ      0x0
#define MM_PTE_EXECUTE_READWRITE MM_PTE_WRITE_MASK
#define MM_PTE_EXECUTE_WRITECOPY 0x200 // read-only copy on write bit set.
#define MM_PTE_NOCACHE           0x010
#define MM_PTE_WRITECOMBINE      0x010 // overridden in MmEnablePAT
#define MM_PTE_GUARD             0x0  // not expressible on AMD64
#define MM_PTE_CACHE             0x0

#define MM_PROTECT_FIELD_SHIFT 5

//
// Bits available for the software working set index within the hardware PTE.
//

#define MI_MAXIMUM_PTE_WORKING_SET_INDEX (1 << _HARDWARE_PTE_WORKING_SET_BITS)

//
// Zero PTE
//

#define MM_ZERO_PTE 0

//
// Zero Kernel PTE
//

#define MM_ZERO_KERNEL_PTE 0

//
// A demand zero PTE with a protection or PAGE_READWRITE.
//

#define MM_DEMAND_ZERO_WRITE_PTE (MM_READWRITE << MM_PROTECT_FIELD_SHIFT)


//
// A demand zero PTE with a protection or PAGE_READWRITE for system space.
//

#define MM_KERNEL_DEMAND_ZERO_PTE (MM_READWRITE << MM_PROTECT_FIELD_SHIFT)

//
// A no access PTE for system space.
//

#define MM_KERNEL_NOACCESS_PTE (MM_NOACCESS << MM_PROTECT_FIELD_SHIFT)

//
// Kernel stack alignment requirements.
//

#define MM_STACK_ALIGNMENT 0x0

#define MM_STACK_OFFSET 0x0

//
// System process definitions
//

#define PXE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PTE_PER_PAGE 512
#define PTE_PER_PAGE_BITS 10    // This handles the case where the page is full

#if PTE_PER_PAGE_BITS > 32
error - too many bits to fit into MMPTE_SOFTWARE or MMPFN.u1
#endif

//
// Number of page table pages for user addresses.
//

#define MM_USER_PXES (0x10)

#define MM_USER_PAGE_TABLE_PAGES ((ULONG_PTR)PDE_PER_PAGE * PPE_PER_PAGE * MM_USER_PXES)

#define MM_USER_PAGE_DIRECTORY_PAGES (PPE_PER_PAGE * MM_USER_PXES)

#define MM_USER_PAGE_DIRECTORY_PARENT_PAGES (MM_USER_PXES)

//++
// VOID
// MI_MAKE_VALID_USER_PTE (
//    OUT OUTPTE,
//    IN FRAME,
//    IN PMASK,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro makes a valid *USER* PTE from a page frame number,
//    protection mask, and owner.
//
//    THIS MUST ONLY BE USED FOR PAGE TABLE ENTRIES (NOT PAGE DIRECTORY
//    ENTRIES), MAPPING USER (NOT KERNEL OR SESSION) VIRTUAL ADDRESSES.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    FRAME - Supplies the page frame number for the PTE.
//
//    PMASK - Supplies the protection to set in the valid PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_VALID_USER_PTE(OUTPTE, FRAME, PMASK, PPTE) {         \
    (OUTPTE).u.Long = MmProtectToPteMask[PMASK] | MM_PTE_VALID_MASK; \
    (OUTPTE).u.Long |= ((FRAME) << PAGE_SHIFT);                      \
    (OUTPTE).u.Hard.Accessed = 1;                                   \
    ASSERT (((PPTE) < (PMMPTE)PDE_BASE) || ((PPTE) > (PMMPTE)PDE_TOP)); \
    (OUTPTE).u.Long |= MM_PTE_OWNER_MASK;                           \
    ASSERT ((OUTPTE).u.Hard.Global == 0);                           \
}

//++
// VOID
// MI_MAKE_VALID_KERNEL_PTE (
//    OUT OUTPTE,
//    IN FRAME,
//    IN PMASK,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro makes a valid *KERNEL* PTE from a page frame number,
//    protection mask, and owner.
//
//    THIS MUST ONLY BE USED FOR PAGE TABLE ENTRIES (NOT PAGE DIRECTORY
//    ENTRIES), MAPPING GLOBAL (NOT SESSION) VIRTUAL ADDRESSES.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    FRAME - Supplies the page frame number for the PTE.
//
//    PMASK - Supplies the protection to set in the valid PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_VALID_KERNEL_PTE(OUTPTE, FRAME, PMASK, PPTE) {       \
    ASSERT (((PPTE) < (PMMPTE)PDE_BASE) || ((PPTE) > (PMMPTE)PDE_TOP)); \
    (OUTPTE).u.Long = MmProtectToPteMask[PMASK] | MM_PTE_VALID_MASK; \
    (OUTPTE).u.Long |= ((FRAME) << PAGE_SHIFT);                      \
    (OUTPTE).u.Hard.Accessed = 1;                                   \
    (OUTPTE).u.Hard.Global = 1;                                     \
}

//++
// VOID
// MI_MAKE_VALID_PTE (
//    OUT OUTPTE,
//    IN FRAME,
//    IN PMASK,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro makes a valid PTE from a page frame number, protection mask,
//    and owner.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the transition PTE.
//
//    FRAME - Supplies the page frame number for the PTE.
//
//    PMASK - Supplies the protection to set in the transition PTE.
//
//    PPTE - Supplies a pointer to the PTE which is being made valid.
//           For prototype PTEs NULL should be specified.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_VALID_PTE(OUTPTE, FRAME, PMASK, PPTE) {             \
    (OUTPTE).u.Long = MmProtectToPteMask[PMASK] | MM_PTE_VALID_MASK;\
    (OUTPTE).u.Long |= ((FRAME) << PAGE_SHIFT);                     \
    (OUTPTE).u.Hard.Accessed = 1;                                   \
    if (((PPTE) >= (PMMPTE)PDE_BASE) && ((PPTE) <= (PMMPTE)PDE_TOP)) { \
        (OUTPTE).u.Hard.NoExecute = 0;                              \
    }                                                               \
    if (MI_DETERMINE_OWNER(PPTE)) {                                 \
        (OUTPTE).u.Long |= MM_PTE_OWNER_MASK;                       \
    }                                                               \
    if ((((PMMPTE)PPTE) >= MiGetPteAddress(MM_KSEG0_BASE)) &&       \
         ((((PMMPTE)PPTE) >= MiGetPteAddress(MM_SYSTEM_SPACE_START)) || \
         (((PMMPTE)PPTE) < MiGetPteAddress(MM_KSEG2_BASE)))) {      \
        (OUTPTE).u.Hard.Global = 1;                                 \
    }                                                               \
}

//++
// VOID
// MI_MAKE_VALID_PTE_TRANSITION (
//    IN OUT OUTPTE
//    IN PROTECT
//    );
//
// Routine Description:
//
//    This macro takes a valid pte and turns it into a transition PTE.
//
// Arguments
//
//    OUTPTE - Supplies the current valid PTE.  This PTE is then
//             modified to become a transition PTE.
//
//    PROTECT - Supplies the protection to set in the transition PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_VALID_PTE_TRANSITION(OUTPTE,PROTECT) \
                (OUTPTE).u.Soft.Transition = 1;           \
                (OUTPTE).u.Soft.Valid = 0;                \
                (OUTPTE).u.Soft.Prototype = 0;            \
                (OUTPTE).u.Soft.Protection = PROTECT;

//++
// VOID
// MI_MAKE_TRANSITION_PTE (
//    OUT OUTPTE,
//    IN PAGE,
//    IN PROTECT,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro takes a valid pte and turns it into a transition PTE.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the transition PTE.
//
//    PAGE - Supplies the page frame number for the PTE.
//
//    PROTECT - Supplies the protection to set in the transition PTE.
//
//    PPTE - Supplies a pointer to the PTE, this is used to determine
//           the owner of the PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_TRANSITION_PTE(OUTPTE,PAGE,PROTECT,PPTE)   \
                (OUTPTE).u.Long = 0;                       \
                (OUTPTE).u.Trans.PageFrameNumber = PAGE;   \
                (OUTPTE).u.Trans.Transition = 1;           \
                (OUTPTE).u.Trans.Protection = PROTECT;     \
                (OUTPTE).u.Trans.Owner = MI_DETERMINE_OWNER(PPTE);


//++
// VOID
// MI_MAKE_TRANSITION_PTE_VALID (
//    OUT OUTPTE,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro takes a transition pte and makes it a valid PTE.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    PPTE - Supplies a pointer to the transition PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_TRANSITION_PTE_VALID(OUTPTE,PPTE)                             \
        ASSERT (((PPTE)->u.Hard.Valid == 0) &&                                \
                ((PPTE)->u.Trans.Prototype == 0) &&                           \
                ((PPTE)->u.Trans.Transition == 1));                           \
        (OUTPTE).u.Long = MmProtectToPteMask[(PPTE)->u.Trans.Protection] | MM_PTE_VALID_MASK; \
        if (((PPTE) >= (PMMPTE)PDE_BASE) && ((PPTE) <= (PMMPTE)PDE_TOP)) { \
            (OUTPTE).u.Hard.NoExecute = 0;                              \
        }                                                               \
        (OUTPTE).u.Long |= ((PPTE->u.Hard.PageFrameNumber) << PAGE_SHIFT);    \
        if (MI_DETERMINE_OWNER(PPTE)) {                                 \
            (OUTPTE).u.Long |= MM_PTE_OWNER_MASK;                       \
        }                                                               \
        if ((((PMMPTE)PPTE) >= MiGetPteAddress(MM_KSEG0_BASE)) &&       \
             ((((PMMPTE)PPTE) >= MiGetPteAddress(MM_SYSTEM_SPACE_START)) || \
             (((PMMPTE)PPTE) < MiGetPteAddress(MM_KSEG2_BASE)))) {      \
            (OUTPTE).u.Hard.Global = 1;                                 \
        }                                                               \
        (OUTPTE).u.Hard.Accessed = 1;

//++
// VOID
// MI_MAKE_TRANSITION_KERNELPTE_VALID (
//    OUT OUTPTE,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro takes a transition kernel PTE and makes it a valid PTE.
//
//    THIS MUST ONLY BE USED FOR PAGE TABLE ENTRIES (NOT PAGE DIRECTORY
//    ENTRIES), MAPPING GLOBAL (NOT SESSION) VIRTUAL ADDRESSES.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    PPTE - Supplies a pointer to the transition PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_TRANSITION_KERNELPTE_VALID(OUTPTE,PPTE)                       \
        ASSERT (((PPTE)->u.Hard.Valid == 0) &&                                \
                ((PPTE)->u.Trans.Prototype == 0) &&                           \
                ((PPTE)->u.Trans.Transition == 1));                           \
        (OUTPTE).u.Long = MmProtectToPteMask[(PPTE)->u.Trans.Protection] | MM_PTE_VALID_MASK; \
        ASSERT (((PPTE) < (PMMPTE)PDE_BASE) || ((PPTE) > (PMMPTE)PDE_TOP));   \
        (OUTPTE).u.Long |= ((PPTE->u.Hard.PageFrameNumber) << PAGE_SHIFT);    \
        (OUTPTE).u.Long |= MI_PTE_OWNER_KERNEL;                               \
        ASSERT ((((PMMPTE)PPTE) >= MiGetPteAddress(MM_KSEG0_BASE)) &&         \
             ((((PMMPTE)PPTE) >= MiGetPteAddress(MM_SYSTEM_SPACE_START)) ||   \
             (((PMMPTE)PPTE) < MiGetPteAddress(MM_KSEG2_BASE))));             \
        (OUTPTE).u.Hard.Global = 1;                                           \
        (OUTPTE).u.Hard.Accessed = 1;

//++
// VOID
// MI_MAKE_TRANSITION_PROTOPTE_VALID (
//    OUT OUTPTE,
//    IN PPTE
//    );
//
// Routine Description:
//
//    This macro takes a transition prototype PTE (in paged pool) and
//    makes it a valid PTE.  Because we know this is a prototype PTE and
//    not a pagetable PTE, this can directly or in the global bit.  This
//    makes a measurable performance gain since every instruction counts
//    when holding the PFN lock.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to build the valid PTE.
//
//    PPTE - Supplies a pointer to the transition PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_MAKE_TRANSITION_PROTOPTE_VALID(OUTPTE,PPTE)                        \
        ASSERT (((PPTE)->u.Hard.Valid == 0) &&                                \
                ((PPTE)->u.Trans.Prototype == 0) &&                           \
                ((PPTE)->u.Trans.Transition == 1));                           \
        (OUTPTE).u.Long = MmProtectToPteMask[(PPTE)->u.Trans.Protection] | MM_PTE_VALID_MASK; \
        (OUTPTE).u.Long |= ((PPTE->u.Hard.PageFrameNumber) << PAGE_SHIFT);    \
        (OUTPTE).u.Hard.Global = 1;                                     \
        (OUTPTE).u.Hard.Accessed = 1;

#define MI_FAULT_STATUS_INDICATES_EXECUTION(_FaultStatus)   (_FaultStatus & 0x8)

#define MI_FAULT_STATUS_INDICATES_WRITE(_FaultStatus)   (_FaultStatus & 0x1)

#define MI_CLEAR_FAULT_STATUS(_FaultStatus)             (_FaultStatus = 0)

#define MI_IS_PTE_EXECUTABLE(_TempPte) ((_TempPte)->u.Hard.NoExecute == 0)

//++
// VOID
// MI_SET_PTE_IN_WORKING_SET (
//    OUT PMMPTE PTE,
//    IN ULONG WSINDEX
//    );
//
// Routine Description:
//
//    This macro inserts the specified working set index into the argument PTE.
//
//    No TB invalidation is needed for other processors (or this one) even
//    though the entry may already be in a TB - it's just a software field
//    update and doesn't affect miss resolution.
//
// Arguments
//
//    PTE - Supplies the PTE in which to insert the working set index.
//
//    WSINDEX - Supplies the working set index for the PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_PTE_IN_WORKING_SET(PTE, WSINDEX) {             \
    MMPTE _TempPte;                                           \
    _TempPte = *(PTE);                                        \
    _TempPte.u.Hard.SoftwareWsIndex = (WSINDEX);              \
    ASSERT (_TempPte.u.Long != 0);                            \
    *(PTE) = _TempPte;                                        \
}

//++
// ULONG WsIndex
// MI_GET_WORKING_SET_FROM_PTE(
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    This macro returns the working set index from the argument PTE.
//    Since the AMD64 PTE has no free bits nothing needs to be done on this
//    architecture.
//
// Arguments
//
//    PTE - Supplies the PTE to extract the working set index from.
//
// Return Value:
//
//    This macro returns the working set index for the argument PTE.
//
//--

#define MI_GET_WORKING_SET_FROM_PTE(PTE)  (ULONG)(PTE)->u.Hard.SoftwareWsIndex

//++
// VOID
// MI_SET_PTE_WRITE_COMBINE (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and enables WriteCombining as the
//    caching state.  Note that the PTE bits may only be set this way
//    if the Page Attribute Table is present and the PAT has been
//    initialized to provide Write Combining.
//
//    If either of the above conditions is not satisfied, then
//    the macro enables WEAK UC (PCD = 1, PWT = 0) in the PTE.
//
// Arguments
//
//    PTE - Supplies a valid PTE.
//
// Return Value:
//
//     None.
//
//--
//

#define MI_SET_PTE_WRITE_COMBINE(PTE) \
            {                                                               \
                if (MiWriteCombiningPtes == TRUE) {                         \
                    ((PTE).u.Hard.CacheDisable = 0);                        \
                    ((PTE).u.Hard.WriteThrough = 1);                        \
                } else {                                                    \
                    ((PTE).u.Hard.CacheDisable = 1);                        \
                    ((PTE).u.Hard.WriteThrough = 0);                        \
                }                                                           \
            }

#define MI_SET_LARGE_PTE_WRITE_COMBINE(PTE) MI_SET_PTE_WRITE_COMBINE(PTE)

//++
// VOID
// MI_PREPARE_FOR_NONCACHED (
//    IN MI_PFN_CACHE_ATTRIBUTE CacheAttribute
//    );
//
// Routine Description:
//
//    This macro prepares the system prior to noncached PTEs being created.
//
// Arguments
//
//    CacheAttribute - Supplies the cache attribute the PTEs will be filled
//                     with.
//
// Return Value:
//
//     None.
//
//--
#define MI_PREPARE_FOR_NONCACHED(_CacheAttribute)                           \
        if (_CacheAttribute != MiCached) {                                  \
            MI_FLUSH_ENTIRE_TB (0x20);                                      \
            KeInvalidateAllCaches ();                                       \
        }

//++
// VOID
// MI_FLUSH_TB_FOR_INDIVIDUAL_ATTRIBUTE_CHANGE (
//    IN PFN_NUMBER PageFrameIndex,
//    IN MI_PFN_CACHE_ATTRIBUTE CacheAttribute
//    );
//
// Routine Description:
//
//    The entire TB must be flushed if we are changing cache attributes.
//
//    KeFlushSingleTb cannot be used because we don't know
//    what virtual address(es) this physical frame was last mapped at.
//
//    Additionally, the cache must be flushed if we are switching from
//    write back to write combined (or noncached) because otherwise the
//    current data may live in the cache while the uc/wc mapping is used
//    and then when the uc/wc mapping is freed, the cache will hold stale
//    data that will be found when a normal write back mapping is reapplied.
//
// Arguments
//
//    PageFrameIndex - Supplies the page frame number that is going to be
//                     used with the new attribute.
//
//    CacheAttribute - Supplies the cache attribute the new PTEs will be filled
//                     with.
//
// Return Value:
//
//     None.
//
//--

#define MI_FLUSH_TB_FOR_INDIVIDUAL_ATTRIBUTE_CHANGE(_PageFrameIndex,_CacheAttribute)          \
            MiFlushTbForAttributeChange += 1;                      \
            MI_FLUSH_ENTIRE_TB (0x21);                             \
            if (_CacheAttribute != MiCached) {                     \
                MiFlushCacheForAttributeChange += 1;               \
                KeInvalidateAllCaches ();                          \
            }

//++
// VOID
// MI_FLUSH_ENTIRE_TB_FOR_ATTRIBUTE_CHANGE (
//    IN MI_PFN_CACHE_ATTRIBUTE CacheAttribute
//    );
//
// Routine Description:
//
//    The entire TB must be flushed if we are changing cache attributes.
//
//    KeFlushSingleTb cannot be used because we don't know
//    what virtual address(es) this physical frame was last mapped at.
//
//    Additionally, the cache must be flushed if we are switching from
//    write back to write combined (or noncached) because otherwise the
//    current data may live in the cache while the uc/wc mapping is used
//    and then when the uc/wc mapping is freed, the cache will hold stale
//    data that will be found when a normal write back mapping is reapplied.
//
// Arguments
//
//    CacheAttribute - Supplies the cache attribute the new PTEs will be filled
//                     with.
//
// Return Value:
//
//     None.
//
//--

#define MI_FLUSH_ENTIRE_TB_FOR_ATTRIBUTE_CHANGE(_CacheAttribute)   \
            MiFlushTbForAttributeChange += 1;                      \
            MI_FLUSH_ENTIRE_TB (0x22);                             \
            if (_CacheAttribute != MiCached) {                     \
                MiFlushCacheForAttributeChange += 1;               \
                KeInvalidateAllCaches ();                          \
            }

//++
// VOID
// MI_FLUSH_TB_FOR_CACHED_ATTRIBUTE (
//    VOID
//    );
//
// Routine Description:
//
//    The entire TB must be flushed if we are changing cache attributes.
//
//    KeFlushSingleTb cannot be used because we don't know
//    what virtual address(es) a physical frame was last mapped at.
//
//    Note no cache flush is needed because the attribute-changing-pages
//    are going to be mapped fully cached.
//
// Arguments
//
//    None.
//
// Return Value:
//
//     None.
//
//--

#define MI_FLUSH_TB_FOR_CACHED_ATTRIBUTE()                         \
            MiFlushTbForAttributeChange += 1;                      \
            MI_FLUSH_ENTIRE_TB (0x23);

//++
// VOID
// MI_SET_PTE_DIRTY (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro sets the dirty bit(s) in the specified PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to set dirty.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_PTE_DIRTY(PTE) (PTE).u.Long |= HARDWARE_PTE_DIRTY_MASK


//++
// VOID
// MI_SET_PTE_CLEAN (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro clears the dirty bit(s) in the specified PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to set clear.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_PTE_CLEAN(PTE) (PTE).u.Long &= ~HARDWARE_PTE_DIRTY_MASK



//++
// VOID
// MI_IS_PTE_DIRTY (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro checks the dirty bit(s) in the specified PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to check.
//
// Return Value:
//
//    TRUE if the page is dirty (modified), FALSE otherwise.
//
//--

#define MI_IS_PTE_DIRTY(PTE) ((PTE).u.Hard.Dirty != 0)


//++
// VOID
// MI_SET_GLOBAL_STATE (
//    IN MMPTE PTE,
//    IN ULONG STATE
//    );
//
// Routine Description:
//
//    This macro sets the global bit in the PTE. if the pointer PTE is within
//
// Arguments
//
//    PTE - Supplies the PTE to set global state into.
//
//    STATE - Supplies 1 if global, 0 if not.
//
// Return Value:
//
//     None.
//
//--

#define MI_SET_GLOBAL_STATE(PTE, STATE) (PTE).u.Hard.Global = STATE;


//++
// VOID
// MI_ENABLE_CACHING (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and sets the caching state to be
//    enabled.  This is performed by clearing the PCD and PWT bits in the PTE.
//
//    Semantics of the overlap between PCD, PWT, and the
//    USWC memory type in the MTRR are:
//
//    PCD   PWT   Mtrr Mem Type      Effective Memory Type
//     1     0    USWC               USWC
//     1     1    USWC               UC
//
// Arguments
//
//    PTE - Supplies a valid PTE.
//
// Return Value:
//
//     None.
//
//--

#define MI_ENABLE_CACHING(PTE) \
            {                                                                \
                ((PTE).u.Hard.CacheDisable = 0);                             \
                ((PTE).u.Hard.WriteThrough = 0);                             \
            }



//++
// VOID
// MI_DISABLE_CACHING (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and sets the caching state to be
//    disabled.  This is performed by setting the PCD and PWT bits in the PTE.
//
//    Semantics of the overlap between PCD, PWT, and the
//    USWC memory type in the MTRR are:
//
//    PCD   PWT   Mtrr Mem Type      Effective Memory Type
//     1     0    USWC               USWC
//     1     1    USWC               UC
//
//    Since an effective memory type of UC is desired here,
//    the WT bit is set.
//
// Arguments
//
//    PTE - Supplies a pointer to the valid PTE.
//
// Return Value:
//
//     None.
//
//--


#define MI_DISABLE_CACHING(PTE) \
            {                                                                \
                ((PTE).u.Hard.CacheDisable = 1);                             \
                ((PTE).u.Hard.WriteThrough = 1);                             \
            }


#define MI_DISABLE_LARGE_PTE_CACHING(PTE) MI_DISABLE_CACHING(PTE)


//++
// BOOLEAN
// MI_IS_CACHING_DISABLED (
//    IN PMMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and returns TRUE if caching is
//    disabled.
//
// Arguments
//
//    PPTE - Supplies a pointer to the valid PTE.
//
// Return Value:
//
//     TRUE if caching is disabled, FALSE if it is enabled.
//
//--

#define MI_IS_CACHING_DISABLED(PPTE)   \
            ((PPTE)->u.Hard.CacheDisable == 1)


//++
// VOID
// MI_SET_PFN_DELETED (
//    IN PMMPFN PPFN
//    );
//
// Routine Description:
//
//    This macro takes a pointer to a PFN element and indicates that
//    the PFN is no longer in use.
//
// Arguments
//
//    PPTE - Supplies a pointer to the PFN element.
//
// Return Value:
//
//    none.
//
//--

#define MI_SET_PFN_DELETED(PPFN) \
    (PPFN)->PteAddress = (PMMPTE)((ULONG_PTR)PPFN->PteAddress | 0x1);


//++
// VOID
// MI_MARK_PFN_UNDELETED (
//    IN PMMPFN PPFN
//    );
//
// Routine Description:
//
//    This macro takes a pointer to a deleted PFN element and mark that
//    the PFN is not deleted.
//
// Arguments
//
//    PPTE - Supplies a pointer to the PFN element.
//
// Return Value:
//
//    none.
//
//--

#define MI_MARK_PFN_UNDELETED(PPFN) \
    PPFN->PteAddress = (PMMPTE)((ULONG_PTR)PPFN->PteAddress & ~0x1);



//++
// BOOLEAN
// MI_IS_PFN_DELETED (
//    IN PMMPFN PPFN
//    );
//
// Routine Description:
//
//    This macro takes a pointer to a PFN element and determines if
//    the PFN is no longer in use.
//
// Arguments
//
//    PPTE - Supplies a pointer to the PFN element.
//
// Return Value:
//
//     TRUE if PFN is no longer used, FALSE if it is still being used.
//
//--

#define MI_IS_PFN_DELETED(PPFN)   \
            ((ULONG_PTR)(PPFN)->PteAddress & 0x1)


//++
// VOID
// MI_CHECK_PAGE_ALIGNMENT (
//    IN ULONG PAGE,
//    IN PMMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro takes a PFN element number (Page) and checks to see
//    if the virtual alignment for the previous address of the page
//    is compatible with the new address of the page.  If they are
//    not compatible, the D cache is flushed.
//
// Arguments
//
//    PAGE - Supplies the PFN element.
//    PPTE - Supplies a pointer to the new PTE which will contain the page.
//
// Return Value:
//
//    none.
//
//--

// does nothing on AMD64.

#define MI_CHECK_PAGE_ALIGNMENT(PAGE,PPTE)




//++
// VOID
// MI_INITIALIZE_HYPERSPACE_MAP (
//    VOID
//    );
//
// Routine Description:
//
//    This macro initializes the PTEs reserved for double mapping within
//    hyperspace.
//
// Arguments
//
//    None.
//
// Return Value:
//
//    None.
//
//--

// does nothing on AMD64.

#define MI_INITIALIZE_HYPERSPACE_MAP(INDEX)


//++
// ULONG
// MI_GET_NEXT_COLOR (
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This macro returns the next color in the sequence.
//
// Arguments
//
//    COLOR - Supplies the color to return the next of.
//
// Return Value:
//
//    Next color in sequence.
//
//--

#define MI_GET_NEXT_COLOR(COLOR)  ((COLOR + 1) & MM_COLOR_MASK)


//++
// ULONG
// MI_GET_PREVIOUS_COLOR (
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This macro returns the previous color in the sequence.
//
// Arguments
//
//    COLOR - Supplies the color to return the previous of.
//
// Return Value:
//
//    Previous color in sequence.
//
//--

#define MI_GET_PREVIOUS_COLOR(COLOR) (0)

#define MI_GET_SECONDARY_COLOR(PAGE,PFN) ((ULONG)(PAGE & MmSecondaryColorMask))

#define MI_GET_COLOR_FROM_SECONDARY(SECONDARY_COLOR) (0)


//++
// VOID
// MI_GET_MODIFIED_PAGE_BY_COLOR (
//    OUT ULONG PAGE,
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This macro returns the first page destined for a paging
//    file with the desired color.  It does NOT remove the page
//    from its list.
//
// Arguments
//
//    PAGE - Returns the page located, the value MM_EMPTY_LIST is
//           returned if there is no page of the specified color.
//
//    COLOR - Supplies the color of page to locate.
//
// Return Value:
//
//    none.
//
//--

#define MI_GET_MODIFIED_PAGE_BY_COLOR(PAGE,COLOR) \
            PAGE = MmModifiedPageListByColor[COLOR].Flink


//++
// VOID
// MI_GET_MODIFIED_PAGE_ANY_COLOR (
//    OUT ULONG PAGE,
//    IN OUT ULONG COLOR
//    );
//
// Routine Description:
//
//    This macro returns the first page destined for a paging
//    file with the desired color.  If not page of the desired
//    color exists, all colored lists are searched for a page.
//    It does NOT remove the page from its list.
//
// Arguments
//
//    PAGE - Returns the page located, the value MM_EMPTY_LIST is
//           returned if there is no page of the specified color.
//
//    COLOR - Supplies the color of page to locate and returns the
//            color of the page located.
//
// Return Value:
//
//    none.
//
//--

#define MI_GET_MODIFIED_PAGE_ANY_COLOR(PAGE,COLOR) \
            {                                                                \
                if (MmTotalPagesForPagingFile == 0) {                        \
                    PAGE = MM_EMPTY_LIST;                                    \
                } else {                                                     \
                    PAGE = MmModifiedPageListByColor[COLOR].Flink;           \
                }                                                            \
            }



//++
// VOID
// MI_MAKE_VALID_PTE_WRITE_COPY (
//    IN OUT PMMPTE PTE
//    );
//
// Routine Description:
//
//    This macro checks to see if the PTE indicates that the
//    page is writable and if so it clears the write bit and
//    sets the copy-on-write bit.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     None.
//
//--

#if defined(NT_UP)
#define MI_MAKE_VALID_PTE_WRITE_COPY(PPTE) \
                    if ((PPTE)->u.Hard.Write == 1) {    \
                        (PPTE)->u.Hard.CopyOnWrite = 1; \
                        (PPTE)->u.Hard.Write = 0;       \
                    }
#else
#define MI_MAKE_VALID_PTE_WRITE_COPY(PPTE) \
                    if ((PPTE)->u.Hard.Write == 1) {    \
                        (PPTE)->u.Hard.CopyOnWrite = 1; \
                        (PPTE)->u.Hard.Write = 0;       \
                        (PPTE)->u.Hard.Writable = 0;    \
                    }
#endif


#define MI_PTE_OWNER_USER       1

#define MI_PTE_OWNER_KERNEL     0


//++
// ULONG
// MI_DETERMINE_OWNER (
//    IN MMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro examines the virtual address of the PTE and determines
//    if the PTE resides in system space or user space.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     1 if the owner is USER_MODE, 0 if the owner is KERNEL_MODE.
//
//--

#define MI_DETERMINE_OWNER(PPTE)   \
    ((((PPTE) <= MiHighestUserPte) ||                                       \
      ((PPTE) >= MiGetPdeAddress(NULL) && ((PPTE) <= MiHighestUserPde)) ||  \
      ((PPTE) >= MiGetPpeAddress(NULL) && ((PPTE) <= MiHighestUserPpe)) ||  \
      ((PPTE) >= MiGetPxeAddress(NULL) && ((PPTE) <= MiHighestUserPxe)))    \
      ? MI_PTE_OWNER_USER : MI_PTE_OWNER_KERNEL)



//++
// VOID
// MI_SET_ACCESSED_IN_PTE (
//    IN OUT MMPTE PPTE,
//    IN ULONG ACCESSED
//    );
//
// Routine Description:
//
//    This macro sets the ACCESSED field in the PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     None
//
//--

#define MI_SET_ACCESSED_IN_PTE(PPTE,ACCESSED) \
                    ((PPTE)->u.Hard.Accessed = ACCESSED)

//++
// ULONG
// MI_GET_ACCESSED_IN_PTE (
//    IN OUT MMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro returns the state of the ACCESSED field in the PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//     The state of the ACCESSED field.
//
//--

#define MI_GET_ACCESSED_IN_PTE(PPTE) ((PPTE)->u.Hard.Accessed)


//++
// VOID
// MI_SET_OWNER_IN_PTE (
//    IN PMMPTE PPTE
//    IN ULONG OWNER
//    );
//
// Routine Description:
//
//    This macro sets the owner field in the PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    None.
//
//--

#define MI_SET_OWNER_IN_PTE(PPTE,OWNER) ((PPTE)->u.Hard.Owner = OWNER)


//
// Mask to clear all fields but protection in a PTE to or in paging file
// location.
//

#define CLEAR_FOR_PAGE_FILE 0x000003E0

//++
// VOID
// MI_SET_PAGING_FILE_INFO (
//    OUT MMPTE OUTPTE,
//    IN MMPTE PPTE,
//    IN ULONG FILEINFO,
//    IN ULONG OFFSET
//    );
//
// Routine Description:
//
//    This macro sets into the specified PTE the supplied information
//    to indicate where the backing store for the page is located.
//
// Arguments
//
//    OUTPTE - Supplies the PTE in which to store the result.
//
//    PTE - Supplies the PTE to operate upon.
//
//    FILEINFO - Supplies the number of the paging file.
//
//    OFFSET - Supplies the offset into the paging file.
//
// Return Value:
//
//    None.
//
//--

#define MI_SET_PAGING_FILE_INFO(OUTPTE,PPTE,FILEINFO,OFFSET)            \
       (OUTPTE).u.Long = (PPTE).u.Long;                             \
       (OUTPTE).u.Long &= CLEAR_FOR_PAGE_FILE;                       \
       (OUTPTE).u.Long |= (FILEINFO << 1);                           \
       (OUTPTE).u.Soft.PageFileHigh = (OFFSET);


//++
// PMMPTE
// MiPteToProto (
//    IN OUT MMPTE PPTE,
//    IN ULONG FILEINFO,
//    IN ULONG OFFSET
//    );
//
// Routine Description:
//
//   This macro returns the address of the corresponding prototype which
//   was encoded earlier into the supplied PTE.
//
// Arguments
//
//    lpte - Supplies the PTE to operate upon.
//
// Return Value:
//
//    Pointer to the prototype PTE that backs this PTE.
//
//--

#define MiPteToProto(lpte) \
            ((PMMPTE)((lpte)->u.Proto.ProtoAddress))


//++
// ULONG
// MiProtoAddressForPte (
//    IN PMMPTE proto_va
//    );
//
// Routine Description:
//
//    This macro sets into the specified PTE the supplied information
//    to indicate where the backing store for the page is located.
//    MiProtoAddressForPte returns the bit field to OR into the PTE to
//    reference a prototype PTE.  And set the protoPTE bit,
//    MM_PTE_PROTOTYPE_MASK.
//
// Arguments
//
//    proto_va - Supplies the address of the prototype PTE.
//
// Return Value:
//
//    Mask to set into the PTE.
//
//--

#define MiProtoAddressForPte(proto_va)  \
    (((ULONG_PTR)proto_va << 16) | MM_PTE_PROTOTYPE_MASK)



//++
// ULONG
// MiProtoAddressForKernelPte (
//    IN PMMPTE proto_va
//    );
//
// Routine Description:
//
//    This macro sets into the specified PTE the supplied information
//    to indicate where the backing store for the page is located.
//    MiProtoAddressForPte returns the bit field to OR into the PTE to
//    reference a prototype PTE.  And set the protoPTE bit,
//    MM_PTE_PROTOTYPE_MASK.
//
//    This macro also sets any other information (such as global bits)
//    required for kernel mode PTEs.
//
// Arguments
//
//    proto_va - Supplies the address of the prototype PTE.
//
// Return Value:
//
//    Mask to set into the PTE.
//
//--

//  not different on AMD64.

#define MiProtoAddressForKernelPte(proto_va)  MiProtoAddressForPte(proto_va)

//++
// PSUBSECTION
// MiGetSubsectionAddress (
//    IN PMMPTE lpte
//    );
//
// Routine Description:
//
//   This macro takes a PTE and returns the address of the subsection that
//   the PTE refers to.  Subsections are quadword structures allocated
//   from nonpaged pool.
//
// Arguments
//
//    lpte - Supplies the PTE to operate upon.
//
// Return Value:
//
//    A pointer to the subsection referred to by the supplied PTE.
//
//--

#define MiGetSubsectionAddress(lpte)                              \
    ((PSUBSECTION)((lpte)->u.Subsect.SubsectionAddress))


//++
// ULONG
// MiGetSubsectionAddressForPte (
//    IN PSUBSECTION VA
//    );
//
// Routine Description:
//
//    This macro takes the address of a subsection and encodes it for use
//    in a PTE.
//
// Arguments
//
//    VA - Supplies a pointer to the subsection to encode.
//
// Return Value:
//
//     The mask to set into the PTE to make it reference the supplied
//     subsection.
//
//--

#define MiGetSubsectionAddressForPte(VA) ((ULONGLONG)VA << 16)

//++
// PMMPTE
// MiGetPxeAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPxeAddress returns the address of the extended page directory parent
//    entry which maps the given virtual address.  This is one level above the
//    page parent directory.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PXE for.
//
// Return Value:
//
//    The address of the PXE.
//
//--

#define MiGetPxeAddress(va)   ((PMMPTE)PXE_BASE + MiGetPxeOffset(va))

//++
// PMMPTE
// MiGetPpeAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPpeAddress returns the address of the page directory parent entry
//    which maps the given virtual address.  This is one level above the
//    page directory.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PPE for.
//
// Return Value:
//
//    The address of the PPE.
//
//--

#define MiGetPpeAddress(va)   \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PPI_SHIFT) << PTE_SHIFT) + PPE_BASE))

//++
// PMMPTE
// MiGetPdeAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeAddress returns the address of the PDE which maps the
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PDE for.
//
// Return Value:
//
//    The address of the PDE.
//
//--

#define MiGetPdeAddress(va)  \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PDI_SHIFT) << PTE_SHIFT) + PDE_BASE))


//++
// PMMPTE
// MiGetPteAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPteAddress returns the address of the PTE which maps the
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PTE for.
//
// Return Value:
//
//    The address of the PTE.
//
//--

#define MiGetPteAddress(va) \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PTI_SHIFT) << PTE_SHIFT) + PTE_BASE))


//++
// ULONG
// MiGetPxeOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPxeOffset returns the offset into an extended page directory parent
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the extended parent page directory table the corresponding
//    PXE is at.
//
//--

#define MiGetPxeOffset(va) ((ULONG)(((ULONG_PTR)(va) >> PXI_SHIFT) & PXI_MASK))

//++
// ULONG
// MiGetPxeIndex (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPxeIndex returns the extended page directory parent index
//    for a given virtual address.
//
//    N.B. This does not mask off PXE bits.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the index for.
//
// Return Value:
//
//    The index into the extended page directory parent - ie: the virtual page
//    directory parent number.  This is different from the extended page
//    directory parent offset because this spans extended page directory
//    parents on supported platforms.
//
//--

#define MiGetPxeIndex(va) ((ULONG)((ULONG_PTR)(va) >> PXI_SHIFT))

//++
// ULONG
// MiGetPpeOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPpeOffset returns the offset into a page directory parent for a
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the parent page directory table the corresponding
//    PPE is at.
//
//--

#define MiGetPpeOffset(va) ((ULONG)(((ULONG_PTR)(va) >> PPI_SHIFT) & PPI_MASK))

//++
// ULONG
// MiGetPpeIndex (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPpeIndex returns the page directory parent index
//    for a given virtual address.
//
//    N.B. This does not mask off PXE bits.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the index for.
//
// Return Value:
//
//    The index into the page directory parent - ie: the virtual page directory
//    number.  This is different from the page directory parent offset because
//    this spans page directory parents on supported platforms.
//
//--

#define MiGetPpeIndex(va) ((ULONG)((ULONG_PTR)(va) >> PPI_SHIFT))

//++
// ULONG
// MiGetPdeOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeOffset returns the offset into a page directory
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page directory table the corresponding PDE is at.
//
//--

#define MiGetPdeOffset(va) ((ULONG)(((ULONG_PTR)(va) >> PDI_SHIFT) & (PDE_PER_PAGE - 1)))

//++
// ULONG
// MiGetPdeIndex (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeIndex returns the page directory index
//    for a given virtual address.
//
//    N.B. This does not mask off PPE or PXE bits.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the index for.
//
// Return Value:
//
//    The index into the page directory - ie: the virtual page table number.
//    This is different from the page directory offset because this spans
//    page directories on supported platforms.
//
//--

#define MiGetPdeIndex(va) ((ULONG)((ULONG_PTR)(va) >> PDI_SHIFT))

//++
// ULONG
// MiGetPteOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPteOffset returns the offset into a page table page
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page table page table the corresponding PTE is at.
//
//--

#define MiGetPteOffset(va) ((ULONG)(((ULONG_PTR)(va) >> PTI_SHIFT) & (PTE_PER_PAGE - 1)))

//++
// PVOID
// MiGetVirtualAddressMappedByPxe (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPxe returns the virtual address
//    which is mapped by a given PXE address.
//
// Arguments
//
//    PXE - Supplies the PXE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PXE.
//
//--

#define MiGetVirtualAddressMappedByPxe(PXE) \
    MiGetVirtualAddressMappedByPde(MiGetVirtualAddressMappedByPde(PXE))

//++
// PVOID
// MiGetVirtualAddressMappedByPpe (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPpe returns the virtual address
//    which is mapped by a given PPE address.
//
// Arguments
//
//    PPE - Supplies the PPE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PPE.
//
//--

#define MiGetVirtualAddressMappedByPpe(PPE) \
    MiGetVirtualAddressMappedByPte(MiGetVirtualAddressMappedByPde(PPE))

//++
// PVOID
// MiGetVirtualAddressMappedByPde (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPde returns the virtual address
//    which is mapped by a given PDE address.
//
// Arguments
//
//    PDE - Supplies the PDE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PDE.
//
//--

#define MiGetVirtualAddressMappedByPde(PDE) \
    MiGetVirtualAddressMappedByPte(MiGetVirtualAddressMappedByPte(PDE))

//++
// PVOID
// MiGetVirtualAddressMappedByPte (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPte returns the virtual address
//    which is mapped by a given PTE address.
//
// Arguments
//
//    PTE - Supplies the PTE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PTE.
//
//--

#define VA_SHIFT (63 - 47)              // address sign extend shift count

#define MiGetVirtualAddressMappedByPte(PTE) \
    ((PVOID)((LONG_PTR)(((LONG_PTR)(PTE) - PTE_BASE) << (PAGE_SHIFT + VA_SHIFT - PTE_SHIFT)) >> VA_SHIFT))

//++
// LOGICAL
// MiIsVirtualAddressOnPxeBoundary (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    MiIsVirtualAddressOnPxeBoundary returns TRUE if the virtual address is
//    on an extended page directory parent entry boundary.
//
// Arguments
//
//    VA - Supplies the virtual address to check.
//
// Return Value:
//
//    TRUE if on a boundary, FALSE if not.
//
//--

#define MiIsVirtualAddressOnPxeBoundary(VA) (((ULONG_PTR)(VA) & PAGE_DIRECTORY0_MASK) == 0)

//++
// LOGICAL
// MiIsVirtualAddressOnPpeBoundary (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    MiIsVirtualAddressOnPpeBoundary returns TRUE if the virtual address is
//    on a page directory entry boundary.
//
// Arguments
//
//    VA - Supplies the virtual address to check.
//
// Return Value:
//
//    TRUE if on a boundary, FALSE if not.
//
//--

#define MiIsVirtualAddressOnPpeBoundary(VA) (((ULONG_PTR)(VA) & PAGE_DIRECTORY1_MASK) == 0)


//++
// LOGICAL
// MiIsVirtualAddressOnPdeBoundary (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    MiIsVirtualAddressOnPdeBoundary returns TRUE if the virtual address is
//    on a page directory entry boundary.
//
// Arguments
//
//    VA - Supplies the virtual address to check.
//
// Return Value:
//
//    TRUE if on a 2MB PDE boundary, FALSE if not.
//
//--

#define MiIsVirtualAddressOnPdeBoundary(VA) (((ULONG_PTR)(VA) & PAGE_DIRECTORY2_MASK) == 0)


//++
// LOGICAL
// MiIsPteOnPxeBoundary (
//    IN PVOID PTE
//    );
//
// Routine Description:
//
//    MiIsPteOnPxeBoundary returns TRUE if the PTE is
//    on an extended page directory parent entry boundary.
//
// Arguments
//
//    PTE - Supplies the PTE to check.
//
// Return Value:
//
//    TRUE if on a boundary, FALSE if not.
//
//--

#define MiIsPteOnPxeBoundary(PTE) (((ULONG_PTR)(PTE) & (PAGE_DIRECTORY1_MASK)) == 0)

//++
// LOGICAL
// MiIsPteOnPpeBoundary (
//    IN PVOID PTE
//    );
//
// Routine Description:
//
//    MiIsPteOnPpeBoundary returns TRUE if the PTE is
//    on a page directory parent entry boundary.
//
// Arguments
//
//    PTE - Supplies the PTE to check.
//
// Return Value:
//
//    TRUE if on a boundary, FALSE if not.
//
//--

#define MiIsPteOnPpeBoundary(PTE) (((ULONG_PTR)(PTE) & (PAGE_DIRECTORY2_MASK)) == 0)


//++
// LOGICAL
// MiIsPteOnPdeBoundary (
//    IN PVOID PTE
//    );
//
// Routine Description:
//
//    MiIsPteOnPdeBoundary returns TRUE if the PTE is
//    on a page directory entry boundary.
//
// Arguments
//
//    PTE - Supplies the PTE to check.
//
// Return Value:
//
//    TRUE if on a 2MB PDE boundary, FALSE if not.
//
//--

#define MiIsPteOnPdeBoundary(PTE) (((ULONG_PTR)(PTE) & (PAGE_SIZE - 1)) == 0)

//++
//ULONG
//GET_PAGING_FILE_NUMBER (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro extracts the paging file number from a PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    The paging file number.
//
//--

#define GET_PAGING_FILE_NUMBER(PTE) ((ULONG)(((PTE).u.Soft.PageFileLow)))

//++
//ULONG
//GET_PAGING_FILE_OFFSET (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro extracts the offset into the paging file from a PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    The paging file offset.
//
//--

#define GET_PAGING_FILE_OFFSET(PTE) ((ULONG)((PTE).u.Soft.PageFileHigh))


//++
//ULONG
//IS_PTE_NOT_DEMAND_ZERO (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    This macro checks to see if a given PTE is NOT a demand zero PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    Returns 0 if the PTE is demand zero, non-zero otherwise.
//
//--

#define IS_PTE_NOT_DEMAND_ZERO(PTE) \
                 ((PTE).u.Long & ((ULONG_PTR)0xFFFFFFFFFFFFF000 |  \
                                  MM_PTE_VALID_MASK |       \
                                  MM_PTE_PROTOTYPE_MASK |   \
                                  MM_PTE_TRANSITION_MASK))

//++
// VOID
// MI_MAKE_PROTECT_WRITE_COPY (
//    IN OUT MMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro makes a writable PTE a writable-copy PTE.
//
// Arguments
//
//    PTE - Supplies the PTE to operate upon.
//
// Return Value:
//
//    NONE
//
//--

#define MI_MAKE_PROTECT_WRITE_COPY(PTE) \
        if ((PTE).u.Soft.Protection & MM_PROTECTION_WRITE_MASK) {      \
            (PTE).u.Long |= MM_PROTECTION_COPY_MASK << MM_PROTECT_FIELD_SHIFT;      \
        }


//++
// VOID
// MI_SET_PAGE_DIRTY(
//    IN PMMPTE PPTE,
//    IN PVOID VA,
//    IN PVOID PFNHELD
//    );
//
// Routine Description:
//
//    This macro sets the dirty bit (and release page file space).
//
// Arguments
//
//    TEMP - Supplies a temporary for usage.
//
//    PPTE - Supplies a pointer to the PTE that corresponds to VA.
//
//    VA - Supplies a the virtual address of the page fault.
//
//    PFNHELD - Supplies TRUE if the PFN lock is held.
//
// Return Value:
//
//    None.
//
//--

#if defined(NT_UP)
#define MI_SET_PAGE_DIRTY(PPTE,VA,PFNHELD)
#else
#define MI_SET_PAGE_DIRTY(PPTE,VA,PFNHELD)                          \
            if ((PPTE)->u.Hard.Dirty == 1) {                        \
                MiSetDirtyBit ((VA),(PPTE),(PFNHELD));              \
            }
#endif




//++
// VOID
// MI_NO_FAULT_FOUND(
//    IN FAULTSTATUS,
//    IN PMMPTE PPTE,
//    IN PVOID VA,
//    IN PVOID PFNHELD
//    );
//
// Routine Description:
//
//    This macro handles the case when a page fault is taken and no
//    PTE with the valid bit clear is found.
//
// Arguments
//
//    FAULTSTATUS - Supplies the fault status.
//
//    PPTE - Supplies a pointer to the PTE that corresponds to VA.
//
//    VA - Supplies a the virtual address of the page fault.
//
//    PFNHELD - Supplies TRUE if the PFN lock is held.
//
// Return Value:
//
//    None.
//
//--

#if defined(NT_UP)
#define MI_NO_FAULT_FOUND(FAULTSTATUS,PPTE,VA,PFNHELD)
#else
#define MI_NO_FAULT_FOUND(FAULTSTATUS,PPTE,VA,PFNHELD) \
        if ((MI_FAULT_STATUS_INDICATES_WRITE(FAULTSTATUS)) && ((PPTE)->u.Hard.Dirty == 0)) {  \
            MiSetDirtyBit ((VA),(PPTE),(PFNHELD));     \
        }
#endif




//++
// ULONG
// MI_CAPTURE_DIRTY_BIT_TO_PFN (
//    IN PMMPTE PPTE,
//    IN PMMPFN PPFN
//    );
//
// Routine Description:
//
//    This macro gets captures the state of the dirty bit to the PFN
//    and frees any associated page file space if the PTE has been
//    modified element.
//
//    NOTE - THE PFN LOCK MUST BE HELD!
//
// Arguments
//
//    PPTE - Supplies the PTE to operate upon.
//
//    PPFN - Supplies a pointer to the PFN database element that corresponds
//           to the page mapped by the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_CAPTURE_DIRTY_BIT_TO_PFN(PPTE,PPFN)                      \
         ASSERT (KeGetCurrentIrql() > APC_LEVEL);                   \
         if (((PPFN)->u3.e1.Modified == 0) &&                       \
            ((PPTE)->u.Hard.Dirty != 0)) {                          \
             MI_SET_MODIFIED (PPFN, 1, 0x18);                       \
             if (((PPFN)->OriginalPte.u.Soft.Prototype == 0) &&     \
                          ((PPFN)->u3.e1.WriteInProgress == 0)) {   \
                 MiReleasePageFileSpace ((PPFN)->OriginalPte);      \
                 (PPFN)->OriginalPte.u.Soft.PageFileHigh = 0;       \
             }                                                      \
         }


//++
// BOOLEAN
// MI_IS_PHYSICAL_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro determines if a given virtual address is really a
//    physical address.
//
// Arguments
//
//    VA - Supplies the virtual address.
//
// Return Value:
//
//    FALSE if it is not a physical address, TRUE if it is.
//
//--

#define MI_IS_PHYSICAL_ADDRESS(Va) \
    ((MiGetPxeAddress(Va)->u.Hard.Valid == 1) && \
     (MiGetPpeAddress(Va)->u.Hard.Valid == 1) && \
     ((MiGetPdeAddress(Va)->u.Long & 0x81) == 0x81))


//++
// ULONG
// MI_CONVERT_PHYSICAL_TO_PFN (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro converts a physical address (see MI_IS_PHYSICAL_ADDRESS)
//    to its corresponding physical frame number.
//
// Arguments
//
//    VA - Supplies a pointer to the physical address.
//
// Return Value:
//
//    Returns the PFN for the page.
//
//--

#define MI_CONVERT_PHYSICAL_TO_PFN(Va)     \
    ((PFN_NUMBER)(MiGetPdeAddress(Va)->u.Hard.PageFrameNumber) + (MiGetPteOffset((ULONG_PTR)Va)))


typedef struct _MMCOLOR_TABLES {
    PFN_NUMBER Flink;
    PVOID Blink;
    PFN_NUMBER Count;
} MMCOLOR_TABLES, *PMMCOLOR_TABLES;

extern PMMCOLOR_TABLES MmFreePagesByColor[2];

extern PFN_NUMBER MmTotalPagesForPagingFile;


//
// A VALID Page Table Entry on an AMD64 has the following definition.
//

#define MI_MAXIMUM_PAGEFILE_SIZE (((UINT64)4 * 1024 * 1024 * 1024 - 1) * PAGE_SIZE)

#define MI_PTE_LOOKUP_NEEDED ((ULONG64)0xffffffff)

typedef struct _MMPTE_SOFTWARE {
    ULONGLONG Valid : 1;
    ULONGLONG PageFileLow : 4;
    ULONGLONG Protection : 5;
    ULONGLONG Prototype : 1;
    ULONGLONG Transition : 1;
    ULONGLONG UsedPageTableEntries : PTE_PER_PAGE_BITS;
    ULONGLONG Reserved : 20 - PTE_PER_PAGE_BITS;
    ULONGLONG PageFileHigh : 32;
} MMPTE_SOFTWARE;

typedef struct _MMPTE_TRANSITION {
    ULONGLONG Valid : 1;
    ULONGLONG Write : 1;
    ULONGLONG Owner : 1;
    ULONGLONG WriteThrough : 1;
    ULONGLONG CacheDisable : 1;
    ULONGLONG Protection : 5;
    ULONGLONG Prototype : 1;
    ULONGLONG Transition : 1;
    ULONGLONG PageFrameNumber : 28;
    ULONGLONG Unused : 24;
} MMPTE_TRANSITION;

typedef struct _MMPTE_PROTOTYPE {
    ULONGLONG Valid : 1;
    ULONGLONG Unused0: 7;
    ULONGLONG ReadOnly : 1;
    ULONGLONG Unused1: 1;
    ULONGLONG Prototype : 1;
    ULONGLONG Protection : 5;
    LONGLONG ProtoAddress: 48;
} MMPTE_PROTOTYPE;

typedef struct _MMPTE_SUBSECTION {
    ULONGLONG Valid : 1;
    ULONGLONG Unused0 : 4;
    ULONGLONG Protection : 5;
    ULONGLONG Prototype : 1;
    ULONGLONG Unused1 : 5;
    LONGLONG SubsectionAddress : 48;
} MMPTE_SUBSECTION;

typedef struct _MMPTE_LIST {
    ULONGLONG Valid : 1;
    ULONGLONG OneEntry : 1;
    ULONGLONG filler0 : 3;

    //
    // Note the Prototype bit must not be used for lists like freed nonpaged
    // pool because lookaside pops can legitimately reference bogus addresses
    // (since the pop is unsynchronized) and the fault handler must be able to
    // distinguish lists from protos so a retry status can be returned (vs a
    // fatal bugcheck).
    //
    // The same caveat applies to both the Transition and the Protection
    // fields as they are similarly examined in the fault handler and would
    // be misinterpreted if ever nonzero in the freed nonpaged pool chains.
    //

    ULONGLONG Protection : 5;
    ULONGLONG Prototype : 1;        // MUST BE ZERO as per above comment.
    ULONGLONG Transition : 1;

    ULONGLONG filler1 : 20;
    ULONGLONG NextEntry : 32;
} MMPTE_LIST;

typedef struct _MMPTE_HIGHLOW {
    ULONG LowPart;
    ULONG HighPart;
} MMPTE_HIGHLOW;


typedef struct _MMPTE_HARDWARE_LARGEPAGE {
    ULONGLONG Valid : 1;
    ULONGLONG Write : 1;
    ULONGLONG Owner : 1;
    ULONGLONG WriteThrough : 1;
    ULONGLONG CacheDisable : 1;
    ULONGLONG Accessed : 1;
    ULONGLONG Dirty : 1;
    ULONGLONG LargePage : 1;
    ULONGLONG Global : 1;
    ULONGLONG CopyOnWrite : 1; // software field
    ULONGLONG Prototype : 1;   // software field
    ULONGLONG reserved0 : 1;   // software field
    ULONGLONG PAT : 1;
    ULONGLONG reserved1 : 8;   // software field
    ULONGLONG PageFrameNumber : 19;
    ULONGLONG reserved2 : 24;   // software field
} MMPTE_HARDWARE_LARGEPAGE, *PMMPTE_HARDWARE_LARGEPAGE;

//
// A Page Table Entry on AMD64 has the following definition.
// Note the MP version is to avoid stalls when flushing TBs across processors.
//

//
// Uniprocessor version.
//

typedef struct _MMPTE_HARDWARE {
    ULONGLONG Valid : 1;
#if defined(NT_UP)
    ULONGLONG Write : 1;        // UP version
#else
    ULONGLONG Writable : 1;        // changed for MP version
#endif
    ULONGLONG Owner : 1;
    ULONGLONG WriteThrough : 1;
    ULONGLONG CacheDisable : 1;
    ULONGLONG Accessed : 1;
    ULONGLONG Dirty : 1;
    ULONGLONG LargePage : 1;
    ULONGLONG Global : 1;
    ULONGLONG CopyOnWrite : 1; // software field
    ULONGLONG Prototype : 1;   // software field
#if defined(NT_UP)
    ULONGLONG reserved0 : 1;  // software field
#else
    ULONGLONG Write : 1;       // software field - MP change
#endif
    ULONGLONG PageFrameNumber : 28;
    ULONG64 reserved1 : 24 - (_HARDWARE_PTE_WORKING_SET_BITS+1);
    ULONGLONG SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
    ULONG64 NoExecute : 1;
} MMPTE_HARDWARE, *PMMPTE_HARDWARE;

#if defined(NT_UP)
#define HARDWARE_PTE_DIRTY_MASK     0x40
#else
#define HARDWARE_PTE_DIRTY_MASK     0x42
#endif

#define MI_PDE_MAPS_LARGE_PAGE(PDE) ((PDE)->u.Hard.LargePage == 1)

#define MI_MAKE_PDE_MAP_LARGE_PAGE(PDE) ((PDE)->u.Hard.LargePage = 1)

#define MI_GET_PAGE_FRAME_FROM_PTE(PTE) ((PTE)->u.Hard.PageFrameNumber)
#define MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE(PTE) ((PTE)->u.Trans.PageFrameNumber)
#define MI_GET_PROTECTION_FROM_SOFT_PTE(PTE) ((ULONG)(PTE)->u.Soft.Protection)
#define MI_GET_PROTECTION_FROM_TRANSITION_PTE(PTE) ((ULONG)(PTE)->u.Trans.Protection)

typedef struct _MMPTE {
    union  {
        ULONG_PTR Long;
        MMPTE_HARDWARE Hard;
        MMPTE_HARDWARE_LARGEPAGE HardLarge;
        HARDWARE_PTE Flush;
        MMPTE_PROTOTYPE Proto;
        MMPTE_SOFTWARE Soft;
        MMPTE_TRANSITION Trans;
        MMPTE_SUBSECTION Subsect;
        MMPTE_LIST List;
        } u;
} MMPTE;

typedef MMPTE *PMMPTE;

extern PMMPTE MiFirstReservedZeroingPte;

#define InterlockedCompareExchangePte(_PointerPte, _NewContents, _OldContents) \
        InterlockedCompareExchange64 ((PLONGLONG)(_PointerPte), (LONGLONG)(_NewContents), (LONGLONG)(_OldContents))

#define InterlockedExchangePte(_PointerPte, _NewContents) InterlockedExchange64((PLONG64)(_PointerPte), _NewContents)

//++
// VOID
// MI_WRITE_VALID_PTE (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_VALID_PTE fills in the specified PTE making it valid with the
//    specified contents.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_VALID_PTE(_PointerPte, _PteContents)       \
            ASSERT ((_PointerPte)->u.Hard.Valid == 0);      \
            ASSERT ((_PteContents).u.Hard.Valid == 1);      \
            MI_INSERT_VALID_PTE(_PointerPte);               \
            MI_LOG_PTE_CHANGE (_PointerPte, _PteContents);  \
            (*(_PointerPte) = (_PteContents))

//++
// VOID
// MI_WRITE_INVALID_PTE (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_INVALID_PTE fills in the specified PTE making it invalid with the
//    specified contents.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_INVALID_PTE(_PointerPte, _PteContents)     \
            ASSERT ((_PteContents).u.Hard.Valid == 0);      \
            MI_REMOVE_PTE(_PointerPte);                     \
            MI_LOG_PTE_CHANGE (_PointerPte, _PteContents);  \
            (*(_PointerPte) = (_PteContents))

#define MI_WRITE_INVALID_PTE_WITHOUT_WS MI_WRITE_INVALID_PTE

//++
// VOID
// MI_WRITE_ZERO_PTE (
//    IN PMMPTE PointerPte
//    );
//
// Routine Description:
//
//    MI_WRITE_ZERO_PTE fills the specified PTE with zero, making it invalid.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_ZERO_PTE(_PointerPte)                  \
            MI_REMOVE_PTE(_PointerPte);                 \
            MI_LOG_PTE_CHANGE (_PointerPte, ZeroPte);   \
            (_PointerPte)->u.Long = 0;

//++
// VOID
// MI_WRITE_VALID_PTE_NEW_PROTECTION (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_VALID_PTE_NEW_PROTECTION fills in the specified PTE (which was
//    already valid) changing only the protection or the dirty bit.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_VALID_PTE_NEW_PROTECTION(_PointerPte, _PteContents)    \
            ASSERT ((_PointerPte)->u.Hard.Valid == 1);  \
            ASSERT ((_PteContents).u.Hard.Valid == 1);  \
            ASSERT ((_PointerPte)->u.Hard.PageFrameNumber == (_PteContents).u.Hard.PageFrameNumber); \
            MI_LOG_PTE_CHANGE (_PointerPte, _PteContents);  \
            (*(_PointerPte) = (_PteContents))

//++
// VOID
// MI_WRITE_VALID_PTE_NEW_PAGE (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_VALID_PTE_NEW_PAGE fills in the specified PTE (which was
//    already valid) changing the page and the protection.
//    Note that the contents are very carefully written.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_VALID_PTE_NEW_PAGE(_PointerPte, _PteContents)    \
            ASSERT ((_PointerPte)->u.Hard.Valid == 1);  \
            ASSERT ((_PteContents).u.Hard.Valid == 1);  \
            ASSERT ((_PointerPte)->u.Hard.PageFrameNumber != (_PteContents).u.Hard.PageFrameNumber); \
            MI_LOG_PTE_CHANGE (_PointerPte, _PteContents);  \
            (*(_PointerPte) = (_PteContents))

//++
// VOID
// MiFillMemoryPte (
//    IN PMMPTE Destination,
//    IN ULONG  NumberOfPtes,
//    IN MMPTE  Pattern
//    };
//
// Routine Description:
//
//    This function fills memory with the specified PTE pattern.
//
// Arguments
//
//    Destination - Supplies a pointer to the memory to fill.
//
//    NumberOfPtes - Supplies the number of PTEs (not bytes!) to be filled.
//
//    Pattern - Supplies the PTE fill pattern.
//
// Return Value:
//
//    None.
//
//--

#define MiFillMemoryPte(Destination, Length, Pattern) \
             __stosq((PULONG64)(Destination), Pattern, Length)

#define MiZeroMemoryPte(Destination, Length) \
             __stosq((PULONG64)(Destination), 0, Length)

//++
// BOOLEAN
// MI_IS_WRITE_COMBINE_ENABLED (
//    IN PMMPTE PPTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and returns TRUE if write combine is
//    enabled.
//
// Arguments
//
//    PPTE - Supplies a pointer to the valid PTE.
//
// Return Value:
//
//     TRUE if write combine is enabled, FALSE if it is disabled.
//
//--

__forceinline
LOGICAL
MI_IS_WRITE_COMBINE_ENABLED (
    IN PMMPTE PointerPte
    )
{
    if (MiWriteCombiningPtes == TRUE) {
        if ((PointerPte->u.Hard.CacheDisable == 0) &&
            (PointerPte->u.Hard.WriteThrough == 1)) {

            return TRUE;
        }
    }
    else {
        if ((PointerPte->u.Hard.CacheDisable == 1) &&
            (PointerPte->u.Hard.WriteThrough == 0)) {

            return TRUE;
        }
    }

    return FALSE;
}


ULONG
FASTCALL
MiDetermineUserGlobalPteMask (
    IN PMMPTE Pte
    );

//++
// BOOLEAN
// MI_IS_PAGE_TABLE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a page table address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a page table address, FALSE if not.
//
//--

#define MI_IS_PAGE_TABLE_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)PTE_BASE && (PVOID)(VA) <= (PVOID)PTE_TOP)

//++
// BOOLEAN
// MI_IS_PAGE_TABLE_OR_HYPER_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a page table or hyperspace address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a page table or hyperspace address, FALSE if not.
//
//--

#define MI_IS_PAGE_TABLE_OR_HYPER_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)PTE_BASE && (PVOID)(VA) <= (PVOID)HYPER_SPACE_END)

//++
// BOOLEAN
// MI_IS_KERNEL_PAGE_TABLE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a page table address for a kernel address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a kernel page table address, FALSE if not.
//
//--

#define MI_IS_KERNEL_PAGE_TABLE_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)MiGetPteAddress(MM_SYSTEM_RANGE_START) && (PVOID)(VA) <= (PVOID)PTE_TOP)


//++
// BOOLEAN
// MI_IS_PAGE_DIRECTORY_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a page directory address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a page directory address, FALSE if not.
//
//--

#define MI_IS_PAGE_DIRECTORY_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)PDE_BASE && (PVOID)(VA) <= (PVOID)PDE_TOP)


//++
// BOOLEAN
// MI_IS_HYPER_SPACE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a hyper space address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a hyper space address, FALSE if not.
//
//--

#define MI_IS_HYPER_SPACE_ADDRESS(VA)   \
            ((PVOID)(VA) >= (PVOID)HYPER_SPACE && (PVOID)(VA) <= (PVOID)HYPER_SPACE_END)


//++
// BOOLEAN
// MI_IS_PROCESS_SPACE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a process-specific address.  This is an address in user space
//    or page table pages or hyper space.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is a process-specific address, FALSE if not.
//
//--

#define MI_IS_PROCESS_SPACE_ADDRESS(VA)   \
            (((PVOID)(VA) <= (PVOID)MM_HIGHEST_USER_ADDRESS) || \
             ((PVOID)(VA) >= (PVOID)PTE_BASE && (PVOID)(VA) <= (PVOID)HYPER_SPACE_END))


//++
// BOOLEAN
// MI_IS_PTE_PROTOTYPE (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a PTE address and determines if it is a prototype PTE.
//
// Arguments
//
//    PTE - Supplies the virtual address of the PTE to check.
//
// Return Value:
//
//    TRUE if the PTE is in a segment (ie, a prototype PTE), FALSE if not.
//
//--

#define MI_IS_PTE_PROTOTYPE(PTE)   \
            ((PTE) > (PMMPTE)PTE_TOP)

//++
// BOOLEAN
// MI_IS_SYSTEM_CACHE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is a system cache address.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is in the system cache, FALSE if not.
//
//--

#define MI_IS_SYSTEM_CACHE_ADDRESS(VA)                            \
         ((PVOID)(VA) >= (PVOID)MmSystemCacheStart &&            \
		     (PVOID)(VA) <= (PVOID)MmSystemCacheEnd)

//++
// VOID
// MI_BARRIER_SYNCHRONIZE (
//    IN ULONG TimeStamp
//    );
//
// Routine Description:
//
//    MI_BARRIER_SYNCHRONIZE compares the argument timestamp against the
//    current IPI barrier sequence stamp.  When equal, all processors will
//    issue memory barriers to ensure that newly created pages remain coherent.
//
//    When a page is put in the zeroed or free page list the current
//    barrier sequence stamp is read (interlocked - this is necessary
//    to get the correct value - memory barriers won't do the trick)
//    and stored in the pfn entry for the page. The current barrier
//    sequence stamp is maintained by the IPI send logic and is
//    incremented (interlocked) when the target set of an IPI send
//    includes all processors, but the one doing the send. When a page
//    is needed its sequence number is compared against the current
//    barrier sequence number.  If it is equal, then the contents of
//    the page may not be coherent on all processors, and an IPI must
//    be sent to all processors to ensure a memory barrier is
//    executed (generic call can be used for this). Sending the IPI
//    automatically updates the barrier sequence number. The compare
//    is for equality as this is the only value that requires the IPI
//    (i.e., the sequence number wraps, values in both directions are
//    older). When a page is removed in this fashion and either found
//    to be coherent or made coherent, it cannot be modified between
//    that time and writing the PTE. If the page is modified between
//    these times, then an IPI must be sent.
//
// Arguments
//
//    TimeStamp - Supplies the timestamp at the time when the page was zeroed.
//
// Return Value:
//
//    None.
//
//--

// does nothing on AMD64.

#define MI_BARRIER_SYNCHRONIZE(TimeStamp)

//++
// VOID
// MI_BARRIER_STAMP_ZEROED_PAGE (
//    IN PULONG PointerTimeStamp
//    );
//
// Routine Description:
//
//    MI_BARRIER_STAMP_ZEROED_PAGE issues an interlocked read to get the
//    current IPI barrier sequence stamp.  This is called AFTER a page is
//    zeroed.
//
// Arguments
//
//    PointerTimeStamp - Supplies a timestamp pointer to fill with the
//                       current IPI barrier sequence stamp.
//
// Return Value:
//
//    None.
//
//--

// does nothing on AMD64.

#define MI_BARRIER_STAMP_ZEROED_PAGE(PointerTimeStamp)

//
//++
// LOGICAL
// MI_RESERVED_BITS_CANONICAL (
//    IN PVOID VirtualAddress
//    );
//
// Routine Description:
//
//    This routine checks whether all of the reserved bits are correct.
//
//    The processor implements at 48 bits of VA and memory management
//    uses them all so the VA is checked against 48 bits to prevent
//    reserved bit faults as our caller is not going to be expecting them.
//
// Arguments
//
//    VirtualAddress - Supplies the virtual address to check.
//
// Return Value:
//
//    TRUE if the address is ok, FALSE if not.
//

LOGICAL
__inline
MI_RESERVED_BITS_CANONICAL (
    IN PVOID VirtualAddress
    )
{

    //
    // Bits 48-63 of the address must match, i.e., they must be all zeros
    // or all ones.
    //

    return ((ULONG64)(((LONG64)VirtualAddress >> 48) + 1) <= 1);
}

//++
// VOID
// MI_DISPLAY_TRAP_INFORMATION (
//    IN PVOID TrapInformation
//    );
//
// Routine Description:
//
//    Display any relevant trap information to aid debugging.
//
// Arguments
//
//    TrapInformation - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
#define MI_DISPLAY_TRAP_INFORMATION(TrapInformation)                    \
            KdPrint(("MM:***RIP %p, EFL %p\n",                          \
                     ((PKTRAP_FRAME) (TrapInformation))->Rip,           \
                     ((PKTRAP_FRAME) (TrapInformation))->EFlags));      \
            KdPrint(("MM:***RAX %p, RCX %p RDX %p\n",                   \
                     ((PKTRAP_FRAME) (TrapInformation))->Rax,           \
                     ((PKTRAP_FRAME) (TrapInformation))->Rcx,           \
                     ((PKTRAP_FRAME) (TrapInformation))->Rdx));         \
            KdPrint(("MM:***RBX %p, RSI %p RDI %p\n",                   \
                     ((PKTRAP_FRAME) (TrapInformation))->Rbx,           \
                     ((PKTRAP_FRAME) (TrapInformation))->Rsi,           \
                     ((PKTRAP_FRAME) (TrapInformation))->Rdi));

VOID
MiGetStackPointer (
    OUT PULONG_PTR StackPointer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\i386\paesup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    paesup.c

Abstract:

    This module contains the machine dependent support for the x86 PAE
    architecture.

--*/

#include "mi.h"

#if defined (_X86PAE_)

#define PAES_PER_PAGE  (PAGE_SIZE / sizeof(PAE_ENTRY))

#define MINIMUM_PAE_SLIST_THRESHOLD (PAES_PER_PAGE * 1)
#define MINIMUM_PAE_THRESHOLD       (PAES_PER_PAGE * 4)
#define REPLENISH_PAE_SIZE          (PAES_PER_PAGE * 16)
#define EXCESS_PAE_THRESHOLD        (PAES_PER_PAGE * 20)

#define MM_HIGHEST_PAE_PAGE      0xFFFFF

ULONG MiFreePaeEntries;
PAE_ENTRY MiFirstFreePae;

LONG MmAllocatedPaePages;
KSPIN_LOCK MiPaeLock;

SLIST_HEADER MiPaeEntrySList;

PAE_ENTRY MiSystemPaeVa;

LONG
MiPaeAllocatePages (
    VOID
    );

VOID
MiPaeFreePages (
    PVOID VirtualAddress
    );

#pragma alloc_text(INIT,MiPaeInitialize)
#pragma alloc_text(PAGE,MiPaeFreePages)

VOID
MiMarkMdlPageAttributes (
    IN PMDL Mdl,
    IN PFN_NUMBER NumberOfPages,
    IN MI_PFN_CACHE_ATTRIBUTE CacheAttribute
    );

VOID
MiPaeInitialize (
    VOID
    )
{
    InitializeSListHead (&MiPaeEntrySList);
    KeInitializeSpinLock (&MiPaeLock);
    InitializeListHead (&MiFirstFreePae.PaeEntry.ListHead);
}

ULONG
MiPaeAllocate (
    OUT PPAE_ENTRY *Va
    )

/*++

Routine Description:

    This routine allocates the top level page directory pointer structure.
    This structure will contain 4 PDPTEs.

Arguments:

    Va - Supplies a place to put the virtual address this page can be accessed
         at.

Return Value:

    Returns a virtual and physical address suitable for use as a top
    level page directory pointer page.  The page returned must be below
    physical 4GB as required by the processor.

    Returns 0 if no page was allocated.

Environment:

    Kernel mode.  No locks may be held.

--*/

{
    LOGICAL FlushedOnce;
    PPAE_ENTRY Pae2;
    PPAE_ENTRY Pae3;
    PPAE_ENTRY Pae3Base;
    PPAE_ENTRY Pae;
    PPAE_ENTRY PaeBase;
    PFN_NUMBER PageFrameIndex;
    PSLIST_ENTRY SingleListEntry;
    ULONG j;
    ULONG Entries;
    KLOCK_QUEUE_HANDLE LockHandle;
#if DBG
    PMMPFN Pfn1;
#endif

    FlushedOnce = FALSE;

    ASSERT (KeGetCurrentIrql() <= APC_LEVEL);

    do {

        //
        // Pop an entry from the freelist.
        //

        SingleListEntry = InterlockedPopEntrySList (&MiPaeEntrySList);

        if (SingleListEntry != NULL) {
            Pae = CONTAINING_RECORD (SingleListEntry,
                                    PAE_ENTRY,
                                    NextPae);

            PaeBase = (PPAE_ENTRY)PAGE_ALIGN(Pae);

            *Va = Pae;

            PageFrameIndex = PaeBase->PaeEntry.PageFrameNumber;
            ASSERT (PageFrameIndex <= MM_HIGHEST_PAE_PAGE);

            return (PageFrameIndex << PAGE_SHIFT) + BYTE_OFFSET (Pae);
        }

        KeAcquireInStackQueuedSpinLock (&MiPaeLock, &LockHandle);

        if (MiFreePaeEntries != 0) {

            ASSERT (IsListEmpty (&MiFirstFreePae.PaeEntry.ListHead) == 0);

            Pae = (PPAE_ENTRY) RemoveHeadList (&MiFirstFreePae.PaeEntry.ListHead);

            PaeBase = (PPAE_ENTRY)PAGE_ALIGN(Pae);
            PaeBase->PaeEntry.EntriesInUse += 1;
#if DBG
            RtlZeroMemory ((PVOID)Pae, sizeof(PAE_ENTRY));

            Pfn1 = MI_PFN_ELEMENT (PaeBase->PaeEntry.PageFrameNumber);
            ASSERT (Pfn1->u2.ShareCount == 1);
            ASSERT (Pfn1->u3.e2.ReferenceCount == 1);
            ASSERT (Pfn1->u3.e1.PageLocation == ActiveAndValid);
            ASSERT (Pfn1->u3.e1.CacheAttribute == MiCached);
#endif

            MiFreePaeEntries -= 1;

            //
            // Since we're holding the spinlock, dequeue a chain of entries
            // for the SLIST.
            //

            Entries = MiFreePaeEntries;

            if (Entries != 0) {
                if (Entries > MINIMUM_PAE_SLIST_THRESHOLD) {
                    Entries = MINIMUM_PAE_SLIST_THRESHOLD;
                }

                ASSERT (IsListEmpty (&MiFirstFreePae.PaeEntry.ListHead) == 0);

                Pae2 = (PPAE_ENTRY) RemoveHeadList (&MiFirstFreePae.PaeEntry.ListHead);
                Pae2->NextPae.Next = NULL;
                Pae3 = Pae2;
                Pae3Base = (PPAE_ENTRY)PAGE_ALIGN(Pae3);
                Pae3Base->PaeEntry.EntriesInUse += 1;

                for (j = 1; j < Entries; j += 1) {
                    ASSERT (IsListEmpty (&MiFirstFreePae.PaeEntry.ListHead) == 0);

                    Pae3->NextPae.Next = (PSLIST_ENTRY) RemoveHeadList (&MiFirstFreePae.PaeEntry.ListHead);

                    Pae3 = (PPAE_ENTRY) Pae3->NextPae.Next;
                    Pae3Base = (PPAE_ENTRY)PAGE_ALIGN(Pae3);
                    Pae3Base->PaeEntry.EntriesInUse += 1;
                }

                MiFreePaeEntries -= Entries;

                KeReleaseInStackQueuedSpinLock (&LockHandle);

                Pae3->NextPae.Next = NULL;

                InterlockedPushListSList (&MiPaeEntrySList,
                                          (PSLIST_ENTRY) Pae2,
                                          (PSLIST_ENTRY) Pae3,
                                          Entries);
            }
            else {
                KeReleaseInStackQueuedSpinLock (&LockHandle);
            }

            ASSERT (KeGetCurrentIrql() <= APC_LEVEL);
            *Va = Pae;

            PageFrameIndex = PaeBase->PaeEntry.PageFrameNumber;
            ASSERT (PageFrameIndex <= MM_HIGHEST_PAE_PAGE);

            return (PageFrameIndex << PAGE_SHIFT) + BYTE_OFFSET (Pae);
        }

        KeReleaseInStackQueuedSpinLock (&LockHandle);

        if (FlushedOnce == TRUE) {
            break;
        }

        //
        // No free pages in the cachelist, replenish the list now.
        //

        if (MiPaeAllocatePages () == 0) {

            InterlockedIncrement (&MiDelayPageFaults);

            //
            // Attempt to move pages to the standby list.
            //

            MmEmptyAllWorkingSets ();
            MiFlushAllPages();

            KeDelayExecutionThread (KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER)&MmHalfSecond);

            InterlockedDecrement (&MiDelayPageFaults);

            FlushedOnce = TRUE;

            //
            // Since all the working sets have been trimmed, check whether
            // another thread has replenished our list.  If not, then attempt
            // to do so since the working set pain has already been absorbed.
            //

            if (MiFreePaeEntries < MINIMUM_PAE_THRESHOLD) {
                MiPaeAllocatePages ();
            }
        }

    } while (TRUE);

    ASSERT (KeGetCurrentIrql() <= APC_LEVEL);

    return 0;
}

VOID
MiPaeFree (
    PPAE_ENTRY Pae
    )

/*++

Routine Description:

    This routine releases the top level page directory pointer page.

Arguments:

    PageFrameIndex - Supplies the top level page directory pointer page.

Return Value:

    None.

Environment:

    Kernel mode.  No locks may be held.

--*/

{
    ULONG i;
    PLIST_ENTRY NextEntry;
    PPAE_ENTRY PaeBase;
    KLOCK_QUEUE_HANDLE LockHandle;

#if DBG
    PMMPTE PointerPte;
    PFN_NUMBER PageFrameIndex;
    PMMPFN Pfn1;

    PointerPte = MiGetPteAddress (Pae);
    PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

    //
    // This page must be in the first 4GB of RAM.
    //

    ASSERT (PageFrameIndex <= MM_HIGHEST_PAE_PAGE);

    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

    ASSERT (Pfn1->u2.ShareCount == 1);
    ASSERT (Pfn1->u3.e2.ReferenceCount == 1);
    ASSERT (Pfn1->u3.e1.PageLocation == ActiveAndValid);
    ASSERT (Pfn1->u3.e1.CacheAttribute == MiCached);
#endif

    if (ExQueryDepthSList (&MiPaeEntrySList) < MINIMUM_PAE_SLIST_THRESHOLD) {
        InterlockedPushEntrySList (&MiPaeEntrySList, &Pae->NextPae);
        return;
    }

    PaeBase = (PPAE_ENTRY)PAGE_ALIGN(Pae);

    KeAcquireInStackQueuedSpinLock (&MiPaeLock, &LockHandle);

    PaeBase->PaeEntry.EntriesInUse -= 1;

    if ((PaeBase->PaeEntry.EntriesInUse == 0) &&
        (MiFreePaeEntries > EXCESS_PAE_THRESHOLD)) {

        //
        // Free the entire page.
        //

        i = 1;
        NextEntry = MiFirstFreePae.PaeEntry.ListHead.Flink;
        while (NextEntry != &MiFirstFreePae.PaeEntry.ListHead) {

            Pae = CONTAINING_RECORD (NextEntry,
                                     PAE_ENTRY,
                                     PaeEntry.ListHead);

            if (PAGE_ALIGN(Pae) == PaeBase) {
                RemoveEntryList (NextEntry);
                i += 1;
            }
            NextEntry = Pae->PaeEntry.ListHead.Flink;
        }
        ASSERT (i == PAES_PER_PAGE - 1);
        MiFreePaeEntries -= (PAES_PER_PAGE - 1);
        KeReleaseInStackQueuedSpinLock (&LockHandle);

        MiPaeFreePages (PaeBase);
    }
    else {

        InsertTailList (&MiFirstFreePae.PaeEntry.ListHead,
                        &Pae->PaeEntry.ListHead);
        MiFreePaeEntries += 1;
        KeReleaseInStackQueuedSpinLock (&LockHandle);
    }

    return;
}

LONG
MiPaeAllocatePages (
    VOID
    )

/*++

Routine Description:

    This routine replenishes the PAE top level mapping list.

Arguments:

    None.

Return Value:

    The number of pages allocated.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/
{
    PMDL MemoryDescriptorList;
    LONG AllocatedPaePages;
    ULONG i;
    ULONG j;
    PPFN_NUMBER SlidePage;
    PPFN_NUMBER Page;
    PFN_NUMBER PageFrameIndex;
    ULONG_PTR ActualPages;
    PMMPTE PointerPte;
    PVOID BaseAddress;
    PPAE_ENTRY Pae;
    ULONG NumberOfPages;
    MMPTE TempPte;
    PHYSICAL_ADDRESS HighAddress;
    PHYSICAL_ADDRESS LowAddress;
    PHYSICAL_ADDRESS SkipBytes;
    KLOCK_QUEUE_HANDLE LockHandle;

#if defined (_MI_MORE_THAN_4GB_)
    if (MiNoLowMemory != 0) {
        BaseAddress = MiAllocateLowMemory (PAGE_SIZE,
                                           0,
                                           MiNoLowMemory - 1,
                                           0,
                                           (PVOID)0x123,
                                           MmCached,
                                           'DeaP');
        if (BaseAddress == NULL) {
            return 0;
        }

        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (MiGetPteAddress(BaseAddress));

        Pae = (PPAE_ENTRY) BaseAddress;
        Pae->PaeEntry.EntriesInUse = 0;
        Pae->PaeEntry.PageFrameNumber = PageFrameIndex;
        Pae += 1;

        KeAcquireInStackQueuedSpinLock (&MiPaeLock, &LockHandle);

        for (i = 1; i < PAES_PER_PAGE; i += 1) {
            InsertTailList (&MiFirstFreePae.PaeEntry.ListHead,
                            &Pae->PaeEntry.ListHead);
            Pae += 1;
        }
        MiFreePaeEntries += (PAES_PER_PAGE - 1);

        KeReleaseInStackQueuedSpinLock (&LockHandle);

        InterlockedIncrement (&MmAllocatedPaePages);
        return 1;
    }
#endif

    NumberOfPages = REPLENISH_PAE_SIZE / PAES_PER_PAGE;
    AllocatedPaePages = 0;

    HighAddress.QuadPart = (ULONGLONG)_4gb - 1;
    LowAddress.QuadPart = 0;
    SkipBytes.QuadPart = 0;

    //
    // This is a potentially expensive call so pick up a chunk of pages
    // at once to amortize the cost.
    //

    MemoryDescriptorList = MiAllocatePagesForMdl (LowAddress,
                                                  HighAddress,
                                                  SkipBytes,
                                                  NumberOfPages << PAGE_SHIFT,
                                                  MiCached,
                                                  0);

    if (MemoryDescriptorList == NULL) {
        return 0;
    }

    ActualPages = MemoryDescriptorList->ByteCount >> PAGE_SHIFT;

    TempPte = ValidKernelPte;
    Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);

    //
    // Map each page individually as they may need to be freed individually
    // later.
    //

    for (i = 0; i < ActualPages; i += 1) {
        PageFrameIndex = *Page;

        PointerPte = MiReserveSystemPtes (1, SystemPteSpace);

        if (PointerPte == NULL) {

            //
            // Free any remaining pages in the MDL as they are not mapped.
            // Slide the MDL pages forward so the mapped ones are kept.
            //

            MmInitializeMdl (MemoryDescriptorList,
                             0,
                             (ActualPages - i) << PAGE_SHIFT);

            SlidePage = (PPFN_NUMBER)(MemoryDescriptorList + 1);

            while (i < ActualPages) {
                i += 1;
                *SlidePage = *Page;
                SlidePage += 1;
                Page += 1;
            }

            MmFreePagesFromMdl (MemoryDescriptorList);

            break;
        }

        TempPte.u.Hard.PageFrameNumber = PageFrameIndex;
        MI_WRITE_VALID_PTE (PointerPte, TempPte);

        BaseAddress = MiGetVirtualAddressMappedByPte (PointerPte);

        Pae = (PPAE_ENTRY) BaseAddress;

        Pae->PaeEntry.EntriesInUse = 0;
        Pae->PaeEntry.PageFrameNumber = PageFrameIndex;
        Pae += 1;

        //
        // Put the first chunk into the SLIST if it's still low, and just
        // enqueue all the other entries normally.
        //

        if ((i == 0) &&
            (ExQueryDepthSList (&MiPaeEntrySList) < MINIMUM_PAE_SLIST_THRESHOLD)) {

            (Pae - 1)->PaeEntry.EntriesInUse = PAES_PER_PAGE - 1;

            for (j = 1; j < PAES_PER_PAGE - 1; j += 1) {
                Pae->NextPae.Next = (PSLIST_ENTRY) (Pae + 1);
                Pae += 1;
            }

            Pae->NextPae.Next = NULL;

            InterlockedPushListSList (&MiPaeEntrySList,
                                      (PSLIST_ENTRY)((PPAE_ENTRY) BaseAddress + 1),
                                      (PSLIST_ENTRY) Pae,
                                      PAES_PER_PAGE - 1);
        }
        else {

            KeAcquireInStackQueuedSpinLock (&MiPaeLock, &LockHandle);

            for (j = 1; j < PAES_PER_PAGE; j += 1) {
                InsertTailList (&MiFirstFreePae.PaeEntry.ListHead,
                                &Pae->PaeEntry.ListHead);
                Pae += 1;
            }

            MiFreePaeEntries += (PAES_PER_PAGE - 1);

            KeReleaseInStackQueuedSpinLock (&LockHandle);
        }

        AllocatedPaePages += 1;

        Page += 1;
    }

    ExFreePool (MemoryDescriptorList);

    InterlockedExchangeAdd (&MmAllocatedPaePages, AllocatedPaePages);

    return AllocatedPaePages;
}

VOID
MiPaeFreePages (
    PVOID VirtualAddress
    )

/*++

Routine Description:

    This routine releases a single page that previously contained top level
    page directory pointer pages.

Arguments:

    VirtualAddress - Supplies the virtual address of the page that contained
                     top level page directory pointer pages.

Return Value:

    None.

Environment:

    Kernel mode.  No locks held.

--*/

{
    ULONG MdlPages;
    PFN_NUMBER PageFrameIndex;
    PMMPTE PointerPte;
    PFN_NUMBER MdlHack[(sizeof(MDL) / sizeof(PFN_NUMBER)) + 1];
    PPFN_NUMBER MdlPage;
    PMDL MemoryDescriptorList;

#if defined (_MI_MORE_THAN_4GB_)
    if (MiNoLowMemory != 0) {
        if (MiFreeLowMemory (VirtualAddress, 'DeaP') == TRUE) {
            InterlockedDecrement (&MmAllocatedPaePages);
            return;
        }
    }
#endif

    MemoryDescriptorList = (PMDL)&MdlHack[0];
    MdlPages = 1;
    MmInitializeMdl (MemoryDescriptorList, 0, MdlPages << PAGE_SHIFT);

    MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);

    PointerPte = MiGetPteAddress (VirtualAddress);
    PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
    *MdlPage = PageFrameIndex;

    ASSERT ((MI_PFN_ELEMENT(PageFrameIndex))->u3.e1.CacheAttribute == MiCached);

    MiReleaseSystemPtes (PointerPte, 1, SystemPteSpace);

    MmFreePagesFromMdl (MemoryDescriptorList);

    InterlockedDecrement (&MmAllocatedPaePages);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\i386\procpae.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    procpae.c

Abstract:

    This module contains machine-specific
    routines to support the process structure.

--*/


#include "mi.h"

extern SIZE_T MmProcessCommit;

#if defined(_X86PAE_)


BOOLEAN
MmCreateProcessAddressSpace (
    IN ULONG MinimumWorkingSetSize,
    IN PEPROCESS NewProcess,
    OUT PULONG_PTR DirectoryTableBase
    )

/*++

Routine Description:

    This routine creates an address space which maps the system
    portion and contains a hyper space entry.

Arguments:

    MinimumWorkingSetSize - Supplies the minimum working set size for
                            this address space.  This value is only used
                            to ensure that ample physical pages exist
                            to create this process.

    NewProcess - Supplies a pointer to the process object being created.

    DirectoryTableBase - Returns the value of the newly created
                         address space's Page Directory (PD) page and
                         hyper space page.

Return Value:

    Returns TRUE if an address space was successfully created, FALSE
    if ample physical pages do not exist.

Environment:

    Kernel mode.  APCs Disabled.

--*/

{
    LOGICAL FlushTbNeeded;
    PFN_NUMBER PageDirectoryIndex;
    PFN_NUMBER HyperSpaceIndex;
    PFN_NUMBER PageContainingWorkingSet;
    PFN_NUMBER VadBitMapPage;
    MMPTE TempPte;
    MMPTE TempPte2;
    PEPROCESS CurrentProcess;
    KIRQL OldIrql;
    PMMPFN Pfn1;
    ULONG Color;
    PMMPTE PointerPte;
    ULONG PdeOffset;
    PMMPTE MappingPte;
    PMMPTE PointerFillPte;
    PMMPTE CurrentAddressSpacePde;
    ULONG TopQuad;
    MMPTE TopPte;
    PPAE_ENTRY PaeVa;
    ULONG i;
    PFN_NUMBER PageDirectories[PD_PER_SYSTEM];

    FlushTbNeeded = FALSE;

    //
    // Charge commitment for the page directory pages, working set page table
    // page, and working set list.  If Vad bitmap lookups are enabled, then
    // charge for a page or two for that as well.
    //

    if (MiChargeCommitment (MM_PROCESS_COMMIT_CHARGE, NULL) == FALSE) {
        return FALSE;
    }

    CurrentProcess = PsGetCurrentProcess ();

    NewProcess->NextPageColor = (USHORT) (RtlRandom (&MmProcessColorSeed));
    KeInitializeSpinLock (&NewProcess->HyperSpaceLock);

    TopQuad = MiPaeAllocate (&PaeVa);

    if (TopQuad == 0) {
        MiReturnCommitment (MM_PROCESS_COMMIT_CHARGE);
        return FALSE;
    }

    TempPte = ValidPdePde;
    MI_SET_GLOBAL_STATE (TempPte, 0);

    //
    // Get the PFN lock to get physical pages.
    //

    LOCK_PFN (OldIrql);

    //
    // Check to make sure the physical pages are available.
    //

    if (MI_NONPAGEABLE_MEMORY_AVAILABLE() <= (SPFN_NUMBER)MinimumWorkingSetSize){

        UNLOCK_PFN (OldIrql);
        MiPaeFree (PaeVa);
        MiReturnCommitment (MM_PROCESS_COMMIT_CHARGE);

        //
        // Indicate no directory base was allocated.
        //

        return FALSE;
    }

    MM_TRACK_COMMIT (MM_DBG_COMMIT_PROCESS_CREATE, MM_PROCESS_COMMIT_CHARGE);

    MI_DECREMENT_RESIDENT_AVAILABLE (MinimumWorkingSetSize,
                                     MM_RESAVAIL_ALLOCATE_CREATE_PROCESS);

    //
    // Allocate the page directory pages.
    //

    for (i = 0; i < PD_PER_SYSTEM; i += 1) {

        if (MmAvailablePages < MM_HIGH_LIMIT) {
            MiEnsureAvailablePageOrWait (NULL, OldIrql);
        }

        Color =  MI_PAGE_COLOR_PTE_PROCESS (PDE_BASE,
                                            &CurrentProcess->NextPageColor);

        PageDirectories[i] = MiRemoveZeroPageMayReleaseLocks (Color, OldIrql);

        Pfn1 = MI_PFN_ELEMENT (PageDirectories[i]);

        if (Pfn1->u3.e1.CacheAttribute != MiCached) {
            Pfn1->u3.e1.CacheAttribute = MiCached;
            FlushTbNeeded = TRUE;
        }
    }

    //
    // Initialize the parent page directory entries.
    //

    TopPte.u.Long = TempPte.u.Long & ~MM_PAE_PDPTE_MASK;
    for (i = 0; i < PD_PER_SYSTEM; i += 1) {
        TopPte.u.Hard.PageFrameNumber = PageDirectories[i];
        PaeVa->PteEntry[i].u.Long = TopPte.u.Long;
    }

    NewProcess->PaeTop = (PVOID) PaeVa;
    DirectoryTableBase[0] = TopQuad;

    //
    // Allocate the hyper space page table page.
    //

    if (MmAvailablePages < MM_HIGH_LIMIT) {
        MiEnsureAvailablePageOrWait (NULL, OldIrql);
    }

    Color = MI_PAGE_COLOR_PTE_PROCESS (MiGetPdeAddress(HYPER_SPACE),
                                       &CurrentProcess->NextPageColor);

    HyperSpaceIndex = MiRemoveZeroPageMayReleaseLocks (Color, OldIrql);

    Pfn1 = MI_PFN_ELEMENT (HyperSpaceIndex);

    if (Pfn1->u3.e1.CacheAttribute != MiCached) {
        Pfn1->u3.e1.CacheAttribute = MiCached;
        FlushTbNeeded = TRUE;
    }

    //
    // Unlike DirectoryTableBase[0], the HyperSpaceIndex is stored as an
    // absolute PFN and does not need to be below 4GB.
    //

    DirectoryTableBase[1] = HyperSpaceIndex;

    //
    // Remove page(s) for the VAD bitmap.
    //

    if (MmAvailablePages < MM_HIGH_LIMIT) {
        MiEnsureAvailablePageOrWait (NULL, OldIrql);
    }

    Color = MI_PAGE_COLOR_VA_PROCESS (MmWorkingSetList,
                                      &CurrentProcess->NextPageColor);

    VadBitMapPage = MiRemoveZeroPageMayReleaseLocks (Color, OldIrql);

    Pfn1 = MI_PFN_ELEMENT (VadBitMapPage);

    if (Pfn1->u3.e1.CacheAttribute != MiCached) {
        Pfn1->u3.e1.CacheAttribute = MiCached;
        FlushTbNeeded = TRUE;
    }

    //
    // Remove a page for the working set list.
    //

    if (MmAvailablePages < MM_HIGH_LIMIT) {
        MiEnsureAvailablePageOrWait (NULL, OldIrql);
    }

    Color = MI_PAGE_COLOR_VA_PROCESS (MmWorkingSetList,
                                      &CurrentProcess->NextPageColor);

    PageContainingWorkingSet = MiRemoveZeroPageMayReleaseLocks (Color, OldIrql);

    Pfn1 = MI_PFN_ELEMENT (PageContainingWorkingSet);

    if (Pfn1->u3.e1.CacheAttribute != MiCached) {
        Pfn1->u3.e1.CacheAttribute = MiCached;
        FlushTbNeeded = TRUE;
    }

    UNLOCK_PFN (OldIrql);

    if (FlushTbNeeded == TRUE) {
        MI_FLUSH_TB_FOR_CACHED_ATTRIBUTE ();
    }

    ASSERT (NewProcess->AddressSpaceInitialized == 0);
    PS_SET_BITS (&NewProcess->Flags, PS_PROCESS_FLAGS_ADDRESS_SPACE1);
    ASSERT (NewProcess->AddressSpaceInitialized == 1);

    NewProcess->Vm.MinimumWorkingSetSize = MinimumWorkingSetSize;

    NewProcess->WorkingSetPage = PageContainingWorkingSet;

    //
    // Initialize the PTEs for hyperspace and the VAD bitmap mapping.
    //

    TempPte.u.Hard.PageFrameNumber = VadBitMapPage;

    MappingPte = MiReserveSystemPtes (1, SystemPteSpace);

    if (MappingPte != NULL) {

        MI_MAKE_VALID_KERNEL_PTE (TempPte2,
                                  HyperSpaceIndex,
                                  MM_READWRITE,
                                  MappingPte);

        MI_SET_PTE_DIRTY (TempPte2);

        MI_WRITE_VALID_PTE (MappingPte, TempPte2);

        PointerPte = MiGetVirtualAddressMappedByPte (MappingPte);
    }
    else {
        PointerPte = MiMapPageInHyperSpace (CurrentProcess, HyperSpaceIndex, &OldIrql);
    }

    PointerPte[MiGetPteOffset(VAD_BITMAP_SPACE)] = TempPte;

    TempPte.u.Hard.PageFrameNumber = PageContainingWorkingSet;
    PointerPte[MiGetPteOffset(MmWorkingSetList)] = TempPte;

    if (MappingPte != NULL) {
        MiReleaseSystemPtes (MappingPte, 1, SystemPteSpace);
    }
    else {
        MiUnmapPageInHyperSpace (CurrentProcess, PointerPte, OldIrql);
    }

    //
    // Set the PTE address in the PFN for the page directory page.
    //

    Pfn1 = MI_PFN_ELEMENT (PageDirectories[PD_PER_SYSTEM - 1]);

    Pfn1->PteAddress = (PMMPTE)PDE_BASE;

    //
    // Add the new process to our internal list prior to filling any
    // system PDEs so if a system PDE changes (large page map or unmap)
    // it can mark this process for a subsequent update.
    //

    ASSERT (NewProcess->Pcb.DirectoryTableBase[0] == 0);

    LOCK_EXPANSION (OldIrql);

    InsertTailList (&MmProcessList, &NewProcess->MmProcessLinks);

    UNLOCK_EXPANSION (OldIrql);

    //
    // Map the page directory page in hyperspace.
    //

    MappingPte = MiReserveSystemPtes (1, SystemPteSpace);

    if (MappingPte != NULL) {

        MI_MAKE_VALID_KERNEL_PTE (TempPte2,
                                  PageDirectories[PD_PER_SYSTEM - 1],
                                  MM_READWRITE,
                                  MappingPte);

        MI_SET_PTE_DIRTY (TempPte2);

        MI_WRITE_VALID_PTE (MappingPte, TempPte2);

        PointerPte = MiGetVirtualAddressMappedByPte (MappingPte);
    }
    else {
        PointerPte = MiMapPageInHyperSpace (CurrentProcess, PageDirectories[PD_PER_SYSTEM - 1], &OldIrql);
    }

    CurrentAddressSpacePde = MiGetPdeAddress (0xC0000000);

    //
    // Copy the entire page directory page for the highest GB so all the
    // kernel mappings are inherited.
    //

    RtlCopyMemory (PointerPte, CurrentAddressSpacePde, PAGE_SIZE);

    //
    // Recursively map each page directory page so it points to itself.
    //

    for (i = 0; i < PD_PER_SYSTEM; i += 1) {
        TempPte.u.Hard.PageFrameNumber = PageDirectories[i];
        PointerPte[i] = TempPte;
    }

    //
    // Map the working set page table page.
    //

    PdeOffset = MiGetPdeOffset (HYPER_SPACE);

    TempPte.u.Hard.PageFrameNumber = HyperSpaceIndex;
    PointerPte[PdeOffset] = TempPte;

    //
    // Zero the remaining page directory range used to map the working
    // set list and its hash.
    //

    PdeOffset += 1;
    ASSERT (MiGetPdeOffset (MmHyperSpaceEnd) >= PdeOffset);

    MiZeroMemoryPte (&PointerPte[PdeOffset],
                     (MiGetPdeOffset (MmHyperSpaceEnd) - PdeOffset + 1));

    //
    // The page directory page is now initialized.
    //

    if (MappingPte != NULL) {
        MiReleaseSystemPtes (MappingPte, 1, SystemPteSpace);
    }
    else {
        MiUnmapPageInHyperSpace (CurrentProcess, PointerPte, OldIrql);
    }

    //
    // Map all the virtual space in the 2GB->3GB range when it's not user space.
    // This includes kernel/HAL code & data, the PFN database, initial nonpaged
    // pool, any extra system PTE or system cache areas, system views and
    // session space.
    //

    if (MmSystemRangeStart < (PVOID) 0xC0000000) {

        PageDirectoryIndex = MI_GET_PAGE_FRAME_FROM_PTE (&PaeVa->PteEntry[PD_PER_SYSTEM - 2]);

        MappingPte = MiReserveSystemPtes (1, SystemPteSpace);

        if (MappingPte != NULL) {

            MI_MAKE_VALID_KERNEL_PTE (TempPte2,
                                      PageDirectoryIndex,
                                      MM_READWRITE,
                                      MappingPte);

            MI_SET_PTE_DIRTY (TempPte2);

            MI_WRITE_VALID_PTE (MappingPte, TempPte2);

            PointerPte = MiGetVirtualAddressMappedByPte (MappingPte);
        }
        else {
            PointerPte = MiMapPageInHyperSpace (CurrentProcess, PageDirectoryIndex, &OldIrql);
        }

        PdeOffset = MiGetPdeOffset (MmSystemRangeStart);
        PointerFillPte = &PointerPte[PdeOffset];
        CurrentAddressSpacePde = MiGetPdeAddress (MmSystemRangeStart);

        RtlCopyMemory (PointerFillPte,
                       CurrentAddressSpacePde,
                       PAGE_SIZE - PdeOffset * sizeof (MMPTE));

        if (MappingPte != NULL) {
            MiReleaseSystemPtes (MappingPte, 1, SystemPteSpace);
        }
        else {
            MiUnmapPageInHyperSpace (CurrentProcess, PointerPte, OldIrql);
        }
    }

    InterlockedExchangeAddSizeT (&MmProcessCommit, MM_PROCESS_COMMIT_CHARGE);

    //
    // Up the session space reference count.
    //

    MiSessionAddProcess (NewProcess);

    return TRUE;
}

PMMPTE MiLargePageHyperPte;


VOID
MiUpdateSystemPdes (
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This routine updates the system PDEs, typically due to a large page
    system PTE mapping being created or destroyed.  This is rare.

    Note this is only needed for 32-bit platforms (64-bit platforms share
    a common top level system page).

Arguments:

    Process - Supplies a pointer to the process to update.

Return Value:

    None.

Environment:

    Kernel mode, expansion lock held.

    The caller acquired the expansion lock prior to clearing the update
    bit from this process.  We must update the PDEs prior to releasing
    it so that any new updates can also be rippled.

--*/

{
    ULONG PdeOffset;
    ULONG PdeEndOffset;
    LOGICAL LowPtes;
    PVOID VirtualAddress;
    MMPTE TempPte;
    PFN_NUMBER PageDirectoryIndex;
    PFN_NUMBER TargetPageDirectoryIndex;
    PEPROCESS CurrentProcess;
    PMMPTE PointerPte;
    PMMPTE PointerPde;
    PMMPTE TargetPdePage;
    PMMPTE TargetAddressSpacePde;
    PMMPTE PaeTop;
    ULONG i;

    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);

    CurrentProcess = PsGetCurrentProcess ();

    //
    // Map the page directory page in hyperspace.
    // Note for PAE, this is the high 1GB virtual only.
    //

    PaeTop = Process->PaeTop;
    ASSERT (PaeTop != NULL);
    PaeTop += 3;
    ASSERT (PaeTop->u.Hard.Valid == 1);
    TargetPageDirectoryIndex = (PFN_NUMBER)(PaeTop->u.Hard.PageFrameNumber);

    PaeTop = &MiSystemPaeVa.PteEntry[PD_PER_SYSTEM - 1];
    ASSERT (PaeTop->u.Hard.Valid == 1);
    PageDirectoryIndex = (PFN_NUMBER)(PaeTop->u.Hard.PageFrameNumber);

    TempPte = ValidKernelPte;
    TempPte.u.Hard.PageFrameNumber = TargetPageDirectoryIndex;
    ASSERT (MiLargePageHyperPte->u.Long == 0);
    MI_WRITE_VALID_PTE (MiLargePageHyperPte, TempPte);
    TargetPdePage = MiGetVirtualAddressMappedByPte (MiLargePageHyperPte);

    LowPtes = FALSE;

    //
    // Map the system process page directory as we know that's always kept
    // up to date.
    //

    PointerPte = MiMapPageInHyperSpaceAtDpc (CurrentProcess,
                                             PageDirectoryIndex);

    //
    // Copy all system PTE ranges that reside in the top 1GB.
    //

    for (i = 0; i < MiPteRangeIndex; i += 1) {

        VirtualAddress = MiPteRanges[i].StartingVa;

        if (VirtualAddress < (PVOID) 0xC0000000) {
            LowPtes = TRUE;
            continue;
        }

        PdeOffset = MiGetPdeOffset (VirtualAddress);
        PdeEndOffset = MiGetPdeOffset (MiPteRanges[i].EndingVa);

        PointerPde = &PointerPte[PdeOffset];
        TargetAddressSpacePde = &TargetPdePage[PdeOffset];

        RtlCopyMemory (TargetAddressSpacePde,
                       PointerPde,
                       (PdeEndOffset - PdeOffset + 1) * sizeof (MMPTE));

    }

    MiUnmapPageInHyperSpaceFromDpc (CurrentProcess, PointerPte);

    //
    // Just invalidate the mapping on the current processor as we cannot
    // have context switched.
    //

    MI_WRITE_ZERO_PTE (MiLargePageHyperPte);
    MI_FLUSH_CURRENT_TB_SINGLE (TargetPdePage);

    ASSERT (MmSystemRangeStart >= (PVOID) 0x80000000);

    //
    // Copy low additional system PTE ranges (if they exist).
    //

    if (LowPtes == TRUE) {
            
        ASSERT (MmSystemRangeStart < (PVOID) 0xC0000000);

        //
        // Map the target process' page directory.
        //

        PaeTop = Process->PaeTop;
        ASSERT (PaeTop != NULL);
        PaeTop += 2;
        ASSERT (PaeTop->u.Hard.Valid == 1);
        TargetPageDirectoryIndex = (PFN_NUMBER)(PaeTop->u.Hard.PageFrameNumber);

        TempPte.u.Hard.PageFrameNumber = TargetPageDirectoryIndex;
        ASSERT (MiLargePageHyperPte->u.Long == 0);
        MI_WRITE_VALID_PTE (MiLargePageHyperPte, TempPte);

        //
        // Map the system's page directory.
        //

        PaeTop = &MiSystemPaeVa.PteEntry[PD_PER_SYSTEM - 2];
        ASSERT (PaeTop->u.Hard.Valid == 1);
        PageDirectoryIndex = (PFN_NUMBER)(PaeTop->u.Hard.PageFrameNumber);

        PdeOffset = MiGetPdeOffset (MmSystemRangeStart);
        TargetAddressSpacePde = &TargetPdePage[PdeOffset];

        PointerPte = MiMapPageInHyperSpaceAtDpc (CurrentProcess,
                                                 PageDirectoryIndex);

        //
        // Copy all system ranges that reside in the 3rd GB.
        //
    
        for (i = 0; i < MiPteRangeIndex; i += 1) {
    
            VirtualAddress = MiPteRanges[i].StartingVa;
    
            if (VirtualAddress < (PVOID) 0xC0000000) {
    
                PdeOffset = MiGetPdeOffset (VirtualAddress);
                PdeEndOffset = MiGetPdeOffset (MiPteRanges[i].EndingVa);
        
                PointerPde = &PointerPte[PdeOffset];
                TargetAddressSpacePde = &TargetPdePage[PdeOffset];
        
                RtlCopyMemory (TargetAddressSpacePde,
                               PointerPde,
                               (PdeEndOffset - PdeOffset + 1) * sizeof (MMPTE));
            } 
        }
    
        MiUnmapPageInHyperSpaceFromDpc (CurrentProcess, PointerPte);

        //
        // Just invalidate the mapping on the current processor as we cannot
        // have context switched.
        //

        MI_WRITE_ZERO_PTE (MiLargePageHyperPte);
        MI_FLUSH_CURRENT_TB_SINGLE (TargetPdePage);
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\fastref.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rundown.c

Abstract:

    This module houses routines that do fast referencing of object manager
    objects. This is just a thin layer around the fast ref package in EX.
    The EX routines are all inline so their description is here.

    The basic principle of these routines is to allow fast referencing of
    objects held in pointers protected by locks. This is done by assuming
    the pointer to an object is aligned on a 8 byte boundary and using the
    bottom 3 bits of the pointer as a fast referencing mechanism. The
    assumption of this algorithm is that the pointer changes far less
    frequently than it is referenced.

    Given the following bit definition of a
    pointer:

    +-----------+---+
    |    p      | n |
    +-----------+---+

    p << 3 : Object pointer. Bottom three bits are zero. p may be null in
             which case n must be zero
    n : Total number of pre-references unused

    For a non-null p the total number of references on the target object
    associated with this structure is >= 1 + 7 - n. There is an associated
    reference for the pointer itself and one for each of the possible
    extra references.

    Fast references proceed to perform one of the following transformation:

    +-----------+---+    +-----------+-----+
    |    p      | n | => |    p      | n-1 | n > 0, p != NULL
    +-----------+---+    +-----------+-----+

    +-----------+---+    +-----------+---+
    |   NULL    | 0 | => |   NULL    | 0 | NULL pointers are never fast refed
    +-----------+---+    +-----------+---+ and never have cached references

    Slow references do the following transformation:

    +-----------+---+    +-----------+-----+
    |    p      | 0 | => |    p      |  7  | An addition 8 references are
    +-----------+---+    +-----------+-----+ added to the object

    The second transformation is either done under a lock or done by the
    thread that does the transition with n = 1 => n = 0.

    The reference obtained by this fast algorithm may be released by
    dereferencing the target object directly or by attempting to return the
    reference to the pointer. Returning the reference to the pointer has
    the following transformations:

    +-----------+---+    +-----------+-----+
    |    p      | n | => |    p      | n+1 | n < 7, p != NULL
    +-----------+---+    +-----------+-----+

    +-----------+---+    +-----------+-----+
    |    p      | 7 | => |    p      |  0  | Dereference the object directly
    +-----------+---+    +-----------+-----+

    +-----------+---+    +-----------+-----+ Dereference the object directly
    |    q      | n | => |    q      |  n  | as the pointer p has been
    +-----------+---+    +-----------+-----+ replaced by q. q May be NULL

--*/

#include "obp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ObInitializeFastReference)
#pragma alloc_text(PAGE,ObFastReferenceObject)
#pragma alloc_text(PAGE,ObFastReferenceObjectLocked)
#pragma alloc_text(PAGE,ObFastDereferenceObject)
#pragma alloc_text(PAGE,ObFastReplaceObject)
#endif

NTKERNELAPI
VOID
FASTCALL
ObInitializeFastReference (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    Initialize a fast reference structure.

Arguments:

    FastRef - Rundown block to be initialized

Return Value:

    None

--*/
{
    //
    // If an object was given then bias the object reference by the cache size.
    //
    if (Object != NULL) {
        ObReferenceObjectEx (Object, ExFastRefGetAdditionalReferenceCount ());
    }
    ExFastRefInitialize (FastRef, Object);
}

NTKERNELAPI
PVOID
FASTCALL
ObFastReferenceObject (
    IN PEX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine attempts a fast reference of an object in a fast ref
    structure.

Arguments:

    FastRef - Rundown block to be used for the reference

Return Value:

    PVOID - Object that was referenced or NULL if we failed

--*/
{
    EX_FAST_REF OldRef;
    PVOID Object;
    ULONG RefsToAdd, Unused;
    //
    // Attempt the fast reference
    //
    OldRef = ExFastReference (FastRef);

    Object = ExFastRefGetObject (OldRef);
    //
    // We fail if there wasn't an object or if it has no cached references
    // left. Both of these cases had the cached reference count zero.
    //
    Unused = ExFastRefGetUnusedReferences (OldRef);

    if (Unused <= 1) {
        if (Unused == 0) {
            return NULL;
        }
        //
        // If we took the counter to zero then attempt to make life easier for
        // the next referencer by resetting the counter to its max. Since we now
        // have a reference to the object we can do this.
        //
        RefsToAdd = ExFastRefGetAdditionalReferenceCount ();
        ObReferenceObjectEx (Object, RefsToAdd);

        //
        // Try to add the added references to the cache. If we fail then just
        // release them.
        //
        if (!ExFastRefAddAdditionalReferenceCounts (FastRef, Object, RefsToAdd)) {
            ObDereferenceObjectEx (Object, RefsToAdd);
        }
    }
    return Object;
}

NTKERNELAPI
PVOID
FASTCALL
ObFastReferenceObjectLocked (
    IN PEX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine does a slow object reference. This must be called while
    holding a lock.

Arguments:

    FastRef - Rundown block to be used to reference the object

Return Value:

    PVOID - Object that was referenced or NULL if there was no object.

--*/
{
    PVOID Object;
    EX_FAST_REF OldRef;

    OldRef = *FastRef;
    Object = ExFastRefGetObject (OldRef);
    if (Object != NULL) {
        ObReferenceObject (Object);
    }
    return Object;
}

NTKERNELAPI
VOID
FASTCALL
ObFastDereferenceObject (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    This routine does a fast dereference if possible.

Arguments:

    FastRef - Rundown block to be used to dereference the object

Return Value:

    None.

--*/
{
    if (!ExFastRefDereference (FastRef, Object)) {
        //
        // If the object changed or there is no space left in the reference
        // cache then just deref the object.
        //
        ObDereferenceObject (Object);
    }
}

NTKERNELAPI
PVOID
FASTCALL
ObFastReplaceObject (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    This routine does a swap of the object. This must be called while holding
    a lock.

Arguments:

    FastRef - Rundown block to be used to do the swap.

Return Value:

    PVOID - Object that was in the block before the swap..

--*/
{
    EX_FAST_REF OldRef;
    PVOID OldObject;
    ULONG RefsToReturn;

    //
    // If we have been given an object then bias it by the correct amount.
    //
    if (Object != NULL) {
        ObReferenceObjectEx (Object, ExFastRefGetAdditionalReferenceCount ());
    }
    //
    // Do the swap
    //
    OldRef = ExFastRefSwapObject (FastRef, Object);
    OldObject = ExFastRefGetObject (OldRef);
    //
    // If there was an original object then we need to work out how many
    // cached references there were (if any) and return them.
    //
    if (OldObject != NULL) {
        RefsToReturn = ExFastRefGetUnusedReferences (OldRef);
        if (RefsToReturn > 0) {
            ObDereferenceObjectEx (OldObject, RefsToReturn);
        }
    }
    return OldObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\i386\setmodfy.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   setmodfy.c

Abstract:

    This module contains the setting modify bit routine for memory management.
    x86 specific.

--*/

#include "mi.h"

#if defined (_X86PAE_)
extern PMMPTE MmSystemCacheWorkingSetListPte;
#endif


ULONG
FASTCALL
MiDetermineUserGlobalPteMask (
    IN PMMPTE Pte
    )

/*++

Routine Description:

    Builds a mask to OR with the PTE frame field.
    This mask has the valid and access bits set and
    has the global and owner bits set based on the
    address of the PTE.

    *******************  NOTE *********************************************
        THIS ROUTINE DOES NOT CHECK FOR PDEs WHICH NEED TO BE
        SET GLOBAL AS IT ASSUMES PDEs FOR SYSTEM SPACE ARE
        PROPERLY SET AT INITIALIZATION TIME!

Arguments:

    Pte - Supplies a pointer to the PTE in which to fill.

Return Value:

    Mask to OR into the frame to make a valid PTE.

Environment:

    Kernel mode, 386 specific.

--*/


{
    MMPTE Mask;

    Mask.u.Long = 0;
    Mask.u.Hard.Valid = 1;
    Mask.u.Hard.Accessed = 1;

#if defined (_X86PAE_)
    ASSERT (MmSystemCacheWorkingSetListPte != NULL);
#endif

    if (Pte <= MiHighestUserPte) {
        Mask.u.Hard.Owner = 1;
    }
    else if ((Pte < MiGetPteAddress (PTE_BASE)) ||
#if defined (_X86PAE_)
             (Pte >= MmSystemCacheWorkingSetListPte)
#else
             (Pte >= MiGetPteAddress (MM_SYSTEM_CACHE_WORKING_SET))
#endif
    ) {

        if (MI_IS_SESSION_PTE (Pte) == FALSE) {
#if defined (_X86PAE_)
          if ((Pte < (PMMPTE)PDE_BASE) || (Pte > (PMMPTE)PDE_TOP))
#endif
            Mask.u.Long |= MmPteGlobal.u.Long;
        }
    }
    else if ((Pte >= MiGetPdeAddress (NULL)) && (Pte <= MiHighestUserPde)) {
        Mask.u.Hard.Owner = 1;
    }

    //
    // Since the valid, accessed, global and owner bits are always in the
    // low dword of the PTE, returning a ULONG is ok.
    //

    return (ULONG)Mask.u.Long;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obcreate.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obcreate.c

Abstract:

    Object creation

--*/

#include "obp.h"

#undef ObCreateObject

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ObCreateObject)
#pragma alloc_text(PAGE, ObpCaptureObjectCreateInformation)
#pragma alloc_text(PAGE, ObpCaptureObjectName)
#pragma alloc_text(PAGE, ObpAllocateObjectNameBuffer)
#pragma alloc_text(PAGE, ObpFreeObjectNameBuffer)
#pragma alloc_text(PAGE, ObDeleteCapturedInsertInfo)
#pragma alloc_text(PAGE, ObpAllocateObject)
#pragma alloc_text(PAGE, ObpFreeObject)
#pragma alloc_text(PAGE, ObFreeObjectCreateInfoBuffer)
#endif


#if DBG

BOOLEAN ObWatchHandles = FALSE;

//
//  The following variable is only used on a checked build to control
//  echoing out the allocs and frees of objects
//

BOOLEAN ObpShowAllocAndFree;
#else

const BOOLEAN ObWatchHandles = FALSE;

#endif

//
//  Local performance counters
//

#if DBG
ULONG ObpObjectsCreated;
ULONG ObpObjectsWithPoolQuota;
ULONG ObpObjectsWithHandleDB;
ULONG ObpObjectsWithName;
ULONG ObpObjectsWithCreatorInfo;
#endif // DBG

C_ASSERT ( (FIELD_OFFSET (OBJECT_HEADER, Body) % MEMORY_ALLOCATION_ALIGNMENT) == 0 );
C_ASSERT ( (sizeof (OBJECT_HEADER_CREATOR_INFO) % MEMORY_ALLOCATION_ALIGNMENT) == 0 );
C_ASSERT ( (sizeof (OBJECT_HEADER_NAME_INFO) % MEMORY_ALLOCATION_ALIGNMENT) == 0 );
C_ASSERT ( (sizeof (OBJECT_HEADER_QUOTA_INFO) % MEMORY_ALLOCATION_ALIGNMENT) == 0 );


NTSTATUS
ObCreateObject (
    __in KPROCESSOR_MODE ProbeMode,
    __in POBJECT_TYPE ObjectType,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in KPROCESSOR_MODE OwnershipMode,
    __inout_opt PVOID ParseContext,
    __in ULONG ObjectBodySize,
    __in ULONG PagedPoolCharge,
    __in ULONG NonPagedPoolCharge,
    __out PVOID *Object
    )

/*++

Routine Description:

    This functions allocates space for an NT Object from either
    Paged or NonPaged pool. It captures the optional name and
    SECURITY_DESCRIPTOR parameters for later use when the object is
    inserted into an object table.  No quota is charged at this time.
    That occurs when the object is inserted into an object table.

Arguments:

    ProbeMode - The processor mode to consider when doing a probe
        of the input parameters

    ObjectType - A pointer of the type returned by ObCreateObjectType
        that gives the type of object being created.

    ObjectAttributes - Optionally supplies the attributes of the object
        being created (such as its name)

    OwnershipMode - The processor mode of who is going to own the object

    ParseContext - Ignored

    ObjectBodySize - Number of bytes to allocate for the object body.  The
        object body immediately follows the object header in memory and are
        part of a single allocation.

    PagedPoolCharge - Supplies the amount of paged pool to charge for the
        object.  If zero is specified then the default charge for the object
        type is used.

    NonPagedPoolCharge - Supplies the amount of nonpaged pool to charge for
        the object.  If zero is specified then the default charge for the
        object type is used.

    Object - Receives a pointer to the newly created object

Return Value:

    Following errors can occur:

        - invalid object type
        - insufficient memory

--*/

{
    UNICODE_STRING CapturedObjectName;
    POBJECT_CREATE_INFORMATION ObjectCreateInfo;
    POBJECT_HEADER ObjectHeader;
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ParseContext);

    //
    //  Allocate a buffer to capture the object creation information.
    //

    ObjectCreateInfo = ObpAllocateObjectCreateInfoBuffer();

    if (ObjectCreateInfo == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        //  Capture the object attributes, quality of service, and object
        //  name, if specified. Otherwise, initialize the captured object
        //  name, the security quality of service, and the create attributes
        //  to default values.
        //

        Status = ObpCaptureObjectCreateInformation( ObjectType,
                                                    ProbeMode,
                                                    OwnershipMode,
                                                    ObjectAttributes,
                                                    &CapturedObjectName,
                                                    ObjectCreateInfo,
                                                    FALSE );

        if (NT_SUCCESS(Status)) {

            //
            //  If the creation attributes are invalid, then return an error
            //  status.
            //

            if (ObjectType->TypeInfo.InvalidAttributes & ObjectCreateInfo->Attributes) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                //
                //  Set the paged and nonpaged pool quota charges for the
                //  object allocation.
                //

                if (PagedPoolCharge == 0) {

                    PagedPoolCharge = ObjectType->TypeInfo.DefaultPagedPoolCharge;
                }

                if (NonPagedPoolCharge == 0) {

                    NonPagedPoolCharge = ObjectType->TypeInfo.DefaultNonPagedPoolCharge;
                }

                ObjectCreateInfo->PagedPoolCharge = PagedPoolCharge;
                ObjectCreateInfo->NonPagedPoolCharge = NonPagedPoolCharge;

                //
                //  Allocate and initialize the object.
                //

                Status = ObpAllocateObject( ObjectCreateInfo,
                                            OwnershipMode,
                                            ObjectType,
                                            &CapturedObjectName,
                                            ObjectBodySize,
                                            &ObjectHeader );

                if (NT_SUCCESS(Status)) {

                    //
                    //  If a permanent object is being created, then check if
                    //  the caller has the appropriate privilege.
                    //

                    *Object = &ObjectHeader->Body;

                    if (ObjectHeader->Flags & OB_FLAG_PERMANENT_OBJECT) {

                        if (!SeSinglePrivilegeCheck( SeCreatePermanentPrivilege,
                                                     ProbeMode)) {

                            ObpFreeObject(*Object);

                            Status = STATUS_PRIVILEGE_NOT_HELD;
                        }
                    }

#ifdef POOL_TAGGING
                    if (ObpTraceEnabled && NT_SUCCESS(Status)) {

                        //
                        //  Register the object and push stack information for the
                        //  first reference
                        //

                        ObpRegisterObject( ObjectHeader );
                        ObpPushStackInfo( ObjectHeader, TRUE );
                    }
#endif //POOL_TAGGING

                    //
                    //  Here is the only successful path out of this module but
                    //  this path can also return privilege not held.  In the 
                    //  error case, all the resources have already been freed
                    //  by ObpFreeObject.
                    //

                    return Status;
                }
            }

            //
            //  An error path, free the create information.
            //

            ObpReleaseObjectCreateInformation(ObjectCreateInfo);

            if (CapturedObjectName.Buffer != NULL) {

                ObpFreeObjectNameBuffer(&CapturedObjectName);
            }
        }

        //
        //  An error path, free object creation information buffer.
        //

        ObpFreeObjectCreateInfoBuffer(ObjectCreateInfo);
    }

    //
    //  An error path
    //

    return Status;
}


NTSTATUS
ObpCaptureObjectCreateInformation (
    IN POBJECT_TYPE ObjectType OPTIONAL,
    IN KPROCESSOR_MODE ProbeMode,
    IN KPROCESSOR_MODE CreatorMode,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OUT PUNICODE_STRING CapturedObjectName,
    IN POBJECT_CREATE_INFORMATION ObjectCreateInfo,
    IN LOGICAL UseLookaside
    )

/*++

Routine Description:

    This function captures the object creation information and stuff
    it into the input variable ObjectCreateInfo

Arguments:

    ObjectType - Specifies the type of object we expect to capture,
        currently ignored.

    ProbeMode - Specifies the processor mode for doing our parameter
        probes

    CreatorMode - Specifies the mode the object is being created for

    ObjectAttributes - Supplies the object attributes we are trying
        to capture

    CapturedObjectName - Receives the name of the object being created

    ObjectCreateInfo - Receives the create information for the object
        like its root, attributes, and security information

    UseLookaside - Specifies if we are to allocate the captured name
        buffer from the lookaside list or from straight pool.

Return Value:

    An appropriate status value

--*/

{
    PUNICODE_STRING ObjectName;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    NTSTATUS Status;
    ULONG Size;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ObjectType);

    //
    //  Capture the object attributes, the security quality of service, if
    //  specified, and object name, if specified.
    //

    Status = STATUS_SUCCESS;

    RtlZeroMemory(ObjectCreateInfo, sizeof(OBJECT_CREATE_INFORMATION));

    try {

        if (ARGUMENT_PRESENT(ObjectAttributes)) {

            //
            //  Probe the object attributes if necessary.
            //

            if (ProbeMode != KernelMode) {

                ProbeForReadSmallStructure( ObjectAttributes,
                                            sizeof(OBJECT_ATTRIBUTES),
                                            sizeof(ULONG_PTR) );
            }

            if (ObjectAttributes->Length != sizeof(OBJECT_ATTRIBUTES) ||
                (ObjectAttributes->Attributes & ~OBJ_ALL_VALID_ATTRIBUTES)) {

                Status = STATUS_INVALID_PARAMETER;

                goto failureExit;
            }

            //
            //  Capture the object attributes.
            //

            ObjectCreateInfo->RootDirectory = ObjectAttributes->RootDirectory;
            ObjectCreateInfo->Attributes = ObjectAttributes->Attributes & OBJ_ALL_VALID_ATTRIBUTES;
            //
            // Remove privileged option if passed in from user mode
            //
            if (CreatorMode != KernelMode) {
                ObjectCreateInfo->Attributes &= ~OBJ_KERNEL_HANDLE;
            } else if (ObWatchHandles) {
                if ((ObjectCreateInfo->Attributes&OBJ_KERNEL_HANDLE) == 0 &&
                    PsGetCurrentProcess() != PsInitialSystemProcess) {
                    DbgBreakPoint ();
                }
            }
            ObjectName = ObjectAttributes->ObjectName;
            SecurityDescriptor = ObjectAttributes->SecurityDescriptor;
            SecurityQos = ObjectAttributes->SecurityQualityOfService;

            if (ARGUMENT_PRESENT(SecurityDescriptor)) {

                Status = SeCaptureSecurityDescriptor( SecurityDescriptor,
                                                      ProbeMode,
                                                      PagedPool,
                                                      TRUE,
                                                      &ObjectCreateInfo->SecurityDescriptor );

                if (!NT_SUCCESS(Status)) {

                    KdPrint(( "OB: Failed to capture security descriptor at %08x - Status == %08x\n",
                              SecurityDescriptor,
                              Status) );

                    //
                    //  The cleanup routine depends on this being NULL if it isn't
                    //  allocated.  SeCaptureSecurityDescriptor may modify this
                    //  parameter even if it fails.
                    //

                    ObjectCreateInfo->SecurityDescriptor = NULL;

                    goto failureExit;
                }

                SeComputeQuotaInformationSize(  ObjectCreateInfo->SecurityDescriptor,
                                                &Size );

                ObjectCreateInfo->SecurityDescriptorCharge = SeComputeSecurityQuota( Size );
                ObjectCreateInfo->ProbeMode = ProbeMode;
            }

            if (ARGUMENT_PRESENT(SecurityQos)) {

                if (ProbeMode != KernelMode) {

                    ProbeForReadSmallStructure( SecurityQos, sizeof(*SecurityQos), sizeof(ULONG));
                }

                ObjectCreateInfo->SecurityQualityOfService = *SecurityQos;
                ObjectCreateInfo->SecurityQos = &ObjectCreateInfo->SecurityQualityOfService;
            }

        } else {

            ObjectName = NULL;
        }

    } except (ExSystemExceptionFilter()) {

        Status = GetExceptionCode();

        goto failureExit;
    }

    //
    //  If an object name is specified, then capture the object name.
    //  Otherwise, initialize the object name descriptor and check for
    //  an incorrectly specified root directory.
    //

    if (ARGUMENT_PRESENT(ObjectName)) {

        Status = ObpCaptureObjectName( ProbeMode,
                                       ObjectName,
                                       CapturedObjectName,
                                       UseLookaside );

    } else {

        CapturedObjectName->Buffer = NULL;
        CapturedObjectName->Length = 0;
        CapturedObjectName->MaximumLength = 0;

        if (ARGUMENT_PRESENT(ObjectCreateInfo->RootDirectory)) {

            Status = STATUS_OBJECT_NAME_INVALID;
        }
    }

    //
    //  If the completion status is not successful, and a security quality
    //  of service parameter was specified, then free the security quality
    //  of service memory.
    //

failureExit:

    if (!NT_SUCCESS(Status)) {

        ObpReleaseObjectCreateInformation(ObjectCreateInfo);
    }

    return Status;
}


NTSTATUS
ObpCaptureObjectName (
    IN KPROCESSOR_MODE ProbeMode,
    IN PUNICODE_STRING ObjectName,
    IN OUT PUNICODE_STRING CapturedObjectName,
    IN LOGICAL UseLookaside
    )

/*++

Routine Description:

    This function captures the object name but first verifies that
    it is at least properly sized.

Arguments:

    ProbeMode - Supplies the processor mode to use when probing
        the object name

    ObjectName - Supplies the caller's version of the object name

    CapturedObjectName - Receives the captured verified version
        of the object name

    UseLookaside - Indicates if the captured name buffer should be
        allocated from the lookaside list or from straight pool

Return Value:

    An appropriate status value

--*/

{
    PWCH FreeBuffer;
    UNICODE_STRING InputObjectName;
    ULONG Length;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Initialize the object name descriptor and capture the specified name
    //  string.
    //

    CapturedObjectName->Buffer = NULL;
    CapturedObjectName->Length = 0;
    CapturedObjectName->MaximumLength = 0;

    Status = STATUS_SUCCESS;

    //
    //  Probe and capture the name string descriptor and probe the
    //  name string, if necessary.
    //

    FreeBuffer = NULL;

    try {

        if (ProbeMode != KernelMode) {

            ProbeAndReadUnicodeStringEx(&InputObjectName, ObjectName);

            ProbeForRead( InputObjectName.Buffer,
                          InputObjectName.Length,
                          sizeof(WCHAR) );

        } else {

            InputObjectName = *ObjectName;
        }

        //
        //  If the length of the string is not zero, then capture the string.
        //

        if (InputObjectName.Length != 0) {

            //
            //  If the length of the string is not an even multiple of the
            //  size of a UNICODE character or cannot be zero terminated,
            //  then return an error.
            //

            Length = InputObjectName.Length;

            if (((Length & (sizeof(WCHAR) - 1)) != 0) ||
                (Length == (MAXUSHORT - sizeof(WCHAR) + 1))) {

                Status = STATUS_OBJECT_NAME_INVALID;

            } else {

                //
                //  Allocate a buffer for the specified name string.
                //
                //  N.B. The name buffer allocation routine adds one
                //       UNICODE character to the length and initializes
                //       the string descriptor.
                //

                FreeBuffer = ObpAllocateObjectNameBuffer( Length,
                                                          UseLookaside,
                                                          CapturedObjectName );

                if (FreeBuffer == NULL) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    //  Copy the specified name string to the destination
                    //  buffer.
                    //

                    RtlCopyMemory(FreeBuffer, InputObjectName.Buffer, Length);

                    //
                    //  Zero terminate the name string and initialize the
                    //  string descriptor.
                    //

                    FreeBuffer[Length / sizeof(WCHAR)] = UNICODE_NULL;
                }
            }
        }

    } except(ExSystemExceptionFilter()) {

        Status = GetExceptionCode();

        if (FreeBuffer != NULL) {

            ExFreePool(FreeBuffer);
        }
    }

    return Status;
}


PWCHAR
ObpAllocateObjectNameBuffer (
    IN ULONG Length,
    IN LOGICAL UseLookaside,
    IN OUT PUNICODE_STRING ObjectName
    )

/*++

Routine Description:

    This function allocates an object name buffer.

    N.B. This function is nonpageable.

Arguments:

    Length - Supplies the length of the required buffer in bytes.

    UseLookaside - Supplies a logical variable that determines whether an
        attempt is made to allocate the name buffer from the lookaside list.

    ObjectName - Supplies a pointer to a name buffer string descriptor.

Return Value:

    If the allocation is successful, then name buffer string descriptor
    is initialized and the address of the name buffer is returned as the
    function value. Otherwise, a value of NULL is returned.

--*/

{
    PVOID Buffer;
    ULONG Maximum;

    //
    //  If allocation from the lookaside lists is specified and the buffer
    //  size is less than the size of lookaside list entries, then attempt
    //  to allocate the name buffer from the lookaside lists. Otherwise,
    //  attempt to allocate the name buffer from nonpaged pool.
    //

    Maximum = Length + sizeof(WCHAR);

    if ((UseLookaside == FALSE) || (Maximum > OBJECT_NAME_BUFFER_SIZE)) {

        //
        //  Attempt to allocate the buffer from nonpaged pool.
        //

        Buffer = ExAllocatePoolWithTag( OB_NAMESPACE_POOL_TYPE , Maximum, 'mNbO' );

    } else {

        //
        //  Attempt to allocate the name buffer from the lookaside list. If
        //  the allocation attempt fails, then attempt to allocate the name
        //  buffer from pool.
        //

        Maximum = OBJECT_NAME_BUFFER_SIZE;
        Buffer = ExAllocateFromPPLookasideList(LookasideNameBufferList);
    }

    //
    //  Initialize the string descriptor and return the buffer address.
    //

    ObjectName->Length = (USHORT)Length;
    ObjectName->MaximumLength = (USHORT)Maximum;
    ObjectName->Buffer = Buffer;

    return (PWCHAR)Buffer;
}


VOID
FASTCALL
ObpFreeObjectNameBuffer (
    OUT PUNICODE_STRING ObjectName
    )

/*++

Routine Description:

    This function frees an object name buffer.

    N.B. This function is nonpageable.

Arguments:

    ObjectName - Supplies a pointer to a name buffer string descriptor.

Return Value:

    None.

--*/

{
    PVOID Buffer;

    //
    //  If the size of the buffer is not equal to the size of lookaside list
    //  entries, then  free the buffer to pool. Otherwise, free the buffer to
    //  the lookaside list.
    //

    Buffer = ObjectName->Buffer;

    if (ObjectName->MaximumLength != OBJECT_NAME_BUFFER_SIZE) {
        ExFreePool(Buffer);

    } else {
        ExFreeToPPLookasideList(LookasideNameBufferList, Buffer);
    }

    return;
}


NTKERNELAPI
VOID
ObDeleteCapturedInsertInfo (
    __in PVOID Object
    )

/*++

Routine Description:

    This function frees the creation information that could be pointed at
    by the object header.

Arguments:

    Object - Supplies the object being modified

Return Value:

    None.

--*/

{
    POBJECT_HEADER ObjectHeader;

    PAGED_CODE();

    //
    //  Get the address of the object header and free the object create
    //  information object if the object is being created.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

    if (ObjectHeader->Flags & OB_FLAG_NEW_OBJECT) {

        if (ObjectHeader->ObjectCreateInfo != NULL) {

            ObpFreeObjectCreateInformation(ObjectHeader->ObjectCreateInfo);

            ObjectHeader->ObjectCreateInfo = NULL;
        }
    }

    return;
}


NTSTATUS
ObpAllocateObject (
    IN POBJECT_CREATE_INFORMATION ObjectCreateInfo,
    IN KPROCESSOR_MODE OwnershipMode,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    IN PUNICODE_STRING ObjectName,
    IN ULONG ObjectBodySize,
    OUT POBJECT_HEADER *ReturnedObjectHeader
    )

/*++

Routine Description:

    This routine allocates a new object including the object header
    and body from pool and fill in the appropriate fields.

Arguments:

    ObjectCreateInfo - Supplies the create information for the new object

    OwnershipMode - Supplies the processor mode of who is going to own
        the object

    ObjectType - Optionally supplies the object type of the object being
        created. If the object create info not null then this field must
        be supplied.

    ObjectName - Supplies the name of the object being created

    ObjectBodySize - Specifies the size, in bytes, of the body of the object
        being created

    ReturnedObjectHeader - Receives a pointer to the object header for the
        newly created objet.

Return Value:

    An appropriate status value.

--*/

{
    ULONG HeaderSize;
    POBJECT_HEADER ObjectHeader;
    ULONG QuotaInfoSize;
    ULONG HandleInfoSize;
    ULONG NameInfoSize;
    ULONG CreatorInfoSize;
    POBJECT_HEADER_QUOTA_INFO QuotaInfo;
    POBJECT_HEADER_HANDLE_INFO HandleInfo;
    POBJECT_HEADER_NAME_INFO NameInfo;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POOL_TYPE PoolType;

    PAGED_CODE();

#if DBG
    ObpObjectsCreated += 1;
#endif // DBG

    //
    //  Compute the sizes of the optional object header components.
    //

    if (ObjectCreateInfo == NULL) {

        QuotaInfoSize = 0;
        HandleInfoSize = 0;
        NameInfoSize = sizeof( OBJECT_HEADER_NAME_INFO );
        CreatorInfoSize = sizeof( OBJECT_HEADER_CREATOR_INFO );

    } else {

        //
        //  The caller specified some additional object create info
        //
        //  First check to see if we need to set the quota
        //

        if (((ObjectCreateInfo->PagedPoolCharge != ObjectType->TypeInfo.DefaultPagedPoolCharge ||
              ObjectCreateInfo->NonPagedPoolCharge != ObjectType->TypeInfo.DefaultNonPagedPoolCharge ||
              ObjectCreateInfo->SecurityDescriptorCharge > SE_DEFAULT_SECURITY_QUOTA) &&
                 PsGetCurrentProcess() != PsInitialSystemProcess) ||
            (ObjectCreateInfo->Attributes & OBJ_EXCLUSIVE)) {

            QuotaInfoSize = sizeof( OBJECT_HEADER_QUOTA_INFO );
#if DBG
            ObpObjectsWithPoolQuota += 1;
#endif // DBG

        } else {

            QuotaInfoSize = 0;
        }

        //
        //  Check if we are to allocate space to maintain handle counts
        //

        if (ObjectType->TypeInfo.MaintainHandleCount) {

            HandleInfoSize = sizeof( OBJECT_HEADER_HANDLE_INFO );
#if DBG
            ObpObjectsWithHandleDB += 1;
#endif // DBG

        } else {

            HandleInfoSize = 0;
        }

        //
        //  Check if we are to allocate space for the name
        //

        if (ObjectName->Buffer != NULL) {

            NameInfoSize = sizeof( OBJECT_HEADER_NAME_INFO );
#if DBG
            ObpObjectsWithName += 1;
#endif // DBG

        } else {

            NameInfoSize = 0;
        }

        //
        //  Finally check if we are to maintain the creator info
        //

        if (ObjectType->TypeInfo.MaintainTypeList) {

            CreatorInfoSize = sizeof( OBJECT_HEADER_CREATOR_INFO );
#if DBG
            ObpObjectsWithCreatorInfo += 1;
#endif // DBG

        } else {

            CreatorInfoSize = 0;
        }
    }

    //
    //  Now compute the total header size
    //

    HeaderSize = QuotaInfoSize +
                 HandleInfoSize +
                 NameInfoSize +
                 CreatorInfoSize +
                 FIELD_OFFSET( OBJECT_HEADER, Body );

    //
    //  Allocate and initialize the object.
    //
    //  If the object type is not specified or specifies nonpaged pool,
    //  then allocate the object from nonpaged pool.
    //  Otherwise, allocate the object from paged pool.
    //

    if ((ObjectType == NULL) || (ObjectType->TypeInfo.PoolType == NonPagedPool)) {

        PoolType = NonPagedPool;

    } else {

        PoolType = PagedPool;
    }

    ObjectHeader = ExAllocatePoolWithTag( PoolType,
                                          HeaderSize + ObjectBodySize,
                                          (ObjectType == NULL ? 'TjbO' : ObjectType->Key) |
                                            PROTECTED_POOL );

    if (ObjectHeader == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Now based on if we are to put in the quota, handle, name, or creator info we
    //  will do the extra work.  This order is very important because we rely on
    //  it to free the object.
    //

    if (QuotaInfoSize != 0) {

        QuotaInfo = (POBJECT_HEADER_QUOTA_INFO)ObjectHeader;
        QuotaInfo->PagedPoolCharge = ObjectCreateInfo->PagedPoolCharge;
        QuotaInfo->NonPagedPoolCharge = ObjectCreateInfo->NonPagedPoolCharge;
        QuotaInfo->SecurityDescriptorCharge = ObjectCreateInfo->SecurityDescriptorCharge;
        QuotaInfo->ExclusiveProcess = NULL;
        ObjectHeader = (POBJECT_HEADER)(QuotaInfo + 1);
    }

    if (HandleInfoSize != 0) {

        HandleInfo = (POBJECT_HEADER_HANDLE_INFO)ObjectHeader;
        HandleInfo->SingleEntry.HandleCount = 0;
        ObjectHeader = (POBJECT_HEADER)(HandleInfo + 1);
    }

    if (NameInfoSize != 0) {

        NameInfo = (POBJECT_HEADER_NAME_INFO)ObjectHeader;
        NameInfo->Name = *ObjectName;
        NameInfo->Directory = NULL;
        NameInfo->QueryReferences = 1;

        if ( (OwnershipMode == KernelMode) 
                && 
             (ObjectCreateInfo != NULL)
                &&
             (ObjectCreateInfo->Attributes & OBJ_KERNEL_EXCLUSIVE) ) {

            NameInfo->QueryReferences |= OBP_NAME_KERNEL_PROTECTED;
        }
       
        ObjectHeader = (POBJECT_HEADER)(NameInfo + 1);
    }

    if (CreatorInfoSize != 0) {

        CreatorInfo = (POBJECT_HEADER_CREATOR_INFO)ObjectHeader;
        CreatorInfo->CreatorBackTraceIndex = 0;
        CreatorInfo->CreatorUniqueProcess = PsGetCurrentProcess()->UniqueProcessId;
        InitializeListHead( &CreatorInfo->TypeList );

        PERFINFO_ADD_OBJECT_TO_ALLOCATED_TYPE_LIST(CreatorInfo, ObjectType);

        ObjectHeader = (POBJECT_HEADER)(CreatorInfo + 1);
    }

    //
    //  Compute the proper offsets based on what we have
    //

    if (QuotaInfoSize != 0) {

        ObjectHeader->QuotaInfoOffset = (UCHAR)(QuotaInfoSize + HandleInfoSize + NameInfoSize + CreatorInfoSize);

    } else {

        ObjectHeader->QuotaInfoOffset = 0;
    }

    if (HandleInfoSize != 0) {

        ObjectHeader->HandleInfoOffset = (UCHAR)(HandleInfoSize + NameInfoSize + CreatorInfoSize);

    } else {

        ObjectHeader->HandleInfoOffset = 0;
    }

    if (NameInfoSize != 0) {

        ObjectHeader->NameInfoOffset =  (UCHAR)(NameInfoSize + CreatorInfoSize);

    } else {

        ObjectHeader->NameInfoOffset = 0;
    }

    //
    //  Say that this is a new object, and conditionally set the other flags
    //

    ObjectHeader->Flags = OB_FLAG_NEW_OBJECT;

    if (CreatorInfoSize != 0) {

        ObjectHeader->Flags |= OB_FLAG_CREATOR_INFO;
    }

    if (HandleInfoSize != 0) {

        ObjectHeader->Flags |= OB_FLAG_SINGLE_HANDLE_ENTRY;
    }

    //
    //  Set the counters and its type
    //

    ObjectHeader->PointerCount = 1;
    ObjectHeader->HandleCount = 0;
    ObjectHeader->Type = ObjectType;

    //
    //  Initialize the object header.
    //
    //  N.B. The initialization of the object header is done field by
    //       field rather than zeroing the memory and then initializing
    //       the pertinent fields.
    //
    //  N.B. It is assumed that the caller will initialize the object
    //       attributes, object ownership, and parse context.
    //

    if (OwnershipMode == KernelMode) {

        ObjectHeader->Flags |= OB_FLAG_KERNEL_OBJECT;
    }

    if (ObjectCreateInfo != NULL &&
        ObjectCreateInfo->Attributes & OBJ_PERMANENT ) {

        ObjectHeader->Flags |= OB_FLAG_PERMANENT_OBJECT;
    }

    if ((ObjectCreateInfo != NULL) &&
        (ObjectCreateInfo->Attributes & OBJ_EXCLUSIVE)) {

        ObjectHeader->Flags |= OB_FLAG_EXCLUSIVE_OBJECT;
    }

    ObjectHeader->ObjectCreateInfo = ObjectCreateInfo;
    ObjectHeader->SecurityDescriptor = NULL;

    if (ObjectType != NULL) {

        InterlockedIncrement((PLONG)&ObjectType->TotalNumberOfObjects);

        if (ObjectType->TotalNumberOfObjects > ObjectType->HighWaterNumberOfObjects) {

            ObjectType->HighWaterNumberOfObjects = ObjectType->TotalNumberOfObjects;
        }
    }

#if DBG

    //
    //  On a checked build echo out allocs
    //

    if (ObpShowAllocAndFree) {

        DbgPrint( "OB: Alloc %lx (%lx) %04lu", ObjectHeader, ObjectHeader, ObjectBodySize );

        if (ObjectType) {

            DbgPrint(" - %wZ\n", &ObjectType->Name );

        } else {

            DbgPrint(" - Type\n" );
        }
    }
#endif

    *ReturnedObjectHeader = ObjectHeader;

    return STATUS_SUCCESS;
}


VOID
FASTCALL
ObpFreeObject (
    IN PVOID Object
    )

/*++

Routine Description:

    This routine undoes ObpAllocateObject.  It returns the object back to free pool.

Arguments:

    Object - Supplies a pointer to the body of the object being freed.

Return Value:

    None.

--*/

{
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    POBJECT_HEADER_QUOTA_INFO QuotaInfo;
    POBJECT_HEADER_HANDLE_INFO HandleInfo;
    POBJECT_HEADER_NAME_INFO NameInfo;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    PVOID FreeBuffer;
    ULONG NonPagedPoolCharge;
    ULONG PagedPoolCharge;

    PAGED_CODE();

    //
    //  Get the address of the object header.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);
    ObjectType = ObjectHeader->Type;

    //
    //  Now from the header determine the start of the allocation.  We need
    //  to backup based on what precedes the header.  The order is very
    //  important and must be the inverse of that used by ObpAllocateObject
    //

    FreeBuffer = ObjectHeader;

    CreatorInfo = OBJECT_HEADER_TO_CREATOR_INFO( ObjectHeader );

    if (CreatorInfo != NULL) {

        FreeBuffer = CreatorInfo;
    }

    NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

    if (NameInfo != NULL) {

        FreeBuffer = NameInfo;
    }

    HandleInfo = OBJECT_HEADER_TO_HANDLE_INFO( ObjectHeader );

    if (HandleInfo != NULL) {

        FreeBuffer = HandleInfo;
    }

    QuotaInfo = OBJECT_HEADER_TO_QUOTA_INFO( ObjectHeader );

    if (QuotaInfo != NULL) {

        FreeBuffer = QuotaInfo;
    }

#if DBG

    //
    //  On a checked build echo out frees
    //

    if (ObpShowAllocAndFree) {

        DbgPrint( "OB: Free  %lx (%lx) - Type: %wZ\n", ObjectHeader, ObjectHeader, &ObjectType->Name );
    }
#endif

    //
    //  Decrement the number of objects of this type
    //

    InterlockedDecrement((PLONG)&ObjectType->TotalNumberOfObjects);

    //
    //  Check where we were in the object initialization phase.  This
    //  flag really only tests if we have charged quota for this object.
    //  This is because the object create info and the quota block charged
    //  are unioned together.
    //

    if (ObjectHeader->Flags & OB_FLAG_NEW_OBJECT) {

        if (ObjectHeader->ObjectCreateInfo != NULL) {

            ObpFreeObjectCreateInformation( ObjectHeader->ObjectCreateInfo );

            ObjectHeader->ObjectCreateInfo = NULL;
        }

    } else {

        if (ObjectHeader->QuotaBlockCharged != NULL) {

            if (QuotaInfo != NULL) {

                PagedPoolCharge = QuotaInfo->PagedPoolCharge +
                                  QuotaInfo->SecurityDescriptorCharge;

                NonPagedPoolCharge = QuotaInfo->NonPagedPoolCharge;

            } else {

                PagedPoolCharge = ObjectType->TypeInfo.DefaultPagedPoolCharge;

                if (ObjectHeader->Flags & OB_FLAG_DEFAULT_SECURITY_QUOTA ) {

                    PagedPoolCharge += SE_DEFAULT_SECURITY_QUOTA;
                }

                NonPagedPoolCharge = ObjectType->TypeInfo.DefaultNonPagedPoolCharge;
            }

            PsReturnSharedPoolQuota( ObjectHeader->QuotaBlockCharged,
                                     PagedPoolCharge,
                                     NonPagedPoolCharge );

            ObjectHeader->QuotaBlockCharged = NULL;
        }
    }

    if ((HandleInfo != NULL) &&
        ((ObjectHeader->Flags & OB_FLAG_SINGLE_HANDLE_ENTRY) == 0)) {

        //
        //  If a handle database has been allocated, then free the memory.
        //

        ExFreePool( HandleInfo->HandleCountDataBase );

        HandleInfo->HandleCountDataBase = NULL;
    }

    //
    //  If a name string buffer has been allocated, then free the memory.
    //

    if (NameInfo != NULL && NameInfo->Name.Buffer != NULL) {

        ExFreePool( NameInfo->Name.Buffer );

        NameInfo->Name.Buffer = NULL;
    }

    PERFINFO_REMOVE_OBJECT_FROM_ALLOCATED_TYPE_LIST(CreatorInfo, ObjectHeader);

    //
    //  Trash type field so we don't get far if we attempt to
    //  use a stale object pointer to this object.
    //
    //  Win64 Note: trash it by zero-extended it. 
    //                sign-extension will create a valid kernel address.


    ObjectHeader->Type = UIntToPtr(0xBAD0B0B0); 
    ExFreePoolWithTag( FreeBuffer,
                       (ObjectType == NULL ? 'TjbO' : ObjectType->Key) |
                            PROTECTED_POOL );

    return;
}


VOID
FASTCALL
ObFreeObjectCreateInfoBuffer (
    IN POBJECT_CREATE_INFORMATION ObjectCreateInfo
    )

/*++

Routine Description:

    This function frees a create information buffer.  Called from IO component

    N.B. This function is nonpageable.

Arguments:

    ObjectCreateInfo - Supplies a pointer to a create information buffer.

Return Value:

    None.

--*/

{
    ObpFreeObjectCreateInfoBuffer( ObjectCreateInfo );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\i386\procx86.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    procx86.c

Abstract:

    This module contains machine-specific
    routines to support the process structure.

--*/


#include "mi.h"

extern SIZE_T MmProcessCommit;

#if !defined(_X86PAE_)


BOOLEAN
MmCreateProcessAddressSpace (
    IN ULONG MinimumWorkingSetSize,
    IN PEPROCESS NewProcess,
    OUT PULONG_PTR DirectoryTableBase
    )

/*++

Routine Description:

    This routine creates an address space which maps the system
    portion and contains a hyper space entry.

Arguments:

    MinimumWorkingSetSize - Supplies the minimum working set size for
                            this address space.  This value is only used
                            to ensure that ample physical pages exist
                            to create this process.

    NewProcess - Supplies a pointer to the process object being created.

    DirectoryTableBase - Returns the value of the newly created
                         address space's Page Directory (PD) page and
                         hyper space page.

Return Value:

    Returns TRUE if an address space was successfully created, FALSE
    if ample physical pages do not exist.

Environment:

    Kernel mode.  APCs Disabled.

--*/

{
    LOGICAL FlushTbNeeded;
    PFN_NUMBER PageDirectoryIndex;
    PFN_NUMBER HyperSpaceIndex;
    PFN_NUMBER PageContainingWorkingSet;
    PFN_NUMBER VadBitMapPage;
    MMPTE TempPte;
    MMPTE TempPte2;
    PEPROCESS CurrentProcess;
    KIRQL OldIrql;
    PMMPFN Pfn1;
    ULONG Color;
    PMMPTE PointerPte;
    ULONG PdeOffset;
    PMMPTE MappingPte;
    PMMPTE PointerFillPte;
    PMMPTE CurrentAddressSpacePde;

    //
    // Charge commitment for the page directory pages, working set page table
    // page, and working set list.  If Vad bitmap lookups are enabled, then
    // charge for a page or two for that as well.
    //

    if (MiChargeCommitment (MM_PROCESS_COMMIT_CHARGE, NULL) == FALSE) {
        return FALSE;
    }

    FlushTbNeeded = FALSE;
    CurrentProcess = PsGetCurrentProcess ();

    NewProcess->NextPageColor = (USHORT) (RtlRandom (&MmProcessColorSeed));
    KeInitializeSpinLock (&NewProcess->HyperSpaceLock);

    //
    // Get the PFN lock to get physical pages.
    //

    LOCK_PFN (OldIrql);

    //
    // Check to make sure the physical pages are available.
    //

    if (MI_NONPAGEABLE_MEMORY_AVAILABLE() <= (SPFN_NUMBER)MinimumWorkingSetSize){

        UNLOCK_PFN (OldIrql);
        MiReturnCommitment (MM_PROCESS_COMMIT_CHARGE);

        //
        // Indicate no directory base was allocated.
        //

        return FALSE;
    }

    MM_TRACK_COMMIT (MM_DBG_COMMIT_PROCESS_CREATE, MM_PROCESS_COMMIT_CHARGE);

    MI_DECREMENT_RESIDENT_AVAILABLE (MinimumWorkingSetSize,
                                     MM_RESAVAIL_ALLOCATE_CREATE_PROCESS);

    //
    // Allocate a page directory page.
    //

    if (MmAvailablePages < MM_HIGH_LIMIT) {
        MiEnsureAvailablePageOrWait (NULL, OldIrql);
    }

    Color =  MI_PAGE_COLOR_PTE_PROCESS (PDE_BASE,
                                        &CurrentProcess->NextPageColor);

    PageDirectoryIndex = MiRemoveZeroPageMayReleaseLocks (Color, OldIrql);

    Pfn1 = MI_PFN_ELEMENT (PageDirectoryIndex);

    if (Pfn1->u3.e1.CacheAttribute != MiCached) {
        Pfn1->u3.e1.CacheAttribute = MiCached;
        FlushTbNeeded = TRUE;
    }

    //
    // Allocate the hyper space page table page.
    //

    if (MmAvailablePages < MM_HIGH_LIMIT) {
        MiEnsureAvailablePageOrWait (NULL, OldIrql);
    }

    Color = MI_PAGE_COLOR_PTE_PROCESS (MiGetPdeAddress(HYPER_SPACE),
                                       &CurrentProcess->NextPageColor);

    HyperSpaceIndex = MiRemoveZeroPageMayReleaseLocks (Color, OldIrql);

    Pfn1 = MI_PFN_ELEMENT (HyperSpaceIndex);

    if (Pfn1->u3.e1.CacheAttribute != MiCached) {
        Pfn1->u3.e1.CacheAttribute = MiCached;
        FlushTbNeeded = TRUE;
    }

    //
    // Remove page(s) for the VAD bitmap.
    //

    if (MmAvailablePages < MM_HIGH_LIMIT) {
        MiEnsureAvailablePageOrWait (NULL, OldIrql);
    }

    Color = MI_PAGE_COLOR_VA_PROCESS (MmWorkingSetList,
                                      &CurrentProcess->NextPageColor);

    VadBitMapPage = MiRemoveZeroPageMayReleaseLocks (Color, OldIrql);

    Pfn1 = MI_PFN_ELEMENT (VadBitMapPage);

    if (Pfn1->u3.e1.CacheAttribute != MiCached) {
        Pfn1->u3.e1.CacheAttribute = MiCached;
        FlushTbNeeded = TRUE;
    }

    //
    // Remove a page for the working set list.
    //

    if (MmAvailablePages < MM_HIGH_LIMIT) {
        MiEnsureAvailablePageOrWait (NULL, OldIrql);
    }

    Color = MI_PAGE_COLOR_VA_PROCESS (MmWorkingSetList,
                                      &CurrentProcess->NextPageColor);

    PageContainingWorkingSet = MiRemoveZeroPageMayReleaseLocks (Color, OldIrql);

    Pfn1 = MI_PFN_ELEMENT (PageContainingWorkingSet);

    if (Pfn1->u3.e1.CacheAttribute != MiCached) {
        Pfn1->u3.e1.CacheAttribute = MiCached;
        FlushTbNeeded = TRUE;
    }

    UNLOCK_PFN (OldIrql);

    if (FlushTbNeeded == TRUE) {
        MI_FLUSH_TB_FOR_CACHED_ATTRIBUTE ();
    }

    ASSERT (NewProcess->AddressSpaceInitialized == 0);
    PS_SET_BITS (&NewProcess->Flags, PS_PROCESS_FLAGS_ADDRESS_SPACE1);
    ASSERT (NewProcess->AddressSpaceInitialized == 1);

    NewProcess->Vm.MinimumWorkingSetSize = MinimumWorkingSetSize;

    NewProcess->WorkingSetPage = PageContainingWorkingSet;

    INITIALIZE_DIRECTORY_TABLE_BASE (&DirectoryTableBase[0], PageDirectoryIndex);

    INITIALIZE_DIRECTORY_TABLE_BASE (&DirectoryTableBase[1], HyperSpaceIndex);

    //
    // Initialize the page reserved for hyper space.
    //

    TempPte = ValidPdePde;
    MI_SET_GLOBAL_STATE (TempPte, 0);

    MappingPte = MiReserveSystemPtes (1, SystemPteSpace);

    if (MappingPte != NULL) {

        MI_MAKE_VALID_KERNEL_PTE (TempPte2,
                                  HyperSpaceIndex,
                                  MM_READWRITE,
                                  MappingPte);

        MI_SET_PTE_DIRTY (TempPte2);

        MI_WRITE_VALID_PTE (MappingPte, TempPte2);

        PointerPte = MiGetVirtualAddressMappedByPte (MappingPte);
    }
    else {
        PointerPte = MiMapPageInHyperSpace (CurrentProcess, HyperSpaceIndex, &OldIrql);
    }

    TempPte.u.Hard.PageFrameNumber = VadBitMapPage;
    PointerPte[MiGetPteOffset(VAD_BITMAP_SPACE)] = TempPte;

    TempPte.u.Hard.PageFrameNumber = PageContainingWorkingSet;
    PointerPte[MiGetPteOffset(MmWorkingSetList)] = TempPte;

    if (MappingPte != NULL) {
        MiReleaseSystemPtes (MappingPte, 1, SystemPteSpace);
    }
    else {
        MiUnmapPageInHyperSpace (CurrentProcess, PointerPte, OldIrql);
    }

    //
    // Set the PTE address in the PFN for the page directory page.
    //

    Pfn1 = MI_PFN_ELEMENT (PageDirectoryIndex);

    Pfn1->PteAddress = (PMMPTE)PDE_BASE;

    TempPte = ValidPdePde;
    TempPte.u.Hard.PageFrameNumber = HyperSpaceIndex;
    MI_SET_GLOBAL_STATE (TempPte, 0);

    //
    // Add the new process to our internal list prior to filling any
    // system PDEs so if a system PDE changes (large page map or unmap)
    // it can mark this process for a subsequent update.
    //

    ASSERT (NewProcess->Pcb.DirectoryTableBase[0] == 0);

    LOCK_EXPANSION (OldIrql);

    InsertTailList (&MmProcessList, &NewProcess->MmProcessLinks);

    UNLOCK_EXPANSION (OldIrql);

    //
    // Map the page directory page in hyperspace.
    //

    MappingPte = MiReserveSystemPtes (1, SystemPteSpace);

    if (MappingPte != NULL) {

        MI_MAKE_VALID_KERNEL_PTE (TempPte2,
                                  PageDirectoryIndex,
                                  MM_READWRITE,
                                  MappingPte);

        MI_SET_PTE_DIRTY (TempPte2);

        MI_WRITE_VALID_PTE (MappingPte, TempPte2);

        PointerPte = MiGetVirtualAddressMappedByPte (MappingPte);
    }
    else {
        PointerPte = MiMapPageInHyperSpace (CurrentProcess, PageDirectoryIndex, &OldIrql);
    }

    PdeOffset = MiGetPdeOffset (MmSystemRangeStart);
    PointerFillPte = &PointerPte[PdeOffset];
    CurrentAddressSpacePde = MiGetPdeAddress (MmSystemRangeStart);

    RtlCopyMemory (PointerFillPte,
                   CurrentAddressSpacePde,
                   PAGE_SIZE - PdeOffset * sizeof (MMPTE));

    //
    // Map the working set page table page.
    //

    PdeOffset = MiGetPdeOffset (HYPER_SPACE);
    PointerPte[PdeOffset] = TempPte;

    //
    // Zero the remaining page directory range used to map the working
    // set list and its hash.
    //

    PdeOffset += 1;
    ASSERT (MiGetPdeOffset (MmHyperSpaceEnd) >= PdeOffset);

    MiZeroMemoryPte (&PointerPte[PdeOffset],
                     (MiGetPdeOffset (MmHyperSpaceEnd) - PdeOffset + 1));

    //
    // Recursively map the page directory page so it points to itself.
    //

    TempPte.u.Hard.PageFrameNumber = PageDirectoryIndex;
    PointerPte[MiGetPdeOffset(PTE_BASE)] = TempPte;

    if (MappingPte != NULL) {
        MiReleaseSystemPtes (MappingPte, 1, SystemPteSpace);
    }
    else {
        MiUnmapPageInHyperSpace (CurrentProcess, PointerPte, OldIrql);
    }

    InterlockedExchangeAddSizeT (&MmProcessCommit, MM_PROCESS_COMMIT_CHARGE);

    //
    // Up the session space reference count.
    //

    MiSessionAddProcess (NewProcess);

    return TRUE;
}

PMMPTE MiLargePageHyperPte;


VOID
MiUpdateSystemPdes (
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This routine updates the system PDEs, typically due to a large page
    system PTE mapping being created or destroyed.  This is rare.

    Note this is only needed for 32-bit platforms (64-bit platforms share
    a common top level system page).

Arguments:

    Process - Supplies a pointer to the process to update.

Return Value:

    None.

Environment:

    Kernel mode, expansion lock held.

    The caller acquired the expansion lock prior to clearing the update
    bit from this process.  We must update the PDEs prior to releasing
    it so that any new updates can also be rippled.

--*/

{
    ULONG i;
    ULONG PdeOffset;
    ULONG PdeEndOffset;
    MMPTE TempPte;
    PFN_NUMBER PageDirectoryIndex;
    PFN_NUMBER TargetPageDirectoryIndex;
    PEPROCESS CurrentProcess;
    PMMPTE PointerPte;
    PMMPTE PointerPde;
    PMMPTE TargetPdePage;
    PMMPTE TargetAddressSpacePde;

    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);

    CurrentProcess = PsGetCurrentProcess ();

    //
    // Map the page directory page in hyperspace.
    // Note for PAE, this is the high 1GB virtual only.
    //

    ASSERT (Process->Pcb.DirectoryTableBase[0] != 0);
    TargetPageDirectoryIndex = Process->Pcb.DirectoryTableBase[0] >> PAGE_SHIFT;

    ASSERT (PsInitialSystemProcess != NULL);
    ASSERT (PsInitialSystemProcess->Pcb.DirectoryTableBase[0] != 0);
    PageDirectoryIndex = PsInitialSystemProcess->Pcb.DirectoryTableBase[0] >> PAGE_SHIFT;

    TempPte = ValidKernelPte;
    TempPte.u.Hard.PageFrameNumber = TargetPageDirectoryIndex;
    ASSERT (MiLargePageHyperPte->u.Long == 0);
    MI_WRITE_VALID_PTE (MiLargePageHyperPte, TempPte);
    TargetPdePage = MiGetVirtualAddressMappedByPte (MiLargePageHyperPte);

    //
    // Map the system process page directory as we know that's always kept
    // up to date.
    //

    PointerPte = MiMapPageInHyperSpaceAtDpc (CurrentProcess,
                                             PageDirectoryIndex);

    //
    // Copy all system PTE ranges.
    //

    for (i = 0; i < MiPteRangeIndex; i += 1) {

        PdeOffset = MiGetPdeOffset (MiPteRanges[i].StartingVa);
        PdeEndOffset = MiGetPdeOffset (MiPteRanges[i].EndingVa);

        PointerPde = &PointerPte[PdeOffset];
        TargetAddressSpacePde = &TargetPdePage[PdeOffset];

        RtlCopyMemory (TargetAddressSpacePde,
                       PointerPde,
                       (PdeEndOffset - PdeOffset + 1) * sizeof (MMPTE));

    }

    MiUnmapPageInHyperSpaceFromDpc (CurrentProcess, PointerPte);

    //
    // Just invalidate the mapping on the current processor as we cannot
    // have context switched.
    //

    MI_WRITE_ZERO_PTE (MiLargePageHyperPte);
    MI_FLUSH_CURRENT_TB_SINGLE (TargetPdePage);

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obclose.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obclose.c

Abstract:

    Object close system service

--*/

#include "obp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtMakeTemporaryObject)
#pragma alloc_text(PAGE,NtClose)
#pragma alloc_text(PAGE,ObMakeTemporaryObject)
#pragma alloc_text(PAGE,ObpCloseHandleTableEntry)
#pragma alloc_text(PAGE,ObCloseHandle)
#pragma alloc_text(PAGE,ObpCloseHandle)
#endif

//
//  Indicates if auditing is enabled so we have to close down the object
//  audit alarm
//

extern BOOLEAN SepAdtAuditingEnabled;

NTSTATUS
ObpCloseHandleTableEntry (
    IN PHANDLE_TABLE ObjectTable,
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN Rundown
    )
/*++

Routine Description:

    This function is used to close a handle table entry

Arguments:

    ObjectTableEntry - Supplies the entry being closed. It must be locked
    PreviousMode     - Mode of caller
    Rundown          - Called as part of process rundown, ignore protected handles in this mode

Return Value:

    NTSTATUS.

--*/
{
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    PVOID Object;
    ULONG CapturedGrantedAccess;
    ULONG CapturedAttributes;
    #if DBG
    KIRQL SaveIrql;
    #endif // DBG

    //
    //  From the object table entry we can grab a pointer to the object
    //  header, get its type and its body
    //

    ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);
    ObjectType = ObjectHeader->Type;
    Object = &ObjectHeader->Body;

    //
    //  If the object type specifies an okay to close procedure then we
    //  need to invoke that callback.  If the callback doesn't want us to
    //  close handle then unlock the object table and return the error
    //  to our caller
    //

    if (ObjectType->TypeInfo.OkayToCloseProcedure != NULL) {

        ObpBeginTypeSpecificCallOut( SaveIrql );

        if (!(*ObjectType->TypeInfo.OkayToCloseProcedure)( PsGetCurrentProcess(),
                                                           Object,
                                                           Handle,
                                                           PreviousMode )) {

            ObpEndTypeSpecificCallOut( SaveIrql, "NtClose", ObjectType, Object );

            ExUnlockHandleTableEntry( ObjectTable, ObjectTableEntry );

            return STATUS_HANDLE_NOT_CLOSABLE;
        }

        ObpEndTypeSpecificCallOut( SaveIrql, "NtClose", ObjectType, Object );
    }

    CapturedAttributes = ObpGetHandleAttributes(ObjectTableEntry);

    //
    //  If the previous mode was user and the handle is protected from
    //  being closed, then we'll either raise or return an error depending
    //  on the global flags and debugger port situation.
    //

    if ((CapturedAttributes & OBJ_PROTECT_CLOSE) != 0 && Rundown == FALSE) {

        if (PreviousMode != KernelMode) {

            ExUnlockHandleTableEntry( ObjectTable, ObjectTableEntry );

            if (!KeIsAttachedProcess() &&
                ((NtGlobalFlag & FLG_ENABLE_CLOSE_EXCEPTIONS) ||
                 (PsGetCurrentProcess()->DebugPort != NULL) ||
                 (ObjectTable->DebugInfo != NULL))) {

                //
                //  Raise and exception in user mode
                //
                return KeRaiseUserException(STATUS_HANDLE_NOT_CLOSABLE);

            } else {

                return STATUS_HANDLE_NOT_CLOSABLE;
            }

        } else {
            KeBugCheckEx(INVALID_KERNEL_HANDLE, (ULONG_PTR)Handle, 0, 0, 0);
        }
    }
    
    //
    //  Get the granted access for the handle
    //

#if i386 

    if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

        CapturedGrantedAccess = ObpTranslateGrantedAccessIndex( ObjectTableEntry->GrantedAccessIndex );

    } else {

        CapturedGrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);
    }

#else

    CapturedGrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);

#endif // i386 

    //
    //  Now remove the handle from the handle table
    //

    ExDestroyHandle( ObjectTable,
                     Handle,
                     ObjectTableEntry );

    //
    //  perform any auditing required
    //

    //
    //  Extract the value of the GenerateOnClose bit stored
    //  after object open auditing is performed.  This value
    //  was stored by a call to ObSetGenerateOnClosed.
    //

    if (CapturedAttributes & OBJ_AUDIT_OBJECT_CLOSE) {

        if ( SepAdtAuditingEnabled ) {

            SeCloseObjectAuditAlarm( Object,
                                     (HANDLE)((ULONG_PTR)Handle & ~OBJ_HANDLE_TAGBITS),  // Mask off the tagbits defined for OB objects.
                                     TRUE );
        }
    }

    //
    //  Since we took the handle away we need to decrement the objects
    //  handle count, and remove a reference
    //

    ObpDecrementHandleCount( PsGetCurrentProcess(),
                             ObjectHeader,
                             ObjectType,
                             CapturedGrantedAccess );

    ObDereferenceObject( Object );

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ObpCloseHandle (
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    )
/*++

Routine Description:

    This function is used to close access to the specified handle with the given mode

Arguments:

    Handle - Supplies the handle being closed
    PreviousMode - Processor mode to be used in the handle access checks.
    CanNotRaise - We are not allowed to do a user mode raise.

Return Value:

    An appropriate status value

--*/
{
    PHANDLE_TABLE ObjectTable;
    PHANDLE_TABLE_ENTRY ObjectTableEntry;
    NTSTATUS Status;
    BOOLEAN AttachedToProcess = FALSE;
    KAPC_STATE ApcState;
    PETHREAD CurrentThread;
    PEPROCESS CurrentProcess;


    ObpValidateIrql( "NtClose" );

    CurrentThread = PsGetCurrentThread ();
    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);
    //
    //  For the current process we will grab its handle/object table and
    //  translate the handle to its corresponding table entry.  If the
    //  call is successful it also lock down the handle table.  But first
    //  check for a kernel handle and attach and use that table if so.
    //

    if (IsKernelHandle( Handle, PreviousMode ))  {

        Handle = DecodeKernelHandle( Handle );

        ObjectTable = ObpKernelHandleTable;

        //
        //  Go to the system process if we have to
        //
        if (CurrentProcess != PsInitialSystemProcess) {
           KeStackAttachProcess (&PsInitialSystemProcess->Pcb, &ApcState);
           AttachedToProcess = TRUE;
        }

    } else {

        ObjectTable = CurrentProcess->ObjectTable;
    }

    //
    //  Protect ourselves from being interrupted while we hold a handle table
    //  entry lock
    //

    KeEnterCriticalRegionThread(&CurrentThread->Tcb);

    ObjectTableEntry = ExMapHandleToPointer( ObjectTable,
                                             Handle );

    //
    //  Check that the specified handle is legitimate otherwise we can
    //  assume the caller just passed in some bogus handle value
    //

    if (ObjectTableEntry != NULL) {

        Status = ObpCloseHandleTableEntry (ObjectTable, ObjectTableEntry, Handle, PreviousMode, FALSE);

        KeLeaveCriticalRegionThread(&CurrentThread->Tcb);
        //
        //  If we are attached to the system process then detach
        //
        if (AttachedToProcess) {

            KeUnstackDetachProcess(&ApcState);
            AttachedToProcess = FALSE;
        }


    } else {

        KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

        //
        //  At this point the input handle did not translate to a valid
        //  object table entry
        //

        //
        //  If we are attached to the system process then return
        //  back to our caller
        //

        if (AttachedToProcess) {
            KeUnstackDetachProcess(&ApcState);
            AttachedToProcess = FALSE;
        }

        //
        //  Now if the handle is not null and it does not represent the
        //  current thread or process then if we're user mode we either raise
        //  or return an error
        //

        if ((Handle != NULL) &&
            (Handle != NtCurrentThread()) &&
            (Handle != NtCurrentProcess())) {

            if (PreviousMode != KernelMode) {

                if ((NtGlobalFlag & FLG_ENABLE_CLOSE_EXCEPTIONS) ||
                    (CurrentProcess->DebugPort != NULL) ||
                    (ObjectTable->DebugInfo != NULL)) {

                    if (!KeIsAttachedProcess()) {
                        return KeRaiseUserException (STATUS_INVALID_HANDLE);
                    } else {
                        return STATUS_INVALID_HANDLE;
                    }

                }

            } else {

                //
                //  bugcheck here if kernel debugger is enabled and if kernel mode code is
                //  closing a bogus handle and process is not exiting.  Ignore
                //  if no PEB as this occurs if process is killed before
                //  really starting.
                //

                if ((!PsIsThreadTerminating(CurrentThread)) &&
                    (CurrentProcess->Peb != NULL)) {

                    if (KdDebuggerEnabled) {
                        KeBugCheckEx(INVALID_KERNEL_HANDLE, (ULONG_PTR)Handle, 1, 0, 0);
                    }
                }

            }
        }

        Status = STATUS_INVALID_HANDLE;
    }


    return Status;
}

NTSTATUS
ObCloseHandle (
    __in HANDLE Handle,
    __in KPROCESSOR_MODE PreviousMode
    )
/*++

Routine Description:

    This function is used to close access to the specified handle with the given mode

Arguments:

    Handle - Supplies the handle being closed
    PreviousMode - Processor mode to be used in the handle access checks.

Return Value:

    An appropriate status value

--*/
{
    return ObpCloseHandle (Handle,
                           PreviousMode);
}

NTSTATUS
NtClose (
    __in HANDLE Handle
    )

/*++

Routine Description:

    This function is used to close access to the specified handle

Arguments:

    Handle - Supplies the handle being closed

Return Value:

    An appropriate status value

--*/

{
    return ObpCloseHandle (Handle,
                           KeGetPreviousMode ());
}

NTSTATUS
NtMakeTemporaryObject (
    __in HANDLE Handle
    )

/*++

Routine Description:

    This routine makes the specified object non permanent.

Arguments:

    Handle - Supplies a handle to the object being modified

Return Value:

    An appropriate status value.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PVOID Object;
    OBJECT_HANDLE_INFORMATION HandleInformation;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output argument if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle( Handle,
                                        DELETE,
                                        (POBJECT_TYPE)NULL,
                                        PreviousMode,
                                        &Object,
                                        &HandleInformation );
    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    //
    //  Make the object temporary.  Note that the object should still
    //  have a name and directory entry because its handle count is not
    //  zero
    //

    ObMakeTemporaryObject( Object );

    //
    //  Check if we need to generate a delete object audit/alarm
    //

    if (HandleInformation.HandleAttributes & OBJ_AUDIT_OBJECT_CLOSE) {

        SeDeleteObjectAuditAlarm( Object,
                                  Handle );
    }

    ObDereferenceObject( Object );

    return( Status );
}


VOID
ObMakeTemporaryObject (
    __in PVOID Object
    )

/*++

Routine Description:

    This routine removes the name of the object from its parent
    directory.  The object is only removed if it has a non zero
    handle count and a name.  Otherwise the object is simply
    made non permanent

Arguments:

    Object - Supplies the object being modified

Return Value:

    None.

--*/

{
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;

    PAGED_CODE();


    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    //
    // Other bits are set in this flags field by the handle database code. Synchronize with that.
    //
    ObpLockObject( ObjectHeader );

    ObjectHeader->Flags &= ~OB_FLAG_PERMANENT_OBJECT;

    ObpUnlockObject( ObjectHeader );

    //
    // Now delete the object name if no more handles are present.
    //
    ObpDeleteNameCheck( Object );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obdevmap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obdevmap.c

Abstract:

    This module contains routines for creating and querying Device Map objects.
    Device Map objects define a DOS device name space, such as drive letters
    and peripheral devices (e.g. COM1)

--*/

#include "obp.h"

//
// Global that activates/disables LUID device maps
//
extern ULONG ObpLUIDDeviceMapsEnabled;


NTSTATUS
ObSetDirectoryDeviceMap (
    OUT PDEVICE_MAP *ppDeviceMap OPTIONAL,
    IN HANDLE DirectoryHandle
    );

NTSTATUS
ObSetDeviceMap (
    IN PEPROCESS TargetProcess OPTIONAL,
    IN HANDLE DirectoryHandle
    );

NTSTATUS
ObQueryDeviceMapInformation (
    IN PEPROCESS TargetProcess OPTIONAL,
    OUT PPROCESS_DEVICEMAP_INFORMATION DeviceMapInformation,
    IN ULONG Flags
    );
    
VOID
ObInheritDeviceMap (
    IN PEPROCESS NewProcess,
    IN PEPROCESS ParentProcess OPTIONAL
    );

VOID
ObDereferenceDeviceMap (
    IN PEPROCESS Process
    );

ULONG
ObIsLUIDDeviceMapsEnabled (
    );

#ifdef OBP_PAGEDPOOL_NAMESPACE
#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,ObSetDirectoryDeviceMap)
#pragma alloc_text(PAGE,ObSetDeviceMap)
#pragma alloc_text(PAGE,ObQueryDeviceMapInformation)
#pragma alloc_text(PAGE,ObInheritDeviceMap)
#pragma alloc_text(PAGE,ObDereferenceDeviceMap)
#pragma alloc_text(PAGE,ObIsLUIDDeviceMapsEnabled)
#endif
#endif // OBP_PAGEDPOOL_NAMESPACE


NTSTATUS
ObSetDirectoryDeviceMap (
    OUT PDEVICE_MAP *ppDeviceMap OPTIONAL,
    IN HANDLE DirectoryHandle
    )

/*++

Routine Description:

    This function sets the device map for the specified object directory.
    A device map is a structure associated with an object directory and
    a Logon ID (LUID).  When the object manager sees a references to a
    name beginning with \??\ or just \??, then it requests the device
    map of the LUID from the kernel reference monitor, which keeps track
    of LUIDs.  This allows multiple virtual \??  object directories on
    a per LUID basis.  The WindowStation logic will use this
    functionality to allocate devices unique to each WindowStation.

    SeGetLogonIdDeviceMap() use this function to create the device map
    structure associated with the directory object for the LUID device
    map.  So, this function should only be called from kernel mode.

Arguments:

    ppDeviceMap - returns a pointer to the device map structure

    DirectoryHandle - Specifies the object directory to associate with the
        device map.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_SHARING_VIOLATION - The specified object directory is already
            associated with a device map.

        STATUS_INSUFFICIENT_RESOURCES - Unable to allocate pool for the device
            map data structure;

        STATUS_ACCESS_DENIED - Caller did not have DIRECTORY_TRAVERSE access
            to the specified object directory.

--*/

{
    NTSTATUS Status;
    POBJECT_DIRECTORY DosDevicesDirectory;
    PDEVICE_MAP DeviceMap, FreeDeviceMap;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;

    PAGED_CODE();

    //
    //  Reference the object directory handle and see if it is already
    //  associated with a device map structure.  If so, fail this call.
    //

    Status = ObReferenceObjectByHandle( DirectoryHandle,
                                        DIRECTORY_TRAVERSE,
                                        ObpDirectoryObjectType,
                                        KernelMode,
                                        &DosDevicesDirectory,
                                        NULL );

    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    FreeDeviceMap = NULL;

    DeviceMap = ExAllocatePoolWithTag( OB_NAMESPACE_POOL_TYPE, sizeof( *DeviceMap ), 'mDbO' );

    if (DeviceMap == NULL) {

        ObDereferenceObject( DosDevicesDirectory );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return( Status );

    }

    RtlZeroMemory( DeviceMap, sizeof( *DeviceMap ) );

    DeviceMap->ReferenceCount = 1;
    DeviceMap->DosDevicesDirectory = DosDevicesDirectory;

    //
    //  Capture the device map
    //
    
    ObpLockDeviceMap();

    if (DosDevicesDirectory->DeviceMap != NULL) {
        FreeDeviceMap = DeviceMap;
        DeviceMap = DosDevicesDirectory->DeviceMap;
        DeviceMap->ReferenceCount++;
    } else {
        DosDevicesDirectory->DeviceMap = DeviceMap;
    }

    if (DosDevicesDirectory != ObSystemDeviceMap->DosDevicesDirectory) {
        DeviceMap->GlobalDosDevicesDirectory = ObSystemDeviceMap->DosDevicesDirectory;
    }

    ObpUnlockDeviceMap();

    //
    // pass back a pointer to the device map
    //
    if (ppDeviceMap != NULL) {
        *ppDeviceMap = DeviceMap;
    }

    //
    // Make the object permanent until the devmap is removed. This keeps the name in the tree
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( DosDevicesDirectory );
    NameInfo = ObpReferenceNameInfo( ObjectHeader );

    //
    // Other bits are set in this flags field by the handle database code. Synchronize with that.
    //
    
    ObpLockObject( ObjectHeader );

    if (NameInfo != NULL && NameInfo->Directory != NULL) {
        ObjectHeader->Flags |= OB_FLAG_PERMANENT_OBJECT;
    }

    ObpUnlockObject( ObjectHeader );

    ObpDereferenceNameInfo(NameInfo);

    //
    // If the directory already had a devmap and so was already referenced.
    // Drop ours and free the unused block.
    //
    if (FreeDeviceMap != NULL) {
        ObDereferenceObject (DosDevicesDirectory);
        ExFreePool (FreeDeviceMap);
    }
    return( Status );
}


NTSTATUS
ObSetDeviceMap (
    IN PEPROCESS TargetProcess OPTIONAL,
    IN HANDLE DirectoryHandle
    )

/*++

Routine Description:

    This function sets the device map for the specified process, using
    the specified object directory.  A device map is a structure
    associated with an object directory and a process.  When the object
    manager sees a references to a name beginning with \??\ or just \??,
    then it follows the device map object in the calling process's
    EPROCESS structure to get to the object directory to use for that
    reference.  This allows multiple virtual \??  object directories on
    a per process basis.  The WindowStation logic will use this
    functionality to allocate devices unique to each WindowStation.

Arguments:

    TargetProcess - Specifies the target process to associate the device map
        with.  If null then the current process is used and the directory
        becomes the system default dos device map.

    DirectoryHandle - Specifies the object directory to associate with the
        device map.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_SHARING_VIOLATION - The specified object directory is already
            associated with a device map.

        STATUS_INSUFFICIENT_RESOURCES - Unable to allocate pool for the device
            map data structure;

        STATUS_ACCESS_DENIED - Caller did not have DIRECTORY_TRAVERSE access
            to the specified object directory.

--*/

{
    NTSTATUS Status;
    POBJECT_DIRECTORY DosDevicesDirectory;
    PDEVICE_MAP DeviceMap, FreeDeviceMap, DerefDeviceMap;
    PEPROCESS Target = TargetProcess;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;

    BOOLEAN PreserveName = FALSE;

    PAGED_CODE();

    //
    //  Reference the object directory handle and see if it is already
    //  associated with a device map structure.  If so, fail this call.
    //

    Status = ObReferenceObjectByHandle( DirectoryHandle,
                                        DIRECTORY_TRAVERSE,
                                        ObpDirectoryObjectType,
                                        KeGetPreviousMode(),
                                        &DosDevicesDirectory,
                                        NULL );

    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    FreeDeviceMap = NULL;

    DeviceMap = ExAllocatePoolWithTag( OB_NAMESPACE_POOL_TYPE, sizeof( *DeviceMap ), 'mDbO' );

    if (DeviceMap == NULL) {

        ObDereferenceObject( DosDevicesDirectory );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return( Status );

    }

    RtlZeroMemory( DeviceMap, sizeof( *DeviceMap ) );

    DeviceMap->ReferenceCount = 1;
    DeviceMap->DosDevicesDirectory = DosDevicesDirectory;

    //
    //  Capture the device map
    //

    ObpLockDeviceMap();

    if (DosDevicesDirectory->DeviceMap != NULL) {
        FreeDeviceMap = DeviceMap;
        DeviceMap = DosDevicesDirectory->DeviceMap;
        DeviceMap->ReferenceCount++;
    } else {
        DosDevicesDirectory->DeviceMap = DeviceMap;
    }


    if (Target == NULL) {

        Target = PsGetCurrentProcess();

        ObSystemDeviceMap = DeviceMap;

    }

    if (DosDevicesDirectory != ObSystemDeviceMap->DosDevicesDirectory) {
        DeviceMap->GlobalDosDevicesDirectory = ObSystemDeviceMap->DosDevicesDirectory;
        PreserveName = TRUE;
    }

    DerefDeviceMap = Target->DeviceMap;

    Target->DeviceMap = DeviceMap;

    ObpUnlockDeviceMap();

    if (PreserveName == TRUE) {
        //
        // Make the object permanent until the devmap is removed. This keeps the name in the tree
        //
        ObjectHeader = OBJECT_TO_OBJECT_HEADER( DosDevicesDirectory );
        NameInfo = ObpReferenceNameInfo( ObjectHeader );


        //
        // Other bits are set in this flags field by the handle database code. Synchronize with that.
        //
        ObpLockObject( ObjectHeader );

        if (NameInfo != NULL && NameInfo->Directory != NULL) {
            ObjectHeader->Flags |= OB_FLAG_PERMANENT_OBJECT;
        }

        ObpUnlockObject( ObjectHeader );

        ObpDereferenceNameInfo( NameInfo );
    }
    //
    // If the directory already had a devmap and so was already referenced.
    // Drop ours and free the unused bock.
    //
    if (FreeDeviceMap != NULL) {
        ObDereferenceObject (DosDevicesDirectory);
        ExFreePool (FreeDeviceMap);
    }
    //
    // If the target already had a device map then deref it now
    //
    if (DerefDeviceMap != NULL) {
        ObfDereferenceDeviceMap (DerefDeviceMap);
    }
    return( Status );
}


NTSTATUS
ObQueryDeviceMapInformation (
    IN PEPROCESS TargetProcess OPTIONAL,
    OUT PPROCESS_DEVICEMAP_INFORMATION DeviceMapInformation,
    IN ULONG Flags
    )

/*++

Routine Description:

    This function queries information from the device map associated with the
    specified process.  The returned information contains a bit map indicating
    which drive letters are defined in the associated object directory, along
    with an array of drive types that give the type of each drive letter.

Arguments:

    TargetProcess - Specifies the target process to retrieve the device map
        from.  If not specified then we return the global default device map

    DeviceMapInformation - Specifies the location where to store the results.

    Flags - Specifies the query type

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_END_OF_FILE - The specified process was not associated with
            a device map.

        STATUS_ACCESS_VIOLATION - The DeviceMapInformation buffer pointer
            value specified an invalid address.

        STATUS_INVALID_PARAMETER - if LUID device maps are enabled,
            specified process is not the current process
--*/

{
    NTSTATUS Status;
    PDEVICE_MAP DeviceMap = NULL;
    PROCESS_DEVICEMAP_INFORMATION LocalMapInformation;
    ULONG Mask;
    LOGICAL SearchShadow;
    BOOLEAN UsedLUIDDeviceMap = FALSE;

    if (Flags & ~(PROCESS_LUID_DOSDEVICES_ONLY)) {
        return STATUS_INVALID_PARAMETER;
    }

    SearchShadow = !(Flags & PROCESS_LUID_DOSDEVICES_ONLY);

    //
    // if LUID device maps are enabled,
    // Verify that the process is the current process or
    // no process was specified
    //

    if (ObpLUIDDeviceMapsEnabled != 0) {
        if (ARGUMENT_PRESENT( TargetProcess ) &&
           (PsGetCurrentProcess() != TargetProcess)) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Get the caller's LUID device map
        //

        DeviceMap = ObpReferenceDeviceMap();
    }

    //
    //  First, while using a spinlock to protect the device map from
    //  going away we will make local copy of the information.
    //

    ObpLockDeviceMap();
    
    if (DeviceMap == NULL) {
        //
        //  Check if the caller gave us a target process and if not then use
        //  the globally defined one
        //

        if (ARGUMENT_PRESENT( TargetProcess )) {

            DeviceMap = TargetProcess->DeviceMap;

        } else {

            DeviceMap = ObSystemDeviceMap;
        }
    } else {
        UsedLUIDDeviceMap = TRUE;
    }

    //
    //  If we do not have a device map then we'll return an error otherwise
    //  we simply copy over the device map structure (bitmap and drive type
    //  array) into the output buffer
    //

    if (DeviceMap == NULL) {

        ObpUnlockDeviceMap();

        Status = STATUS_END_OF_FILE;

    } else {
        ULONG i;
        PDEVICE_MAP ShadowDeviceMap;

        Status = STATUS_SUCCESS;


        ShadowDeviceMap = DeviceMap;
        if (DeviceMap->GlobalDosDevicesDirectory != NULL &&
            DeviceMap->GlobalDosDevicesDirectory->DeviceMap != NULL) {
            ShadowDeviceMap = DeviceMap->GlobalDosDevicesDirectory->DeviceMap;
        }

        LocalMapInformation.Query.DriveMap = DeviceMap->DriveMap;

        for (i = 0, Mask = 1;
             i < sizeof (LocalMapInformation.Query.DriveType) /
                 sizeof (LocalMapInformation.Query.DriveType[0]);
             i++, Mask <<= 1) {
            LocalMapInformation.Query.DriveType[i] = DeviceMap->DriveType[i];
            if ( (Mask & DeviceMap->DriveMap) == 0 &&
                 SearchShadow &&
                 ( ( ObpLUIDDeviceMapsEnabled != 0   // check if LUID Device
                                                     // maps are enabled
                   ) ||
                   ( ShadowDeviceMap->DriveType[i] != DOSDEVICE_DRIVE_REMOTE &&
                     ShadowDeviceMap->DriveType[i] != DOSDEVICE_DRIVE_CALCULATE
                   ) ) ) {
                LocalMapInformation.Query.DriveType[i] = ShadowDeviceMap->DriveType[i];
                LocalMapInformation.Query.DriveMap |= ShadowDeviceMap->DriveMap & Mask;
            }
        }

        ObpUnlockDeviceMap();

        //
        // If the LUID device map was used,
        // then dereference the LUID device map
        //
        if (UsedLUIDDeviceMap == TRUE) {
            ObfDereferenceDeviceMap(DeviceMap);
        }

        //
        //  Now we can copy the information to the caller buffer using
        //  a try-except to guard against the output buffer changing.
        //  Note that the caller must have already probed the buffer
        //  for write.
        //

        try {

            RtlCopyMemory( &DeviceMapInformation->Query,
                           &LocalMapInformation.Query,
                           sizeof( DeviceMapInformation->Query ));

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    }

    return Status;
}


VOID
ObInheritDeviceMap (
    IN PEPROCESS NewProcess,
    IN PEPROCESS ParentProcess OPTIONAL
    )

/*++

Routine Description:

    This function is called at process initialization time to inherit the
    device map for a process.  If no parent process, then inherits from
    the system device map.

Arguments:

    NewProcess - Supplies the process being initialized that needs a new
        dos device map

    ParentProcess - - Optionally specifies the parent process whose device
        map we inherit.  This process if specified must have a device map

Return Value:

    None.

--*/

{
    PDEVICE_MAP DeviceMap;

    //
    //  If we are called with a parent process then grab its device map
    //  otherwise grab the system wide device map and check that is does
    //  exist
    //

    ObpLockDeviceMap();

    if (ParentProcess) {

        DeviceMap = ParentProcess->DeviceMap;

    } else {

        //
        //  Note: WindowStation guys may want a callout here to get the
        //  device map to use for this case.
        //

        DeviceMap = ObSystemDeviceMap;

    }

    if (DeviceMap != NULL) {
        //
        //  With the device map bumps its reference count and add it to the
        //  new process
        //
        DeviceMap->ReferenceCount++;
        NewProcess->DeviceMap = DeviceMap;

    }
    ObpUnlockDeviceMap();

    return;
}


VOID
ObDereferenceDeviceMap (
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This function is called at process tear down time to decrement the
    reference count on a device map.  When the reference count goes to
    zero, it means no more processes are using this, so it can be freed
    and the reference on the associated object directory can be released.

Arguments:

    Process - Process being destroyed.

Return Value:

    None.

--*/

{
    PDEVICE_MAP DeviceMap;

    //
    //  Grab the device map and then we only have work to do
    //  it there is one
    //

    ObpLockDeviceMap();

    DeviceMap = Process->DeviceMap;
    Process->DeviceMap = NULL;

    ObpUnlockDeviceMap();

    if (DeviceMap != NULL) {

        //
        //  To dereference the device map we need to null out the
        //  processes device map pointer, and decrement its ref count
        //  If the ref count goes to zero we can free up the memory
        //  and dereference the dos device directory object
        //


        ObfDereferenceDeviceMap(DeviceMap);

    }

    //
    //  And return to our caller
    //

    return;
}


ULONG
ObIsLUIDDeviceMapsEnabled (
    )

/*++

Routine Description:

    This function is checks if LUID DosDevices are enabled.

Arguments:

    None.

Return Value:

    0 - LUID DosDevices are disabled.
    1 - LUID DosDevices are enabled.

--*/

{
    return( ObpLUIDDeviceMapsEnabled );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obdir.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obdir.c

Abstract:

    Directory Object routines

--*/

#include "obp.h"
#include <stdio.h>

POBJECT_DIRECTORY
ObpGetShadowDirectory(
    POBJECT_DIRECTORY Dir
    );

//
// Defined in ntos\se\rmlogon.c
// private kernel function to obtain the LUID device map's directory
// object
// returns a kernel handle
//
NTSTATUS
SeGetLogonIdDeviceMap(
    IN PLUID pLogonId,
    OUT PDEVICE_MAP* ppDevMap
    );

NTSTATUS
ObpSetCurrentProcessDeviceMap(
    );

POBJECT_HEADER_NAME_INFO
ObpTryReferenceNameInfoExclusive(
    IN POBJECT_HEADER ObjectHeader
    );

VOID
ObpReleaseExclusiveNameLock(
    IN POBJECT_HEADER ObjectHeader
    );

POBJECT_DIRECTORY_ENTRY
ObpUnlinkDirectoryEntry (
    IN POBJECT_DIRECTORY Directory,
    IN ULONG HashIndex
    );

VOID
ObpLinkDirectoryEntry (
    IN POBJECT_DIRECTORY Directory,
    IN ULONG HashIndex,
    IN POBJECT_DIRECTORY_ENTRY NewDirectoryEntry
    );

VOID
ObpReleaseLookupContextObject (
    IN POBP_LOOKUP_CONTEXT LookupContext
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NtCreateDirectoryObject)
#pragma alloc_text(PAGE,NtOpenDirectoryObject)
#pragma alloc_text(PAGE,NtQueryDirectoryObject)
#pragma alloc_text(PAGE,ObpLookupDirectoryEntry)
#pragma alloc_text(PAGE,ObpInsertDirectoryEntry)
#pragma alloc_text(PAGE,ObpDeleteDirectoryEntry)
#pragma alloc_text(PAGE,ObpLookupObjectName)
#pragma alloc_text(PAGE,NtMakePermanentObject)

#ifdef OBP_PAGEDPOOL_NAMESPACE
#pragma alloc_text(PAGE,ObpGetShadowDirectory)
#pragma alloc_text(PAGE,ObpSetCurrentProcessDeviceMap)
#pragma alloc_text(PAGE,ObpReferenceDeviceMap)
#pragma alloc_text(PAGE,ObfDereferenceDeviceMap)
#pragma alloc_text(PAGE,ObSwapObjectNames)
#pragma alloc_text(PAGE,ObpReleaseLookupContextObject)
#pragma alloc_text(PAGE,ObpLinkDirectoryEntry)
#pragma alloc_text(PAGE,ObpUnlinkDirectoryEntry)
#pragma alloc_text(PAGE,ObpReleaseExclusiveNameLock)
#pragma alloc_text(PAGE,ObpTryReferenceNameInfoExclusive)
 
#endif  // OBP_PAGEDPOOL_NAMESPACE

#endif

//
//  Global Object manager flags to control the case sensitivity lookup
//  and the LUID devicemap lookup
//

ULONG ObpCaseInsensitive = 1;
extern ULONG ObpLUIDDeviceMapsEnabled;

WCHAR ObpUnsecureGlobalNamesBuffer[128] = { 0 };
ULONG ObpUnsecureGlobalNamesLength = sizeof(ObpUnsecureGlobalNamesBuffer);


BOOLEAN
ObpIsUnsecureName(
    IN PUNICODE_STRING ObjectName,
    IN BOOLEAN CaseInsensitive
    )
{
    PWCHAR CrtName;
    UNICODE_STRING UnsecurePrefix;

    if (ObpUnsecureGlobalNamesBuffer[0] == 0) {

        return FALSE;
    }

    CrtName = ObpUnsecureGlobalNamesBuffer;

    do {

        RtlInitUnicodeString(&UnsecurePrefix, CrtName);

        if (UnsecurePrefix.Length) {

            if (RtlPrefixUnicodeString( &UnsecurePrefix, ObjectName, CaseInsensitive)) {

                return TRUE;
            }
        }

        CrtName += (UnsecurePrefix.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR);

    } while ( UnsecurePrefix.Length );

    return FALSE;
}

NTSTATUS
NtCreateDirectoryObject (
    __out PHANDLE DirectoryHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This routine creates a new directory object according to user
    specified object attributes

Arguments:

    DirectoryHandle - Receives the handle for the newly created
        directory object

    DesiredAccess - Supplies the access being requested for this
        new directory object

    ObjectAttributes - Supplies caller specified attributes for new
        directory object

Return Value:

    An appropriate status value.

--*/

{
    POBJECT_DIRECTORY Directory;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    ObpValidateIrql( "NtCreateDirectoryObject" );

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( DirectoryHandle );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }
    }

    //
    //  Allocate and initialize a new Directory Object.  We don't need
    //  to specify a parse context or charge any quota.  The size of
    //  the object body is simply a directory object.  This call gets
    //  us a new referenced object.
    //

    Status = ObCreateObject( PreviousMode,
                             ObpDirectoryObjectType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof( *Directory ),
                             0,
                             0,
                             (PVOID *)&Directory );

    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    RtlZeroMemory( Directory, sizeof( *Directory ) );

    ExInitializePushLock( &Directory->Lock );
    Directory->SessionId = OBJ_INVALID_SESSION_ID;

    //
    //  Insert directory object in the current processes handle table,
    //  set directory handle value and return status.
    //
    //  ObInsertObject will delete the object in the case of failure
    //

    Status = ObInsertObject( Directory,
                             NULL,
                             DesiredAccess,
                             0,
                             (PVOID *)NULL,
                             &Handle );

    try {

        *DirectoryHandle = Handle;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  Fall through, since we do not want to undo what we have done.
        //
    }

    return( Status );
}

NTSTATUS
NtOpenDirectoryObject (
    __out PHANDLE DirectoryHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This routine opens an existing directory object.

Arguments:

    DirectoryHandle - Receives the handle for the newly opened directory
        object

    DesiredAccess - Supplies the access being requested for this
        directory object

    ObjectAttributes - Supplies caller specified attributes for the
        directory object

Return Value:

    An appropriate status value.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    HANDLE Handle;

    PAGED_CODE();

    ObpValidateIrql( "NtOpenDirectoryObject" );

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( DirectoryHandle );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }
    }

    //
    //  Open handle to the directory object with the specified desired access,
    //  set directory handle value, and return service completion status.
    //

    Status = ObOpenObjectByName( ObjectAttributes,
                                 ObpDirectoryObjectType,
                                 PreviousMode,
                                 NULL,
                                 DesiredAccess,
                                 NULL,
                                 &Handle );

    try {

        *DirectoryHandle = Handle;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  Fall through, since we do not want to undo what we have done.
        //
    }

    return Status;
}

NTSTATUS
NtQueryDirectoryObject (
    __in HANDLE DirectoryHandle,
    __out_bcount_opt(Length) PVOID Buffer,
    __in ULONG Length,
    __in BOOLEAN ReturnSingleEntry,
    __in BOOLEAN RestartScan,
    __inout PULONG Context,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This function returns information regarding a specified object
    directory.

Arguments:

    DirectoryHandle - Supplies a handle to the directory being queried

    Buffer - Supplies the output buffer to receive the directory
        information.  On return this contains one or more OBJECT DIRECTORY
        INFORMATION structures, the last one being null.  And then this is
        followed by the string names for the directory entries.

    Length - Supplies the length, in bytes, of the user supplied output
        buffer

    ReturnSingleEntry - Indicates if this routine should just return
        one entry in the directory

    RestartScan - Indicates if we are to restart the scan or continue
        relative to the enumeration context passed in as the next
        parameter

    Context - Supplies an enumeration context that must be resupplied
        to this routine on subsequent calls to keep the enumeration
        in sync

    ReturnLength - Optionally receives the length, in bytes, that this
        routine has stuffed into the output buffer

Return Value:

    An appropriate status value.

--*/

{
    POBJECT_DIRECTORY Directory;
    POBJECT_DIRECTORY_ENTRY DirectoryEntry;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;
    UNICODE_STRING ObjectName;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    PWCH NameBuffer;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG Bucket, EntryNumber, CapturedContext;
    ULONG TotalLengthNeeded, LengthNeeded, EntriesFound;
    PCHAR TempBuffer;
    OBP_LOOKUP_CONTEXT LookupContext;

    PAGED_CODE();

    ObpValidateIrql( "NtQueryDirectoryObject" );

    ObpInitializeLookupContext( &LookupContext );

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWrite( Buffer, Length, sizeof( WCHAR ) );
            ProbeForWriteUlong( Context );

            if (ARGUMENT_PRESENT( ReturnLength )) {

                ProbeForWriteUlong( ReturnLength );
            }

            if (RestartScan) {

                CapturedContext = 0;

            } else {

                CapturedContext = *Context;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    } else {

        if (RestartScan) {

            CapturedContext = 0;

        } else {

            CapturedContext = *Context;
        }
    }

    //
    //  Test for 64 bit if Length + sizeof( OBJECT_DIRECTORY_INFORMATION ) is less than Length
    //  Return STATUS_INVALID_PARAMETER if there is an overflow
    //

    if (ObpIsOverflow( Length, sizeof( OBJECT_DIRECTORY_INFORMATION ))) {

        return( STATUS_INVALID_PARAMETER );
    }

    //
    //  Allocate space for a temporary work buffer, make sure we got it,
    //  and then zero it out.  Make sure the buffer is large enough to
    //  hold at least one dir info record.  This will make the logic work
    //  better when the a bad length is passed in.
    //

    TempBuffer = ExAllocatePoolWithQuotaTag( PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                             Length + sizeof( OBJECT_DIRECTORY_INFORMATION ),
                                             'mNbO' );

    if (TempBuffer == NULL) {

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlZeroMemory( TempBuffer, Length );

    //
    //  Reference the directory object
    //

    Status = ObReferenceObjectByHandle( DirectoryHandle,
                                        DIRECTORY_QUERY,
                                        ObpDirectoryObjectType,
                                        PreviousMode,
                                        (PVOID *)&Directory,
                                        NULL );

    if (!NT_SUCCESS( Status )) {

        ExFreePool( TempBuffer );

        return( Status );
    }

    //
    //  Lock down the directory structures for the life of this
    //  procedure
    //

    ObpLockDirectoryShared(Directory, &LookupContext);

    //
    //  DirInfo is used to march through the output buffer filling
    //  in directory information.  We'll start off by making sure
    //  there is room for a NULL entry at end.
    //

    DirInfo = (POBJECT_DIRECTORY_INFORMATION)TempBuffer;

    TotalLengthNeeded = sizeof( *DirInfo );

    //
    //  Keep track of the number of entries found and actual
    //  entry that we are processing
    //

    EntryNumber = 0;
    EntriesFound = 0;

    //
    //  By default we'll say there are no more entries until the
    //  following loop put in some data
    //

    Status = STATUS_NO_MORE_ENTRIES;

    //
    //  Our outer loop processes each hash bucket in the directory object
    //

    for (Bucket=0; Bucket<NUMBER_HASH_BUCKETS; Bucket++) {

        DirectoryEntry = Directory->HashBuckets[ Bucket ];

        //
        //  For this hash bucket we'll zip through its list of entries.
        //  This is a singly linked list so when the next pointer is null
        //  (i.e., false) we at the end of the hash list
        //

        while (DirectoryEntry) {

            //
            //  The captured context is simply the entry count unless the
            //  user specified otherwise we start at zero, which means
            //  the first entry is always returned in the enumeration.
            //  If we have an match based on the entry index then we
            //  process this entry.  We bump the captured context further
            //  done in the code.
            //

            if (CapturedContext == EntryNumber++) {

                //
                //  For this directory entry we'll get a pointer to the
                //  object body and see if it has an object name.  If it
                //  doesn't have a name then we'll give it an empty name.
                //

                ObjectHeader = OBJECT_TO_OBJECT_HEADER( DirectoryEntry->Object );
                NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

                if (NameInfo != NULL) {

                    ObjectName = NameInfo->Name;

                } else {

                    RtlInitUnicodeString( &ObjectName, NULL );
                }

                //
                //  Now compute the length needed for this entry.  This would
                //  be the size of the object directory information record,
                //  plus the size of the object name and object type name both
                //  null terminated.
                //

                LengthNeeded = sizeof( *DirInfo ) +
                               ObjectName.Length + sizeof( UNICODE_NULL ) +
                               ObjectHeader->Type->Name.Length + sizeof( UNICODE_NULL );

                //
                //  If there isn't enough room then take the following error
                //  path.   If the user wanted a single entry then tell the
                //  caller what length is really needed and say the buffer was
                //  too small.  Otherwise the user wanted multiple entries,
                //  so we'll just say there are more entries in the directory.
                //  In both cases we drop down the entry number because we
                //  weren't able to fit it in on this call
                //

                if ((TotalLengthNeeded + LengthNeeded) > Length) {

                    if (ReturnSingleEntry) {

                        TotalLengthNeeded += LengthNeeded;

                        Status = STATUS_BUFFER_TOO_SMALL;

                    } else {

                        Status = STATUS_MORE_ENTRIES;
                    }

                    EntryNumber -= 1;
                    goto querydone;
                }

                //
                //  The information will fit in the buffer.  So now fill
                //  in the output buffer.  We temporarily put in pointers
                //  to the name buffer as stored in the object and object
                //  type.  We copy the data buffer to the user buffer
                //  right before we return to the caller
                //

                try {

                    DirInfo->Name.Length            = ObjectName.Length;
                    DirInfo->Name.MaximumLength     = (USHORT)(ObjectName.Length+sizeof( UNICODE_NULL ));
                    DirInfo->Name.Buffer            = ObjectName.Buffer;

                    DirInfo->TypeName.Length        = ObjectHeader->Type->Name.Length;
                    DirInfo->TypeName.MaximumLength = (USHORT)(ObjectHeader->Type->Name.Length+sizeof( UNICODE_NULL ));
                    DirInfo->TypeName.Buffer        = ObjectHeader->Type->Name.Buffer;

                    Status = STATUS_SUCCESS;

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    Status = GetExceptionCode();
                }

                if (!NT_SUCCESS( Status )) {

                    goto querydone;
                }

                //
                //  Update the total number of bytes needed in this query.
                //  Push the dir info pointer to the next output location,
                //  and indicate how many entries we've processed
                //
                //

                TotalLengthNeeded += LengthNeeded;

                DirInfo++;
                EntriesFound++;

                //
                //  If we are to return only one entry then move on to the
                //  post processing phase, otherwise indicate that we're
                //  processing the next entry and go back to the top of
                //  the inner loop
                //

                if (ReturnSingleEntry) {

                    goto querydone;

                } else {

                    //
                    //  Bump the captured context by one entry.
                    //

                    CapturedContext++;
                }
            }

            //
            //  Get the next directory entry from the singly linked hash
            //  bucket chain
            //

            DirectoryEntry = DirectoryEntry->ChainLink;
        }
    }

    //
    //  At this point we've processed the directory entries and the first
    //  part of the output buffer now contains a bunch of object directory
    //  information records,  but the pointers in them refer to the wrong
    //  copies.  So now we have some fixup to do.
    //

querydone:

    try {

        //
        //  We'll only do this post processing if we've been successful
        //  so far.  Note that this means we could be returning in the
        //  user's output buffer system address that are meaningless, but
        //  then getting back an error status should tell the caller to
        //  forget about everything in the output buffer.  Given back
        //  a system address also isn't harmful because there is nothing
        //  that the user can really do with it.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  Null terminate the string of object directory information
            //  records and point to where the actual names will go
            //

            RtlZeroMemory( DirInfo, sizeof( *DirInfo ));

            DirInfo++;

            NameBuffer = (PWCH)DirInfo;

            //
            //  Now for every entry that we've put in the output buffer
            //  DirInfo will point to the entry and EntriesFound kept the
            //  count.  Note that we are guaranteed space because of
            //  the math we did earlier in computing TotalLengthNeeded.
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION)TempBuffer;

            while (EntriesFound--) {

                //
                //  Copy over the object name, set the dir info pointer into
                //  the user's buffer, then null terminate the string.  Note
                //  that we are really copying the data into our temp buffer
                //  but the pointer fix up is for the user's buffer which
                //  we'll copy into right after this loop.
                //

                RtlCopyMemory( NameBuffer,
                               DirInfo->Name.Buffer,
                               DirInfo->Name.Length );

                DirInfo->Name.Buffer = (PVOID)((ULONG_PTR)Buffer + ((ULONG_PTR)NameBuffer - (ULONG_PTR)TempBuffer));
                NameBuffer           = (PWCH)((ULONG_PTR)NameBuffer + DirInfo->Name.Length);
                *NameBuffer++        = UNICODE_NULL;

                //
                //  Do the same copy with the object type name
                //

                RtlCopyMemory( NameBuffer,
                               DirInfo->TypeName.Buffer,
                               DirInfo->TypeName.Length );

                DirInfo->TypeName.Buffer = (PVOID)((ULONG_PTR)Buffer + ((ULONG_PTR)NameBuffer - (ULONG_PTR)TempBuffer));
                NameBuffer               = (PWCH)((ULONG_PTR)NameBuffer + DirInfo->TypeName.Length);
                *NameBuffer++            = UNICODE_NULL;

                //
                //  Move on to the next dir info record
                //

                DirInfo++;
            }

            //
            //  Set the enumeration context to the entry number of the next
            //  entry to return.
            //

            *Context = EntryNumber;
        }

        //
        //  Copy over the results from our temp buffer to the users buffer.
        //  But adjust the amount copied just in case the total length needed
        //  exceeds the length we allocated.
        //

        RtlCopyMemory( Buffer,
                       TempBuffer,
                       (TotalLengthNeeded <= Length ? TotalLengthNeeded : Length) );

        //
        //  In all cases we'll tell the caller how much space if really needed
        //  provided the user asked for this information
        //

        if (ARGUMENT_PRESENT( ReturnLength )) {

            *ReturnLength = TotalLengthNeeded;
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  Fall through, since we do not want to undo what we have done.
        //
    }

    //
    //  Unlock the directory structures, dereference the directory object,
    //  free up our temp buffer, and return to our caller
    //

    ObpUnlockDirectory( Directory, &LookupContext);

    ObDereferenceObject( Directory );

    ExFreePool( TempBuffer );

    return( Status );
}



PVOID
ObpLookupDirectoryEntry (
    IN POBJECT_DIRECTORY Directory,
    IN PUNICODE_STRING Name,
    IN ULONG Attributes,
    IN BOOLEAN SearchShadow,
    OUT POBP_LOOKUP_CONTEXT LookupContext
    )

/*++

Routine Description:

    This routine will lookup a single directory entry in a given directory.
    If it founds an object into that directory with the give name,
    that object will be referenced and the name will be referenced too, in order
    to prevent them going away when the directory is unlocked.
    The referenced object is saved in the LookupContext, and the references will be released
    at the next lookup, or when ObpReleaseLookupContext is called.

Arguments:

    Directory - Supplies the directory being searched

    Name - Supplies the name of entry we're looking for

    Attributes - Indicates if the lookup should be case insensitive
        or not

    SearchShadow - If TRUE, and the object name is not found in the current directory,
    it will search the object into the shadow directory.

    LookupContext - The lookup context for this call. This structure must be initialized
    before calling first time ObpLookupDirectoryEntry.

Return Value:

    Returns a pointer to the corresponding object body if found and NULL
    otherwise.
--*/

{
    POBJECT_DIRECTORY_ENTRY *HeadDirectoryEntry;
    POBJECT_DIRECTORY_ENTRY DirectoryEntry;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;
    PWCH Buffer;
    ULONG Wchar;
    ULONG HashIndex;
    ULONG HashValue;
    ULONG WcharLength;
    BOOLEAN CaseInSensitive;
    POBJECT_DIRECTORY_ENTRY *LookupBucket;
    PVOID Object = NULL;

    PAGED_CODE();

    if (ObpLUIDDeviceMapsEnabled == 0) {

        SearchShadow = FALSE; // Disable global devmap search
    }

    //
    //  The caller needs to specify both a directory and a name otherwise
    //  we can't process the request
    //

    if (!Directory || !Name) {

        goto UPDATECONTEXT;
    }

    //
    //  Set a local variable to tell us if the search is case sensitive
    //

    if (Attributes & OBJ_CASE_INSENSITIVE) {

        CaseInSensitive = TRUE;

    } else {

        CaseInSensitive = FALSE;
    }

    //
    //  Establish our local pointer to the input name buffer and get the
    //  number of unicode characters in the input name.  Also make sure
    //  the caller gave us a non null name
    //

    Buffer = Name->Buffer;
    WcharLength = Name->Length / sizeof( *Buffer );

    if (!WcharLength || !Buffer) {

        goto UPDATECONTEXT;
    }

    //
    //  Compute the address of the head of the bucket chain for this name.
    //

#if defined(_AMD64_)

    //
    // Hash four unicode chars at a time.  This is optimized for the ASCII
    // case.
    // 

    if (WcharLength >= 4) {

        ULONG64 Chunk;
        ULONG64 ChunkHash;
        ULONG   Index;

        ChunkHash = 0;
        do {

            Chunk = *(PULONG64)Buffer;
            if ((Chunk & 0xFF80FF80FF80FF80) == 0) {

                //
                // Chunk contains all ASCII characters, upcase all four.
                //
                // N.B. This will also transform some numerals and
                // punctuation characters, but will not significantly impact
                // the hash distribution.
                //

                Chunk &= ~0x0020002000200020;

            } else {

                //
                // Chunk contains at least one non-ASCII character,
                // upcase each character individually.
                //

                for (Index = 0; Index < 4; Index += 1) {

                    Wchar = (WCHAR)Chunk;
                    if (Wchar < 'a') {
            
                        NOTHING;
            
                    } else if (Wchar > 'z') {

                        Wchar = RtlUpcaseUnicodeChar( (WCHAR)Wchar );
            
                    } else {
            
                        Wchar -= ('a'-'A');
                    }

                    Chunk = ShiftRight128( Chunk, Wchar, 16 );
                }
            }

            ChunkHash += (ChunkHash << 1) + (ChunkHash >> 1);
            ChunkHash += Chunk;

            Buffer += 4;
            WcharLength -= 4;

        } while (WcharLength >= 4);

        HashIndex = (ULONG)(ChunkHash + (ChunkHash >> 32));

    } else

#endif

    {
        HashIndex = 0;
    }

    while (WcharLength--) {

        Wchar = *Buffer++;
        HashIndex += (HashIndex << 1) + (HashIndex >> 1);

        if (Wchar < 'a') {

            HashIndex += Wchar;

        } else if (Wchar > 'z') {

            HashIndex += RtlUpcaseUnicodeChar( (WCHAR)Wchar );

        } else {

            HashIndex += (Wchar - ('a'-'A'));
        }
    }

    HashValue = HashIndex;
    HashIndex %= NUMBER_HASH_BUCKETS;

    LookupContext->HashIndex = (USHORT)HashIndex;
    LookupContext->HashValue = HashValue;


    while (1) {

        HeadDirectoryEntry = (POBJECT_DIRECTORY_ENTRY *)&Directory->HashBuckets[ HashIndex ];

        LookupBucket = HeadDirectoryEntry;

        //
        //  Lock the directory for read access, if the context was not previously locked
        //  exclusively
        //

        if (!LookupContext->DirectoryLocked) {

            ObpLockDirectoryShared( Directory, LookupContext);
        }

        //
        //  Walk the chain of directory entries for this hash bucket, looking
        //  for either a match, or the insertion point if no match in the chain.
        //

        while ((DirectoryEntry = *HeadDirectoryEntry) != NULL) {

            if (DirectoryEntry->HashValue == HashValue) {
    
                //
                //  Get the object header and name from the object body
                //
                //  This function assumes the name must exist, otherwise it
                //  wouldn't be in a directory
                //
    
                ObjectHeader = OBJECT_TO_OBJECT_HEADER( DirectoryEntry->Object );
                NameInfo = OBJECT_HEADER_TO_NAME_INFO_EXISTS( ObjectHeader );
    
                //
                //  Compare strings using appropriate function.
                //
    
                if (RtlEqualUnicodeString( Name,
                                           &NameInfo->Name,
                                           CaseInSensitive )) {
    
                    //
                    //  If name matches, then exit loop with DirectoryEntry
                    //  pointing to matching entry.
                    //
    
                    break;
                }
            }

            HeadDirectoryEntry = &DirectoryEntry->ChainLink;
        }

        //
        //  At this point, there are two possiblilities:
        //
        //   - we found an entry that matched and DirectoryEntry points to that
        //     entry.  Update the bucket chain so that the entry found is at the
        //     head of the bucket chain.  This is so the ObpDeleteDirectoryEntry
        //     and ObpInsertDirectoryEntry functions will work.  Also repeated
        //     lookups of the same name will succeed quickly.
        //
        //   - we did not find an entry that matched and DirectoryEntry is NULL.
        //

        if (DirectoryEntry) {

            //
            //  The following convoluted piece of code moves a directory entry
            //  we've found to the front of the hash list.
            //

            if (HeadDirectoryEntry != LookupBucket) {

                if ( LookupContext->DirectoryLocked
                        ||
                     ExTryConvertPushLockSharedToExclusive(&Directory->Lock)) {

                    *HeadDirectoryEntry = DirectoryEntry->ChainLink;
                    DirectoryEntry->ChainLink = *LookupBucket;
                    *LookupBucket = DirectoryEntry;
                }
            }

            //
            //  Now return the object to our caller
            //

            Object = DirectoryEntry->Object;

            goto UPDATECONTEXT;

        } else {

            if (!LookupContext->DirectoryLocked) {

                ObpUnlockDirectory( Directory, LookupContext );
            }

            //
            // If this is a directory with a device map then search the second directory for an entry.
            //

            if (SearchShadow && Directory->DeviceMap != NULL) {
                POBJECT_DIRECTORY NewDirectory;

                NewDirectory = ObpGetShadowDirectory (Directory);
                if (NewDirectory != NULL) {
                    Directory = NewDirectory;
                    continue;
                }
            }

            goto UPDATECONTEXT;
        }
    }

UPDATECONTEXT:

    if (Object) {

        //
        //  Reference the name to keep it's directory alive and the object
        //  before returning from the lookup
        //

        ObpReferenceNameInfo( OBJECT_TO_OBJECT_HEADER(Object) );
        ObReferenceObject( Object );

        //
        //  We can safely drop the lock now
        //

        if (!LookupContext->DirectoryLocked) {

            ObpUnlockDirectory( Directory, LookupContext );
        }
    }

    //
    //  If we have a previously referenced object we can dereference it
    //

    if (LookupContext->Object) {

        POBJECT_HEADER_NAME_INFO PreviousNameInfo;

        PreviousNameInfo = OBJECT_HEADER_TO_NAME_INFO(OBJECT_TO_OBJECT_HEADER(LookupContext->Object));

        ObpDereferenceNameInfo(PreviousNameInfo);
        ObDereferenceObject(LookupContext->Object);
    }

    LookupContext->Object = Object;

    return Object;
}


BOOLEAN
ObpInsertDirectoryEntry (
    IN POBJECT_DIRECTORY Directory,
    IN POBP_LOOKUP_CONTEXT LookupContext,
    IN POBJECT_HEADER ObjectHeader
    )

/*++

Routine Description:

    This routine will insert a new directory entry into a directory
    object.  The directory must have already have been searched using
    ObpLookupDirectoryEntry because that routine sets the LookupContext.

    N.B. The ObpLookupDirectoryEntry before should be done with the LookupContext
    locked.

Arguments:

    Directory - Supplies the directory object being modified.  This
        function assumes that we earlier did a lookup on the name
        that was successful or we just did an insertion

    Object - Supplies the object to insert into the directory

    LookupContext - The lookupContext passed in previously to  ObpLookupDirectoryEntry

Return Value:

    TRUE if the object is inserted successfully and FALSE otherwise

--*/

{
    POBJECT_DIRECTORY_ENTRY *HeadDirectoryEntry;
    POBJECT_DIRECTORY_ENTRY NewDirectoryEntry;
    POBJECT_HEADER_NAME_INFO NameInfo = OBJECT_HEADER_TO_NAME_INFO_EXISTS( ObjectHeader );

#if DBG

    //
    //  This function should be always called with a valid Directory
    //  and LookupContext. Test this on checked builds
    //

    if ((LookupContext->Object != NULL) ||
        !LookupContext->DirectoryLocked ||
        (Directory != LookupContext->Directory)) {

        DbgPrint("OB: ObpInsertDirectoryEntry - invalid context %p %ld\n",
                 LookupContext->Object,
                 (ULONG)LookupContext->DirectoryLocked );
        DbgBreakPoint();

        return FALSE;
    }

#endif // DBG

    //
    //  Allocate memory for a new entry, and fail if not enough memory.
    //

    NewDirectoryEntry = (POBJECT_DIRECTORY_ENTRY)ExAllocatePoolWithTag( PagedPool,
                                                                        sizeof( OBJECT_DIRECTORY_ENTRY ),
                                                                        'iDbO' );

    if (NewDirectoryEntry == NULL) {

        return( FALSE );
    }

    //
    //  Get the right lookup bucket based on the HashIndex
    //

    HeadDirectoryEntry = (POBJECT_DIRECTORY_ENTRY *)&Directory->HashBuckets[ LookupContext->HashIndex ];

    //
    //  Link the new entry into the chain at the insertion point.
    //  This puts the new object right at the head of the current
    //  hash bucket chain
    //

    NewDirectoryEntry->HashValue = LookupContext->HashValue;
    NewDirectoryEntry->ChainLink = *HeadDirectoryEntry;
    *HeadDirectoryEntry = NewDirectoryEntry;
    NewDirectoryEntry->Object = &ObjectHeader->Body;

    //
    //  Point the object header back to the directory we just inserted
    //  it into.
    //

    NameInfo->Directory = Directory;

    //
    //  Return success.
    //

    return( TRUE );
}


BOOLEAN
ObpDeleteDirectoryEntry (
    IN POBP_LOOKUP_CONTEXT LookupContext
    )

/*++

Routine Description:

    This routine deletes the most recently found directory entry from
    the specified directory object.  It will only succeed after a
    successful ObpLookupDirectoryEntry call.

Arguments:

    Directory - Supplies the directory being modified

Return Value:

    TRUE if the deletion succeeded and FALSE otherwise

--*/

{
    POBJECT_DIRECTORY_ENTRY *HeadDirectoryEntry;
    POBJECT_DIRECTORY_ENTRY DirectoryEntry;
    IN POBJECT_DIRECTORY Directory = LookupContext->Directory;

    //
    //  Make sure we have a directory and that it has a found entry
    //

    if (!Directory ) {

        return( FALSE );
    }

    //
    //  The lookup path places the object in the front of the list, so basically
    //  we find the object immediately
    //

    HeadDirectoryEntry = (POBJECT_DIRECTORY_ENTRY *)&Directory->HashBuckets[ LookupContext->HashIndex ];

    DirectoryEntry = *HeadDirectoryEntry;

    //
    //  Unlink the entry from the head of the bucket chain and free the
    //  memory for the entry.
    //

    *HeadDirectoryEntry = DirectoryEntry->ChainLink;
    DirectoryEntry->ChainLink = NULL;

    ExFreePool( DirectoryEntry );

    return TRUE;
}

POBJECT_DIRECTORY
ObpGetShadowDirectory(
    POBJECT_DIRECTORY Dir
    )
{
    POBJECT_DIRECTORY NewDir;

    NewDir = NULL;

    ObpLockDeviceMap();

    if (Dir->DeviceMap != NULL) {
        NewDir = Dir->DeviceMap->GlobalDosDevicesDirectory;
    }

    ObpUnlockDeviceMap();

    return NewDir;
}


NTSTATUS
ObpSetCurrentProcessDeviceMap(
    )
/*++

Routine Description:

    This function sets the process' device map to the device map associated
    with the process token's LUID.

Arguments:

    none

Return Values:

    STATUS_NO_TOKEN - process does not have a primary token

    STATUS_OBJECT_PATH_INVALID - could not obtain the device map associated
                                 with the process token's LUID

    An appropriate status - unexcepted error occurred

--*/
{
    PEPROCESS pProcess;
    PACCESS_TOKEN pToken = NULL;
    LUID userLuid;
    LUID SystemAuthenticationId = SYSTEM_LUID;  // Local_System's LUID
    PDEVICE_MAP DeviceMap = NULL;
    PDEVICE_MAP DerefDeviceMap = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    pProcess = PsGetCurrentProcess();

    pToken = PsReferencePrimaryToken( pProcess );

    if (pToken == NULL) {
        return (STATUS_NO_TOKEN);
    }

    Status = SeQueryAuthenticationIdToken( pToken, &userLuid );

    if (!NT_SUCCESS(Status)) {
        PsDereferencePrimaryToken( pToken );
        return (Status);
    }

    if (!RtlEqualLuid( &userLuid, &SystemAuthenticationId )) {
        PDEVICE_MAP pDevMap;

        //
        // Get a handle to the Device Map for the user's LUID
        //
        Status = SeGetLogonIdDeviceMap( &userLuid,
                                        &pDevMap );

        if (NT_SUCCESS(Status)) {
            DeviceMap = pDevMap;
        }
    }
    else {
        //
        // Process is Local_System, so use the System's device map
        //
        DeviceMap = ObSystemDeviceMap;
    }

    if (DeviceMap != NULL) {
        //
        // set the process' device map
        //

        ObpLockDeviceMap();

        DerefDeviceMap = pProcess->DeviceMap;

        pProcess->DeviceMap = DeviceMap;

        DeviceMap->ReferenceCount++;

        ObpUnlockDeviceMap();
    }
    else {
        Status = STATUS_OBJECT_PATH_INVALID;
    }

    PsDereferencePrimaryToken( pToken );

    //
    // If the process already had a device map, then deref it now
    //
    if (DerefDeviceMap != NULL) {
        ObfDereferenceDeviceMap (DerefDeviceMap);
    }

    return (Status);
}


PDEVICE_MAP
ObpReferenceDeviceMap(
    )
/*++

Routine Description:

    This function obtains the correct device map associated with the
    caller.
    If LUID device maps are enabled,
    then we obtain the LUID's device map.

    We use the existing process device map field as a cache for the
    process token's LUID device map.

    If LUID device maps are disabled,
    then use the device map associated with the process

Arguments:

    none

Return Values:

    A pointer to the caller's device map
    NULL - could not obtain the user's device map

--*/
{
    PDEVICE_MAP DeviceMap = NULL;
    BOOLEAN LocalSystemRequest = FALSE;
    LOGICAL LUIDDeviceMapsEnabled;
    PACCESS_TOKEN pToken = NULL;
    NTSTATUS Status;

    LUIDDeviceMapsEnabled = (ObpLUIDDeviceMapsEnabled != 0);

    if (LUIDDeviceMapsEnabled == TRUE) {

        PETHREAD Thread = NULL;

        //
        //     Separate device maps for each user LUID
        // if (thread is impersonating)
        //    then get user's LUID to retrieve their device map
        //    else use the process' device map
        // if (LUID is the Local_System)
        //    then use the system's device map
        // if (unable to retrieve LUID's device map),
        //    then use the process' device map
        //

        //
        // Get the current thread & check if the thread is impersonating
        //
        // if impersonating,
        //     then take the long path
        //          - get thread's access token
        //          - read the caller's LUID from the token
        //          - get the device map associate with this LUID
        // if not impersonating,
        //     then use the device map associated with the process
        //
        Thread = PsGetCurrentThread();

        if ( PS_IS_THREAD_IMPERSONATING (Thread) ) {
            BOOLEAN fCopyOnOpen;
            BOOLEAN fEffectiveOnly;
            SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
            LUID userLuid;


            //
            // Get the caller's access token from the thread
            //
            pToken = PsReferenceImpersonationToken( Thread,
                                                    &fCopyOnOpen,
                                                    &fEffectiveOnly,
                                                    &ImpersonationLevel);

            if (pToken != NULL) {

                //
                // query the token for the LUID
                //
                Status = SeQueryAuthenticationIdToken( pToken, &userLuid );
            }
            else {
                Status = STATUS_NO_TOKEN;
                userLuid.LowPart = 0;
                userLuid.HighPart = 0;
            }

            if (NT_SUCCESS(Status)) {
                LUID SystemAuthenticationId = SYSTEM_LUID;  // Local_System's LUID

                //
                // Verify the caller is not Local_System by
                // comparing the LUID with Local_System's LUID
                //
                if (!RtlEqualLuid( &userLuid, &SystemAuthenticationId )) {
                    PDEVICE_MAP pDevMap;

                    //
                    // Get a handle to the Device Map for the LUID
                    //
                    Status = SeGetLogonIdDeviceMap( &userLuid,
                                                    &pDevMap );

                    if (NT_SUCCESS(Status)) {

                        //
                        // Use the device map associated with the LUID
                        //

                        DeviceMap = pDevMap;

                        ObpLockDeviceMap();

                        if (DeviceMap != NULL) {
                            DeviceMap->ReferenceCount++;
                        }

                        ObpUnlockDeviceMap();

                    }

                }
                else {
                    //
                    // Local_System will use the system's device map
                    //
                    LocalSystemRequest = TRUE;
                }

            }

        }

    }

    if (DeviceMap == NULL) {
        //
        // if (going to reference the process' device map and the process'
        // device map is not set),
        // then set the process' device map
        //
        if ((LUIDDeviceMapsEnabled == TRUE) &&
            (LocalSystemRequest == FALSE) &&
            ((PsGetCurrentProcess()->DeviceMap) == NULL)) {

            Status = ObpSetCurrentProcessDeviceMap();

            if (!NT_SUCCESS(Status)) {
                goto Error_Exit;
            }
        }

        ObpLockDeviceMap();

        if (LocalSystemRequest == TRUE) {
            //
            // Use the system's device map
            //
            DeviceMap = ObSystemDeviceMap;
        }
        else {
            //
            // Use the device map from the process
            //
            DeviceMap = PsGetCurrentProcess()->DeviceMap;
        }

        if (DeviceMap != NULL) {
            DeviceMap->ReferenceCount++;
        }
        ObpUnlockDeviceMap();
    }

Error_Exit:

    if( pToken != NULL ) {
        PsDereferenceImpersonationToken(pToken);
    }

    return DeviceMap;
}


VOID
FASTCALL
ObfDereferenceDeviceMap(
    IN PDEVICE_MAP DeviceMap
    )
{
    ObpLockDeviceMap();

    DeviceMap->ReferenceCount--;

    if (DeviceMap->ReferenceCount == 0) {

        DeviceMap->DosDevicesDirectory->DeviceMap = NULL;

        ObpUnlockDeviceMap();

        //
        // This devmap is dead so mark the directory temporary so its name will go away and dereference it.
        //
        ObMakeTemporaryObject (DeviceMap->DosDevicesDirectory);
        ObDereferenceObject( DeviceMap->DosDevicesDirectory );

        ExFreePool( DeviceMap );

    } else {

        ObpUnlockDeviceMap();
    }
}


NTSTATUS
ObpLookupObjectName (
    IN HANDLE RootDirectoryHandle OPTIONAL,
    IN PUNICODE_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode,
    IN PVOID ParseContext OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    IN PVOID InsertObject OPTIONAL,
    IN OUT PACCESS_STATE AccessState,
    OUT POBP_LOOKUP_CONTEXT LookupContext,
    OUT PVOID *FoundObject
    )

/*++

Routine Description:

    This function will search a given directoroy for a specified
    object name.  It will also create a new object specified by
    InsertObject.

Arguments:

    RootDirectoryHandle - Optionally supplies the directory being
        searched.  If not supplied then this routine searches
        the root directory

    ObjectName - Supplies the name of object to lookup

    Attributes - Specifies the attributes for the lookup (e.g., case
        insensitive)

    ObjectType - Specifies the type of the object to lookup

    AccessMode - Specifies the callers processor mode

    ParseContext - Optionally supplies a parse context that is blindly
        passed to the parse callback routines

    SecurityQos - Optionally supplies a pointer to the passed Security
        Quality of Service parameter that is blindly passed to the parse
        callback routines

    InsertObject - Optionally supplies the object we think will be found.
        This is used if the caller did not give a root directory handle
        and the object name is "\" and the root object directory hasn't
        been created yet.  In other cases where we wind up creating
        a new directory entry this is the object inserted.

    AccessState - Current access state, describing already granted access
        types, the privileges used to get them, and any access types yet to
        be granted.  The access masks may not contain any generic access
        types.

    DirectoryLocked - Receives an indication if this routine has returned
        with the input directory locked

    FoundObject - Receives a pointer to the object body if found

Return Value:

    An appropriate status value.

    N.B. If the status returned is SUCCESS the caller has the
    responsibility to release the lookup context

--*/

{
    POBJECT_DIRECTORY RootDirectory;
    POBJECT_DIRECTORY Directory = NULL;
    POBJECT_DIRECTORY ParentDirectory = NULL;
    POBJECT_DIRECTORY ReferencedDirectory = NULL;
    POBJECT_DIRECTORY ReferencedParentDirectory = NULL;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;
    PDEVICE_MAP DeviceMap = NULL;
    PVOID Object;
    UNICODE_STRING RemainingName;
    UNICODE_STRING ComponentName;
    PWCH NewName;
    NTSTATUS Status;
    BOOLEAN Reparse = FALSE;
    BOOLEAN ReparsedSymbolicLink = FALSE;
    ULONG MaxReparse = OBJ_MAX_REPARSE_ATTEMPTS;
    OB_PARSE_METHOD ParseProcedure;
    extern POBJECT_TYPE IoFileObjectType;
    KPROCESSOR_MODE AccessCheckMode;

    ObpValidateIrql( "ObpLookupObjectName" );

    //
    //  Initialize our output variables to say we haven't lock or found
    //  anything but we were successful at it
    //

    ObpInitializeLookupContext(LookupContext);

    *FoundObject = NULL;
    Status = STATUS_SUCCESS;

    Object = NULL;

    //
    //  If the global flag says that we need to perform a case-insensitive check
    //  we'll force the OBJ_CASE_INSENSITIVE flag in attributes at lookup
    //

    if ( ObpCaseInsensitive ) {

        if ( (ObjectType == NULL) ||
             (ObjectType->TypeInfo.CaseInsensitive)
           ) {

            Attributes |= OBJ_CASE_INSENSITIVE;
        }
    }

    if (Attributes & OBJ_FORCE_ACCESS_CHECK) {
        AccessCheckMode = UserMode;
    } else {
        AccessCheckMode = AccessMode;
    }

    //
    //  Check if the caller has given us a directory to search.  Otherwise
    //  we'll search the root object directory
    //

    if (ARGUMENT_PRESENT( RootDirectoryHandle )) {

        //
        //  Otherwise reference the directory object and make sure
        //  that we successfully got the object
        //

        Status = ObReferenceObjectByHandle( RootDirectoryHandle,
                                            0,
                                            NULL,
                                            AccessMode,
                                            (PVOID *)&RootDirectory,
                                            NULL );

        if (!NT_SUCCESS( Status )) {

            return( Status );
        }

        //
        //  Translate the directory object to its object header
        //

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( RootDirectory );

        //
        //  Now if the name we're looking up starts with a "\" and it
        //  does not have a parse procedure then the syntax is bad
        //

        if ((ObjectName->Buffer != NULL) &&
            (*(ObjectName->Buffer) == OBJ_NAME_PATH_SEPARATOR) &&
            (ObjectHeader->Type != IoFileObjectType)) {

            ObDereferenceObject( RootDirectory );

            return( STATUS_OBJECT_PATH_SYNTAX_BAD );
        }

        //
        //  Now make sure that we do not have the directory of the
        //  object types
        //

        if (ObjectHeader->Type != ObpDirectoryObjectType) {

            //
            //  We have an object directory that is not the object type
            //  directory.  So now if it doesn't have a parse routine
            //  then there is nothing we can
            //

            if (ObjectHeader->Type->TypeInfo.ParseProcedure == NULL) {

                ObDereferenceObject( RootDirectory );

                return( STATUS_INVALID_HANDLE );

            } else {

                MaxReparse = OBJ_MAX_REPARSE_ATTEMPTS;

                //
                //  The following loop cycles cycles through the various
                //  parse routine to we could encounter trying to resolve
                //  this name through symbolic links.
                //

                while (TRUE) {

#if DBG
                    KIRQL SaveIrql;
#endif

                    RemainingName = *ObjectName;

                    //
                    //  Invoke the callback routine to parse the remaining
                    //  object name
                    //

                    ObpBeginTypeSpecificCallOut( SaveIrql );

                    Status = (*ObjectHeader->Type->TypeInfo.ParseProcedure)( RootDirectory,
                                                                             ObjectType,
                                                                             AccessState,
                                                                             AccessCheckMode,
                                                                             Attributes,
                                                                             ObjectName,
                                                                             &RemainingName,
                                                                             ParseContext,
                                                                             SecurityQos,
                                                                             &Object );

                    ObpEndTypeSpecificCallOut( SaveIrql, "Parse", ObjectHeader->Type, Object );

                    //
                    //  If the status was not to do a reparse and the lookup
                    //  was not successful then we found nothing so we
                    //  dereference the directory and return the status to
                    //  our caller.  If the object we got back was null then
                    //  we'll tell our caller that we couldn't find the name.
                    //  Lastly if we did not get a reparse and we were
                    //  successful and the object is not null then everything
                    //  gets nicely returned to our caller
                    //

                    if ( ( Status != STATUS_REPARSE ) &&
                         ( Status != STATUS_REPARSE_OBJECT )) {

                        if (!NT_SUCCESS( Status )) {

                            Object = NULL;

                        } else if (Object == NULL) {

                            Status = STATUS_OBJECT_NAME_NOT_FOUND;
                        }

                        ObDereferenceObject( RootDirectory );

                        *FoundObject = Object;

                        return( Status );

                    //
                    //  We got a status reparse, which means the object
                    //  name has been modified to have use start all over
                    //  again.  If the reparse target is now empty or it
                    //  is a path separator then we start the parse at the
                    //  root directory
                    //

                    } else if ((ObjectName->Length == 0) ||
                               (ObjectName->Buffer == NULL) ||
                               (*(ObjectName->Buffer) == OBJ_NAME_PATH_SEPARATOR)) {

                        //
                        //  Restart the parse relative to the root directory.
                        //

                        ObDereferenceObject( RootDirectory );

                        RootDirectory = ObpRootDirectoryObject;
                        RootDirectoryHandle = NULL;

                        goto ParseFromRoot;

                    //
                    //  We got a reparse and we actually have a new name to
                    //  go to we if we haven't exhausted our reparse attempts
                    //  yet then just continue to the top of this loop.
                    //

                    } else if (--MaxReparse) {

                        continue;

                    //
                    //  We got a reparse and we've exhausted our times through
                    //  the loop so we'll return what we found.
                    //

                    } else {

                        ObDereferenceObject( RootDirectory );

                        *FoundObject = Object;

                        //
                        //  At this point we were failing in stress by
                        //  returning to the caller with a success status but
                        //  a null object pointer.
                        //

                        if (Object == NULL) {

                            Status = STATUS_OBJECT_NAME_NOT_FOUND;
                        }

                        return( Status );
                    }
                }
            }

        //
        //  At this point the caller has given us the directory of object
        //  types.  If the caller didn't specify a name then we'll return
        //  a pointer to the root object directory.
        //

        } else if ((ObjectName->Length == 0) ||
                   (ObjectName->Buffer == NULL)) {

            Status = ObReferenceObjectByPointer( RootDirectory,
                                                 0,
                                                 ObjectType,
                                                 AccessMode );

            if (NT_SUCCESS( Status )) {

                Object = RootDirectory;
            }

            ObDereferenceObject( RootDirectory );

            *FoundObject = Object;

            return( Status );
        }

    //
    //  Otherwise the caller did not specify a directory to search so
    //  we'll default to the object root directory
    //

    } else {

        RootDirectory = ObpRootDirectoryObject;

        //
        //  If the name we're looking for is empty then it is malformed.
        //  Also it has to start with a "\" or it is malformed.
        //

        if ((ObjectName->Length == 0) ||
            (ObjectName->Buffer == NULL) ||
            (*(ObjectName->Buffer) != OBJ_NAME_PATH_SEPARATOR)) {

            return( STATUS_OBJECT_PATH_SYNTAX_BAD );
        }

        //
        //  Check if the name is has only one character (that is the "\")
        //  Which means that the caller really just wants to lookup the
        //  root directory.
        //

        if (ObjectName->Length == sizeof( OBJ_NAME_PATH_SEPARATOR )) {

            //
            //  If there is not a root directory yet.  Then we really
            //  can't return it, however if the caller specified
            //  an insert object that is the one we'll reference and
            //  return to our caller
            //

            if (!RootDirectory) {

                if (InsertObject) {

                    Status = ObReferenceObjectByPointer( InsertObject,
                                                         0,
                                                         ObjectType,
                                                         AccessMode );

                    if (NT_SUCCESS( Status )) {

                        *FoundObject = InsertObject;
                    }

                    return( Status );

                } else {

                    return( STATUS_INVALID_PARAMETER );
                }

            //
            //  At this point the caller did not specify a root directory,
            //  the name is "\" and the root object directory exists so
            //  we'll simply return the real root directory object
            //

            } else {

                Status = ObReferenceObjectByPointer( RootDirectory,
                                                     0,
                                                     ObjectType,
                                                     AccessMode );

                if (NT_SUCCESS( Status )) {

                    *FoundObject = RootDirectory;
                }

                return( Status );
            }

        //
        //  At this pointer the caller did not specify a root directory,
        //  and the name is more than just a "\"
        //
        //  Now if the lookup is case insensitive, and the name buffer is a
        //  legitimate pointer (meaning that is it quadword aligned), and
        //  there is a dos device map for the process.  Then we'll handle
        //  the situation here. First get the device map and make sure it
        //  doesn't go away while we're using it.
        //

        } else {

ParseFromRoot:

            if (DeviceMap != NULL) {

                ObfDereferenceDeviceMap(DeviceMap);
                DeviceMap = NULL;
            }

            if (!((ULONG_PTR)(ObjectName->Buffer) & (sizeof(ULONGLONG)-1))) {

                //
                //  Check if the object name is actually equal to the
                //  global dos devices short name prefix "\??\"
                //

                if ((ObjectName->Length >= ObpDosDevicesShortName.Length)

                        &&

                    (*(PULONGLONG)(ObjectName->Buffer) == ObpDosDevicesShortNamePrefix.Alignment.QuadPart)) {

                    if ((DeviceMap = ObpReferenceDeviceMap()) != NULL) {
                        if (DeviceMap->DosDevicesDirectory != NULL ) {

                            //
                            //  The user gave us the dos short name prefix so we'll
                            //  look down the directory, and start the search at the
                            //  dos device directory
                            //

                            ParentDirectory = RootDirectory;

                            Directory = DeviceMap->DosDevicesDirectory;

                            RemainingName = *ObjectName;
                            RemainingName.Buffer += (ObpDosDevicesShortName.Length / sizeof( WCHAR ));
                            RemainingName.Length = (USHORT)(RemainingName.Length - ObpDosDevicesShortName.Length);

                            goto quickStart;

                        }
                    }
                    //
                    //  The name is not equal to "\??\" but check if it is
                    //  equal to "\??"
                    //

                } else if ((ObjectName->Length == ObpDosDevicesShortName.Length - sizeof( WCHAR ))

                                &&

                    (*(PULONG)(ObjectName->Buffer) == ObpDosDevicesShortNameRoot.Alignment.LowPart)

                                &&

                    (*((PWCHAR)(ObjectName->Buffer)+2) == (WCHAR)(ObpDosDevicesShortNameRoot.Alignment.HighPart))) {

                    //
                    //  The user specified "\??" so we return to dos devices
                    //  directory to our caller
                    //

                    if ((DeviceMap = ObpReferenceDeviceMap()) != NULL) {
                        if (DeviceMap->DosDevicesDirectory != NULL ) {

                            Status = ObReferenceObjectByPointer( DeviceMap->DosDevicesDirectory,
                                                                 0,
                                                                 ObjectType,
                                                                 AccessMode );

                            if (NT_SUCCESS( Status )) {

                                *FoundObject = DeviceMap->DosDevicesDirectory;
                            }

                            //
                            //  Dereference the Device Map
                            //

                            ObfDereferenceDeviceMap(DeviceMap);

                            return( Status );
                        }
                    }
                }
            }
        }
    }

    //
    //  At this point either
    //
    //  the user specified a directory that is not the object
    //  type directory and got reparsed back to the root directory
    //
    //  the user specified the object type directory and gave us
    //  a name to actually look up
    //
    //  the user did not specify a search directory (default
    //  to root object directory) and if the name did start off
    //  with the dos device prefix we've munged outselves back to
    //  it to the dos device directory for the process
    //

    if( ReparsedSymbolicLink == FALSE ) {
        Reparse = TRUE;
        MaxReparse = OBJ_MAX_REPARSE_ATTEMPTS;
    }

    while (Reparse) {

        RemainingName = *ObjectName;

quickStart:

        Reparse = FALSE;

        while (TRUE) {

            Object = NULL;

            //if (RemainingName.Length == 0) {
            //    Status = STATUS_OBJECT_NAME_INVALID;
            //    break;
            //    }

            //
            //  If the remaining name for the object starts with a
            //  "\" then just gobble up the "\"
            //

            if ( (RemainingName.Length != 0) &&
                 (*(RemainingName.Buffer) == OBJ_NAME_PATH_SEPARATOR) ) {

                RemainingName.Buffer++;
                RemainingName.Length -= sizeof( OBJ_NAME_PATH_SEPARATOR );
            }

            //
            //  The following piece of code will calculate the first
            //  component of the remaining name.  If there is not
            //  a remaining component then the object name is malformed
            //

            ComponentName = RemainingName;

            while (RemainingName.Length != 0) {

                if (*(RemainingName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {

                    break;
                }

                RemainingName.Buffer++;
                RemainingName.Length -= sizeof( OBJ_NAME_PATH_SEPARATOR );
            }

            ComponentName.Length = (USHORT)(ComponentName.Length - RemainingName.Length);

            if (ComponentName.Length == 0) {

                Status = STATUS_OBJECT_NAME_INVALID;
                break;
            }

            //
            //  Now we have the first component name to lookup so we'll
            //  look the directory is necessary
            //

            if ( Directory == NULL ) {

                Directory = RootDirectory;
            }

            //
            //  Now if the caller does not have traverse privilege and
            //  there is a parent directory then we must check if the
            //  user has traverse access to the directory.  Our local
            //  Reparse variable should be false at this point so we'll
            //  drop out of both loops
            //

            if ( (AccessCheckMode != KernelMode) &&
                 !(AccessState->Flags & TOKEN_HAS_TRAVERSE_PRIVILEGE) ) {

                //
                // If the privilege is to be checked, reference this directory
                // which will be the ParentDirectory for the next iteration if
                // any.
                //
                ASSERT( ReferencedDirectory == NULL );

                ObReferenceObject( Directory );
                ReferencedDirectory = Directory;
                 
                if (ParentDirectory != NULL) {

                    if (!ObpCheckTraverseAccess( ParentDirectory,
                                                 DIRECTORY_TRAVERSE,
                                                 AccessState,
                                                 FALSE,
                                                 AccessCheckMode,
                                                 &Status )) {
    
                        break;
                    }
                }
            }

            //
            //  If the object already exists in this directory, find it,
            //  else return NULL.
            //

            if (RemainingName.Length == 0) {

                //
                //  If we are searching the last name, take an additional reference 
                //  to the directory. We need this to either insert a new object into
                //  this directory, or to check for traverse access if an insert object
                //  is not specified. If not referenced the directory could go 
                //  away since ObpLookupDirectoryEntry releases the existing reference
                //
                if (ReferencedDirectory == NULL) {

                    ObReferenceObject( Directory );
                    ReferencedDirectory = Directory;
                }

                if (InsertObject != NULL) {
                    //
                    //  We lock the context exclusively before the lookup if we have an object
                    //  to insert. An insertion is likely to occur after this lookup if it fails, 
                    //  so we need to protect this directory to be changed until the 
                    //  ObpInsertDirectoryEntry call
                    //
    
                    ObpLockLookupContext( LookupContext, Directory );
                }
            }

            Object = ObpLookupDirectoryEntry( Directory,
                                              &ComponentName,
                                              Attributes,
                                              InsertObject == NULL ? TRUE : FALSE,
                                              LookupContext );

            if (!Object) {

                //
                //  We didn't find the object.  If there is some remaining
                //  name left (meaning the component name is a directory in
                //  path we trying to break) or the caller didn't specify an
                //  insert object then we then we'll break out here with an
                //  error status
                //

                if (RemainingName.Length != 0) {

                    Status = STATUS_OBJECT_PATH_NOT_FOUND;
                    break;
                }

                if (!InsertObject) {

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                    break;
                }

                //
                //  Check that the caller has the access to the directory
                //  to either create a subdirectory (in the object type
                //  directory) or to create an object of the given component
                //  name.  If the call fails then we'll break out of here
                //  with the status value set
                //

                if (!ObCheckCreateObjectAccess( Directory,
                                                ObjectType == ObpDirectoryObjectType ?
                                                        DIRECTORY_CREATE_SUBDIRECTORY :
                                                        DIRECTORY_CREATE_OBJECT,
                                                AccessState,
                                                &ComponentName,
                                                FALSE,
                                                AccessCheckMode,
                                                &Status )) {

                    break;
                }
                
                ObjectHeader = OBJECT_TO_OBJECT_HEADER( InsertObject );

                if ((Directory->SessionId != OBJ_INVALID_SESSION_ID)
                        &&
                    ((ObjectHeader->Type == MmSectionObjectType)
                            ||
                    (ObjectHeader->Type == ObpSymbolicLinkObjectType))) {

                    //
                    //  This directory is restricted to session. Check whether we are
                    //  in the same session with the directory, and if we have privilege to 
                    //  access it otherwise
                    //

                    if ((Directory->SessionId != PsGetCurrentProcessSessionId())
                            &&
                        !SeSinglePrivilegeCheck( SeCreateGlobalPrivilege, AccessCheckMode)
                            &&
                        !ObpIsUnsecureName( &ComponentName,
                                            ((Attributes & OBJ_CASE_INSENSITIVE) ? TRUE : FALSE ))) {

                        Status = STATUS_ACCESS_DENIED;

                        break;
                    }
                }

                //
                //  The object does not exist in the directory and
                //  we are allowed to create one.  So allocate space
                //  for the name and insert the name into the directory
                //

                NewName = ExAllocatePoolWithTag( PagedPool, ComponentName.Length, 'mNbO' );

                if ((NewName == NULL) ||
                    !ObpInsertDirectoryEntry( Directory, LookupContext, ObjectHeader )) {

                    if (NewName != NULL) {

                        ExFreePool( NewName );
                    }


                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                //
                //  We have an insert object so now get its name info,
                //  because we are going to change its name and insert it
                //  into the directory
                //

                ObReferenceObject( InsertObject );

                NameInfo = OBJECT_HEADER_TO_NAME_INFO_EXISTS( ObjectHeader );

                ObReferenceObject( Directory );

                RtlCopyMemory( NewName,
                               ComponentName.Buffer,
                               ComponentName.Length );

                if (NameInfo->Name.Buffer) {

                    ExFreePool( NameInfo->Name.Buffer );
                }

                NameInfo->Name.Buffer = NewName;
                NameInfo->Name.Length = ComponentName.Length;
                NameInfo->Name.MaximumLength = ComponentName.Length;

                Object = InsertObject;

                Status = STATUS_SUCCESS;

                break;
            }

            //
            //  At this point we've found the component name within
            //  the directory.  So we'll now grab the components object
            //  header, and get its parse routine
            //

ReparseObject:

            ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
            ParseProcedure = ObjectHeader->Type->TypeInfo.ParseProcedure;

            //
            //  Now if there is a parse routine for the type and we are not
            //  inserting a new object or the parse routine is for symbolic
            //  links then we'll actually call the parse routine
            //

            if (ParseProcedure && (!InsertObject || (ParseProcedure == ObpParseSymbolicLink))) {

#if DBG
                KIRQL SaveIrql;
#endif

                //
                //  Reference the object and then free the directory lock
                //  This will keep the object from going away with the
                //  directory unlocked
                //

                ObpIncrPointerCount( ObjectHeader );

                Directory = NULL;

                ObpReleaseLookupContext(LookupContext);
                
                //
                //  Release the extra references on the directory and parent directory 
                //  if they were taken since we may go through a reparse, and we do not 
                //  need these anymore.
                // 
    
                if (ReferencedDirectory != NULL) {
                    ObDereferenceObject( ReferencedDirectory );
                    ReferencedDirectory = NULL;
                }
                if (ReferencedParentDirectory != NULL) {
                    ObDereferenceObject( ReferencedParentDirectory );
                    ReferencedParentDirectory = NULL;
                }

                ObpBeginTypeSpecificCallOut( SaveIrql );

                //
                //  Call the objects parse routine
                //

                Status = (*ParseProcedure)( Object,
                                            (PVOID)ObjectType,
                                            AccessState,
                                            AccessCheckMode,
                                            Attributes,
                                            ObjectName,
                                            &RemainingName,
                                            ParseContext,
                                            SecurityQos,
                                            &Object );

                ObpEndTypeSpecificCallOut( SaveIrql, "Parse", ObjectHeader->Type, Object );

                //
                //  We can now decrement the object reference count
                //

                ObDereferenceObject( &ObjectHeader->Body );

                //
                //  Check if we have some reparsing to do
                //

                if ((Status == STATUS_REPARSE) || (Status == STATUS_REPARSE_OBJECT)) {

                    //
                    //  See if we've reparsed too many times already and if
                    //  so we'll fail the request
                    //

                    if (--MaxReparse) {

                        //
                        //  Tell the outer loop to continue looping
                        //

                        Reparse = TRUE;

                        //
                        //  Check if we have a reparse object or the name
                        //  starts with a "\"
                        //

                        if ((Status == STATUS_REPARSE_OBJECT) ||
                            (*(ObjectName->Buffer) == OBJ_NAME_PATH_SEPARATOR)) {

                            //
                            //  If the user specified a start directory then
                            //  remove this information because we're taking
                            //  a reparse point to someplace else
                             //

                            if (ARGUMENT_PRESENT( RootDirectoryHandle )) {

                                ObDereferenceObject( RootDirectory );
                                RootDirectoryHandle = NULL;
                            }

                            //
                            //  And where we start is the root directory
                            //  object
                            //

                            ParentDirectory = NULL;
                            RootDirectory = ObpRootDirectoryObject;

                            //
                            //  Now if this is a reparse object (means we have
                            //  encountered a symbolic link that has already been
                            //  snapped so we have an object and remaining
                            //  name that need to be examined) and we didn't
                            //  find an object from the parse routine object
                            //  break out of both loops.
                            //

                            if (Status == STATUS_REPARSE_OBJECT) {

                                Reparse = FALSE;

                                if (Object == NULL) {

                                    Status = STATUS_OBJECT_NAME_NOT_FOUND;

                                } else {

                                    //
                                    //  At this point we have a reparse object
                                    //  so we'll look the directory down and
                                    //  parse the new object
                                    //

                                    goto ReparseObject;
                                }
                            } else {
                                //
                                // At this point Status must be equal to
                                // STATUS_REPARSE because [(Status equals
                                // (STATUS_REPARSE_OBJECT or STATUS_REPARSE))
                                // && (Status != STATUS_REPARSE_OBJECT)]
                                //
                                ReparsedSymbolicLink = TRUE;
                                goto ParseFromRoot;
                            }

                        //
                        //  We did not have a reparse object and the name
                        //  does not start with a "\".  Meaning we got back
                        //  STATUS_REPASE, so now check if the directory
                        //  is the root object directory and if so then
                        //  we didn't the name otherwise we'll drop out of
                        //  the inner loop and reparse true to get back to
                        //  outer loop
                        //

                        } else if (RootDirectory == ObpRootDirectoryObject) {

                            Object = NULL;
                            Status = STATUS_OBJECT_NAME_NOT_FOUND;

                            Reparse = FALSE;
                        }

                    } else {

                        //
                        //  We return object not found if we've exhausted
                        //  the MaxReparse time
                        //

                        Object = NULL;
                        Status = STATUS_OBJECT_NAME_NOT_FOUND;
                    }

                //
                //  We are not reparsing and if we did not get success then
                //  the object is null and we'll break out of our loops
                //

                } else if (!NT_SUCCESS( Status )) {

                    Object = NULL;

                //
                //  We are not reparsing and we got back success but check
                //  if the object is null because that means we really didn't
                //  find the object, and then break out of our loops
                //
                //  If the object is not null then we've been successful and
                //  prosperous so break out with the object set.
                //

                } else if (Object == NULL) {

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                }

                break;

            } else {

                //
                //  At this point we do not have a parse routine or if there
                //  is a parse routine it is not for symbolic links or there
                //  may not be a specified insert object
                //
                //  Check to see if we have exhausted the remaining name
                //

                if (RemainingName.Length == 0) {

                    //
                    //  Check if the caller specified an object to insert.
                    //  If specified then we'll break out of our loops with
                    //  the object that we've found
                    //

                    if (!InsertObject) {

                        //
                        //  The user did not specify an insert object
                        //  so we're opening an existing object.  Make sure
                        //  we have traverse access to the container
                        //  directory.
                        //

                        if ( (AccessCheckMode != KernelMode) &&
                             !(AccessState->Flags & TOKEN_HAS_TRAVERSE_PRIVILEGE) ) {

                            if (!ObpCheckTraverseAccess( Directory,
                                                         DIRECTORY_TRAVERSE,
                                                         AccessState,
                                                         FALSE,
                                                         AccessCheckMode,
                                                         &Status )) {

                                Object = NULL;
                                break;
                            }
                        }

                        Status = ObReferenceObjectByPointer( Object,
                                                             0,
                                                             ObjectType,
                                                             AccessMode );

                        if (!NT_SUCCESS( Status )) {

                            Object = NULL;
                        }
                    }

                    break;

                } else {

                    //
                    //  There is some name remaining names to process
                    //  if the directory we're looking at is the
                    //  directory of object types and set ourselves
                    //  up to parse it all over again.
                    //

                    if (ObjectHeader->Type == ObpDirectoryObjectType) {

                        //
                        //  Setup for the next iteration, dereference the parent directory
                        //  from the previous iteration
                        //
                        if (ReferencedParentDirectory != NULL) {
                            ObDereferenceObject( ReferencedParentDirectory );
                        }
                        ReferencedParentDirectory = ReferencedDirectory;
                        ReferencedDirectory = NULL;

                        ParentDirectory = Directory;
                        Directory = (POBJECT_DIRECTORY)Object;

                    } else {

                        //
                        //  Otherwise there has been a mismatch so we'll
                        //  set our error status and break out of the
                        //  loops
                        //

                        Status = STATUS_OBJECT_TYPE_MISMATCH;
                        Object = NULL;

                        break;
                    }
                }
            }
        }
    }

    //
    //  We can release the context if our search was unsuccessful.
    //  We still need the directory to be locked if a new object is
    //  inserted into that directory, until we finish the initialization
    //  (i.e SD, handle, ...). Note the object is visible now and could be accessed
    //  via name. We need to hold the directory lock until we are done.
    //

    if ( !NT_SUCCESS(Status) ) {

        ObpReleaseLookupContext(LookupContext);
    }

    //
    //  If the device map has been referenced then dereference it
    //

    if (DeviceMap != NULL) {

        ObfDereferenceDeviceMap(DeviceMap);
    }

    //
    //  Dereference the directory and parent directory that might have been referenced during
    //  the course of the lookup. 
    // 

    if (ReferencedDirectory != NULL) {
        ObDereferenceObject( ReferencedDirectory );
    }

    if (ReferencedParentDirectory != NULL) {
        ObDereferenceObject( ReferencedParentDirectory );
    }


    //
    //  At this point we've parsed the object name as much as possible
    //  going through symbolic links as necessary.  So now set the
    //  output object pointer, and if we really did not find an object
    //  then we might need to modify the error status.  If the
    //  status was reparse or some success status then translate it
    //  to name not found.
    //

    if (!(*FoundObject = Object)) {

        if (Status == STATUS_REPARSE) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;

        } else if (NT_SUCCESS( Status )) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    //
    //  If the caller gave us a root directory to search (and we didn't
    //  zero out this value) then free up our reference
    //

    if (ARGUMENT_PRESENT( RootDirectoryHandle )) {

        ObDereferenceObject( RootDirectory );
        RootDirectoryHandle = NULL;
    }

    //
    //  And return to our caller
    //

    return( Status );
}

NTSTATUS
NtMakePermanentObject (
    __in HANDLE Handle
    )

/*++

Routine Description:

    This routine makes the specified object permanent.
    By default, only Local_System may make this call

Arguments:

    Handle - Supplies a handle to the object being modified

Return Value:

    An appropriate status value.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PVOID Object;
    OBJECT_HANDLE_INFORMATION HandleInformation;
    POBJECT_HEADER ObjectHeader;


    PAGED_CODE();

    //
    //  Get previous processor mode and probe output argument if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    //
    //  The object is being changed to permanent, check if
    //  the caller has the appropriate privilege.
    //
    if (!SeSinglePrivilegeCheck( SeCreatePermanentPrivilege,
                                 PreviousMode)) {

        Status = STATUS_PRIVILEGE_NOT_HELD;
        return( Status );
    }

    Status = ObReferenceObjectByHandle( Handle,
                                        0,
                                        (POBJECT_TYPE)NULL,
                                        PreviousMode,
                                        &Object,
                                        &HandleInformation );
    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    //
    //  Make the object permanent.  Note that the object should still
    //  have a name and directory entry because its handle count is not
    //  zero
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    //
    // Other bits are set in this flags field by the handle database code. Synchronize with that.
    //

    ObpLockObject( ObjectHeader );

    ObjectHeader->Flags |= OB_FLAG_PERMANENT_OBJECT;

    //
    // This routine releases the type mutex
    //

    ObpUnlockObject( ObjectHeader );

    ObDereferenceObject( Object );

    return( Status );
}

POBJECT_HEADER_NAME_INFO
ObpTryReferenceNameInfoExclusive(
    IN POBJECT_HEADER ObjectHeader
    )

/*++

    Routine Description:

        The function references exclusively the name information for a named object
        Note that if there are outstanding references to the name info this function can fail


    Arguments:

        ObjectHeader - Object being locked

    Return Value:
        
        Returns the name information or NULL if it cannot be locked
    
    Assumptions:
    
        The parent directory is assumed to be exclusively locked (so that other threads
        waiting to reference the name will have first to grab the directory lock). 
        
--*/

{
    POBJECT_HEADER_NAME_INFO NameInfo;
    LONG References, NewReferences;
    
    NameInfo = OBJECT_HEADER_TO_NAME_INFO_EXISTS( ObjectHeader );
    
    References = NameInfo->QueryReferences;

    do {

        //
        //  If this is not the only reference to the object then we cannot lock the name
        //  N.B. The caller needs also to have a reference to this name
        //

        if (((References & (~OBP_NAME_KERNEL_PROTECTED)) != 2) 
                ||
            (NameInfo->Directory == NULL)) {

            return NULL;
        }

        NewReferences = InterlockedCompareExchange ( (PLONG) &NameInfo->QueryReferences,
                                                     OBP_NAME_LOCKED | References,
                                                     References);

        //
        // If the exchange compare completed ok then we did a reference so return true.
        //

        if (NewReferences == References) {

            return NameInfo;
        }

        //
        // We failed because somebody else got in and changed the refence count on us. Use the new value to
        // prime the exchange again.
        //

        References = NewReferences;

    } while (TRUE);

    return NULL;
}

VOID
ObpReleaseExclusiveNameLock(
    IN POBJECT_HEADER ObjectHeader
    )

/*++

    Routine Description:

        The routine releases the exclusive lock for the name information

    Arguments:

        ObjectHeader - Object being locked

    Return Value:

        None.

--*/

{
    POBJECT_HEADER_NAME_INFO NameInfo;
    NameInfo = OBJECT_HEADER_TO_NAME_INFO_EXISTS( ObjectHeader );

    InterlockedExchangeAdd((PLONG)&NameInfo->QueryReferences, -OBP_NAME_LOCKED);
}

POBJECT_DIRECTORY_ENTRY
ObpUnlinkDirectoryEntry (
    IN POBJECT_DIRECTORY Directory,
    IN ULONG HashIndex
    )

/*++

    Routine Description:

        This function removes the directory entry from a directory. Note that before calling this 
        function a lookup is necessary.

    Arguments:

        Directory - Supplies the directory

        HashIndex - The hash value obtained from from the lookup context

    Return Value:

        Returns the directory entry removed from parent

--*/

{
    POBJECT_DIRECTORY_ENTRY *HeadDirectoryEntry;
    POBJECT_DIRECTORY_ENTRY DirectoryEntry;

    //
    //  The lookup path places the object in the front of the list, so basically
    //  we find the object immediately
    //

    HeadDirectoryEntry = (POBJECT_DIRECTORY_ENTRY *)&Directory->HashBuckets[ HashIndex ];

    DirectoryEntry = *HeadDirectoryEntry;

    //
    //  Unlink the entry from the head of the bucket chain and free the
    //  memory for the entry.
    //

    *HeadDirectoryEntry = DirectoryEntry->ChainLink;
    DirectoryEntry->ChainLink = NULL;

    return DirectoryEntry;
}


VOID
ObpLinkDirectoryEntry (
    IN POBJECT_DIRECTORY Directory,
    IN ULONG HashIndex,
    IN POBJECT_DIRECTORY_ENTRY NewDirectoryEntry
    )

/*++

    Routine Description:

        The function inserts a new directory entry into a directory object

    Arguments:

        Directory - Supplies the directory object being modified.  This
            function assumes that we earlier did a lookup on the name
            that was successful or we just did an insertion

        HashIndex - The hash value obtained from from the lookup context

        NewDirectoryEntry - Supplies the directory entry to be inserted

Return Value:

        None

--*/

{
    POBJECT_DIRECTORY_ENTRY *HeadDirectoryEntry;
    
    //
    //  Get the right lookup bucket based on the HashIndex
    //

    HeadDirectoryEntry = (POBJECT_DIRECTORY_ENTRY *)&Directory->HashBuckets[ HashIndex ];

    //
    //  Link the new entry into the chain at the insertion point.
    //  This puts the new object right at the head of the current
    //  hash bucket chain
    //

    NewDirectoryEntry->ChainLink = *HeadDirectoryEntry;
    *HeadDirectoryEntry = NewDirectoryEntry;
}

VOID
ObpReleaseLookupContextObject (
    IN POBP_LOOKUP_CONTEXT LookupContext
    )

/*++

    Routine Description:
    
        This function releases the object references (added during the lookup)
        but still keeps the directory locked. 
        
        N.B. The caller must retain at least one reference to the object and
        to the name to make sure the deletion does not happen under the lock.

    Arguments:
    
        LookupContext - Supplies the context used in previous lookup

    Return Value:
    
        None.

--*/

{
    //
    //  Remove the references added to the name info and object
    //

    if (LookupContext->Object) {
        POBJECT_HEADER_NAME_INFO NameInfo;

        NameInfo = OBJECT_HEADER_TO_NAME_INFO(OBJECT_TO_OBJECT_HEADER(LookupContext->Object));

        ObpDereferenceNameInfo( NameInfo );
        ObDereferenceObject(LookupContext->Object);
        LookupContext->Object = NULL;
    }
}

NTSTATUS
ObSwapObjectNames (
    IN HANDLE DirectoryHandle,
    IN HANDLE Handle1,
    IN HANDLE Handle2,
    IN ULONG Flags
    )

/*++

    Routine Description:

        The function swaps the names (and permanent object attribute) for two objects inserted into
        the same directory. Both objects must be named and have the same object type.
        The function can fail if another one of these objects has the name locked (for a lookup for example)
    
    Arguments:

        DirectoryHandle - Supplies the parent directory for both objects

        Handle1 - Supplies the handle to the first object

        Handle2 - Supplies the handle to the second object

    Return Value:

    	NTSTATUS.

--*/

{

    #define INVALID_HASH_INDEX 0xFFFFFFFF

    KPROCESSOR_MODE PreviousMode;
    PVOID Object1, Object2;
    NTSTATUS Status;
    POBJECT_HEADER_NAME_INFO NameInfo1, NameInfo2;
    POBJECT_HEADER ObjectHeader1 = NULL, ObjectHeader2 = NULL;
    POBJECT_DIRECTORY Directory;
    OBP_LOOKUP_CONTEXT LookupContext;
    POBJECT_HEADER_NAME_INFO ExclusiveNameInfo1 = NULL, ExclusiveNameInfo2 = NULL;
    POBJECT_DIRECTORY_ENTRY DirectoryEntry1 = NULL, DirectoryEntry2 = NULL;
    ULONG HashIndex1 = INVALID_HASH_INDEX, HashIndex2 = INVALID_HASH_INDEX;
    UNICODE_STRING TmpStr;
    ULONG TmpHash;
    OBJECT_HANDLE_INFORMATION HandleInformation;
    
    PreviousMode = KeGetPreviousMode();

    UNREFERENCED_PARAMETER(Flags);

    Object1 = NULL;
    Object2 = NULL;
    NameInfo1 = NULL;
    NameInfo2 = NULL;

    ObpInitializeLookupContext(&LookupContext);

    Status = ObReferenceObjectByHandle( DirectoryHandle,
                                        DIRECTORY_CREATE_OBJECT | DIRECTORY_CREATE_SUBDIRECTORY,
                                        ObpDirectoryObjectType,
                                        PreviousMode,
                                        (PVOID *)&Directory,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        goto exit;
    }
    
    Status = ObReferenceObjectByHandle( Handle1,
                                        DELETE,
                                        (POBJECT_TYPE)NULL,
                                        PreviousMode,
                                        &Object1,
                                        &HandleInformation );

    if (!NT_SUCCESS(Status)) {

        goto exit;
    }
    
    Status = ObReferenceObjectByHandle( Handle2,
                                        DELETE,
                                        (POBJECT_TYPE)NULL,
                                        PreviousMode,
                                        &Object2,
                                        &HandleInformation );

    if (!NT_SUCCESS(Status)) {

        goto exit;
    }

    if (Object1 == Object2) {

        Status = STATUS_OBJECT_NAME_COLLISION;
        goto exit;
    }

    ObjectHeader1 = OBJECT_TO_OBJECT_HEADER( Object1 );
    NameInfo1 = ObpReferenceNameInfo( ObjectHeader1 );

    ObjectHeader2 = OBJECT_TO_OBJECT_HEADER( Object2 );
    NameInfo2 = ObpReferenceNameInfo( ObjectHeader2 );

    if (ObjectHeader1->Type != ObjectHeader2->Type) {

        Status = STATUS_OBJECT_TYPE_MISMATCH;
        goto exit;
    }

    if ((NameInfo1 == NULL)
            ||
        (NameInfo2 == NULL)) {

        Status = STATUS_OBJECT_NAME_INVALID;
        goto exit;
    }

    if ((Directory != NameInfo1->Directory)
            ||
        (Directory != NameInfo2->Directory)) {

        Status = STATUS_OBJECT_NAME_INVALID;
        goto exit;
    }

    ObpLockLookupContext ( &LookupContext, Directory );

    //
    //  Check that the object we is still in the directory
    //

    if (Object1 != ObpLookupDirectoryEntry( Directory,
                                            &NameInfo1->Name,
                                            0,
                                            FALSE,
                                            &LookupContext )) {

        //
        //  The object is no longer in directory
        //

        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto exit;
    }

    HashIndex1 = LookupContext.HashIndex;
    DirectoryEntry1 = ObpUnlinkDirectoryEntry(Directory, HashIndex1);

    ObpReleaseLookupContextObject(&LookupContext);

    if (Object2 != ObpLookupDirectoryEntry( Directory,
                                            &NameInfo2->Name,
                                            0,
                                            FALSE,
                                            &LookupContext )) {

        //
        //  The object is no longer in directory
        //

        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto exit;
    }

    HashIndex2 = LookupContext.HashIndex;
    DirectoryEntry2 = ObpUnlinkDirectoryEntry(Directory, HashIndex2);
    
    ObpReleaseLookupContextObject(&LookupContext);

    //
    //  Now try to lock exclusively both object names
    //

    ExclusiveNameInfo1 = ObpTryReferenceNameInfoExclusive(ObjectHeader1);

    if (ExclusiveNameInfo1 == NULL) {

        Status = STATUS_LOCK_NOT_GRANTED;
        goto exit;
    }

    ExclusiveNameInfo2 = ObpTryReferenceNameInfoExclusive(ObjectHeader2);

    if (ExclusiveNameInfo2 == NULL) {

        Status = STATUS_LOCK_NOT_GRANTED;
        goto exit;
    }

    //
    //  We have both names exclusively locked. we can swap now them
    //

    TmpStr = ExclusiveNameInfo1->Name;
    ExclusiveNameInfo1->Name = ExclusiveNameInfo2->Name;
    ExclusiveNameInfo2->Name = TmpStr;

    TmpHash = DirectoryEntry1->HashValue;
    DirectoryEntry1->HashValue = DirectoryEntry2->HashValue;
    DirectoryEntry2->HashValue = TmpHash;

    //
    //  Now link back the objects, using the swapped hashes
    //

    ObpLinkDirectoryEntry(Directory, HashIndex2, DirectoryEntry1);
    ObpLinkDirectoryEntry(Directory, HashIndex1, DirectoryEntry2);
    
    DirectoryEntry1 = NULL;
    DirectoryEntry2 = NULL;

exit:
    
    if (DirectoryEntry1) {

        ObpLinkDirectoryEntry(Directory, HashIndex1, DirectoryEntry1);
    }
    
    if (DirectoryEntry2) {

        ObpLinkDirectoryEntry(Directory, HashIndex2, DirectoryEntry2);
    }

    if (ExclusiveNameInfo1) {
        ObpReleaseExclusiveNameLock(ObjectHeader1);
    }
    
    if (ExclusiveNameInfo2) {
        ObpReleaseExclusiveNameLock(ObjectHeader2);
    }

    ObpReleaseLookupContext( &LookupContext );

    if ( NT_SUCCESS( Status ) 
            &&
         (ObjectHeader1 != NULL)
            &&
         (ObjectHeader2 != NULL)) {
        
        //
        //  Lock now both objects and move swap the permanent object flag, if different
        //

        if ((ObjectHeader1->Flags ^ ObjectHeader2->Flags) & OB_FLAG_PERMANENT_OBJECT) {

            //
            //  Both objects are required to have the same object type. We lock them all
            //  before swapping the flags
            //

            ObpLockAllObjects(ObjectHeader1->Type);

            //
            //  Test again under the lock whether flags were changed
            //

            if ((ObjectHeader1->Flags ^ ObjectHeader2->Flags) & OB_FLAG_PERMANENT_OBJECT) {

                //
                //  swap the flags
                //

                ObjectHeader1->Flags ^= OB_FLAG_PERMANENT_OBJECT;
                ObjectHeader2->Flags ^= OB_FLAG_PERMANENT_OBJECT;
            }

            ObpUnlockAllObjects(ObjectHeader1->Type);
        }
    }

    ObpDereferenceNameInfo(NameInfo1);
    ObpDereferenceNameInfo(NameInfo2);

    if (Object1) {

        ObpDeleteNameCheck( Object1 ); // check whether the permanent flag went away meanwhile
        ObDereferenceObject( Object1 );
    }
    
    if (Object2) {
        
        ObpDeleteNameCheck( Object2 ); // check whether the permanent flag went away meanwhile
        ObDereferenceObject( Object2 );
    }

    if (Directory) {

        ObDereferenceObject( Directory );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obhandle.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obhandle.c

Abstract:

    Object handle routines

--*/

#include "obp.h"

//
//  Define logical sum of all generic accesses.
//

#define GENERIC_ACCESS (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)

//
//  Define the mask for the trace index. The last bit is used for
//  OBJ_PROTECT_CLOSE bit
//

#define OBP_CREATOR_BACKTRACE_LIMIT      0x7fff
#define OBP_CREATOR_BACKTRACE_INDEX_MASK OBP_CREATOR_BACKTRACE_LIMIT

//
// Define local prototypes
//

NTSTATUS
ObpIncrementHandleDataBase (
    IN POBJECT_HEADER ObjectHeader,
    IN PEPROCESS Process,
    OUT PULONG NewProcessHandleCount
    );

NTSTATUS
ObpCaptureHandleInformation (
    IN OUT PSYSTEM_HANDLE_TABLE_ENTRY_INFO *HandleEntryInfo,
    IN HANDLE UniqueProcessId,
    IN PVOID HandleTableEntry,
    IN HANDLE HandleIndex,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    );

NTSTATUS
ObpCaptureHandleInformationEx (
    IN OUT PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX *HandleEntryInfo,
    IN HANDLE UniqueProcessId,
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE HandleIndex,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    );

USHORT
ObpComputeGrantedAccessIndex (
    ACCESS_MASK GrantedAccess
    );

ACCESS_MASK
ObpTranslateGrantedAccessIndex (
    USHORT GrantedAccessIndex
    );

USHORT
RtlLogUmodeStackBackTrace(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtDuplicateObject)
#pragma alloc_text(PAGE,ObGetHandleInformation)
#pragma alloc_text(PAGE,ObGetHandleInformationEx)
#pragma alloc_text(PAGE,ObpCaptureHandleInformation)
#pragma alloc_text(PAGE,ObpCaptureHandleInformationEx)
#pragma alloc_text(PAGE,ObpIncrementHandleDataBase)
#pragma alloc_text(PAGE,ObpInsertHandleCount)
#pragma alloc_text(PAGE,ObpIncrementHandleCount)
#pragma alloc_text(PAGE,ObpIncrementUnnamedHandleCount)
#pragma alloc_text(PAGE,ObpChargeQuotaForObject)
#pragma alloc_text(PAGE,ObpDecrementHandleCount)
#pragma alloc_text(PAGE,ObpCreateHandle)
#pragma alloc_text(PAGE,ObpCreateUnnamedHandle)
#pragma alloc_text(PAGE,ObpValidateDesiredAccess)
#pragma alloc_text(PAGE,ObDuplicateObject)
#pragma alloc_text(PAGE,ObReferenceProcessHandleTable)
#pragma alloc_text(PAGE,ObDereferenceProcessHandleTable)
#pragma alloc_text(PAGE,ObpComputeGrantedAccessIndex)
#pragma alloc_text(PAGE,ObpTranslateGrantedAccessIndex)
#pragma alloc_text(PAGE,ObGetProcessHandleCount)
#endif



PHANDLE_TABLE
ObReferenceProcessHandleTable (
    PEPROCESS SourceProcess
    )

/*++

Routine Description:

    This function allows safe cross process handle table references. Table deletion
    at process exit waits for all outstanding references to finish. Once the table
    is marked deleted further references are denied byt this function.

Arguments:

    SourceProcesss - Process whose handle table is to be referenced

Return Value:

    Referenced handle table or NULL if the processes handle table has been or is in the
    process of being deleted.

--*/

{

    PHANDLE_TABLE ObjectTable;

    ObjectTable = NULL;

    if (ExAcquireRundownProtection (&SourceProcess->RundownProtect)) {

        ObjectTable = SourceProcess->ObjectTable;

        if (ObjectTable == NULL) {

            ExReleaseRundownProtection (&SourceProcess->RundownProtect);
        }
    }

    return ObjectTable;
}

VOID
ObDereferenceProcessHandleTable (
    PEPROCESS SourceProcess
    )
/*++

Routine Description:

    This function removes the outstanding reference obtained via ObReferenceProcessHandleTable.

Arguments:

    ObjectTable - Handle table to dereference

Return Value:

    None.

--*/
{
    ExReleaseRundownProtection (&SourceProcess->RundownProtect);
}

ULONG
ObGetProcessHandleCount (
    PEPROCESS Process
    )
/*++

Routine Description:

    This function returns the total number of open handles for a process.

Arguments:

    Process - Process whose handle table is to be queried.

Return Value:

    Count of open handles.

--*/
{
    PHANDLE_TABLE HandleTable;
    ULONG HandleCount;

    HandleTable = ObReferenceProcessHandleTable (Process);

    if ( HandleTable ) {
        HandleCount = HandleTable->HandleCount;

        ObDereferenceProcessHandleTable (Process);

    } else {
        HandleCount = 0;
    }

    return HandleCount;
}

NTSTATUS
ObDuplicateObject (
    IN PEPROCESS SourceProcess,
    IN HANDLE SourceHandle,
    IN PEPROCESS TargetProcess OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options,
    IN KPROCESSOR_MODE PreviousMode
    )
/*++

Routine Description:

    This function creates a handle that is a duplicate of the specified
    source handle.  The source handle is evaluated in the context of the
    specified source process.  The calling process must have
    PROCESS_DUP_HANDLE access to the source process.  The duplicate
    handle is created with the specified attributes and desired access.
    The duplicate handle is created in the handle table of the specified
    target process.  The calling process must have PROCESS_DUP_HANDLE
    access to the target process.

Arguments:

    SourceProcess - Supplies a pointer to the source process for the
        handle being duplicated

    SourceHandle - Supplies the handle being duplicated

    TargetProcess - Optionally supplies a pointer to the target process
        that is to receive the new handle

    TargetHandle - Optionally returns a the new duplicated handle

    DesiredAccess - Desired access for the new handle

    HandleAttributes - Desired attributes for the new handle

    Options - Duplication options that control things like close source,
        same access, and same attributes.

    PreviousMode - Mode of caller

Return Value:

    NTSTATUS - Status pf call

--*/
{
    NTSTATUS Status;
    PVOID SourceObject;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    BOOLEAN Attached;
    PHANDLE_TABLE SourceObjectTable, TargetObjectTable;
    HANDLE_TABLE_ENTRY ObjectTableEntry;
    OBJECT_HANDLE_INFORMATION HandleInformation;
    HANDLE NewHandle;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    ACCESS_MASK SourceAccess;
    ACCESS_MASK TargetAccess;
    ACCESS_MASK AuditMask = (ACCESS_MASK)0;
    PACCESS_STATE PassedAccessState = NULL;
    HANDLE_TABLE_ENTRY_INFO ObjectInfo;
    KAPC_STATE ApcState;


    if (ARGUMENT_PRESENT (TargetHandle)) {
        *TargetHandle = NULL;
    }
    //
    //  If the caller is not asking for the same access then
    //  validate the access they are requesting doesn't contain
    //  any bad bits
    //

    if (!(Options & DUPLICATE_SAME_ACCESS)) {

        Status = ObpValidateDesiredAccess( DesiredAccess );

        if (!NT_SUCCESS( Status )) {

            return( Status );
        }
    }

    //
    //  The Attached variable indicates if we needed to
    //  attach to the source process because it was not the
    //  current process.
    //

    Attached = FALSE;


    //
    //  Lock down access to the process object tables
    //
    SourceObjectTable = ObReferenceProcessHandleTable (SourceProcess);

    //
    //  Make sure the source process has an object table still
    //

    if ( SourceObjectTable == NULL ) {

        return STATUS_PROCESS_IS_TERMINATING;
    }

    //
    //  The the input source handle get a pointer to the
    //  source object itself, then detach from the process
    //  if necessary and check if we were given a good
    //  source handle.
    //

    Status = ObpReferenceProcessObjectByHandle (SourceHandle,
                                                SourceProcess,
                                                SourceObjectTable,
                                                PreviousMode,
                                                &SourceObject,
                                                &HandleInformation,
                                                &AuditMask);

    if (NT_SUCCESS( Status )) {

        if ((HandleInformation.HandleAttributes & OBJ_AUDIT_OBJECT_CLOSE) == 0) {
            AuditMask = 0;
        }
    }


    if (!NT_SUCCESS( Status )) {

        ObDereferenceProcessHandleTable (SourceProcess);

        return( Status );
    }

    //
    //  We are all done if no target process handle was specified.
    //  This is practically a noop because the only really end result
    //  could be that we've closed the source handle.
    //

    if (!ARGUMENT_PRESENT( TargetProcess )) {

        //
        //  If no TargetProcessHandle, then only possible option is to close
        //  the source handle in the context of the source process.
        //

        if (!(Options & DUPLICATE_CLOSE_SOURCE)) {

            Status = STATUS_INVALID_PARAMETER;
        }

        if (Options & DUPLICATE_CLOSE_SOURCE) {

            KeStackAttachProcess( &SourceProcess->Pcb, &ApcState );

            NtClose( SourceHandle );

            KeUnstackDetachProcess (&ApcState);
        }

        ObDereferenceProcessHandleTable (SourceProcess);

        ObDereferenceObject( SourceObject );

        return( Status );
    }

    SourceAccess = HandleInformation.GrantedAccess;

    //
    //  Make sure the target process has not exited
    //

    TargetObjectTable = ObReferenceProcessHandleTable (TargetProcess);
    if ( TargetObjectTable == NULL ) {

        if (Options & DUPLICATE_CLOSE_SOURCE) {

            KeStackAttachProcess( &SourceProcess->Pcb, &ApcState );

            NtClose( SourceHandle );

            KeUnstackDetachProcess (&ApcState);
        }

        ObDereferenceProcessHandleTable (SourceProcess);

        ObDereferenceObject( SourceObject );

        return STATUS_PROCESS_IS_TERMINATING;
    }

    //
    //  If the specified target process is not the current process, attach
    //  to the specified target process.
    //

    if (PsGetCurrentProcess() != TargetProcess) {

        KeStackAttachProcess( &TargetProcess->Pcb, &ApcState );

        Attached = TRUE;
    }

    //
    //  Construct the proper desired access and attributes for the new handle
    //

    if (Options & DUPLICATE_SAME_ACCESS) {

        DesiredAccess = SourceAccess;
    }

    if (Options & DUPLICATE_SAME_ATTRIBUTES) {

        HandleAttributes = HandleInformation.HandleAttributes;

    } else {

        //
        //  Always propagate auditing information.
        //

        HandleAttributes |= HandleInformation.HandleAttributes & OBJ_AUDIT_OBJECT_CLOSE;
    }

    //
    //  Get the object header for the source object
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( SourceObject );
    ObjectType = ObjectHeader->Type;

    RtlZeroMemory( &ObjectTableEntry, sizeof( HANDLE_TABLE_ENTRY ) );

    ObjectTableEntry.Object = ObjectHeader;

    ObjectTableEntry.ObAttributes |= (HandleAttributes & OBJ_HANDLE_ATTRIBUTES);

    //
    //  The following will be reset below if AVR is performed.
    //

    ObjectInfo.AuditMask = AuditMask;

    //
    //  If any of the generic access bits are specified then map those to more
    //  specific access bits
    //

    if ((DesiredAccess & GENERIC_ACCESS) != 0) {

        RtlMapGenericMask( &DesiredAccess,
                           &ObjectType->TypeInfo.GenericMapping );
    }

    //
    //  Make sure to preserve ACCESS_SYSTEM_SECURITY, which most likely is not
    //  found in the ValidAccessMask
    //

    TargetAccess = DesiredAccess &
                   (ObjectType->TypeInfo.ValidAccessMask | ACCESS_SYSTEM_SECURITY);

    //
    //  If the access requested for the target is a superset of the
    //  access allowed in the source, perform full AVR.  If it is a
    //  subset or equal, do not perform any access validation.
    //
    //  Do not allow superset access if object type has a private security
    //  method, as there is no means to call them in this case to do the
    //  access check.
    //
    //  If the AccessState is not passed to ObpIncrementHandleCount
    //  there will be no AVR.
    //

    if (TargetAccess & ~SourceAccess) {

        if (ObjectType->TypeInfo.SecurityProcedure == SeDefaultObjectMethod) {

            Status = SeCreateAccessState( &AccessState,
                                          &AuxData,
                                          TargetAccess,       // DesiredAccess
                                          &ObjectType->TypeInfo.GenericMapping );

            PassedAccessState = &AccessState;

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

    } else {

        //
        //  Do not perform AVR
        //

        PassedAccessState = NULL;

        Status = STATUS_SUCCESS;
    }

    //
    //  Increment the new handle count and get a pointer to
    //  the target processes object table
    //

    if ( NT_SUCCESS( Status )) {

        Status = ObpIncrementHandleCount( ObDuplicateHandle,
                                          PsGetCurrentProcess(), // this is already the target process
                                          SourceObject,
                                          ObjectType,
                                          PassedAccessState,
                                          PreviousMode,
                                          HandleAttributes );

    }

    if (Attached) {

        KeUnstackDetachProcess (&ApcState);

        Attached = FALSE;
    }

    if (Options & DUPLICATE_CLOSE_SOURCE) {

        KeStackAttachProcess( &SourceProcess->Pcb, &ApcState );

        NtClose( SourceHandle );

        KeUnstackDetachProcess(&ApcState);
    }

    if (!NT_SUCCESS( Status )) {

        if (PassedAccessState != NULL) {

            SeDeleteAccessState( PassedAccessState );
        }

        ObDereferenceProcessHandleTable (SourceProcess);
        ObDereferenceProcessHandleTable (TargetProcess);

        ObDereferenceObject( SourceObject );

        return( Status );
    }

    if ((PassedAccessState != NULL) && (PassedAccessState->GenerateOnClose == TRUE)) {

        //
        //  If we performed AVR opening the handle, then mark the handle as needing
        //  auditing when it's closed.  Also save away the maximum audit mask
        //  if one was created.
        //

        ObjectTableEntry.ObAttributes |= OBJ_AUDIT_OBJECT_CLOSE;
        ObjectInfo.AuditMask = ((PAUX_ACCESS_DATA)PassedAccessState->AuxData)->MaximumAuditMask;
    }

#if i386 

    if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

        LONG StackTraceIndex;

        ObjectTableEntry.GrantedAccessIndex = ObpComputeGrantedAccessIndex( TargetAccess );

        if (PreviousMode == KernelMode) {

            StackTraceIndex = RtlLogStackBackTrace();

        } else {

            StackTraceIndex = RtlLogUmodeStackBackTrace();
        }

        //
        //  Save the stack trace only if the index fits the CreatorBackTraceIndex
        //  minus the ProtectOnClose bit
        //

        if (StackTraceIndex < OBP_CREATOR_BACKTRACE_LIMIT) {

            ObjectTableEntry.CreatorBackTraceIndex = (USHORT)StackTraceIndex;
        
        } else {

            ObjectTableEntry.CreatorBackTraceIndex = 0;
        }
    
    } else {

        ObjectTableEntry.GrantedAccess = TargetAccess;
    }

#else

    ObjectTableEntry.GrantedAccess = TargetAccess;

#endif // i386 

    //
    //  Now that we've constructed a new object table entry for the duplicated handle
    //  we need to add it to the object table of the target process
    //

    ObpEncodeProtectClose(ObjectTableEntry);

    NewHandle = ExCreateHandle( TargetObjectTable, &ObjectTableEntry );

    if (NewHandle) {

        if ( ObjectInfo.AuditMask != 0 ) {

            //
            //  Make sure it's the same object before setting the handle information.
            //  The user may have closed it immediately after the ExCreateHandle call,
            //  so at this time it may either be invalid or a completely different object.
            //

            PHANDLE_TABLE_ENTRY HandleTableEntry;
            PKTHREAD CurrentThread;

            CurrentThread = KeGetCurrentThread ();

            KeEnterCriticalRegionThread (CurrentThread);

            HandleTableEntry = ExMapHandleToPointer ( TargetObjectTable, NewHandle );

            if (HandleTableEntry != NULL) {

                if (((ULONG_PTR)(HandleTableEntry->Object) & ~OBJ_HANDLE_ATTRIBUTES) == (ULONG_PTR)ObjectHeader) {

                    ExSetHandleInfo(TargetObjectTable, NewHandle, &ObjectInfo, TRUE);
                }

                ExUnlockHandleTableEntry( TargetObjectTable, HandleTableEntry );
            }

            KeLeaveCriticalRegionThread (CurrentThread);
        }

        //
        //  We have a new handle to audit the creation of the new handle if
        //  AVR was done.  And set the optional output handle variable.  Note
        //  that if we reach here the status variable is already a success
        //

        if (PassedAccessState != NULL) {

            SeAuditHandleCreation( PassedAccessState, NewHandle );
        }

        if ( (ObjectTableEntry.ObAttributes & OBJ_AUDIT_OBJECT_CLOSE) && 
             (SeDetailedAuditingWithToken( PassedAccessState ? SeQuerySubjectContextToken( &PassedAccessState->SubjectSecurityContext ) : NULL )) ) {

            SeAuditHandleDuplication( SourceHandle,
                                      NewHandle,
                                      SourceProcess,
                                      TargetProcess );
        }


    } else {

        //
        //  We didn't get a new handle to decrement the handle count dereference
        //  the necessary objects, set the optional output variable and indicate
        //  why we're failing
        //

        ObpDecrementHandleCount( TargetProcess,
                                 ObjectHeader,
                                 ObjectType,
                                 TargetAccess );

        ObDereferenceObject( SourceObject );


        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (ARGUMENT_PRESENT( TargetHandle )) {

        *TargetHandle = NewHandle;

    }

    //
    //  Cleanup from our selfs and then return to our caller
    //

    if (PassedAccessState != NULL) {

        SeDeleteAccessState( PassedAccessState );
    }

    ObDereferenceProcessHandleTable (SourceProcess);
    ObDereferenceProcessHandleTable (TargetProcess);

    return( Status );
}

NTSTATUS
NtDuplicateObject (
    __in HANDLE SourceProcessHandle,
    __in HANDLE SourceHandle,
    __in_opt HANDLE TargetProcessHandle,
    __out_opt PHANDLE TargetHandle,
    __in ACCESS_MASK DesiredAccess,
    __in ULONG HandleAttributes,
    __in ULONG Options
    )

/*++

Routine Description:

    This function creates a handle that is a duplicate of the specified
    source handle.  The source handle is evaluated in the context of the
    specified source process.  The calling process must have
    PROCESS_DUP_HANDLE access to the source process.  The duplicate
    handle is created with the specified attributes and desired access.
    The duplicate handle is created in the handle table of the specified
    target process.  The calling process must have PROCESS_DUP_HANDLE
    access to the target process.

Arguments:

    SourceProcessHandle - Supplies a handle to the source process for the
        handle being duplicated

    SourceHandle - Supplies the handle being duplicated

    TargetProcessHandle - Optionally supplies a handle to the target process
        that is to receive the new handle

    TargetHandle - Optionally returns a the new duplicated handle

    DesiredAccess - Desired access for the new handle

    HandleAttributes - Desired attributes for the new handle

    Options - Duplication options that control things like close source,
        same access, and same attributes.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status, Status1;
    PEPROCESS SourceProcess;
    PEPROCESS TargetProcess;
    HANDLE NewHandle = NULL;

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (ARGUMENT_PRESENT( TargetHandle ) && (PreviousMode != KernelMode)) {

        try {

            ProbeForWriteHandle( TargetHandle );
            *TargetHandle = NULL;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }
    }


    //
    //  Given the input source process handle get a pointer
    //  to the source process object
    //

    Status = ObReferenceObjectByHandle( SourceProcessHandle,
                                        PROCESS_DUP_HANDLE,
                                        PsProcessType,
                                        PreviousMode,
                                        (PVOID *)&SourceProcess,
                                        NULL );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  We are all done if no target process handle was specified.
    //  This is practically a noop because the only really end result
    //  could be that we've closed the source handle.
    //

    if (!ARGUMENT_PRESENT( TargetProcessHandle )) {

        //
        //  If no TargetProcessHandle, then only possible option is to close
        //  the source handle in the context of the source process.
        //

        TargetProcess = NULL;
        Status1 = STATUS_SUCCESS;
    } else {
        //
        //  At this point the caller did specify for a target process
        //  So from the target process handle get a pointer to the
        //  target process object.
        //

        Status1 = ObReferenceObjectByHandle( TargetProcessHandle,
                                             PROCESS_DUP_HANDLE,
                                             PsProcessType,
                                             PreviousMode,
                                             (PVOID *)&TargetProcess,
                                             NULL );
        //
        // The original structure of Duplicate cased us to still close the input handle if the output process handle
        // was bad. We preserve that functionality.
        //
        if (!NT_SUCCESS (Status1)) {
            TargetProcess = NULL;
        }
    }

    Status = ObDuplicateObject (SourceProcess,
                                SourceHandle,
                                TargetProcess,
                                &NewHandle,
                                DesiredAccess,
                                HandleAttributes,
                                Options,
                                PreviousMode );

    if (ARGUMENT_PRESENT( TargetHandle )) {

        try {

            *TargetHandle = NewHandle;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  Fall through, since we cannot undo what we have done.
            //
        }
    }

    ObDereferenceObject( SourceProcess );
    if ( TargetProcess != NULL) {
        ObDereferenceObject( TargetProcess );
    }

    if (!NT_SUCCESS (Status1)) {
        Status = Status1;
    }
    return( Status );
}


NTSTATUS
ObGetHandleInformation (
    OUT PSYSTEM_HANDLE_INFORMATION HandleInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This routine returns information about the specified handle.

Arguments:

    HandleInformation - Supplies an array of handle information
        structures to fill in

    Length - Supplies the length the handle information array in bytes

    ReturnLength - Receives the number of bytes used by this call

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status;
    ULONG RequiredLength;

    PAGED_CODE();

    RequiredLength = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handles );

    if (Length < RequiredLength) {

        return( STATUS_INFO_LENGTH_MISMATCH );
    }

    HandleInformation->NumberOfHandles = 0;

    //
    //  For every handle in every handle table we'll be calling
    //  our callback routine
    //

    Status = ExSnapShotHandleTables( ObpCaptureHandleInformation,
                                     HandleInformation,
                                     Length,
                                     &RequiredLength );

    if (ARGUMENT_PRESENT( ReturnLength )) {

        *ReturnLength = RequiredLength;
    }

    return( Status );
}


NTSTATUS
ObGetHandleInformationEx (
    OUT PSYSTEM_HANDLE_INFORMATION_EX HandleInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This routine returns information about the specified handle.

Arguments:

    HandleInformation - Supplies an array of handle information
        structures to fill in

    Length - Supplies the length the handle information array in bytes

    ReturnLength - Receives the number of bytes used by this call

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status;
    ULONG RequiredLength;

    PAGED_CODE();

    RequiredLength = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION_EX, Handles );

    if (Length < RequiredLength) {

        return( STATUS_INFO_LENGTH_MISMATCH );
    }

    HandleInformation->NumberOfHandles = 0;

    //
    //  For every handle in every handle table we'll be calling
    //  our callback routine
    //

    Status = ExSnapShotHandleTablesEx( ObpCaptureHandleInformationEx,
                                       HandleInformation,
                                       Length,
                                       &RequiredLength );

    if (ARGUMENT_PRESENT( ReturnLength )) {

        *ReturnLength = RequiredLength;
    }

    return( Status );
}


NTSTATUS
ObpCaptureHandleInformation (
    IN OUT PSYSTEM_HANDLE_TABLE_ENTRY_INFO *HandleEntryInfo,
    IN HANDLE UniqueProcessId,
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE HandleIndex,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    )

/*++

Routine Description:

    This is the callback routine of ObGetHandleInformation

Arguments:

    HandleEntryInfo - Supplies a pointer to the output buffer to receive
        the handle information

    UniqueProcessId - Supplies the process id of the caller

    ObjectTableEntry - Supplies the handle table entry that is being
        captured

    HandleIndex - Supplies the index for the preceding handle table entry

    Length - Specifies the length, in bytes, of the original user buffer

    RequiredLength - Specifies the length, in bytes, that has already been
        used in the buffer to store information.  On return this receives
        the updated number of bytes being used.

        Note that the HandleEntryInfo does not necessarily point to the
        start of the original user buffer.  It will have been offset by
        the feed-in RequiredLength value.

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;

    //
    //  Figure out who much size we really need to contain this extra record
    //  and then check that it fits.
    //

    *RequiredLength += sizeof( SYSTEM_HANDLE_TABLE_ENTRY_INFO );

    if (Length < *RequiredLength) {

        Status = STATUS_INFO_LENGTH_MISMATCH;

    } else {

        //
        //  Get the object header from the table entry and then copy over the information
        //

        ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

        (*HandleEntryInfo)->UniqueProcessId       = (USHORT)((ULONG_PTR)UniqueProcessId);
        (*HandleEntryInfo)->HandleAttributes      = (UCHAR)ObpGetHandleAttributes(ObjectTableEntry);
        (*HandleEntryInfo)->ObjectTypeIndex       = (UCHAR)(ObjectHeader->Type->Index);
        (*HandleEntryInfo)->HandleValue           = (USHORT)((ULONG_PTR)(HandleIndex));
        (*HandleEntryInfo)->Object                = &ObjectHeader->Body;
        (*HandleEntryInfo)->CreatorBackTraceIndex = 0;

#if i386 

        if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

            (*HandleEntryInfo)->CreatorBackTraceIndex = ObjectTableEntry->CreatorBackTraceIndex & OBP_CREATOR_BACKTRACE_INDEX_MASK;
            (*HandleEntryInfo)->GrantedAccess = ObpTranslateGrantedAccessIndex( ObjectTableEntry->GrantedAccessIndex );

        } else {

            (*HandleEntryInfo)->GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);
        }

#else

        (*HandleEntryInfo)->GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);

#endif // i386 

        (*HandleEntryInfo)++;

        Status = STATUS_SUCCESS;
    }

    return( Status );
}


NTSTATUS
ObpCaptureHandleInformationEx (
    IN OUT PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX *HandleEntryInfo,
    IN HANDLE UniqueProcessId,
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE HandleIndex,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    )

/*++

Routine Description:

    This is the callback routine of ObGetHandleInformation

Arguments:

    HandleEntryInfo - Supplies a pointer to the output buffer to receive
        the handle information

    UniqueProcessId - Supplies the process id of the caller

    ObjectTableEntry - Supplies the handle table entry that is being
        captured

    HandleIndex - Supplies the index for the preceding handle table entry

    Length - Specifies the length, in bytes, of the original user buffer

    RequiredLength - Specifies the length, in bytes, that has already been
        used in the buffer to store information.  On return this receives
        the updated number of bytes being used.

        Note that the HandleEntryInfo does not necessarily point to the
        start of the original user buffer.  It will have been offset by
        the feed-in RequiredLength value.

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;

    //
    //  Figure out who much size we really need to contain this extra record
    //  and then check that it fits.
    //

    *RequiredLength += sizeof( SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX );

    if (Length < *RequiredLength) {

        Status = STATUS_INFO_LENGTH_MISMATCH;

    } else {

        //
        //  Get the object header from the table entry and then copy over the information
        //

        ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

        (*HandleEntryInfo)->UniqueProcessId       = (ULONG_PTR)UniqueProcessId;
        (*HandleEntryInfo)->HandleAttributes      = (UCHAR)ObpGetHandleAttributes(ObjectTableEntry);
        (*HandleEntryInfo)->ObjectTypeIndex       = (USHORT)(ObjectHeader->Type->Index);
        (*HandleEntryInfo)->HandleValue           = (ULONG_PTR)(HandleIndex);
        (*HandleEntryInfo)->Object                = &ObjectHeader->Body;
        (*HandleEntryInfo)->CreatorBackTraceIndex = 0;

#if i386 

        if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

            (*HandleEntryInfo)->CreatorBackTraceIndex = ObjectTableEntry->CreatorBackTraceIndex & OBP_CREATOR_BACKTRACE_INDEX_MASK;
            (*HandleEntryInfo)->GrantedAccess = ObpTranslateGrantedAccessIndex( ObjectTableEntry->GrantedAccessIndex );

        } else {

            (*HandleEntryInfo)->GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);
        }

#else

        (*HandleEntryInfo)->GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);

#endif // i386 

        (*HandleEntryInfo)++;

        Status = STATUS_SUCCESS;
    }

    return( Status );
}


POBJECT_HANDLE_COUNT_ENTRY
ObpInsertHandleCount (
    POBJECT_HEADER ObjectHeader
    )

/*++

Routine Description:

    This function will increase the size of the handle database
    stored in the handle information of an object header.  If
    necessary it will allocate new and free old handle databases.

    This routine should not be called if there is already free
    space in the handle table.

Arguments:

    ObjectHeader - The object whose handle count is being incremented

Return Value:

    The pointer to the next free handle count entry within the
    handle database.

--*/

{
    POBJECT_HEADER_HANDLE_INFO HandleInfo;
    POBJECT_HANDLE_COUNT_DATABASE OldHandleCountDataBase;
    POBJECT_HANDLE_COUNT_DATABASE NewHandleCountDataBase;
    POBJECT_HANDLE_COUNT_ENTRY FreeHandleCountEntry;
    ULONG CountEntries;
    ULONG OldSize;
    ULONG NewSize;
    OBJECT_HANDLE_COUNT_DATABASE SingleEntryDataBase;

    PAGED_CODE();

    //
    //  Check if the object has any handle information
    //

    HandleInfo = OBJECT_HEADER_TO_HANDLE_INFO(ObjectHeader);

    if (HandleInfo == NULL) {

        return NULL;
    }

    //
    //  The object does have some handle information.  If it has
    //  a single handle entry then we'll construct a local dummy
    //  handle count database and come up with a new data base for
    //  storing two entries.
    //

    if (ObjectHeader->Flags & OB_FLAG_SINGLE_HANDLE_ENTRY) {

        SingleEntryDataBase.CountEntries = 1;
        SingleEntryDataBase.HandleCountEntries[0] = HandleInfo->SingleEntry;

        OldHandleCountDataBase = &SingleEntryDataBase;

        OldSize = sizeof( SingleEntryDataBase );

        CountEntries = 2;

        NewSize = sizeof(OBJECT_HANDLE_COUNT_DATABASE) +
               ((CountEntries - 1) * sizeof( OBJECT_HANDLE_COUNT_ENTRY ));

    } else {

        //
        //  The object already has multiple handles so we reference the
        //  current handle database, and compute a new size bumped by four
        //

        OldHandleCountDataBase = HandleInfo->HandleCountDataBase;

        CountEntries = OldHandleCountDataBase->CountEntries;

        OldSize = sizeof(OBJECT_HANDLE_COUNT_DATABASE) +
               ((CountEntries - 1) * sizeof( OBJECT_HANDLE_COUNT_ENTRY));

        CountEntries += 4;

        NewSize = sizeof(OBJECT_HANDLE_COUNT_DATABASE) +
               ((CountEntries - 1) * sizeof( OBJECT_HANDLE_COUNT_ENTRY));
    }

    //
    //  Now allocate pool for the new handle database.
    //

    NewHandleCountDataBase = ExAllocatePoolWithTag(PagedPool, NewSize,'dHbO');

    if (NewHandleCountDataBase == NULL) {

        return NULL;
    }

    //
    //  Copy over the old database.  Note that this might just copy our
    //  local dummy entry for the single entry case
    //

    RtlCopyMemory(NewHandleCountDataBase, OldHandleCountDataBase, OldSize);

    //
    //  If the previous mode was a single entry then remove that
    //  indication otherwise free up with previous handle database
    //

    if (ObjectHeader->Flags & OB_FLAG_SINGLE_HANDLE_ENTRY) {

        ObjectHeader->Flags &= ~OB_FLAG_SINGLE_HANDLE_ENTRY;

    } else {

        ExFreePool( OldHandleCountDataBase );
    }

    //
    //  Find the end of the new database that is used and zero out
    //  the memory
    //

    FreeHandleCountEntry =
        (POBJECT_HANDLE_COUNT_ENTRY)((PCHAR)NewHandleCountDataBase + OldSize);

    RtlZeroMemory(FreeHandleCountEntry, NewSize - OldSize);

    //
    //  Set the new database to the proper entry count and put it
    //  all in the object
    //

    NewHandleCountDataBase->CountEntries = CountEntries;

    HandleInfo->HandleCountDataBase = NewHandleCountDataBase;

    //
    //  And return to our caller
    //

    return FreeHandleCountEntry;
}


NTSTATUS
ObpIncrementHandleDataBase (
    IN POBJECT_HEADER ObjectHeader,
    IN PEPROCESS Process,
    OUT PULONG NewProcessHandleCount
    )

/*++

Routine Description:

    This function increments the handle count database associated with the
    specified object for a specified process. This function is assuming that
    is called only for MaintainHandleCount == TRUE.

Arguments:

    ObjectHeader - Supplies a pointer to the object.

    Process - Supplies a pointer to the process whose handle count is to be
        updated.

    NewProcessHandleCount - Supplies a pointer to a variable that receives
        the new handle count for the process.

Return Value:

    An appropriate status value

--*/

{
    POBJECT_HEADER_HANDLE_INFO HandleInfo;
    POBJECT_HANDLE_COUNT_DATABASE HandleCountDataBase;
    POBJECT_HANDLE_COUNT_ENTRY HandleCountEntry;
    POBJECT_HANDLE_COUNT_ENTRY FreeHandleCountEntry;
    ULONG CountEntries;

    PAGED_CODE();

    //
    //  Translate the object header to the handle information.
    //  The HandleInfo can't be null because this function should be
    //  called only if MaintainHandleCount == TRUE
    //

    HandleInfo = OBJECT_HEADER_TO_HANDLE_INFO_EXISTS(ObjectHeader);

    //
    //  Check if the object has space for only a single handle
    //

    if (ObjectHeader->Flags & OB_FLAG_SINGLE_HANDLE_ENTRY) {

        //
        //  If the single handle isn't in use then set the entry
        //  and tell the caller there is only one handle
        //

        if (HandleInfo->SingleEntry.HandleCount == 0) {

            *NewProcessHandleCount = 1;
            HandleInfo->SingleEntry.HandleCount = 1;
            HandleInfo->SingleEntry.Process = Process;

            return STATUS_SUCCESS;

        //
        //  If the single entry is for the same process as specified
        //  then increment the count and we're done
        //

        } else if (HandleInfo->SingleEntry.Process == Process) {

            *NewProcessHandleCount = ++HandleInfo->SingleEntry.HandleCount;

            return STATUS_SUCCESS;

        //
        //  Finally we have a object with a single handle entry already
        //  in use, so we need to grow the handle database before
        //  we can set this new value
        //

        } else {

            FreeHandleCountEntry = ObpInsertHandleCount( ObjectHeader );

            if (FreeHandleCountEntry == NULL) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }

            FreeHandleCountEntry->Process = Process;
            FreeHandleCountEntry->HandleCount = 1;
            *NewProcessHandleCount = 1;

            return STATUS_SUCCESS;
        }
    }

    //
    //  The object does not contain a single entry, therefore we're
    //  assuming it already has a handle count database
    //

    HandleCountDataBase = HandleInfo->HandleCountDataBase;

    FreeHandleCountEntry = NULL;

    if (HandleCountDataBase != NULL) {

        //
        //  Get the number of entries and a pointer to the first one
        //  in the handle database
        //

        CountEntries = HandleCountDataBase->CountEntries;
        HandleCountEntry = &HandleCountDataBase->HandleCountEntries[ 0 ];

        //
        //  For each entry in the handle database check for a process
        //  match and if so then increment the handle count and return
        //  to our caller.  Otherwise if the entry is free then remember
        //  it so we can store to it later
        //

        while (CountEntries) {

            if (HandleCountEntry->Process == Process) {

                *NewProcessHandleCount = ++HandleCountEntry->HandleCount;

                return STATUS_SUCCESS;

            } else if (HandleCountEntry->HandleCount == 0) {

                FreeHandleCountEntry = HandleCountEntry;
            }

            ++HandleCountEntry;
            --CountEntries;
        }

        //
        //  If we did not find a free handle entry then we have to grow the
        //  handle database before we can set this new value
        //

        if (FreeHandleCountEntry == NULL) {

            FreeHandleCountEntry = ObpInsertHandleCount( ObjectHeader );

            if (FreeHandleCountEntry == NULL) {

                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }

        FreeHandleCountEntry->Process = Process;
        FreeHandleCountEntry->HandleCount = 1;
        *NewProcessHandleCount = 1;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ObpIncrementHandleCount (
    OB_OPEN_REASON OpenReason,
    PEPROCESS Process,
    PVOID Object,
    POBJECT_TYPE ObjectType,
    PACCESS_STATE AccessState OPTIONAL,
    KPROCESSOR_MODE AccessMode,
    ULONG Attributes
    )

/*++

Routine Description:

    Increments the count of number of handles to the given object.

    If the object is being opened or created, access validation and
    auditing will be performed as appropriate.

Arguments:

    OpenReason - Supplies the reason the handle count is being incremented.

    Process - Pointer to the process in which the new handle will reside.

    Object - Supplies a pointer to the body of the object.

    ObjectType - Supplies the type of the object.

    AccessState - Optional parameter supplying the current accumulated
        security information describing the attempt to access the object.

    AccessMode - Supplies the mode of the requestor.

    Attributes - Desired attributes for the handle

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ProcessHandleCount;
    BOOLEAN ExclusiveHandle;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER ObjectHeader;
    BOOLEAN HasPrivilege = FALSE;
    PRIVILEGE_SET Privileges;
    BOOLEAN NewObject;
    BOOLEAN HoldObjectTypeMutex = FALSE;
    KPROCESSOR_MODE AccessCheckMode;
    ULONG NewTotal;

    PAGED_CODE();

    ObpValidateIrql( "ObpIncrementHandleCount" );

    //
    //  Get a pointer to the object header
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    //
    // If the caller asked us to always do an access check then use user mode for previous mode
    //
    if (Attributes & OBJ_FORCE_ACCESS_CHECK) {
        AccessCheckMode = UserMode;
    } else {
        AccessCheckMode = AccessMode;
    }

    ExclusiveHandle = FALSE;
    HoldObjectTypeMutex = TRUE;

    ObpLockObject( ObjectHeader );


    try {

        //
        //  Charge the user quota for the object
        //

        Status = ObpChargeQuotaForObject( ObjectHeader, ObjectType, &NewObject );

        if (!NT_SUCCESS( Status )) {

            leave;
        }

        //
        //  Check if the caller wants exclusive access and if so then
        //  make sure the attributes and header flags match up correctly
        //

        if (Attributes & OBJ_EXCLUSIVE) {

            if ((Attributes & OBJ_INHERIT) ||
                ((ObjectHeader->Flags & OB_FLAG_EXCLUSIVE_OBJECT) == 0)) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            if (((OBJECT_HEADER_TO_EXCLUSIVE_PROCESS(ObjectHeader) == NULL) &&
                 (ObjectHeader->HandleCount != 0))

                    ||

                ((OBJECT_HEADER_TO_EXCLUSIVE_PROCESS(ObjectHeader) != NULL) &&
                 (OBJECT_HEADER_TO_EXCLUSIVE_PROCESS(ObjectHeader) != PsGetCurrentProcess()))) {

                Status = STATUS_ACCESS_DENIED;
                leave;
            }

            ExclusiveHandle = TRUE;

        //
        //  The user doesn't want exclusive access so now check to make sure
        //  the attriutes and header flags match up correctly
        //

        } else if ((ObjectHeader->Flags & OB_FLAG_EXCLUSIVE_OBJECT) &&
                   (OBJECT_HEADER_TO_EXCLUSIVE_PROCESS(ObjectHeader) != NULL)) {

            Status = STATUS_ACCESS_DENIED;
            leave;
        }

        if ( (AccessCheckMode != KernelMode)
                 &&
             ObpIsKernelExclusiveObject( ObjectHeader )) {
            
            Status = STATUS_ACCESS_DENIED;
            leave;
        }

        //
        //  If handle count going from zero to one for an existing object that
        //  maintains a handle count database, but does not have an open procedure
        //  just a close procedure, then fail the call as they are trying to
        //  reopen an object by pointer and the close procedure will not know
        //  that the object has been 'recreated'
        //

        if ((ObjectHeader->HandleCount == 0) &&
            (!NewObject) &&
            (ObjectType->TypeInfo.MaintainHandleCount) &&
            (ObjectType->TypeInfo.OpenProcedure == NULL) &&
            (ObjectType->TypeInfo.CloseProcedure != NULL)) {

            Status = STATUS_UNSUCCESSFUL;
            leave;
        }

        if ((OpenReason == ObOpenHandle) ||
            ((OpenReason == ObDuplicateHandle) && ARGUMENT_PRESENT(AccessState))) {

            //
            //  Perform Access Validation to see if we can open this
            //  (already existing) object.
            //

            if (!ObCheckObjectAccess( Object,
                                      AccessState,
                                      TRUE,
                                      AccessCheckMode,
                                      &Status )) {

                leave;
            }

        } else if ((OpenReason == ObCreateHandle)) {

            //
            //  We are creating a new instance of this object type.
            //  A total of three audit messages may be generated:
            //
            //  1 - Audit the attempt to create an instance of this
            //      object type.
            //
            //  2 - Audit the successful creation.
            //
            //  3 - Audit the allocation of the handle.
            //

            //
            //  At this point, the RemainingDesiredAccess field in
            //  the AccessState may still contain either Generic access
            //  types, or MAXIMUM_ALLOWED.  We will map the generics
            //  and substitute GenericAll for MAXIMUM_ALLOWED.
            //

            if ( AccessState->RemainingDesiredAccess & MAXIMUM_ALLOWED ) {

                AccessState->RemainingDesiredAccess &= ~MAXIMUM_ALLOWED;
                AccessState->RemainingDesiredAccess |= GENERIC_ALL;
            }

            if ((GENERIC_ACCESS & AccessState->RemainingDesiredAccess) != 0) {

                RtlMapGenericMask( &AccessState->RemainingDesiredAccess,
                                   &ObjectType->TypeInfo.GenericMapping );
            }

            //
            //  Since we are creating the object, we can give any access the caller
            //  wants.  The only exception is ACCESS_SYSTEM_SECURITY, which requires
            //  a privilege.
            //

            if ( AccessState->RemainingDesiredAccess & ACCESS_SYSTEM_SECURITY ) {

                //
                //  We could use SeSinglePrivilegeCheck here, but it
                //  captures the subject context again, and we don't
                //  want to do that in this path for performance reasons.
                //

                Privileges.PrivilegeCount = 1;
                Privileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
                Privileges.Privilege[0].Luid = SeSecurityPrivilege;
                Privileges.Privilege[0].Attributes = 0;

                HasPrivilege = SePrivilegeCheck( &Privileges,
                                                 &AccessState->SubjectSecurityContext,
                                                 AccessCheckMode );

                if (!HasPrivilege) {

                    SePrivilegedServiceAuditAlarm ( NULL,
                                                    &AccessState->SubjectSecurityContext,
                                                    &Privileges,
                                                    FALSE );

                    Status = STATUS_PRIVILEGE_NOT_HELD;
                    leave;
                }

                AccessState->RemainingDesiredAccess &= ~ACCESS_SYSTEM_SECURITY;
                AccessState->PreviouslyGrantedAccess |= ACCESS_SYSTEM_SECURITY;

                (VOID) SeAppendPrivileges( AccessState,
                                           &Privileges );
            }
        }

        if (ExclusiveHandle) {

            OBJECT_HEADER_TO_QUOTA_INFO_EXISTS(ObjectHeader)->ExclusiveProcess = Process;
        }

        ObpIncrHandleCount( ObjectHeader );
        ProcessHandleCount = 0;

        //
        //  If the object type wants us to keep try of the handle counts
        //  then call our routine to do the work
        //

        if (ObjectType->TypeInfo.MaintainHandleCount) {

            Status = ObpIncrementHandleDataBase( ObjectHeader,
                                                 Process,
                                                 &ProcessHandleCount );

            if (!NT_SUCCESS(Status)) {

                //
                //  The only thing we need to do is to remove the
                //  reference added before. The quota charge will be
                //  returned at object deletion
                //

                ObpDecrHandleCount( ObjectHeader );

                leave;
            }
        }

        ObpUnlockObject( ObjectHeader );
        HoldObjectTypeMutex = FALSE;
        //
        //  Set our preliminary status now to success because
        //  the call to the open procedure might change this
        //

        Status = STATUS_SUCCESS;

        //
        //  If the object type has an open procedure
        //  then invoke that procedure
        //

        if (ObjectType->TypeInfo.OpenProcedure != NULL) {

#if DBG
            KIRQL SaveIrql;
#endif

            //
            //  Leave the object type mutex when call the OpenProcedure. If an exception
            //  while OpenProcedure the HoldObjectTypeMutex disable leaving the mutex
            //  on finally block
            //

            ObpBeginTypeSpecificCallOut( SaveIrql );

            Status = (*ObjectType->TypeInfo.OpenProcedure)( OpenReason,
                                                            Process,
                                                            Object,
                                                            AccessState ?
                                                                AccessState->PreviouslyGrantedAccess :
                                                                0,
                                                            ProcessHandleCount );

            ObpEndTypeSpecificCallOut( SaveIrql, "Open", ObjectType, Object );

            //
            //  Hold back the object type mutex and set the HoldObjectTypeMutex variable
            //  to allow releasing the mutex while leaving this procedure
            //


            if (!NT_SUCCESS(Status)) {

                ObpLockObject( ObjectHeader );
                HoldObjectTypeMutex = TRUE;

                (VOID)ObpDecrHandleCount( ObjectHeader );
                leave;
            }
        }

        //
        //  Get the objects creator info block and insert it on the
        //  global list of objects for that type
        //

        if (OpenReason == ObCreateHandle) {
            CreatorInfo = OBJECT_HEADER_TO_CREATOR_INFO( ObjectHeader );

            if (CreatorInfo != NULL) {

                ObpEnterObjectTypeMutex( ObjectType );
                
                InsertTailList( &ObjectType->TypeList, &CreatorInfo->TypeList );
                
                ObpLeaveObjectTypeMutex( ObjectType );
            }
        }

        //
        //  Do some simple bookkeeping for the handle counts
        //  and then return to our caller
        //

        NewTotal = (ULONG) InterlockedIncrement((PLONG)&ObjectType->TotalNumberOfHandles);

        //
        //  Note: The highwater mark is only for bookkeeping. We can do this w/o
        //  lock. In the worst case next time will be updated
        //

        if (NewTotal > ObjectType->HighWaterNumberOfHandles) {

            ObjectType->HighWaterNumberOfHandles = NewTotal;
        }

    } finally {

        if ( HoldObjectTypeMutex ) {

            ObpUnlockObject( ObjectHeader );
        }
    }

    return( Status );
}


NTSTATUS
ObpIncrementUnnamedHandleCount (
    PACCESS_MASK DesiredAccess,
    PEPROCESS Process,
    PVOID Object,
    POBJECT_TYPE ObjectType,
    KPROCESSOR_MODE AccessMode,
    ULONG Attributes
    )

/*++

Routine Description:

    Increments the count of number of handles to the given object.

Arguments:

    Desired Access - Supplies the desired access to the object and receives
        the assign access mask

    Process - Pointer to the process in which the new handle will reside.

    Object - Supplies a pointer to the body of the object.

    ObjectType - Supplies the type of the object.

    AccessMode - Supplies the mode of the requestor.

    Attributes - Desired attributes for the handle

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ExclusiveHandle;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER ObjectHeader;
    BOOLEAN NewObject;
    ULONG ProcessHandleCount;
    BOOLEAN HoldObjectTypeMutex = FALSE;
    ULONG NewTotal;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (AccessMode);

    ObpValidateIrql( "ObpIncrementUnnamedHandleCount" );

    //
    //  Get a pointer to the object header
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    ExclusiveHandle = FALSE;
    HoldObjectTypeMutex = TRUE;

    ObpLockObject( ObjectHeader );

    try {


        //
        //  Charge the user quota for the object
        //

        Status = ObpChargeQuotaForObject( ObjectHeader, ObjectType, &NewObject );

        if (!NT_SUCCESS( Status )) {

            leave;
        }
        //
        //  Check if the caller wants exclusive access and if so then
        //  make sure the attributes and header flags match up correctly
        //

        if (Attributes & OBJ_EXCLUSIVE) {

            if ((Attributes & OBJ_INHERIT) ||
                ((ObjectHeader->Flags & OB_FLAG_EXCLUSIVE_OBJECT) == 0)) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            if (((OBJECT_HEADER_TO_EXCLUSIVE_PROCESS(ObjectHeader) == NULL) &&
                 (ObjectHeader->HandleCount != 0))

                        ||

                ((OBJECT_HEADER_TO_EXCLUSIVE_PROCESS(ObjectHeader) != NULL) &&
                 (OBJECT_HEADER_TO_EXCLUSIVE_PROCESS(ObjectHeader) != PsGetCurrentProcess()))) {

                Status = STATUS_ACCESS_DENIED;
                leave;
            }

            ExclusiveHandle = TRUE;

        //
        //  The user doesn't want exclusive access so now check to make sure
        //  the attriutes and header flags match up correctly
        //

        } else if ((ObjectHeader->Flags & OB_FLAG_EXCLUSIVE_OBJECT) &&
                   (OBJECT_HEADER_TO_EXCLUSIVE_PROCESS(ObjectHeader) != NULL)) {

            Status = STATUS_ACCESS_DENIED;
            leave;
        }

        //
        //  If handle count going from zero to one for an existing object that
        //  maintains a handle count database, but does not have an open procedure
        //  just a close procedure, then fail the call as they are trying to
        //  reopen an object by pointer and the close procedure will not know
        //  that the object has been 'recreated'
        //

        if ((ObjectHeader->HandleCount == 0) &&
            (!NewObject) &&
            (ObjectType->TypeInfo.MaintainHandleCount) &&
            (ObjectType->TypeInfo.OpenProcedure == NULL) &&
            (ObjectType->TypeInfo.CloseProcedure != NULL)) {

            Status = STATUS_UNSUCCESSFUL;

            leave;
        }

        //
        //  If the user asked for the maximum allowed then remove the bit and
        //  or in generic all access
        //

        if ( *DesiredAccess & MAXIMUM_ALLOWED ) {

            *DesiredAccess &= ~MAXIMUM_ALLOWED;
            *DesiredAccess |= GENERIC_ALL;
        }

        //  If the user asked for any generic bit then translate it to
        //  someone more appropriate for the object type
        //

        if ((GENERIC_ACCESS & *DesiredAccess) != 0) {

            RtlMapGenericMask( DesiredAccess,
                               &ObjectType->TypeInfo.GenericMapping );
        }

        if (ExclusiveHandle) {

            OBJECT_HEADER_TO_QUOTA_INFO_EXISTS(ObjectHeader)->ExclusiveProcess = Process;
        }

        ObpIncrHandleCount( ObjectHeader );
        ProcessHandleCount = 0;

        //
        //  If the object type wants us to keep try of the handle counts
        //  then call our routine to do the work
        //

        if (ObjectType->TypeInfo.MaintainHandleCount) {

            Status = ObpIncrementHandleDataBase( ObjectHeader,
                                                 Process,
                                                 &ProcessHandleCount );

            if (!NT_SUCCESS(Status)) {

                //
                //  The only thing we need to do is to remove the
                //  reference added before. The quota charge will be
                //  returned at object deletion.
                //

                ObpDecrHandleCount( ObjectHeader );
                leave;
            }
        }

        ObpUnlockObject( ObjectHeader );
        HoldObjectTypeMutex = FALSE;

        //
        //  Set our preliminary status now to success because
        //  the call to the open procedure might change this
        //

        Status = STATUS_SUCCESS;

        //
        //  If the object type has an open procedure
        //  then invoke that procedure
        //

        if (ObjectType->TypeInfo.OpenProcedure != NULL) {

#if DBG
            KIRQL SaveIrql;
#endif

            //
            //  Call the OpenProcedure. If an exception
            //  while OpenProcedure the HoldObjectTypeMutex disable leaving the mutex
            //  on finally block
            //


            ObpBeginTypeSpecificCallOut( SaveIrql );

            Status = (*ObjectType->TypeInfo.OpenProcedure)( ObCreateHandle,
                                                       Process,
                                                       Object,
                                                       *DesiredAccess,
                                                       ProcessHandleCount );

            ObpEndTypeSpecificCallOut( SaveIrql, "Open", ObjectType, Object );

            //
            //  Hold back the object type mutex and set the HoldObjectTypeMutex variable
            //  to allow releasing the mutex while leaving this procedure
            //


            if (!NT_SUCCESS(Status)) {

                ObpLockObject( ObjectHeader );
                HoldObjectTypeMutex = TRUE;

                (VOID)ObpDecrHandleCount( ObjectHeader );
                leave;
            }
        }

        //
        //  Get a pointer to the creator info block for the object and insert
        //  it on the global list of object for that type
        //

        CreatorInfo = OBJECT_HEADER_TO_CREATOR_INFO( ObjectHeader );

        if (CreatorInfo != NULL) {

            ObpEnterObjectTypeMutex( ObjectType );

            InsertTailList( &ObjectType->TypeList, &CreatorInfo->TypeList );

            ObpLeaveObjectTypeMutex( ObjectType );
        }

        //
        //  Do some simple bookkeeping for the handle counts
        //  and then return to our caller
        //

        NewTotal = (ULONG) InterlockedIncrement((PLONG)&ObjectType->TotalNumberOfHandles);

        if (NewTotal > ObjectType->HighWaterNumberOfHandles) {

            ObjectType->HighWaterNumberOfHandles = NewTotal;
        }

    } finally {

        if ( HoldObjectTypeMutex ) {

            ObpUnlockObject( ObjectHeader );
        }
    }

    return( Status );
}


NTSTATUS
ObpChargeQuotaForObject (
    IN POBJECT_HEADER ObjectHeader,
    IN POBJECT_TYPE ObjectType,
    OUT PBOOLEAN NewObject
    )

/*++

Routine Description:

    This routine charges quota against the current process for the new
    object

Arguments:

    ObjectHeader - Supplies a pointer to the new object being charged for

    ObjectType - Supplies the type of the new object

    NewObject - Returns true if the object is really new and false otherwise

Return Value:

    An appropriate status value

--*/

{
    POBJECT_HEADER_QUOTA_INFO QuotaInfo;
    ULONG NonPagedPoolCharge;
    ULONG PagedPoolCharge;

    //
    //  Get a pointer to the quota block for this object
    //

    QuotaInfo = OBJECT_HEADER_TO_QUOTA_INFO( ObjectHeader );

    *NewObject = FALSE;

    //
    //  If the object is new then we have work to do otherwise
    //  we'll return with NewObject set to false
    //

    if (ObjectHeader->Flags & OB_FLAG_NEW_OBJECT) {

        //
        //  Say the object now isn't new
        //

        ObjectHeader->Flags &= ~OB_FLAG_NEW_OBJECT;

        //
        //  If there does exist a quota info structure for this
        //  object then calculate what our charge should be from
        //  the information stored in that structure
        //

        if (QuotaInfo != NULL) {

            PagedPoolCharge = QuotaInfo->PagedPoolCharge +
                              QuotaInfo->SecurityDescriptorCharge;
            NonPagedPoolCharge = QuotaInfo->NonPagedPoolCharge;

        } else {

            //
            //  There isn't any quota information so we're on our own
            //  Paged pool charge is the default for the object plus
            //  the security descriptor if present.  Nonpaged pool charge
            //  is the default for the object.
            //

            PagedPoolCharge = ObjectType->TypeInfo.DefaultPagedPoolCharge;

            if (ObjectHeader->SecurityDescriptor != NULL) {

                ObjectHeader->Flags |= OB_FLAG_DEFAULT_SECURITY_QUOTA;
                PagedPoolCharge += SE_DEFAULT_SECURITY_QUOTA;
            }

            NonPagedPoolCharge = ObjectType->TypeInfo.DefaultNonPagedPoolCharge;
        }

        //
        //  Now charge for the quota and make sure it succeeds
        //

        ObjectHeader->QuotaBlockCharged = (PVOID)PsChargeSharedPoolQuota( PsGetCurrentProcess(),
                                                                          PagedPoolCharge,
                                                                          NonPagedPoolCharge );

        if (ObjectHeader->QuotaBlockCharged == NULL) {

            return STATUS_QUOTA_EXCEEDED;
        }

        *NewObject = TRUE;
    }

    return STATUS_SUCCESS;
}


VOID
ObpDecrementHandleCount (
    PEPROCESS Process,
    POBJECT_HEADER ObjectHeader,
    POBJECT_TYPE ObjectType,
    ACCESS_MASK GrantedAccess
    )

/*++

Routine Description:

    This procedure decrements the handle count for the specified object

Arguments:

    Process - Supplies the process where the handle existed

    ObjectHeader - Supplies a pointer to the object header for the object

    ObjectType - Supplies a type of the object

    GrantedAccess - Supplies the current access mask to the object

Return Value:

    None.

--*/

{
    POBJECT_HEADER_HANDLE_INFO HandleInfo;
    POBJECT_HANDLE_COUNT_DATABASE HandleCountDataBase;
    POBJECT_HANDLE_COUNT_ENTRY HandleCountEntry;
    PVOID Object;
    ULONG CountEntries;
    ULONG ProcessHandleCount;
    ULONG_PTR SystemHandleCount;
    LOGICAL HandleCountIsZero;

    PAGED_CODE();


    Object = (PVOID)&ObjectHeader->Body;

    ProcessHandleCount = 0;

    ObpLockObject( ObjectHeader );

    SystemHandleCount = ObjectHeader->HandleCount;

    //
    //  Decrement the handle count and it was one and it
    //  was an exclusive object then zero out the exclusive
    //  process
    //

    HandleCountIsZero = ObpDecrHandleCount( ObjectHeader );

    if ( HandleCountIsZero &&
        (ObjectHeader->Flags & OB_FLAG_EXCLUSIVE_OBJECT)) {

        OBJECT_HEADER_TO_QUOTA_INFO_EXISTS( ObjectHeader )->ExclusiveProcess = NULL;
    }

    //
    //  If the object maintains a handle count database then
    //  search through the handle database and decrement
    //  the necessary information
    //

    if (ObjectType->TypeInfo.MaintainHandleCount) {

        HandleInfo = OBJECT_HEADER_TO_HANDLE_INFO_EXISTS( ObjectHeader );

        //
        //  Check if there is a single handle entry, then it better
        //  be ours
        //

        if (ObjectHeader->Flags & OB_FLAG_SINGLE_HANDLE_ENTRY) {

            ASSERT(HandleInfo->SingleEntry.Process == Process);
            ASSERT(HandleInfo->SingleEntry.HandleCount > 0);

            ProcessHandleCount = HandleInfo->SingleEntry.HandleCount--;
            HandleCountEntry = &HandleInfo->SingleEntry;

        } else {

            //
            //  Otherwise search the database for a process match
            //

            HandleCountDataBase = HandleInfo->HandleCountDataBase;

            if (HandleCountDataBase != NULL) {

                CountEntries = HandleCountDataBase->CountEntries;
                HandleCountEntry = &HandleCountDataBase->HandleCountEntries[ 0 ];

                while (CountEntries) {

                    if ((HandleCountEntry->HandleCount != 0) &&
                        (HandleCountEntry->Process == Process)) {

                        ProcessHandleCount = HandleCountEntry->HandleCount--;

                        break;
                    }

                    HandleCountEntry++;
                    CountEntries--;
                }
            }
            else {
                HandleCountEntry = NULL;
            }
        }

        //
        //  Now if the process is giving up all handles to the object
        //  then zero out the handle count entry.  For a single handle
        //  entry this is just the single entry in the header handle info
        //  structure
        //

        if (ProcessHandleCount == 1) {

            HandleCountEntry->Process = NULL;
            HandleCountEntry->HandleCount = 0;
        }
    }

    ObpUnlockObject( ObjectHeader );

    //
    //  If the Object Type has a Close Procedure, then release the type
    //  mutex before calling it, and then call ObpDeleteNameCheck without
    //  the mutex held.
    //

    if (ObjectType->TypeInfo.CloseProcedure) {

#if DBG
        KIRQL SaveIrql;
#endif

        ObpBeginTypeSpecificCallOut( SaveIrql );

        (*ObjectType->TypeInfo.CloseProcedure)( Process,
                                                Object,
                                                GrantedAccess,
                                                ProcessHandleCount,
                                                SystemHandleCount );

        ObpEndTypeSpecificCallOut( SaveIrql, "Close", ObjectType, Object );

    }

    ObpDeleteNameCheck( Object );

    InterlockedDecrement((PLONG)&ObjectType->TotalNumberOfHandles);

    return;
}


NTSTATUS
ObpCreateHandle (
    IN OB_OPEN_REASON OpenReason,
    IN PVOID Object,
    IN POBJECT_TYPE ExpectedObjectType OPTIONAL,
    IN PACCESS_STATE AccessState,
    IN ULONG ObjectPointerBias OPTIONAL,
    IN ULONG Attributes,
    IN POBP_LOOKUP_CONTEXT LookupContext,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *ReferencedNewObject OPTIONAL,
    OUT PHANDLE Handle
    )

/*++

Routine Description:

    This function creates a new handle to an existing object

Arguments:

    OpenReason - The reason why we are doing this work

    Object - A pointer to the body of the new object

    ExpectedObjectType - Optionally Supplies the object type that
        the caller is expecting

    AccessState - Supplies the access state for the handle requested
        by the caller

    ObjectPointerBias - Optionally supplies a count of addition
        increments we do to the pointer count for the object

    Attributes -  Desired attributes for the handle

    DirectoryLocked - Indicates if the root directory mutex is already held

    AccessMode - Supplies the mode of the requestor.

    ReferencedNewObject - Optionally receives a pointer to the body
        of the new object

    Handle - Receives the new handle value

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    PVOID ObjectTable;
    HANDLE_TABLE_ENTRY ObjectTableEntry;
    HANDLE NewHandle;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK GrantedAccess;
    BOOLEAN AttachedToProcess = FALSE;
    BOOLEAN KernelHandle = FALSE;
    KAPC_STATE ApcState;
    HANDLE_TABLE_ENTRY_INFO ObjectInfo;

    PAGED_CODE();

    ObpValidateIrql( "ObpCreateHandle" );

    //
    //  Get a pointer to the object header and object type
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    //
    //  If the object type isn't what was expected then
    //  return an error to our caller, but first see if
    //  we should release the directory mutex
    //

    if ((ARGUMENT_PRESENT( ExpectedObjectType )) &&
        (ObjectType != ExpectedObjectType )) {

        if (LookupContext) {
            ObpReleaseLookupContext( LookupContext );
        }

        return( STATUS_OBJECT_TYPE_MISMATCH );
    }

    //
    //  Set the first ulong of the object table entry to point
    //  back to the object header
    //

    ObjectTableEntry.Object = ObjectHeader;

    //
    //  Now get a pointer to the object table for either the current process
    //  of the kernel handle table. OBJ_KERNEL_HANDLE dropped for user mode on capture.
    //

    if ((Attributes & OBJ_KERNEL_HANDLE) /* && (AccessMode == KernelMode) */) {

        ObjectTable = ObpKernelHandleTable;
        KernelHandle = TRUE;

        //
        //  Go to the system process if we have to
        //

        if (PsGetCurrentProcess() != PsInitialSystemProcess) {
            KeStackAttachProcess (&PsInitialSystemProcess->Pcb, &ApcState);
            AttachedToProcess = TRUE;
        }


    } else {

        ObjectTable = ObpGetObjectTable();
    }

    //
    //  ObpIncrementHandleCount will perform access checking on the
    //  object being opened as appropriate.
    //

    Status = ObpIncrementHandleCount( OpenReason,
                                      PsGetCurrentProcess(),
                                      Object,
                                      ObjectType,
                                      AccessState,
                                      AccessMode,
                                      Attributes );

    if (AccessState->GenerateOnClose) {

        Attributes |= OBJ_AUDIT_OBJECT_CLOSE;
    }

    //
    //  Or in some low order bits into the first ulong of the object
    //  table entry
    //

    ObjectTableEntry.ObAttributes |= (Attributes & OBJ_HANDLE_ATTRIBUTES);

    //
    //  Merge both the remaining desired access and the currently
    //  granted access states into one mask and then compute
    //  the granted access
    //

    DesiredAccess = AccessState->RemainingDesiredAccess |
                    AccessState->PreviouslyGrantedAccess;

    GrantedAccess = DesiredAccess &
                    (ObjectType->TypeInfo.ValidAccessMask | ACCESS_SYSTEM_SECURITY );

    //
    // AccessState->PreviouslyGrantedAccess is used for success audits in SeAuditHandleCreation() which uses it in calls
    // to SepAdtPrivilegeObjectAuditAlarm() and SepAdtOpenObjectAuditAlarm().  Sanitize any bad bits from it.
    //

    AccessState->PreviouslyGrantedAccess = GrantedAccess;

    //
    //  Compute and save away the audit mask for this object
    //  (if one exists).  Note we only do this if the GenerateOnClose
    //  flag comes back in the access state, because this tells us
    //  that the audit is a result of what is in the SACL.
    //

    ObjectInfo.AuditMask = ((PAUX_ACCESS_DATA)AccessState->AuxData)->MaximumAuditMask;


    if (!NT_SUCCESS( Status )) {
        
        if (LookupContext) {
            
            ObpReleaseLookupContext( LookupContext );
        }

        if (AttachedToProcess) {
            
            KeUnstackDetachProcess(&ApcState);
            AttachedToProcess = FALSE;
        }

        return( Status );
    }

    //
    //  We need to reference the object before calling
    //  ObpReleaseLookupContext to make sure we'll have a valid object
    //  Note that ObpReleaseLookupContext has the side effect of
    //  dereferencing the object.
    //

    if (ARGUMENT_PRESENT( ObjectPointerBias )) {

        //
        //  Bias the pointer count if that is what the caller wanted
        //

        ObpIncrPointerCountEx (ObjectHeader, ObjectPointerBias);
    }

    //
    //  Unlock the directory if it is locked
    //

    if (LookupContext) {

        ObpReleaseLookupContext( LookupContext );
    }

    //
    //  Set the granted access mask in the object table entry (second ulong)
    //

#if i386

    if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

        LONG StackTraceIndex;

        ObjectTableEntry.GrantedAccessIndex = ObpComputeGrantedAccessIndex( GrantedAccess );

        if (AccessMode == KernelMode) {

            StackTraceIndex = RtlLogStackBackTrace();

        } else {

            StackTraceIndex = RtlLogUmodeStackBackTrace();
        }

        //
        //  Save the stack trace only if the index fits the CreatorBackTraceIndex
        //  minus the ProtectOnClose bit
        //

        if (StackTraceIndex < OBP_CREATOR_BACKTRACE_LIMIT) {

            ObjectTableEntry.CreatorBackTraceIndex = (USHORT)StackTraceIndex;
        
        } else {

            ObjectTableEntry.CreatorBackTraceIndex = 0;
        }

    } else {

        ObjectTableEntry.GrantedAccess = GrantedAccess;
    }

#else

    ObjectTableEntry.GrantedAccess = GrantedAccess;

#endif // i386 

    //
    //  Add this new object table entry to the object table for the process
    //

    ObpEncodeProtectClose(ObjectTableEntry);

    NewHandle = ExCreateHandle( ObjectTable, &ObjectTableEntry );

    //
    //  If we didn't get a handle then cleanup after ourselves and return
    //  the error to our caller
    //

    if (NewHandle == NULL) {

        ObpDecrementHandleCount( PsGetCurrentProcess(),
                                 ObjectHeader,
                                 ObjectType,
                                 GrantedAccess );

        if (ARGUMENT_PRESENT( ObjectPointerBias )) {

            if (ObjectPointerBias > 1) {
                
                ObpDecrPointerCountEx (ObjectHeader, ObjectPointerBias - 1);
            }

            ObDereferenceObject( Object );
        }

        //
        //  If we are attached to the system process then return
        //  back to our caller
        //

        if (AttachedToProcess) {
            KeUnstackDetachProcess(&ApcState);
            AttachedToProcess = FALSE;
        }

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    if ( ObjectInfo.AuditMask != 0 ) {

        PHANDLE_TABLE_ENTRY HandleTableEntry;
        PKTHREAD CurrentThread;
        
        CurrentThread = KeGetCurrentThread();

        KeEnterCriticalRegionThread( CurrentThread );
        
        //
        //  Make sure it's the same object before setting the handle information.
        //  The user may have closed it immediately after the ExCreateHandle call,
        //  so at this time it may either be invalid or a completely different object.
        //


        HandleTableEntry = ExMapHandleToPointer ( ObjectTable, NewHandle );

        if (HandleTableEntry != NULL) {

            if (((ULONG_PTR)(HandleTableEntry->Object) & ~OBJ_HANDLE_ATTRIBUTES) == (ULONG_PTR)ObjectHeader) {

                ExSetHandleInfo(ObjectTable, NewHandle, &ObjectInfo, TRUE);
            }

            ExUnlockHandleTableEntry( ObjectTable, HandleTableEntry );
        }
        
        KeLeaveCriticalRegionThread( CurrentThread );
    }

    //
    //  We have a new Ex style handle now make it an ob style handle and also
    //  adjust for the kernel handle by setting the sign bit in the handle
    //  value
    //

    if (KernelHandle) {

        NewHandle = EncodeKernelHandle( NewHandle );
    }

    *Handle = NewHandle;

    //
    //  If requested, generate audit messages to indicate that a new handle
    //  has been allocated.
    //
    //  This is the final security operation in the creation/opening of the
    //  object.
    //

    if ( AccessState->GenerateAudit ) {

        SeAuditHandleCreation( AccessState,
                               *Handle );
    }

    if (OpenReason == ObCreateHandle) {

        PAUX_ACCESS_DATA AuxData = AccessState->AuxData;

        if ( ( AuxData->PrivilegesUsed != NULL) && (AuxData->PrivilegesUsed->PrivilegeCount > 0) ) {

            SePrivilegeObjectAuditAlarm( *Handle,
                                         &AccessState->SubjectSecurityContext,
                                         GrantedAccess,
                                         AuxData->PrivilegesUsed,
                                         TRUE,
                                         KeGetPreviousMode() );
        }
    }

    //
    //  If the caller had a pointer bias and wanted the new reference object
    //  then return that value
    //

    if ((ARGUMENT_PRESENT( ObjectPointerBias )) &&
        (ARGUMENT_PRESENT( ReferencedNewObject ))) {

        *ReferencedNewObject = Object;
    }

    //
    //  If we are attached to the system process then return
    //  back to our caller
    //

    if (AttachedToProcess) {
        KeUnstackDetachProcess(&ApcState);
        AttachedToProcess = FALSE;
    }

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}


NTSTATUS
ObpCreateUnnamedHandle (
    IN PVOID Object,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ObjectPointerBias OPTIONAL,
    IN ULONG Attributes,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *ReferencedNewObject OPTIONAL,
    OUT PHANDLE Handle
    )

/*++

Routine Description:

    This function creates a new unnamed handle for an existing object

Arguments:

    Object - A pointer to the body of the new object

    DesiredAccess - Supplies the access mask being requested

    ObjectPointerBias - Optionally supplies a count of addition
        increments we do to the pointer count for the object

    Attributes -  Desired attributes for the handle

    AccessMode - Supplies the mode of the requestor.

    ReferencedNewObject - Optionally receives a pointer to the body
        of the new object

    Handle - Receives the new handle value

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    PVOID ObjectTable;
    HANDLE_TABLE_ENTRY ObjectTableEntry;
    HANDLE NewHandle;
    ACCESS_MASK GrantedAccess;
    BOOLEAN AttachedToProcess = FALSE;
    BOOLEAN KernelHandle = FALSE;
    KAPC_STATE ApcState;

    PAGED_CODE();

    ObpValidateIrql( "ObpCreateUnnamedHandle" );

    //
    //  Get the object header and type for the new object
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    //
    //  Set the first ulong of the object table entry to point
    //  to the object header and then or in the low order attribute
    //  bits
    //

    ObjectTableEntry.Object = ObjectHeader;

    ObjectTableEntry.ObAttributes |= (Attributes & OBJ_HANDLE_ATTRIBUTES);

    //
    //  Now get a pointer to the object table for either the current process
    //  of the kernel handle table
    //

    if ((Attributes & OBJ_KERNEL_HANDLE) /* && (AccessMode == KernelMode) */) {

        ObjectTable = ObpKernelHandleTable;
        KernelHandle = TRUE;

        //
        //  Go to the system process if we have to
        //

        if (PsGetCurrentProcess() != PsInitialSystemProcess) {
            KeStackAttachProcess (&PsInitialSystemProcess->Pcb, &ApcState);
            AttachedToProcess = TRUE;
        }

    } else {

        ObjectTable = ObpGetObjectTable();
    }

    //
    //  Increment the handle count, this routine also does the access
    //  check if necessary
    //

    Status = ObpIncrementUnnamedHandleCount( &DesiredAccess,
                                             PsGetCurrentProcess(),
                                             Object,
                                             ObjectType,
                                             AccessMode,
                                             Attributes );


    GrantedAccess = DesiredAccess &
                    (ObjectType->TypeInfo.ValidAccessMask | ACCESS_SYSTEM_SECURITY );

    if (!NT_SUCCESS( Status )) {

        //
        //  If we are attached to the system process then return
        //  back to our caller
        //

        if (AttachedToProcess) {
            KeUnstackDetachProcess(&ApcState);
            AttachedToProcess = FALSE;
        }

        return( Status );
    }

    //
    //  Bias the pointer count if that is what the caller wanted
    //

    if (ARGUMENT_PRESENT( ObjectPointerBias )) {

        ObpIncrPointerCountEx (ObjectHeader, ObjectPointerBias);

    }

    //
    //  Set the granted access mask in the object table entry (second ulong)
    //

#if i386 

    if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

        LONG StackTraceIndex;

        ObjectTableEntry.GrantedAccessIndex = ObpComputeGrantedAccessIndex( GrantedAccess );

        if (AccessMode == KernelMode) {

            StackTraceIndex = RtlLogStackBackTrace();

        } else {

            StackTraceIndex = RtlLogUmodeStackBackTrace();
        }

        //
        //  Save the stack trace only if the index fits the CreatorBackTraceIndex
        //  minus the ProtectOnClose bit
        //

        if (StackTraceIndex < OBP_CREATOR_BACKTRACE_LIMIT) {

            ObjectTableEntry.CreatorBackTraceIndex = (USHORT)StackTraceIndex;

        } else {

            ObjectTableEntry.CreatorBackTraceIndex = 0;
        }

    } else {

        ObjectTableEntry.GrantedAccess = GrantedAccess;
    }

#else

    ObjectTableEntry.GrantedAccess = GrantedAccess;

#endif // i386 

    //
    //  Add this new object table entry to the object table for the process
    //

    ObpEncodeProtectClose(ObjectTableEntry);

    NewHandle = ExCreateHandle( ObjectTable, &ObjectTableEntry );

    //
    //  If we didn't get a handle then cleanup after ourselves and return
    //  the error to our caller
    //

    if (NewHandle == NULL) {

        //
        //  The caller must have a reference to this object while 
        //  making this call. The pointer count cannot drop to 0
        //

        if (ARGUMENT_PRESENT( ObjectPointerBias )) {

            ObpDecrPointerCountEx (ObjectHeader, ObjectPointerBias);
        }

        ObpDecrementHandleCount( PsGetCurrentProcess(),
                                 ObjectHeader,
                                 ObjectType,
                                 GrantedAccess );

        //
        //  If we are attached to the system process then return
        //  back to our caller
        //

        if (AttachedToProcess) {
            KeUnstackDetachProcess(&ApcState);
            AttachedToProcess = FALSE;
        }

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  We have a new Ex style handle now make it an ob style handle and also
    //  adjust for the kernel handle by setting the sign bit in the handle
    //  value
    //

    if (KernelHandle) {

        NewHandle = EncodeKernelHandle( NewHandle );
    }

    *Handle = NewHandle;

    //
    //  If the caller had a pointer bias and wanted the new reference object
    //  then return that value
    //

    if ((ARGUMENT_PRESENT( ObjectPointerBias )) &&
        (ARGUMENT_PRESENT( ReferencedNewObject ))) {

        *ReferencedNewObject = Object;
    }

    //
    //  If we are attached to the system process then return
    //  back to our caller
    //

    if (AttachedToProcess) {
        KeUnstackDetachProcess(&ApcState);
        AttachedToProcess = FALSE;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
ObpValidateDesiredAccess (
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine checks the input desired access mask to see that
    some invalid bits are not set.  The invalid bits are the top
    two reserved bits and the top three standard rights bits.
    See \nt\public\sdk\inc\ntseapi.h for more details.

Arguments:

    DesiredAccess - Supplies the mask being checked

Return Value:

    STATUS_ACCESS_DENIED if one or more of the wrongs bits are set and
    STATUS_SUCCESS otherwise

--*/

{
    if (DesiredAccess & 0x0CE00000) {

        return( STATUS_ACCESS_DENIED );

    } else {

        return( STATUS_SUCCESS );
    }
}


#if i386 

//
//  The following three variables are just performance counters
//  for the following two routines
//

ULONG ObpXXX1;
ULONG ObpXXX2;
ULONG ObpXXX3;

USHORT
ObpComputeGrantedAccessIndex (
    ACCESS_MASK GrantedAccess
    )

/*++

Routine Description:

    This routine takes a granted access and returns and index
    back to our cache of granted access masks.

Arguments:

    GrantedAccess - Supplies the access mask being added to the cache

Return Value:

    USHORT - returns an index in the cache for the input granted access

--*/

{
    ULONG GrantedAccessIndex, n;
    PACCESS_MASK p;
    PKTHREAD CurrentThread;

    ObpXXX1 += 1;

    //
    //  Lock the global data structure
    //

    CurrentThread = KeGetCurrentThread ();

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockExclusive ( &ObpLock );

    n = ObpCurCachedGrantedAccessIndex;
    p = ObpCachedGrantedAccesses;

    //
    //  For each index in our cache look for a match and if found
    //  then unlock the data structure and return that index
    //

    for (GrantedAccessIndex = 0; GrantedAccessIndex < n; GrantedAccessIndex++, p++ ) {

        ObpXXX2 += 1;

        if (*p == GrantedAccess) {

            ExReleasePushLockExclusive ( &ObpLock );
            KeLeaveCriticalRegionThread (CurrentThread);
            return (USHORT)GrantedAccessIndex;
        }
    }

    //
    //  We didn't find a match now see if we've maxed out the cache
    //

    if (ObpCurCachedGrantedAccessIndex == ObpMaxCachedGrantedAccessIndex) {

        DbgPrint( "OB: GrantedAccess cache limit hit.\n" );
        DbgBreakPoint();
    }

    //
    //  Set the granted access to the next free slot and increment the
    //  number used in the cache, release the lock, and return the
    //  new index to our caller
    //

    *p = GrantedAccess;
    ObpCurCachedGrantedAccessIndex += 1;

    ExReleasePushLockExclusive ( &ObpLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return (USHORT)GrantedAccessIndex;
}

ACCESS_MASK
ObpTranslateGrantedAccessIndex (
    USHORT GrantedAccessIndex
    )

/*++

Routine Description:

    This routine takes as input a cache index and returns
    the corresponding granted access mask

Arguments:

    GrantedAccessIndex - Supplies the cache index to look up

Return Value:

    ACCESS_MASK - Returns the corresponding desired access mask

--*/

{
    ACCESS_MASK GrantedAccess = (ACCESS_MASK)0;
    PKTHREAD CurrentThread;

    ObpXXX3 += 1;

    //
    //  Lock the global data structure
    //

    CurrentThread = KeGetCurrentThread ();

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockExclusive ( &ObpLock );

    //
    //  If the input index is within bounds then get the granted
    //  access
    //

    if (GrantedAccessIndex < ObpCurCachedGrantedAccessIndex) {

        GrantedAccess = ObpCachedGrantedAccesses[ GrantedAccessIndex ];
    }

    //
    //  Release the lock and return the granted access to our caller
    //

    ExReleasePushLockExclusive ( &ObpLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return GrantedAccess;
}

#endif // i386
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obp.h

Abstract:

    Private include file for the OB subcomponent of the NTOS project

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4053)   // one void operand
#pragma warning(disable:4706)   // assignment within conditional

#include "ntos.h"
#include "seopaque.h"
#include <zwapi.h>

#ifdef _WIN64

#define ObpInterlockedExchangeAdd InterlockedExchangeAdd64
#define ObpInterlockedIncrement InterlockedIncrement64
#define ObpInterlockedDecrement InterlockedDecrement64
#define ObpInterlockedCompareExchange InterlockedCompareExchange64

#else 

#define ObpInterlockedExchangeAdd InterlockedExchangeAdd
#define ObpInterlockedIncrement InterlockedIncrement
#define ObpInterlockedDecrement InterlockedDecrement
#define ObpInterlockedCompareExchange InterlockedCompareExchange

#endif

#define OBP_PAGEDPOOL_NAMESPACE

//
//  The Object Header structures are private, but are defined in ob.h
//  so that various macros can directly access header fields.
//

struct _OBJECT_HEADER;
struct _OBJECT_BODY_HEADER;

//
//  Setup default pool tags
//

#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'  bO')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'  bO')
#endif

//
//  Define some macros that will verify that our callbacks don't give us a bad irql
//

#if DBG
#define ObpBeginTypeSpecificCallOut( IRQL ) (IRQL)=KeGetCurrentIrql()
#define ObpEndTypeSpecificCallOut( IRQL, str, ot, o ) {                                               \
    if ((IRQL)!=KeGetCurrentIrql()) {                                                                 \
        DbgPrint( "OB: ObjectType: %wZ  Procedure: %s  Object: %08x\n", &ot->Name, str, o );          \
        DbgPrint( "    Returned at %x IRQL, but was called at %x IRQL\n", KeGetCurrentIrql(), IRQL ); \
        DbgBreakPoint();                                                                              \
    }                                                                                                 \
}
#else
#define ObpBeginTypeSpecificCallOut( IRQL )
#define ObpEndTypeSpecificCallOut( IRQL, str, ot, o )
#endif // DBG

//
//  Define some more macros to validate the current irql
//

#if DBG
#define ObpValidateIrql( str ) \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        DbgPrint( "OB: %s called at IRQL %d\n", (str), KeGetCurrentIrql() ); \
        DbgBreakPoint(); \
        }
#else
#define ObpValidateIrql( str )
#endif // DBG


//
//  This global lock protects the granted access lists when we are collecting stack traces
//

EX_PUSH_LOCK ObpLock;

KEVENT ObpDefaultObject;
WORK_QUEUE_ITEM ObpRemoveObjectWorkItem;
PVOID ObpRemoveObjectList;

//
//  This global lock is used to protect the device map tear down and build up
//  We can no longer use an individual lock in the device map itself because
//  that wasn't sufficient to protect the device map itself.
//

#ifdef OBP_PAGEDPOOL_NAMESPACE

#define OB_NAMESPACE_POOL_TYPE PagedPool

KGUARDED_MUTEX ObpDeviceMapLock;

#define OBP_DECLARE_OLDIRQL

#define ObpLockDeviceMap() \
    KeAcquireGuardedMutex( &ObpDeviceMapLock )

#define ObpUnlockDeviceMap() \
    KeReleaseGuardedMutex( &ObpDeviceMapLock )

#else // !OBP_PAGEDPOOL_NAMESPACE

#define OB_NAMESPACE_POOL_TYPE NonPagedPool

KSPIN_LOCK ObpDeviceMapLock;

#define ObpLockDeviceMap() \
    ExAcquireSpinLock( &ObpDeviceMapLock, &OldIrql )

#define ObpUnlockDeviceMap() \
    ExReleaseSpinLock( &ObpDeviceMapLock, OldIrql )

#endif  // OBP_PAGEDPOOL_NAMESPACE

#define ObpIncrPointerCountEx(np,Count) (ObpInterlockedExchangeAdd (&np->PointerCount, Count) + Count)
#define ObpDecrPointerCountEx(np,Count) (ObpInterlockedExchangeAdd (&np->PointerCount, -(LONG_PTR)(Count)) - Count)

#ifndef POOL_TAGGING

#define ObpIncrPointerCount(np)           ObpInterlockedIncrement( &np->PointerCount )
#define ObpDecrPointerCount(np)           ObpInterlockedDecrement( &np->PointerCount )
#define ObpDecrPointerCountWithResult(np) (ObpInterlockedDecrement( &np->PointerCount ) == 0)

#define ObpPushStackInfo(np, inc)

#else //POOL_TAGGING

VOID
ObpInitStackTrace();

VOID
ObpRegisterObject (
    POBJECT_HEADER ObjectHeader
    );

VOID
ObpDeregisterObject (
    POBJECT_HEADER ObjectHeader
    );

VOID
ObpPushStackInfo (
    POBJECT_HEADER ObjectHeader,
    BOOLEAN IsRef
    );

extern BOOLEAN ObpTraceEnabled;

#define ObpIncrPointerCount(np)           ((ObpTraceEnabled ? ObpPushStackInfo(np,TRUE) : 0),ObpInterlockedIncrement( &np->PointerCount ))
#define ObpDecrPointerCount(np)           ((ObpTraceEnabled ? ObpPushStackInfo(np,FALSE) : 0),ObpInterlockedDecrement( &np->PointerCount ))
#define ObpDecrPointerCountWithResult(np) ((ObpTraceEnabled ? ObpPushStackInfo(np,FALSE) : 0),(ObpInterlockedDecrement( &np->PointerCount ) == 0))

#endif //POOL_TAGGING

#define ObpIncrHandleCount(np)            ObpInterlockedIncrement( &np->HandleCount )
#define ObpDecrHandleCount(np)            (ObpInterlockedDecrement( &np->HandleCount ) == 0)



//
//  Define macros to acquire and release an object type fast mutex.
//
//
//  VOID
//  ObpEnterObjectTypeMutex (
//      IN POBJECT_TYPE ObjectType
//      )
//

#define ObpEnterObjectTypeMutex(_ObjectType) {                   \
    ObpValidateIrql("ObpEnterObjectTypeMutex");                  \
    KeEnterCriticalRegion();                                     \
    ExAcquireResourceExclusiveLite(&(_ObjectType)->Mutex, TRUE); \
}

//
//  VOID
//  ObpLeaveObjectTypeMutex (
//      IN POBJECT_TYPE ObjectType
//      )
//

#define ObpLeaveObjectTypeMutex(_ObjectType) {  \
    ExReleaseResourceLite(&(_ObjectType)->Mutex);   \
    KeLeaveCriticalRegion();                    \
    ObpValidateIrql("ObpLeaveObjectTypeMutex"); \
}

#define LOCK_HASH_MASK (OBJECT_LOCK_COUNT - 1)

#define ObpHashObjectHeader(_ObjectHeader)      \
    ((((ULONG_PTR)(_ObjectHeader)) >> 8) & LOCK_HASH_MASK)

#define ObpLockObject(_ObjectHeader) {                           \
    ULONG_PTR LockIndex = ObpHashObjectHeader(_ObjectHeader);    \
    ObpValidateIrql("ObpEnterObjectTypeMutex");                  \
    KeEnterCriticalRegion();                                     \
    ExAcquireResourceExclusiveLite(&((_ObjectHeader)->Type->ObjectLocks[LockIndex]), TRUE); \
}

#define ObpLockObjectShared(_ObjectHeader) {                     \
    ULONG_PTR LockIndex = ObpHashObjectHeader(_ObjectHeader);    \
    ObpValidateIrql("ObpEnterObjectTypeMutex");                  \
    KeEnterCriticalRegion();                                     \
    ExAcquireResourceSharedLite(&((_ObjectHeader)->Type->ObjectLocks[LockIndex]), TRUE); \
}

#define ObpUnlockObject(_ObjectHeader) {                                        \
    ULONG_PTR LockIndex = ObpHashObjectHeader(_ObjectHeader);                   \
    ExReleaseResourceLite(&((_ObjectHeader)->Type->ObjectLocks[LockIndex]));        \
    KeLeaveCriticalRegion();                                                    \
    ObpValidateIrql("ObpLeaveObjectTypeMutex");                                 \
}


//
//  A Macro to return the object table for the current process
//

#define ObpGetObjectTable() (PsGetCurrentProcess()->ObjectTable)

//
//  Macro to test whether or not the object manager is responsible for
//  an object's security descriptor, or if the object has its own
//  security management routines.
//

#define ObpCentralizedSecurity(_ObjectType)                              \
    ((_ObjectType)->TypeInfo.SecurityProcedure == SeDefaultObjectMethod)

//
//  Declare a global table of object types.
//

#define OBP_MAX_DEFINED_OBJECT_TYPES 48
POBJECT_TYPE ObpObjectTypes[ OBP_MAX_DEFINED_OBJECT_TYPES ];


//
//  This is some special purpose code to keep a table of access masks correlated with
//  back traces.  If used these routines replace the GrantedAccess mask in the
//  preceding object table entry with a granted access index and a call back index.
//

#if i386 
ACCESS_MASK
ObpTranslateGrantedAccessIndex (
    USHORT GrantedAccessIndex
    );

USHORT
ObpComputeGrantedAccessIndex (
    ACCESS_MASK GrantedAccess
    );

USHORT ObpCurCachedGrantedAccessIndex;
USHORT ObpMaxCachedGrantedAccessIndex;
PACCESS_MASK ObpCachedGrantedAccesses;
#endif // i386 

//
//  The three low order bits of the object table entry are used for handle
//  attributes.
//

//
//  We moved the PROTECT_CLOSE in the granted access mask
//

extern ULONG ObpAccessProtectCloseBit;

//
//  The bit mask for inherit MUST be 0x2.
//

#if (OBJ_INHERIT != 0x2)

#error Object inheritance bit definition conflicts

#endif

//
//  Define the bit mask for the generate audit on close attribute.
//
//  When a handle to an object with security is created, audit routines will
//  be called to perform any auditing that may be required. The audit routines
//  will return a boolean indicating whether or not audits should be generated
//  on close.
//

#define OBJ_AUDIT_OBJECT_CLOSE 0x00000004L


//
//  The following three bits are available for handle attributes in the
//  Object field of an ObjectTableEntry.
//

#define OBJ_HANDLE_ATTRIBUTES (OBJ_PROTECT_CLOSE | OBJ_INHERIT | OBJ_AUDIT_OBJECT_CLOSE)

#define ObpDecodeGrantedAccess(Access)       \
    ((Access) & ~ObpAccessProtectCloseBit)

#define ObpGetHandleAttributes(HandleTableEntry)                                    \
     ((((HandleTableEntry)->GrantedAccess) & ObpAccessProtectCloseBit) ?            \
     ((((HandleTableEntry)->ObAttributes) & OBJ_HANDLE_ATTRIBUTES) | OBJ_PROTECT_CLOSE) : \
     (((HandleTableEntry)->ObAttributes) & (OBJ_INHERIT | OBJ_AUDIT_OBJECT_CLOSE)) )

#define ObpEncodeProtectClose(ObjectTableEntry)                         \
    if ( (ObjectTableEntry).ObAttributes & OBJ_PROTECT_CLOSE ) {        \
                                                                        \
        (ObjectTableEntry).ObAttributes &= ~OBJ_PROTECT_CLOSE;          \
        (ObjectTableEntry).GrantedAccess |= ObpAccessProtectCloseBit;   \
    }


//
//  Security Descriptor Cache
//
//  Cache entry header.
//

typedef struct _SECURITY_DESCRIPTOR_HEADER {

    LIST_ENTRY Link;
    ULONG  RefCount;
    ULONG  FullHash;
#if defined (_WIN64)
    PVOID  Spare;   // Align to 16 byte boundary.
#endif
    QUAD   SecurityDescriptor;

} SECURITY_DESCRIPTOR_HEADER, *PSECURITY_DESCRIPTOR_HEADER;

//
//  Macro to convert a security descriptor into its security descriptor header
//

#define SD_TO_SD_HEADER(_sd) \
    CONTAINING_RECORD( (_sd), SECURITY_DESCRIPTOR_HEADER, SecurityDescriptor )

//
//  Macro to convert a header link into its security descriptor header
//

#define LINK_TO_SD_HEADER(_link) \
    CONTAINING_RECORD( (_link), SECURITY_DESCRIPTOR_HEADER, Link )


//
//  Number of minor hash entries
//

#define SECURITY_DESCRIPTOR_CACHE_ENTRIES    257



//
//  Lock state signatures
//

#define OBP_LOCK_WAITEXCLUSIVE_SIGNATURE    0xAAAA1234
#define OBP_LOCK_WAITSHARED_SIGNATURE       0xBBBB1234
#define OBP_LOCK_OWNEDEXCLUSIVE_SIGNATURE   0xCCCC1234
#define OBP_LOCK_OWNEDSHARED_SIGNATURE      0xDDDD1234
#define OBP_LOCK_RELEASED_SIGNATURE         0xEEEE1234
#define OBP_LOCK_UNUSED_SIGNATURE           0xFFFF1234

//
//  Lookup directories
//

typedef struct _OBP_LOOKUP_CONTEXT {

    POBJECT_DIRECTORY Directory;
    PVOID Object;
    ULONG HashValue;
    USHORT HashIndex;
    BOOLEAN DirectoryLocked;
    volatile ULONG LockStateSignature;

} OBP_LOOKUP_CONTEXT, *POBP_LOOKUP_CONTEXT;

//
// Context for the sweep routine. Passed through handle enumeration.
//
typedef struct _OBP_SWEEP_CONTEXT {
    PHANDLE_TABLE HandleTable;
    KPROCESSOR_MODE PreviousMode;
} OBP_SWEEP_CONTEXT, *POBP_SWEEP_CONTEXT;


//
//  Global data
//

POBJECT_TYPE ObpTypeObjectType;
POBJECT_TYPE ObpDirectoryObjectType;
POBJECT_TYPE ObpSymbolicLinkObjectType;
POBJECT_TYPE ObpDeviceMapObjectType;
POBJECT_DIRECTORY ObpRootDirectoryObject;
POBJECT_DIRECTORY ObpTypeDirectoryObject;

typedef union {
    WCHAR Name[sizeof(ULARGE_INTEGER)/sizeof(WCHAR)];
    ULARGE_INTEGER Alignment;
} ALIGNEDNAME;

extern const ALIGNEDNAME ObpDosDevicesShortNamePrefix;
extern const ALIGNEDNAME ObpDosDevicesShortNameRoot;
extern const UNICODE_STRING ObpDosDevicesShortName;

ERESOURCE SecurityDescriptorCacheLock;

//
//  Define date structures for the object creation information region.
//

extern GENERAL_LOOKASIDE ObpCreateInfoLookasideList;

//
//  Define data structures for the object name buffer lookaside list.
//

#define OBJECT_NAME_BUFFER_SIZE 248

extern GENERAL_LOOKASIDE ObpNameBufferLookasideList;

//
//  There is one global kernel handle table accessed via negative handle
//  and only in kernel mode
//

PHANDLE_TABLE ObpKernelHandleTable;

//
//  The following macros are used to test and manipulate special kernel
//  handles.  A kernel handle is just a regular handle with its sign
//  bit set.  But must exclude -1 and -2 values which are the current
//  process and current thread constants.
//

#define KERNEL_HANDLE_MASK ((ULONG_PTR)((LONG)0x80000000))

#define IsKernelHandle(H,M)                                \
    (((KERNEL_HANDLE_MASK & (ULONG_PTR)(H)) == KERNEL_HANDLE_MASK) && \
     ((M) == KernelMode) &&                                \
     ((H) != NtCurrentThread()) &&                         \
     ((H) != NtCurrentProcess()))

#define EncodeKernelHandle(H) (HANDLE)(KERNEL_HANDLE_MASK | (ULONG_PTR)(H))

#define DecodeKernelHandle(H) (HANDLE)(KERNEL_HANDLE_MASK ^ (ULONG_PTR)(H))

//
//  Test macro for overflow
//

#define ObpIsOverflow(A,B) ((A) > ((A) + (B)))


//
//  Internal Entry Points defined in obcreate.c and some associated macros
//

#define ObpFreeObjectCreateInformation(_ObjectCreateInfo) { \
    ObpReleaseObjectCreateInformation((_ObjectCreateInfo)); \
    ObpFreeObjectCreateInfoBuffer((_ObjectCreateInfo));     \
}

#define ObpReleaseObjectCreateInformation(_ObjectCreateInfo) {               \
    if ((_ObjectCreateInfo)->SecurityDescriptor != NULL) {                   \
        SeReleaseSecurityDescriptor((_ObjectCreateInfo)->SecurityDescriptor, \
                                    (_ObjectCreateInfo)->ProbeMode,          \
                                     TRUE);                                  \
        (_ObjectCreateInfo)->SecurityDescriptor = NULL;                      \
    }                                                                        \
}

NTSTATUS
ObpCaptureObjectCreateInformation (
    IN POBJECT_TYPE ObjectType OPTIONAL,
    IN KPROCESSOR_MODE ProbeMode,
    IN KPROCESSOR_MODE CreatorMode,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PUNICODE_STRING CapturedObjectName,
    IN POBJECT_CREATE_INFORMATION ObjectCreateInfo,
    IN LOGICAL UseLookaside
    );

NTSTATUS
ObpCaptureObjectName (
    IN KPROCESSOR_MODE ProbeMode,
    IN PUNICODE_STRING ObjectName,
    IN OUT PUNICODE_STRING CapturedObjectName,
    IN LOGICAL UseLookaside
    );

PWCHAR
ObpAllocateObjectNameBuffer (
    IN ULONG Length,
    IN LOGICAL UseLookaside,
    IN OUT PUNICODE_STRING ObjectName
    );

VOID
FASTCALL
ObpFreeObjectNameBuffer (
    IN PUNICODE_STRING ObjectName
    );

NTSTATUS
ObpAllocateObject (
    IN POBJECT_CREATE_INFORMATION ObjectCreateInfo,
    IN KPROCESSOR_MODE OwnershipMode,
    IN POBJECT_TYPE ObjectType,
    IN PUNICODE_STRING ObjectName,
    IN ULONG ObjectBodySize,
    OUT POBJECT_HEADER *ReturnedObjectHeader
    );


VOID
FASTCALL
ObpFreeObject (
    IN PVOID Object
    );


/*++

POBJECT_CREATE_INFORMATION
ObpAllocateObjectCreateInfoBuffer (
    VOID
    )

Routine Description:

    This function allocates a created information buffer.

    N.B. This function is nonpageable.

Arguments:

    None.

Return Value:

    If the allocation is successful, then the address of the allocated
    create information buffer is is returned as the function value.
    Otherwise, a value of NULL is returned.

--*/

#define ObpAllocateObjectCreateInfoBuffer()             \
    (POBJECT_CREATE_INFORMATION)ExAllocateFromPPLookasideList(LookasideCreateInfoList)


/*++

VOID
FASTCALL
ObpFreeObjectCreateInfoBuffer (
    IN POBJECT_CREATE_INFORMATION ObjectCreateInfo
    )

Routine Description:

    This function frees a create information buffer.

    N.B. This function is nonpageable.

Arguments:

    ObjectCreateInfo - Supplies a pointer to a create information buffer.

Return Value:

    None.

--*/

#define ObpFreeObjectCreateInfoBuffer(ObjectCreateInfo) \
    ExFreeToPPLookasideList(LookasideCreateInfoList, ObjectCreateInfo)

//
//  Internal Entry Points defined in oblink.c
//

NTSTATUS
ObpParseSymbolicLink (
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

VOID
ObpDeleteSymbolicLink (
    IN  PVOID   Object
    );

VOID
ObpCreateSymbolicLinkName (
    POBJECT_SYMBOLIC_LINK SymbolicLink
    );

VOID
ObpDeleteSymbolicLinkName (
    POBJECT_SYMBOLIC_LINK SymbolicLink
    );


//
//  Internal Entry Points defined in obdir.c
//

PVOID
ObpLookupDirectoryEntry (
    IN POBJECT_DIRECTORY Directory,
    IN PUNICODE_STRING Name,
    IN ULONG Attributes,
    IN BOOLEAN SearchShadow,
    OUT POBP_LOOKUP_CONTEXT LookupContext
    );


BOOLEAN
ObpInsertDirectoryEntry (
    IN POBJECT_DIRECTORY Directory,
    IN POBP_LOOKUP_CONTEXT LookupContext,
    IN POBJECT_HEADER ObjectHeader
    );


BOOLEAN
ObpDeleteDirectoryEntry (
    IN POBP_LOOKUP_CONTEXT LookupContext
    );


NTSTATUS
ObpLookupObjectName (
    IN HANDLE RootDirectoryHandle,
    IN PUNICODE_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode,
    IN PVOID ParseContext OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    IN PVOID InsertObject OPTIONAL,
    IN OUT PACCESS_STATE AccessState,
    OUT POBP_LOOKUP_CONTEXT LookupContext,
    OUT PVOID *FoundObject
    );

VOID
ObpUnlockObjectDirectoryPath (
    IN POBJECT_DIRECTORY LockedDirectory
    );

PDEVICE_MAP
ObpReferenceDeviceMap(
    );

VOID
FASTCALL
ObfDereferenceDeviceMap(
    IN PDEVICE_MAP DeviceMap
    );


//
//  Internal entry points defined in obref.c
//


VOID
ObpDeleteNameCheck (
    IN PVOID Object
    );


VOID
ObpProcessRemoveObjectQueue (
    PVOID Parameter
    );

VOID
ObpRemoveObjectRoutine (
    IN  PVOID   Object,
    IN  BOOLEAN CalledOnWorkerThread
    );


//
//  Internal entry points defined in obhandle.c
//


POBJECT_HANDLE_COUNT_ENTRY
ObpInsertHandleCount (
    POBJECT_HEADER ObjectHeader
    );

NTSTATUS
ObpIncrementHandleCount (
    OB_OPEN_REASON OpenReason,
    PEPROCESS Process,
    PVOID Object,
    POBJECT_TYPE ObjectType,
    PACCESS_STATE AccessState OPTIONAL,
    KPROCESSOR_MODE AccessMode,
    ULONG Attributes
    );


VOID
ObpDecrementHandleCount (
    PEPROCESS Process,
    POBJECT_HEADER ObjectHeader,
    POBJECT_TYPE ObjectType,
    ACCESS_MASK GrantedAccess
    );

NTSTATUS
ObpCreateHandle (
    IN OB_OPEN_REASON OpenReason,
    IN PVOID Object,
    IN POBJECT_TYPE ExpectedObjectType OPTIONAL,
    IN PACCESS_STATE AccessState,
    IN ULONG ObjectPointerBias OPTIONAL,
    IN ULONG Attributes,
    IN POBP_LOOKUP_CONTEXT LookupContext,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *ReferencedNewObject OPTIONAL,
    OUT PHANDLE Handle
    );

NTSTATUS
ObpIncrementUnnamedHandleCount (
    PACCESS_MASK DesiredAccess,
    PEPROCESS Process,
    PVOID Object,
    POBJECT_TYPE ObjectType,
    KPROCESSOR_MODE AccessMode,
    ULONG Attributes
    );


NTSTATUS
ObpCreateUnnamedHandle (
    IN PVOID Object,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ObjectPointerBias OPTIONAL,
    IN ULONG Attributes,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *ReferencedNewObject OPTIONAL,
    OUT PHANDLE Handle
    );

NTSTATUS
ObpChargeQuotaForObject (
    IN POBJECT_HEADER ObjectHeader,
    IN POBJECT_TYPE ObjectType,
    OUT PBOOLEAN NewObject
    );

NTSTATUS
ObpValidateDesiredAccess (
    IN ACCESS_MASK DesiredAccess
    );


//
//  Internal entry points defined in obse.c
//

BOOLEAN
ObpCheckPseudoHandleAccess (
    IN PVOID Object,
    IN ACCESS_MASK DesiredAccess,
    OUT PNTSTATUS AccessStatus,
    IN BOOLEAN TypeMutexLocked
    );


BOOLEAN
ObpCheckTraverseAccess (
    IN PVOID DirectoryObject,
    IN ACCESS_MASK TraverseAccess,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN TypeMutexLocked,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PNTSTATUS AccessStatus
    );

BOOLEAN
ObpCheckObjectReference (
    IN PVOID Object,
    IN OUT PACCESS_STATE AccessState,
    IN BOOLEAN TypeMutexLocked,
    IN KPROCESSOR_MODE AccessMode,
    OUT PNTSTATUS AccessStatus
    );


//
//  Internal entry points defined in obsdata.c
//

NTSTATUS
ObpInitSecurityDescriptorCache (
    VOID
    );

ULONG
ObpHashSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Length
    );

ULONG
ObpHashBuffer (
    PVOID Data,
    ULONG Length
    );

PSECURITY_DESCRIPTOR_HEADER
ObpCreateCacheEntry (
    PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    ULONG Length,
    ULONG FullHash,
    ULONG RefBias
    );


PSECURITY_DESCRIPTOR
ObpReferenceSecurityDescriptor (
    POBJECT_HEADER ObjectHeader
    );


PVOID
ObpDestroySecurityDescriptorHeader (
    IN PSECURITY_DESCRIPTOR_HEADER Header
    );

BOOLEAN
ObpCompareSecurityDescriptors (
    IN PSECURITY_DESCRIPTOR SD1,
    ULONG Length,
    IN PSECURITY_DESCRIPTOR SD2
    );

NTSTATUS
ObpValidateAccessMask (
    PACCESS_STATE AccessState
    );

NTSTATUS
ObpCloseHandleTableEntry (
    IN PHANDLE_TABLE ObjectTable,
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN Rundown
    );

NTSTATUS
ObpCloseHandle (
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    );

VOID
ObpDeleteObjectType (
    IN  PVOID   Object
    );

VOID
ObpAuditObjectAccess(
    IN HANDLE Handle,
    IN PHANDLE_TABLE_ENTRY_INFO ObjectTableEntryInfo,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK DesiredAccess
    );

NTSTATUS
ObpQueryNameString (
    IN PVOID Object,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    );



//
//  Inline functions
//

FORCEINLINE
BOOLEAN
ObpSafeInterlockedIncrement(
    IN OUT LONG_PTR volatile *lpValue
    )

/*

Routine Description:

    This function increments the LONG value passed in.
    Unlike the InterlockedIncrement function, this will not increment from 0 to 1.
    It will return FALSE if it's trying to reference from 0.

Arguments:

    lpValue - The pointer to the LONG value that should be safe incremented

Return Value:

    Returns FALSE if the current value is 0 (so it cannot increment to 1). TRUE means the LONG
    value was incremented

*/

{
    LONG_PTR PointerCount, NewPointerCount;

    //
    // If the object is being deleted then the reference count is zero. So the idea here is to reference
    // the long value but avoid the 0 -> 1 transition that would cause a double delete.
    //

    PointerCount = ReadForWriteAccess(lpValue);

    do {
        if (PointerCount == 0) {
            return FALSE;
        }
        NewPointerCount = ObpInterlockedCompareExchange (lpValue,
                                                         PointerCount+1,
                                                         PointerCount);

        //
        // If the exchange compare completed ok then we did a reference so return true.
        //

        if (NewPointerCount == PointerCount) {

            return TRUE;
        }

        //
        // We failed because somebody else got in and changed the refence count on us. Use the new value to
        // prime the exchange again.
        //

        PointerCount = NewPointerCount;
    } while (TRUE);

    return TRUE;
}

#define OBP_NAME_LOCKED	            ((LONG)0x80000000)
#define OBP_NAME_KERNEL_PROTECTED   ((LONG)0x40000000)

FORCEINLINE
BOOLEAN
ObpSafeInterlockedIncrementLong(
    IN OUT LONG volatile *lpValue
    )

/*

Routine Description:

    This function increments the LONG value passed in.
    Unlike the InterlockedIncrement function, this will not increment from 0 to 1.
    It will return FALSE if it's trying to reference from 0.

Arguments:

    lpValue - The pointer to the LONG value that should be safe incremented

Return Value:

    Returns FALSE if the current value is 0 (so it cannot increment to 1). TRUE means the LONG
    value was incremented

*/

{
    LONG PointerCount, NewPointerCount;

    //
    // If the object is being deleted then the reference count is zero. So the idea here is to reference
    // the long value but avoid the 0 -> 1 transition that would cause a double delete.
    //

    PointerCount = ReadForWriteAccess(lpValue);

    do {
        if (PointerCount == 0) {
            return FALSE;
        }
        NewPointerCount = InterlockedCompareExchange (lpValue,
                                                      PointerCount+1,
                                                      PointerCount);

        //
        // If the exchange compare completed ok then we did a reference so return true.
        //

        if (NewPointerCount == PointerCount) {

            return TRUE;
        }

        //
        // We failed because somebody else got in and changed the refence count on us. Use the new value to
        // prime the exchange again.
        //

        PointerCount = NewPointerCount;
    } while (TRUE);

    return TRUE;
}


POBJECT_HEADER_NAME_INFO
FORCEINLINE
ObpReferenceNameInfo(
    IN POBJECT_HEADER ObjectHeader
    )

/*

Routine Description:
    This function references the name information structure. This is a substitute
    for the previous global locking mechanism that used the RootDirectoryMutex to protect
    the fields inside the NAME_INFO as well.
    If the function returns a non-NULL name info, the name buffer and Directory will not go away
    until the ObpDereferenceNameInfo call.

Arguments:

    ObjectHeader - The object header whose name should be safe-referenced

Return Value:
    Returns NULL if the object doesn't have a name information structure, or if the name info is being deleted
    Returns a pointer to the POBJECT_HEADER_NAME_INFO if it's safe to use the fields inside it.

*/

{
    POBJECT_HEADER_NAME_INFO NameInfo;
    NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

    if ((NameInfo != NULL)
            &&
        ObpSafeInterlockedIncrementLong((PLONG) &NameInfo->QueryReferences )) {

        if (NameInfo->QueryReferences & OBP_NAME_LOCKED) {

            //
            //  The name is locked this means that the directory entry must be valid
            //

            ExAcquireReleasePushLockExclusive(&NameInfo->Directory->Lock);
        }

        return NameInfo;
    }

    return NULL;
}


VOID
FORCEINLINE
ObpDereferenceNameInfo(
    IN POBJECT_HEADER_NAME_INFO NameInfo
    )

/*

Routine Description:
    This function dereferences the name information structure. If the number of references
    drops to 0, the name is freed and the directory dereferenced

Arguments:

    NameInfo - The pointer to the name info structure, as returned by ObpReferenceNameInfo.
    (NULL value is allowed)

Return Value:
    None

*/

{

    if ( (NameInfo != NULL)
            &&
         (InterlockedDecrement((PLONG)&NameInfo->QueryReferences) == 0)) {

        PVOID DirObject;

        //
        //  Free the name buffer and zero out the name data fields
        //

        if (NameInfo->Name.Buffer != NULL) {

            ExFreePool( NameInfo->Name.Buffer );

            NameInfo->Name.Buffer = NULL;
            NameInfo->Name.Length = 0;
            NameInfo->Name.MaximumLength = 0;
        }

        DirObject = NameInfo->Directory;

        if (DirObject != NULL) {

            NameInfo->Directory = NULL;
            ObDereferenceObjectDeferDelete( DirObject );
        }
    }
}


FORCEINLINE
LOGICAL
ObpIsKernelExclusiveObject(
    IN POBJECT_HEADER ObjectHeader
    )

/*

Routine Description:
    This function verifies if a named object can only be opened in kernel mode

Arguments:

    ObjectHeader - The object header whose name should be safe-referenced

Return Value:
    TRUE if the object is available only to kernel

*/

{
    POBJECT_HEADER_NAME_INFO NameInfo;
    NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

    return ((NameInfo != NULL) && ((NameInfo->QueryReferences & OBP_NAME_KERNEL_PROTECTED) != 0));
}


VOID
FORCEINLINE
ObpLockDirectoryExclusive(
    IN POBJECT_DIRECTORY Directory,
    IN POBP_LOOKUP_CONTEXT LockContext
    )

/*

Routine Description:
    This Function locks exclusively the Directory. It is used for write access to
    the directory structure.

Arguments:

    Directory - The directory being locked

Return Value:
    None

*/

{
    LockContext->LockStateSignature = OBP_LOCK_WAITEXCLUSIVE_SIGNATURE;
    KeEnterCriticalRegion();
    ExAcquirePushLockExclusive( &Directory->Lock );
    LockContext->LockStateSignature = OBP_LOCK_OWNEDEXCLUSIVE_SIGNATURE;
}


VOID
FORCEINLINE
ObpLockDirectoryShared (
    IN POBJECT_DIRECTORY Directory,
    IN POBP_LOOKUP_CONTEXT LockContext
    )

/*

Routine Description:
    This Function locks shared the Directory. It is used to read fields inside
    the directory structure.

Arguments:

    Directory - The directory being locked

Return Value:
    None

*/

{
    LockContext->LockStateSignature = OBP_LOCK_WAITSHARED_SIGNATURE;
    KeEnterCriticalRegion();
    ExAcquirePushLockShared( &Directory->Lock );
    LockContext->LockStateSignature = OBP_LOCK_OWNEDSHARED_SIGNATURE;
}


VOID
FORCEINLINE
ObpUnlockDirectory(
    IN POBJECT_DIRECTORY Directory,
    IN POBP_LOOKUP_CONTEXT LockContext
    )

/*

Routine Description:
    This Function unlocks a Directory (previously locked exclusive or shared).

Arguments:

    Directory - The directory that needs to be unlocked

Return Value:
    None

*/

{
    ExReleasePushLock( &Directory->Lock );
    LockContext->LockStateSignature = OBP_LOCK_RELEASED_SIGNATURE;
    KeLeaveCriticalRegion();
}


VOID
FORCEINLINE
ObpInitializeLookupContext(
    IN POBP_LOOKUP_CONTEXT LookupContext
    )

/*

Routine Description:
    This Function initialize a lookup context structure.

Arguments:

    LookupContext - The LookupContext to be initialized

Return Value:
    None

*/

{
    LookupContext->DirectoryLocked = FALSE;
    LookupContext->Object = NULL;
    LookupContext->Directory = NULL;
    LookupContext->LockStateSignature = OBP_LOCK_UNUSED_SIGNATURE;
}


VOID
FORCEINLINE
ObpLockLookupContext (
    IN POBP_LOOKUP_CONTEXT LookupContext,
    IN POBJECT_DIRECTORY Directory
    )

/*

Routine Description:
    This function locks a lookup context. The directory
    is exclusively owned after this call and it's safe to access
    the directory in write mode. This function is intended to be used in
    insertion / deletion into/from the specified directory.

    The directory is unlocked at the next ObpReleaseLookupContext.

Arguments:

    LookupContext - The LookupContext to be initialized

    Directory - The directory being locked for exclusive access.

Return Value:
    None

*/

{

    ObpLockDirectoryExclusive(Directory, LookupContext);
    LookupContext->DirectoryLocked = TRUE;
    LookupContext->Directory = Directory;
}



VOID
FORCEINLINE
ObpReleaseLookupContext (
    IN POBP_LOOKUP_CONTEXT LookupContext
    )

/*

Routine Description:
    This function undoes the references and locking changes during these calls:
    ObpLockLookupContext and ObpLookupDirectoryEntry.

    N.B. If ObpLookupDirectoryEntry is called several times in a loop, each call
    will undo the references done at the previous call. ObpReleaseLookupContext
    should be called only ones at the end.

Arguments:

    LookupContext - The LookupContext to be released

Return Value:
    None

*/

{
    //
    //  If the context was locked we need to unlock the directory
    //

    if (LookupContext->DirectoryLocked) {

        ObpUnlockDirectory( LookupContext->Directory, LookupContext );
        LookupContext->Directory = NULL;
        LookupContext->DirectoryLocked = FALSE;
    }

    //
    //  Remove the references added to the name info and object
    //

    if (LookupContext->Object) {
        POBJECT_HEADER_NAME_INFO NameInfo;

        NameInfo = OBJECT_HEADER_TO_NAME_INFO(OBJECT_TO_OBJECT_HEADER(LookupContext->Object));

        ObpDereferenceNameInfo( NameInfo );
        ObDereferenceObject(LookupContext->Object);
        LookupContext->Object = NULL;
    }
}

NTSTATUS
ObpReferenceProcessObjectByHandle (
    IN HANDLE Handle,
    IN PEPROCESS Process,
    IN PHANDLE_TABLE HandleTable,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *Object,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation,
    OUT PACCESS_MASK AuditMask
    );

VOID
FORCEINLINE
ObpLockAllObjects (
    IN POBJECT_TYPE ObjectType
    )
{
    LONG i;

    KeEnterCriticalRegion();                                    

    for (i = 0; i < OBJECT_LOCK_COUNT; i++) {

        ExAcquireResourceExclusiveLite(&(ObjectType->ObjectLocks[i]), TRUE);
    }
}

VOID
FORCEINLINE
ObpUnlockAllObjects (
    IN POBJECT_TYPE ObjectType
    )
{
    LONG i;

    for (i = OBJECT_LOCK_COUNT - 1; i >= 0; i--) {

        ExReleaseResourceLite(&(ObjectType->ObjectLocks[i]));       
    }

    KeLeaveCriticalRegion();                                                    
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\oblink.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    oblink.c

Abstract:

    Symbolic Link Object routines

--*/

#include "obp.h"

VOID
ObpProcessDosDeviceSymbolicLink (
    POBJECT_SYMBOLIC_LINK SymbolicLink,
    ULONG Action
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NtCreateSymbolicLinkObject)
#pragma alloc_text(PAGE,NtOpenSymbolicLinkObject)
#pragma alloc_text(PAGE,NtQuerySymbolicLinkObject)
#pragma alloc_text(PAGE,ObpParseSymbolicLink)
#pragma alloc_text(PAGE,ObpDeleteSymbolicLink)
#pragma alloc_text(PAGE,ObpDeleteSymbolicLinkName)
#pragma alloc_text(PAGE,ObpCreateSymbolicLinkName)
#pragma alloc_text(PAGE,ObpProcessDosDeviceSymbolicLink)
#endif

//
//  This is the object type for device objects.
//

extern POBJECT_TYPE IoDeviceObjectType;

//
//  Global that enables/disables LUID device maps
//
extern ULONG ObpLUIDDeviceMapsEnabled;

//
//  Local procedure prototypes
//

#define CREATE_SYMBOLIC_LINK 0
#define DELETE_SYMBOLIC_LINK 1

NTSTATUS
NtCreateSymbolicLinkObject (
    __out PHANDLE LinkHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in PUNICODE_STRING LinkTarget
    )

/*++

Routine Description:

    This function creates a symbolic link object, sets it initial value to
    value specified in the LinkTarget parameter, and opens a handle to the
    object with the specified desired access.

Arguments:

    LinkHandle - Supplies a pointer to a variable that will receive the
        symbolic link object handle.

    DesiredAccess - Supplies the desired types of access for the symbolic link
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    LinkTarget - Supplies the target name for the symbolic link object.

Return Value:

    An appropriate status value

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    POBJECT_SYMBOLIC_LINK SymbolicLink;
    PVOID Object;
    HANDLE Handle;
    UNICODE_STRING CapturedLinkTarget;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( ObjectAttributes,
                                        sizeof( OBJECT_ATTRIBUTES ),
                                        sizeof( ULONG ));

            ProbeForReadSmallStructure( LinkTarget,
                                        sizeof( *LinkTarget ),
                                        sizeof( UCHAR ));

            CapturedLinkTarget = *LinkTarget;

            ProbeForRead( CapturedLinkTarget.Buffer,
                          CapturedLinkTarget.MaximumLength,
                          sizeof( UCHAR ));

            ProbeForWriteHandle( LinkHandle );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    } else {

        CapturedLinkTarget = *LinkTarget;
    }

    //
    //  Check if there is an odd MaximumLength
    //

    if (CapturedLinkTarget.MaximumLength % sizeof( WCHAR )) {

        //
        //  Round down the MaximumLength to a valid even size
        //

        CapturedLinkTarget.MaximumLength = (CapturedLinkTarget.MaximumLength / sizeof( WCHAR )) * sizeof( WCHAR );
    }

    //
    //  Error if link target name length is odd, the length is greater than
    //  the maximum length, or zero and creating.
    //

    if ((CapturedLinkTarget.MaximumLength == 0) ||
        (CapturedLinkTarget.Length > CapturedLinkTarget.MaximumLength) ||
        (CapturedLinkTarget.Length % sizeof( WCHAR ))) {

        KdPrint(( "OB: Invalid symbolic link target - %wZ\n", &CapturedLinkTarget ));

        return( STATUS_INVALID_PARAMETER );
    }

    //
    //  Create the symbolic link object
    //

    Status = ObCreateObject( PreviousMode,
                             ObpSymbolicLinkObjectType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof( *SymbolicLink ),
                             0,
                             0,
                             (PVOID *)&SymbolicLink );

    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    //
    //  Fill in symbolic link object with link target name string
    //

    KeQuerySystemTime( &SymbolicLink->CreationTime );

    SymbolicLink->DosDeviceDriveIndex = 0;
    SymbolicLink->LinkTargetObject = NULL;

    RtlInitUnicodeString( &SymbolicLink->LinkTargetRemaining,  NULL );

    SymbolicLink->LinkTarget.MaximumLength = CapturedLinkTarget.MaximumLength;
    SymbolicLink->LinkTarget.Length = CapturedLinkTarget.Length;
    SymbolicLink->LinkTarget.Buffer = (PWCH)ExAllocatePoolWithTag( PagedPool,
                                                                   CapturedLinkTarget.MaximumLength,
                                                                   'tmyS' );

    if (SymbolicLink->LinkTarget.Buffer == NULL) {

        ObDereferenceObject( SymbolicLink );

        return STATUS_NO_MEMORY;
    }

    try {

        RtlCopyMemory( SymbolicLink->LinkTarget.Buffer,
                       CapturedLinkTarget.Buffer,
                       CapturedLinkTarget.MaximumLength );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        ObDereferenceObject( SymbolicLink );

        return( GetExceptionCode() );
    }

    //
    //  Insert symbolic link object in the current processes object table,
    //  set symbolic link handle value and return status.
    //

    Status = ObInsertObject( SymbolicLink,
                             NULL,
                             DesiredAccess,
                             0,
                             (PVOID *)&Object,
                             &Handle );

    try {

        *LinkHandle = Handle;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Fall through, since we do not want to undo what we have done.
        //
    }

    return( Status );
}

NTSTATUS
NtOpenSymbolicLinkObject (
    __out PHANDLE LinkHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an symbolic link object with the specified
    desired access.

Arguments:

    LinkHandle - Supplies a pointer to a variable that will receive the
        symbolic link object handle.

    DesiredAccess - Supplies the desired types of access for the symbolic link
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    An appropriate status value

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    HANDLE Handle;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //  The object attributes does not need to be probed because the
    //  ObOpenObjectByName does the probe for us
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( LinkHandle );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }
    }

    //
    //  Open handle to the symbolic link object with the specified desired
    //  access, set symbolic link handle value, and return service completion
    //  status.
    //

    Status = ObOpenObjectByName( ObjectAttributes,
                                 ObpSymbolicLinkObjectType,
                                 PreviousMode,
                                 NULL,
                                 DesiredAccess,
                                 NULL,
                                 &Handle );

    try {

        *LinkHandle = Handle;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  Fall through, since we do not want to undo what we have done.
        //
    }

    return( Status );
}

NTSTATUS
NtQuerySymbolicLinkObject (
    __in HANDLE LinkHandle,
    __inout PUNICODE_STRING LinkTarget,
    __out_opt PULONG ReturnedLength
    )

/*++

Routine Description:

    This function queries the state of a symbolic link object and returns the
    requested information in the specified record structure.

Arguments:

    LinkHandle - Supplies a handle to a symbolic link object.  This handle
        must have SYMBOLIC_LINK_QUERY access granted.

    LinkTarget - Supplies a pointer to a record that is to receive the
        target name of the symbolic link object.

    ReturnedLength - Optionally receives the maximum length, in bytes, of
        the link target on return

Return Value:

    An appropriate status value

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    POBJECT_SYMBOLIC_LINK SymbolicLink;
    UNICODE_STRING CapturedLinkTarget;

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( LinkTarget,
                                        sizeof( *LinkTarget ),
                                        sizeof( WCHAR ) );

            ProbeForWriteUshort( &LinkTarget->Length );

            ProbeForWriteUshort( &LinkTarget->MaximumLength );

            CapturedLinkTarget = *LinkTarget;

            ProbeForWrite( CapturedLinkTarget.Buffer,
                           CapturedLinkTarget.MaximumLength,
                           sizeof( UCHAR ) );

            if (ARGUMENT_PRESENT( ReturnedLength )) {

                ProbeForWriteUlong( ReturnedLength );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    } else {

        CapturedLinkTarget = *LinkTarget;
    }

    //
    //  Reference symbolic link object by handle, read current state, deference
    //  symbolic link object, fill in target name structure and return service
    //  status.
    //

    Status = ObReferenceObjectByHandle( LinkHandle,
                                        SYMBOLIC_LINK_QUERY,
                                        ObpSymbolicLinkObjectType,
                                        PreviousMode,
                                        (PVOID *)&SymbolicLink,
                                        NULL );

    if (NT_SUCCESS( Status )) {

        POBJECT_HEADER ObjectHeader;

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( SymbolicLink );

        ObpLockObject( ObjectHeader );

        //
        //  If the caller wants a return length and what we found can easily
        //  fit in the output buffer then we copy into the output buffer all
        //  the bytes from the link.
        //
        //  If the caller did not want a return length and we found can still
        //  easily fit in the output buffer then copy over the bytes that just
        //  make up the string and nothing extra
        //

        if ((ARGUMENT_PRESENT( ReturnedLength ) &&
                (SymbolicLink->LinkTarget.MaximumLength <= CapturedLinkTarget.MaximumLength))

                    ||

            (!ARGUMENT_PRESENT( ReturnedLength ) &&
                (SymbolicLink->LinkTarget.Length <= CapturedLinkTarget.MaximumLength)) ) {

            try {

                RtlCopyMemory( CapturedLinkTarget.Buffer,
                               SymbolicLink->LinkTarget.Buffer,
                               ARGUMENT_PRESENT( ReturnedLength ) ? SymbolicLink->LinkTarget.MaximumLength
                                                                  : SymbolicLink->LinkTarget.Length );

                LinkTarget->Length = SymbolicLink->LinkTarget.Length;

                if (ARGUMENT_PRESENT( ReturnedLength )) {

                    *ReturnedLength = SymbolicLink->LinkTarget.MaximumLength;
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                // Fall through, since we do cannot undo what we have done.
                //
            }

        } else {

            //
            //  The output buffer is just too small for the link target, but
            //  we'll tell the user how much is needed if they asked for that
            //  return value
            //

            if (ARGUMENT_PRESENT( ReturnedLength )) {

                try {

                    *ReturnedLength = SymbolicLink->LinkTarget.MaximumLength;

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    //
                    // Fall through, since we do cannot undo what we have done.
                    //
                }
            }

            Status = STATUS_BUFFER_TOO_SMALL;
        }

        ObpUnlockObject( ObjectHeader );

        ObDereferenceObject( SymbolicLink );
    }

    return( Status );
}


NTSTATUS
ObpParseSymbolicLink (
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This is the call back routine for parsing symbolic link objects.  It is invoked
    as part of ObpLookupObjectName

Arguments:

    ParseObject - This will actually be a symbolic link object

    ObjectType - Specifies the type of the object to lookup

    AccessState - Current access state, describing already granted access
        types, the privileges used to get them, and any access types yet to
        be granted.  The access masks may not contain any generic access
        types.

    AccessMode - Specifies the callers processor mode

    Attributes - Specifies the attributes for the lookup (e.g., case
        insensitive)

    CompleteName - Supplies a pointer to the complete name that we are trying
        to open.  On return this could be modified to fit the new reparse
        buffer

    RemainingName - Supplies a pointer to the remaining name that we are
        trying to open.  On return this will point to what remains after
        we processed the symbolic link.

    Context - Unused

    SecurityQos - Unused

    Object - Receives a pointer to the symbolic link object that we
        resolve to

Return Value:

    STATUS_REPARSE_OBJECT if the parse object is already a snapped
        symbolic link meaning we've modified the remaining name and
        and have returned the target object of the symbolic link


    STATUS_REPARSE if the parse object has not been snapped.  In this
        case the Complete name has been modified with the link target
        name added in front of the remaining name.  The parameters
        remaining name and object must now be ignored by the caller

    An appropriate error value

--*/

{
    ULONG NewLength;
    USHORT Length;
    USHORT MaximumLength;
    PWCHAR NewName, NewRemainingName;
    ULONG InsertAmount;
    NTSTATUS Status;
    POBJECT_SYMBOLIC_LINK SymbolicLink;
    PUNICODE_STRING LinkTargetName;

    UNREFERENCED_PARAMETER (Context);
    UNREFERENCED_PARAMETER (AccessState);
    UNREFERENCED_PARAMETER (SecurityQos);
    UNREFERENCED_PARAMETER (Attributes);

    PAGED_CODE();

    //
    //  This routine needs to be synchonized with the delete symbolic link
    //  operation.  Which uses the root directory mutex.
    //

    *Object = NULL;

    //
    //  If there isn't any name remaining and the caller gave us
    //  an object type then we'll reference the parse object.  If
    //  this is successful then that's the object we return.  Otherwise
    //  if the status is anything but a type mismatch then we'll
    //  return that error status
    //

    if (RemainingName->Length == 0) {

        if ( ObjectType ) {

            Status = ObReferenceObjectByPointer( ParseObject,
                                                 0,
                                                 ObjectType,
                                                 AccessMode );

            if (NT_SUCCESS( Status )) {

                *Object = ParseObject;

                return Status;

            } else if (Status != STATUS_OBJECT_TYPE_MISMATCH) {

                return Status;
            }
       }

       //
       //  If the remaining name does not start with a "\" then
       //  its is malformed and we'll call it a type mismatch
       //

    } else if (*(RemainingName->Buffer) != OBJ_NAME_PATH_SEPARATOR) {

        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    //  A symbolic link has been encountered. See if this link has been snapped
    //  to a particular object.
    //

    SymbolicLink = (POBJECT_SYMBOLIC_LINK)ParseObject;

    if (SymbolicLink->LinkTargetObject != NULL) {

        //
        //  This is a snapped link.  Get the remaining portion of the
        //  symbolic link target, if any.
        //

        LinkTargetName = &SymbolicLink->LinkTargetRemaining;

        if (LinkTargetName->Length == 0) {

            //
            //  Remaining link target string is zero, so return to caller
            //  quickly with snapped object pointer and remaining object name
            //  which we haven't touched yet.
            //

            *Object = SymbolicLink->LinkTargetObject;

            return STATUS_REPARSE_OBJECT;
        }

        //
        //  We have a snapped symbolic link that has additional text.
        //  Insert that in front of the current remaining name, preserving
        //  and text between CompleteName and RemainingName
        //

        InsertAmount = LinkTargetName->Length;

        if ((LinkTargetName->Buffer[ (InsertAmount / sizeof( WCHAR )) - 1 ] == OBJ_NAME_PATH_SEPARATOR)

                &&

            (*(RemainingName->Buffer) == OBJ_NAME_PATH_SEPARATOR)) {

            //
            //  Both the link target name ends in a "\" and the remaining
            //  starts with a "\" but we only need one when we're done
            //

            InsertAmount -= sizeof( WCHAR );
        }

        //
        //  We need to bias the difference between two
        //  pointers with * sizeof(wchar) because the difference is in wchar
        //  and we need the length in bytes
        //

        NewLength = (ULONG)(((RemainingName->Buffer - CompleteName->Buffer) * sizeof( WCHAR )) +
                    InsertAmount +
                    RemainingName->Length);

        if (NewLength > 0xFFF0) {

            return STATUS_NAME_TOO_LONG;
        }

        Length = (USHORT)NewLength;

        //
        //  Now check if the new computed length is too big for the input
        //  buffer containing the complete name
        //

        if (CompleteName->MaximumLength <= Length) {

            //
            //  The new concatenated name is larger than the buffer supplied for
            //  the complete name.  Allocate space for this new string
            //

            MaximumLength = Length + sizeof( UNICODE_NULL );
            NewName = ExAllocatePoolWithTag( OB_NAMESPACE_POOL_TYPE, MaximumLength, 'mNbO' );

            if (NewName == NULL) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            //  Calculate the pointer within this buffer for the remaining
            //  name.  This value has not been biased by the new link
            //  target name
            //

            NewRemainingName = NewName + (RemainingName->Buffer - CompleteName->Buffer);

            //
            //  Copy over all the names that we've processed so far
            //

            RtlCopyMemory( NewName,
                           CompleteName->Buffer,
                           ((RemainingName->Buffer - CompleteName->Buffer) * sizeof( WCHAR )));

            //
            //  If we have some remaining names then those over at the
            //  the location offset to hold the link target name
            //

            if (RemainingName->Length != 0) {

                RtlCopyMemory( (PVOID)((PUCHAR)NewRemainingName + InsertAmount),
                               RemainingName->Buffer,
                               RemainingName->Length );
            }

            //
            //  Now insert the link target name
            //

            RtlCopyMemory( NewRemainingName, LinkTargetName->Buffer, InsertAmount );

            //
            //  Free the old complete name buffer and reset the input
            //  strings to use the new buffer
            //

            ExFreePool( CompleteName->Buffer );

            CompleteName->Buffer = NewName;
            CompleteName->Length = Length;
            CompleteName->MaximumLength = MaximumLength;

            RemainingName->Buffer = NewRemainingName;
            RemainingName->Length = Length - (USHORT)((PCHAR)NewRemainingName - (PCHAR)NewName);
            RemainingName->MaximumLength = RemainingName->Length + sizeof( UNICODE_NULL );

        } else {

            //
            //  Insert extra text associated with this symbolic link name before
            //  existing remaining name, if any.
            //
            //  First shove over the remaining name to make a hole for the
            //  link target name
            //

            if (RemainingName->Length != 0) {

                RtlMoveMemory( (PVOID)((PUCHAR)RemainingName->Buffer + InsertAmount),
                               RemainingName->Buffer,
                               RemainingName->Length );
            }

            //
            //  Now insert the link target name
            //

            RtlCopyMemory( RemainingName->Buffer, LinkTargetName->Buffer, InsertAmount );

            //
            //  Adjust input strings to account for this inserted text
            //

            CompleteName->Length = (USHORT)(CompleteName->Length + LinkTargetName->Length);

            RemainingName->Length = (USHORT)(RemainingName->Length + LinkTargetName->Length);
            RemainingName->MaximumLength += RemainingName->Length + sizeof( UNICODE_NULL );

            CompleteName->Buffer[ CompleteName->Length / sizeof( WCHAR ) ] = UNICODE_NULL;
        }

        //
        //  Return the object address associated with snapped symbolic link
        //  and the reparse object status code.
        //

        *Object = SymbolicLink->LinkTargetObject;

        return STATUS_REPARSE_OBJECT;
    }

    //
    //  The symbolic has not yet been snapped
    //
    //  Compute the size of the new name and check if the name will
    //  fit in the existing complete name buffer.
    //

    LinkTargetName = &SymbolicLink->LinkTarget;

    InsertAmount = LinkTargetName->Length;

    if ((InsertAmount != 0)
            &&
        (LinkTargetName->Buffer[ (InsertAmount / sizeof( WCHAR )) - 1 ] == OBJ_NAME_PATH_SEPARATOR)
            &&
        (RemainingName->Length != 0)
            &&
        (*(RemainingName->Buffer) == OBJ_NAME_PATH_SEPARATOR)) {

        //
        //  Both the link target name ends in a "\" and the remaining
        //  starts with a "\" but we only need one when we're done
        //

        InsertAmount -= sizeof( WCHAR );
    }

    NewLength = InsertAmount + RemainingName->Length;

    if (NewLength > 0xFFF0) {

        return STATUS_NAME_TOO_LONG;
    }

    Length = (USHORT)NewLength;

    if (CompleteName->MaximumLength <= Length) {

        //
        //  The new concatenated name is larger than the buffer supplied for
        //  the complete name.
        //

        MaximumLength = Length + sizeof( UNICODE_NULL );
        NewName = ExAllocatePoolWithTag( OB_NAMESPACE_POOL_TYPE, MaximumLength, 'mNbO' );

        if (NewName == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        MaximumLength = CompleteName->MaximumLength;
        NewName = CompleteName->Buffer;
    }

    //
    //  Concatenate the symbolic link name with the remaining name,
    //  if any.  What this does is overwrite the front of the complete
    //  name up to the remaining name with the links target name
    //

    if (RemainingName->Length != 0) {

        RtlMoveMemory( (PVOID)((PUCHAR)NewName + InsertAmount),
                       RemainingName->Buffer,
                       RemainingName->Length );
    }

    RtlCopyMemory( NewName, LinkTargetName->Buffer, InsertAmount );

    NewName[ Length / sizeof( WCHAR ) ] = UNICODE_NULL;

    //
    //  If a new name buffer was allocated, then free the original complete
    //  name buffer.
    //

    if ((NewName != CompleteName->Buffer)
            &&
        (CompleteName->Buffer != NULL)) {

        ExFreePool( CompleteName->Buffer );
    }

    //
    //  Set the new complete name buffer parameters and return a reparse
    //  status.
    //

    CompleteName->Buffer = NewName;
    CompleteName->Length = Length;
    CompleteName->MaximumLength = MaximumLength;

    return STATUS_REPARSE;
}


VOID
ObpDeleteSymbolicLink (
    IN  PVOID   Object
    )

/*++

Routine Description:

    This routine is called when a reference to a symbolic link goes to zero.
    Its job is to clean up the memory used to the symbolic link string

Arguments:

    Object - Supplies a pointer to the symbolic link object being deleted

Return Value:

    None.

--*/

{
    POBJECT_SYMBOLIC_LINK SymbolicLink = (POBJECT_SYMBOLIC_LINK)Object;

    PAGED_CODE();

    //
    //  The only cleaning up we need to do is to free the link target
    //  buffer
    //

    if (SymbolicLink->LinkTarget.Buffer != NULL) {

        ExFreePool( SymbolicLink->LinkTarget.Buffer );
    }

    SymbolicLink->LinkTarget.Buffer = NULL;

    //
    //  And return to our caller
    //

    return;
}


VOID
ObpDeleteSymbolicLinkName (
    POBJECT_SYMBOLIC_LINK SymbolicLink
    )

/*++

Routine Description:

    This routine delete the symbolic from the system

Arguments:

    SymbolicLink - Supplies a pointer to the object body for the symbolic
        link object to delete

Return Value:

    None.

    This function must be called with the symbolic link object locked.
    That lock is protecting the symlink specific fields.

--*/

{

    ObpProcessDosDeviceSymbolicLink( SymbolicLink, DELETE_SYMBOLIC_LINK );

    return;
}


VOID
ObpCreateSymbolicLinkName (
    POBJECT_SYMBOLIC_LINK SymbolicLink
    )

/*++

Routine Description:

    This routine does extra processing for symbolic links being created in
    object directories controlled by device map objects.

    This processing consists of:

    1.  Determine if the name of the symbolic link is a drive letter.
        If so, then we will need to update the drive type in the
        associated device map object.

    2.  Process the link target, trying to resolve it into a pointer to
        an object other than a object directory object.  All object
        directories traversed must grant world traverse access other
        wise we bail out.  If we successfully find a non object
        directory object, then reference the object pointer and store it
        in the symbolic link object, along with a remaining string if
        any.  ObpLookupObjectName will used this cache object pointer to
        short circuit the name lookup directly to the cached object's
        parse routine.  For any object directory objects traversed along
        the way, increment their symbolic link SymbolicLinkUsageCount
        field.  This field is used whenever an object directory is
        deleted or its security is changed such that it no longer grants
        world traverse access.  In either case, if the field is non-zero
        we walk all the symbolic links and resnap them.

Arguments:

    SymbolicLink - pointer to symbolic link object being created.

Return Value:

    None.

--*/

{
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;
    WCHAR DosDeviceDriveLetter;
    ULONG DosDeviceDriveIndex;

    //
    //  Now see if this symbolic link is being created in an object directory
    //  controlled by a device map object.  Since we are only called from
    //  NtCreateSymbolicLinkObject, after the handle to this symbolic link
    //  has been created but before it is returned to the caller the handle can't
    //  be closed while we are executing, unless via a random close,
    //  So no need to hold the type specific mutex while we look at the name.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( SymbolicLink );
    NameInfo = ObpReferenceNameInfo( ObjectHeader );

    if ((NameInfo == NULL) ||
        (NameInfo->Directory == NULL) ||
        (NameInfo->Directory->DeviceMap == NULL)) {

        ObpDereferenceNameInfo( NameInfo );
        return;
    }

    //
    //  Here if we are creating a symbolic link in an object directory controlled
    //  by a device map object.  See if this is a drive letter definition.  If so
    //  calculate the drive letter index and remember in the symbolic link object.
    //

    DosDeviceDriveIndex = 0;

    if ((NameInfo->Name.Length == (2 * sizeof( WCHAR ))) &&
        (NameInfo->Name.Buffer[ 1 ] == L':')) {

        DosDeviceDriveLetter = RtlUpcaseUnicodeChar( NameInfo->Name.Buffer[ 0 ] );

        if ((DosDeviceDriveLetter >= L'A') && (DosDeviceDriveLetter <= L'Z')) {

            DosDeviceDriveIndex = DosDeviceDriveLetter - L'A';
            DosDeviceDriveIndex += 1;

            SymbolicLink->DosDeviceDriveIndex = DosDeviceDriveIndex;
        }
    }

    //
    //  Now traverse the target path seeing if we can snap the link now.
    //

    ObpProcessDosDeviceSymbolicLink( SymbolicLink, CREATE_SYMBOLIC_LINK );

    ObpDereferenceNameInfo( NameInfo );

    return;
}


//
//  Local support routine
//

#define MAX_DEPTH 16

VOID
ObpProcessDosDeviceSymbolicLink (
    POBJECT_SYMBOLIC_LINK SymbolicLink,
    ULONG Action
    )

/*++

Routine Description:

    This function is called whenever a symbolic link is created or deleted
    in an object directory controlled by a device map object.

    For creates, it attempts to snap the symbolic link to a non-object
    directory object.  It does this by walking the symbolic link target
    string, until it sees a non-directory object or a directory object
    that does NOT allow World traverse access.  It stores a referenced
    pointer to this object in the symbolic link object.  It also
    increments a count in each of the object directory objects that it
    walked over.  This count is used to disallow any attempt to remove
    World traverse access from a directory object after it has
    participated in a snapped symbolic link.

    For deletes, it repeats the walk of the target string, decrementing
    the count associated with each directory object walked over.  It also
    dereferences the snapped object pointer.

Arguments:

    SymbolicLink - pointer to symbolic link object being created or deleted.

    Action - describes whether this is a create or a delete action

Return Value:

    None.

--*/

{
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;
    UNICODE_STRING RemainingName;
    UNICODE_STRING ComponentName;

    POBJECT_DIRECTORY Directory, ParentDirectory;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_MAP DeviceMap = NULL;
    ULONG DosDeviceDriveType;
    BOOLEAN DeviceMapUsed = FALSE;
    UNICODE_STRING RemainingTarget;
    ULONG MaxReparse = OBJ_MAX_REPARSE_ATTEMPTS;
    OBP_LOOKUP_CONTEXT LookupContext;
    POBJECT_DIRECTORY SymLinkDirectory = NULL;
    BOOLEAN PreviousLockingState;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( SymbolicLink );
    NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

    if (NameInfo != NULL) {

        SymLinkDirectory = NameInfo->Directory;
    }

    Object = NULL;
    RtlInitUnicodeString( &RemainingTarget, NULL );

    ObpInitializeLookupContext( &LookupContext );

    //
    //  Check if we are creating a symbolic link or if the link has already
    //  been snapped
    //

    if ((Action == CREATE_SYMBOLIC_LINK) ||
        (SymbolicLink->LinkTargetObject != NULL)) {

        ParentDirectory = NULL;
        Directory = ObpRootDirectoryObject;
        RemainingName = SymbolicLink->LinkTarget;

        //
        // If LUID device maps are enabled,
        // then use the Object Manager's pointer to the global
        // device map
        // With LUID device maps enabled, the process' device map pointer
        // may be NULL
        //
        if (ObpLUIDDeviceMapsEnabled != 0) {
            DeviceMap = ObSystemDeviceMap;
        }
        else {
            //
            // use the device map associated with the process
            //
            DeviceMap = PsGetCurrentProcess()->DeviceMap;
        }


ReCalcDeviceMap:

        if (DeviceMap) {


            if (!((ULONG_PTR)(RemainingName.Buffer) & (sizeof(ULONGLONG)-1))

                        &&

                (DeviceMap->DosDevicesDirectory != NULL )) {

                //
                //  Check if the object name is actually equal to the
                //  global dos devices short name prefix "\??\"
                //

                if ((RemainingName.Length >= ObpDosDevicesShortName.Length)

                        &&

                    (*(PULONGLONG)(RemainingName.Buffer) == ObpDosDevicesShortNamePrefix.Alignment.QuadPart)) {

                    //
                    //  The user gave us the dos short name prefix so we'll
                    //  look down the directory, and start the search at the
                    //  dos device directory
                    //

                    Directory = DeviceMap->DosDevicesDirectory;

                    RemainingName.Buffer += (ObpDosDevicesShortName.Length / sizeof( WCHAR ));
                    RemainingName.Length = (USHORT)(RemainingName.Length - ObpDosDevicesShortName.Length);

                    DeviceMapUsed = TRUE;

                }
            }
        }

        //
        //  The following loop will dissect the link target checking
        //  that each directory exists and that we have access to
        //  the directory.  When we pop out the local directories
        //  array will contain a list of directories that we need
        //  to traverse to process this action.
        //

        while (TRUE) {

            //
            //  Gobble up the "\" in the remaining name
            //

            if (*(RemainingName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {

                RemainingName.Buffer++;
                RemainingName.Length -= sizeof( OBJ_NAME_PATH_SEPARATOR );
            }

            //
            //  And dissect the name into its first component and any
            //  remaining part
            //

            ComponentName = RemainingName;

            while (RemainingName.Length != 0) {

                if (*(RemainingName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {

                    break;
                }

                RemainingName.Buffer++;
                RemainingName.Length -= sizeof( OBJ_NAME_PATH_SEPARATOR );
            }

            ComponentName.Length = (USHORT)(ComponentName.Length - RemainingName.Length);

            if (ComponentName.Length == 0) {

                ObpReleaseLookupContext(&LookupContext);
                return;
            }

            //
            //  Look this component name up in this directory.  If not found, then
            //  bail.
            //

            //
            //  If we are searching the same directory that contains the sym link
            //  we have already the directory exclusively locked. We need to adjust
            //  the lookupcontext state and avoid recursive locking
            //

            if (Directory == SymLinkDirectory) {

                PreviousLockingState = LookupContext.DirectoryLocked;
                LookupContext.DirectoryLocked = TRUE;
            }
            else {
                PreviousLockingState = FALSE;
            }

            Object = ObpLookupDirectoryEntry( Directory,
                                              &ComponentName,
                                              0,
                                              FALSE ,
                                              &LookupContext);

            if (Directory == SymLinkDirectory) {

                LookupContext.DirectoryLocked = PreviousLockingState;
            }

            if (Object == NULL) {

                break;
            }

            //
            //  See if this is a object directory object.  If so, keep going
            //

            ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

            if (ObjectHeader->Type == ObpDirectoryObjectType) {

                ParentDirectory = Directory;
                Directory = (POBJECT_DIRECTORY)Object;

            } else if ((ObjectHeader->Type == ObpSymbolicLinkObjectType) &&
                       (((POBJECT_SYMBOLIC_LINK)Object)->DosDeviceDriveIndex == 0)) {

                //
                // To prevent Denial of Service attacks from parsing
                // symbolic links infinitely.
                // Check the number of symbolic link parse attempts
                //
                if (MaxReparse == 0) {

                    Object = NULL;
                    break;
                }

                MaxReparse--;

                //
                //  Found a symbolic link to another symbolic link that is
                //  not already snapped.  So switch to its target string
                //  so we can chase down the real device object
                //

                ParentDirectory = NULL;
                Directory = ObpRootDirectoryObject;

                //
                //  Save the remaining name
                //

                if (RemainingTarget.Length == 0) {

                    RemainingTarget = RemainingName;
                }

                RemainingName = ((POBJECT_SYMBOLIC_LINK)Object)->LinkTarget;

                goto ReCalcDeviceMap;

            } else {

                //
                //  Not an object directory object, or a symbolic link to an
                //  unsnapped symbolic link, so all done.  Exit the loop
                //

                break;
            }
        }
    }

    //
    //  Done processing symbolic link target path.  Update symbolic link
    //  object as appropriate for passed in reason
    //

    //
    //  If this is a drive letter symbolic link, get the address of the device
    //  map object that is controlling the containing object directory so we
    //  can update the drive type in the device map.
    //

    DeviceMap = NULL;

    if (SymbolicLink->DosDeviceDriveIndex != 0) {

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( SymbolicLink );
        NameInfo = ObpReferenceNameInfo( ObjectHeader );

        if (NameInfo != NULL && NameInfo->Directory) {

            DeviceMap = NameInfo->Directory->DeviceMap;
        }

        ObpDereferenceNameInfo( NameInfo );
    }

    //
    //  Check if we are creating a symbolic link
    //

    if (Action == CREATE_SYMBOLIC_LINK) {

        DosDeviceDriveType = DOSDEVICE_DRIVE_CALCULATE;

        if (Object != NULL) {


            //
            // We only want to do snapping for console session. When we create a
            // remote session all the symbolic links stored in the console dos devices
            // directory (\??) are copied into the per session DosDevices object directory
            // (\Session\<id>\DosDevices). We don't want to do snapping for the copied
            // symbolic links since for each copy we will increment the ref count on the
            // target object. All these counts have to go to zero before the device can be
            // deleted.
            //
            // Disable snapping until we come up with a delete scheme for it
            //
            if (FALSE /*( PsGetCurrentProcess()->SessionId == 0) || (DeviceMapUsed)*/) {
                //
                //  Create action.  Store a referenced pointer to the snapped object
                //  along with the description of any remaining name string.  Also,
                //  for Dos drive letters, update the drive type in the appropriate
                //  device map object.
                //

                ObReferenceObject( Object );

                SymbolicLink->LinkTargetObject = Object;

                //
                //  If we have saved a remaining target string
                //  we'll set it to the symbolic link object
                //

                if ( RemainingTarget.Length ) {

                    RemainingName = RemainingTarget;
                }

                if ((*(RemainingName.Buffer) == OBJ_NAME_PATH_SEPARATOR) &&
                    (RemainingName.Length == sizeof( OBJ_NAME_PATH_SEPARATOR))) {

                    RtlInitUnicodeString( &SymbolicLink->LinkTargetRemaining, NULL );

                } else {

                    SymbolicLink->LinkTargetRemaining = RemainingName;
                }
            }

            if (SymbolicLink->DosDeviceDriveIndex != 0) {

                //
                //  Default is to calculate the drive type in user mode if we are
                //  unable to snap the symbolic link or it does not resolve to a
                //  DEVICE_OBJECT we know about.
                //

                ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

                if (ObjectHeader->Type == IoDeviceObjectType) {

                    DeviceObject = (PDEVICE_OBJECT)Object;

                    switch (DeviceObject->DeviceType) {

                    case FILE_DEVICE_CD_ROM:
                    case FILE_DEVICE_CD_ROM_FILE_SYSTEM:

                        DosDeviceDriveType = DOSDEVICE_DRIVE_CDROM;

                        break;

                    case FILE_DEVICE_DISK:
                    case FILE_DEVICE_DISK_FILE_SYSTEM:
                    case FILE_DEVICE_FILE_SYSTEM:

                        if (DeviceObject->Characteristics & FILE_REMOVABLE_MEDIA) {

                            DosDeviceDriveType = DOSDEVICE_DRIVE_REMOVABLE;

                        } else {

                            DosDeviceDriveType = DOSDEVICE_DRIVE_FIXED;
                        }

                        break;

                    case FILE_DEVICE_MULTI_UNC_PROVIDER:
                    case FILE_DEVICE_NETWORK:
                    case FILE_DEVICE_NETWORK_BROWSER:
                    case FILE_DEVICE_NETWORK_REDIRECTOR:

                        DosDeviceDriveType = DOSDEVICE_DRIVE_REMOTE;

                        break;

                    case FILE_DEVICE_NETWORK_FILE_SYSTEM:

#if defined(REMOTE_BOOT)
                        //
                        //  If this is a remote boot workstation, the X:
                        //  drive is a redirected drive, but needs to look
                        //  like a local drive.
                        //

                        if (IoRemoteBootClient &&
                            (SymbolicLink->DosDeviceDriveIndex == 24)) {

                            DosDeviceDriveType = DOSDEVICE_DRIVE_FIXED;

                        } else
#endif // defined(REMOTE_BOOT)
                        {
                            DosDeviceDriveType = DOSDEVICE_DRIVE_REMOTE;
                        }

                        break;

                    case FILE_DEVICE_VIRTUAL_DISK:

                        DosDeviceDriveType = DOSDEVICE_DRIVE_RAMDISK;

                        break;

                    default:

                        DosDeviceDriveType = DOSDEVICE_DRIVE_UNKNOWN;

                        break;
                    }
                }
            }
        }

        //
        //  If this is a drive letter symbolic link, update the drive type and
        //  and mark as valid drive letter.
        //

        if (DeviceMap != NULL) {

            ObpLockDeviceMap();

            DeviceMap->DriveType[ SymbolicLink->DosDeviceDriveIndex-1 ] = (UCHAR)DosDeviceDriveType;
            DeviceMap->DriveMap |= 1 << (SymbolicLink->DosDeviceDriveIndex-1) ;

            ObpUnlockDeviceMap();
        }

    } else {

        //
        //  Deleting the symbolic link.  Dereference the snapped object pointer if any
        //  and zero out the snapped object fields.
        //

        RtlInitUnicodeString( &SymbolicLink->LinkTargetRemaining, NULL );

        Object = SymbolicLink->LinkTargetObject;

        if (Object != NULL) {

            SymbolicLink->LinkTargetObject = NULL;
            ObDereferenceObject( Object );
        }

        //
        //  If this is a drive letter symbolic link, set the drive type to
        //  unknown and clear the bit in the drive letter bit map.
        //

        if (DeviceMap != NULL) {

            ObpLockDeviceMap();

            DeviceMap->DriveMap &= ~(1 << (SymbolicLink->DosDeviceDriveIndex-1));
            DeviceMap->DriveType[ SymbolicLink->DosDeviceDriveIndex-1 ] = DOSDEVICE_DRIVE_UNKNOWN;

            ObpUnlockDeviceMap();

            SymbolicLink->DosDeviceDriveIndex = 0;
        }

        //
        //  N.B. The original code freed here the target buffer. This is
        //  illegal because the parse routine for symbolic links reads the buffer unsynchronized
        //  The buffer will be released in the delete procedure, when the sym link goes away
        //

    }

    ObpReleaseLookupContext(&LookupContext);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obinit.c

Abstract:

    Initialization module for the OB subcomponent of NTOS

--*/

#include "obp.h"

//
//  Define date structures for the object creation information region.
//

GENERAL_LOOKASIDE ObpCreateInfoLookasideList;

//
//  Define data structures for the object name buffer lookaside list.
//

#define OBJECT_NAME_BUFFER_SIZE 248

GENERAL_LOOKASIDE ObpNameBufferLookasideList;

//
//  Form some default access masks for the various object types
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif


const GENERIC_MAPPING ObpTypeMapping = {
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    OBJECT_TYPE_ALL_ACCESS
};

const GENERIC_MAPPING ObpDirectoryMapping = {
    STANDARD_RIGHTS_READ |
        DIRECTORY_QUERY |
        DIRECTORY_TRAVERSE,
    STANDARD_RIGHTS_WRITE |
        DIRECTORY_CREATE_OBJECT |
        DIRECTORY_CREATE_SUBDIRECTORY,
    STANDARD_RIGHTS_EXECUTE |
        DIRECTORY_QUERY |
        DIRECTORY_TRAVERSE,
    DIRECTORY_ALL_ACCESS
};

const GENERIC_MAPPING ObpSymbolicLinkMapping = {
    STANDARD_RIGHTS_READ |
        SYMBOLIC_LINK_QUERY,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE |
        SYMBOLIC_LINK_QUERY,
    SYMBOLIC_LINK_ALL_ACCESS
};

//
//  Local procedure prototypes
//

NTSTATUS
ObpCreateDosDevicesDirectory (
    VOID
    );

NTSTATUS
ObpGetDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

VOID
ObpFreeDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

BOOLEAN
ObpShutdownCloseHandleProcedure (
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE HandleId,
    IN PVOID EnumParameter
    );


#ifdef ALLOC_PRAGMA
BOOLEAN
ObDupHandleProcedure (
    PEPROCESS Process,
    PHANDLE_TABLE OldObjectTable,
    PHANDLE_TABLE_ENTRY OldObjectTableEntry,
    PHANDLE_TABLE_ENTRY ObjectTableEntry
    );
BOOLEAN
ObAuditInheritedHandleProcedure (
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE HandleId,
    IN PVOID EnumParameter
    );
VOID
ObDestroyHandleProcedure (
    IN HANDLE HandleIndex
    );
BOOLEAN
ObpEnumFindHandleProcedure (
    PHANDLE_TABLE_ENTRY ObjectTableEntry,
    HANDLE HandleId,
    PVOID EnumParameter
    );

BOOLEAN
ObpCloseHandleProcedure (
    IN PHANDLE_TABLE_ENTRY HandleTableEntry,
    IN HANDLE Handle,
    IN PVOID EnumParameter
    );

#pragma alloc_text(INIT,ObInitSystem)
#pragma alloc_text(PAGE,ObDupHandleProcedure)
#pragma alloc_text(PAGE,ObAuditInheritedHandleProcedure)
#pragma alloc_text(PAGE,ObInitProcess)
#pragma alloc_text(PAGE,ObInitProcess2)
#pragma alloc_text(PAGE,ObDestroyHandleProcedure)
#pragma alloc_text(PAGE,ObKillProcess)
#pragma alloc_text(PAGE,ObClearProcessHandleTable)
#pragma alloc_text(PAGE,ObpCloseHandleProcedure)
#pragma alloc_text(PAGE,ObpEnumFindHandleProcedure)
#pragma alloc_text(PAGE,ObFindHandleForObject)
#pragma alloc_text(PAGE,ObpShutdownCloseHandleProcedure)
#pragma alloc_text(PAGE,ObShutdownSystem)
#pragma alloc_text(INIT,ObpCreateDosDevicesDirectory)
#pragma alloc_text(INIT,ObpGetDosDevicesProtection)
#pragma alloc_text(INIT,ObpFreeDosDevicesProtection)
#endif

//
//  The default quota block is setup by obinitsystem
//


ULONG ObpAccessProtectCloseBit = MAXIMUM_ALLOWED;


PDEVICE_MAP ObSystemDeviceMap = NULL;

//
//  CurrentControlSet values set by code in config\cmdat3.c at system load time
//  These are private variables within obinit.c
//

#define OBJ_SECURITY_MODE_BNO_RESTRICTED 1

ULONG ObpProtectionMode;
ULONG ObpLUIDDeviceMapsDisabled;
ULONG ObpAuditBaseDirectories;
ULONG ObpAuditBaseObjects;
ULONG ObpObjectSecurityMode = OBJ_SECURITY_MODE_BNO_RESTRICTED;

//
// ObpLUIDDeviceMapsEnabled holds the result of "Is LUID device maps enabled?"
// Depends on the DWORD registry keys, ProtectionMode & LUIDDeviceMapsDisabled:
// location: \Registry\Machine\System\CurrentControlSet\Control\Session Manager
//
// Enabling/Disabling works as follows:
// if ((ProtectionMode == 0) || (LUIDDeviceMapsDisabled !=0)) {
//     // LUID device maps are disabled
//     // ObpLUIDDeviceMapsEnabled == 0
// }
// else {
//     // LUID device maps are enabled
//     // ObpLUIDDeviceMapsEnabled == 1
// }
//
ULONG ObpLUIDDeviceMapsEnabled;

//
//  MmNumberOfPagingFiles is used in shutdown, to make sure we're not
//  leaking any kernel handles.
//
extern ULONG MmNumberOfPagingFiles;

//
//  These are global variables
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif
//
//  A ULONGLONG aligned global variable
//  for use by ObpLookupObjectName for quick comparisons.
//
const ALIGNEDNAME ObpDosDevicesShortNamePrefix = { L'\\',L'?',L'?',L'\\' }; // L"\??\"
const ALIGNEDNAME ObpDosDevicesShortNameRoot = { L'\\',L'?',L'?',L'\0' }; // L"\??"
const UNICODE_STRING ObpDosDevicesShortName = {
    sizeof(ObpDosDevicesShortNamePrefix),
    sizeof(ObpDosDevicesShortNamePrefix),
    (PWSTR)&ObpDosDevicesShortNamePrefix
};

#define ObpGlobalDosDevicesShortName    L"\\GLOBAL??"  // \GLOBAL??

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

BOOLEAN
ObInitSystem (
    VOID
    )

/*++

Routine Description:

    This function performs the system initialization for the object
    manager.  The object manager data structures are self describing
    with the exception of the root directory, the type object type and
    the directory object type.  The initialization code then constructs
    these objects by hand to get the ball rolling.

Arguments:

    None.

Return Value:

    TRUE if successful and FALSE if an error occurred.

    The following errors can occur:

    - insufficient memory

--*/

{
    USHORT CreateInfoMaxDepth;
    USHORT NameBufferMaxDepth;
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    UNICODE_STRING TypeTypeName;
    UNICODE_STRING SymbolicLinkTypeName;
    UNICODE_STRING DirectoryTypeName;
    UNICODE_STRING RootDirectoryName;
    UNICODE_STRING TypeDirectoryName;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE RootDirectoryHandle;
    HANDLE TypeDirectoryHandle;
    PLIST_ENTRY Next, Head;
    POBJECT_HEADER ObjectTypeHeader;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER_NAME_INFO NameInfo;
    MM_SYSTEMSIZE SystemSize;
    SECURITY_DESCRIPTOR AuditSd;
    PSECURITY_DESCRIPTOR EffectiveSd;
    PACL    AuditAllAcl;
    UCHAR   AuditAllBuffer[250];  // Ample room for the ACL
    ULONG   AuditAllLength;
    PACE_HEADER Ace;
    PGENERAL_LOOKASIDE Lookaside;
    ULONG Index;
    PKPRCB Prcb;
    OBP_LOOKUP_CONTEXT LookupContext;
    PACL Dacl;
    ULONG DaclLength;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    //
    //  Determine the the size of the object creation and the name buffer
    //  lookaside lists.
    //

    SystemSize = MmQuerySystemSize();

    if (SystemSize == MmLargeSystem) {

        if (MmIsThisAnNtAsSystem()) {

            CreateInfoMaxDepth = 64;
            NameBufferMaxDepth = 32;

        } else {

            CreateInfoMaxDepth = 32;
            NameBufferMaxDepth = 16;
        }

    } else {

        CreateInfoMaxDepth = 3;
        NameBufferMaxDepth = 3;
    }

    //
    //  PHASE 0 Initialization
    //

    if (InitializationPhase == 0) {

        //
        //  Initialize the object creation lookaside list.
        //

        ExInitializeSystemLookasideList( &ObpCreateInfoLookasideList,
                                         NonPagedPool,
                                         sizeof(OBJECT_CREATE_INFORMATION),
                                         'iCbO',
                                         CreateInfoMaxDepth,
                                         &ExSystemLookasideListHead );

        //
        //  Initialize the name buffer lookaside list.
        //

        ExInitializeSystemLookasideList( &ObpNameBufferLookasideList,

#ifndef OBP_PAGEDPOOL_NAMESPACE

                                         NonPagedPool,

#else

                                         PagedPool,

#endif

                                         OBJECT_NAME_BUFFER_SIZE,
                                         'mNbO',
                                         NameBufferMaxDepth,
                                         &ExSystemLookasideListHead );

        //
        //  Initialize the system create info and name buffer lookaside lists
        //  for the current processor.
        //
        // N.B. Temporarily during the initialization of the system both
        //      lookaside list pointers in the processor block point to
        //      the same lookaside list structure. Later in initialization
        //      another lookaside list structure is allocated and filled
        //      for the per processor list.
        //

        Prcb = KeGetCurrentPrcb();
        Prcb->PPLookasideList[LookasideCreateInfoList].L = &ObpCreateInfoLookasideList;
        Prcb->PPLookasideList[LookasideCreateInfoList].P = &ObpCreateInfoLookasideList;
        Prcb->PPLookasideList[LookasideNameBufferList].L = &ObpNameBufferLookasideList;
        Prcb->PPLookasideList[LookasideNameBufferList].P = &ObpNameBufferLookasideList;

        //
        //  Initialize the object removal queue listhead.
        //

        ObpRemoveObjectList = NULL;

        //
        //  Initialize security descriptor cache
        //

        ObpInitSecurityDescriptorCache();

        KeInitializeEvent( &ObpDefaultObject, NotificationEvent, TRUE );
        ExInitializePushLock( &ObpLock );
        PsGetCurrentProcess()->GrantedAccess = PROCESS_ALL_ACCESS;
        PsGetCurrentThread()->GrantedAccess = THREAD_ALL_ACCESS;

#ifndef OBP_PAGEDPOOL_NAMESPACE
        KeInitializeSpinLock( &ObpDeviceMapLock );
#else
        KeInitializeGuardedMutex( &ObpDeviceMapLock );
#endif  // OBP_PAGEDPOOL_NAMESPACE

        //
        //  Initialize the quota system
        //
        PsInitializeQuotaSystem ();

        //
        //  Initialize the handle table for the system process and also the global
        //  kernel handle table
        //

        ObpKernelHandleTable = PsGetCurrentProcess()->ObjectTable = ExCreateHandleTable( NULL );
#if DBG
        //
        // On checked make handle reuse take much longer
        //
        ExSetHandleTableStrictFIFO (ObpKernelHandleTable);
#endif

        //
        // Initialize the deferred delete work item.
        //

        ExInitializeWorkItem( &ObpRemoveObjectWorkItem,
                              ObpProcessRemoveObjectQueue,
                              NULL );

        //
        //  Create an object type for the "Type" object.  This is the start of
        //  of the object types and goes in the ObpTypeDirectoryObject.
        //

        RtlZeroMemory( &ObjectTypeInitializer, sizeof( ObjectTypeInitializer ) );
        ObjectTypeInitializer.Length = sizeof( ObjectTypeInitializer );
        ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
        ObjectTypeInitializer.PoolType = NonPagedPool;

        RtlInitUnicodeString( &TypeTypeName, L"Type" );
        ObjectTypeInitializer.ValidAccessMask = OBJECT_TYPE_ALL_ACCESS;
        ObjectTypeInitializer.GenericMapping = ObpTypeMapping;
        ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( OBJECT_TYPE );
        ObjectTypeInitializer.MaintainTypeList = TRUE;
        ObjectTypeInitializer.UseDefaultObject = TRUE;
        ObjectTypeInitializer.DeleteProcedure = &ObpDeleteObjectType;
        ObCreateObjectType( &TypeTypeName,
                            &ObjectTypeInitializer,
                            (PSECURITY_DESCRIPTOR)NULL,
                            &ObpTypeObjectType );

        //
        //  Create the object type for the "Directory" object.
        //
        
        ObjectTypeInitializer.PoolType = OB_NAMESPACE_POOL_TYPE;

        RtlInitUnicodeString( &DirectoryTypeName, L"Directory" );
        ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( OBJECT_DIRECTORY );
        ObjectTypeInitializer.ValidAccessMask = DIRECTORY_ALL_ACCESS;
        ObjectTypeInitializer.CaseInsensitive = TRUE;
        ObjectTypeInitializer.GenericMapping = ObpDirectoryMapping;
        ObjectTypeInitializer.UseDefaultObject = TRUE;
        ObjectTypeInitializer.MaintainTypeList = FALSE;
        ObjectTypeInitializer.DeleteProcedure = NULL;
        ObCreateObjectType( &DirectoryTypeName,
                            &ObjectTypeInitializer,
                            (PSECURITY_DESCRIPTOR)NULL,
                            &ObpDirectoryObjectType );
        
        //
        //  Clear SYNCHRONIZE from the access mask to not allow
        //  synchronization on directory objects
        //

        ObpDirectoryObjectType->TypeInfo.ValidAccessMask &= ~SYNCHRONIZE;

        //
        //  Create the object type for the "SymbolicLink" object.
        //

        RtlInitUnicodeString( &SymbolicLinkTypeName, L"SymbolicLink" );
        ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( OBJECT_SYMBOLIC_LINK );
        ObjectTypeInitializer.ValidAccessMask = SYMBOLIC_LINK_ALL_ACCESS;
        ObjectTypeInitializer.CaseInsensitive = TRUE;
        ObjectTypeInitializer.GenericMapping = ObpSymbolicLinkMapping;
        ObjectTypeInitializer.DeleteProcedure = ObpDeleteSymbolicLink;
        ObjectTypeInitializer.ParseProcedure = ObpParseSymbolicLink;
        ObCreateObjectType( &SymbolicLinkTypeName,
                            &ObjectTypeInitializer,
                            (PSECURITY_DESCRIPTOR)NULL,
                            &ObpSymbolicLinkObjectType );
        
        //
        //  Clear SYNCHRONIZE from the access mask to not allow
        //  synchronization on symbolic link objects objects
        //

        ObpSymbolicLinkObjectType->TypeInfo.ValidAccessMask &= ~SYNCHRONIZE;

#ifdef POOL_TAGGING
        //
        // Initialize the ref/deref object-tracing mechanism
        //

        ObpInitStackTrace();
#endif //POOL_TAGGING

#if i386 

        //
        //  Initialize the cached granted access structure.  These variables are used
        //  in place of the access mask in the object table entry.
        //

        ObpCurCachedGrantedAccessIndex = 0;

        if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

            ObpMaxCachedGrantedAccessIndex = 2*PAGE_SIZE / sizeof( ACCESS_MASK );
            ObpCachedGrantedAccesses = ExAllocatePoolWithTag( PagedPool, 2*PAGE_SIZE, 'gAbO' );

            if (ObpCachedGrantedAccesses == NULL) {

                return FALSE;
            }

            ObpAccessProtectCloseBit = 0x80000000;
        } else {

            ObpMaxCachedGrantedAccessIndex = 0;
            ObpCachedGrantedAccesses = NULL;
        }

#endif // i386 

    } // End of Phase 0 Initialization

    //
    //  PHASE 1 Initialization
    //

    if (InitializationPhase == 1) {

        //
        //  Initialize the per processor nonpaged lookaside lists and descriptors.
        //

        for (Index = 0; Index < (ULONG)KeNumberProcessors; Index += 1) {
            Prcb = KiProcessorBlock[Index];

            //
            //  Initialize the create information per processor lookaside pointers.
            //

            Prcb->PPLookasideList[LookasideCreateInfoList].L = &ObpCreateInfoLookasideList;
            Lookaside = ExAllocatePoolWithTag( NonPagedPool,
                                               sizeof(GENERAL_LOOKASIDE),
                                              'ICbO');

            if (Lookaside != NULL) {
                ExInitializeSystemLookasideList( Lookaside,
                                                 NonPagedPool,
                                                 sizeof(OBJECT_CREATE_INFORMATION),
                                                 'ICbO',
                                                 CreateInfoMaxDepth,
                                                 &ExSystemLookasideListHead );

            } else {
                Lookaside = &ObpCreateInfoLookasideList;
            }

            Prcb->PPLookasideList[LookasideCreateInfoList].P = Lookaside;

            //
            //  Initialize the name buffer per processor lookaside pointers.
            //


            Prcb->PPLookasideList[LookasideNameBufferList].L = &ObpNameBufferLookasideList;
            Lookaside = ExAllocatePoolWithTag( NonPagedPool,
                                               sizeof(GENERAL_LOOKASIDE),
                                               'MNbO');

            if (Lookaside != NULL) {
                ExInitializeSystemLookasideList( Lookaside,

#ifndef OBP_PAGEDPOOL_NAMESPACE

                                                 NonPagedPool,

#else

                                                PagedPool,

#endif

                                                 OBJECT_NAME_BUFFER_SIZE,
                                                 'MNbO',
                                                 NameBufferMaxDepth,
                                                 &ExSystemLookasideListHead );

            } else {
                Lookaside = &ObpNameBufferLookasideList;
            }

            Prcb->PPLookasideList[LookasideNameBufferList].P = Lookaside;

        }

        EffectiveSd = SePublicDefaultUnrestrictedSd;

        //
        //  This code is only executed if base auditing is turned on.
        //

        if ((ObpAuditBaseDirectories != 0) || (ObpAuditBaseObjects != 0)) {

            //
            //  build an SACL to audit
            //

            AuditAllAcl = (PACL)AuditAllBuffer;
            AuditAllLength = (ULONG)sizeof(ACL) +
                               ((ULONG)sizeof(SYSTEM_AUDIT_ACE)) +
                               SeLengthSid(SeWorldSid);

            ASSERT( sizeof(AuditAllBuffer)   >   AuditAllLength );

            Status = RtlCreateAcl( AuditAllAcl, AuditAllLength, ACL_REVISION2);

            ASSERT( NT_SUCCESS(Status) );

            Status = RtlAddAuditAccessAce ( AuditAllAcl,
                                            ACL_REVISION2,
                                            GENERIC_ALL,
                                            SeWorldSid,
                                            TRUE,  TRUE ); //Audit success and failure
            ASSERT( NT_SUCCESS(Status) );

            Status = RtlGetAce( AuditAllAcl, 0,  (PVOID)&Ace );

            ASSERT( NT_SUCCESS(Status) );

            if (ObpAuditBaseDirectories != 0) {

                Ace->AceFlags |= (CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
            }

            if (ObpAuditBaseObjects != 0) {

                Ace->AceFlags |= (OBJECT_INHERIT_ACE    |
                                  CONTAINER_INHERIT_ACE |
                                  INHERIT_ONLY_ACE);
            }

            //
            //  Now create a security descriptor that looks just like
            //  the public default, but has auditing in it as well.
            //

            EffectiveSd = (PSECURITY_DESCRIPTOR)&AuditSd;
            Status = RtlCreateSecurityDescriptor( EffectiveSd,
                                                  SECURITY_DESCRIPTOR_REVISION1 );

            ASSERT( NT_SUCCESS(Status) );

            Status = RtlSetDaclSecurityDescriptor( EffectiveSd,
                                                   TRUE,        // DaclPresent
                                                   SePublicDefaultUnrestrictedDacl,
                                                   FALSE );     // DaclDefaulted

            ASSERT( NT_SUCCESS(Status) );

            Status = RtlSetSaclSecurityDescriptor( EffectiveSd,
                                                   TRUE,        // DaclPresent
                                                   AuditAllAcl,
                                                   FALSE );     // DaclDefaulted

            ASSERT( NT_SUCCESS(Status) );
        }

        //
        //  We only need to use the EffectiveSd on the root.  The SACL
        //  will be inherited by all other objects.
        //

        //
        //  Create a directory object for the root directory
        //

        RtlInitUnicodeString( &RootDirectoryName, L"\\" );

        InitializeObjectAttributes( &ObjectAttributes,
                                    &RootDirectoryName,
                                    OBJ_CASE_INSENSITIVE |
                                    OBJ_PERMANENT,
                                    NULL,
                                    EffectiveSd );

        Status = NtCreateDirectoryObject( &RootDirectoryHandle,
                                          DIRECTORY_ALL_ACCESS,
                                          &ObjectAttributes );

        if (!NT_SUCCESS( Status )) {

            return( FALSE );
        }

        Status = ObReferenceObjectByHandle( RootDirectoryHandle,
                                            0,
                                            ObpDirectoryObjectType,
                                            KernelMode,
                                            (PVOID *)&ObpRootDirectoryObject,
                                            NULL );

        if (!NT_SUCCESS( Status )) {

            return( FALSE );
        }

        Status = NtClose( RootDirectoryHandle );

        if (!NT_SUCCESS( Status )) {

            return( FALSE );
        }

        //
        //  Create a directory object for the directory of kernel objects
        //

        Status = RtlCreateSecurityDescriptor (&SecurityDescriptor,
                                              SECURITY_DESCRIPTOR_REVISION);

        if (!NT_SUCCESS (Status)) {
            return( FALSE );
        }

        DaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) * 3 +
                                RtlLengthSid (SeLocalSystemSid) +
                                RtlLengthSid(SeAliasAdminsSid) +
                                RtlLengthSid (SeWorldSid);

        Dacl = ExAllocatePoolWithTag (PagedPool, DaclLength, 'lcaD');

        if (Dacl == NULL) {
            return( FALSE );
        }


        //
        // Create the SD for the the well-known directories
        //

        Status = RtlCreateAcl (Dacl, DaclLength, ACL_REVISION);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Dacl);
            return( FALSE );
        }

        Status = RtlAddAccessAllowedAce (Dacl,
                                         ACL_REVISION,
                                         DIRECTORY_QUERY | DIRECTORY_TRAVERSE | READ_CONTROL,
                                         SeWorldSid);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Dacl);
            return( FALSE );
        }

        Status = RtlAddAccessAllowedAce (Dacl,
                                         ACL_REVISION,
                                         DIRECTORY_ALL_ACCESS,
                                         SeAliasAdminsSid);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Dacl);
            return( FALSE );
        }

        Status = RtlAddAccessAllowedAce (Dacl,
                                         ACL_REVISION,
                                         DIRECTORY_ALL_ACCESS,
                                         SeLocalSystemSid);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Dacl);
            return( FALSE );
        }

        Status = RtlSetDaclSecurityDescriptor (&SecurityDescriptor,
                                               TRUE,
                                               Dacl,
                                               FALSE);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Dacl);
            return( FALSE );
        }
      
        RtlInitUnicodeString( &TypeDirectoryName, L"\\KernelObjects" );

        InitializeObjectAttributes( &ObjectAttributes,
                                    &TypeDirectoryName,
                                    OBJ_CASE_INSENSITIVE |
                                    OBJ_PERMANENT,
                                    NULL,
                                    &SecurityDescriptor );

        Status = NtCreateDirectoryObject( &TypeDirectoryHandle,
                                          DIRECTORY_ALL_ACCESS,
                                          &ObjectAttributes );

        if (!NT_SUCCESS( Status )) {

            return( FALSE );
        }

        Status = NtClose( TypeDirectoryHandle );

        if (!NT_SUCCESS( Status )) {

            return( FALSE );
        }

        //
        //  Create a directory object for the directory of object types
        //

        RtlInitUnicodeString( &TypeDirectoryName, L"\\ObjectTypes" );

        InitializeObjectAttributes( &ObjectAttributes,
                                    &TypeDirectoryName,
                                    OBJ_CASE_INSENSITIVE |
                                    OBJ_PERMANENT,
                                    NULL,
                                    NULL );

        Status = NtCreateDirectoryObject( &TypeDirectoryHandle,
                                          DIRECTORY_ALL_ACCESS,
                                          &ObjectAttributes );

        if (!NT_SUCCESS( Status )) {

            return( FALSE );
        }

        Status = ObReferenceObjectByHandle( TypeDirectoryHandle,
                                            0,
                                            ObpDirectoryObjectType,
                                            KernelMode,
                                            (PVOID *)&ObpTypeDirectoryObject,
                                            NULL );

        if (!NT_SUCCESS( Status )) {

            return( FALSE );
        }

        Status = NtClose( TypeDirectoryHandle );

        if (!NT_SUCCESS( Status )) {

            return( FALSE );
        }

        //
        //  For every object type that has already been created we will
        //  insert it in the type directory.  We do this looking down the
        //  linked list of type objects and for every one that has a name
        //  and isn't already in a directory we'll look the name up and
        //  then put it in the directory.  Be sure to skip the first
        //  entry in the type object types lists.
        //

        ObpInitializeLookupContext( &LookupContext );
        ObpLockLookupContext ( &LookupContext, ObpTypeDirectoryObject );

        Head = &ObpTypeObjectType->TypeList;
        Next = Head->Flink;

        while (Next != Head) {

            //
            //  Right after the creator info is the object header.  Get
            //  the object header and then see if there is a name.
            //

            CreatorInfo = CONTAINING_RECORD( Next,
                                             OBJECT_HEADER_CREATOR_INFO,
                                             TypeList );

            ObjectTypeHeader = (POBJECT_HEADER)(CreatorInfo+1);

            NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectTypeHeader );

            //
            //  Check if we have a name and we're not in a directory
            //


            if ((NameInfo != NULL) && (NameInfo->Directory == NULL)) {

                if (!ObpLookupDirectoryEntry( ObpTypeDirectoryObject,
                                              &NameInfo->Name,
                                              OBJ_CASE_INSENSITIVE,
                                              FALSE,
                                              &LookupContext)) {

                    ObpInsertDirectoryEntry( ObpTypeDirectoryObject,
                                             &LookupContext,
                                             ObjectTypeHeader );
                }
            }

            Next = Next->Flink;
        }
        
        ObpReleaseLookupContext(&LookupContext);

        //
        //  Create \DosDevices object directory for drive letters and Win32 device names
        //

        Status = ObpCreateDosDevicesDirectory();

        if (!NT_SUCCESS( Status )) {

            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
ObDupHandleProcedure (
    PEPROCESS Process,
    PHANDLE_TABLE OldObjectTable,
    PHANDLE_TABLE_ENTRY OldObjectTableEntry,
    PHANDLE_TABLE_ENTRY ObjectTableEntry
    )

/*++

Routine Description:

    This is the worker routine for ExDupHandleTable and
    is invoked via ObInitProcess.

Arguments:

    Process - Supplies a pointer to the new process

    HandleTable - Old handle table we are duplicating

    ObjectTableEntry - Supplies a pointer to the newly
        created handle table entry

Return Value:

    TRUE if the item can be inserted in the new table
        and FALSE otherwise

--*/

{
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    PVOID Object;
    ACCESS_STATE AccessState;

    //
    //  If the object table should not be inherited then return false
    //
    if (!(ObjectTableEntry->ObAttributes & OBJ_INHERIT)) {

        ExUnlockHandleTableEntry (OldObjectTable, OldObjectTableEntry);
        return( FALSE );
    }

    //
    //  Get a pointer to the object header and body
    //

    ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

    Object = &ObjectHeader->Body;

    //
    //  Increment the pointer count to the object before we unlock the old entry
    //

    ObpIncrPointerCount (ObjectHeader);

    ExUnlockHandleTableEntry (OldObjectTable, OldObjectTableEntry);

    //
    //  If we are tracing the call stacks for cached security indices then
    //  we have a translation to do.  Otherwise the table entry contains
    //  straight away the granted access mask.
    //

#if i386

    if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

        AccessState.PreviouslyGrantedAccess = ObpTranslateGrantedAccessIndex( ObjectTableEntry->GrantedAccessIndex );

    } else {

        AccessState.PreviouslyGrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);
    }

#else

    AccessState.PreviouslyGrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);

#endif // i386 

    //
    //  Increment the handle count on the object because we've just added
    //  another handle to it.
    //

    Status = ObpIncrementHandleCount( ObInheritHandle,
                                      Process,
                                      Object,
                                      ObjectHeader->Type,
                                      &AccessState,
                                      KernelMode,
                                      0 );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject (Object);
        return( FALSE );
    }


    return( TRUE );
}


BOOLEAN
ObAuditInheritedHandleProcedure (
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE HandleId,
    IN PVOID EnumParameter
    )

/*++

Routine Description:

    ExEnumHandleTable worker routine to generate audits when handles are
    inherited.  An audit is generated if the handle attributes indicate
    that the handle is to be audited on close.

Arguments:

    ObjectTableEntry - Points to the handle table entry of interest.

    HandleId - Supplies the handle.

    EnumParameter - Supplies information about the source and target processes.

Return Value:

    FALSE, which tells ExEnumHandleTable to continue iterating through the
    handle table.

--*/

{
    PSE_PROCESS_AUDIT_INFO ProcessAuditInfo = EnumParameter;

    //
    //  Check if we have to do an audit
    //

    if (!(ObjectTableEntry->ObAttributes & OBJ_AUDIT_OBJECT_CLOSE)) {

        return( FALSE );
    }

    //
    //  Do the audit then return for more
    //

    SeAuditHandleDuplication( HandleId,
                              HandleId,
                              ProcessAuditInfo->Parent,
                              ProcessAuditInfo->Process );

    return( FALSE );
}



NTSTATUS
ObInitProcess (
    PEPROCESS ParentProcess OPTIONAL,
    PEPROCESS NewProcess
    )

/*++

Routine Description:

    This function initializes a process object table.  If the ParentProcess
    is specified, then all object handles with the OBJ_INHERIT attribute are
    copied from the parent object table to the new process' object table.
    The HandleCount field of each object copied is incremented by one.  Both
    object table mutexes remained locked for the duration of the copy
    operation.

Arguments:

    ParentProcess - optional pointer to a process object that is the
        parent process to inherit object handles from.

    NewProcess - pointer to the process object being initialized.

Return Value:

    Status code.

    The following errors can occur:

    - insufficient memory
    - STATUS_PROCESS_IS_TERMINATING if the parent process is terminating

--*/

{
    PHANDLE_TABLE OldObjectTable;
    PHANDLE_TABLE NewObjectTable;
    SE_PROCESS_AUDIT_INFO ProcessAuditInfo;

    //
    //  If we have a parent process then we need to lock it down
    //  check that it is not going away and then make a copy
    //  of its handle table.  If there isn't a parent then
    //  we'll start with an empty handle table.
    //

    if (ARGUMENT_PRESENT( ParentProcess )) {

        OldObjectTable = ObReferenceProcessHandleTable (ParentProcess);

        if ( !OldObjectTable ) {

            return STATUS_PROCESS_IS_TERMINATING;
        }

        NewObjectTable = ExDupHandleTable( NewProcess,
                                           OldObjectTable,
                                           ObDupHandleProcedure,
                                           OBJ_INHERIT );

    } else {

        OldObjectTable = NULL;
        NewObjectTable = ExCreateHandleTable( NewProcess );
    }

    //
    //  Check that we really have a new handle table otherwise
    //  we must be out of resources
    //

    if ( NewObjectTable ) {

        //
        //  Set the new processes object table and if we are
        //  auditing then enumerate the new table calling
        //  the audit procedure
        //

        NewProcess->ObjectTable = NewObjectTable;

        if ( SeDetailedAuditingWithToken( NULL ) ) {

            ProcessAuditInfo.Process = NewProcess;
            ProcessAuditInfo.Parent  = ParentProcess;

            ExEnumHandleTable( NewObjectTable,
                               ObAuditInheritedHandleProcedure,
                               (PVOID)&ProcessAuditInfo,
                               (PHANDLE)NULL );
        }

        //
        //  Free the old table if it exists and then
        //  return to our caller
        //

        if ( OldObjectTable ) {

            ObDereferenceProcessHandleTable( ParentProcess );
        }

        return (STATUS_SUCCESS);

    } else {

        //
        //  We're out of resources to null out the new object table field,
        //  unlock the old object table, and tell our caller that this
        //  didn't work
        //

        NewProcess->ObjectTable = NULL;

        if ( OldObjectTable ) {

            ObDereferenceProcessHandleTable( ParentProcess );
        }

        return (STATUS_INSUFFICIENT_RESOURCES);
    }
}


VOID
ObInitProcess2 (
    PEPROCESS NewProcess
    )

/*++

Routine Description:

    This function is called after an image file has been mapped into the address
    space of a newly created process.  Allows the object manager to set LIFO/FIFO
    ordering for handle allocation based on the SubSystemVersion number in the
    image.

Arguments:

    NewProcess - pointer to the process object being initialized.

Return Value:

    None.

--*/

{
    //
    //  Set LIFO ordering of handles for images <= SubSystemVersion 3.50
    //

    if (NewProcess->ObjectTable) {

        ExSetHandleTableOrder( NewProcess->ObjectTable, (BOOLEAN)(NewProcess->SubSystemVersion <= 0x332) );
    }

    return;
}


VOID
ObDestroyHandleProcedure (
    IN HANDLE HandleIndex
    )

/*++

Routine Description:

    This function is used to close a handle but takes as input a
    handle table index that it first translates to an handle
    before calling close.  Note that the handle index is really
    just the offset within the handle table entries.

Arguments:

    HandleIndex - Supplies a handle index for the handle being closed.

Return Value:

    None.

--*/

{
    ZwClose( HandleIndex );

    return;
}

BOOLEAN
ObpCloseHandleProcedure (
    IN PHANDLE_TABLE_ENTRY HandleTableEntry,
    IN HANDLE Handle,
    IN PVOID EnumParameter
    )
/*++

Routine Description:

    This function is used to close all the handles in a table

Arguments:

    HandleTableEntry - Current handle entry
    Handle - Handle for the entry
    EnumParameter - Sweep context, table and mode

Return Value:

    None.

--*/

{
    POBP_SWEEP_CONTEXT SweepContext;

    SweepContext = EnumParameter;
    ObpCloseHandleTableEntry (SweepContext->HandleTable,
                              HandleTableEntry,
                              Handle,
                              SweepContext->PreviousMode,
                              TRUE);
    return TRUE;
}

VOID
ObClearProcessHandleTable (
    PEPROCESS Process
    )
/*++

Routine Description:

    This function marks the process handle table for deletion and clears out all the handles.

Arguments:

    Process - Pointer to the process that is to be acted on.

--*/

{
    PHANDLE_TABLE ObjectTable;
    BOOLEAN AttachedToProcess = FALSE;
    KAPC_STATE ApcState;
    PETHREAD CurrentThread;
    OBP_SWEEP_CONTEXT SweepContext;

    ObjectTable = ObReferenceProcessHandleTable (Process);

    if (ObjectTable == NULL) {
        return;
    }


    CurrentThread = PsGetCurrentThread ();
    if (PsGetCurrentProcessByThread(CurrentThread) != Process) {
        KeStackAttachProcess (&Process->Pcb, &ApcState);
        AttachedToProcess = TRUE;
    }

    KeEnterCriticalRegionThread(&CurrentThread->Tcb);
    //
    // Close all the handles
    //
    SweepContext.PreviousMode = UserMode;
    SweepContext.HandleTable = ObjectTable;

    ExSweepHandleTable (ObjectTable,
                        ObpCloseHandleProcedure,
                        &SweepContext);

    KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

    if (AttachedToProcess == TRUE) {
        KeUnstackDetachProcess (&ApcState);
    }

    ObDereferenceProcessHandleTable (Process);
    return;
}


VOID
ObKillProcess (
    PEPROCESS Process
    )
/*++

Routine Description:

    This function is called whenever a process is destroyed.  It loops over
    the process' object table and closes all the handles.

Arguments:

    Process - Pointer to the process that is being destroyed.

Return Value:

    None.

--*/

{
    PHANDLE_TABLE ObjectTable;
    BOOLEAN PreviousIOHardError;
    PKTHREAD CurrentThread;
    OBP_SWEEP_CONTEXT SweepContext;

    PAGED_CODE();

    ObpValidateIrql( "ObKillProcess" );

    //
    // Wait for any cross process references to finish
    //
    ExWaitForRundownProtectionRelease (&Process->RundownProtect);
    //
    // This routine gets recalled multiple times for the same object so just mark the object so future waits
    // work ok.
    //
    ExRundownCompleted (&Process->RundownProtect);

    //
    //  If the process does NOT have an object table, return
    //

    ObjectTable = Process->ObjectTable;

    if (ObjectTable != NULL) {

        PreviousIOHardError = IoSetThreadHardErrorMode(FALSE);

        //
        //  For each valid entry in the object table, close the handle
        //  that points to that entry.
        //

        //
        // Close all the handles
        //

        CurrentThread = KeGetCurrentThread ();

        KeEnterCriticalRegionThread(CurrentThread);

        SweepContext.PreviousMode = KernelMode;
        SweepContext.HandleTable = ObjectTable;

        ExSweepHandleTable (ObjectTable,
                            ObpCloseHandleProcedure,
                            &SweepContext);

        ASSERT (ObjectTable->HandleCount == 0);

        KeLeaveCriticalRegionThread(CurrentThread);

        IoSetThreadHardErrorMode( PreviousIOHardError );


        Process->ObjectTable = NULL;

        ExDestroyHandleTable( ObjectTable, NULL );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  The following structure is only used by the enumeration routine
//  and the callback.  It provides context for the comparison of
//  the objects.
//

typedef struct _OBP_FIND_HANDLE_DATA {

    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    POBJECT_HANDLE_INFORMATION HandleInformation;

} OBP_FIND_HANDLE_DATA, *POBP_FIND_HANDLE_DATA;

BOOLEAN
ObpEnumFindHandleProcedure (
    PHANDLE_TABLE_ENTRY ObjectTableEntry,
    HANDLE HandleId,
    PVOID EnumParameter
    )

/*++

Routine Description:

    Call back routine when enumerating an object table to find a handle
    for a particular object

Arguments:

    HandleTableEntry - Supplies a pointer to the handle table entry
        being examined.

    HandleId - Supplies the actual handle value for the preceding entry

    EnumParameter - Supplies context for the matching.

Return Value:

    Returns TRUE if a match is found and the enumeration should stop.  Returns FALSE
    otherwise, so the enumeration will continue.

--*/

{
    POBJECT_HEADER ObjectHeader;
    ACCESS_MASK GrantedAccess;
    ULONG HandleAttributes;
    POBP_FIND_HANDLE_DATA MatchCriteria = EnumParameter;

    UNREFERENCED_PARAMETER (HandleId);

    //
    //  Get the object header from the table entry and see if
    //  object types and headers match if specified.
    //

    ObjectHeader = (POBJECT_HEADER)((ULONG_PTR)ObjectTableEntry->Object & ~OBJ_HANDLE_ATTRIBUTES);

    if ((MatchCriteria->ObjectHeader != NULL) &&
        (MatchCriteria->ObjectHeader != ObjectHeader)) {

        return FALSE;
    }

    if ((MatchCriteria->ObjectType != NULL) &&
        (MatchCriteria->ObjectType != ObjectHeader->Type)) {

        return FALSE;
    }

    //
    //  Check if we have handle information that we need to compare
    //

    if (ARGUMENT_PRESENT( MatchCriteria->HandleInformation )) {

        //
        //  If we are tracing the call stacks for cached security indices then
        //  we have a translation to do.  Otherwise the table entry contains
        //  straight away the granted access mask.
        //

#if i386 

        if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

            GrantedAccess = ObpTranslateGrantedAccessIndex( ObjectTableEntry->GrantedAccessIndex );

        } else {

            GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);
        }
#else

        GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);

#endif // i386

        //
        //  Get the handle attributes from table entry and see if the
        //  fields match.  If they do not match we will return false to
        //  continue the search.
        //

        HandleAttributes = ObpGetHandleAttributes(ObjectTableEntry);

        if (MatchCriteria->HandleInformation->HandleAttributes != HandleAttributes ||
            MatchCriteria->HandleInformation->GrantedAccess != GrantedAccess ) {

            return FALSE;
        }
    }

    //
    //  We found something that matches our criteria so return true to
    //  our caller to stop the enumeration
    //

    return TRUE;
}


BOOLEAN
ObFindHandleForObject (
    __in PEPROCESS Process,
    __in_opt PVOID Object OPTIONAL,
    __in_opt POBJECT_TYPE ObjectType OPTIONAL,
    __in_opt POBJECT_HANDLE_INFORMATION HandleInformation,
    __out PHANDLE Handle
    )

/*++

Routine Description:

    This routine searches the handle table for the specified process,
    looking for a handle table entry that matches the passed parameters.
    If an an Object pointer is specified it must match.  If an
    ObjectType is specified it must match.  If HandleInformation is
    specified, then both the HandleAttributes and GrantedAccess mask
    must match.  If all three match parameters are NULL, then will
    match the first allocated handle for the specified process that
    matches the specified object pointer.

Arguments:

    Process - Specifies the process whose object table is to be searched.

    Object - Specifies the object pointer to look for.

    ObjectType - Specifies the object type to look for.

    HandleInformation - Specifies additional match criteria to look for.

    Handle - Specifies the location to receive the handle value whose handle
        entry matches the supplied object pointer and optional match criteria.

Return Value:

    TRUE if a match was found and FALSE otherwise.

--*/

{
    PHANDLE_TABLE ObjectTable;
    OBP_FIND_HANDLE_DATA EnumParameter;
    BOOLEAN Result;

    Result = FALSE;

    //
    //  Lock the object object name space
    //

    ObjectTable = ObReferenceProcessHandleTable (Process);

    //
    //  We only do the work if the process has an object table meaning
    //  it isn't going away
    //

    if (ObjectTable != NULL) {

        //
        //  Set the match parameters that our caller supplied
        //

        if (ARGUMENT_PRESENT( Object )) {

            EnumParameter.ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

        } else {

            EnumParameter.ObjectHeader = NULL;
        }

        EnumParameter.ObjectType = ObjectType;
        EnumParameter.HandleInformation = HandleInformation;

        //
        //  Call the routine the enumerate the object table, this will
        //  return true if we get match.  The enumeration routine really
        //  returns a index into the object table entries we need to
        //  translate it to a real handle before returning.
        //

        if (ExEnumHandleTable( ObjectTable,
                               ObpEnumFindHandleProcedure,
                               &EnumParameter,
                               Handle )) {

            Result = TRUE;
        }

        ObDereferenceProcessHandleTable( Process );
    }

    return Result;
}


//
//  Local support routine
//

NTSTATUS
ObpCreateDosDevicesDirectory (
    VOID
    )

/*++

Routine Description:

    This routine creates the directory object for the dos devices and sets
    the device map for the system process.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error

--*/

{
    NTSTATUS Status;
    UNICODE_STRING NameString;
    UNICODE_STRING RootNameString;
    UNICODE_STRING TargetString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE DirectoryHandle;
    HANDLE SymbolicLinkHandle;
    SECURITY_DESCRIPTOR DosDevicesSD;

    //
    // Determine if LUID device maps are enabled or disabled
    // Store the result in ObpLUIDDeviceMapsEnabled
    //     0 - LUID device maps are disabled
    //     1 - LUID device maps are enabled
    //
    if ((ObpProtectionMode == 0) || (ObpLUIDDeviceMapsDisabled != 0)) {
        ObpLUIDDeviceMapsEnabled = 0;
    }
    else {
        ObpLUIDDeviceMapsEnabled = 1;
    }

    //
    //  Create the security descriptor to use for the \?? directory
    //

    Status = ObpGetDosDevicesProtection( &DosDevicesSD );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Create the root directory object for the global \?? directory.
    //

    RtlInitUnicodeString( &RootNameString, ObpGlobalDosDevicesShortName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &RootNameString,
                                OBJ_PERMANENT,
                                (HANDLE) NULL,
                                &DosDevicesSD );

    Status = NtCreateDirectoryObject( &DirectoryHandle,
                                      DIRECTORY_ALL_ACCESS,
                                      &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Create a device map that will control this directory.  It will be
    //  stored in the each EPROCESS for use by ObpLookupObjectName when
    //  translating names that begin with \??\
    //  With LUID device maps, the device map is stored in the each EPROCESS
    //  upon the first reference to the device map, and the EPROCESS
    //  device map field is cleared when the EPROCESS access token is set.
    //

    Status = ObSetDeviceMap( NULL, DirectoryHandle );


    //
    //  Now create a symbolic link, \??\GLOBALROOT, that points to \
    //  WorkStation service needs some mechanism to access a session specific
    //  DosDevicesDirectory. DosPathToSessionPath API will take a DosPath
    //  e.g (C:) and convert it into session specific path
    //  (e.g GLOBALROOT\Sessions\6\DosDevices\C:). The GLOBALROOT symbolic
    //  link is used to escape out of the current process's DosDevices directory
    //

    RtlInitUnicodeString( &NameString, L"GLOBALROOT" );
    RtlInitUnicodeString( &TargetString, L"" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &NameString,
                                OBJ_PERMANENT,
                                DirectoryHandle,
                                &DosDevicesSD );

    Status = NtCreateSymbolicLinkObject( &SymbolicLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &TargetString );

    if (NT_SUCCESS( Status )) {

        NtClose( SymbolicLinkHandle );
    }

    //
    //  Create a symbolic link, \??\Global, that points to the global \??
    //  Drivers loaded dynamically create the symbolic link in the global
    //  DosDevices directory. User mode components need some way to access this
    //  symbolic link in the global dosdevices directory. The Global symbolic
    //  link is used to escape out of the current sessions's DosDevices directory
    //  and use the global dosdevices directory. e.g CreateFile("\\\\.\\Global\\NMDev"..);
    //

    RtlInitUnicodeString( &NameString, L"Global" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &NameString,
                                OBJ_PERMANENT,
                                DirectoryHandle,
                                &DosDevicesSD );

    Status = NtCreateSymbolicLinkObject( &SymbolicLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &RootNameString );

    if (NT_SUCCESS( Status )) {

        NtClose( SymbolicLinkHandle );
    }


    NtClose( DirectoryHandle );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Now create a symbolic link, \DosDevices, that points to \??
    //  for backwards compatibility with old drivers that use the old
    //  name.
    //

    RtlInitUnicodeString( &RootNameString, (PWCHAR)&ObpDosDevicesShortNameRoot );

    RtlCreateUnicodeString( &NameString, L"\\DosDevices" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &NameString,
                                OBJ_PERMANENT,
                                (HANDLE) NULL,
                                &DosDevicesSD );

    Status = NtCreateSymbolicLinkObject( &SymbolicLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &RootNameString );

    if (NT_SUCCESS( Status )) {

        NtClose( SymbolicLinkHandle );
    }

    //
    //  All done with the security descriptor for \??
    //

    ObpFreeDosDevicesProtection( &DosDevicesSD );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
ObpGetDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine builds a security descriptor for use in creating
    the \DosDevices object directory.  The protection of \DosDevices
    must establish inheritable protection which will dictate how
    dos devices created via the DefineDosDevice() and
    IoCreateUnprotectedSymbolicLink() apis can be managed.

    The protection assigned is dependent upon an administrable registry
    key:

        Key: \hkey_local_machine\System\CurrentControlSet\Control\Session Manager
        Value: [REG_DWORD] ProtectionMode

    If this value is 0x1, then

            Administrators may control all Dos devices,
            Anyone may create new Dos devices (such as net drives
                or additional printers),
            Anyone may use any Dos device,
            The creator of a Dos device may delete it.
            Note that this protects system-defined LPTs and COMs so that only
                administrators may redirect them.  However, anyone may add
                additional printers and direct them to wherever they would
                like.

           This is achieved with the following protection for the DosDevices
           Directory object:

                    Grant:  World:   Execute | Read         (No Inherit)
                    Grant:  System:  All Access             (No Inherit)
                    Grant:  World:   Execute                (Inherit Only)
                    Grant:  Admins:  All Access             (Inherit Only)
                    Grant:  System:  All Access             (Inherit Only)
                    Grant:  Owner:   All Access             (Inherit Only)

    If this value is 0x0, or not present, then

            Administrators may control all Dos devices,
            Anyone may create new Dos devices (such as net drives
                or additional printers),
            Anyone may use any Dos device,
            Anyone may delete Dos devices created with either DefineDosDevice()
                or IoCreateUnprotectedSymbolicLink().  This is how network drives
                and LPTs are created (but not COMs).

           This is achieved with the following protection for the DosDevices
           Directory object:

                    Grant:  World:   Execute | Read | Write (No Inherit)
                    Grant:  System:  All Access             (No Inherit)
                    Grant:  World:   All Access             (Inherit Only)


Arguments:

    SecurityDescriptor - The address of a security descriptor to be
        initialized and filled in.  When this security descriptor is no
        longer needed, you should call ObpFreeDosDevicesProtection() to
        free the protection information.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_NO_MEMORY - not enough memory


--*/

{
    NTSTATUS Status;
    ULONG aceIndex, aclLength;
    PACL dacl;
    PACE_HEADER ace;
    ACCESS_MASK accessMask;

    UCHAR inheritOnlyFlags = (OBJECT_INHERIT_ACE    |
                              CONTAINER_INHERIT_ACE |
                              INHERIT_ONLY_ACE
                             );

    //
    //  NOTE:  This routine expects the value of ObpProtectionMode to have been set
    //

    Status = RtlCreateSecurityDescriptor( SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );

    ASSERT( NT_SUCCESS( Status ) );

    if (ObpProtectionMode & 0x00000001) {

        //
        //  Dacl:
        //          Grant:  World:   Execute | Read         (No Inherit)
        //          Grant:  System:  All Access             (No Inherit)
        //          Grant:  World:   Execute                (Inherit Only)
        //          Grant:  Admins:  All Access             (Inherit Only)
        //          Grant:  System:  All Access             (Inherit Only)
        //          Grant:  Owner:   All Access             (Inherit Only)
        //

        aclLength = sizeof( ACL )                           +
                    6 * sizeof( ACCESS_ALLOWED_ACE )        +
                    (2*RtlLengthSid( SeWorldSid ))          +
                    (2*RtlLengthSid( SeLocalSystemSid ))    +
                    RtlLengthSid( SeAliasAdminsSid )        +
                    RtlLengthSid( SeCreatorOwnerSid );

        dacl = (PACL)ExAllocatePool(PagedPool, aclLength );

        if (dacl == NULL) {

            return STATUS_NO_MEMORY;
        }

        Status = RtlCreateAcl( dacl, aclLength, ACL_REVISION2);
        ASSERT( NT_SUCCESS( Status ) );

        //
        //  Non-inheritable ACEs first
        //      World
        //      System
        //

        aceIndex = 0;
        accessMask = (GENERIC_READ | GENERIC_EXECUTE);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeWorldSid );
        ASSERT( NT_SUCCESS( Status ) );
        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeLocalSystemSid );
        ASSERT( NT_SUCCESS( Status ) );

        //
        //  Inheritable ACEs at the end of the ACL
        //          World
        //          Admins
        //          System
        //          Owner
        //

        aceIndex++;
        accessMask = (GENERIC_EXECUTE);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeWorldSid );
        ASSERT( NT_SUCCESS( Status ) );
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        ASSERT( NT_SUCCESS( Status ) );
        ace->AceFlags |= inheritOnlyFlags;

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeAliasAdminsSid );
        ASSERT( NT_SUCCESS( Status ) );
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        ASSERT( NT_SUCCESS( Status ) );
        ace->AceFlags |= inheritOnlyFlags;

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeLocalSystemSid );
        ASSERT( NT_SUCCESS( Status ) );
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        ASSERT( NT_SUCCESS( Status ) );
        ace->AceFlags |= inheritOnlyFlags;

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeCreatorOwnerSid );
        ASSERT( NT_SUCCESS( Status ) );
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        ASSERT( NT_SUCCESS( Status ) );
        ace->AceFlags |= inheritOnlyFlags;

        Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                               TRUE,               //DaclPresent,
                                               dacl,               //Dacl
                                               FALSE );            //!DaclDefaulted

        ASSERT( NT_SUCCESS( Status ) );

    } else {

        //
        //  DACL:
        //          Grant:  World:   Execute | Read | Write (No Inherit)
        //          Grant:  System:  All Access             (No Inherit)
        //          Grant:  World:   All Access             (Inherit Only)
        //

        aclLength = sizeof( ACL )                           +
                    3 * sizeof( ACCESS_ALLOWED_ACE )        +
                    (2*RtlLengthSid( SeWorldSid ))          +
                    RtlLengthSid( SeLocalSystemSid );

        dacl = (PACL)ExAllocatePool(PagedPool, aclLength );

        if (dacl == NULL) {

            return STATUS_NO_MEMORY;
        }

        Status = RtlCreateAcl( dacl, aclLength, ACL_REVISION2);
        ASSERT( NT_SUCCESS( Status ) );

        //
        //  Non-inheritable ACEs first
        //      World
        //      System
        //

        aceIndex = 0;
        accessMask = (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeWorldSid );
        ASSERT( NT_SUCCESS( Status ) );

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeLocalSystemSid );
        ASSERT( NT_SUCCESS( Status ) );

        //
        //  Inheritable ACEs at the end of the ACL
        //          World
        //

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, SeWorldSid );
        ASSERT( NT_SUCCESS( Status ) );
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        ASSERT( NT_SUCCESS( Status ) );
        ace->AceFlags |= inheritOnlyFlags;

        Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                               TRUE,               //DaclPresent,
                                               dacl,               //Dacl
                                               FALSE );            //!DaclDefaulted

        ASSERT( NT_SUCCESS( Status ) );
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

VOID
ObpFreeDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine frees memory allocated via ObpGetDosDevicesProtection().

Arguments:

    SecurityDescriptor - The address of a security descriptor initialized by
        ObpGetDosDevicesProtection().

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PACL Dacl;
    BOOLEAN DaclPresent, Defaulted;

    Status = RtlGetDaclSecurityDescriptor ( SecurityDescriptor,
                                            &DaclPresent,
                                            &Dacl,
                                            &Defaulted );

    ASSERT( NT_SUCCESS( Status ) );
    ASSERT( DaclPresent );
    ASSERT( Dacl != NULL );

    ExFreePool( (PVOID)Dacl );
    
    return;
}

BOOLEAN
ObpShutdownCloseHandleProcedure (
    IN PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN HANDLE HandleId,
    IN PVOID EnumParameter
    )

/*++

Routine Description:

    ExEnumHandleTable worker routine will call this routine for each
    valid handle into the kernel table at shutdown

Arguments:

    ObjectTableEntry - Points to the handle table entry of interest.

    HandleId - Supplies the handle.

    EnumParameter - Supplies information about the source and target processes.

Return Value:

    FALSE, which tells ExEnumHandleTable to continue iterating through the
    handle table.

--*/

{

    POBJECT_HEADER ObjectHeader;
    PULONG         NumberOfOpenHandles;

#if !DBG
    UNREFERENCED_PARAMETER (HandleId);
#endif
    //
    //  Get the object header from the table entry and then copy over the information
    //

    ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

    //
    //  Dump the leak info for the checked build
    //

    KdPrint(("\tFound object %p (handle %08lx)\n",
              &ObjectHeader->Body,
              HandleId
            ));

    NumberOfOpenHandles = (PULONG)EnumParameter;
    ASSERT(NumberOfOpenHandles);

    ++*NumberOfOpenHandles;

    return( FALSE );
}

extern PLIST_ENTRY *ObsSecurityDescriptorCache;


//
//  Object manager shutdown routine
//

VOID
ObShutdownSystem (
    IN ULONG Phase
    )

/*++

Routine Description:

    This routine frees the objects created by the object manager.

Arguments:

Return Value:

    None.

--*/

{
    switch (Phase) {
    case 0:
    {
        ULONG                    Bucket,
                                 Depth,
                                 SymlinkHitDepth;
        POBJECT_TYPE             ObjectType;
        POBJECT_HEADER_NAME_INFO NameInfo;
#if DBG
        KIRQL                    SaveIrql;
#endif
        POBJECT_HEADER           ObjectHeader;
        POBJECT_DIRECTORY        Directory,
                                 DescentDirectory;
        POBJECT_DIRECTORY_ENTRY  OldDirectoryEntry,
                                *DirectoryEntryPtr;
        PVOID                    Object;

        Directory = ObpRootDirectoryObject;

        DescentDirectory = NULL;

        // The starting depth is completely arbitrary, but not using
        // zero as a valid depth lets us use it as a sentinel to
        // ensure we haven't over-decremented it, and as a check at
        // the end (where it should be one less than its starting value).
        Depth = 1;
        SymlinkHitDepth = 1;

        while (Directory) {

            ASSERT(Depth);

      restart_dir_walk:
            ASSERT(Directory);

            for (Bucket = 0;
                 Bucket < NUMBER_HASH_BUCKETS;
                 Bucket++) {

                DirectoryEntryPtr = Directory->HashBuckets + Bucket;
                while (*DirectoryEntryPtr) {
                    Object = (*DirectoryEntryPtr)->Object;
                    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
                    ObjectType = ObjectHeader->Type;
                    NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

                    if (DescentDirectory) {
                        // We're recovering from a descent; we want to
                        // iterate forward until we're past the
                        // directory which we were just processing.
                        if (Object == DescentDirectory) {
                            DescentDirectory = NULL;
                            if (SymlinkHitDepth > Depth) {
                                // We hit a symlink in that descent, which
                                // potentially rearranged the buckets in
                                // this chain; we need to rescan the
                                // entire chain.
                                DirectoryEntryPtr =
                                    Directory->HashBuckets + Bucket;
                                SymlinkHitDepth = Depth;
                                continue;
                            }
                        }

                        // Either we haven't found the descent dir
                        // yet, or we did (and set it to NULL, so
                        // we'll stop skipping things), and don't have
                        // to deal with a symlink readjustment --
                        // either way, march forward.

                        DirectoryEntryPtr =
                            &(*DirectoryEntryPtr)->ChainLink;

                        continue;
                    }

                    if (ObjectType == ObpTypeObjectType) {
                        // We'll clean these up later
                        // Keep going down the chain
                        DirectoryEntryPtr =
                            &(*DirectoryEntryPtr)->ChainLink;
                        continue;
                    } else if (ObjectType == ObpDirectoryObjectType) {
                        // Iteratively descend
                        Directory = Object;
                        Depth++;
                        goto restart_dir_walk;
                    } else {
                        // It's an object not related to Ob object
                        // management; mark it non-permanent, and if
                        // it doesn't have any handles, remove it from
                        // the directory (delete the name and
                        // dereference it once).

                        ObpLockObject( ObjectHeader );

                        ObjectHeader->Flags &= ~OB_FLAG_PERMANENT_OBJECT;

                        ObpUnlockObject( ObjectHeader );

                        if (ObjectHeader->HandleCount == 0) {
                            OldDirectoryEntry = *DirectoryEntryPtr;
                            *DirectoryEntryPtr = OldDirectoryEntry->ChainLink;
                            ExFreePool(OldDirectoryEntry);

                            if ( !ObjectType->TypeInfo.SecurityRequired ) {

                                ObpBeginTypeSpecificCallOut( SaveIrql );

                                (ObjectType->TypeInfo.SecurityProcedure)( Object,
                                                                          DeleteSecurityDescriptor,
                                                                          NULL,
                                                                          NULL,
                                                                          NULL,
                                                                          &ObjectHeader->SecurityDescriptor,
                                                                          ObjectType->TypeInfo.PoolType,
                                                                          NULL );

                                ObpEndTypeSpecificCallOut( SaveIrql, "Security", ObjectType, Object );
                            }

                            //
                            //  If this is a symbolic link object then we also need to
                            //  delete the symbolic link
                            //

                            if (ObjectType == ObpSymbolicLinkObjectType) {
                                SymlinkHitDepth = Depth;
                                ObpDeleteSymbolicLinkName( (POBJECT_SYMBOLIC_LINK)Object );
                                // Since ObpDeleteSymbolicLinkName may
                                // potentially rearrange our buckets,
                                // we need to rescan from the
                                // beginning of this hash chain.
                                DirectoryEntryPtr =
                                    Directory->HashBuckets + Bucket;
                            }

                            //
                            //  Free the name buffer and zero out the name data fields
                            //

                            ExFreePool( NameInfo->Name.Buffer );

                            NameInfo->Name.Buffer = NULL;
                            NameInfo->Name.Length = 0;
                            NameInfo->Name.MaximumLength = 0;
                            NameInfo->Directory = NULL;

                            ObDereferenceObject( Object );
                            ObDereferenceObject( Directory );
                        } else {
                            // Keep going down the chain
                            DirectoryEntryPtr = &(*DirectoryEntryPtr)->ChainLink;
                        }
                    }
                } // while *DirectoryObjectPtr
            } // loop over buckets

            // Well -- we're done with this directory.  We might have
            // been processing it as a child directory, though -- so
            // if it has a parent, we need to go back up to it, and
            // reset our iteration.

            Depth--;
            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Directory);
            NameInfo = OBJECT_HEADER_TO_NAME_INFO(ObjectHeader);

            // We always assign DescentDirectory and Directory here; if
            // the current directory does not have a parent (i.e. it's
            // the root), this will terminate the iteration.
            DescentDirectory = Directory;
            Directory = NameInfo->Directory;
        } // while (Directory)

        ASSERT(Depth == 0);

        break;
    } // Phase 0

    case 1:
    {
        ULONG NumberOfOpenSystemHandles = 0;

        //
        //  Iterate through the handle tables, and look for existing handles
        //

        KdPrint(("Scanning open system handles...\n"));
        ExEnumHandleTable ( PsInitialSystemProcess->ObjectTable,
                            ObpShutdownCloseHandleProcedure,
                            &NumberOfOpenSystemHandles,
                            NULL );

        ASSERT(MmNumberOfPagingFiles == 0);
        break;

    } // Phase 1

    default:
    {
        NTSTATUS Status;
        UNICODE_STRING RootNameString;
        PLIST_ENTRY Next, Head;
        POBJECT_HEADER_CREATOR_INFO CreatorInfo;
        POBJECT_HEADER  ObjectTypeHeader;
        PVOID Object;

        ASSERT(Phase == 2);

        //
        //  Free the SecurityDescriptor chche
        //

    //
    //  Remove all types from the object type directory
    //

        Head = &ObpTypeObjectType->TypeList;
        Next = Head->Flink;

        while (Next != Head) {

            PVOID Object;

            //
            //  Right after the creator info is the object header.  Get\
            //  the object header and then see if there is a name
            //

            CreatorInfo = CONTAINING_RECORD( Next,
                                             OBJECT_HEADER_CREATOR_INFO,
                                             TypeList );

            ObjectTypeHeader = (POBJECT_HEADER)(CreatorInfo+1);

            Object = &ObjectTypeHeader->Body;

            Next = Next->Flink;

            ObMakeTemporaryObject(Object);
        }


        RtlInitUnicodeString( &RootNameString, L"DosDevices" );

        Status = ObReferenceObjectByName( &RootNameString,
                                          OBJ_CASE_INSENSITIVE,
                                          0L,
                                          0,
                                          ObpSymbolicLinkObjectType,
                                          KernelMode,
                                          NULL,
                                          &Object
            );
        if ( NT_SUCCESS( Status ) ) {

            ObMakeTemporaryObject(Object);
            ObDereferenceObject( Object );
        }

        RtlInitUnicodeString( &RootNameString, L"Global" );

        Status = ObReferenceObjectByName( &RootNameString,
                                          OBJ_CASE_INSENSITIVE,
                                          0L,
                                          0,
                                          ObpSymbolicLinkObjectType,
                                          KernelMode,
                                          NULL,
                                          &Object
            );
        
        if ( NT_SUCCESS( Status ) ) {

            ObMakeTemporaryObject(Object);
            ObDereferenceObject( Object );
        }

        RtlInitUnicodeString( &RootNameString, L"GLOBALROOT" );

        Status = ObReferenceObjectByName( &RootNameString,
                                          OBJ_CASE_INSENSITIVE,
                                          0L,
                                          0,
                                          ObpSymbolicLinkObjectType,
                                          KernelMode,
                                          NULL,
                                          &Object
            );
        if ( NT_SUCCESS( Status ) ) {

            ObMakeTemporaryObject(Object);
            ObDereferenceObject( Object );
        }

        //
        //  Destroy the root directory
        //

        ObDereferenceObject( ObpRootDirectoryObject );

        //
        //  Destroy the ObpDirectoryObjectType object
        //

        ObDereferenceObject( ObpDirectoryObjectType );

        //
        //  Destroy the ObpSymbolicLinkObjectType
        //

        ObDereferenceObject( ObpSymbolicLinkObjectType );

        //
        //  Destroy the type directory object
        //

        ObDereferenceObject( ObpTypeDirectoryObject );

        //
        //  Destroy the ObpTypeObjectType
        //

        ObDereferenceObject( ObpTypeObjectType );

        //
        //  Free the ObpCachedGrantedAccesses pool
        //

#if i386 
        if (ObpCachedGrantedAccesses) {
            ExFreePool( ObpCachedGrantedAccesses );
        }
#endif // i386 

    } // default Phase (2)
    } // switch (Phase)
}


ULONG
ObGetSecurityMode (
    )
{
    return ObpObjectSecurityMode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obinsert.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obinsert.c

Abstract:

    Object instantiation API

--*/

#include "obp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ObInsertObject)
#endif


NTSTATUS
ObInsertObject (
    __in PVOID Object,
    __in_opt PACCESS_STATE AccessState,
    __in_opt ACCESS_MASK DesiredAccess,
    __in ULONG ObjectPointerBias,
    __out_opt PVOID *NewObject,
    __out_opt PHANDLE Handle
    )

/*++

Routine Description:

    This routine inserts an object into the current processes handle table.

    The Object header includes a pointer to a SecurityDescriptor passed in
    an object creation call.  This SecurityDescriptor is not assumed to have
    been captured.  This routine is responsible for making an appropriate
    SecurityDescriptor and removing the reference in the object header.

Arguments:

    Object - Supplies a pointer to the new object body

    AccessState - Optionally supplies the access state for the new
        handle

    DesiredAccess - Optionally supplies the desired access we want for the
        new handle

    ObjectPointerBias - Supplies a bias to apply for the pointer count for the
        object

    NewObject - Optionally receives the pointer to the new object that we've
        created a handle for

    Handle - Receives the new handle, If NULL then no handle is created.
             Objects that don't have handles created must be unnamed and
             have an object bias of zero.

Return Value:

    An appropriate NTSTATUS value.

--*/

{
    POBJECT_CREATE_INFORMATION ObjectCreateInfo;
    POBJECT_HEADER ObjectHeader;
    PUNICODE_STRING ObjectName;
    POBJECT_TYPE ObjectType;
    POBJECT_HEADER_NAME_INFO NameInfo;
    PSECURITY_DESCRIPTOR ParentDescriptor = NULL;
    PVOID InsertObject;
    HANDLE NewHandle;
    OB_OPEN_REASON OpenReason;
    NTSTATUS Status = STATUS_SUCCESS;
    ACCESS_STATE LocalAccessState;
    AUX_ACCESS_DATA AuxData;
    BOOLEAN SecurityDescriptorAllocated;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS ReturnStatus;
    PVOID DirObject = NULL;
    OBP_LOOKUP_CONTEXT LookupContext;

    PAGED_CODE();

    ObpValidateIrql("ObInsertObject");

    //
    //  Get the address of the object header, the object create information,
    //  the object type, and the address of the object name descriptor, if
    //  specified.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

#if DBG

    if ((ObjectHeader->Flags & OB_FLAG_NEW_OBJECT) == 0) {

        KdPrint(("OB: Attempting to insert existing object %08x\n", Object));
        KdBreakPoint();

        ObDereferenceObject(Object);

        return STATUS_INVALID_PARAMETER;
    }

#endif

    ObjectCreateInfo = ObjectHeader->ObjectCreateInfo;

    ObjectType = ObjectHeader->Type;

    NameInfo = ObpReferenceNameInfo( ObjectHeader );

    ObjectName = NULL;

    if ((NameInfo != NULL) && (NameInfo->Name.Buffer != NULL)) {

        ObjectName = &NameInfo->Name;
    }

    ASSERT (ARGUMENT_PRESENT (Handle) || (ObjectPointerBias == 0 && ObjectName == NULL &&
                                          ObjectType->TypeInfo.SecurityRequired && NewObject == NULL));

    //
    //  If security checks are not required and an object name is not
    //  specified, insert an unnamed object, biasing the count
    //  by one, dereference the bias, and return to our caller
    //

    PreviousMode = KeGetPreviousMode();

    if (!ObjectType->TypeInfo.SecurityRequired && (ObjectName == NULL)) {

        ObjectHeader->ObjectCreateInfo = NULL;

        *Handle = NULL;

        Status = ObpCreateUnnamedHandle( Object,
                                         DesiredAccess,
                                         1 + ObjectPointerBias,
                                         ObjectCreateInfo->Attributes,
                                         PreviousMode,
                                         NewObject,
                                         Handle );
        //
        //  Free the object creation information and dereference the object.
        //

        ObpFreeObjectCreateInformation(ObjectCreateInfo);

        ObpDereferenceNameInfo( NameInfo );
        ObDereferenceObject(Object);

        return Status;
    }

    //
    //  The object is either named or requires full security checks.  If the
    //  caller hasn't specified an access state then dummy up a local one
    //  using the requested desired access
    //

    if (!ARGUMENT_PRESENT(AccessState)) {

        AccessState = &LocalAccessState;

        Status = SeCreateAccessState( &LocalAccessState,
                                      &AuxData,
                                      DesiredAccess,
                                      &ObjectType->TypeInfo.GenericMapping );

        if (!NT_SUCCESS(Status)) {

            ObpDereferenceNameInfo( NameInfo );
            ObDereferenceObject(Object);

            return Status;
        }
    }

    AccessState->SecurityDescriptor = ObjectCreateInfo->SecurityDescriptor;

    //
    //  Check the desired access mask against the security descriptor
    //

    Status = ObpValidateAccessMask( AccessState );

    if (!NT_SUCCESS( Status )) {

        if (AccessState == &LocalAccessState) {

            SeDeleteAccessState( AccessState );
        }

        ObpDereferenceNameInfo( NameInfo );
        ObDereferenceObject(Object);

        if (AccessState == &LocalAccessState) {

            SeDeleteAccessState( AccessState );
        }

        return( Status );
    }

    //
    //  Set some local state variables
    //

    ObpInitializeLookupContext(&LookupContext);

    InsertObject = Object;
    OpenReason = ObCreateHandle;

    //
    //  Check if we have an object name.  If so then
    //  lookup the name
    //

    if (ObjectName != NULL) {

        Status = ObpLookupObjectName( ObjectCreateInfo->RootDirectory,
                                      ObjectName,
                                      ObjectCreateInfo->Attributes,
                                      ObjectType,
                                      (KPROCESSOR_MODE)(ObjectHeader->Flags & OB_FLAG_KERNEL_OBJECT
                                                            ? KernelMode : UserMode),
                                      ObjectCreateInfo->ParseContext,
                                      ObjectCreateInfo->SecurityQos,
                                      Object,
                                      AccessState,
                                      &LookupContext,
                                      &InsertObject );

        //
        //  We found the name and it is not the object we have as our input.
        //  So we cannot insert the object again so we'll return an
        //  appropriate status
        //

        if (NT_SUCCESS(Status) &&
            (InsertObject != NULL) &&
            (InsertObject != Object)) {

            OpenReason = ObOpenHandle;

            if (ObjectCreateInfo->Attributes & OBJ_OPENIF) {

                if (ObjectType != OBJECT_TO_OBJECT_HEADER(InsertObject)->Type) {

                    Status = STATUS_OBJECT_TYPE_MISMATCH;

                } else {

                    Status = STATUS_OBJECT_NAME_EXISTS;     // Warning only
                }

            } else {

                if (OBJECT_TO_OBJECT_HEADER(InsertObject)->Type == ObpSymbolicLinkObjectType) {

                     ObDereferenceObject(InsertObject);
                }
                
                Status = STATUS_OBJECT_NAME_COLLISION;
            }
        }

        //
        //  We did not find the name so we'll cleanup after ourselves
        //  and return to our caller
        //

        if (!NT_SUCCESS( Status )) {

            ObpReleaseLookupContext( &LookupContext );

            ObpDereferenceNameInfo( NameInfo );
            ObDereferenceObject( Object );

            //
            //  Free security information if we allocated it
            //

            if (AccessState == &LocalAccessState) {

                SeDeleteAccessState( AccessState );
            }

            return( Status );

        } else {

            //
            //  Otherwise we did locate the object name
            //
            //  If we just created a named symbolic link then call out to
            //  handle any Dos Device name semantics.
            //

            if (ObjectType == ObpSymbolicLinkObjectType) {

                ObpCreateSymbolicLinkName( (POBJECT_SYMBOLIC_LINK)InsertObject );
            }
        }
    }

    //
    //  If we are creating a new object, then we need assign security
    //  to it.  A pointer to the captured caller-proposed security
    //  descriptor is contained in the AccessState structure.  The
    //  SecurityDescriptor field in the object header must point to
    //  the final security descriptor, or to NULL if no security is
    //  to be assigned to the object.
    //

    if (InsertObject == Object) {

        //
        //  Only the following objects have security descriptors:
        //
        //       - Named Objects
        //       - Unnamed objects whose object-type information explicitly
        //         indicates a security descriptor is required.
        //

        if ((ObjectName != NULL) || ObjectType->TypeInfo.SecurityRequired) {

            //
            //  Get the parent's descriptor, if there is one...
            //

            if ((NameInfo != NULL) && (NameInfo->Directory != NULL)) {

                //
                //  This will allocate a block of memory and copy
                //  the parent's security descriptor into it, and
                //  return the pointer to the block.
                //
                //  Call ObReleaseObjectSecurity to free up this
                //  memory.
                //

                ObGetObjectSecurity( NameInfo->Directory,
                                     &ParentDescriptor,
                                     &SecurityDescriptorAllocated );
            }
            else {
                SecurityDescriptorAllocated = FALSE;
            }

            //
            //  Take the captured security descriptor in the AccessState,
            //  put it into the proper format, and call the object's
            //  security method to assign the new security descriptor to
            //  the new object.
            //

            Status = ObAssignSecurity( AccessState,
                                       ParentDescriptor,
                                       Object,
                                       ObjectType );

            if (ParentDescriptor != NULL) {

                ObReleaseObjectSecurity( ParentDescriptor,
                                         SecurityDescriptorAllocated );

            } else if (NT_SUCCESS( Status )) {

                SeReleaseSecurityDescriptor( ObjectCreateInfo->SecurityDescriptor,
                                             ObjectCreateInfo->ProbeMode,
                                             TRUE );

                ObjectCreateInfo->SecurityDescriptor = NULL;
                AccessState->SecurityDescriptor = NULL;
            }
        }

        if (!NT_SUCCESS( Status )) {

            //
            //  The attempt to assign the security descriptor to
            //  the object failed.
            //
            
            if (LookupContext.DirectoryLocked) {
                
                //
                //  If ObpLookupObjectName already inserted the 
                //  object into the directory we have to backup this
                //

                //
                //  Capture the object Directory 
                //

                DirObject = NameInfo->Directory;

                ObpDeleteDirectoryEntry( &LookupContext ); 
            }

            ObpReleaseLookupContext( &LookupContext );

            //
            //  If ObpLookupObjectName inserted the object into the directory
            //  it added a reference to the object and to its directory
            //  object. We should remove the extra-references
            //

            if (DirObject) {

                ObDereferenceObject( Object );
                ObDereferenceObject( DirObject );
            }

            //
            //  The first backout logic used ObpDeleteNameCheck
            //  which is wrong because the security descriptor for
            //  the object is not initialized. Actually  ObpDeleteNameCheck
            //  had no effect because the object was removed before from 
            //  the directory
            //

            ObpDereferenceNameInfo( NameInfo );
            ObDereferenceObject( Object );

            //
            //  Free security information if we allocated it
            //

            if (AccessState == &LocalAccessState) {

                SeDeleteAccessState( AccessState );
            }

            return( Status );
        }
    }

    ReturnStatus = Status;

    ObjectHeader->ObjectCreateInfo = NULL;

    //
    //  Create a named handle for the object with a pointer bias
    //  This call also will unlock the directory lock is necessary
    //  on return
    //

    if (ARGUMENT_PRESENT (Handle)) {

        Status = ObpCreateHandle( OpenReason,
                                  InsertObject,
                                  NULL,
                                  AccessState,
                                  1 + ObjectPointerBias,
                                  ObjectCreateInfo->Attributes,
                                  &LookupContext,
                                  PreviousMode,
                                  NewObject,
                                  &NewHandle );

        //
        //  If the insertion failed, the following dereference will cause
        //  the newly created object to be deallocated.
        //

        if (!NT_SUCCESS( Status )) {

            //
            //  Make the name reference go away if an error.
            //

            if (ObjectName != NULL) {

                ObpDeleteNameCheck( Object );
            }

            *Handle = NULL;

            ReturnStatus = Status;

        } else {
            *Handle = NewHandle;
        }

        ObpDereferenceNameInfo( NameInfo );

        ObDereferenceObject( Object );


    } else {

        BOOLEAN IsNewObject;

        //
        //  Charge the user quota for the object.
        //

        ObpLockObject( ObjectHeader );

        ReturnStatus = ObpChargeQuotaForObject( ObjectHeader, ObjectType, &IsNewObject );

        ObpUnlockObject( ObjectHeader );

        if (!NT_SUCCESS (ReturnStatus)) {
            ObDereferenceObject( Object );
        }

        //
        //  N.B. An object cannot be named if no Handle parameter is specified.
        //  The calls to ObpDereferenceNameInfo and ObpReleaseLookupContext are 
        //  not necessary in this path then.
        //
    }

    ObpFreeObjectCreateInformation( ObjectCreateInfo );

    //
    //  Free security information if we allocated it
    //

    if (AccessState == &LocalAccessState) {

        SeDeleteAccessState( AccessState );
    }

    return( ReturnStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obref.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obref.c

Abstract:

    Object open API

--*/

#include "obp.h"

#undef ObReferenceObjectByHandle

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,ObpInitStackTrace)
#pragma alloc_text(PAGE,ObOpenObjectByName)
#pragma alloc_text(PAGE,ObOpenObjectByPointer)
#pragma alloc_text(PAGE,ObReferenceObjectByHandle)
#pragma alloc_text(PAGE,ObpReferenceProcessObjectByHandle)
#pragma alloc_text(PAGE,ObReferenceObjectByName)
#pragma alloc_text(PAGE,ObReferenceFileObjectForWrite)
#pragma alloc_text(PAGE,ObpProcessRemoveObjectQueue)
#pragma alloc_text(PAGE,ObpRemoveObjectRoutine)
#pragma alloc_text(PAGE,ObpDeleteNameCheck)
#pragma alloc_text(PAGE,ObpAuditObjectAccess)
#pragma alloc_text(PAGE,ObIsObjectDeletionInline)
#pragma alloc_text(PAGE,ObAuditObjectAccess)
#endif

//
//
//  Stack Trace code
//
//
ULONG ObpTraceNoDeregister = 0;
WCHAR ObpTracePoolTagsBuffer[128] = { 0 };
ULONG ObpTracePoolTagsLength = sizeof(ObpTracePoolTagsBuffer);
ULONG ObpTracePoolTags[16];
BOOLEAN ObpTraceEnabled = FALSE;

#ifdef POOL_TAGGING

#define OBTRACE_OBJECTBUCKETS   401     // # of buckets in the object hash table (a prime)
#define OBTRACE_STACKS          14747   // max # of unique stack traces (a prime)
#define OBTRACE_STACKSPEROBJECT 32768   // max number of object references
#define OBTRACE_TRACEDEPTH      16      // depth of stack traces

//
//  The constants below are used by the !obtrace debugger extension
//

const ObpObjectBuckets   = OBTRACE_OBJECTBUCKETS;
const ObpMaxStacks       = OBTRACE_STACKS;
const ObpStacksPerObject = OBTRACE_STACKSPEROBJECT;
const ObpTraceDepth      = OBTRACE_TRACEDEPTH;

//
// Object reference stacktrace structure
//

typedef struct _OBJECT_REF_TRACE {
    PVOID StackTrace[OBTRACE_TRACEDEPTH];
} OBJECT_REF_TRACE, *POBJECT_REF_TRACE;


typedef struct _OBJECT_REF_STACK_INFO {
    USHORT Sequence;
    USHORT Index;
} OBJECT_REF_STACK_INFO, *POBJECT_REF_STACK_INFO;

//
// Object reference info structure
//

typedef struct _OBJECT_REF_INFO {
    POBJECT_HEADER ObjectHeader;
    PVOID NextRef;
    UCHAR ImageFileName[16];
    ULONG  NextPos;
    OBJECT_REF_STACK_INFO StackInfo[OBTRACE_STACKSPEROBJECT];
} OBJECT_REF_INFO, *POBJECT_REF_INFO;

//
// The stack hash table, and the object hash table
//

OBJECT_REF_TRACE *ObpStackTable = NULL;
POBJECT_REF_INFO *ObpObjectTable = NULL;

//
// Some statistics
//

ULONG ObpNumStackTraces;
ULONG ObpNumTracedObjects;
ULONG ObpStackSequence;

//
// Spin lock for object tracing
//

KSPIN_LOCK ObpStackTraceLock;

#define OBTRACE_HASHOBJECT(x) (((((ULONG)(ULONG_PTR)(&(x)->Body)) >> 4) & 0xfffff) % OBTRACE_OBJECTBUCKETS)

POBJECT_REF_INFO
ObpGetObjectRefInfo (
    POBJECT_HEADER ObjectHeader
    )

/*++

Routine Description:

    This routine returns a pointer to the OBJECT_REF_INFO for the
    specified object, or NULL, if it doesn't exist.

Arguments:

    ObjectHeader - Pointer to the object header

Return Value:

    The pointer to a OBJECT_REF_INFO object for the specified object.

--*/

{
    POBJECT_REF_INFO ObjectRefInfo = ObpObjectTable[OBTRACE_HASHOBJECT(ObjectHeader)];

    while (ObjectRefInfo && ObjectRefInfo->ObjectHeader != ObjectHeader) {

        ObjectRefInfo = (POBJECT_REF_INFO)ObjectRefInfo->NextRef;
    }

    return ObjectRefInfo;
}


ULONG
ObpGetTraceIndex (
    POBJECT_REF_TRACE Trace
    )

/*++

Routine Description:

    This routine returns the index of 'Trace' in the stack
    trace hash table (ObpStackTable).  If Trace does not exist
    in the table, it is added, and the new index is returned.

Arguments:

    Trace - Pointer to a stack trace to find in the table

Return Value:

    The index of Trace in ObpStackTable

--*/

{
    ULONG_PTR Value = 0;
    ULONG Index;
    PUSHORT Key;
    ULONG Hash;

    //
    // Determine the hash value for the stack trace
    //

    Key = (PUSHORT)Trace->StackTrace;
    for (Index = 0; Index < sizeof(Trace->StackTrace) / sizeof(*Key); Index += 2) {

        Value += Key[Index] ^ Key[Index + 1];
    }

    Hash = ((ULONG)Value) % OBTRACE_STACKS;

    //
    // Look up the trace at that index (linear probing)
    //

    while (ObpStackTable[Hash].StackTrace[0] != NULL &&
           RtlCompareMemory(&ObpStackTable[Hash], Trace, sizeof(OBJECT_REF_TRACE)) != sizeof(OBJECT_REF_TRACE)) {

        Hash = (Hash + 1) % OBTRACE_STACKS;
        if (Hash == ((ULONG)Value) % OBTRACE_STACKS) {

            return OBTRACE_STACKS;
        }
    }

    //
    // If the trace doesn't already exist in the table, add it.
    //

    if (ObpStackTable[Hash].StackTrace[0] == NULL) {

        RtlCopyMemory(&ObpStackTable[Hash], Trace, sizeof(OBJECT_REF_TRACE));
        ObpNumStackTraces++;
    }

    return Hash;
}


VOID
ObpInitStackTrace()

/*++

Routine Description:

    Initialize the ob ref/deref stack-tracing code.

Arguments:

Return Value:

--*/

{
    ULONG i,j;

    KeInitializeSpinLock( &ObpStackTraceLock );
    RtlZeroMemory(ObpTracePoolTags, sizeof(ObpTracePoolTags));
    ObpStackSequence = 0;
    ObpNumStackTraces = 0;
    ObpNumTracedObjects = 0;
    ObpTraceEnabled = FALSE;

    //
    // Loop through the ObpTracePoolTagsBuffer string, and convert it to
    // an array of pool tags.
    //
    // The string should be in the form "Tag1;Tag2;Tag3; ..."
    //

    for (i = 0; i < sizeof(ObpTracePoolTags) / sizeof(ULONG); i++) {
        for (j = 0; j < 4; j++) {
            ObpTracePoolTags[i] = (ObpTracePoolTags[i] << 8) | ObpTracePoolTagsBuffer[5*i+(3-j)];
        }
    }

    //
    // If object tracing was turned on via the registry key, then we
    // need to allocate memory for the tables.  If the memory allocations
    // fail, we turn off tracing by clearing the pool tag array.
    //

    if (ObpTracePoolTags[0] != 0) {

        ObpStackTable = ExAllocatePoolWithTag( NonPagedPool,
                                               OBTRACE_STACKS * sizeof(OBJECT_REF_TRACE),
                                               'TSbO' );

        if (ObpStackTable != NULL) {

            RtlZeroMemory(ObpStackTable, OBTRACE_STACKS * sizeof(OBJECT_REF_TRACE));

            ObpObjectTable = ExAllocatePoolWithTag( NonPagedPool,
                                                    OBTRACE_OBJECTBUCKETS * sizeof(POBJECT_REF_INFO),
                                                    'TSbO' );
            if (ObpObjectTable != NULL) {

                RtlZeroMemory(ObpObjectTable, OBTRACE_OBJECTBUCKETS * sizeof(POBJECT_REF_INFO));
                ObpTraceEnabled = TRUE;

            } else {

                ExFreePoolWithTag( ObpStackTable, 'TSbO' );
                ObpStackTable = NULL;
                RtlZeroMemory(ObpTracePoolTags, sizeof(ObpTracePoolTags));
            }

        } else {

            RtlZeroMemory(ObpTracePoolTags, sizeof(ObpTracePoolTags));
        }
    }
}


BOOLEAN
ObpIsObjectTraced (
    POBJECT_HEADER ObjectHeader
    )

/*++

Routine Description:

    This routine determines if an object should have its references
    and dereferences traced.

Arguments:

    ObjectHeader - The object to check

Return Value:

    TRUE, if the object should be traced, and FALSE, otherwise

--*/

{
    ULONG i;

    if (ObjectHeader != NULL) {

        //
        // Loop through the ObpTracePoolTags array, and return true if
        // the object type key matches one of them.
        //

        for (i = 0; i < sizeof(ObpTracePoolTags) / sizeof(ULONG); i++) {

            if (ObjectHeader->Type->Key == ObpTracePoolTags[i]) {

                return TRUE;
            }
        }
    }

    return FALSE;
}


VOID
ObpRegisterObject (
    POBJECT_HEADER ObjectHeader
    )

/*++

Routine Description:

    This routine is called once for each object that is created.
    It determines if the object should be traced, and if so, adds
    it to the hash table.

Arguments:

    ObjectHeader - The object to register

Return Value:

--*/

{
    KIRQL OldIrql;
    POBJECT_REF_INFO ObjectRefInfo = NULL;

    //
    // Are we tracing this object?
    //

    if (ObpIsObjectTraced( ObjectHeader )) {

        ExAcquireSpinLock( &ObpStackTraceLock, &OldIrql );

        ObjectRefInfo = ObpGetObjectRefInfo(ObjectHeader);

        if (ObjectRefInfo == NULL) {

            //
            // Allocate a new OBJECT_REF_INFO for the object
            //

            ObjectRefInfo = ExAllocatePoolWithTag( NonPagedPool,
                                                   sizeof(OBJECT_REF_INFO),
                                                   'TSbO' );

            if (ObjectRefInfo != NULL) {

                //
                // Place the object into the hash table (at the beginning of the bucket)
                //

                ObjectRefInfo->NextRef = ObpObjectTable[OBTRACE_HASHOBJECT(ObjectHeader)];
                ObpObjectTable[OBTRACE_HASHOBJECT(ObjectHeader)] = ObjectRefInfo;

            } else {

                DbgPrint( "ObpRegisterObject - ExAllocatePoolWithTag failed.\n" );
            }
        }

        if (ObjectRefInfo != NULL) {

            ObpNumTracedObjects++;

            //
            // Initialize the OBJECT_REF_INFO
            //

            ObjectRefInfo->ObjectHeader = ObjectHeader;
            RtlCopyMemory( ObjectRefInfo->ImageFileName,
                           PsGetCurrentProcess()->ImageFileName,
                           sizeof(ObjectRefInfo->ImageFileName) );
            ObjectRefInfo->NextPos = 0;
            RtlZeroMemory( ObjectRefInfo->StackInfo,
                           sizeof(ObjectRefInfo->StackInfo) );
        }

        ExReleaseSpinLock( &ObpStackTraceLock, OldIrql );
    }
}


VOID
ObpDeregisterObject (
    POBJECT_HEADER ObjectHeader
    )

/*++

Routine Description:

    This routine is called once for each object that is deleted.
    It determines if the object is traced, and if so, deletes
    it from the hash table.

Arguments:

    ObjectHeader - The object to deregister

Return Value:

--*/

{
    KIRQL OldIrql;
    POBJECT_REF_INFO ObjectRefInfo = NULL;

    //
    // Are we tracing this object?
    //

    if (ObpIsObjectTraced( ObjectHeader )) {

        ExAcquireSpinLock( &ObpStackTraceLock, &OldIrql );

        ObjectRefInfo = ObpObjectTable[OBTRACE_HASHOBJECT(ObjectHeader)];

        if (ObjectRefInfo != NULL) {

            //
            // Remove the entry from the list
            //

            if (ObjectRefInfo->ObjectHeader == ObjectHeader) {

                ObpObjectTable[OBTRACE_HASHOBJECT(ObjectHeader)] = ObjectRefInfo->NextRef;

            } else {

                POBJECT_REF_INFO PrevObjectRefInfo;
                do {
                    PrevObjectRefInfo = ObjectRefInfo;
                    ObjectRefInfo = ObjectRefInfo->NextRef;
                } while (ObjectRefInfo && (ObjectRefInfo->ObjectHeader != ObjectHeader));

                if (ObjectRefInfo && (ObjectRefInfo->ObjectHeader == ObjectHeader)) {

                    PrevObjectRefInfo->NextRef = ObjectRefInfo->NextRef;
                }
            }
        }

        //
        // Free the object we just removed from the list
        //

        if (ObjectRefInfo != NULL) {

            ExFreePoolWithTag( ObjectRefInfo, 'TSbO' );
        }

        ExReleaseSpinLock( &ObpStackTraceLock, OldIrql );
    }
}


VOID
ObpPushStackInfo (
    POBJECT_HEADER ObjectHeader,
    BOOLEAN IsRef
    )

/*++

Routine Description:

    This routine is called each time an object is referenced or
    dereferenced.  It determines if the object is traced, and if
    so, adds the necessary trace to the object reference info.

Arguments:

    ObjectHeader - The object to trace.
    IsRef - TRUE if this is a ref, FALSE if a deref

Return Value:

--*/

{
    KIRQL OldIrql;
    POBJECT_REF_INFO ObjectInfo;

    //
    // Are we tracing this object?
    //

    if (ObpIsObjectTraced( ObjectHeader )) {

        OBJECT_REF_TRACE Stack = { 0 };
        ULONG StackIndex;
        ULONG CapturedTraces;

        //
        //  Capture the stack trace outside the spinlock. 
        //  NOTE: stack traces cannot be captured on IA64 and AMD64 at dispatch level and above
        //

        CapturedTraces = RtlCaptureStackBackTrace( 1, OBTRACE_TRACEDEPTH, Stack.StackTrace, &StackIndex );

        if (CapturedTraces >= 1) {

            ExAcquireSpinLock( &ObpStackTraceLock, &OldIrql );

            ObjectInfo = ObpGetObjectRefInfo( ObjectHeader );

            if (ObjectInfo) {

                //
                // Get the table index for the trace
                //

                StackIndex = ObpGetTraceIndex( &Stack );

                if (StackIndex < OBTRACE_STACKS) {

                    //
                    // Add new reference info to the object
                    //

                    if (ObjectInfo->NextPos < OBTRACE_STACKSPEROBJECT) {

                        ObjectInfo->StackInfo[ObjectInfo->NextPos].Index = (USHORT)StackIndex | (IsRef ? 0x8000 : 0);
                        ObpStackSequence++;
                        ObjectInfo->StackInfo[ObjectInfo->NextPos].Sequence = (USHORT)ObpStackSequence;
                        ObjectInfo->NextPos++;
                    }
                }
            }

            ExReleaseSpinLock( &ObpStackTraceLock, OldIrql );
        }
    }
}

#endif //POOL_TAGGING
//
//
//  End Stack trace code
//

typedef struct _OB_TEMP_BUFFER {

    ACCESS_STATE LocalAccessState;
    OBJECT_CREATE_INFORMATION ObjectCreateInfo;
    OBP_LOOKUP_CONTEXT LookupContext;
    AUX_ACCESS_DATA AuxData;

} OB_TEMP_BUFFER,  *POB_TEMP_BUFFER;


NTSTATUS
ObOpenObjectByName (
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode,
    __inout_opt PACCESS_STATE AccessState,
    __in_opt ACCESS_MASK DesiredAccess,
    __inout_opt PVOID ParseContext,
    __out PHANDLE Handle
    )

/*++

Routine Description:


    This function opens an object with full access validation and auditing.
    Soon after entering we capture the SubjectContext for the caller. This
    context must remain captured until auditing is complete, and passed to
    any routine that may have to do access checking or auditing.

Arguments:

    ObjectAttributes - Supplies a pointer to the object attributes.

    ObjectType - Supplies an optional pointer to the object type descriptor.

    AccessMode - Supplies the processor mode of the access.

    AccessState - Supplies an optional pointer to the current access status
        describing already granted access types, the privileges used to get
        them, and any access types yet to be granted.

    DesiredAcess - Supplies the desired access to the object.

    ParseContext - Supplies an optional pointer to parse context.

    Handle - Supplies a pointer to a variable that receives the handle value.

Return Value:

    If the object is successfully opened, then a handle for the object is
    created and a success status is returned. Otherwise, an error status is
    returned.

--*/

{
    NTSTATUS Status;
    NTSTATUS HandleStatus;
    PVOID ExistingObject;
    HANDLE NewHandle;
    OB_OPEN_REASON OpenReason;
    POBJECT_HEADER ObjectHeader;
    UNICODE_STRING CapturedObjectName;
    PGENERIC_MAPPING GenericMapping;
    
    PAGED_CODE();

    ObpValidateIrql("ObOpenObjectByName");

    //
    //  If the object attributes are not specified, then return an error.
    //

    *Handle = NULL;

    if (!ARGUMENT_PRESENT(ObjectAttributes)) {

        Status = STATUS_INVALID_PARAMETER;

    } else {

        POB_TEMP_BUFFER TempBuffer;

#if defined(_AMD64_)

        OB_TEMP_BUFFER ObpTempBuffer;

        TempBuffer = &ObpTempBuffer;

#else

        TempBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                            sizeof(OB_TEMP_BUFFER),
                                            'tSbO'
                                          );

        if (TempBuffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

#endif

        //
        //  Capture the object creation information.
        //

        Status = ObpCaptureObjectCreateInformation( ObjectType,
                                                    AccessMode,
                                                    AccessMode,
                                                    ObjectAttributes,
                                                    &CapturedObjectName,
                                                    &TempBuffer->ObjectCreateInfo,
                                                    TRUE );

        //
        //  If the object creation information is successfully captured,
        //  then generate the access state.
        //

        if (NT_SUCCESS(Status)) {

            if (!ARGUMENT_PRESENT(AccessState)) {

                //
                //  If an object type descriptor is specified, then use
                //  associated generic mapping. Otherwise, use no generic
                //  mapping.
                //

                GenericMapping = NULL;

                if (ARGUMENT_PRESENT(ObjectType)) {

                    GenericMapping = &ObjectType->TypeInfo.GenericMapping;
                }

                AccessState = &TempBuffer->LocalAccessState;

                Status = SeCreateAccessState( &TempBuffer->LocalAccessState,
                                              &TempBuffer->AuxData,
                                              DesiredAccess,
                                              GenericMapping );

                if (!NT_SUCCESS(Status)) {

                    goto FreeCreateInfo;
                }
            }

            //
            //  If there is a security descriptor specified in the object
            //  attributes, then capture it in the access state.
            //

            if (TempBuffer->ObjectCreateInfo.SecurityDescriptor != NULL) {

                AccessState->SecurityDescriptor = TempBuffer->ObjectCreateInfo.SecurityDescriptor;
            }

            //
            //  Validate the access state.
            //

            Status = ObpValidateAccessMask(AccessState);

            //
            //  If the access state is valid, then lookup the object by
            //  name.
            //

            if (NT_SUCCESS(Status)) {

                Status = ObpLookupObjectName( TempBuffer->ObjectCreateInfo.RootDirectory,
                                              &CapturedObjectName,
                                              TempBuffer->ObjectCreateInfo.Attributes,
                                              ObjectType,
                                              AccessMode,
                                              ParseContext,
                                              TempBuffer->ObjectCreateInfo.SecurityQos,
                                              NULL,
                                              AccessState,
                                              &TempBuffer->LookupContext,
                                              &ExistingObject );

                //
                //  If the object was successfully looked up, then attempt
                //  to create or open a handle.
                //

                if (NT_SUCCESS(Status)) {

                    ObjectHeader = OBJECT_TO_OBJECT_HEADER(ExistingObject);

                    //
                    //  If the object is being created, then the operation
                    //  must be a open-if operation. Otherwise, a handle to
                    //  an object is being opened.
                    //

                    if (ObjectHeader->Flags & OB_FLAG_NEW_OBJECT) {

                        OpenReason = ObCreateHandle;

                        if (ObjectHeader->ObjectCreateInfo != NULL) {

                            ObpFreeObjectCreateInformation(ObjectHeader->ObjectCreateInfo);
                            ObjectHeader->ObjectCreateInfo = NULL;
                        }

                    } else {

                        OpenReason = ObOpenHandle;
                    }

                    //
                    //  If any of the object attributes are invalid, then
                    //  return an error status.
                    //

                    if (ObjectHeader->Type->TypeInfo.InvalidAttributes & TempBuffer->ObjectCreateInfo.Attributes) {

                        Status = STATUS_INVALID_PARAMETER;

                        ObpReleaseLookupContext( &TempBuffer->LookupContext );

                        ObDereferenceObject(ExistingObject);

                    } else {

                        //
                        //  The status returned by the object lookup routine
                        //  must be returned if the creation of a handle is
                        //  successful. Otherwise, the handle creation status
                        //  is returned.
                        //

                        HandleStatus = ObpCreateHandle( OpenReason,
                                                        ExistingObject,
                                                        ObjectType,
                                                        AccessState,
                                                        0,
                                                        TempBuffer->ObjectCreateInfo.Attributes,
                                                        &TempBuffer->LookupContext,
                                                        AccessMode,
                                                        (PVOID *)NULL,
                                                        &NewHandle );

                        if (!NT_SUCCESS(HandleStatus)) {

                            ObDereferenceObject(ExistingObject);

                            Status = HandleStatus;

                        } else {

                            *Handle = NewHandle;
                        }
                    }

                } else {

                    ObpReleaseLookupContext( &TempBuffer->LookupContext );
                }
            }

            //
            //  If the access state was generated, then delete the access
            //  state.
            //

            if (AccessState == &TempBuffer->LocalAccessState) {

                SeDeleteAccessState(AccessState);
            }

            //
            //  Free the create information.
            //

        FreeCreateInfo:

            ObpReleaseObjectCreateInformation(&TempBuffer->ObjectCreateInfo);

            if (CapturedObjectName.Buffer != NULL) {

                ObpFreeObjectNameBuffer(&CapturedObjectName);
            }
        }

#if !defined(_AMD64_)

        ExFreePool(TempBuffer);

#endif

    }

    return Status;
}


NTSTATUS
ObOpenObjectByPointer (
    __in PVOID Object,                                            
    __in ULONG HandleAttributes,                           
    __in_opt PACCESS_STATE PassedAccessState,  
    __in ACCESS_MASK DesiredAccess,                   
    __in_opt POBJECT_TYPE ObjectType,                   
    __in KPROCESSOR_MODE AccessMode,               
    __out PHANDLE Handle                                        
    )

/*++

Routine Description:

    This routine opens an object referenced by a pointer.

Arguments:

    Object - A pointer to the object being opened.

    HandleAttributes - The desired attributes for the handle, such
        as OBJ_INHERIT, OBJ_PERMANENT, OBJ_EXCLUSIVE, OBJ_CASE_INSENSITIVE,
        OBJ_OPENIF, and OBJ_OPENLINK

    PassedAccessState - Supplies an optional pointer to the current access
        status describing already granted access types, the privileges used
        to get them, and any access types yet to be granted.

    DesiredAcess - Supplies the desired access to the object.

    ObjectType - Supplies the type of the object being opened

    AccessMode - Supplies the processor mode of the access.

    Handle - Supplies a pointer to a variable that receives the handle value.

Return Value:

    An appropriate NTSTATUS value

--*/

{
    NTSTATUS Status;
    HANDLE NewHandle = (HANDLE)-1;
    POBJECT_HEADER ObjectHeader;
    ACCESS_STATE LocalAccessState;
    PACCESS_STATE AccessState = NULL;
    AUX_ACCESS_DATA AuxData;

    PAGED_CODE();

    ObpValidateIrql( "ObOpenObjectByPointer" );

    //
    //  First increment the pointer count for the object.  This routine
    //  also checks the object types
    //

    Status = ObReferenceObjectByPointer( Object,
                                         0,
                                         ObjectType,
                                         AccessMode );

    if (NT_SUCCESS( Status )) {

        //
        //  Get the object header for the input object body
        //

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

        //
        //  If the caller did not pass in an access state then
        //  we will create a new one based on the desired access
        //  and the object types generic mapping
        //

        if (!ARGUMENT_PRESENT( PassedAccessState )) {

            Status = SeCreateAccessState( &LocalAccessState,
                                          &AuxData,
                                          DesiredAccess,
                                          &ObjectHeader->Type->TypeInfo.GenericMapping );

            if (!NT_SUCCESS( Status )) {

                ObDereferenceObject( Object );

                return(Status);
            }

            AccessState = &LocalAccessState;

        //
        //  Otherwise the caller did specify an access state so
        //  we use the one passed in.
        //

        } else {

            AccessState = PassedAccessState;
        }

        //
        //  Make sure the caller is asking for handle attributes that are
        //  valid for the given object type
        //

        if (ObjectHeader->Type->TypeInfo.InvalidAttributes & HandleAttributes) {

            if (AccessState == &LocalAccessState) {

                SeDeleteAccessState( AccessState );
            }

            ObDereferenceObject( Object );

            return( STATUS_INVALID_PARAMETER );
        }

        //
        //  We've referenced the object and have an access state to give
        //  the new handle so now create a new handle for the object.
        //

        Status = ObpCreateHandle( ObOpenHandle,
                                  Object,
                                  ObjectType,
                                  AccessState,
                                  0,
                                  HandleAttributes,
                                  NULL,
                                  AccessMode,
                                  (PVOID *)NULL,
                                  &NewHandle );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( Object );
        }
    }

    //
    //  If we successfully opened by object and created a new handle
    //  then set the output variable correctly
    //

    if (NT_SUCCESS( Status )) {

        *Handle = NewHandle;

    } else {

        *Handle = NULL;
    }

    //
    //  Check if we used our own access state and now need to cleanup
    //

    if (AccessState == &LocalAccessState) {

        SeDeleteAccessState( AccessState );
    }

    //
    //  And return to our caller
    //

    return( Status );
}


NTSTATUS
ObReferenceObjectByHandle (
    __in HANDLE Handle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode,
    __out PVOID *Object,
    __out_opt POBJECT_HANDLE_INFORMATION HandleInformation
    )

/*++

Routine Description:

    Given a handle to an object this routine returns a pointer
    to the body of the object with proper ref counts

Arguments:

    Handle - Supplies a handle to the object being referenced.  It can
        also be the result of NtCurrentProcess or NtCurrentThread

    DesiredAccess - Supplies the access being requested by the caller

    ObjectType - Optionally supplies the type of the object we
        are expecting

    AccessMode - Supplies the processor mode of the access

    Object - Receives a pointer to the object body if the operation
        is successful

    HandleInformation - Optionally receives information regarding the
        input handle.

Return Value:

    An appropriate NTSTATUS value

--*/

{
    ACCESS_MASK GrantedAccess;
    PHANDLE_TABLE HandleTable;
    POBJECT_HEADER ObjectHeader;
    PHANDLE_TABLE_ENTRY ObjectTableEntry;
    PEPROCESS Process;
    NTSTATUS Status;
    PETHREAD Thread;

    ObpValidateIrql("ObReferenceObjectByHandle");

    Thread = PsGetCurrentThread ();
    *Object = NULL;

    //
    // Check is this handle is a kernel handle or one of the two builtin pseudo handles
    //
    if ((LONG)(ULONG_PTR) Handle < 0) {
        //
        //  If the handle is equal to the current process handle and the object
        //  type is NULL or type process, then attempt to translate a handle to
        //  the current process. Otherwise, check if the handle is the current
        //  thread handle.
        //

        if (Handle == NtCurrentProcess()) {

            if ((ObjectType == PsProcessType) || (ObjectType == NULL)) {

                Process = PsGetCurrentProcessByThread(Thread);
                GrantedAccess = Process->GrantedAccess;

                if ((SeComputeDeniedAccesses(GrantedAccess, DesiredAccess) == 0) ||
                    (AccessMode == KernelMode)) {

                    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Process);

                    if (ARGUMENT_PRESENT(HandleInformation)) {

                        HandleInformation->GrantedAccess = GrantedAccess;
                        HandleInformation->HandleAttributes = 0;
                    }

                    ObpIncrPointerCount(ObjectHeader);
                    *Object = Process;

                    ASSERT( *Object != NULL );

                    Status = STATUS_SUCCESS;

                } else {

                    Status = STATUS_ACCESS_DENIED;
                }

            } else {

                Status = STATUS_OBJECT_TYPE_MISMATCH;
            }

            return Status;

        //
        //  If the handle is equal to the current thread handle and the object
        //  type is NULL or type thread, then attempt to translate a handle to
        //  the current thread. Otherwise, the we'll try and translate the
        //  handle
        //

        } else if (Handle == NtCurrentThread()) {

            if ((ObjectType == PsThreadType) || (ObjectType == NULL)) {

                GrantedAccess = Thread->GrantedAccess;

                if ((SeComputeDeniedAccesses(GrantedAccess, DesiredAccess) == 0) ||
                    (AccessMode == KernelMode)) {

                    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Thread);

                    if (ARGUMENT_PRESENT(HandleInformation)) {

                        HandleInformation->GrantedAccess = GrantedAccess;
                        HandleInformation->HandleAttributes = 0;
                    }

                    ObpIncrPointerCount(ObjectHeader);
                    *Object = Thread;

                    ASSERT( *Object != NULL );

                    Status = STATUS_SUCCESS;

                } else {

                    Status = STATUS_ACCESS_DENIED;
                }

            } else {

                Status = STATUS_OBJECT_TYPE_MISMATCH;
            }

            return Status;

        } else if (AccessMode == KernelMode) {
            //
            //  Make the handle look like a regular handle
            //

            Handle = DecodeKernelHandle( Handle );

            //
            //  The global kernel handle table
            //

            HandleTable = ObpKernelHandleTable;
        } else {
            //
            // The previous mode was user for this kernel handle value. Reject it here.
            //

            return STATUS_INVALID_HANDLE;
        }

    } else {
        HandleTable = PsGetCurrentProcessByThread(Thread)->ObjectTable;
    }

    ASSERT(HandleTable != NULL);

    //
    // Protect this thread from being suspended while we hold the handle table entry lock
    //

    KeEnterCriticalRegionThread(&Thread->Tcb);

    //
    //  Translate the specified handle to an object table index.
    //

    ObjectTableEntry = ExMapHandleToPointerEx ( HandleTable, Handle, AccessMode );

    //
    //  Make sure the object table entry really does exist
    //

    if (ObjectTableEntry != NULL) {

        ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

        //
        // Optimize for a successful reference by bringing the object header
        // into the cache exclusive.
        //

        ReadForWriteAccess(ObjectHeader);
        if ((ObjectHeader->Type == ObjectType) || (ObjectType == NULL)) {

#if i386 
            if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

                GrantedAccess = ObpTranslateGrantedAccessIndex( ObjectTableEntry->GrantedAccessIndex );

            } else {

                GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);
            }
#else
            GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);

#endif // i386 

            if ((SeComputeDeniedAccesses(GrantedAccess, DesiredAccess) == 0) ||
                (AccessMode == KernelMode)) {

                PHANDLE_TABLE_ENTRY_INFO ObjectInfo;

                ObjectInfo = ExGetHandleInfo(HandleTable, Handle, TRUE);

                //
                //  Access to the object is allowed. Return the handle
                //  information is requested, increment the object
                //  pointer count, unlock the handle table and return
                //  a success status.
                //
                //  Note that this is the only successful return path
                //  out of this routine if the user did not specify
                //  the current process or current thread in the input
                //  handle.
                //

                if (ARGUMENT_PRESENT(HandleInformation)) {

                    HandleInformation->GrantedAccess = GrantedAccess;
                    HandleInformation->HandleAttributes = ObpGetHandleAttributes(ObjectTableEntry);
                }

                //
                //  If this object was audited when it was opened, it may
                //  be necessary to generate an audit now.  Check the audit
                //  mask that was saved when the handle was created.
                //
                //  It is safe to do this check in a non-atomic fashion,
                //  because bits will never be added to this mask once it is
                //  created.
                //

                if ( (ObjectTableEntry->ObAttributes & OBJ_AUDIT_OBJECT_CLOSE) &&
                     (ObjectInfo != NULL) &&
                     (ObjectInfo->AuditMask != 0) &&
                     (DesiredAccess != 0)) {

                      
                      ObpAuditObjectAccess( Handle, ObjectInfo, &ObjectHeader->Type->Name, DesiredAccess );
                }

                ObpIncrPointerCount(ObjectHeader);

                ExUnlockHandleTableEntry( HandleTable, ObjectTableEntry );

                KeLeaveCriticalRegionThread(&Thread->Tcb);

                *Object = &ObjectHeader->Body;

                ASSERT( *Object != NULL );

                return STATUS_SUCCESS;

            } else {

                Status = STATUS_ACCESS_DENIED;
            }

        } else {

            Status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        ExUnlockHandleTableEntry( HandleTable, ObjectTableEntry );

    } else {

        Status = STATUS_INVALID_HANDLE;
    }

    KeLeaveCriticalRegionThread(&Thread->Tcb);


    return Status;
}


NTSTATUS
ObpReferenceProcessObjectByHandle (
    IN HANDLE Handle,
    IN PEPROCESS Process,
    IN PHANDLE_TABLE HandleTable,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *Object,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation,
    OUT PACCESS_MASK AuditMask
    )

/*++

Routine Description:

    Given a handle to an object a process and its handle table
    this routine returns a pointer to the body of the object with
    proper ref counts

Arguments:

    Handle - Supplies a handle to the object being referenced.  It can
        also be the result of NtCurrentProcess or NtCurrentThread

    Process - Process that the handle should be referenced from.

    HandleTable - Handle table of target process

    AccessMode - Supplies the processor mode of the access

    Object - Receives a pointer to the object body if the operation
        is successful

    HandleInformation - receives information regarding the
        input handle.

    AuditMask - Pointer to any audit mask associated with the handle.

Return Value:

    An appropriate NTSTATUS value

--*/

{
    ACCESS_MASK GrantedAccess;
    POBJECT_HEADER ObjectHeader;
    PHANDLE_TABLE_ENTRY ObjectTableEntry;
    NTSTATUS Status;
    PETHREAD Thread;
    PHANDLE_TABLE_ENTRY_INFO ObjectInfo;

    ObpValidateIrql("ObReferenceObjectByHandle");

    Thread = PsGetCurrentThread ();
    *Object = NULL;

    //
    // Check is this handle is a kernel handle or one of the two builtin pseudo handles
    //
    if ((LONG)(ULONG_PTR) Handle < 0) {
        //
        //  If the handle is equal to the current process handle and the object
        //  type is NULL or type process, then attempt to translate a handle to
        //  the current process. Otherwise, check if the handle is the current
        //  thread handle.
        //

        if (Handle == NtCurrentProcess()) {

            GrantedAccess = Process->GrantedAccess;

            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Process);

            HandleInformation->GrantedAccess = GrantedAccess;
            HandleInformation->HandleAttributes = 0;

            *AuditMask = 0;

            ObpIncrPointerCount(ObjectHeader);
            *Object = Process;

            ASSERT( *Object != NULL );

            Status = STATUS_SUCCESS;

            return Status;

        //
        //  If the handle is equal to the current thread handle and the object
        //  type is NULL or type thread, then attempt to translate a handle to
        //  the current thread. Otherwise, the we'll try and translate the
        //  handle
        //

        } else if (Handle == NtCurrentThread()) {

            GrantedAccess = Thread->GrantedAccess;

            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Thread);

            HandleInformation->GrantedAccess = GrantedAccess;
            HandleInformation->HandleAttributes = 0;

            *AuditMask = 0;

            ObpIncrPointerCount(ObjectHeader);
            *Object = Thread;

            ASSERT( *Object != NULL );

            Status = STATUS_SUCCESS;

            return Status;

        } else if (AccessMode == KernelMode) {
            //
            //  Make the handle look like a regular handle
            //

            Handle = DecodeKernelHandle( Handle );

            //
            //  The global kernel handle table
            //

            HandleTable = ObpKernelHandleTable;
        } else {
            //
            // The previous mode was user for this kernel handle value. Reject it here.
            //

            return STATUS_INVALID_HANDLE;
        }

    }

    ASSERT(HandleTable != NULL);

    //
    // Protect this thread from being suspended while we hold the handle table entry lock
    //

    KeEnterCriticalRegionThread(&Thread->Tcb);

    //
    //  Translate the specified handle to an object table index.
    //

    ObjectTableEntry = ExMapHandleToPointer ( HandleTable, Handle );

    //
    //  Make sure the object table entry really does exist
    //

    if (ObjectTableEntry != NULL) {

        ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

#if i386 
        if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

            GrantedAccess = ObpTranslateGrantedAccessIndex( ObjectTableEntry->GrantedAccessIndex );

        } else {

            GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);
        }
#else
        GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);

#endif // i386 


        ObjectInfo = ExGetHandleInfo(HandleTable, Handle, TRUE);

        //
        //  Return the handle information, increment the object
        //  pointer count, unlock the handle table and return
        //  a success status.
        //
        //  Note that this is the only successful return path
        //  out of this routine if the user did not specify
        //  the current process or current thread in the input
        //  handle.
        //

        HandleInformation->GrantedAccess = GrantedAccess;
        HandleInformation->HandleAttributes = ObpGetHandleAttributes(ObjectTableEntry);

        //
        //  Return handle audit information to the caller
        //
        if (ObjectInfo != NULL) {
            *AuditMask = ObjectInfo->AuditMask;
        } else {
            *AuditMask = 0;
        }

        ObpIncrPointerCount(ObjectHeader);

        ExUnlockHandleTableEntry( HandleTable, ObjectTableEntry );

        KeLeaveCriticalRegionThread(&Thread->Tcb);

        *Object = &ObjectHeader->Body;

        ASSERT( *Object != NULL );

        return STATUS_SUCCESS;


    } else {

        Status = STATUS_INVALID_HANDLE;
    }

    KeLeaveCriticalRegionThread(&Thread->Tcb);


    return Status;
}



NTSTATUS
ObReferenceFileObjectForWrite(
    IN HANDLE Handle,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *FileObject,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation
    )

/*++

Routine Description:

    Given a handle to a file object this routine returns a pointer
    to the body of the object with proper ref counts and auditing.  This
    routine is meant to solve a very particular handle reference issue with
    file object access auditing.  Do not call this unless you understand exactly
    what you are doing.

Arguments:

    Handle - Supplies a handle to the IoFileObjectType being referenced.

    AccessMode - Supplies the processor mode of the access

    FileObject - Receives a pointer to the object body if the operation
        is successful

    HandleInformation - receives information regarding the input handle.

Return Value:

    An appropriate NTSTATUS value

--*/

{
    ACCESS_MASK GrantedAccess;
    ACCESS_MASK DesiredAccess;
    PHANDLE_TABLE HandleTable;
    POBJECT_HEADER ObjectHeader;
    PHANDLE_TABLE_ENTRY ObjectTableEntry;
    NTSTATUS Status;
    PETHREAD Thread;
    PHANDLE_TABLE_ENTRY_INFO ObjectInfo;

    ObpValidateIrql("ObReferenceFileObjectForWrite");

    Thread = PsGetCurrentThread ();

    //
    // Check is this handle is a kernel handle
    //

    if ((LONG)(ULONG_PTR) Handle < 0) {
        
        if ((AccessMode == KernelMode) && (Handle != NtCurrentProcess()) && (Handle != NtCurrentThread())) {
            
            //
            //  Make the handle look like a regular handle
            //

            Handle = DecodeKernelHandle( Handle );

            //
            //  The global kernel handle table
            //

            HandleTable = ObpKernelHandleTable;
        } else {
            //
            // The previous mode was user for this kernel handle value, or it was a builtin handle. Reject it here.
            //

            return STATUS_INVALID_HANDLE;
        } 
    } else {
        HandleTable = PsGetCurrentProcessByThread(Thread)->ObjectTable;
    }

    ASSERT(HandleTable != NULL);

    //
    // Protect this thread from being suspended while we hold the handle table entry lock
    //

    KeEnterCriticalRegionThread(&Thread->Tcb);

    //
    //  Translate the specified handle to an object table index.
    //

    ObjectTableEntry = ExMapHandleToPointerEx ( HandleTable, Handle, AccessMode );

    //
    //  Make sure the object table entry really does exist
    //

    if (ObjectTableEntry != NULL) {

        ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

        if (NT_SUCCESS(IoComputeDesiredAccessFileObject((PFILE_OBJECT)&ObjectHeader->Body, (PNTSTATUS)&DesiredAccess))) {

#if i386
            if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

                GrantedAccess = ObpTranslateGrantedAccessIndex( ObjectTableEntry->GrantedAccessIndex );

            } else {

                GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);
            }
#else
            GrantedAccess = ObpDecodeGrantedAccess(ObjectTableEntry->GrantedAccess);

#endif // i386

            ObjectInfo = ExGetHandleInfo(HandleTable, Handle, TRUE);

            //
            //  Access to the object is allowed. Return the handle
            //  information, increment the object pointer count,
            //  compute correct access, audit, unlock the handle
            //  table and return a success status.
            //
            //  Note that this is the only successful return path
            //  out of this routine.
            //

            HandleInformation->GrantedAccess = GrantedAccess;
            HandleInformation->HandleAttributes = ObpGetHandleAttributes(ObjectTableEntry);

            //
            // Check to ensure that the caller has either WRITE_DATA or APPEND_DATA
            // access to the file.  If not, cleanup and return an access denied
            // error status value.  Note that if this is a pipe then the APPEND_DATA
            // access check may not be made since this access code is overlaid with
            // CREATE_PIPE_INSTANCE access.
            //

            if (SeComputeGrantedAccesses( GrantedAccess, DesiredAccess )) {

                //
                //  If this object was audited when it was opened, it may
                //  be necessary to generate an audit now.  Check the audit
                //  mask that was saved when the handle was created.
                //
                //  It is safe to do this check in a non-atomic fashion,
                //  because bits will never be added to this mask once it is
                //  created.
                //

                if ( (ObjectTableEntry->ObAttributes & OBJ_AUDIT_OBJECT_CLOSE) &&
                     (ObjectInfo != NULL) &&
                     (ObjectInfo->AuditMask != 0) &&
                     (DesiredAccess != 0) &&
                     (AccessMode != KernelMode)) {

                      ObpAuditObjectAccess( Handle, ObjectInfo, &ObjectHeader->Type->Name, DesiredAccess );
                }

                ObpIncrPointerCount(ObjectHeader);
                ExUnlockHandleTableEntry( HandleTable, ObjectTableEntry );
                KeLeaveCriticalRegionThread(&Thread->Tcb);
            
                *FileObject = &ObjectHeader->Body;
                
                ASSERT( *FileObject != NULL );

                return STATUS_SUCCESS;
            
            } else {

                Status = STATUS_ACCESS_DENIED;
            }

        } else {

            Status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        ExUnlockHandleTableEntry( HandleTable, ObjectTableEntry );

    } else {

        Status = STATUS_INVALID_HANDLE;
    }

    KeLeaveCriticalRegionThread(&Thread->Tcb);

    //
    //  No handle translation is possible. Set the object address to NULL
    //  and return an error status.
    //

    *FileObject = NULL;

    return Status;
}


VOID
ObAuditObjectAccess(
    IN HANDLE Handle,
    IN POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL,
    IN KPROCESSOR_MODE AccessMode,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine will determine if it is necessary to audit the operation being
    performed on the passed handle.  If so, it will clear the bits in the handle
    and generate the appropriate audit before returning.

    The bits in the handle's audit mask are cleared in an atomic way so that
    multiple threads coming through this code do not generate more than one
    audit for the same operation.

Arguments:

    Handle - Supplies the handle being accessed.

    AccessMode - The mode (kernel or user) that originated the handle.

    DesiredAccess - Supplies the access mask describing how the handle is being used
        in this operation.

Return Value:

    None.

--*/

{
    PHANDLE_TABLE HandleTable;
    PHANDLE_TABLE_ENTRY ObjectTableEntry;
    POBJECT_HEADER ObjectHeader;
    PKTHREAD CurrentThread;

    //
    // Exit fast if we have nothing to do.
    //

    if (ARGUMENT_PRESENT(HandleInformation)) {
        if (!(HandleInformation->HandleAttributes & OBJ_AUDIT_OBJECT_CLOSE)) {
            return;
        }
    }

    //
    // Do not currently support this on kernel mode
    // handles.
    //

    if (AccessMode == KernelMode) {
        return;
    }

    HandleTable = ObpGetObjectTable();

    ASSERT(HandleTable != NULL);

    //
    //  Translate the specified handle to an object table index.
    //

    CurrentThread = KeGetCurrentThread ();
    KeEnterCriticalRegionThread (CurrentThread);

    ObjectTableEntry = ExMapHandleToPointer( HandleTable, Handle );

    //
    //  Make sure the object table entry really does exist
    //

    if (ObjectTableEntry != NULL) {

        PHANDLE_TABLE_ENTRY_INFO ObjectInfo;

        ObjectInfo = ExGetHandleInfo(HandleTable, Handle, TRUE);

        ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

        //
        //  If this object was audited when it was opened, it may
        //  be necessary to generate an audit now.  Check the audit
        //  mask that was saved when the handle was created.
        //
        //  It is safe to do this check in a non-atomic fashion,
        //  because bits will never be added to this mask once it is
        //  created.
        //
        //  Note: is OBJ_AUDIT_OBJECT_CLOSE in ObAttributes kept in synch with
        //  HandleAttributes?
        //

        if ( (ObjectTableEntry->ObAttributes & OBJ_AUDIT_OBJECT_CLOSE) &&
             (ObjectInfo != NULL) &&
             (ObjectInfo->AuditMask != 0) &&
             (DesiredAccess != 0))  {

              ObpAuditObjectAccess( Handle, ObjectInfo, &ObjectHeader->Type->Name, DesiredAccess );
        }

        ExUnlockHandleTableEntry( HandleTable, ObjectTableEntry );
    }
    KeLeaveCriticalRegionThread (CurrentThread);
}



VOID
ObpAuditObjectAccess(
    IN HANDLE Handle,
    IN PHANDLE_TABLE_ENTRY_INFO ObjectTableEntryInfo,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This routine will determine if it is necessary to audit the operation being
    performed on the passed handle.  If so, it will clear the bits in the handle
    and generate the appropriate audit before returning.

    The bits in the handle's audit mask are cleared in an atomic way so that
    multiple threads coming through this code do not generate more than one
    audit for the same operation.

Arguments:

    Handle - Supplies the handle being accessed.

    ObjectTableEntry - Supplies the object table entry for the handle passed in the
        first parameter.

    DesiredAccess - Supplies the access mask describing how the handle is being used
        in this operation.

Return Value:

    None.

--*/
{
    ACCESS_MASK t1, t2, r;
    ACCESS_MASK BitsToAudit;

    //
    //  Determine if this access is to
    //  be audited, and if so, clear the bits
    //  in the ObjectTableEntry.
    //

    while (ObjectTableEntryInfo->AuditMask != 0) {

        t1 = ObjectTableEntryInfo->AuditMask;
        t2 = t1 & ~DesiredAccess;

        if (t2 != t1) {

            r = (ACCESS_MASK) InterlockedCompareExchange((PLONG)&ObjectTableEntryInfo->AuditMask,  t2, t1);

            if (r == t1) {

                //
                //  AuditMask was == t1, so AuditMask is now == t2
                //  it worked, r contains what was in AuditMask, which
                //  we can examine safely.
                //

                BitsToAudit = r & DesiredAccess;

                //
                // Generate audit here
                //

                if (BitsToAudit != 0) {

                    SeOperationAuditAlarm( NULL,
                                           Handle,
                                           ObjectTypeName,
                                           BitsToAudit,
                                           NULL
                                           );
                }

                return;
            }

            //
            // else, somebody changed it, go around for another try
            //

        } else {

            //
            //  There are no bits in the AuditMask that we
            //  want to audit here, just leave.
            //

            return;
        }
    }
}


NTSTATUS
ObReferenceObjectByName (
    __in PUNICODE_STRING ObjectName,
    __in ULONG Attributes,
    __in_opt PACCESS_STATE AccessState,
    __in_opt ACCESS_MASK DesiredAccess,
    __in POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode,
    __inout_opt PVOID ParseContext,
    __out PVOID *Object
    )

/*++

Routine Description:

    Given a name of an object this routine returns a pointer
    to the body of the object with proper ref counts

Arguments:

    ObjectName - Supplies the name of the object being referenced

    Attributes - Supplies the desired handle attributes

    AccessState - Supplies an optional pointer to the current access
        status describing already granted access types, the privileges used
        to get them, and any access types yet to be granted.

    DesiredAccess - Optionally supplies the desired access to the
        for the object

    ObjectType - Specifies the object type according to the caller

    AccessMode - Supplies the processor mode of the access

    ParseContext - Optionally supplies a context to pass down to the
        parse routine

    Object - Receives a pointer to the referenced object body

Return Value:

    An appropriate NTSTATUS value

--*/

{
    UNICODE_STRING CapturedObjectName;
    PVOID ExistingObject;
    ACCESS_STATE LocalAccessState;
    AUX_ACCESS_DATA AuxData;
    NTSTATUS Status;
    OBP_LOOKUP_CONTEXT LookupContext;

    PAGED_CODE();

    ObpValidateIrql("ObReferenceObjectByName");

    //
    //  If the object name descriptor is not specified, or the object name
    //  length is zero (tested after capture), then the object name is
    //  invalid.
    //

    if (ObjectName == NULL) {

        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    //  Capture the object name.
    //

    Status = ObpCaptureObjectName( AccessMode,
                                   ObjectName,
                                   &CapturedObjectName,
                                   TRUE );

    if (NT_SUCCESS(Status)) {

        //
        //  No buffer has been allocated for a zero length name so no free
        //  needed
        //

        if (CapturedObjectName.Length == 0) {

           return STATUS_OBJECT_NAME_INVALID;
        }

        //
        //  If the access state is not specified, then create the access
        //  state.
        //

        if (!ARGUMENT_PRESENT(AccessState)) {

            AccessState = &LocalAccessState;

            Status = SeCreateAccessState( &LocalAccessState,
                                          &AuxData,
                                          DesiredAccess,
                                          &ObjectType->TypeInfo.GenericMapping );

            if (!NT_SUCCESS(Status)) {

                goto FreeBuffer;
            }
        }

        //
        //  Lookup object by name.
        //

        Status = ObpLookupObjectName( NULL,
                                      &CapturedObjectName,
                                      Attributes,
                                      ObjectType,
                                      AccessMode,
                                      ParseContext,
                                      NULL,
                                      NULL,
                                      AccessState,
                                      &LookupContext,
                                      &ExistingObject );

        //
        //  If the directory is returned locked, then unlock it.
        //

        ObpReleaseLookupContext( &LookupContext );
        //
        //  If the lookup was successful, then return the existing
        //  object if access is allowed. Otherwise, return NULL.
        //

        *Object = NULL;

        if (NT_SUCCESS(Status)) {

            if (ObpCheckObjectReference( ExistingObject,
                                         AccessState,
                                         FALSE,
                                         AccessMode,
                                         &Status )) {

                *Object = ExistingObject;

            } else {

                ObDereferenceObject( ExistingObject );
            }
        }

        //
        //  If the access state was generated, then delete the access
        //  state.
        //

        if (AccessState == &LocalAccessState) {

            SeDeleteAccessState(AccessState);
        }

        //
        //  Free the object name buffer.
        //

FreeBuffer:

        ObpFreeObjectNameBuffer(&CapturedObjectName);
    }

    return Status;
}


NTSTATUS
ObReferenceObjectByPointer (
    __in PVOID Object,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode
    )

/*++

Routine Description:

    This routine adds another reference count to an object denoted by
    a pointer to the object body

Arguments:

    Object - Supplies a pointer to the object being referenced

    DesiredAccess - Specifies the desired access for the reference

    ObjectType - Specifies the object type according to the caller

    AccessMode - Supplies the processor mode of the access

Return Value:

    STATUS_SUCCESS if successful and STATUS_OBJECT_TYPE_MISMATCH otherwise

--*/

{
    POBJECT_HEADER ObjectHeader;

    UNREFERENCED_PARAMETER (DesiredAccess);

    //
    //  Translate the pointer to the object body to a pointer to the
    //  object header
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    //
    //  If the specified object type does not match and either the caller is
    //  not kernel mode or it is not a symbolic link object then it is an
    //  error
    //

    if ((ObjectHeader->Type != ObjectType) && (AccessMode != KernelMode ||
                                               ObjectType == ObpSymbolicLinkObjectType)) {

        return( STATUS_OBJECT_TYPE_MISMATCH );
    }

    //
    //  Otherwise increment the pointer count and return success to
    //  our caller
    //

    ObpIncrPointerCount( ObjectHeader );

    return( STATUS_SUCCESS );
}

VOID
ObpDeferObjectDeletion (
    IN POBJECT_HEADER ObjectHeader
    )
{
    PVOID OldValue;
    //
    // Push this object on the list. If we make an empty to non-empty
    // transition then we may have to start a worker thread.
    //

    while (1) {
        OldValue = ReadForWriteAccess (&ObpRemoveObjectList);
        ObjectHeader->NextToFree = OldValue;
        if (InterlockedCompareExchangePointer (&ObpRemoveObjectList,
                                               ObjectHeader,
                                               OldValue) == OldValue) {
            break;
        }
    }

    if (OldValue == NULL) {
        //
        //  If we have to start the worker thread then go ahead
        //  and enqueue the work item
        //

        ExQueueWorkItem( &ObpRemoveObjectWorkItem, CriticalWorkQueue );
    }

}


LONG_PTR
FASTCALL
ObfReferenceObject (
    __in PVOID Object
    )

/*++

Routine Description:

    This function increments the reference count for an object.

    N.B. This function should be used to increment the reference count
        when the accessing mode is kernel or the objct type is known.

Arguments:

    Object - Supplies a pointer to the object whose reference count is
        incremented.

Return Value:

    None.

--*/

{
    POBJECT_HEADER ObjectHeader;
    LONG_PTR RetVal;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    RetVal = ObpIncrPointerCount( ObjectHeader );
    ASSERT (RetVal != 1);
    return RetVal;
}

LONG_PTR
FASTCALL
ObReferenceObjectEx (
    IN PVOID Object,
    IN ULONG Count
    )
/*++

Routine Description:

    This function increments the reference count for an object by the specified amount.

Arguments:

    Object - Supplies a pointer to the object whose reference count is
        incremented.
    Count - Amount to increment by

Return Value:

    LONG - New value of count

--*/
{
    POBJECT_HEADER ObjectHeader;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    return ObpIncrPointerCountEx (ObjectHeader, Count);
}

LONG_PTR
FASTCALL
ObDereferenceObjectEx (
    IN PVOID Object,
    IN ULONG Count
    )
/*++

Routine Description:

    This function decrements the reference count for an object by the specified amount.

Arguments:

    Object - Supplies a pointer to the object whose reference count is
        incremented.
    Count - Amount to decrement by

Return Value:

    LONG - New value of count

--*/
{
    POBJECT_HEADER ObjectHeader;
    LONG_PTR Result;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    Result = ObpDecrPointerCountEx (ObjectHeader, Count);
    if (Result == 0) {
        ObpDeferObjectDeletion (ObjectHeader);
    }
    return Result;
}



BOOLEAN
FASTCALL
ObReferenceObjectSafe (
    IN PVOID Object
    )

/*++

Routine Description:

    This function increments the reference count for an object. It returns
    FALSE if the object is being deleted or TRUE if it's safe to use the object further

Arguments:

    Object - Supplies a pointer to the object whose reference count is
             incremented.

Return Value:

    TRUE    - The object was successfuly referenced and safe to use
    FALSE   - The object is being deleted

--*/

{
    POBJECT_HEADER ObjectHeader;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    if (ObpSafeInterlockedIncrement(&ObjectHeader->PointerCount)) {

#ifdef POOL_TAGGING
        if(ObpTraceEnabled) {
            ObpPushStackInfo(ObjectHeader, TRUE);
        }
#endif // POOL_TAGGING

        return TRUE;
    }

    return FALSE;
}



LONG_PTR
FASTCALL
ObfDereferenceObject (
    __in PVOID Object
    )

/*++

Routine Description:

    This routine decrments the reference count of the specified object and
    does whatever cleanup there is if the count goes to zero.

Arguments:

    Object - Supplies a pointer to the body of the object being dereferenced

Return Value:

    None.

--*/

{
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    KIRQL OldIrql;
    LONG_PTR Result;

    //
    //  Translate a pointer to the object body to a pointer to the object
    //  header.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

#if DBG
    {
        POBJECT_HEADER_NAME_INFO NameInfo;

        NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

        if (NameInfo) {

            InterlockedDecrement(&NameInfo->DbgDereferenceCount) ;
        }
    }
#endif

    //
    //  Decrement the point count and if the result is now then
    //  there is extra work to do
    //

    ObjectType = ReadForWriteAccess(&ObjectHeader->Type);

    Result = ObpDecrPointerCount( ObjectHeader );

    if (Result == 0) {

        //
        //  Find out the level we're at and the object type
        //

        OldIrql = KeGetCurrentIrql();

        ASSERT(ObjectHeader->HandleCount == 0);

        //
        //  If we're at the passive level then go ahead and delete the
        //  object now.
        //

        if ( !KeAreAllApcsDisabled() ) {

#ifdef POOL_TAGGING
                //
                // The object is going away, so we deregister it.
                //

                if (ObpTraceEnabled && !ObpTraceNoDeregister) {

                    ObpDeregisterObject( ObjectHeader );
                }
#endif //POOL_TAGGING

                ObpRemoveObjectRoutine( Object, FALSE );

                return Result;

        } else {

            //
            //  Objects can't be deleted from an IRQL above PASSIVE_LEVEL.
            //  So queue the delete operation.
            //

            ObpDeferObjectDeletion (ObjectHeader);
        }
    }

    return Result;
}

VOID
ObDereferenceObjectDeferDelete (
    IN PVOID Object
    )
{
    POBJECT_HEADER ObjectHeader;
    LONG_PTR Result;

#if DBG
    POBJECT_HEADER_NAME_INFO NameInfo;
#endif

    //
    //  Translate a pointer to the object body to a pointer to the object
    //  header.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

#if DBG
    NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

    if (NameInfo) {

        InterlockedDecrement(&NameInfo->DbgDereferenceCount) ;
    }
#endif

    //
    //  Decrement the point count and if the result is now then
    //  there is extra work to do
    //

    Result = ObpDecrPointerCount( ObjectHeader );

    if (Result == 0) {
        ObpDeferObjectDeletion (ObjectHeader);
    }
}


VOID
ObpProcessRemoveObjectQueue (
    PVOID Parameter
    )

/*++

Routine Description:

    This is the work routine for the remove object work queue.  Its
    job is to remove and process items from the remove object queue.

Arguments:

    Parameter - Ignored

Return Value:

    None.

--*/

{
    POBJECT_HEADER ObjectHeader, NextObject;

    UNREFERENCED_PARAMETER (Parameter);
    //
    // Process the list of deferred delete objects.
    // The list head serves two purposes. First it maintains
    // the list of objects we need to delete and second
    // it signals that this thread is active.
    // While we are processing the latest list we leave the
    // header as the value 1. This will never be an object address
    // as the bottom bits should be clear for an object.
    //
    while (1) {
        ObjectHeader = InterlockedExchangePointer (&ObpRemoveObjectList,
                                                  (PVOID) 1);
        while (1) {
#ifdef POOL_TAGGING
            if (ObpTraceEnabled && !ObpTraceNoDeregister) {

                ObpDeregisterObject( ObjectHeader );
            }
#endif
            NextObject = ObjectHeader->NextToFree;
            ObpRemoveObjectRoutine( &ObjectHeader->Body, TRUE );
            ObjectHeader = NextObject;
            if (ObjectHeader == NULL || ObjectHeader == (PVOID) 1) {
                break;
            }
        }

        if (ObpRemoveObjectList == (PVOID) 1 &&
            InterlockedCompareExchangePointer (&ObpRemoveObjectList,
                                               NULL,
                                               (PVOID) 1) == (PVOID) 1) {
            break;
        }
    }
}


VOID
ObpRemoveObjectRoutine (
    IN  PVOID   Object,
    IN  BOOLEAN CalledOnWorkerThread
    )

/*++

Routine Description:

    This routine is used to delete an object whose reference count has
    gone to zero.

Arguments:

    Object - Supplies a pointer to the body of the object being deleted

    CalledOnWorkerThread - TRUE if called on worker thread, FALSE if called in
                           the context of the ObDereferenceObject.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER_NAME_INFO NameInfo;

    PAGED_CODE();

    ObpValidateIrql( "ObpRemoveObjectRoutine" );

    //
    //  Retrieve an object header from the object body, and also get
    //  the object type, creator and name info if available
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;
    CreatorInfo = OBJECT_HEADER_TO_CREATOR_INFO( ObjectHeader );
    NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );


    //
    //  If there is a creator info record and we are on the list
    //  for the object type then remove this object from the list
    //

    if (CreatorInfo != NULL && !IsListEmpty( &CreatorInfo->TypeList )) {

        //
        //  Get exclusive access to the object type object
        //

        ObpEnterObjectTypeMutex( ObjectType );

        RemoveEntryList( &CreatorInfo->TypeList );

        //
        //  We are done with the object type object so we can now release it
        //

        ObpLeaveObjectTypeMutex( ObjectType );
    }

    //
    //  If there is a name info record and the name buffer is not null
    //  then free the buffer and zero out the name record
    //

    if (NameInfo != NULL && NameInfo->Name.Buffer != NULL) {

        ExFreePool( NameInfo->Name.Buffer );

        NameInfo->Name.Buffer = NULL;
        NameInfo->Name.Length = 0;
        NameInfo->Name.MaximumLength = 0;
    }


    //
    //  Security descriptor deletion must precede the
    //  call to the object's DeleteProcedure.  Check if we have
    //  a security descriptor and if so then call the routine
    //  to delete the security descritpor.
    //

    if (ObjectHeader->SecurityDescriptor != NULL) {

#if DBG
        KIRQL SaveIrql;
#endif

        ObpBeginTypeSpecificCallOut( SaveIrql );

        Status = (ObjectType->TypeInfo.SecurityProcedure)( Object,
                                                           DeleteSecurityDescriptor,
                                                           NULL, NULL, NULL,
                                                           &ObjectHeader->SecurityDescriptor,
                                                           0,
                                                           NULL );

        ObpEndTypeSpecificCallOut( SaveIrql, "Security", ObjectType, Object );
    }

    //
    //  Now if there is a delete callback for the object type invoke
    //  the routine
    //

    if (ObjectType->TypeInfo.DeleteProcedure) {

#if DBG
        KIRQL SaveIrql;
#endif

        ObpBeginTypeSpecificCallOut( SaveIrql );

        if (!CalledOnWorkerThread) {

            ObjectHeader->Flags |= OB_FLAG_DELETED_INLINE;
        }

        (*(ObjectType->TypeInfo.DeleteProcedure))(Object);

        ObpEndTypeSpecificCallOut( SaveIrql, "Delete", ObjectType, Object );
    }

    //
    //  Finally return the object back to pool including releasing any quota
    //  charges
    //

    ObpFreeObject( Object );
}


VOID
ObpDeleteNameCheck (
    IN PVOID Object
    )

/*++

Routine Description:

    This routine removes the name of an object from its parent directory

Arguments:

    Object - Supplies a pointer to the object body whose name is being checked

    TypeMutexHeld - Indicates if the lock on object type is being held by the
        caller

Return Value:

    None.

--*/

{
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    POBJECT_HEADER_NAME_INFO NameInfo;
    PVOID DirObject;
    OBP_LOOKUP_CONTEXT LookupContext;

    PAGED_CODE();

    ObpValidateIrql( "ObpDeleteNameCheck" );

    //
    //  Translate the object body to an object header also get
    //  the object type and name info if present
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    NameInfo = ObpReferenceNameInfo( ObjectHeader );
    ObjectType = ObjectHeader->Type;

    //
    //  Make sure that the object has a zero handle count, has a non
    //  empty name buffer, and is not a permanent object
    //

    if ((ObjectHeader->HandleCount == 0) &&
        (NameInfo != NULL) &&
        (NameInfo->Name.Length != 0) &&
        (!(ObjectHeader->Flags & OB_FLAG_PERMANENT_OBJECT)) &&
        (NameInfo->Directory != NULL)) {

        ObpInitializeLookupContext(&LookupContext);
        ObpLockLookupContext ( &LookupContext, NameInfo->Directory );

        DirObject = NULL;

        //
        //  Check that the object we is still in the directory otherwise
        //  then is nothing for us to remove
        //

        if (Object == ObpLookupDirectoryEntry( NameInfo->Directory,
                                               &NameInfo->Name,
                                               0,
                                               FALSE,
                                               &LookupContext )) {

            //
            //  Now reacquire the lock on the object type and
            //  check check the handle count again.  If it is still
            //  zero then we can do the actual delete name operation
            //
            //
            //  Delete the directory entry, if the entry is still there
            //

            ObpLockObject( ObjectHeader );

            if (ObjectHeader->HandleCount == 0 &&
                (ObjectHeader->Flags & OB_FLAG_PERMANENT_OBJECT) == 0) {

                //
                //  Delete the directory entry
                //

                ObpDeleteDirectoryEntry( &LookupContext );

                //
                //  If this is a symbolic link object then we also need to
                //  delete the symbolic link
                //

                if (ObjectType == ObpSymbolicLinkObjectType) {

                    ObpDeleteSymbolicLinkName( (POBJECT_SYMBOLIC_LINK)Object );
                }

                //
                //  Remove the protection since the object is no longer visible
                //  to allow proper cleanup
                //

                if ( ObpIsKernelExclusiveObject(ObjectHeader) ) {
                 
                    InterlockedExchangeAdd((PLONG)&NameInfo->QueryReferences, -OBP_NAME_KERNEL_PROTECTED);
                }

                DirObject = NameInfo->Directory;
            }


            ObpUnlockObject( ObjectHeader );
        }

        ObpReleaseLookupContext( &LookupContext );

        //
        //  If there is a directory object for the name then decrement
        //  its reference count for it and for the object
        //

        ObpDereferenceNameInfo(NameInfo);

        if (DirObject != NULL) {

            //
            //  Dereference the name twice: one because we referenced it to
            //  safely access the name info, and the second deref is because
            //  we want a deletion for the NameInfo
            //

            ObpDereferenceNameInfo(NameInfo);
            
            ObDereferenceObject( Object );
        }

    } else {

        ObpDereferenceNameInfo(NameInfo);

    }

    return;
}


//
// Thunks to support standard call callers
//

#ifdef ObDereferenceObject
#undef ObDereferenceObject
#endif

LONG_PTR
ObDereferenceObject (
    IN PVOID Object
    )

/*++

Routine Description:

    This is really just a thunk for the Obf version of the dereference
    routine

Arguments:

    Object - Supplies a pointer to the body of the object being dereferenced

Return Value:

    None.

--*/

{
    return ObfDereferenceObject (Object) ;
}


BOOLEAN
ObIsObjectDeletionInline(
    IN PVOID Object
    )

/*++

Routine Description:

    This is available only of object DeleteProcedure callbacks. It allows the
    callback to determine whether the stack on which it is invoked is
Arguments:

    Object - Supplies a pointer to the body of the object being deleted

Return Value:

    TRUE if the deletion procedure is being invoked on the same stack as the
    ObDereferenceObject, and FALSE if the procedure is being invoked from a
    queued work item.

--*/
{
    POBJECT_HEADER ObjectHeader;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    return ((ObjectHeader->Flags & OB_FLAG_DELETED_INLINE) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obquery.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obquery.c

Abstract:

    Query Object system service

--*/

#include "obp.h"

//
//  Local procedure prototypes
//

//
//  The following structure is used to pass the call back routine
//  "ObpSetHandleAttributes" the captured object information and
//  the processor mode of the caller.
//

typedef struct __OBP_SET_HANDLE_ATTRIBUTES {
    OBJECT_HANDLE_FLAG_INFORMATION ObjectInformation;
    KPROCESSOR_MODE PreviousMode;
} OBP_SET_HANDLE_ATTRIBUTES, *POBP_SET_HANDLE_ATTRIBUTES;

BOOLEAN
ObpSetHandleAttributes (
    IN OUT PVOID TableEntry,
    IN ULONG_PTR Parameter
    );

#pragma alloc_text(PAGE, NtQueryObject)
#pragma alloc_text(PAGE, ObpQueryNameString)
#pragma alloc_text(PAGE, ObQueryNameString)
#pragma alloc_text(PAGE, ObQueryTypeName)
#pragma alloc_text(PAGE, ObQueryTypeInfo)
#pragma alloc_text(PAGE, ObQueryObjectAuditingByHandle)
#pragma alloc_text(PAGE, NtSetInformationObject)
#pragma alloc_text(PAGE, ObpSetHandleAttributes)
#pragma alloc_text(PAGE, ObSetHandleAttributes)

NTSTATUS
NtQueryObject (
    __in HANDLE Handle,
    __in OBJECT_INFORMATION_CLASS ObjectInformationClass,
    __out_bcount_opt(ObjectInformationLength) PVOID ObjectInformation,
    __in ULONG ObjectInformationLength,
    __out_opt PULONG ReturnLength
    )

/*++

Routine description:

    This routine is used to query information about a given object

Arguments:

    Handle - Supplies a handle to the object being queried.  This value
        is ignored if the requested information class is for type
        information.

    ObjectInformationClass - Specifies the type of information to return

    ObjectInformation - Supplies an output buffer for the information being
        returned

    ObjectInformationLength - Specifies, in bytes, the length of the
        preceding object information buffer

    ReturnLength - Optionally receives the length, in bytes, used to store
        the object information

Return Value:

    An appropriate status value

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_QUOTA_INFO QuotaInfo;
    POBJECT_HEADER_NAME_INFO NameInfo;
    POBJECT_TYPE ObjectType;
    POBJECT_HEADER ObjectDirectoryHeader;
    POBJECT_DIRECTORY ObjectDirectory;
    ACCESS_MASK GrantedAccess;
    POBJECT_HANDLE_FLAG_INFORMATION HandleFlags;
    OBJECT_HANDLE_INFORMATION HandleInformation = {0};
    ULONG NameInfoSize;
    ULONG SecurityDescriptorSize;
    ULONG TempReturnLength;
    OBJECT_BASIC_INFORMATION ObjectBasicInfo;
    POBJECT_TYPES_INFORMATION TypesInformation;
    POBJECT_TYPE_INFORMATION TypeInfo;
    ULONG i;

    PAGED_CODE();

    //
    //  Initialize our local variables
    //

    TempReturnLength = 0;

    //
    //  Get previous processor mode and probe output argument if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            if (ObjectInformationClass != ObjectHandleFlagInformation) {

                ProbeForWrite( ObjectInformation,
                               ObjectInformationLength,
                               sizeof( ULONG ));

            } else {

                ProbeForWrite( ObjectInformation,
                               ObjectInformationLength,
                               1 );
            }

            //
            //  We'll use a local temp return length variable to pass
            //  through to the later ob query calls which will increment
            //  its value.  We can't pass the users return length directly
            //  because the user might also be altering its value behind
            //  our back.
            //

            if (ARGUMENT_PRESENT( ReturnLength )) {

                ProbeForWriteUlong( ReturnLength );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }
    }

    //
    //  If the query is not for types information then we
    //  will have to get the object in question. Otherwise
    //  for types information there really isn't an object
    //  to grab.
    //

    if (ObjectInformationClass != ObjectTypesInformation) {

        Status = ObReferenceObjectByHandle( Handle,
                                            0,
                                            NULL,
                                            PreviousMode,
                                            &Object,
                                            &HandleInformation );

        if (!NT_SUCCESS( Status )) {

            return( Status );
        }

        GrantedAccess = HandleInformation.GrantedAccess;

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
        ObjectType = ObjectHeader->Type;

    } else {

        GrantedAccess = 0;
        Object = NULL;
        ObjectHeader = NULL;
        ObjectType = NULL;
        Status = STATUS_SUCCESS;
    }

    //
    //  Now process the particular information class being
    //  requested
    //

    switch( ObjectInformationClass ) {

    case ObjectBasicInformation:

        //
        //  Make sure the output buffer is long enough and then
        //  fill in the appropriate fields into our local copy
        //  of basic information.
        //

        if (ObjectInformationLength != sizeof( OBJECT_BASIC_INFORMATION )) {

            ObDereferenceObject( Object );

            return( STATUS_INFO_LENGTH_MISMATCH );
        }

        ObjectBasicInfo.Attributes = HandleInformation.HandleAttributes;

        if (ObjectHeader->Flags & OB_FLAG_PERMANENT_OBJECT) {

            ObjectBasicInfo.Attributes |= OBJ_PERMANENT;
        }

        if (ObjectHeader->Flags & OB_FLAG_EXCLUSIVE_OBJECT) {

            ObjectBasicInfo.Attributes |= OBJ_EXCLUSIVE;
        }

        ObjectBasicInfo.GrantedAccess = GrantedAccess;
        ObjectBasicInfo.HandleCount = (ULONG)ObjectHeader->HandleCount;
        ObjectBasicInfo.PointerCount = (ULONG)ObjectHeader->PointerCount;

        QuotaInfo = OBJECT_HEADER_TO_QUOTA_INFO( ObjectHeader );

        if (QuotaInfo != NULL) {

            ObjectBasicInfo.PagedPoolCharge = QuotaInfo->PagedPoolCharge;
            ObjectBasicInfo.NonPagedPoolCharge = QuotaInfo->NonPagedPoolCharge;

        } else {

            ObjectBasicInfo.PagedPoolCharge = 0;
            ObjectBasicInfo.NonPagedPoolCharge = 0;
        }

        if (ObjectType == ObpSymbolicLinkObjectType) {

            ObjectBasicInfo.CreationTime = ((POBJECT_SYMBOLIC_LINK)Object)->CreationTime;

        } else {

            RtlZeroMemory( &ObjectBasicInfo.CreationTime,
                           sizeof( ObjectBasicInfo.CreationTime ));
        }

        //
        //  Compute the size of the object name string by taking its name plus
        //  separators and traversing up to the root adding each directories
        //  name length plus separators
        //

        NameInfo = ObpReferenceNameInfo( ObjectHeader );

        if ((NameInfo != NULL) && (NameInfo->Directory != NULL)) {

            PVOID ReferencedDirectory = NULL;
        
            //
            //  We grab the root directory lock and test again the directory
            //

            ObjectDirectory = NameInfo->Directory;

            ASSERT (ObjectDirectory);

            ObfReferenceObject( ObjectDirectory );
            ReferencedDirectory = ObjectDirectory;

            NameInfoSize = sizeof( OBJ_NAME_PATH_SEPARATOR ) + NameInfo->Name.Length;

            ObpDereferenceNameInfo( NameInfo );
            NameInfo = NULL;

            while (ObjectDirectory) {

                ObjectDirectoryHeader = OBJECT_TO_OBJECT_HEADER( ObjectDirectory );
                NameInfo = ObpReferenceNameInfo( ObjectDirectoryHeader );

                if ((NameInfo != NULL) && (NameInfo->Directory != NULL)) {

                    NameInfoSize += sizeof( OBJ_NAME_PATH_SEPARATOR ) + NameInfo->Name.Length;
                        
                    ObjectDirectory = NameInfo->Directory;

                    ObfReferenceObject( ObjectDirectory );
                        
                    ObpDereferenceNameInfo( NameInfo );
                    NameInfo = NULL;
                    ObDereferenceObject( ReferencedDirectory );
                    ReferencedDirectory = ObjectDirectory;

                } else {

                    break;
                }
            }

            if (ReferencedDirectory) {

                ObDereferenceObject( ReferencedDirectory );
            }

            NameInfoSize += sizeof( OBJECT_NAME_INFORMATION ) + sizeof( UNICODE_NULL );

        } else {

            NameInfoSize = 0;
        }

        ObpDereferenceNameInfo( NameInfo );
        NameInfo = NULL;

        ObjectBasicInfo.NameInfoSize = NameInfoSize;
        ObjectBasicInfo.TypeInfoSize = ObjectType->Name.Length + sizeof( UNICODE_NULL ) +
                                        sizeof( OBJECT_TYPE_INFORMATION );
        
        if ((GrantedAccess & READ_CONTROL) &&
            ARGUMENT_PRESENT( ObjectHeader->SecurityDescriptor )) {

            SECURITY_INFORMATION SecurityInformation;

            //
            //  Request a complete security descriptor
            //

            SecurityInformation = OWNER_SECURITY_INFORMATION |
                                  GROUP_SECURITY_INFORMATION |
                                  DACL_SECURITY_INFORMATION  |
                                  SACL_SECURITY_INFORMATION;
            
            SecurityDescriptorSize = 0;

            (ObjectType->TypeInfo.SecurityProcedure)( Object,
                                                      QuerySecurityDescriptor,
                                                      &SecurityInformation,
                                                      NULL,
                                                      &SecurityDescriptorSize,
                                                      &ObjectHeader->SecurityDescriptor,
                                                      ObjectType->TypeInfo.PoolType,
                                                      &ObjectType->TypeInfo.GenericMapping );

        } else {

            SecurityDescriptorSize = 0;
        }

        ObjectBasicInfo.SecurityDescriptorSize = SecurityDescriptorSize;

        //
        //  Now that we've packaged up our local copy of basic info we need
        //  to copy it into the output buffer and set the return
        //  length
        //

        try {

            *(POBJECT_BASIC_INFORMATION) ObjectInformation = ObjectBasicInfo;

            TempReturnLength = ObjectInformationLength;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            // Fall through, since we cannot undo what we have done.
            //
        }

        break;

    case ObjectNameInformation:

        //
        //  Call a local worker routine
        //

        Status = ObpQueryNameString( Object,
                                     (POBJECT_NAME_INFORMATION)ObjectInformation,
                                     ObjectInformationLength,
                                     &TempReturnLength,
                                     PreviousMode );
        break;

    case ObjectTypeInformation:

        //
        //  Call a local worker routine
        //

        Status = ObQueryTypeInfo( ObjectType,
                                  (POBJECT_TYPE_INFORMATION)ObjectInformation,
                                  ObjectInformationLength,
                                  &TempReturnLength );
        break;

    case ObjectTypesInformation:

        try {

            //
            //  The first thing we do is set the return length to cover the
            //  types info record.  Later in each call to query type info
            //  this value will be updated as necessary
            //

            TempReturnLength = sizeof( OBJECT_TYPES_INFORMATION );

            //
            //  Make sure there is enough room to hold the types info record
            //  and if so then compute the number of defined types there are
            //

            TypesInformation = (POBJECT_TYPES_INFORMATION)ObjectInformation;

            if (ObjectInformationLength < sizeof( OBJECT_TYPES_INFORMATION ) ) {

                Status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                TypesInformation->NumberOfTypes = 0;

                for (i=0; i<OBP_MAX_DEFINED_OBJECT_TYPES; i++) {

                    ObjectType = ObpObjectTypes[ i ];

                    if (ObjectType == NULL) {

                        break;
                    }

                    TypesInformation->NumberOfTypes += 1;
                }
            }

            //
            //  For each defined type we will query the type info for the
            //  object type and adjust the TypeInfo pointer to the next
            //  free spot
            //

            TypeInfo = (POBJECT_TYPE_INFORMATION)(((PUCHAR)TypesInformation) + ALIGN_UP( sizeof(*TypesInformation), ULONG_PTR ));

            for (i=0; i<OBP_MAX_DEFINED_OBJECT_TYPES; i++) {

                ObjectType = ObpObjectTypes[ i ];

                if (ObjectType == NULL) {

                    break;
                }

                Status = ObQueryTypeInfo( ObjectType,
                                          TypeInfo,
                                          ObjectInformationLength,
                                          &TempReturnLength );

                if (NT_SUCCESS( Status )) {

                    TypeInfo = (POBJECT_TYPE_INFORMATION)
                        ((PCHAR)(TypeInfo+1) + ALIGN_UP( TypeInfo->TypeName.MaximumLength, ULONG_PTR ));
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

        break;

    case ObjectHandleFlagInformation:

        try {

            //
            //  Set the amount of data we are going to return
            //

            TempReturnLength = sizeof(OBJECT_HANDLE_FLAG_INFORMATION);

            HandleFlags = (POBJECT_HANDLE_FLAG_INFORMATION)ObjectInformation;

            //
            //  Make sure we have enough room for the query, and if so we'll
            //  set the output based on the flags stored in the handle
            //

            if (ObjectInformationLength < sizeof( OBJECT_HANDLE_FLAG_INFORMATION)) {

                Status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                HandleFlags->Inherit = FALSE;

                if (HandleInformation.HandleAttributes & OBJ_INHERIT) {

                    HandleFlags->Inherit = TRUE;
                }

                HandleFlags->ProtectFromClose = FALSE;

                if (HandleInformation.HandleAttributes & OBJ_PROTECT_CLOSE) {

                    HandleFlags->ProtectFromClose = TRUE;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

        break;

    default:

        //
        //  To get to this point we must have had an object and the
        //  information class is not defined, so we should dereference the
        //  object and return to our user the bad status
        //

        ObDereferenceObject( Object );

        return( STATUS_INVALID_INFO_CLASS );
    }

    //
    //  Now if the caller asked for a return length we'll set it from
    //  our local copy
    //

    try {

        if (ARGUMENT_PRESENT( ReturnLength ) ) {

            *ReturnLength = TempReturnLength;
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  Fall through, since we cannot undo what we have done.
        //
    }

    //
    //  In the end we can free the object if there was one and return
    //  to our caller
    //

    if (Object != NULL) {

        ObDereferenceObject( Object );
    }

    return( Status );
}

NTSTATUS
ObSetHandleAttributes (
    __in HANDLE Handle,
    __in POBJECT_HANDLE_FLAG_INFORMATION HandleFlags,
    __in KPROCESSOR_MODE PreviousMode
    )
{
    BOOLEAN AttachedToProcess = FALSE;
    KAPC_STATE ApcState;
    OBP_SET_HANDLE_ATTRIBUTES CapturedInformation;
    PVOID ObjectTable;
    HANDLE ObjectHandle;
    NTSTATUS Status;

    PAGED_CODE();

    CapturedInformation.PreviousMode = PreviousMode;
    CapturedInformation.ObjectInformation = *HandleFlags;

    //
    //  Get the address of the object table for the current process.  Or
    //  get the system handle table if this is a kernel handle and we are
    //  in kernel mode
    //

    if (IsKernelHandle( Handle, PreviousMode )) {

        //
        //  Make the handle look like a regular handle
        //

        ObjectHandle = DecodeKernelHandle( Handle );

        //
        //  The global kernel handle table
        //

        ObjectTable = ObpKernelHandleTable;

        //
        //  Go to the system process
        //

        if (PsGetCurrentProcess() != PsInitialSystemProcess) {
            KeStackAttachProcess (&PsInitialSystemProcess->Pcb, &ApcState);
            AttachedToProcess = TRUE;
        }

    } else {

        ObjectTable = ObpGetObjectTable();
        ObjectHandle = Handle;
    }

    //
    //  Make the change to the handle table entry.  The callback
    //  routine will do the actual change
    //

    if (ExChangeHandle( ObjectTable,
                        ObjectHandle,
                        ObpSetHandleAttributes,
                        (ULONG_PTR)&CapturedInformation) ) {

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_ACCESS_DENIED;
    }

    //
    //  If we are attached to the system process then return
    //  back to our caller
    //

    if (AttachedToProcess) {
        KeUnstackDetachProcess(&ApcState);
        AttachedToProcess = FALSE;
    }
    return Status;
}

NTSTATUS
NTAPI
NtSetInformationObject (
    __in HANDLE Handle,
    __in OBJECT_INFORMATION_CLASS ObjectInformationClass,
    __in_bcount(ObjectInformationLength) PVOID ObjectInformation,
    __in ULONG ObjectInformationLength
    )

/*++

Routine description:

    This routine is used to set handle information about a specified
    handle

Arguments:

    Handle - Supplies the handle being modified

    ObjectInformationClass - Specifies the class of information being
        modified.  The only accepted value is ObjectHandleFlagInformation

    ObjectInformation - Supplies the buffer containing the handle
        flag information structure

    ObjectInformationLength - Specifies the length, in bytes, of the
        object information buffer

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION CapturedFlags;
    KPROCESSOR_MODE PreviousMode;

    PAGED_CODE();


    Status = STATUS_INVALID_INFO_CLASS;

    switch (ObjectInformationClass) {
         
        case ObjectHandleFlagInformation:
            {
                if (ObjectInformationLength != sizeof(OBJECT_HANDLE_FLAG_INFORMATION)) {

                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                //
                //  Get previous processor mode and probe and capture the input
                //  buffer
                //

                PreviousMode = KeGetPreviousMode();

                try {

                    if (PreviousMode != KernelMode) {

                        ProbeForRead(ObjectInformation, ObjectInformationLength, 1);
                    }

                    CapturedFlags = *(POBJECT_HANDLE_FLAG_INFORMATION)ObjectInformation;

                } except(ExSystemExceptionFilter()) {

                    return GetExceptionCode();
                }

                Status = ObSetHandleAttributes (Handle,
                                                &CapturedFlags,
                                                PreviousMode);

            }

            break;
        
        case ObjectSessionInformation:
            {
                PreviousMode = KeGetPreviousMode();

                if (!SeSinglePrivilegeCheck( SeTcbPrivilege,
                                             PreviousMode)) {

                    Status = STATUS_PRIVILEGE_NOT_HELD;

                } else {
                    
                    PVOID Object;
                    OBJECT_HANDLE_INFORMATION HandleInformation;

                    Status = ObReferenceObjectByHandle(Handle, 
                                                       0, 
                                                       ObpDirectoryObjectType,
                                                       PreviousMode,
                                                       &Object,
                                                       &HandleInformation
                                                       );

                    if (NT_SUCCESS(Status)) {

                        POBJECT_DIRECTORY Directory;
                        OBP_LOOKUP_CONTEXT LockContext;
                        Directory = (POBJECT_DIRECTORY)Object;

                        ObpInitializeLookupContext( &LockContext );
                        
                        ObpLockDirectoryExclusive(Directory, &LockContext);

                        Directory->SessionId = PsGetCurrentProcessSessionId();

                        ObpUnlockDirectory(Directory, &LockContext);

                        ObDereferenceObject(Object);
                    }
                }
            }

            break;
    }

    //
    //  And return to our caller
    //

    return Status;
}


#define OBP_MISSING_NAME_LITERAL L"..."
#define OBP_MISSING_NAME_LITERAL_SIZE (sizeof( OBP_MISSING_NAME_LITERAL ) - sizeof( UNICODE_NULL ))

NTSTATUS
ObQueryNameString (
    __in PVOID Object,
    __out_bcount(Length) POBJECT_NAME_INFORMATION ObjectNameInfo,
    __in ULONG Length,
    __out PULONG ReturnLength
    )
/*++

Routine description:

    This routine processes a query of an object's name information

Arguments:

    Object - Supplies the object being queried

    ObjectNameInfo - Supplies the buffer to store the name string
        information

    Length - Specifies the length, in bytes, of the original object
        name info buffer.

    ReturnLength - Contains the number of bytes already used up
        in the object name info. On return this receives an updated
        byte count.

        (Length minus ReturnLength) is really now many bytes are left
        in the output buffer.  The buffer supplied to this call may
        actually be offset within the original users buffer

Return Value:

    An appropriate status value

--*/

{
    return ObpQueryNameString( Object,
                               ObjectNameInfo,
                               Length,
                               ReturnLength,
                               KernelMode );
}

NTSTATUS
ObpQueryNameString (
    IN PVOID Object,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    )

/*++

Routine description:

    This routine processes a query of an object's name information

Arguments:

    Object - Supplies the object being queried

    ObjectNameInfo - Supplies the buffer to store the name string
        information

    Length - Specifies the length, in bytes, of the original object
        name info buffer.

    ReturnLength - Contains the number of bytes already used up
        in the object name info. On return this receives an updated
        byte count.

        (Length minus ReturnLength) is really now many bytes are left
        in the output buffer.  The buffer supplied to this call may
        actually be offset within the original users buffer

    Mode - Mode of caller

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;
    POBJECT_HEADER ObjectDirectoryHeader;
    POBJECT_DIRECTORY ObjectDirectory;
    ULONG NameInfoSize = 0;
    PUNICODE_STRING String;
    PWCH StringBuffer;
    ULONG NameSize;
    PVOID ReferencedObject = NULL;
    BOOLEAN DoFullQuery = TRUE;
    ULONG BufferLength;
    PWCH OriginalBuffer;
    BOOLEAN ForceRetry = FALSE;

    PAGED_CODE();

    //
    //  Get the object header and name info record if it exists
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    NameInfo = ObpReferenceNameInfo( ObjectHeader );

    //
    //  If the object type has a query name callback routine then
    //  that is how we get the name
    //

    if (ObjectHeader->Type->TypeInfo.QueryNameProcedure != NULL) {

        try {

#if DBG
            KIRQL SaveIrql;
#endif

            ObpBeginTypeSpecificCallOut( SaveIrql );
            ObpEndTypeSpecificCallOut( SaveIrql, "Query", ObjectHeader->Type, Object );

            Status = (*ObjectHeader->Type->TypeInfo.QueryNameProcedure)( Object,
                                                                         (BOOLEAN)((NameInfo != NULL) && (NameInfo->Name.Length != 0)),
                                                                         ObjectNameInfo,
                                                                         Length,
                                                                         ReturnLength,
                                                                         Mode );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

        ObpDereferenceNameInfo( NameInfo );

        return( Status );
    }

    //
    //  Otherwise, the object type does not specify a query name
    //  procedure so we get to do the work.  The first thing
    //  to check is if the object doesn't even have a name.  If
    //  object doesn't have a name then we'll return an empty name
    //  info structure.
    //

RETRY:
    if ((NameInfo == NULL) || (NameInfo->Name.Buffer == NULL)) {

        //
        //  Compute the length of our return buffer, set the output
        //  if necessary and make sure the supplied buffer is large
        //  enough
        //

        NameInfoSize = sizeof( OBJECT_NAME_INFORMATION );

        try {

            *ReturnLength = NameInfoSize;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            ObpDereferenceNameInfo( NameInfo );

            return( GetExceptionCode() );
        }

        if (Length < NameInfoSize) {

            ObpDereferenceNameInfo( NameInfo );

            return( STATUS_INFO_LENGTH_MISMATCH );
        }

        //
        //  Initialize the output buffer to be an empty string
        //  and then return to our caller
        //

        try {

            ObjectNameInfo->Name.Length = 0;
            ObjectNameInfo->Name.MaximumLength = 0;
            ObjectNameInfo->Name.Buffer = NULL;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  Fall through, since we cannot undo what we have done.
            //
            ObpDereferenceNameInfo(NameInfo);

            return( GetExceptionCode() );
        }

        ObpDereferenceNameInfo(NameInfo);

        return( STATUS_SUCCESS );
    }

    try {

        //
        //  The object does have a name but now see if this is
        //  just the root directory object in which case the name size
        //  is only the "\" character
        //

        if (Object == ObpRootDirectoryObject) {

            NameSize = sizeof( OBJ_NAME_PATH_SEPARATOR );

        } else {

            //
            //  The named object is not the root so for every directory
            //  working out way up we'll add its size to the name keeping
            //  track of "\" characters inbetween each component.  We first
            //  start with the object name itself and then move on to
            //  the directories
            //

            ObjectDirectory = NameInfo->Directory;
            
            if (ObjectDirectory) {
                
                ObfReferenceObject( ObjectDirectory );
                ReferencedObject = ObjectDirectory;
            }
            
            NameSize = sizeof( OBJ_NAME_PATH_SEPARATOR ) + NameInfo->Name.Length;

            ObpDereferenceNameInfo( NameInfo );
            NameInfo = NULL;

            //
            //  While we are not at the root we'll keep moving up
            //

            while ((ObjectDirectory != ObpRootDirectoryObject) && (ObjectDirectory)) {

                //
                //  Get the name information for this directory
                //


                ObjectDirectoryHeader = OBJECT_TO_OBJECT_HEADER( ObjectDirectory );
                NameInfo = ObpReferenceNameInfo( ObjectDirectoryHeader );

                if ((NameInfo != NULL) && (NameInfo->Directory != NULL)) {

                    //
                    //  This directory has a name so add it to the accumulated
                    //  size and move up the tree
                    //

                    NameSize += sizeof( OBJ_NAME_PATH_SEPARATOR ) + NameInfo->Name.Length;
                    
                    ObjectDirectory = NameInfo->Directory;

                    if (ObjectDirectory) {

                        ObfReferenceObject( ObjectDirectory );
                    }
                    
                    ObpDereferenceNameInfo( NameInfo );
                    NameInfo = NULL;
                    ObDereferenceObject( ReferencedObject );
                    
                    ReferencedObject = ObjectDirectory;

                    //
                    //  UNICODE_STRINGs can only hold MAXUSHORT bytes.
                    //

                    if (NameSize > MAXUSHORT) {

                        break;
                    }

                } else {

                    //
                    //  This directory does not have a name so we'll give it
                    //  the "..." name and stop the loop
                    //

                    NameSize += sizeof( OBJ_NAME_PATH_SEPARATOR ) + OBP_MISSING_NAME_LITERAL_SIZE;
                    break;
                }
            }
        }

        //
        //  UNICODE_STRINGs can only hold MAXUSHORT bytes
        //

        if (NameSize > MAXUSHORT) {

            Status = STATUS_NAME_TOO_LONG;
            DoFullQuery = FALSE;
            leave;
        }

        //
        //  At this point NameSize is the number of bytes we need to store the
        //  name of the object from the root down.  The total buffer size we are
        //  going to need will include this size, plus object name information
        //  structure, plus an ending null character
        //

        NameInfoSize = NameSize + sizeof( OBJECT_NAME_INFORMATION ) + sizeof( UNICODE_NULL );

        //
        //  Set the output size and make sure the supplied buffer is large enough
        //  to hold the information
        //

        try {

            *ReturnLength = NameInfoSize;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            DoFullQuery = FALSE;
            leave;
        }

        if (Length < NameInfoSize) {

            Status = STATUS_INFO_LENGTH_MISMATCH;
            DoFullQuery = FALSE;
            leave;
        }

    } finally {

        ObpDereferenceNameInfo( NameInfo );
        NameInfo = NULL;

        if (ReferencedObject) {

            ObDereferenceObject( ReferencedObject );
            ReferencedObject = NULL;
        }
    }
    
    if (!DoFullQuery) {

        return Status;
    }

    NameInfo = ObpReferenceNameInfo( ObjectHeader );

    //
    //  Check whether someone else removed the name meanwhile
    //

    if (!NameInfo) {

        //
        //  The name is gone, we need to jump to the code path that handles
        //  empty object name
        //

        goto RETRY;
    }

    //
    //  Set the String buffer to point to the byte right after the
    //  last byte in the output string.  This following logic actually
    //  fills in the buffer backwards working from the name back to the
    //  root
    //

    StringBuffer = (PWCH)ObjectNameInfo;
    StringBuffer = (PWCH)((PCH)StringBuffer + NameInfoSize);
    OriginalBuffer = (PWCH)((PCH)ObjectNameInfo + sizeof( OBJECT_NAME_INFORMATION ));

    try {

        //
        //  Terminate the string with a null and backup one unicode
        //  character
        //

        *--StringBuffer = UNICODE_NULL;

        //
        //  If the object in question is not the root directory
        //  then we are going to put its name in the string buffer
        //  When we finally reach the root directory we'll append on
        //  the final "\"
        //

        if (Object != ObpRootDirectoryObject) {

            //
            //  Add in the objects name
            //

            String = &NameInfo->Name;
            StringBuffer = (PWCH)((PCH)StringBuffer - String->Length);

            if (StringBuffer <= OriginalBuffer) {

                ForceRetry = TRUE;
                leave;
            }

            RtlCopyMemory( StringBuffer, String->Buffer, String->Length );

            //
            //  While we are not at the root directory we'll keep
            //  moving up
            //

            ObjectDirectory = NameInfo->Directory;

            if (ObjectDirectory) {

                //
                //  Reference the directory for this object to make sure it's
                //  valid while looking up
                //

                ObfReferenceObject( ObjectDirectory );
                ReferencedObject = ObjectDirectory;
            }
                
            ObpDereferenceNameInfo( NameInfo );
            NameInfo = NULL;

            while ((ObjectDirectory != ObpRootDirectoryObject) && (ObjectDirectory)) {

                //
                //  Get the name information for this directory
                //

                ObjectDirectoryHeader = OBJECT_TO_OBJECT_HEADER( ObjectDirectory );
                NameInfo = ObpReferenceNameInfo( ObjectDirectoryHeader );

                //
                //  Tack on the "\" between the last name we added and
                //  this new name
                //

                *--StringBuffer = OBJ_NAME_PATH_SEPARATOR;

                //
                //  Preappend the directory name, if it has one, and
                //  move up to the next directory.
                //

                if ((NameInfo != NULL) && (NameInfo->Directory != NULL)) {

                    String = &NameInfo->Name;
                    StringBuffer = (PWCH)((PCH)StringBuffer - String->Length);
                    
                    if (StringBuffer <= OriginalBuffer) {
                        
                        ForceRetry = TRUE;
                        leave;
                    }

                    RtlCopyMemory( StringBuffer, String->Buffer, String->Length );

                    ObjectDirectory = NameInfo->Directory;

                    if (ObjectDirectory) {

                        ObfReferenceObject( ObjectDirectory );
                    }

                    //
                    //  Dereference the name info (it must be done before dereferencing the object)
                    //

                    ObpDereferenceNameInfo( NameInfo );
                    NameInfo = NULL;

                    ObDereferenceObject( ReferencedObject );

                    ReferencedObject = ObjectDirectory;

                } else {

                    //
                    //  The directory is nameless so use the "..." for
                    //  its name and break out of the loop
                    //

                    StringBuffer = (PWCH)((PCH)StringBuffer - OBP_MISSING_NAME_LITERAL_SIZE);

                    //
                    //  Because we don't hold the global lock any more, we can have a special case
                    //  where a directory of 1 or 2 letters name AND inserted into the root
                    //  can go away meanwhile and "..." will be too long to fit the remaining space
                    //  We already copied the buffer so we cannot rollback everything we done.
                    //  We'll return \..  if the original directory was 1 char length,
                    //  \..\ for 2 char length
                    //

                    if (StringBuffer < OriginalBuffer) {

                        StringBuffer = OriginalBuffer;
                    }

                    RtlCopyMemory( StringBuffer,
                                   OBP_MISSING_NAME_LITERAL,
                                   OBP_MISSING_NAME_LITERAL_SIZE );

                    //
                    //  Test if we are in the case commented above. If yes, we need to move the 
                    //  current pointer to the next char, so the final assignment for \ a few lines
                    //  below will take effect on the start of the block.
                    //

                    if (StringBuffer == OriginalBuffer) {

                        StringBuffer++;
                    }

                    break;
                }
            }
        }

        //
        //  Tack on the "\" for the root directory and then set the
        //  output unicode string variable to have the right size
        //  and point to the right spot.
        //

        *--StringBuffer = OBJ_NAME_PATH_SEPARATOR;

        BufferLength = (USHORT)((ULONG_PTR)ObjectNameInfo + NameInfoSize - (ULONG_PTR)StringBuffer);

        ObjectNameInfo->Name.MaximumLength = (USHORT)BufferLength;
        ObjectNameInfo->Name.Length = (USHORT)(BufferLength - sizeof( UNICODE_NULL ));
        ObjectNameInfo->Name.Buffer = OriginalBuffer;

        //
        //  If one of the parent directories disappeared, the final length
        //  will be smaller than we estimated before. We need to move the string to
        //  the beginning and adjust the returned size.
        //

        if (OriginalBuffer != StringBuffer) {

            RtlMoveMemory(OriginalBuffer, StringBuffer, BufferLength);
            
            *ReturnLength = BufferLength + sizeof( OBJECT_NAME_INFORMATION );
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  Fall through, since we cannot undo what we have done.
        //
        //  This should probably get the exception code and return
        //  that value. However, the caller we'll get an exception
        //  at the first access of the ObjectNameInfo
        //
    }

    ObpDereferenceNameInfo( NameInfo );
    
    if (ReferencedObject) {

        ObDereferenceObject( ReferencedObject );
    }

    if (ForceRetry) {

        //
        //  The query failed maybe because the object name changed during the query
        //
        
        NameInfo = ObpReferenceNameInfo( ObjectHeader );
        ForceRetry = FALSE;

        goto RETRY;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
ObQueryTypeName (
    IN PVOID Object,
    PUNICODE_STRING ObjectTypeName,
    IN ULONG Length,
    OUT PULONG ReturnLength
    )

/*++

Routine description:

    This routine processes a query of an object's type name

Arguments:

    Object - Supplies the object being queried

    ObjectTypeName - Supplies the buffer to store the type name
        string information

    Length - Specifies the length, in bytes, of the object type
        name buffer

    ReturnLength - Contains the number of bytes already used up
        in the object type name buffer. On return this receives
        an updated byte count

        (Length minus ReturnLength) is really now many bytes are left
        in the output buffer.  The buffer supplied to this call may
        actually be offset within the original users buffer

Return Value:

    An appropriate status value

--*/

{
    POBJECT_TYPE ObjectType;
    POBJECT_HEADER ObjectHeader;
    ULONG TypeNameSize;
    PUNICODE_STRING String;
    PWCH StringBuffer;
    ULONG NameSize;

    PAGED_CODE();

    //
    //  From the object get its object type and from that get the size of
    //  the object type name.  The total size for we need for the output
    //  buffer must fit the name, a terminating null, and a preceding
    //  unicode string structure
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    NameSize = ObjectType->Name.Length;
    TypeNameSize = NameSize + sizeof( UNICODE_NULL ) + sizeof( UNICODE_STRING );

    //
    //  Update the number of bytes we need and make sure the output buffer is
    //  large enough
    //

    try {

        *ReturnLength = TypeNameSize;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        return( GetExceptionCode() );
    }

    if (Length < TypeNameSize) {

        return( STATUS_INFO_LENGTH_MISMATCH );
    }

    //
    //  Set string buffer to point to the one byte beyond the
    //  buffer that we're going to fill in
    //

    StringBuffer = (PWCH)ObjectTypeName;
    StringBuffer = (PWCH)((PCH)StringBuffer + TypeNameSize);

    String = &ObjectType->Name;

    try {

        //
        //  Tack on the terminating null character and copy over
        //  the type name
        //

        *--StringBuffer = UNICODE_NULL;

        StringBuffer = (PWCH)((PCH)StringBuffer - String->Length);

        RtlCopyMemory( StringBuffer, String->Buffer, String->Length );

        //
        //  Now set the preceding unicode string to have the right
        //  lengths and to point to this buffer
        //

        ObjectTypeName->Length = (USHORT)NameSize;
        ObjectTypeName->MaximumLength = (USHORT)(NameSize+sizeof( UNICODE_NULL ));
        ObjectTypeName->Buffer = StringBuffer;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Fall through, since we cannot undo what we have done.
        //
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
ObQueryTypeInfo (
    IN POBJECT_TYPE ObjectType,
    OUT POBJECT_TYPE_INFORMATION ObjectTypeInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    )

/*++

Routine description:

    This routine processes the query for object type information

Arguments:

    Object - Supplies a pointer to the object type being queried

    ObjectTypeInfo - Supplies the buffer to store the type information

    Length - Specifies the length, in bytes, of the object type
        information buffer

    ReturnLength - Contains the number of bytes already used up
        in the object type information buffer. On return this receives
        an updated byte count

        (Length minus ReturnLength) is really now many bytes are left
        in the output buffer.  The buffer supplied to this call may
        actually be offset within the original users buffer

Return Value:

    An appropriate status value

--*/

{
    NTSTATUS Status;

    try {

        //
        //  The total number of bytes needed for this query includes the
        //  object type information structure plus the name of the type
        //  rounded up to a ulong boundary
        //

        *ReturnLength += sizeof( *ObjectTypeInfo ) + ALIGN_UP( ObjectType->Name.MaximumLength, ULONG );

        //
        //  Make sure the buffer is large enough for this information and
        //  then fill in the record
        //

        if (Length < *ReturnLength) {

            Status = STATUS_INFO_LENGTH_MISMATCH;

        } else {

            ObjectTypeInfo->TotalNumberOfObjects = ObjectType->TotalNumberOfObjects;
            ObjectTypeInfo->TotalNumberOfHandles = ObjectType->TotalNumberOfHandles;
            ObjectTypeInfo->HighWaterNumberOfObjects = ObjectType->HighWaterNumberOfObjects;
            ObjectTypeInfo->HighWaterNumberOfHandles = ObjectType->HighWaterNumberOfHandles;
            ObjectTypeInfo->InvalidAttributes = ObjectType->TypeInfo.InvalidAttributes;
            ObjectTypeInfo->GenericMapping = ObjectType->TypeInfo.GenericMapping;
            ObjectTypeInfo->ValidAccessMask = ObjectType->TypeInfo.ValidAccessMask;
            ObjectTypeInfo->SecurityRequired = ObjectType->TypeInfo.SecurityRequired;
            ObjectTypeInfo->MaintainHandleCount = ObjectType->TypeInfo.MaintainHandleCount;
            ObjectTypeInfo->PoolType = ObjectType->TypeInfo.PoolType;
            ObjectTypeInfo->DefaultPagedPoolCharge = ObjectType->TypeInfo.DefaultPagedPoolCharge;
            ObjectTypeInfo->DefaultNonPagedPoolCharge = ObjectType->TypeInfo.DefaultNonPagedPoolCharge;

            //
            //  The type name goes right after this structure.  We cannot use
            //  rtl routine like RtlCopyUnicodeString that might use the local
            //  memory to keep state, because this is the user buffer and it
            //  could be changing by user
            //

            ObjectTypeInfo->TypeName.Buffer = (PWSTR)(ObjectTypeInfo+1);
            ObjectTypeInfo->TypeName.Length = ObjectType->Name.Length;
            ObjectTypeInfo->TypeName.MaximumLength = ObjectType->Name.MaximumLength;

            RtlCopyMemory( (PWSTR)(ObjectTypeInfo+1),
                           ObjectType->Name.Buffer,
                           ObjectType->Name.Length );

            ((PWSTR)(ObjectTypeInfo+1))[ ObjectType->Name.Length/sizeof(WCHAR) ] = UNICODE_NULL;

            Status = STATUS_SUCCESS;
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
    }

    return Status;
}


NTSTATUS
ObQueryObjectAuditingByHandle (
    __in HANDLE Handle,
    __out PBOOLEAN GenerateOnClose
    )

/*++

Routine description:

    This routine tells the caller if the indicated handle will
    generate an audit if it is closed

Arguments:

    Handle - Supplies the handle being queried

    GenerateOnClose - Receives TRUE if the handle will generate
        an audit if closed and FALSE otherwise

Return Value:

    An appropriate status value

--*/

{
    PHANDLE_TABLE ObjectTable;
    PHANDLE_TABLE_ENTRY ObjectTableEntry;
    ULONG CapturedAttributes;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    PAGED_CODE();

    ObpValidateIrql( "ObQueryObjectAuditingByHandle" );

    CurrentThread = PsGetCurrentThread ();

    //
    //  For the current process we'll grab its object table and
    //  then get the object table entry
    //

    if (IsKernelHandle( Handle, KeGetPreviousMode() ))  {

        Handle = DecodeKernelHandle( Handle );

        ObjectTable = ObpKernelHandleTable;

    } else {

        ObjectTable = PsGetCurrentProcessByThread (CurrentThread)->ObjectTable;
    }

    //
    //  Protect ourselves from being interrupted while we hold a handle table
    //  entry lock
    //

    KeEnterCriticalRegionThread(&CurrentThread->Tcb);

    ObjectTableEntry = ExMapHandleToPointer( ObjectTable,
                                             Handle );

    //
    //  If we were given a valid handle we'll look at the attributes
    //  stored in the object table entry to decide if we generate
    //  an audit on close
    //

    if (ObjectTableEntry != NULL) {

        CapturedAttributes = ObjectTableEntry->ObAttributes;

        ExUnlockHandleTableEntry( ObjectTable, ObjectTableEntry );

        if (CapturedAttributes & OBJ_AUDIT_OBJECT_CLOSE) {

            *GenerateOnClose = TRUE;

        } else {

            *GenerateOnClose = FALSE;
        }

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_INVALID_HANDLE;
    }

    KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

    return Status;
}


#if DBG
PUNICODE_STRING
ObGetObjectName (
    IN PVOID Object
    )

/*++

Routine description:

    This routine returns a pointer to the name of object

Arguments:

    Object - Supplies the object being queried

Return Value:

    The address of the unicode string that stores the object
    name if available and NULL otherwise

--*/

{
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_NAME_INFO NameInfo;

    //
    //  Translate the input object to a name info structure
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

    //
    //  If the object has a name then return the address of
    //  the name otherwise return null
    //

    if ((NameInfo != NULL) && (NameInfo->Name.Length != 0)) {

        return &NameInfo->Name;

    } else {

        return NULL;
    }
}
#endif // DBG


//
//  Local support routine
//

BOOLEAN
ObpSetHandleAttributes (
    IN OUT PHANDLE_TABLE_ENTRY ObjectTableEntry,
    IN ULONG_PTR Parameter
    )

/*++

Routine description:

    This is the call back routine for the ExChangeHandle from
    NtSetInformationObject

Arguments:

    ObjectTableEntry - Supplies a pointer to the object table entry being
        modified

    Parameter - Supplies a pointer to the OBJECT_HANDLE_FLAG_INFORMATION
        structure to set into the table entry

Return Value:

    Returns TRUE if the operation is successful otherwise FALSE

--*/

{
    POBP_SET_HANDLE_ATTRIBUTES ObjectInformation;
    POBJECT_HEADER ObjectHeader;

    ObjectInformation = (POBP_SET_HANDLE_ATTRIBUTES)Parameter;

    //
    //  Get a pointer to the object type via the object header and if the
    //  caller has asked for inherit but the object type says that inherit
    //  is an invalid flag then return false
    //

    ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(ObjectTableEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

    if ((ObjectInformation->ObjectInformation.Inherit) &&
        ((ObjectHeader->Type->TypeInfo.InvalidAttributes & OBJ_INHERIT) != 0)) {

        return FALSE;
    }

    //
    //  For each piece of information (inherit and protect from close) that
    //  is in the object information buffer we'll set or clear the bits in
    //  the object table entry.  The bits modified are the low order bits of
    //  used to store the pointer to the object header.
    //

    if (ObjectInformation->ObjectInformation.Inherit) {

        ObjectTableEntry->ObAttributes |= OBJ_INHERIT;

    } else {

        ObjectTableEntry->ObAttributes &= ~OBJ_INHERIT;
    }

    if (ObjectInformation->ObjectInformation.ProtectFromClose) {
        
        ObjectTableEntry->GrantedAccess |= ObpAccessProtectCloseBit;

    } else {

        ObjectTableEntry->GrantedAccess &= ~ObpAccessProtectCloseBit;
    }

    //
    //  And return to our caller
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obsdata.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obsdata.c

Abstract:

    Object Manager Security Descriptor Caching

Revision History:

    General cleanup. Don't free/allocate pool under locks. Don't do unaligned fetches during hashing.
    Reduce lock contention etc. Add fast referencing of security descriptor.

--*/

#include "obp.h"


#if DBG
#define OB_DIAGNOSTICS_ENABLED 1
#endif // DBG

//
//  These definitions are useful diagnostics aids
//

#if OB_DIAGNOSTICS_ENABLED

//
//  Test for enabled diagnostic
//

#define IF_OB_GLOBAL( FlagName ) if (ObsDebugFlags & (OBS_DEBUG_##FlagName))

//
//  Diagnostics print statement
//

#define ObPrint( FlagName, _Text_ ) IF_OB_GLOBAL( FlagName ) DbgPrint _Text_

#else

//
//  diagnostics not enabled - No diagnostics included in build
//

//
//  Test for diagnostics enabled
//

#define IF_OB_GLOBAL( FlagName ) if (FALSE)

//
//  Diagnostics print statement (expands to no-op)
//

#define ObPrint( FlagName, _Text_ )     ;

#endif // OB_DIAGNOSTICS_ENABLED


//
//  The following flags enable or disable various diagnostic
//  capabilities within OB code.  These flags are set in
//  ObGlobalFlag (only available within a DBG system).
//
//

#define OBS_DEBUG_ALLOC_TRACKING          ((ULONG) 0x00000001L)
#define OBS_DEBUG_CACHE_FREES             ((ULONG) 0x00000002L)
#define OBS_DEBUG_BREAK_ON_INIT           ((ULONG) 0x00000004L)
#define OBS_DEBUG_SHOW_COLLISIONS         ((ULONG) 0x00000008L)
#define OBS_DEBUG_SHOW_STATISTICS         ((ULONG) 0x00000010L)
#define OBS_DEBUG_SHOW_REFERENCES         ((ULONG) 0x00000020L)
#define OBS_DEBUG_SHOW_DEASSIGN           ((ULONG) 0x00000040L)
#define OBS_DEBUG_STOP_INVALID_DESCRIPTOR ((ULONG) 0x00000080L)
#define OBS_DEBUG_SHOW_HEADER_FREE        ((ULONG) 0x00000100L)

//
// Define struct of single hash clash chain
//
typedef struct _OB_SD_CACHE_LIST {
    EX_PUSH_LOCK PushLock;
    LIST_ENTRY Head;
} OB_SD_CACHE_LIST, *POB_SD_CACHE_LIST;
//
//  Array of pointers to security descriptor entries
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

OB_SD_CACHE_LIST ObsSecurityDescriptorCache[SECURITY_DESCRIPTOR_CACHE_ENTRIES];

#if OB_DIAGNOSTICS_ENABLED

LONG ObsTotalCacheEntries = 0;
ULONG ObsDebugFlags = 0;

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif


#if defined (ALLOC_PRAGMA)
#pragma alloc_text(INIT,ObpInitSecurityDescriptorCache)
#pragma alloc_text(PAGE,ObpHashSecurityDescriptor)
#pragma alloc_text(PAGE,ObpHashBuffer)
#pragma alloc_text(PAGE,ObLogSecurityDescriptor)
#pragma alloc_text(PAGE,ObpCreateCacheEntry)
#pragma alloc_text(PAGE,ObpReferenceSecurityDescriptor)
#pragma alloc_text(PAGE,ObDeassignSecurity)
#pragma alloc_text(PAGE,ObDereferenceSecurityDescriptor)
#pragma alloc_text(PAGE,ObpDestroySecurityDescriptorHeader)
#pragma alloc_text(PAGE,ObpCompareSecurityDescriptors)
#pragma alloc_text(PAGE,ObReferenceSecurityDescriptor)
#endif



NTSTATUS
ObpInitSecurityDescriptorCache (
    VOID
    )

/*++

Routine Description:

    Allocates and initializes the globalSecurity Descriptor Cache

Arguments:

    None

Return Value:

    STATUS_SUCCESS on success, NTSTATUS on failure.

--*/

{
    ULONG i;

    IF_OB_GLOBAL( BREAK_ON_INIT ) {

        DbgBreakPoint();
    }

    //
    // Initialize all the list heads and their associated locks.
    //
    for (i = 0; i < SECURITY_DESCRIPTOR_CACHE_ENTRIES; i++) {
        ExInitializePushLock (&ObsSecurityDescriptorCache[i].PushLock);
        InitializeListHead (&ObsSecurityDescriptorCache[i].Head);
    }

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}


ULONG
ObpHashSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Length
    )

/*++

Routine Description:

    Hashes a security descriptor to a 32 bit value

Arguments:

    SecurityDescriptor - Provides the security descriptor to be hashed
    Length - Length of security descriptor

Return Value:

    ULONG - a 32 bit hash value.

--*/

{
    ULONG Hash;

    Hash = ObpHashBuffer (SecurityDescriptor, Length);

    return Hash;
}


ULONG
ObpHashBuffer (
    PVOID Data,
    ULONG Length
    )

/*++

Routine Description:

    Hashes a buffer into a 32 bit value

Arguments:

    Data - Buffer containing the data to be hashed.

    Length - The length in bytes of the buffer


Return Value:

    ULONG - a 32 bit hash value.

--*/

{
    PULONG Buffer, BufferEnd;
    PUCHAR Bufferp, BufferEndp;

    ULONG Result = 0;

    //
    // Calculate buffer bounds as byte pointers
    //
    Bufferp = Data;
    BufferEndp = Bufferp + Length;

    //
    // Calculate buffer bounds as rounded down ULONG pointers
    //
    Buffer = Data;
    BufferEnd = (PULONG)(Bufferp + (Length&~(sizeof (ULONG) - 1)));

    //
    // Loop over a whole number of ULONGs
    //
    while (Buffer < BufferEnd) {
        Result ^= *Buffer++;
        Result = _rotl (Result, 3);
    }

    //
    // Pull in the remaining bytes
    //
    Bufferp = (PUCHAR) Buffer;
    while (Bufferp < BufferEndp) {
        Result ^= *Bufferp++;
        Result = _rotl (Result, 3);
    }

    

    return Result;
}


NTSTATUS
ObLogSecurityDescriptor (
    __in PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    __out PSECURITY_DESCRIPTOR *OutputSecurityDescriptor,
    __in ULONG RefBias
    )

/*++

Routine Description:

    Takes a passed security descriptor and registers it into the
    security descriptor database.

Arguments:

    InputSecurityDescriptor - The new security descriptor to be logged into
        the database. On a successful return this memory will have been
        freed back to pool.

    OutputSecurityDescriptor - Output security descriptor to be used by the
        caller.

    RefBias - Amount to bias the security descriptor reference count by.
              Typically either 1 or ExFastRefGetAdditionalReferenceCount () + 1,

Return Value:

    An appropriate status value

--*/

{
    ULONG FullHash;
    ULONG Slot;
    PSECURITY_DESCRIPTOR_HEADER NewDescriptor;
    PLIST_ENTRY Front;
    PSECURITY_DESCRIPTOR_HEADER Header = NULL;
    BOOLEAN Match;
    POB_SD_CACHE_LIST Chain;
    PETHREAD CurrentThread;
    ULONG Length;

    Length = RtlLengthSecurityDescriptor (InputSecurityDescriptor);

    FullHash = ObpHashSecurityDescriptor (InputSecurityDescriptor, Length);

    Slot = FullHash % SECURITY_DESCRIPTOR_CACHE_ENTRIES;

    NewDescriptor = NULL;

    //
    // First lock the table for read access. We will change this to write if we have to insert later
    //
    Chain = &ObsSecurityDescriptorCache[Slot];

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockShared (&Chain->PushLock);

    do {
        //
        //  See if the list for this slot is in use.
        //  Lock the table first, unlock if if we don't need it.
        //
        Match = FALSE;

        //
        //  Zoom down the hash bucket looking for a full hash match
        //

        for (Front = Chain->Head.Flink;
             Front != &Chain->Head;
             Front = Front->Flink) {

            Header = LINK_TO_SD_HEADER (Front);

            //
            // The list is ordered by full hash value and is maintained this way by virtue
            // of the fact that we use the 'Back' variable for the insert.
            //

            if (Header->FullHash > FullHash) {
                break;
            }

            if (Header->FullHash == FullHash) {

                Match = ObpCompareSecurityDescriptors (InputSecurityDescriptor,
                                                       Length,
                                                       &Header->SecurityDescriptor);

                if (Match) {

                    break;
                }

                ObPrint (SHOW_COLLISIONS, ("Got a collision on %d, no match\n", Slot));
            }
        }

        //
        //  If we have a match then we'll get the caller to use the old
        //  cached descriptor, but bumping its ref count, freeing what  
        //  the caller supplied and returning the old one to our caller
        //

        if (Match) {

            InterlockedExchangeAdd ((PLONG)&Header->RefCount, RefBias);

            ObPrint (SHOW_REFERENCES, ("Reference Hash = 0x%lX, New RefCount = %d\n", Header->FullHash, Header->RefCount));

            ExReleasePushLock (&Chain->PushLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

            *OutputSecurityDescriptor = &Header->SecurityDescriptor;

            if (NewDescriptor != NULL) {
                ExFreePool (NewDescriptor);
            }

            return STATUS_SUCCESS;
        }


        if (NewDescriptor == NULL) {
            ExReleasePushLockShared (&Chain->PushLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

            //
            //  Can't use an existing one, create a new entry
            //  and insert it into the list.
            //

            NewDescriptor = ObpCreateCacheEntry (InputSecurityDescriptor,
                                                 Length,
                                                 FullHash,
                                                 RefBias);

            if (NewDescriptor == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            //
            // Reacquire the lock in write mode. We will probably have to insert now
            //
            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquirePushLockExclusive (&Chain->PushLock);
        } else {
            break;
        }
    } while (1);

#if OB_DIAGNOSTICS_ENABLED

    InterlockedIncrement (&ObsTotalCacheEntries);

#endif

    ObPrint (SHOW_STATISTICS, ("ObsTotalCacheEntries = %d \n", ObsTotalCacheEntries));
    ObPrint (SHOW_COLLISIONS, ("Adding new entry for index #%d \n", Slot));


    //
    // Insert the entry before the 'Front' entry. If there is no 'Front' entry then this
    // is just inserting at the head
    //

    InsertTailList (Front, &NewDescriptor->Link);

    ExReleasePushLockExclusive (&Chain->PushLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    //
    //  Set the output security descriptor and return to our caller
    //

    *OutputSecurityDescriptor = &NewDescriptor->SecurityDescriptor;

    return( STATUS_SUCCESS );
}


PSECURITY_DESCRIPTOR_HEADER
ObpCreateCacheEntry (
    PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    ULONG FullHash,
    ULONG RefBias
    )

/*++

Routine Description:

    Allocates and initializes a new cache entry.

Arguments:

    InputSecurityDescriptor - The security descriptor to be cached.

    Length - Length of security descriptor

    FullHash - Full 32 bit hash of the security descriptor.

    RefBias - Amount to bias the security descriptor reference count by.
              Typically either 1 or ExFastRefGetAdditionalReferenceCount () + 1,

Return Value:

    A pointer to the newly allocated cache entry, or NULL

--*/

{
    ULONG CacheEntrySize;
    PSECURITY_DESCRIPTOR_HEADER NewDescriptor;

    //
    //  Compute the size that we'll need to allocate.  We need space for
    //  the security descriptor cache minus the funny quad at the end and the
    //  security descriptor itself.
    //

    ASSERT (SecurityDescriptorLength == RtlLengthSecurityDescriptor (InputSecurityDescriptor));
    CacheEntrySize = SecurityDescriptorLength + (sizeof (SECURITY_DESCRIPTOR_HEADER) - sizeof(QUAD));

    //
    //  Now allocate space for the cached entry
    //

    NewDescriptor = ExAllocatePoolWithTag (PagedPool, CacheEntrySize, 'cSbO');

    if (NewDescriptor == NULL) {

        return NULL;
    }

    //
    //  Fill the header, copy over the descriptor data, and return to our
    //  caller
    //

    NewDescriptor->RefCount   = RefBias;
    NewDescriptor->FullHash   = FullHash;

    RtlCopyMemory (&NewDescriptor->SecurityDescriptor,
                   InputSecurityDescriptor,
                   SecurityDescriptorLength);

    return NewDescriptor;
}

VOID
ObReferenceSecurityDescriptor (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG Count
    )
/*++

Routine Description:

    References the security descriptor.

Arguments:

    SecurityDescriptor - Security descriptor inside the cache to reference.
    Count - Amount to reference by

Return Value:

    None.

--*/
{
    PSECURITY_DESCRIPTOR_HEADER SecurityDescriptorHeader;

    SecurityDescriptorHeader = SD_TO_SD_HEADER( SecurityDescriptor );
    ObPrint( SHOW_REFERENCES, ("Referencing Hash %lX, Refcount = %d \n",SecurityDescriptorHeader->FullHash,
                               SecurityDescriptorHeader->RefCount));

    //
    //  Increment the reference count
    //
    InterlockedExchangeAdd ((PLONG)&SecurityDescriptorHeader->RefCount, Count);
}


PSECURITY_DESCRIPTOR
ObpReferenceSecurityDescriptor (
    POBJECT_HEADER ObjectHeader
    )

/*++

Routine Description:

    References the security descriptor of the passed object.

Arguments:

    Object - Object being access validated.

Return Value:

    The security descriptor of the object.

--*/

{
    PSECURITY_DESCRIPTOR_HEADER SecurityDescriptorHeader;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PEX_FAST_REF FastRef;
    EX_FAST_REF OldRef;
    ULONG RefsToAdd, Unused;

    //
    // Attempt the fast reference
    //
    FastRef = (PEX_FAST_REF) &ObjectHeader->SecurityDescriptor;

    OldRef = ExFastReference (FastRef);

    SecurityDescriptor = ExFastRefGetObject (OldRef);

    //
    // See if we can fast reference this security descriptor. Return NULL if there wasn't one
    // and go the slow way if there are no more cached references left.
    //
    Unused = ExFastRefGetUnusedReferences (OldRef);

    if (Unused >= 1 || SecurityDescriptor == NULL) {
        if (Unused == 1) {
            //
            // If we took the counter to zero then attempt to make life easier for
            // the next referencer by resetting the counter to its max. Since we now
            // have a reference to the security descriptor we can do this.
            //
            RefsToAdd = ExFastRefGetAdditionalReferenceCount ();
            SecurityDescriptorHeader = SD_TO_SD_HEADER( SecurityDescriptor );
            InterlockedExchangeAdd ((PLONG)&SecurityDescriptorHeader->RefCount, RefsToAdd);

            //
            // Try to add the added references to the cache. If we fail then just
            // release them. This dereference can not take the reference count to zero.
            //
            if (!ExFastRefAddAdditionalReferenceCounts (FastRef, SecurityDescriptor, RefsToAdd)) {
                InterlockedExchangeAdd ((PLONG)&SecurityDescriptorHeader->RefCount, -(LONG)RefsToAdd);
            }
        }
        return SecurityDescriptor;
    }

    ObpLockObjectShared( ObjectHeader );

    SecurityDescriptor = ExFastRefGetObject (*FastRef);

    IF_OB_GLOBAL( STOP_INVALID_DESCRIPTOR ) {

        if(!RtlValidSecurityDescriptor ( SecurityDescriptor )) {

            DbgBreakPoint();
        }
    }

    //
    //  The objects security descriptor is not allowed to go fron NON-NULL to NULL.
    //
    SecurityDescriptorHeader = SD_TO_SD_HEADER( SecurityDescriptor );
    ObPrint( SHOW_REFERENCES, ("Referencing Hash %lX, Refcount = %d \n",SecurityDescriptorHeader->FullHash,
                               SecurityDescriptorHeader->RefCount));

    //
    //  Increment the reference count
    //
    InterlockedIncrement ((PLONG) &SecurityDescriptorHeader->RefCount);

    ObpUnlockObject( ObjectHeader );


    return( SecurityDescriptor );
}


NTSTATUS
ObDeassignSecurity (
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor
    )

/*++

Routine Description:

    This routine dereferences the input security descriptor

Arguments:

    SecurityDescriptor - Supplies the security descriptor
        being modified

Return Value:

    Only returns STATUS_SUCCESS

--*/

{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    EX_FAST_REF FastRef;

    ObPrint( SHOW_DEASSIGN,("Deassigning security descriptor %x\n",*pSecurityDescriptor));

    //
    //  NULL out the SecurityDescriptor in the object's
    //  header so we don't try to free it again.
    //
    FastRef = *(PEX_FAST_REF) pSecurityDescriptor;
    *pSecurityDescriptor = NULL;

    SecurityDescriptor = ExFastRefGetObject (FastRef);
    ObDereferenceSecurityDescriptor (SecurityDescriptor, ExFastRefGetUnusedReferences (FastRef) + 1);
    
    return STATUS_SUCCESS;
}


VOID
ObDereferenceSecurityDescriptor (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG Count
    )

/*++

Routine Description:

    Decrements the refcount of a cached security descriptor

Arguments:

    SecurityDescriptor - Points to a cached security descriptor

Return Value:

    None.

--*/

{
    PSECURITY_DESCRIPTOR_HEADER SecurityDescriptorHeader;
    PVOID PoolToFree;
    LONG OldValue, NewValue;
    POB_SD_CACHE_LIST Chain;
    PETHREAD CurrentThread;
    ULONG Slot;

    SecurityDescriptorHeader = SD_TO_SD_HEADER( SecurityDescriptor );

    //
    // First see if its possible to do a non-zero transition lock free.
    //
    OldValue = SecurityDescriptorHeader->RefCount;

    //
    // If the old value is equal to the decrement then we will be the deleter of this block. We need the lock for that
    //
    while (OldValue != (LONG) Count) {

        NewValue = InterlockedCompareExchange ((PLONG)&SecurityDescriptorHeader->RefCount, OldValue - Count, OldValue);
        if (NewValue == OldValue) {
            return;
        }
        OldValue = NewValue;
    }

    //
    //  Lock the security descriptor cache and get a pointer
    //  to the security descriptor header
    //
    Slot = SecurityDescriptorHeader->FullHash % SECURITY_DESCRIPTOR_CACHE_ENTRIES;

    Chain = &ObsSecurityDescriptorCache[Slot];

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockExclusive (&Chain->PushLock);

    //
    //  Do some debug work
    //

    ObPrint( SHOW_REFERENCES, ("Dereferencing SecurityDescriptor %x, hash %lx, refcount = %d \n", SecurityDescriptor,
                               SecurityDescriptorHeader->FullHash,
                               SecurityDescriptorHeader->RefCount));

    ASSERT(SecurityDescriptorHeader->RefCount != 0);

    //
    //  Decrement the ref count and if it is now zero then
    //  we can completely remove this entry from the cache
    //

    if (InterlockedExchangeAdd ((PLONG)&SecurityDescriptorHeader->RefCount, -(LONG)Count) == (LONG)Count) {

        PoolToFree = ObpDestroySecurityDescriptorHeader (SecurityDescriptorHeader);
        //
        //  Unlock the security descriptor cache and free the pool
        //

        ExReleasePushLockExclusive (&Chain->PushLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        ExFreePool (PoolToFree);
    } else {

        //
        //  Unlock the security descriptor cache and return to our caller
        //

        ExReleasePushLockExclusive (&Chain->PushLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

}


PVOID
ObpDestroySecurityDescriptorHeader (
    IN PSECURITY_DESCRIPTOR_HEADER Header
    )

/*++

Routine Description:

    Frees a cached security descriptor and unlinks it from the chain.

Arguments:

    Header - Pointer to a security descriptor header (cached security
        descriptor)

Return Value:

    None.

--*/

{
    ASSERT ( Header->RefCount == 0 );

#if OB_DIAGNOSTICS_ENABLED

    InterlockedDecrement (&ObsTotalCacheEntries);

#endif

    ObPrint( SHOW_STATISTICS, ("ObsTotalCacheEntries = %d \n",ObsTotalCacheEntries));

    //
    //  Unlink the cached security descriptor from its linked list
    //

    RemoveEntryList (&Header->Link);

    ObPrint( SHOW_HEADER_FREE, ("Freeing memory at %x \n",Header));

    //
    //  Now return the cached descriptor to our caller to free
    //

    return Header;
}


BOOLEAN
ObpCompareSecurityDescriptors (
    IN PSECURITY_DESCRIPTOR SD1,
    IN ULONG Length1,
    IN PSECURITY_DESCRIPTOR SD2
    )

/*++

Routine Description:

    Performs a byte by byte comparison of two self relative security
    descriptors to determine if they are identical.

Arguments:

    SD1, SD2 - Security descriptors to be compared.
    Length1 - Length of SD1

Return Value:

    TRUE - They are the same.

    FALSE - They are different.

--*/

{
    ULONG Length2;

    //
    //  Calculating the length is pretty fast, see if we
    //  can get away with doing only that.
    //

    ASSERT (Length1 == RtlLengthSecurityDescriptor ( SD1 ));

    Length2 =  RtlLengthSecurityDescriptor ( SD2 );

    if (Length1 != Length2) {

        return( FALSE );
    }

    return (BOOLEAN)RtlEqualMemory ( SD1, SD2, Length1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obvutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obvutil.h

Abstract:

    This header exposes various utilities required to do driver verification.

--*/

LONG_PTR
ObvUtilStartObRefMonitoring(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG_PTR
ObvUtilStopObRefMonitoring(
    IN PDEVICE_OBJECT DeviceObject,
    IN LONG StartSkew
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obtype.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obtype.c

Abstract:

    Object type routines.

--*/

#include "obp.h"


typedef struct _OBJECT_TYPE_ARRAY {

    ULONG   Size;
    POBJECT_HEADER_CREATOR_INFO CreatorInfoArray[1];

} OBJECT_TYPE_ARRAY, *POBJECT_TYPE_ARRAY;

POBJECT_TYPE_ARRAY
ObpCreateTypeArray (
    IN POBJECT_TYPE ObjectType
    );
VOID
ObpDestroyTypeArray (
    IN POBJECT_TYPE_ARRAY ObjectArray
    );
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ObCreateObjectType)
#pragma alloc_text(PAGE,ObEnumerateObjectsByType)
#pragma alloc_text(PAGE,ObpCreateTypeArray)
#pragma alloc_text(PAGE,ObpDestroyTypeArray)
#pragma alloc_text(PAGE,ObGetObjectInformation)
#pragma alloc_text(PAGE,ObpDeleteObjectType)
#endif

/*

 IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT

 There is currently no system service that permits changing
 the security on an object type object.  Consequently, the object
 manager does not check to make sure that a subject is allowed
 to create an object of a given type.

 Should such a system service be added, the following section of
 code must be re-enabled in obhandle.c:

        //
        // Perform access check to see if we are allowed to create
        // an instance of this object type.
        //
        // This routine will audit the attempt to create the
        // object as appropriate.  Note that this is different
        // from auditing the creation of the object itself.
        //

        if (!ObCheckCreateInstanceAccess( ObjectType,
                                          OBJECT_TYPE_CREATE,
                                          AccessState,
                                          TRUE,
                                          AccessMode,
                                          &Status
                                        ) ) {
            return( Status );

            }

 The code is already there, but is not compiled.

 This will ensure that someone who is denied access to an object
 type is not permitted to create an object of that type.

*/


NTSTATUS
ObCreateObjectType (
    __in PUNICODE_STRING TypeName,
    __in POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
    __out POBJECT_TYPE *ObjectType
    )

/*++

Routine Description:

    This routine creates a new object type.

Arguments:

    TypeName - Supplies the name of the new object type

    ObjectTypeInitializer - Supplies a object initialization
        structure.  This structure denotes the default object
        behavior including callbacks.

    SecurityDescriptor - Currently ignored

    ObjectType - Receives a pointer to the newly created object
        type.

Return Value:

    An appropriate NTSTATUS value.

--*/

{
    POOL_TYPE PoolType;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER NewObjectTypeHeader;
    POBJECT_TYPE NewObjectType;
    ULONG i;
    UNICODE_STRING ObjectName;
    PWCH s;
    NTSTATUS Status;
    ULONG StandardHeaderCharge;
    OBP_LOOKUP_CONTEXT LookupContext;

    UNREFERENCED_PARAMETER (SecurityDescriptor);

    ObpValidateIrql( "ObCreateObjectType" );

    //
    //  Return an error if invalid type attributes or no type name specified.
    //  No type name is okay if the type directory object does not exist
    //  yet (see init.c).
    //

    PoolType = ObjectTypeInitializer->PoolType;

    if ((!TypeName)

            ||

        (!TypeName->Length)

            ||

        (TypeName->Length % sizeof( WCHAR ))

            ||

        (ObjectTypeInitializer == NULL)

            ||

        (ObjectTypeInitializer->InvalidAttributes & ~OBJ_ALL_VALID_ATTRIBUTES)

            ||

        (ObjectTypeInitializer->Length != sizeof( *ObjectTypeInitializer ))

            ||

        (ObjectTypeInitializer->MaintainHandleCount &&
            (ObjectTypeInitializer->OpenProcedure == NULL &&
             ObjectTypeInitializer->CloseProcedure == NULL ))

            ||

        ((!ObjectTypeInitializer->UseDefaultObject) &&
            (PoolType != NonPagedPool))) {

        return( STATUS_INVALID_PARAMETER );
    }

    //
    //  Make sure that the type name does not contain an
    //  path name separator
    //

    s = TypeName->Buffer;
    i = TypeName->Length / sizeof( WCHAR );

    while (i--) {

        if (*s++ == OBJ_NAME_PATH_SEPARATOR) {

            return( STATUS_OBJECT_NAME_INVALID );
        }
    }

    //
    //  See if TypeName string already exists in the \ObjectTypes directory
    //  Return an error if it does.  Otherwise add the name to the directory.
    //  Note that there may not necessarily be a type directory.
    //

    ObpInitializeLookupContext( &LookupContext );

    if (ObpTypeDirectoryObject) {

        ObpLockLookupContext( &LookupContext, ObpTypeDirectoryObject);

        if (ObpLookupDirectoryEntry( ObpTypeDirectoryObject,
                                     TypeName,
                                     OBJ_CASE_INSENSITIVE,
                                     FALSE,
                                     &LookupContext )) {

            ObpReleaseLookupContext( &LookupContext );

            return( STATUS_OBJECT_NAME_COLLISION );
        }
    }

    //
    //  Allocate a buffer for the type name and then
    //  copy over the name
    //

    ObjectName.Buffer = ExAllocatePoolWithTag( PagedPool,
                                               (ULONG)TypeName->MaximumLength,
                                               'mNbO' );

    if (ObjectName.Buffer == NULL) {

        ObpReleaseLookupContext( &LookupContext );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ObjectName.MaximumLength = TypeName->MaximumLength;

    RtlCopyUnicodeString( &ObjectName, TypeName );

    //
    //  Allocate memory for the object
    //

    Status = ObpAllocateObject( NULL,
                                KernelMode,
                                ObpTypeObjectType,
                                &ObjectName,
                                sizeof( OBJECT_TYPE ),
                                &NewObjectTypeHeader );

    if (!NT_SUCCESS( Status )) {

        ObpReleaseLookupContext( &LookupContext );
        ExFreePool(ObjectName.Buffer);

        return( Status );
    }

    //
    //  Initialize the create attributes, object ownership. parse context,
    //  and object body pointer.
    //
    //  N.B. This is required since these fields are not initialized.
    //

    NewObjectTypeHeader->Flags |= OB_FLAG_KERNEL_OBJECT |
                                  OB_FLAG_PERMANENT_OBJECT;

    NewObjectType = (POBJECT_TYPE)&NewObjectTypeHeader->Body;
    NewObjectType->Name = ObjectName;

    //
    //  The following call zeros out the number of handles and objects
    //  field plus high water marks
    //

    RtlZeroMemory( &NewObjectType->TotalNumberOfObjects,
                   FIELD_OFFSET( OBJECT_TYPE, TypeInfo ) -
                   FIELD_OFFSET( OBJECT_TYPE, TotalNumberOfObjects ));

    //
    //  If there is not a type object type yet then this must be
    //  that type (i.e., type object type must be the first object type
    //  ever created.  Consequently we'll need to setup some self
    //  referencing pointers.
    //

    if (!ObpTypeObjectType) {

        ObpTypeObjectType = NewObjectType;
        NewObjectTypeHeader->Type = ObpTypeObjectType;
        NewObjectType->TotalNumberOfObjects = 1;

#ifdef POOL_TAGGING

        NewObjectType->Key = 'TjbO';

    } else {

        //
        //  Otherwise this is not the type object type so we'll
        //  try and generate a tag for the new object type provided
        //  pool tagging is turned on.
        //

        ANSI_STRING AnsiName;

        if (NT_SUCCESS( RtlUnicodeStringToAnsiString( &AnsiName, TypeName, TRUE ) )) {

            for (i=3; i>=AnsiName.Length; i--) {

                AnsiName.Buffer[ i ] = ' ';

            }

            NewObjectType->Key = *(PULONG)AnsiName.Buffer;
            ExFreePool( AnsiName.Buffer );

        } else {

            NewObjectType->Key = *(PULONG)TypeName->Buffer;
        }

#endif //POOL_TAGGING

    }

    //
    //  Continue initializing the new object type fields
    //

    NewObjectType->TypeInfo = *ObjectTypeInitializer;
    NewObjectType->TypeInfo.PoolType = PoolType;

    if (NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST) {

        NewObjectType->TypeInfo.MaintainTypeList = TRUE;
    }

    //
    //  Whack quotas passed in so that headers are properly charged
    //
    //  Quota for object name is charged independently
    //

    StandardHeaderCharge = sizeof( OBJECT_HEADER ) +
                           sizeof( OBJECT_HEADER_NAME_INFO ) +
                           (ObjectTypeInitializer->MaintainHandleCount ?
                                sizeof( OBJECT_HEADER_HANDLE_INFO )
                              : 0 );

    if ( PoolType == NonPagedPool ) {

        NewObjectType->TypeInfo.DefaultNonPagedPoolCharge += StandardHeaderCharge;

    } else {

        NewObjectType->TypeInfo.DefaultPagedPoolCharge += StandardHeaderCharge;
    }

    //
    //  If there is not an object type specific security procedure then set
    //  the default one supplied by Se.
    //

    if (ObjectTypeInitializer->SecurityProcedure == NULL) {

        NewObjectType->TypeInfo.SecurityProcedure = SeDefaultObjectMethod;
    }

    //
    //  Initialize the object type lock and its list of objects created
    //  of this type
    //

    ExInitializeResourceLite( &NewObjectType->Mutex );

    for (i = 0; i < OBJECT_LOCK_COUNT; i++) {

        ExInitializeResourceLite( &NewObjectType->ObjectLocks[i] );
    }

    InitializeListHead( &NewObjectType->TypeList );
    PERFINFO_INITIALIZE_OBJECT_ALLOCATED_TYPE_LIST_HEAD(NewObjectType);

    //
    //  If we are to use the default object (meaning that we'll have our
    //  private event as our default object) then the type must allow
    //  synchronize and we'll set the default object
    //

    if (NewObjectType->TypeInfo.UseDefaultObject) {

        NewObjectType->TypeInfo.ValidAccessMask |= SYNCHRONIZE;
        NewObjectType->DefaultObject = &ObpDefaultObject;

    //
    //  Otherwise if this is the type file object then we'll put
    //  in the offset to the event of a file object.
    //

    } else if (ObjectName.Length == 8 && !wcscmp( ObjectName.Buffer, L"File" )) {

        NewObjectType->DefaultObject = ULongToPtr( FIELD_OFFSET( FILE_OBJECT, Event ) );


    //
    // If this is a waitable port, set the offset to the event in the
    // waitableport object.  Another hack
    //

    } else if ( ObjectName.Length == 24 && !wcscmp( ObjectName.Buffer, L"WaitablePort")) {

        NewObjectType->DefaultObject = ULongToPtr( FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ) );

    //
    //  Otherwise indicate that there isn't a default object to wait
    //  on
    //

    } else {

        NewObjectType->DefaultObject = NULL;
    }

    //
    //  Lock down the type object type and if there is a creator info
    //  record then insert this object on that list
    //

    ObpEnterObjectTypeMutex( ObpTypeObjectType );

    CreatorInfo = OBJECT_HEADER_TO_CREATOR_INFO( NewObjectTypeHeader );

    if (CreatorInfo != NULL) {

        InsertTailList( &ObpTypeObjectType->TypeList, &CreatorInfo->TypeList );
    }

    //
    //  Store a pointer to this new object type in the
    //  global object types array.  We'll use the index from
    //  the type object type number of objects count
    //

    NewObjectType->Index = ObpTypeObjectType->TotalNumberOfObjects;

    if (NewObjectType->Index < OBP_MAX_DEFINED_OBJECT_TYPES) {

        ObpObjectTypes[ NewObjectType->Index - 1 ] = NewObjectType;
    }

    //
    //  Unlock the type object type lock
    //

    ObpLeaveObjectTypeMutex( ObpTypeObjectType );

    //
    //  Lastly if there is not a directory object type yet then the following
    //  code will actually drop through and set the output object type
    //  and return success.
    //
    //  Otherwise, there is a directory object type and we try to insert the
    //  new type into the directory.  If this succeeds then we'll reference
    //  the directory type object, unlock the root directory, set the
    //  output type and return success
    //

    if (!ObpTypeDirectoryObject ||
        ObpInsertDirectoryEntry( ObpTypeDirectoryObject, &LookupContext, NewObjectTypeHeader )) {

        if (ObpTypeDirectoryObject) {

            ObReferenceObject( ObpTypeDirectoryObject );
        }

        ObpReleaseLookupContext( &LookupContext );

        *ObjectType = NewObjectType;

        return( STATUS_SUCCESS );

    } else {

        //
        //  Otherwise there is a directory object type and
        //  the insertion failed.  So release the root directory
        //  and return failure to our caller.
        //

        ObpReleaseLookupContext( &LookupContext );

        return( STATUS_INSUFFICIENT_RESOURCES );
    }
}


VOID
ObpDeleteObjectType (
    IN  PVOID   Object
    )

/*++

Routine Description:

    This routine is called when a reference to a type object goes to zero.

Arguments:

    Object - Supplies a pointer to the type object being deleted

Return Value:

    None.

--*/

{
    ULONG i;
    POBJECT_TYPE ObjectType = (POBJECT_TYPE)Object;

    //
    //  The only cleaning up we need to do is to delete the type resource
    //

    for (i = 0; i < OBJECT_LOCK_COUNT; i++) {

        ExDeleteResourceLite( &ObjectType->ObjectLocks[i] );
    }

    ExDeleteResourceLite( &ObjectType->Mutex );

    //
    //  And return to our caller
    //

    return;
}


NTSTATUS
ObEnumerateObjectsByType(
    IN POBJECT_TYPE ObjectType,
    IN OB_ENUM_OBJECT_TYPE_ROUTINE EnumerationRoutine,
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine, via a callback, will enumerate through all
    the objects of a specified type.  This only works on objects
    that maintain the type list (i.e., have an object creator
    info record).

Arguments:

    ObjectType - Supplies the object type being enumerated

    EnumerationRoutine - Supplies the callback routine to use

    Parameter - Supplies a parameter to pass through to the callback
        routine

Return Value:

    STATUS_SUCCESS if the enumeration finishes because the
    end of the list is reached and STATUS_NO_MORE_ENTRIES if
    the enmeration callback routine ever returns false.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING ObjectName;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER_NAME_INFO NameInfo;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE_ARRAY ObjectTypeArray;
    ULONG i;

    Status = STATUS_SUCCESS;

    //
    //  Capture the  object type array
    //

    ObjectTypeArray = ObpCreateTypeArray ( ObjectType );

    //
    //  If it is any object in that queue, start
    //  quering information about it
    //

    if (ObjectTypeArray != NULL) {

        //
        //  The following loop iterates through each object
        //  of the specified type.
        //

        for ( i = 0; i < ObjectTypeArray->Size; i++) {

            //
            //  For each object we'll grab its creator info record,
            //  its object header, and its object body
            //

            CreatorInfo = ObjectTypeArray->CreatorInfoArray[i];

            //
            //  If the object is being deleted, the creator info
            //  will be NULL in the array. Jump then to the next object
            //

            if (!CreatorInfo) {

                continue;
            }

            ObjectHeader = (POBJECT_HEADER)(CreatorInfo+1);

            //
            //  From the object header see if there is a name for the
            //  object. If there is not a name then we'll supply an
            //  empty name.
            //

            NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );

            if (NameInfo != NULL) {

                ObjectName = NameInfo->Name;

            } else {

                RtlZeroMemory( &ObjectName, sizeof( ObjectName ) );
            }

            //
            //  Now invoke the callback and if it returns false then
            //  we're done with the enumeration and will return
            //  an alternate ntstatus value
            //

            if (!(EnumerationRoutine)( &ObjectHeader->Body,
                                       &ObjectName,
                                       ObjectHeader->HandleCount,
                                       ObjectHeader->PointerCount,
                                       Parameter )) {

                Status = STATUS_NO_MORE_ENTRIES;

                break;
            }
        }

        ObpDestroyTypeArray(ObjectTypeArray);
    }

    return Status;
}

PERFINFO_DEFINE_OB_ENUMERATE_ALLOCATED_OBJECTS_BY_TYPE()


POBJECT_TYPE_ARRAY
ObpCreateTypeArray (
    IN POBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine create an array with pointers to all objects queued
    for a given ObjectType. All objects are referenced when are stored
    in the array.

Arguments:

    ObjectType - Supplies the object type for which we make copy
    for all objects.


Return Value:

    The array with objects created. returns NULL if the specified ObjectType
    has the TypeList empty.

--*/

{
    ULONG Count;
    POBJECT_TYPE_ARRAY ObjectArray;
    PLIST_ENTRY Next1, Head1;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER ObjectHeader;
    PVOID Object;

    //
    //  Acquire the ObjectType mutex
    //

    ObpEnterObjectTypeMutex( ObjectType );

    ObjectArray = NULL;

    //
    //  Count the number of elements into the list
    //

    Count = 0;

    Head1 = &ObjectType->TypeList;
    Next1 = Head1->Flink;

    while (Next1 != Head1) {

        Next1 = Next1->Flink;
        Count += 1;
    }

    //
    //  If we have a number of objects > 0 then we'll create an array
    //  and copy all pointers into that array
    //

    if ( Count > 0 ) {

        //
        //  Allocate the memory for array
        //

        ObjectArray = ExAllocatePoolWithTag( PagedPool,
                                             sizeof(OBJECT_TYPE_ARRAY) + sizeof(POBJECT_HEADER_CREATOR_INFO) * (Count - 1),
                                             'rAbO' );
        if ( ObjectArray != NULL ) {

            ObjectArray->Size = Count;

            Count = 0;

            //
            //  Start parsing the TypeList
            //

            Head1 = &ObjectType->TypeList;
            Next1 = Head1->Flink;

            while (Next1 != Head1) {

                ASSERT( Count < ObjectArray->Size );

                //
                //  For each object we'll grab its creator info record,
                //  its object header, and its object body
                //

                CreatorInfo = CONTAINING_RECORD( Next1,
                                                 OBJECT_HEADER_CREATOR_INFO,
                                                 TypeList );

                //
                //  We'll store the CreatorInfo into the ObjectArray
                //

                ObjectArray->CreatorInfoArray[Count] = CreatorInfo;

                //
                //  Find the Object and increment the references to that object
                //  to avoid deleting while are stored copy in this array
                //

                ObjectHeader = (POBJECT_HEADER)(CreatorInfo+1);

                Object = &ObjectHeader->Body;

                if (!ObReferenceObjectSafe( Object))
                {
                    //
                    //  We can't reference the object because it is being deleted
                    //

                    ObjectArray->CreatorInfoArray[Count] = NULL;
                }

                Next1 = Next1->Flink;
                Count++;
            }
        }
    }

    //
    //  Release the ObjectType mutex
    //

    ObpLeaveObjectTypeMutex( ObjectType );

    return ObjectArray;
}


VOID
ObpDestroyTypeArray (
    IN POBJECT_TYPE_ARRAY ObjectArray
    )

/*++

Routine Description:

    This routine destroy an array with pointers to objects, created by
    ObpCreateTypeArray. Each object is dereferenced before releasing the
    array memory.

Arguments:

    ObjectArray - Supplies the array to be freed

Return Value:


--*/

{
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER ObjectHeader;
    PVOID Object;
    ULONG i;

    if (ObjectArray != NULL) {

        //
        //  Go through array and dereference all objects.
        //

        for (i = 0; i < ObjectArray->Size; i++) {

            //
            //  Retrieving the Object from the CreatorInfo
            //

            CreatorInfo = ObjectArray->CreatorInfoArray[i];

            if (CreatorInfo) {

                ObjectHeader = (POBJECT_HEADER)(CreatorInfo+1);

                Object = &ObjectHeader->Body;

                //
                //  Dereference the object
                //

                ObDereferenceObject( Object );
            }
        }

        //
        //  Free the memory allocated for this array
        //

        ExFreePoolWithTag( ObjectArray, 'rAbO' );
    }
}


NTSTATUS
ObGetObjectInformation(
    IN PCHAR UserModeBufferAddress,
    OUT PSYSTEM_OBJECTTYPE_INFORMATION ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This routine returns information for all the object in the
    system.  It enumerates through all the object types and in
    each type it enumerates through their type list.

Arguments:

    UserModeBufferAddress - Supplies the address of the query buffer
        as specified by the user.

    ObjectInformation - Supplies a buffer to receive the object
        type information.  This is essentially the same as the first
        parameter except that one is a system address and the other
        is in the user's address space.

    Length - Supplies the length, in bytes, of the object information
        buffer

    ReturnLength - Optionally receives the total length, in bytes,
        needed to store the object information


Return Value:

    An appropriate status value

--*/

{
    #define OBGETINFO_MAXFILENAME (260 * sizeof(WCHAR))
    
    NTSTATUS ReturnStatus, Status;
    POBJECT_TYPE ObjectType;
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_CREATOR_INFO CreatorInfo;
    POBJECT_HEADER_QUOTA_INFO QuotaInfo;
    PVOID Object;
    BOOLEAN FirstObjectForType;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo = NULL;
    ULONG TotalSize, NameSize;
    POBJECT_HEADER ObjectTypeHeader;
    PVOID TmpBuffer = NULL;
    SIZE_T TmpBufferSize = OBGETINFO_MAXFILENAME + sizeof(UNICODE_STRING);
    POBJECT_NAME_INFORMATION NameInformation;
    extern POBJECT_TYPE IoFileObjectType;
    PWSTR TempBuffer;
    USHORT TempMaximumLength;
    POBJECT_TYPE_ARRAY ObjectTypeArray = NULL;
    POBJECT_TYPE_ARRAY TypeObjectTypeArray;
    ULONG i, TypeIndex;

    PAGED_CODE();

    //
    //  Initialize some local variables
    //

    TmpBuffer = ExAllocatePoolWithTag( PagedPool,
                                       TmpBufferSize,
                                       'rAbO' );

    if (TmpBuffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NameInformation = (POBJECT_NAME_INFORMATION)TmpBuffer;
    ReturnStatus = STATUS_SUCCESS;
    TotalSize = 0;
    TypeInfo = NULL;

    //
    //  Capture the object types into an array
    //

    TypeObjectTypeArray = ObpCreateTypeArray ( ObpTypeObjectType );

    if (!TypeObjectTypeArray) {

        ExFreePoolWithTag( TmpBuffer, 'rAbO' );
        return STATUS_UNSUCCESSFUL;
    }

    try {

        for ( TypeIndex = 0; TypeIndex < TypeObjectTypeArray->Size; TypeIndex++ ) {

            //
            //  For each object type object we'll grab its creator
            //  info record and which must directly precede the
            //  object header followed by the object body
            //

            CreatorInfo = TypeObjectTypeArray->CreatorInfoArray[ TypeIndex ];

            //
            //  If the object type is being deleted, the creator info
            //  will be NULL in the array. Jump then to the next object
            //

            if (!CreatorInfo) {

                continue;
            }

            ObjectTypeHeader = (POBJECT_HEADER)(CreatorInfo+1);
            ObjectType = (POBJECT_TYPE)&ObjectTypeHeader->Body;

            //
            //  Now if this is not the object type object, which is what
            //  the outer loop is going through then we'll jump in one
            //  more loop
            //

            if (ObjectType != ObpTypeObjectType) {

                //
                //  Capture the array with objects queued in the TypeList
                //

                ObjectTypeArray = ObpCreateTypeArray ( ObjectType );

                //
                //  If it is any object in that queue, start
                //  quering information about it
                //

                if (ObjectTypeArray != NULL) {

                    //
                    //  The following loop iterates through each object
                    //  of the specified type.
                    //

                    FirstObjectForType = TRUE;

                    for ( i = 0; i < ObjectTypeArray->Size; i++) {

                        //
                        //  For each object we'll grab its creator info record,
                        //  its object header, and its object body
                        //

                        CreatorInfo = ObjectTypeArray->CreatorInfoArray[i];

                        //
                        //  If the object is being deleted, the creator info
                        //  will be NULL in the array. Jump then to the next object
                        //

                        if (!CreatorInfo) {

                            continue;
                        }

                        ObjectHeader = (POBJECT_HEADER)(CreatorInfo+1);

                        Object = &ObjectHeader->Body;

                        //
                        //  If this is the first time through the inner loop for this
                        //  type then we'll fill in the type info buffer
                        //

                        if (FirstObjectForType) {

                            FirstObjectForType = FALSE;

                            //
                            //  If the pointer it not null (i.e., we've been through
                            //  this loop before) and the total size we've used so
                            //  far hasn't exhausted the output buffer then
                            //  set the previous type info record to point to the
                            //  next type info record
                            //

                            if ((TypeInfo != NULL) && (TotalSize < Length)) {

                                TypeInfo->NextEntryOffset = TotalSize;
                            }

                            //
                            //  Set the current type info record to point to the next
                            //  free spot in the output buffer, and adjust the total
                            //  size used so far to account for the object type info
                            //  buffer
                            //

                            TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)((PCHAR)ObjectInformation + TotalSize);

                            TotalSize += FIELD_OFFSET( SYSTEM_OBJECTTYPE_INFORMATION, TypeName );

                            //
                            //  See if the data will fit into the info buffer, and if
                            //  so then fill in the record
                            //

                            if (TotalSize >= Length) {

                                ReturnStatus = STATUS_INFO_LENGTH_MISMATCH;

                            } else {

                                TypeInfo->NextEntryOffset   = 0;
                                TypeInfo->NumberOfObjects   = ObjectType->TotalNumberOfObjects;
                                TypeInfo->NumberOfHandles   = ObjectType->TotalNumberOfHandles;
                                TypeInfo->TypeIndex         = ObjectType->Index;
                                TypeInfo->InvalidAttributes = ObjectType->TypeInfo.InvalidAttributes;
                                TypeInfo->GenericMapping    = ObjectType->TypeInfo.GenericMapping;
                                TypeInfo->ValidAccessMask   = ObjectType->TypeInfo.ValidAccessMask;
                                TypeInfo->PoolType          = ObjectType->TypeInfo.PoolType;
                                TypeInfo->SecurityRequired  = ObjectType->TypeInfo.SecurityRequired;
                            }

                            //
                            //  Now we need to do the object's type name. The name
                            //  goes right after the type info field.  The following
                            //  query type name call knows to take the address of a
                            //  unicode string and assumes that the buffer to stuff
                            //  the string is right after the unicode string structure.
                            //  The routine also assumes that name size is the number
                            //  of bytes already use in the buffer and add to it the
                            //  number of bytes it uses.  That is why we need to
                            //  initialize it to zero before doing the call.
                            //

                            NameSize = 0;

                            Status = ObQueryTypeName( Object,
                                                      &TypeInfo->TypeName,
                                                      TotalSize < Length ? Length - TotalSize : 0,
                                                      &NameSize );

                            //
                            //  Round the name size up to the next ulong boundary
                            //

                            NameSize = (NameSize + TYPE_ALIGNMENT (SYSTEM_OBJECTTYPE_INFORMATION) - 1) &
                                                   (~(TYPE_ALIGNMENT (SYSTEM_OBJECTTYPE_INFORMATION) - 1));

                            //
                            //  If we were able to successfully get the type name then
                            //  set the max length to the rounded ulong that does not
                            //  include the heading unicode string structure.  Also set
                            //  the buffer to the address that the user would use to
                            //  access the string.
                            //

                            if (NT_SUCCESS( Status )) {

                                TypeInfo->TypeName.MaximumLength = (USHORT)
                                    (NameSize - sizeof( TypeInfo->TypeName ));
                                TypeInfo->TypeName.Buffer = (PWSTR)
                                    (UserModeBufferAddress +
                                     ((PCHAR)TypeInfo->TypeName.Buffer - (PCHAR)ObjectInformation)
                                    );

                            } else {

                                ReturnStatus = Status;
                            }

                            //
                            //  Now we need to bias the total size we've used by the
                            //  size of the object name
                            //

                            TotalSize += NameSize;

                        } else {

                            //
                            //  Otherwise this is not the first time through the inner
                            //  loop for this object type so the only thing we need to
                            //  do is set the previous object info record to "point via
                            //  relative offset" to the next object info record
                            //

                            if (TotalSize < Length) {

                                ObjectInfo->NextEntryOffset = TotalSize;
                            }
                        }

                        //
                        //  We still have an object info record to fill in for this
                        //  record.  The only thing we've done so far is the type info
                        //  record.  So now get a pointer to the new object info record
                        //  and adjust the total size to account for the object record
                        //

                        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)((PCHAR)ObjectInformation + TotalSize);

                        TotalSize += FIELD_OFFSET( SYSTEM_OBJECT_INFORMATION, NameInfo );

                        //
                        //  If there is room for the object info record then fill
                        //  in the record
                        //

                        if (TotalSize >= Length) {

                            ReturnStatus = STATUS_INFO_LENGTH_MISMATCH;

                        } else {

                            ObjectInfo->NextEntryOffset       = 0;
                            ObjectInfo->Object                = Object;
                            ObjectInfo->CreatorUniqueProcess  = CreatorInfo->CreatorUniqueProcess;
                            ObjectInfo->CreatorBackTraceIndex = CreatorInfo->CreatorBackTraceIndex;
                            ObjectInfo->PointerCount          = (ULONG)ObjectHeader->PointerCount;
                            ObjectInfo->HandleCount           = (ULONG)ObjectHeader->HandleCount;
                            ObjectInfo->Flags                 = (USHORT)ObjectHeader->Flags;
                            ObjectInfo->SecurityDescriptor    =
                                ExFastRefGetObject (*(PEX_FAST_REF) &ObjectHeader->SecurityDescriptor);

                            //
                            //  Fill in the appropriate quota information if there is
                            //  any quota information available
                            //

                            QuotaInfo = OBJECT_HEADER_TO_QUOTA_INFO( ObjectHeader );

                            if (QuotaInfo != NULL) {

                                ObjectInfo->PagedPoolCharge    = QuotaInfo->PagedPoolCharge;
                                ObjectInfo->NonPagedPoolCharge = QuotaInfo->NonPagedPoolCharge;

                                if (QuotaInfo->ExclusiveProcess != NULL) {

                                    ObjectInfo->ExclusiveProcessId = QuotaInfo->ExclusiveProcess->UniqueProcessId;
                                }

                            } else {

                                ObjectInfo->PagedPoolCharge    = ObjectType->TypeInfo.DefaultPagedPoolCharge;
                                ObjectInfo->NonPagedPoolCharge = ObjectType->TypeInfo.DefaultNonPagedPoolCharge;
                            }
                        }

                        //
                        //  Now we are ready to get the object name.  If there is not a
                        //  private routine to get the object name then we can call our
                        //  ob routine to query the object name.  Also if this is not
                        //  a file object we can do the query call.  The call will
                        //  fill in our local name buffer.
                        //

                        NameSize = 0;
                        Status = STATUS_SUCCESS;

                        if ((ObjectType->TypeInfo.QueryNameProcedure == NULL) ||
                            (ObjectType != IoFileObjectType)) {

                            Status = ObQueryNameString( Object,
                                                        NameInformation,
                                                        (ULONG)TmpBufferSize,
                                                        &NameSize );

                            //
                            //  Increase the temporary buffer, if the name does not fit
                            //

                            if ((Status == STATUS_INFO_LENGTH_MISMATCH)
                                    &&
                                (NameSize > TmpBufferSize)  //  just sanity checking to not shrink the buffer
                                    &&
                                ((NameSize + TotalSize) < Length)) {

                                PVOID PreviousBuffer = TmpBuffer;

                                TmpBuffer = ExAllocatePoolWithTag( PagedPool,
                                                                   NameSize,
                                                                   'rAbO' );

                                if (TmpBuffer) {
                                    
                                    ExFreePoolWithTag( PreviousBuffer, 'rAbO' );
                                    TmpBufferSize = NameSize;
                                    NameInformation = (POBJECT_NAME_INFORMATION)TmpBuffer;
                                    
                                    //
                                    //  Retry the query.
                                    //

                                    Status = ObQueryNameString( Object,
                                                                NameInformation,
                                                                (ULONG)TmpBufferSize,
                                                                &NameSize );

                                } else {

                                    //
                                    //  The allocation failed. Continue to use the previous buffer
                                    //

                                    TmpBuffer = PreviousBuffer;
                                    Status = STATUS_INSUFFICIENT_RESOURCES;
                                }
                            }

                        //
                        //  If this is a file object then we can get the
                        //  name directly from the file object.  We start by
                        //  directly copying the file object unicode string structure
                        //  into our local memory and then adjust the lengths, copy
                        //  the buffer and modify the pointers as necessary.
                        //

                        } else if (ObjectType == IoFileObjectType) {

                            NameInformation->Name = ((PFILE_OBJECT)Object)->FileName;

                            if ((NameInformation->Name.Length != 0) &&
                                (NameInformation->Name.Buffer != NULL)) {

                                NameSize = NameInformation->Name.Length + sizeof( UNICODE_NULL );

                                //
                                //  We will trim down names that are longer than 260 unicode
                                //  characters in length
                                //

                                if (NameSize > OBGETINFO_MAXFILENAME) {

                                    NameSize = OBGETINFO_MAXFILENAME;
                                    NameInformation->Name.Length = (USHORT)(NameSize - sizeof( UNICODE_NULL ));
                                }

                                //
                                //  Now copy over the name from the buffer used by the
                                //  file object into our local buffer, adjust the
                                //  fields in the unicode string structure and null
                                //  terminate the string.  In the copy we cannot copy
                                //  the null character from the filename because it
                                //  may not be valid memory
                                //

                                RtlMoveMemory( (NameInformation+1),
                                               NameInformation->Name.Buffer,
                                               NameSize - sizeof( UNICODE_NULL) );

                                NameInformation->Name.Buffer = (PWSTR)(NameInformation+1);
                                NameInformation->Name.MaximumLength = (USHORT)NameSize;
                                NameInformation->Name.Buffer[ NameInformation->Name.Length / sizeof( WCHAR )] = UNICODE_NULL;

                                //
                                //  Adjust the name size to account for the unicode
                                //  string structure
                                //

                                NameSize += sizeof( *NameInformation );

                            } else {

                                //
                                //  The file object does not have a name so the name
                                //  size stays zero
                                //
                            }
                        }

                        //
                        //  At this point if we have a name then the name size will
                        //  not be zero and the name is stored in our local name
                        //  information variable
                        //

                        if (NameSize != 0) {

                            //
                            //  Adjust the size of the name up to the next ulong
                            //  boundary and modify the total size required when
                            //  we add in the object name
                            //
                            NameSize = (NameSize + TYPE_ALIGNMENT (SYSTEM_OBJECTTYPE_INFORMATION) - 1) &
                                                   (~(TYPE_ALIGNMENT (SYSTEM_OBJECTTYPE_INFORMATION) - 1));

                            TotalSize += NameSize;

                            //
                            //  If everything has been successful so far, and we have
                            //  a non empty name, and everything fits in the output
                            //  buffer then copy over the name from our local buffer
                            //  into the caller supplied output buffer, append on the
                            //  null terminating character, and adjust the buffer point
                            //  to use the user's buffer
                            //

                            if ((NT_SUCCESS( Status )) &&
                                (NameInformation->Name.Length != 0) &&
                                (TotalSize < Length)) {

                                //
                                //  Use temporary local variable for RltMoveMemory
                                //

                                TempBuffer = (PWSTR)((&ObjectInfo->NameInfo)+1);
                                TempMaximumLength = (USHORT)
                                    (NameInformation->Name.Length + sizeof( UNICODE_NULL ));

                                ObjectInfo->NameInfo.Name.Length = NameInformation->Name.Length;

                                RtlMoveMemory( TempBuffer,
                                               NameInformation->Name.Buffer,
                                               TempMaximumLength);

                                ObjectInfo->NameInfo.Name.Buffer = (PWSTR)
                                    (UserModeBufferAddress +
                                     ((PCHAR)TempBuffer - (PCHAR)ObjectInformation));
                                ObjectInfo->NameInfo.Name.MaximumLength = TempMaximumLength;

                            //
                            //  Otherwise if we've been successful so far but for some
                            //  reason we weren't able to store the object name then
                            //  decide if it was because of an not enough space or
                            //  because the object name is null
                            //

                            } else if (NT_SUCCESS( Status )) {

                                if ((NameInformation->Name.Length != 0) ||
                                    (TotalSize >= Length)) {

                                    ReturnStatus = STATUS_INFO_LENGTH_MISMATCH;

                                } else {

                                    RtlInitUnicodeString( &ObjectInfo->NameInfo.Name, NULL );
                                }

                            //
                            //  Otherwise we have not been successful so far, we'll
                            //  adjust the total size to account for a null unicode
                            //  string, and if it doesn't fit then that's an error
                            //  otherwise we'll put in the null object name
                            //

                            } else {

                                TotalSize += sizeof( ObjectInfo->NameInfo.Name );

                                if (TotalSize >= Length) {

                                    ReturnStatus = STATUS_INFO_LENGTH_MISMATCH;

                                } else {

                                    RtlInitUnicodeString( &ObjectInfo->NameInfo.Name, NULL );

                                    ReturnStatus = Status;
                                }
                            }

                        //
                        //  Otherwise the name size is zero meaning we have not found
                        //  an object name, so we'll adjust total size for the null
                        //  unicode string, and check that it fits in the output
                        //  buffer.  If it fits we'll output a null object name
                        //

                        } else {

                            TotalSize += sizeof( ObjectInfo->NameInfo.Name );

                            if (TotalSize >= Length) {

                                ReturnStatus = STATUS_INFO_LENGTH_MISMATCH;

                            } else {

                                RtlInitUnicodeString( &ObjectInfo->NameInfo.Name, NULL );
                            }
                        }

                    }

                    //
                    //  Release the array with objects
                    //

                    ObpDestroyTypeArray(ObjectTypeArray);
                    ObjectTypeArray = NULL;
                }
            }
        }

        //
        //  Fill in the total size needed to store the buffer if the user wants
        //  that information.  And return to our caller
        //

        if (ARGUMENT_PRESENT( ReturnLength )) {

            *ReturnLength = TotalSize;
        }


    } finally {

        if (ObjectTypeArray != NULL) {

            ObpDestroyTypeArray(ObjectTypeArray);
        }

        ObpDestroyTypeArray( TypeObjectTypeArray );
        
        ExFreePoolWithTag( TmpBuffer, 'rAbO' );
    }
    
    if (TypeInfo == NULL) {

        return STATUS_UNSUCCESSFUL;
    }

    return( ReturnStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obse.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obse.c

Abstract:

    Object Security API calls

--*/

#include "obp.h"

#if defined(ALLOC_PRAGMA)

#pragma alloc_text(PAGE,NtSetSecurityObject)
#pragma alloc_text(PAGE,NtQuerySecurityObject)
#pragma alloc_text(PAGE,ObAssignObjectSecurityDescriptor)
#pragma alloc_text(PAGE,ObAssignSecurity)
#pragma alloc_text(PAGE,ObCheckCreateObjectAccess)
#pragma alloc_text(PAGE,ObCheckObjectAccess)
#pragma alloc_text(PAGE,ObpCheckObjectReference)
#pragma alloc_text(PAGE,ObpCheckTraverseAccess)
#pragma alloc_text(PAGE,ObGetObjectSecurity)
#pragma alloc_text(PAGE,ObSetSecurityDescriptorInfo)
#pragma alloc_text(PAGE,ObQuerySecurityDescriptorInfo)
#pragma alloc_text(PAGE,ObReleaseObjectSecurity)
#pragma alloc_text(PAGE,ObValidateSecurityQuota)
#pragma alloc_text(PAGE,ObpValidateAccessMask)
#pragma alloc_text(PAGE,ObSetSecurityObjectByPointer)

#endif

ULONG ObpDefaultSecurityDescriptorLength = 256;

NTSTATUS
NtSetSecurityObject (
    __in HANDLE Handle,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine is used to invoke an object's security routine.  It
    is used to set the object's security state.

Arguments:

    Handle - Supplies the handle for the object being modified

    SecurityInformation - Indicates the type of information we are
        interested in setting. e.g., owner, group, dacl, or sacl.

    SecurityDescriptor - Supplies the security descriptor for the
        object being modified.

Return Value:

    An appropriate NTSTATUS value

--*/

{
    NTSTATUS Status;
    PVOID Object;
    ACCESS_MASK DesiredAccess;
    OBJECT_HANDLE_INFORMATION HandleInformation;
    KPROCESSOR_MODE RequestorMode;
    SECURITY_DESCRIPTOR_RELATIVE *CapturedDescriptor;

    PAGED_CODE();

    //
    //  Make sure the passed security descriptor is really there.
    //  SeCaptureSecurityDescriptor doesn't mind being passed a NULL
    //  SecurityDescriptor, and will just return NULL back.
    //

    if (!ARGUMENT_PRESENT( SecurityDescriptor )) {

        return( STATUS_ACCESS_VIOLATION );
    }

    //
    //  Establish the accesses needed to the object based upon the
    //  security information being modified.
    //

    SeSetSecurityAccessMask( SecurityInformation, &DesiredAccess );

    Status = ObReferenceObjectByHandle( Handle,
                                        DesiredAccess,
                                        NULL,
                                        RequestorMode = KeGetPreviousMode(),
                                        &Object,
                                        &HandleInformation );

    if (NT_SUCCESS( Status )) {

        //
        //  Probe and capture the input security descriptor, and return
        //  right away if it is ill-formed.
        //
        //  Because the security descriptor is always captured the returned
        //  security descriptor is in self-relative format.
        //

        Status = SeCaptureSecurityDescriptor( SecurityDescriptor,
                                              RequestorMode,
                                              PagedPool,
                                              TRUE,
                                              (PSECURITY_DESCRIPTOR *)&CapturedDescriptor );

        if (NT_SUCCESS( Status )) {

            //
            //  Now check for a valid combination of what the user wants to set
            //  and what was supplied in the input security descriptor.  If the
            //  caller wants to set the owner then the owner field of the
            //  security descriptor better not be null, likewise for the group
            //  setting.  If anything is missing we'll return and error.
            //

            ASSERT(CapturedDescriptor->Control & SE_SELF_RELATIVE);

            if (((SecurityInformation & OWNER_SECURITY_INFORMATION) &&
                (CapturedDescriptor->Owner == 0))

                ||

                ((SecurityInformation & GROUP_SECURITY_INFORMATION) &&
                (CapturedDescriptor->Group == 0))) {

                SeReleaseSecurityDescriptor( (PSECURITY_DESCRIPTOR)CapturedDescriptor,
                                             RequestorMode,
                                             TRUE );

                ObDereferenceObject( Object );

                return( STATUS_INVALID_SECURITY_DESCR );
            }

            Status = ObSetSecurityObjectByPointer( Object,
                                                   SecurityInformation,
                                                   CapturedDescriptor );

            SeReleaseSecurityDescriptor( (PSECURITY_DESCRIPTOR)CapturedDescriptor,
                                         RequestorMode,
                                         TRUE );
        }

        ObDereferenceObject( Object );

    }

    return( Status );
}


NTSTATUS
ObSetSecurityObjectByPointer (
    __in PVOID Object,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine is used to invoke an object's security routine.  It
    is used to set the object's security state.

    This routine is accessible only to the kernel and assumes that all
    necessary validation of parameters has been done by the caller.

Arguments:

    Object - Supplies the pointer for the object being modified

    SecurityInformation - Indicates the type of information we are
        interested in setting. e.g., owner, group, dacl, or sacl.

    SecurityDescriptor - Supplies the security descriptor for the
        object being modified.

Return Value:

    An appropriate NTSTATUS value

--*/

{
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;

    PAGED_CODE();

//    DbgPrint("ObSetSecurityObjectByPointer called for object %#08lx with info "
//             "%x and descriptor %#08lx\n",
//             Object, SecurityInformation, SecurityDescriptor);

    //
    //  Map the object body to an object header and the corresponding
    //  object type
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    //
    //  Make sure the passed security descriptor is really there.
    //

    ASSERT(ARGUMENT_PRESENT( SecurityDescriptor ));

    //
    //  Now invoke the security procedure call back to set the security
    //  descriptor for the object
    //

    Status = (ObjectType->TypeInfo.SecurityProcedure)
                ( Object,
                  SetSecurityDescriptor,
                  &SecurityInformation,
                  SecurityDescriptor,
                  NULL,
                  &ObjectHeader->SecurityDescriptor,
                  ObjectType->TypeInfo.PoolType,
                  &ObjectType->TypeInfo.GenericMapping );


//    DbgPrint("ObSetSecurityObjectByPointer: object security routine returned "
//             "%#08lx\n", Status);

    return( Status );
}

NTSTATUS
NtQuerySecurityObject (
    __in HANDLE Handle,
    __in SECURITY_INFORMATION SecurityInformation,
    __out_bcount_opt(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG Length,
    __out PULONG LengthNeeded
    )

/*++

Routine Description:

    This routine is used to query the security descriptor for an
    object.

Arguments:

    Handle - Supplies the handle for the object being investigated

    SecurityInformation - Indicates the type of information we are
        interested in getting. e.g., owner, group, dacl, or sacl.

    SecurityDescriptor - Supplies a pointer to where the information
        should be returned

    Length - Supplies the size, in bytes, of the output buffer

    LengthNeeded - Receives the length, in bytes, needed to store
        the output security descriptor

Return Value:

    An appropriate NTSTATUS value

--*/

{
    NTSTATUS Status;
    PVOID Object;
    ACCESS_MASK DesiredAccess;
    OBJECT_HANDLE_INFORMATION HandleInformation;
    KPROCESSOR_MODE RequestorMode;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;

    PAGED_CODE();

    //
    //  Probe output parameters
    //

    RequestorMode = KeGetPreviousMode();

    if (RequestorMode != KernelMode) {

        try {

            ProbeForWriteUlong( LengthNeeded );

            ProbeForWrite( SecurityDescriptor, Length, sizeof(ULONG) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();
        }
    }

    //
    //  Establish the accesses needed to the object based upon the
    //  security information being queried
    //

    SeQuerySecurityAccessMask( SecurityInformation, &DesiredAccess );

    Status = ObReferenceObjectByHandle( Handle,
                                        DesiredAccess,
                                        NULL,
                                        RequestorMode,
                                        &Object,
                                        &HandleInformation );

    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    //
    //  Map the object body to an object header and the corresponding
    //  object type
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    //
    //  Invoke the object type's security callback routine to query
    //  the object.  This routine is assumed to have a try-except around
    //  the setting of the output security descriptor
    //

    Status = (ObjectType->TypeInfo.SecurityProcedure)( Object,
                                                       QuerySecurityDescriptor,
                                                       &SecurityInformation,
                                                       SecurityDescriptor,
                                                       &Length,
                                                       &ObjectHeader->SecurityDescriptor,
                                                       ObjectType->TypeInfo.PoolType,
                                                       &ObjectType->TypeInfo.GenericMapping );

    //
    //  Indicate the length needed for the security descriptor.  This
    //  will be set even if the callback failed so the caller will know
    //  the number of bytes necessary
    //

    try {

        *LengthNeeded = Length;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        ObDereferenceObject( Object );

        return(GetExceptionCode());
    }

    //
    //  And return to our caller
    //

    ObDereferenceObject( Object );

    return( Status );
}


BOOLEAN
ObCheckObjectAccess (
    __in PVOID Object,
    __inout PACCESS_STATE AccessState,
    __in BOOLEAN TypeMutexLocked,
    __in KPROCESSOR_MODE AccessMode,
    __out PNTSTATUS AccessStatus
    )

/*++

Routine Description:

    This routine performs access validation on the passed object.  The
    remaining desired access mask is extracted from the AccessState
    parameter and passes to the appropriate security routine to perform the
    access check.

    If the access attempt is successful, SeAccessCheck returns a mask
    containing the granted accesses.  The bits in this mask are turned
    on in the PreviouslyGrantedAccess field of the AccessState, and
    are turned off in the RemainingDesiredAccess field.

Arguments:

    Object - The object being examined.

    AccessState - The ACCESS_STATE structure containing accumulated
        information about the current attempt to gain access to the object.

    TypeMutexLocked - Indicates whether the type mutex for this object's
        type is locked.  The type mutex is used to protect the object's
        security descriptor from being modified while it is being accessed.

    AccessMode - The previous processor mode.

    AccessStatus - Pointer to a variable to return the status code of the
        access attempt.  In the case of failure this status code must be
        propagated back to the user.


Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise

--*/

{
    ACCESS_MASK GrantedAccess = 0;
    BOOLEAN AccessAllowed;
    BOOLEAN MemoryAllocated;
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    PPRIVILEGE_SET Privileges = NULL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (TypeMutexLocked);

    //
    //  Map the object body to an object header and the
    //  corresponding object type
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    //
    //  Obtain the object's security descriptor
    //

    Status = ObGetObjectSecurity( Object,
                                  &SecurityDescriptor,
                                  &MemoryAllocated );

    //
    //  If we failed in getting the security descriptor then
    //  put the object type lock back where it was and return
    //  the error back to our caller
    //

    if (!NT_SUCCESS( Status )) {

        *AccessStatus = Status;

        return( FALSE );

    } else {

        //
        //  Otherwise we've been successful at getting the
        //  object's security descriptor, but now make sure
        //  it is not null.

        if (SecurityDescriptor == NULL) {

            *AccessStatus = Status;

            return(TRUE);
        }
    }

    //
    //  We have a non-null security descriptor so now
    //  lock the caller's tokens until after auditing has been
    //  performed.
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    //
    //  Do the access check, and if we have some privileges then
    //  put those in the access state too.
    //

    AccessAllowed = SeAccessCheck( SecurityDescriptor,
                                   &AccessState->SubjectSecurityContext,
                                   TRUE,                        // Tokens are locked
                                   AccessState->RemainingDesiredAccess,
                                   AccessState->PreviouslyGrantedAccess,
                                   &Privileges,
                                   &ObjectType->TypeInfo.GenericMapping,
                                   AccessMode,
                                   &GrantedAccess,
                                   AccessStatus );

    if (Privileges != NULL) {

        Status = SeAppendPrivileges( AccessState,
                                     Privileges );

        SeFreePrivileges( Privileges );
    }

    //
    //  If we were granted access then set that fact into
    //  what we've been granted and remove it from what remains
    //  to be granted.
    //

    if (AccessAllowed) {

        AccessState->PreviouslyGrantedAccess |= GrantedAccess;
        AccessState->RemainingDesiredAccess &= ~(GrantedAccess | MAXIMUM_ALLOWED);
    }

    //
    //  Audit the attempt to open the object, audit
    //  the creation of its handle later.
    //

    if ( SecurityDescriptor != NULL ) {

        SeOpenObjectAuditAlarm( &ObjectType->Name,
                                Object,
                                NULL,                    // AbsoluteObjectName
                                SecurityDescriptor,
                                AccessState,
                                FALSE,                   // ObjectCreated (FALSE, only open here)
                                AccessAllowed,
                                AccessMode,
                                &AccessState->GenerateOnClose );
    }

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    //
    //  Free the security descriptor before returning to
    //  our caller
    //

    ObReleaseObjectSecurity( SecurityDescriptor,
                             MemoryAllocated );

    return( AccessAllowed );
}


BOOLEAN
ObpCheckObjectReference (
    IN PVOID Object,
    IN OUT PACCESS_STATE AccessState,
    IN BOOLEAN TypeMutexLocked,
    IN KPROCESSOR_MODE AccessMode,
    OUT PNTSTATUS AccessStatus
    )

/*++

Routine Description:

    The routine performs access validation on the passed object.  The
    remaining desired access mask is extracted from the AccessState
    parameter and passes to the appropriate security routine to
    perform the access check.

    If the access attempt is successful, SeAccessCheck returns a mask
    containing the granted accesses.  The bits in this mask are turned
    on in the PreviouslyGrantedAccess field of the AccessState, and
    are turned off in the RemainingDesiredAccess field.

    This routine differs from ObpCheckObjectAccess in that it calls
    a different audit routine.

Arguments:

    Object - The object being examined.

    AccessState - The ACCESS_STATE structure containing accumulated
        information about the current attempt to gain access to the object.

    TypeMutexLocked - Indicates whether the type mutex for this object's
        type is locked.  The type mutex is used to protect the object's
        security descriptor from being modified while it is being accessed.

    AccessMode - The previous processor mode.

    AccessStatus - Pointer to a variable to return the status code of the
        access attempt.  In the case of failure this status code must be
        propagated back to the user.


Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise

--*/

{
    BOOLEAN AccessAllowed;
    ACCESS_MASK GrantedAccess = 0;
    BOOLEAN MemoryAllocated;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    PPRIVILEGE_SET Privileges = NULL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (TypeMutexLocked);

    //
    //  Map the object body to an object header and the
    //  corresponding object type
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    //
    //  Obtain the object's security descriptor
    //

    Status = ObGetObjectSecurity( Object,
                                  &SecurityDescriptor,
                                  &MemoryAllocated );

    //
    //  If we failed in getting the security descriptor then
    //  put the object type lock back where it was and return
    //  the error back to our caller
    //

    if (!NT_SUCCESS( Status )) {

        *AccessStatus = Status;

        return( FALSE );
    }

    //
    //  Lock the caller's tokens until after auditing has been
    //  performed.
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    //
    //  Do the access check, and if we have some privileges then
    //  put those in the access state too.
    //

    AccessAllowed = SeAccessCheck( SecurityDescriptor,
                                   &AccessState->SubjectSecurityContext,
                                   TRUE,               // Tokens are locked
                                   AccessState->RemainingDesiredAccess,
                                   AccessState->PreviouslyGrantedAccess,
                                   &Privileges,
                                   &ObjectType->TypeInfo.GenericMapping,
                                   AccessMode,
                                   &GrantedAccess,
                                   AccessStatus );

    if (AccessAllowed) {

        AccessState->PreviouslyGrantedAccess |= GrantedAccess;
        AccessState->RemainingDesiredAccess &= ~GrantedAccess;
    }

    //
    //  If we have a security descriptor then call the security routine
    //  to audit this reference and then unlock the caller's token
    //

    if ( SecurityDescriptor != NULL ) {

        SeObjectReferenceAuditAlarm( &AccessState->OperationID,
                                     Object,
                                     SecurityDescriptor,
                                     &AccessState->SubjectSecurityContext,
                                     AccessState->RemainingDesiredAccess | AccessState->PreviouslyGrantedAccess,
                                     ((PAUX_ACCESS_DATA)(AccessState->AuxData))->PrivilegesUsed,
                                     AccessAllowed,
                                     AccessMode );
    }

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    //
    //  Finally free the security descriptor
    //  and return to our caller
    //

    ObReleaseObjectSecurity( SecurityDescriptor,
                             MemoryAllocated );

    return( AccessAllowed );
}


BOOLEAN
ObpCheckTraverseAccess (
    IN PVOID DirectoryObject,
    IN ACCESS_MASK TraverseAccess,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN TypeMutexLocked,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PNTSTATUS AccessStatus
    )

/*++

Routine Description:

    This routine checks for traverse access to the given directory object.

    Note that the contents of the AccessState structure are not
    modified, since it is assumed that this access check is incidental
    to another access operation.

Arguments:

    DirectoryObject - The object body of the object being examined.

    TraverseAccess - The desired access to the object, most likely DIRECTORY
        TRAVERSE access.

    AccessState - Checks for traverse access will typically be incidental
        to some other access attempt.  Information on the current state of
        that access attempt is required so that the constituent access
        attempts may be associated with each other in the audit log.

    TypeMutexLocked - Indicates whether the type mutex for this object's
        type is locked.  The type mutex is used to protect the object's
        security descriptor from being modified while it is being accessed.

    PreviousMode - The previous processor mode.

    AccessStatus - Pointer to a variable to return the status code of the
        access attempt.  In the case of failure this status code must be
        propagated back to the user.

Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise.  AccessStatus
    contains the status code to be passed back to the caller.  It is not
    correct to simply pass back STATUS_ACCESS_DENIED, since this will have
    to change with the advent of mandatory access control.

--*/

{
    BOOLEAN AccessAllowed;
    ACCESS_MASK GrantedAccess = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    BOOLEAN MemoryAllocated;
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    PPRIVILEGE_SET Privileges = NULL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (TypeMutexLocked);

    //
    //  Map the object body to an object header and corresponding
    //  object type
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( DirectoryObject );
    ObjectType = ObjectHeader->Type;

    //
    //  Obtain the object's security descriptor and make it was
    //  successful
    //

    Status = ObGetObjectSecurity( DirectoryObject,
                                  &SecurityDescriptor,
                                  &MemoryAllocated );

    if (!NT_SUCCESS( Status )) {

        *AccessStatus = Status;

        return( FALSE );
    }

    if (!SeFastTraverseCheck( SecurityDescriptor,
                              AccessState,
                              DIRECTORY_TRAVERSE,
                              PreviousMode )) {

        //
        //  SeFastTraverseCheck could be modified to tell us that
        //  no one has any access to this directory.  However,
        //  we're going to have to fail this entire call if
        //  that is the case, so we really don't need to worry
        //  all that much about making it blindingly fast.
        //
        //  The world does not have traverse access and we have
        //  the client's access state so lock down the client's
        //  token and then do the access check, appending privileges
        //  if present.  The access check will give the answer
        //  we return back to our caller
        //

        SeLockSubjectContext( &AccessState->SubjectSecurityContext );

        AccessAllowed = SeAccessCheck( SecurityDescriptor,
                                       &AccessState->SubjectSecurityContext,
                                       TRUE,             // Tokens are locked
                                       TraverseAccess,
                                       0,
                                       &Privileges,
                                       &ObjectType->TypeInfo.GenericMapping,
                                       PreviousMode,
                                       &GrantedAccess,
                                       AccessStatus );

        if (Privileges != NULL) {

            Status = SeAppendPrivileges( AccessState,
                                         Privileges );

            SeFreePrivileges( Privileges );
        }

        //
        //  If the client's token is locked then now we can unlock it
        //

        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    } else {

        //
        //  At this point the world has traverse access
        //

        AccessAllowed = TRUE;
    }

    //
    //  Finally free the security descriptor
    //  and then return to our caller
    //

    ObReleaseObjectSecurity( SecurityDescriptor,
                             MemoryAllocated );

    return( AccessAllowed );
}


BOOLEAN
ObCheckCreateObjectAccess (
    __in PVOID DirectoryObject,
    __in ACCESS_MASK CreateAccess,
    __in PACCESS_STATE AccessState,
    __in PUNICODE_STRING ComponentName,
    __in BOOLEAN TypeMutexLocked,
    __in KPROCESSOR_MODE PreviousMode,
    __out PNTSTATUS AccessStatus
    )

/*++

Routine Description:

    This routine checks to see if we are allowed to create an object in the
    given directory, and performs auditing as appropriate.

Arguments:

    DirectoryObject - The directory object being examined.

    CreateAccess - The access mask corresponding to create access for
        this directory type.

    AccessState - Checks for traverse access will typically be incidental
        to some other access attempt.  Information on the current state of
        that access attempt is required so that the constituent access
        attempts may be associated with each other in the audit log.

    ComponentName - Pointer to a Unicode string containing the name of
        the object being created.

    TypeMutexLocked - Indicates whether the type mutex for this object's
        type is locked.  The type mutex is used to protect the object's
        security descriptor from being modified while it is being accessed.

    PreviousMode - The previous processor mode.

    AccessStatus - Pointer to a variable to return the status code of the
        access attempt.  In the case of failure this status code must be
        propagated back to the user.

Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise.  AccessStatus
    contains the status code to be passed back to the caller.  It is not
    correct to simply pass back STATUS_ACCESS_DENIED, since this will have
    to change with the advent of mandatory access control.

--*/

{
    BOOLEAN AccessAllowed;
    ACCESS_MASK GrantedAccess = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    BOOLEAN MemoryAllocated;
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    POBJECT_TYPE ObjectType;
    PPRIVILEGE_SET Privileges = NULL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ComponentName);
    UNREFERENCED_PARAMETER (TypeMutexLocked);

    //
    //  Map the object body to its object header and corresponding
    //  object type
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( DirectoryObject );
    ObjectType = ObjectHeader->Type;

    //
    //  Obtain the object's security descriptor and make it was
    //  successful
    //

    Status = ObGetObjectSecurity( DirectoryObject,
                                  &SecurityDescriptor,
                                  &MemoryAllocated );

    if (!NT_SUCCESS( Status )) {

        *AccessStatus = Status;

        return( FALSE );
    }

    //
    //  lock the caller's tokens until after auditing has been
    //  performed.
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    //
    //  if we have a security descriptor then do an access
    //  check to see if access is allowed and set in the
    //  privileges if necessary
    //

    if (SecurityDescriptor != NULL) {

        AccessAllowed = SeAccessCheck( SecurityDescriptor,
                                       &AccessState->SubjectSecurityContext,
                                       TRUE,            // Tokens are locked
                                       CreateAccess,
                                       0,
                                       &Privileges,
                                       &ObjectType->TypeInfo.GenericMapping,
                                       PreviousMode,
                                       &GrantedAccess,
                                       AccessStatus );

        if (Privileges != NULL) {

            Status = SeAppendPrivileges( AccessState,
                                         Privileges );

            SeFreePrivileges( Privileges );
        }

        //
        //  This is wrong, but leave for reference.
        //
        //  if (AccessAllowed) {
        //
        //      AccessState->PreviouslyGrantedAccess |= GrantedAccess;
        //      AccessState->RemainingDesiredAccess &= ~GrantedAccess;
        //  }
        //

    } else {

        //
        //  At this point there is not a security descriptor
        //  so we'll assume access is allowed
        //

        AccessAllowed = TRUE;
    }

    //
    //  Free the caller's token and if the caller didn't have the
    //  object type locked we need to free it.
    //

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    //
    //  Finally free the security descriptor
    //  and return to our caller
    //

    ObReleaseObjectSecurity( SecurityDescriptor,
                             MemoryAllocated );

    return( AccessAllowed );
}


NTSTATUS
ObAssignObjectSecurityDescriptor (
    IN PVOID Object,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN POOL_TYPE PoolType // This field is currently ignored.
    )

/*++

Routine Description:

    Takes a pointer to an object and sets the SecurityDescriptor field
    in the object's header.

Arguments:

    Object - Supplies a pointer to the object

    SecurityDescriptor - Supplies a pointer to the security descriptor
        to be assigned to the object.  This pointer may be null if there
        is no security on the object.

    PoolType - Supplies the type of pool memory used to allocate the
        security descriptor.  This field is currently ignored.

Return Value:

    An appropriate NTSTATUS value.

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR OutputSecurityDescriptor;
    POBJECT_HEADER ObjectHeader;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PoolType);

    //
    //  If the security descriptor isn't supplied then we set the
    //  object header's security descriptor to null and return
    //  to our caller
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    if (!ARGUMENT_PRESENT(SecurityDescriptor)) {

        ExFastRefInitialize ((PEX_FAST_REF) &ObjectHeader->SecurityDescriptor, NULL);

        return( STATUS_SUCCESS );
    }

    //
    //  Log the new security descriptor into our security database and
    //  get back the real security descriptor to use
    //

    Status = ObLogSecurityDescriptor( SecurityDescriptor,
                                      &OutputSecurityDescriptor,
                                      ExFastRefGetAdditionalReferenceCount () + 1 );

    //
    //  If we've been successful so far then set the object's
    //  security descriptor to the newly allocated one.
    //

    if (NT_SUCCESS(Status)) {

        ExFreePool (SecurityDescriptor);

        ASSERT (OutputSecurityDescriptor);
        __assume (OutputSecurityDescriptor);
        //
        // Initialize a fast reference structure with zero additional references
        //
        ExFastRefInitialize ((PEX_FAST_REF) &ObjectHeader->SecurityDescriptor, OutputSecurityDescriptor);
    }

    //
    //  And return to our caller
    //

    return( Status );
}



NTSTATUS
ObGetObjectSecurity (
    __in PVOID Object,
    __out PSECURITY_DESCRIPTOR *SecurityDescriptor,
    __out PBOOLEAN MemoryAllocated
    )

/*++

Routine Description:

    Given an object, this routine will find its security descriptor.
    It will do this by calling the object's security method.

    It is possible for an object not to have a security descriptor
    at all.  Unnamed objects such as events that can only be referenced
    by a handle are an example of an object that does not have a
    security descriptor.

Arguments:

    Object - Supplies the object body being queried.

    SecurityDescriptor - Returns a pointer to the object's security
        descriptor.

    MemoryAllocated - indicates whether we had to allocate pool
        memory to hold the security descriptor or not.  This should
        be passed back into ObReleaseObjectSecurity.

Return Value:

    STATUS_SUCCESS - The operation was successful.  Note that the
        operation may be successful and still return a NULL security
        descriptor.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient memory was available
        to satisfy the request.

--*/

{
    SECURITY_INFORMATION SecurityInformation;
    ULONG Length = ObpDefaultSecurityDescriptorLength;
    NTSTATUS Status;
    POBJECT_TYPE ObjectType;
    POBJECT_HEADER ObjectHeader;
#if DBG
    KIRQL SaveIrql;
#endif

    PAGED_CODE();

    //
    //  Map the object body to its object header and corresponding
    //  object type
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    ObjectType = ObjectHeader->Type;

    //
    //  If the object is one that uses the default object method,
    //  its security descriptor is contained in ob's security
    //  descriptor cache.
    //
    //  Reference it so that it doesn't go away out from under us.
    //

    if (ObpCentralizedSecurity(ObjectType))  {

        *SecurityDescriptor = ObpReferenceSecurityDescriptor( ObjectHeader );

        *MemoryAllocated = FALSE;

        return( STATUS_SUCCESS );
    }

    //
    //  Request a complete security descriptor
    //

    SecurityInformation = OWNER_SECURITY_INFORMATION |
                          GROUP_SECURITY_INFORMATION |
                          DACL_SECURITY_INFORMATION  |
                          SACL_SECURITY_INFORMATION;

    //
    //  We don't know exactly how large is the SD, but we try with the largest
    //  size we get so far. In general the SD will be released after
    //  the access is checked. It shouldn't be then a problem of an extra pool usage
    //  because this oversizing
    //

    *SecurityDescriptor = ExAllocatePoolWithTag( PagedPool, Length, 'qSbO' );

    if (*SecurityDescriptor == NULL) {

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    *MemoryAllocated = TRUE;

    //
    //  The security method will return an absolute format
    //  security descriptor that just happens to be in a self
    //  contained buffer (not to be confused with a self-relative
    //  security descriptor).
    //

    ObpBeginTypeSpecificCallOut( SaveIrql );

    Status = (*ObjectType->TypeInfo.SecurityProcedure)( Object,
                                                        QuerySecurityDescriptor,
                                                        &SecurityInformation,
                                                        *SecurityDescriptor,
                                                        &Length,
                                                        &ObjectHeader->SecurityDescriptor,
                                                        ObjectType->TypeInfo.PoolType,
                                                        &ObjectType->TypeInfo.GenericMapping );

    ObpEndTypeSpecificCallOut( SaveIrql, "Security", ObjectType, Object );

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        //
        //  The SD is larger than we tried first time. We need to allocate an other
        //  buffer and try again with this size
        //

        ExFreePool( *SecurityDescriptor );
        *MemoryAllocated = FALSE;

        //
        //  Save the new largest size
        //

        ObpDefaultSecurityDescriptorLength = Length;

//        DbgPrint( "ObpDefaultSecurityDescriptorLength increased to %ld\n",
//                  ObpDefaultSecurityDescriptorLength);

        //
        //  Now that we know how large the security descriptor is we
        //  can allocate space for it
        //

        *SecurityDescriptor = ExAllocatePoolWithTag( PagedPool, Length, 'qSbO' );

        if (*SecurityDescriptor == NULL) {

            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        *MemoryAllocated = TRUE;

        //
        //  The security method will return an absolute format
        //  security descriptor that just happens to be in a self
        //  contained buffer (not to be confused with a self-relative
        //  security descriptor).
        //

        ObpBeginTypeSpecificCallOut( SaveIrql );

        Status = (*ObjectType->TypeInfo.SecurityProcedure)( Object,
                                                            QuerySecurityDescriptor,
                                                            &SecurityInformation,
                                                            *SecurityDescriptor,
                                                            &Length,
                                                            &ObjectHeader->SecurityDescriptor,
                                                            ObjectType->TypeInfo.PoolType,
                                                            &ObjectType->TypeInfo.GenericMapping );

        ObpEndTypeSpecificCallOut( SaveIrql, "Security", ObjectType, Object );
    }

    if (!NT_SUCCESS( Status )) {

        ExFreePool( *SecurityDescriptor );

        *MemoryAllocated = FALSE;
    }

    return( Status );
}


VOID
ObReleaseObjectSecurity (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in BOOLEAN MemoryAllocated
    )

/*++

Routine Description:

    This function will free up any memory associated with a queried
    security descriptor.  This undoes the function ObGetObjectSecurity

Arguments:

    SecurityDescriptor - Supplies a pointer to the security descriptor
        to be freed.

    MemoryAllocated - Supplies whether or not we should free the
        memory pointed to by SecurityDescriptor.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check if there is a security descriptor to actually free
    //

    if ( SecurityDescriptor != NULL ) {

        //
        //  If ObGetObjectSecurity allocated memory then we
        //  need to free it. Otherwise what the earlier routine did
        //  was reference the object to keep the security descriptor
        //  to keep it from going away
        //

        if (MemoryAllocated) {

            ExFreePool( SecurityDescriptor );

        } else {

            ObDereferenceSecurityDescriptor( SecurityDescriptor, 1);
        }
    }
}


NTSTATUS
ObValidateSecurityQuota (
    IN PVOID Object,
    IN ULONG NewSize
    )

/*++

Routine Description:

    This routine will check to see if the new security information
    is larger than is allowed by the object's pre-allocated quota.

Arguments:

    Object - Supplies a pointer to the object whose information is to be
        modified.

    NewSize - Supplies the size of the proposed new security
        information.

Return Value:

    STATUS_SUCCESS - New size is within allotted quota.

    STATUS_QUOTA_EXCEEDED - The desired adjustment would have exceeded
        the permitted security quota for this object.

--*/

{
    POBJECT_HEADER ObjectHeader;
    POBJECT_HEADER_QUOTA_INFO QuotaInfo;

    PAGED_CODE();

    //
    //  Map the object body to its object header and corresponding
    //  quota information block
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    //
    // If we never charged quota originaly then don't worry about it now.
    //
    if (ObjectHeader->QuotaBlockCharged == (PEPROCESS_QUOTA_BLOCK) 1) {
        return( STATUS_SUCCESS );
    }

    QuotaInfo = OBJECT_HEADER_TO_QUOTA_INFO( ObjectHeader );

    //
    //  If there isn't any quota info and the new size is greater
    //  then the default security quota then if the object uses
    //  the default value then we've exceeded quota otherwise
    //  let the caller get the quota
    //

    if ((QuotaInfo == NULL) && (NewSize > SE_DEFAULT_SECURITY_QUOTA)) {


        if (!(ObjectHeader->Flags & OB_FLAG_DEFAULT_SECURITY_QUOTA)) {

            return( STATUS_SUCCESS );
        }

        return( STATUS_QUOTA_EXCEEDED );

    //
    //  If the quota is not null and the new size is greater than the
    //  allowed quota charge then if the charge is zero we grant the
    //  request otherwise we've exceeded quota.
    //

    } else if ((QuotaInfo != NULL) && (NewSize > QuotaInfo->SecurityDescriptorCharge)) {

        if (QuotaInfo->SecurityDescriptorCharge == 0) {

            //
            //  Should really charge quota here.
            //

            //  QuotaInfo->SecurityDescriptorCharge = SeComputeSecurityQuota( NewSize );

            return( STATUS_SUCCESS );
        }

        return( STATUS_QUOTA_EXCEEDED );

    //
    //  Otherwise we have two cases.  (1) there isn't any quota info but
    //  the size is within limits or (2) there is a quota info block and
    //  the size is within the specified security descriptor charge so
    //  return success to our caller
    //

    } else {

        return( STATUS_SUCCESS );
    }
}


NTSTATUS
ObAssignSecurity (
    __in PACCESS_STATE AccessState,
    __in_opt PSECURITY_DESCRIPTOR ParentDescriptor,
    __in PVOID Object,
    __in POBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine will assign a security descriptor to a newly created object.
    It assumes that the AccessState parameter contains a captured security
    descriptor.

Arguments:

     AccessState - The AccessState containing the security information
        for this object creation.

     ParentDescriptor - The security descriptor from the parent object, if
        available.

     Object - A pointer to the object being created.

     ObjectType - Supplies the type of object being created.

Return Value:

    STATUS_SUCCESS - indicates the operation was successful.

    STATUS_INVALID_OWNER - The owner SID provided as the owner of the
        target security descriptor is not one the caller is authorized
        to assign as the owner of an object.

    STATUS_PRIVILEGE_NOT_HELD - The caller does not have the privilege
        necessary to explicitly assign the specified system ACL.
        SeSecurityPrivilege privilege is needed to explicitly assign
        system ACLs to objects.

--*/

{
    PSECURITY_DESCRIPTOR NewDescriptor = NULL;
    NTSTATUS Status;
#if DBG
    KIRQL SaveIrql;
#endif

    PAGED_CODE();

    //
    //  SeAssignSecurity will construct the final version
    //  of the security  descriptor
    //

    Status = SeAssignSecurity( ParentDescriptor,
                               AccessState->SecurityDescriptor,
                               &NewDescriptor,
                               (BOOLEAN)(ObjectType == ObpDirectoryObjectType),
                               &AccessState->SubjectSecurityContext,
                               &ObjectType->TypeInfo.GenericMapping,
                               PagedPool );

    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    ObpBeginTypeSpecificCallOut( SaveIrql );

    //
    //  Now invoke the security method callback to finish
    //  the assignment.
    //

    Status = (*ObjectType->TypeInfo.SecurityProcedure)( Object,
                                                        AssignSecurityDescriptor,
                                                        NULL,
                                                        NewDescriptor,
                                                        NULL,
                                                        NULL,
                                                        PagedPool,
                                                        &ObjectType->TypeInfo.GenericMapping );

    ObpEndTypeSpecificCallOut( SaveIrql, "Security", ObjectType, Object );

    if (!NT_SUCCESS( Status )) {

        //
        // The attempt to assign the security descriptor to the object
        // failed.  Free the space used by the new security descriptor.
        //

        SeDeassignSecurity( &NewDescriptor );
    }

    //
    //  And return to our caller
    //

    return( Status );
}



NTSTATUS
ObQuerySecurityDescriptorInfo(
    IN PVOID Object,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    )
/*++

Routine Description:

    This routine will extract the desired information from the
    passed security descriptor and return the information in
    the passed buffer as a security descriptor in self-relative
    format.

    This routine assumes that all parameters are captured and
    safe to reference.

Arguments:

    Object - Object that is having its security queried

    SecurityInformation - Specifies what information is being queried.

    SecurityDescriptor - Supplies the buffer to output the requested
        information into.

        This buffer has been probed only to the size indicated by
        the Length parameter.  Since it still points into user space,
        it must always be accessed in a try clause.

    Length - Supplies the address of a variable containing the length of
        the security descriptor buffer.  Upon return this variable will
        contain the length needed to store the requested information.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor.  The passed security descriptor
        must be in self-relative format.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error value
        otherwise

--*/
{
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    PSECURITY_DESCRIPTOR ReferencedSecurityDescriptor;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ObjectsSecurityDescriptor);

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    //
    // Reference the security descriptor
    //
    ReferencedSecurityDescriptor = ObpReferenceSecurityDescriptor( ObjectHeader );

    Status = SeQuerySecurityDescriptorInfo( SecurityInformation,
                                            SecurityDescriptor,
                                            Length,
                                            &ReferencedSecurityDescriptor
                                            );

    if (ReferencedSecurityDescriptor != NULL) {
        ObDereferenceSecurityDescriptor ( ReferencedSecurityDescriptor, 1 );
    }

    return( Status );
}



NTSTATUS
ObSetSecurityDescriptorInfo (
    __in PVOID Object,
    __in PSECURITY_INFORMATION SecurityInformation,
    __inout PSECURITY_DESCRIPTOR SecurityDescriptor,
    __inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    __in POOL_TYPE PoolType,
    __in PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    Sets the security descriptor on an already secure object.

Arguments:

    Object - Pointer to the object being modified.

    SecurityInformation - Describes which information in the SecurityDescriptor parameter
        is relevant.

    SecurityDescriptor - Provides the new security information.

    ObjectsSecurityDescriptor - Provides/returns the object's security descriptor.

    PoolType - The pool the ObjectSecurityDescriptor is allocated from.

    GenericMapping - Supplies the generic mapping for the object.

Return Value:

    An appropriate status value

--*/

{
    PSECURITY_DESCRIPTOR OldDescriptor;
    PSECURITY_DESCRIPTOR NewDescriptor;
    PSECURITY_DESCRIPTOR CachedDescriptor;
    NTSTATUS Status;
    POBJECT_HEADER ObjectHeader;
    EX_FAST_REF OldRef;

    PAGED_CODE();

    //
    //  Check the rest of our input and call the default set security
    //  method.  Also make sure no one is modifying the security descriptor
    //  while we're looking at it.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

    //
    // In order to preserve some protected fields in the SD (like the SACL) we need to make sure that only one
    // thread updates it at any one time. If we didn't do this another modification could wipe out a SACL
    // an administrator was adding.
    //
    while (1) {

        //
        // Reference the security descriptor
        //

        OldDescriptor = ObpReferenceSecurityDescriptor( ObjectHeader );
        NewDescriptor = OldDescriptor;

        Status = SeSetSecurityDescriptorInfo( Object,
                                              SecurityInformation,
                                              SecurityDescriptor,
                                              &NewDescriptor,
                                              PoolType,
                                              GenericMapping );
        //
        //  If we successfully set the new security descriptor then we
        //  need to log it in our database and get yet another pointer
        //  to the finally security descriptor
        //
        if ( NT_SUCCESS( Status )) {
            Status = ObLogSecurityDescriptor( NewDescriptor,
                                              &CachedDescriptor,
                                              ExFastRefGetAdditionalReferenceCount () + 1 );
            ExFreePool( NewDescriptor );
            if ( NT_SUCCESS( Status )) {
                //
                // Now we need to see if anyone else update this security descriptor inside the
                // gap where we didn't hold the lock. If they did then we just try it all again.
                //
                OldRef = ExFastRefCompareSwapObject ((PEX_FAST_REF)ObjectsSecurityDescriptor,
                                                     CachedDescriptor,
                                                     OldDescriptor);
                if (ExFastRefEqualObjects (OldRef, OldDescriptor)) {
                    //
                    // The swap occured ok. We must now flush any slow refers out of the slow ref path before
                    // dereferencing the object. We do this by obtaining and dropping the object lock.
                    //
                    ObpLockObject( ObjectHeader );
                    ObpUnlockObject( ObjectHeader );
                    //
                    // If there was an original object then we need to work out how many
                    // cached references there were (if any) and return them.
                    //
                    ObDereferenceSecurityDescriptor( OldDescriptor, ExFastRefGetUnusedReferences (OldRef) + 2 );
                    break;
                } else {
                    ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
                    ObDereferenceSecurityDescriptor( CachedDescriptor, ExFastRefGetAdditionalReferenceCount () + 1);
                }

            } else {

                //
                //  Dereference old SecurityDescriptor
                //

                ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
                break;
            }
        } else {

            //
            //  Dereference old SecurityDescriptor
            //
            if (OldDescriptor != NULL) {
                ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
            }
            break;
        }
    }

    //
    //  And return to our caller
    //

    return( Status );
}


NTSTATUS
ObpValidateAccessMask (
    PACCESS_STATE AccessState
    )

/*++

Routine Description:

    Checks the desired access mask of a passed object against the
    passed security descriptor.

Arguments:

    AccessState - A pointer to the AccessState for the pending operation.

Return Value:

    Only returns STATUS_SUCCESS

--*/

{
    SECURITY_DESCRIPTOR *SecurityDescriptor = AccessState->SecurityDescriptor;

    PAGED_CODE();

    //
    //  First make sure the access state has a security descriptor.  If there
    //  is one and it has a system acl and the previously granted access did
    //  not include system security then add the fact that we want system
    //  security to the remaining desired access state.
    //

    if (SecurityDescriptor != NULL) {

        if ( SecurityDescriptor->Control & SE_SACL_PRESENT ) {

            if ( !(AccessState->PreviouslyGrantedAccess & ACCESS_SYSTEM_SECURITY)) {

                AccessState->RemainingDesiredAccess |= ACCESS_SYSTEM_SECURITY;
            }
        }
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\perf\perfdata.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    perfdata.c

Abstract:

    This module contains the global read/write data for the perf subsystem

--*/

#include "perfp.h"

PERFINFO_GROUPMASK PerfGlobalGroupMask;
PERFINFO_GROUPMASK *PPerfGlobalGroupMask;
const PERFINFO_HOOK_HANDLE PerfNullHookHandle = { NULL, NULL };

//
// Profiling
//

KPROFILE PerfInfoProfileObject;
KPROFILE_SOURCE PerfInfoProfileSourceActive = ProfileMaximum;   // Set to invalid source
KPROFILE_SOURCE PerfInfoProfileSourceRequested = ProfileTime;
KPROFILE_SOURCE PerfInfoProfileInterval = 10000;    // 1ms in 100ns ticks
BOOLEAN PerfInfoSampledProfileCaching;
LONG PerfInfoSampledProfileFlushInProgress;
PERFINFO_SAMPLED_PROFILE_CACHE PerfProfileCache;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ob\obwait.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    obwait.c

Abstract:

    This module implements the generic wait system services.

--*/

#include "obp.h"

NTSTATUS
ObpWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

#pragma alloc_text(PAGE, NtWaitForSingleObject)
#pragma alloc_text(PAGE, NtWaitForMultipleObjects)
#pragma alloc_text(PAGE, NtWaitForMultipleObjects32)
#pragma alloc_text(PAGE, ObWaitForSingleObject)
#pragma alloc_text(PAGE, ObpWaitForMultipleObjects)

//
//  We special case these three object types in the wait routine
//

extern POBJECT_TYPE ExEventObjectType;
extern POBJECT_TYPE ExMutantObjectType;
extern POBJECT_TYPE ExSemaphoreObjectType;

NTSTATUS
NtSignalAndWaitForSingleObject (
    __in HANDLE SignalHandle,
    __in HANDLE WaitHandle,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    This function atomically signals the specified signal object and then
    waits until the specified wait object attains a state of Signaled.  An
    optional timeout can also be specified.  If a timeout is not specified,
    then the wait will not be satisfied until the wait object attains a
    state of Signaled.  If a timeout is specified, and the wait object has
    not attained a state of Signaled when the timeout expires, then the
    wait is automatically satisfied.  If an explicit timeout value of zero
    is specified, then no wait will occur if the wait cannot be satisfied
    immediately.  The wait can also be specified as alertable.

Arguments:

    SignalHandle - Supplies the handle of the signal object.

    WaitHandle  - Supplies the handle for the wait object.

    Alertable - Supplies a boolean value that specifies whether the wait
        is alertable.

    Timeout - Supplies an pointer to an absolute or relative time over
        which the wait is to occur.

Return Value:

    The wait completion status.  A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait.  A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread.  A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{
    OBJECT_HANDLE_INFORMATION HandleInformation;
    KPROCESSOR_MODE PreviousMode;
    PVOID RealObject;
    PVOID SignalObject;
    POBJECT_HEADER SignalObjectHeader;
    NTSTATUS Status;
    LARGE_INTEGER TimeoutValue;
    PVOID WaitObject;
    POBJECT_HEADER WaitObjectHeader;

    //
    //  Establish an exception handler and probe the specified timeout value
    //  if necessary.  If the probe fails, then return the exception code as
    //  the service status.
    //

    PreviousMode = KeGetPreviousMode();

    if ((ARGUMENT_PRESENT(Timeout)) && (PreviousMode != KernelMode)) {

        try {

            TimeoutValue = ProbeAndReadLargeInteger(Timeout);
            Timeout = &TimeoutValue;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();
        }
    }

    //
    //  Reference the signal object by handle.
    //

    Status = ObReferenceObjectByHandle( SignalHandle,
                                        0,
                                        NULL,
                                        PreviousMode,
                                        &SignalObject,
                                        &HandleInformation );

    //
    //  If the reference was successful, then reference the wait object by
    //  handle.
    //

    if (NT_SUCCESS(Status)) {

        Status = ObReferenceObjectByHandle( WaitHandle,
                                            SYNCHRONIZE,
                                            NULL,
                                            PreviousMode,
                                            &WaitObject,
                                            NULL );

        //
        //  If the reference was successful, then determine the real wait
        //  object, check the signal object access, signal the signal object,
        //  and wait for the real wait object.
        //

        if (NT_SUCCESS(Status)) {

            WaitObjectHeader = OBJECT_TO_OBJECT_HEADER(WaitObject);
            RealObject = WaitObjectHeader->Type->DefaultObject;

            if ((LONG_PTR)RealObject >= 0) {

                RealObject = (PVOID)((PCHAR)WaitObject + (ULONG_PTR)RealObject);
            }

            //
            //  If the signal object is an event, then check for modify access
            //  and set the event.  Otherwise, if the signal object is a
            //  mutant, then attempt to release ownership of the mutant.
            //  Otherwise, if the object is a semaphore, then check for modify
            //  access and release the semaphore.  Otherwise, the signal objet
            //  is invalid.
            //

            SignalObjectHeader = OBJECT_TO_OBJECT_HEADER(SignalObject);
            Status = STATUS_ACCESS_DENIED;

            if (SignalObjectHeader->Type == ExEventObjectType) {

                //
                //  Check for access to the specified event object,
                //

                if ((PreviousMode != KernelMode) &&
                    (SeComputeDeniedAccesses( HandleInformation.GrantedAccess,
                                              EVENT_MODIFY_STATE) != 0 )) {

                    goto WaitExit;
                }

                //
                //  Set the specified event and wait atomically.
                //
                //  N.B.  This returns with the dispatcher lock held !!!
                //

                KeSetEvent((PKEVENT)SignalObject, EVENT_INCREMENT, TRUE);

            } else if (SignalObjectHeader->Type == ExMutantObjectType) {

                //
                //  Release the specified mutant and wait atomically.
                //
                //  N.B. The release will only be successful if the current
                //       thread is the owner of the mutant.
                //

                try {

                    KeReleaseMutant( (PKMUTANT)SignalObject,
                                     MUTANT_INCREMENT,
                                     FALSE,
                                     TRUE );

                } except((GetExceptionCode () == STATUS_ABANDONED ||
                          GetExceptionCode () == STATUS_MUTANT_NOT_OWNED)?
                             EXCEPTION_EXECUTE_HANDLER :
                             EXCEPTION_CONTINUE_SEARCH) {
                    Status = GetExceptionCode();

                    goto WaitExit;
                }

            } else if (SignalObjectHeader->Type == ExSemaphoreObjectType) {

                //
                //  Check for access to the specified semaphore object,
                //

                if ((PreviousMode != KernelMode) &&
                    (SeComputeDeniedAccesses( HandleInformation.GrantedAccess,
                                              SEMAPHORE_MODIFY_STATE) != 0 )) {

                    goto WaitExit;
                }

                //
                //  Release the specified semaphore and wait atomically.
                //

                try {

                    //
                    //  Release the specified semaphore and wait atomically.
                    //

                    KeReleaseSemaphore( (PKSEMAPHORE)SignalObject,
                                        SEMAPHORE_INCREMENT,
                                        1,
                                        TRUE );

                } except((GetExceptionCode () == STATUS_SEMAPHORE_LIMIT_EXCEEDED)?
                             EXCEPTION_EXECUTE_HANDLER :
                             EXCEPTION_CONTINUE_SEARCH) {

                    Status = GetExceptionCode();

                    goto WaitExit;
                }

            } else {

                Status = STATUS_OBJECT_TYPE_MISMATCH;

                goto WaitExit;
            }

            //
            //  Protect the wait call just in case KeWait decides to raise
            //  For example, a mutant level is exceeded
            //

            try {

                Status = KeWaitForSingleObject( RealObject,
                                                UserRequest,
                                                PreviousMode,
                                                Alertable,
                                                Timeout );

            } except((GetExceptionCode () == STATUS_MUTANT_LIMIT_EXCEEDED)?
                         EXCEPTION_EXECUTE_HANDLER :
                         EXCEPTION_CONTINUE_SEARCH) {

                Status = GetExceptionCode();
            }

WaitExit:

            ObDereferenceObject(WaitObject);
        }

        ObDereferenceObject(SignalObject);
    }

    return Status;
}

NTSTATUS
NtWaitForSingleObject (
    __in HANDLE Handle,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    This function waits until the specified object attains a state of
    Signaled.  An optional timeout can also be specified.  If a timeout
    is not specified, then the wait will not be satisfied until the
    object attains a state of Signaled.  If a timeout is specified, and
    the object has not attained a state of Signaled when the timeout
    expires, then the wait is automatically satisfied.  If an explicit
    timeout value of zero is specified, then no wait will occur if the
    wait cannot be satisfied immediately.  The wait can also be specified
    as alertable.

Arguments:

    Handle  - Supplies the handle for the wait object.

    Alertable - Supplies a boolean value that specifies whether the wait
        is alertable.

    Timeout - Supplies an pointer to an absolute or relative time over
        which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait.  A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    LARGE_INTEGER TimeoutValue;
    PVOID WaitObject;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe and capture timeout argument
    //  if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if ((ARGUMENT_PRESENT(Timeout)) && (PreviousMode != KernelMode)) {

        try {

            TimeoutValue = ProbeAndReadLargeInteger(Timeout);
            Timeout = &TimeoutValue;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();
        }
    }

    //
    //  Get a referenced pointer to the specified object with synchronize
    //  access.
    //

    Status = ObReferenceObjectByHandle( Handle,
                                        SYNCHRONIZE,
                                        NULL,
                                        PreviousMode,
                                        &Object,
                                        NULL );

    //
    //  If access is granted, then check to determine if the specified object
    //  can be waited on.
    //

    if (NT_SUCCESS(Status)) {

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
        WaitObject = ObjectHeader->Type->DefaultObject;

        if ((LONG_PTR)WaitObject >= 0) {

            WaitObject = (PVOID)((PCHAR)Object + (ULONG_PTR)WaitObject);
        }

        //
        //  Protect the wait call just in case KeWait decides to raise
        //  For example, a mutant level is exceeded
        //

        try {
            PERFINFO_DECLARE_OBJECT(Object);

            Status = KeWaitForSingleObject( WaitObject,
                                            UserRequest,
                                            PreviousMode,
                                            Alertable,
                                            Timeout );

        } except((GetExceptionCode () == STATUS_MUTANT_LIMIT_EXCEEDED)?
                     EXCEPTION_EXECUTE_HANDLER :
                     EXCEPTION_CONTINUE_SEARCH) {

            Status = GetExceptionCode();
        }

        ObDereferenceObject(Object);
    }

    return Status;
}

NTSTATUS
NtWaitForMultipleObjects (
    __in ULONG Count,
    __in_ecount(Count) HANDLE Handles[],
    __in WAIT_TYPE WaitType,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    Handles[] - Supplies an array of handles to wait objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status.  A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait.  A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread.  A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{

    HANDLE CapturedHandles[MAXIMUM_WAIT_OBJECTS];
    KPROCESSOR_MODE PreviousMode;
    LARGE_INTEGER TimeoutValue;

    PAGED_CODE();

    //
    //  If the number of objects is zero or greater than the largest number
    //  that can be waited on, then return and invalid parameter status.
    //

    if ((Count == 0) || (Count > MAXIMUM_WAIT_OBJECTS)) {
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    //  If the wait type is not wait any or wait all, then return an invalid
    //  parameter status.
    //

    if ((WaitType != WaitAny) && (WaitType != WaitAll)) {
        return STATUS_INVALID_PARAMETER_3;
    }

    //
    //  Get previous processor mode and probe and capture input arguments if
    //  necessary.
    //

    PreviousMode = KeGetPreviousMode();
    try {
        if (PreviousMode != KernelMode) {
            if (ARGUMENT_PRESENT(Timeout)) {
                TimeoutValue = ProbeAndReadLargeInteger(Timeout);
                Timeout = &TimeoutValue;
            }

            ProbeForRead( Handles, Count * sizeof(HANDLE), sizeof(HANDLE) );
        }

        RtlCopyMemory (CapturedHandles, Handles, Count * sizeof(HANDLE));

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    return ObpWaitForMultipleObjects(Count,
                                     CapturedHandles,
                                     WaitType,
                                     Alertable,
                                     Timeout);
}

NTSTATUS
NtWaitForMultipleObjects32 (
    __in ULONG Count,
    __in_ecount(Count) LONG Handles[],
    __in WAIT_TYPE WaitType,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled. This function is provided to avoid thunking a 32-bit handle
    table to a 64-bit handle table in wow64.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    Handles[] - Supplies an array of 32-bit handles to wait objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status.  A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait.  A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread.  A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{

    HANDLE CapturedHandles[MAXIMUM_WAIT_OBJECTS];
    ULONG Index;
    KPROCESSOR_MODE PreviousMode;
    LARGE_INTEGER TimeoutValue;

    PAGED_CODE();

    //
    //  If the number of objects is zero or greater than the largest number
    //  that can be waited on, then return and invalid parameter status.
    //

    if ((Count == 0) || (Count > MAXIMUM_WAIT_OBJECTS)) {
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    //  Get previous processor mode and probe and capture input arguments if
    //  necessary.
    //

    PreviousMode = KeGetPreviousMode();
    try {
        if (PreviousMode != KernelMode) {
            if (ARGUMENT_PRESENT(Timeout)) {
                TimeoutValue = ProbeAndReadLargeInteger(Timeout);
                Timeout = &TimeoutValue;
            }

            ProbeForRead(Handles, Count * sizeof(LONG), sizeof(LONG));
        }

        for (Index = 0; Index < Count; Index += 1) {
            CapturedHandles[Index] = LongToHandle(Handles[Index]);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    //  Wait for multiple objects.
    //

    return ObpWaitForMultipleObjects(Count,
                                     CapturedHandles,
                                     WaitType,
                                     Alertable,
                                     Timeout);
}

NTSTATUS
ObpWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE CapturedHandles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled.  The wait can be specified to wait until all of the objects
    attain a state of Signaled or until one of the objects attains a state
    of Signaled.  An optional timeout can also be specified.  If a timeout
    is not specified, then the wait will not be satisfied until the objects
    attain a state of Signaled.  If a timeout is specified, and the objects
    have not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied.  If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately.  The wait can also be specified as alertable.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    CapturedHandles[] - Supplies an array of handles to wait objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status.  A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait.  A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread.  A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{

    ULONG i;
    ULONG j;
    POBJECT_HEADER ObjectHeader;
    PVOID Objects[MAXIMUM_WAIT_OBJECTS];
    KPROCESSOR_MODE PreviousMode;
    ULONG RefCount;
    ULONG Size;
    NTSTATUS Status;
    PKWAIT_BLOCK WaitBlockArray;
    ACCESS_MASK GrantedAccess;
    PVOID WaitObjects[MAXIMUM_WAIT_OBJECTS];
    PHANDLE_TABLE HandleTable;
    PHANDLE_TABLE_ENTRY HandleEntry;
    BOOLEAN InCriticalRegion = FALSE;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    //  If the number of objects to be waited on is greater than the number
    //  of builtin wait blocks, then allocate an array of wait blocks from
    //  nonpaged pool. If the wait block array cannot be allocated, then
    //  return insufficient resources.
    //

    PreviousMode = KeGetPreviousMode();

    WaitBlockArray = NULL;

    if (Count > THREAD_WAIT_OBJECTS) {

        Size = Count * sizeof( KWAIT_BLOCK );
        WaitBlockArray = ExAllocatePoolWithTag(NonPagedPool, Size, 'tiaW');

        if (WaitBlockArray == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    //  Loop through the array of handles and get a referenced pointer to
    //  each object.
    //

    i = 0;
    RefCount = 0;

    Status = STATUS_SUCCESS;

    //
    //  Protect ourselves from being interrupted while we hold a handle table
    //  entry lock
    //

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread(&CurrentThread->Tcb);
    InCriticalRegion = TRUE;

    do {

        //
        //  Get a pointer to the object table entry.  Check if this is a kernel
        //  handle and if so then use the kernel handle table otherwise use the
        //  processes handle table.  If we are going for a kernel handle we'll
        //  need to attach to the kernel process otherwise we need to ensure
        //  that we aren't attached.
        //

        if (IsKernelHandle( CapturedHandles[i], PreviousMode )) {

            HANDLE KernelHandle;

            //
            //  Decode the user supplied handle into a regular handle value
            //  and get its handle table entry
            //

            KernelHandle = DecodeKernelHandle( CapturedHandles[i] );

            HandleTable = ObpKernelHandleTable;
            HandleEntry = ExMapHandleToPointerEx ( HandleTable, KernelHandle, PreviousMode );

        } else {

            //
            //  Get the handle table entry
            //

            HandleTable = PsGetCurrentProcessByThread (CurrentThread)->ObjectTable;
            HandleEntry = ExMapHandleToPointerEx ( HandleTable, CapturedHandles[ i ], PreviousMode );
        }

        //
        //  Make sure the handle really did translate to a valid
        //  entry
        //

        if (HandleEntry != NULL) {

            //
            //  Get the granted access for the handle
            //

#if i386 

            if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

                GrantedAccess = ObpTranslateGrantedAccessIndex( HandleEntry->GrantedAccessIndex );

            } else {

                GrantedAccess = ObpDecodeGrantedAccess(HandleEntry->GrantedAccess);
            }

#else
            GrantedAccess = ObpDecodeGrantedAccess(HandleEntry->GrantedAccess);

#endif // i386

            //
            //  Make sure the handle as synchronize access to the
            //  object
            //

            if ((PreviousMode != KernelMode) &&
                (SeComputeDeniedAccesses( GrantedAccess, SYNCHRONIZE ) != 0)) {

                Status = STATUS_ACCESS_DENIED;

                ExUnlockHandleTableEntry( HandleTable, HandleEntry );

                goto ServiceFailed;

            } else {

                //
                //  We have a object with proper access so get the header
                //  and if the default objects points to a real object
                //  then that is the one we're going to wait on.
                //  Otherwise we'll find the kernel wait object at an
                //  offset into the object body
                //

                ObjectHeader = (POBJECT_HEADER)(((ULONG_PTR)(HandleEntry->Object)) & ~OBJ_HANDLE_ATTRIBUTES);

                if ((LONG_PTR)ObjectHeader->Type->DefaultObject < 0) {

                    RefCount += 1;
                    Objects[i] = NULL;
                    WaitObjects[i] = ObjectHeader->Type->DefaultObject;

                } else {

                    ObpIncrPointerCount( ObjectHeader );
                    RefCount += 1;
                    Objects[i] = &ObjectHeader->Body;

                    PERFINFO_DECLARE_OBJECT(Objects[i]);

                    //
                    //  Compute the address of the kernel wait object.
                    //

                    WaitObjects[i] = (PVOID)((PCHAR)&ObjectHeader->Body +
                                             (ULONG_PTR)ObjectHeader->Type->DefaultObject);
                }
            }

            ExUnlockHandleTableEntry( HandleTable, HandleEntry );

        } else {

            //
            //  The entry in the handle table isn't in use
            //

            Status = STATUS_INVALID_HANDLE;

            goto ServiceFailed;
        }

        i += 1;

    } while (i < Count);

    //
    //  At this point the WaitObjects[] is set to the kernel wait objects
    //
    //  Now Check to determine if any of the objects are specified more than
    //  once, but we only need to check this for wait all, with a wait any
    //  the user can specify the same object multiple times.
    //

    if (WaitType == WaitAll) {

        i = 0;

        do {

            for (j = i + 1; j < Count; j += 1) {
                if (WaitObjects[i] == WaitObjects[j]) {

                    Status = STATUS_INVALID_PARAMETER_MIX;

                    goto ServiceFailed;
                }
            }

            i += 1;

        } while (i < Count);
    }

    //
    //  Wait for the specified objects to attain a state of Signaled or a
    //  time out to occur.  Protect the wait call just in case KeWait decides
    //  to raise For example, a mutant level is exceeded
    //

    try {

        InCriticalRegion = FALSE;
        KeLeaveCriticalRegionThread(&CurrentThread->Tcb);
        Status = KeWaitForMultipleObjects( Count,
                                           WaitObjects,
                                           WaitType,
                                           UserRequest,
                                           PreviousMode,
                                           Alertable,
                                           Timeout,
                                           WaitBlockArray );

    } except((GetExceptionCode () == STATUS_MUTANT_LIMIT_EXCEEDED)?
                 EXCEPTION_EXECUTE_HANDLER :
                 EXCEPTION_CONTINUE_SEARCH) {

        Status = GetExceptionCode();
    }

    //
    //  If any objects were referenced, then deference them.
    //

ServiceFailed:

    while (RefCount > 0) {

        RefCount -= 1;

        if (Objects[RefCount] != NULL) {

            ObDereferenceObject(Objects[RefCount]);
        }
    }

    //
    //  If a wait block array was allocated, then deallocate it.
    //

    if (WaitBlockArray != NULL) {

        ExFreePool(WaitBlockArray);
    }

    if (InCriticalRegion) {
        KeLeaveCriticalRegionThread(&CurrentThread->Tcb);
    }

    return Status;
}

NTSTATUS
ObWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    Please refer to NtWaitForSingleObject

Arguments:

    Handle  - Supplies the handle for the wait object.

    Alertable - Supplies a boolean value that specifies whether the wait
        is alertable.

    Timeout - Supplies an pointer to an absolute or relative time over
        which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait.  A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{
    POBJECT_HEADER ObjectHeader;
    PVOID Object;
    NTSTATUS Status;
    PVOID WaitObject;

    PAGED_CODE();

    //
    //  Get a referenced pointer to the specified object with synchronize
    //  access.
    //

    Status = ObReferenceObjectByHandle( Handle,
                                        SYNCHRONIZE,
                                        (POBJECT_TYPE)NULL,
                                        KernelMode,
                                        &Object,
                                        NULL );

    //
    //  If access is granted, then check to determine if the specified object
    //  can be waited on.
    //

    if (NT_SUCCESS( Status ) != FALSE) {

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );

        if ((LONG_PTR)ObjectHeader->Type->DefaultObject < 0) {

            WaitObject = (PVOID)ObjectHeader->Type->DefaultObject;

        } else {

            WaitObject = (PVOID)((PCHAR)Object + (ULONG_PTR)ObjectHeader->Type->DefaultObject);
        }

        //
        //  Protect the wait call just in case KeWait decides
        //  to raise For example, a mutant level is exceeded
        //

        try {

            Status = KeWaitForSingleObject( WaitObject,
                                            UserRequest,
                                            KernelMode,
                                            Alertable,
                                            Timeout );

        } except((GetExceptionCode () == STATUS_MUTANT_LIMIT_EXCEEDED)?
                     EXCEPTION_EXECUTE_HANDLER :
                     EXCEPTION_CONTINUE_SEARCH) {

            Status = GetExceptionCode();
        }

        ObDereferenceObject(Object);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\perf\logging.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    logging.c

Abstract:

    This module contains routines for trace logging.

--*/

#include "perfp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWMI, PerfInfoReserveBytes)
#pragma alloc_text(PAGEWMI, PerfInfoLogBytes)
#endif //ALLOC_PRAGMA


NTSTATUS
PerfInfoReserveBytes(
    PPERFINFO_HOOK_HANDLE Hook,
    USHORT HookId,
    ULONG BytesToReserve
    )
/*++

Routine Description:

    Reserves memory for the hook via WMI and initializes the header.

Arguments:

    Hook - pointer to hook handle (used for reference decrement)
    HookId - Id for the hook
    BytesToLog - size of data in bytes

Return Value:

    STATUS_SUCCESS on success
    STATUS_UNSUCCESSFUL if the buffer memory couldn't be allocated.
--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PPERFINFO_TRACE_HEADER PPerfTraceHeader = NULL;
    PWMI_BUFFER_HEADER PWmiBufferHeader = NULL;

    PERF_ASSERT((BytesToReserve + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data)) <= MAXUSHORT);
    PERF_ASSERT(Hook != NULL);

    PPerfTraceHeader = WmiReserveWithPerfHeader(BytesToReserve, &PWmiBufferHeader);

    if (PPerfTraceHeader != NULL) {
        PPerfTraceHeader->Packet.HookId = HookId;
        Hook->PerfTraceHeader = PPerfTraceHeader;
        Hook->WmiBufferHeader = PWmiBufferHeader;

        Status = STATUS_SUCCESS;
    } else {
        *Hook = PERF_NULL_HOOK_HANDLE;
    }

    return Status;
}


NTSTATUS
PerfInfoLogBytes(
    USHORT HookId,
    PVOID Data,
    ULONG BytesToLog
    )
/*++

Routine Description:

    Reserves memory for the hook, copies the data, and unref's the hook entry.

Arguments:

    HookId - Id for the hook
    Data - pointer to the data to be logged
    BytesToLog - size of data in bytes

Return Value:

    STATUS_SUCCESS on success
--*/
{
    PERFINFO_HOOK_HANDLE Hook;
    NTSTATUS Status;

    Status = PerfInfoReserveBytes(&Hook, HookId, BytesToLog);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    RtlCopyMemory(PERFINFO_HOOK_HANDLE_TO_DATA(Hook, PPERF_BYTE), Data, BytesToLog);
    PERF_FINISH_HOOK(Hook);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\perf\hooks.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hooks.c

Abstract:

    This module contains performance hooks.

--*/

#include "perfp.h"
#include "zwapi.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PerfInfoFlushProfileCache)
#pragma alloc_text(PAGEWMI, PerfProfileInterrupt)
#pragma alloc_text(PAGEWMI, PerfInfoLogInterrupt)
#pragma alloc_text(PAGEWMI, PerfInfoLogBytesAndUnicodeString)
#pragma alloc_text(PAGEWMI, PerfInfoLogFileName)
#pragma alloc_text(PAGEWMI, PerfInfoCalcHashValue)
#pragma alloc_text(PAGEWMI, PerfInfoAddToFileHash)
#pragma alloc_text(PAGEWMI, PerfInfoFileNameRunDown)
#pragma alloc_text(PAGEWMI, PerfInfoProcessRunDown)
#pragma alloc_text(PAGEWMI, PerfInfoSysModuleRunDown)
#endif //ALLOC_PRAGMA

#define MAX_FILENAME_TO_LOG   8192


VOID
PerfInfoFlushProfileCache(
    VOID
    )
/*++

Routine description:

    Flushes the profile cache to the log buffer.  To make sure it get's valid data
    we read the 2 separate version numbers (1 before and 1 after) to check if it's
    been changed.  If so, we just read again.  If that fails often, then we disable
    the cache.  Once the cache is read, we clear it.  This may cause samples to be
    lost but that's ok as this is statistical and it won't matter.

Arguments:
    CheckVersion - If FALSE, the version is not checked. This used when the profile
        interrupt code flushes the cache.

Return Value:
    None

--*/
{
    ULONG PreviousInProgress;

    if ((PerfProfileCache.Entries == 0) || (PerfInfoSampledProfileCaching == FALSE)) {
        return;
    }

    //
    // Signal the interrupt not to mess with the cache
    //
    PreviousInProgress = InterlockedIncrement(&PerfInfoSampledProfileFlushInProgress);
    if (PreviousInProgress != 1) {
        //
        // A flush is already in progress so just return.
        //
        InterlockedDecrement(&PerfInfoSampledProfileFlushInProgress);
        return;
    }

    //
    // Log the portion of the cache that has valid data.
    //
    PerfInfoLogBytes(PERFINFO_LOG_TYPE_SAMPLED_PROFILE_CACHE,
                        &PerfProfileCache,
                        FIELD_OFFSET(PERFINFO_SAMPLED_PROFILE_CACHE, Sample) +
                            (PerfProfileCache.Entries *
                                sizeof(PERFINFO_SAMPLED_PROFILE_INFORMATION))
                        );

    //
    // Clear the cache for the next set of entries.
    //
    PerfProfileCache.Entries = 0;

    //
    // Let the interrupt fill the cache again.
    //
    InterlockedDecrement(&PerfInfoSampledProfileFlushInProgress);
}


VOID
FASTCALL
PerfProfileInterrupt(
    IN KPROFILE_SOURCE Source,
    IN PVOID InstructionPointer
    )
/*++

Routine description:

    Implements instruction profiling.  If the source is not the one we're sampling on,
    we return.  If caching is off, we write any samples coming from the immediately to
    the log.  If caching is on, wrap the cache update with writes to the two versions so
    that the flush routine can know if it has a valid buffer.

Arguments:
    
    Source - Type of profile interrupt

    InstructionPointer - IP at the time of the interrupt

Return Value:
    None

--*/
{
    ULONG i;
    PERFINFO_SAMPLED_PROFILE_INFORMATION SampleData;
#ifdef _X86_
    ULONG_PTR TwiddledIP;
#endif // _X86_
    ULONG ThreadId;

    if (!PERFINFO_IS_GROUP_ON(PERF_PROFILE) &&
        (Source != PerfInfoProfileSourceActive)
        ) {
        //
        // We don't handle multple sources.
        //
        return;
    }

    ThreadId = HandleToUlong(PsGetCurrentThread()->Cid.UniqueThread);

    if (!PerfInfoSampledProfileCaching ||
        PerfInfoSampledProfileFlushInProgress != 0) {
        //
        // No caching. Log and return.
        //
        SampleData.ThreadId = ThreadId;
        SampleData.InstructionPointer = InstructionPointer;
        SampleData.Count = 1;

        PerfInfoLogBytes(PERFINFO_LOG_TYPE_SAMPLED_PROFILE,
                            &SampleData,
                            sizeof(PERFINFO_SAMPLED_PROFILE_INFORMATION)
                            );
        return;
    }

#ifdef _X86_
    //
    // Clear the low two bits to have more cache hits for loops.  Don't waste
    // cycles on other architectures.
    //
    TwiddledIP = (ULONG_PTR)InstructionPointer & ~3;
#endif // _X86_

    //
    // Initial walk thru Instruction Pointer Cache.  Bump Count if address is in cache.
    //
    for (i = 0; i < PerfProfileCache.Entries ; i++) {

        if ((PerfProfileCache.Sample[i].ThreadId == ThreadId) &&
#ifdef _X86_
            (((ULONG_PTR)PerfProfileCache.Sample[i].InstructionPointer & ~3) == TwiddledIP)
#else
            (PerfProfileCache.Sample[i].InstructionPointer == InstructionPointer)
#endif // _X86_
            ) {
            //
            // If we find the instruction pointer in the cache, bump the count
            //

            PerfProfileCache.Sample[i].Count++;
            return;
        }
    }
    if (PerfProfileCache.Entries < PERFINFO_SAMPLED_PROFILE_CACHE_MAX) {
        //
        // If we find an empty spot in the cache, use it for this instruction pointer
        //

        PerfProfileCache.Sample[i].ThreadId = ThreadId;
        PerfProfileCache.Sample[i].InstructionPointer = InstructionPointer;
        PerfProfileCache.Sample[i].Count = 1;
        PerfProfileCache.Entries++;
        return;
    }

    //
    // Flush the cache
    //
    PerfInfoLogBytes(PERFINFO_LOG_TYPE_SAMPLED_PROFILE_CACHE,
                    &PerfProfileCache,
                    sizeof(PERFINFO_SAMPLED_PROFILE_CACHE)
                    );

    PerfProfileCache.Sample[0].ThreadId = ThreadId;
    PerfProfileCache.Sample[0].InstructionPointer = InstructionPointer;
    PerfProfileCache.Sample[0].Count = 1;
    PerfProfileCache.Entries = 1;
    return;
}



VOID
FASTCALL
PerfInfoLogInterrupt(
    IN PVOID ServiceRoutine,
    IN ULONG RetVal,
    IN ULONGLONG InitialTime
    )
/*++

Routine Description:

    This callout routine is called from ntoskrnl.exe (ke\intsup.asm) to log an
    interrupt.

Arguments:

    ServiceRoutine - Address of routine that serviced the interrupt.

    RetVal - Value returned from ServiceRoutine.

    InitialTime - Timestamp before ISR was called.  The timestamp in
                  the event is used as the end time.

Return Value:

    None

--*/
{
    PERFINFO_INTERRUPT_INFORMATION EventInfo;

    EventInfo.ServiceRoutine = ServiceRoutine;
    EventInfo.ReturnValue = RetVal;
    EventInfo.InitialTime = InitialTime;

    PerfInfoLogBytes(PERFINFO_LOG_TYPE_INTERRUPT,
                     &EventInfo,
                     sizeof(EventInfo));

    return;
}


NTSTATUS
PerfInfoLogBytesAndUnicodeString(
    USHORT HookId,
    PVOID SourceData,
    ULONG SourceByteCount,
    PUNICODE_STRING String
    )
/*++

Routine description:

    This routine logs data with UniCode string at the end of the hook.

Arguments:
    
    HookId - Hook Id.

    SourceData - Pointer to the data to be copied

    SourceByteCount - Number of bytes to be copied.
    
    String - The string to be logged.

Return Value:
    Status

--*/
{
    NTSTATUS Status;
    PERFINFO_HOOK_HANDLE Hook;
    ULONG ByteCount;
    ULONG StringBytes;

    if (String == NULL) {
        StringBytes = 0;
    } else {
        StringBytes = String->Length;
        if (StringBytes > MAX_FILENAME_TO_LOG) {
            StringBytes = MAX_FILENAME_TO_LOG;
        }
    }

    ByteCount = (SourceByteCount + StringBytes + sizeof(WCHAR));

    Status = PerfInfoReserveBytes(&Hook, HookId, ByteCount);
    if (NT_SUCCESS(Status))
    {
        const PVOID pvTemp = PERFINFO_HOOK_HANDLE_TO_DATA(Hook, PVOID);
        RtlCopyMemory(pvTemp, SourceData, SourceByteCount);
        if (StringBytes != 0) {
            RtlCopyMemory(PERFINFO_APPLY_OFFSET_GIVING_TYPE(pvTemp, SourceByteCount, PVOID),
                          String->Buffer,
                          StringBytes
                          );
        }
        (PERFINFO_APPLY_OFFSET_GIVING_TYPE(pvTemp, SourceByteCount, PWCHAR))[StringBytes / sizeof(WCHAR)] = UNICODE_NULL;
        PERF_FINISH_HOOK(Hook);

        Status = STATUS_SUCCESS;
    }
    return Status;
}


NTSTATUS
PerfInfoLogFileName(
    PVOID  FileObject,
    PUNICODE_STRING SourceString
    )
/*++

Routine Description:

    This routine logs a FileObject pointer and FileName to the log.  The pointer is used
    as hash key to map this name to other trace events.

Arguments:

    FileObject - Pointer to the FileName member within the FILE_OBJECT
                 structure.  The FileName may not yet be initialized,
                 so the actual data comes from the SourceString
                 parameter.

    SourceString - Optional pointer to the source string.


Return Value:

    STATUS_SUCCESS
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PERFINFO_FILENAME_INFORMATION FileInfo;

    if ((FileObject != NULL) &&
        (SourceString != NULL) &&
        (SourceString->Length != 0)) {
        FileInfo.HashKeyFileNamePointer = FileObject;
        Status = PerfInfoLogBytesAndUnicodeString(PERFINFO_LOG_TYPE_FILENAME_CREATE,
                                                  &FileInfo,
                                                  FIELD_OFFSET(PERFINFO_FILENAME_INFORMATION, FileName),
                                                  SourceString);
    }

    return Status;
}


ULONG
PerfInfoCalcHashValue(
    PVOID Key,
    ULONG Len
    )

/*++

Routine Description:

    Generic hash routine.

Arguments:

    Key - Pointer to data to calculate a hash value for.

    Len - Number of bytes pointed to by key.

Return Value:

    Hash value.

--*/

{
    char *cp = Key;
    ULONG i, ConvKey=0;
    for(i = 0; i < Len; i++)
    {
        ConvKey = 37 * ConvKey + (unsigned int) *cp;
        cp++;
    }

    #define RNDM_CONSTANT   314159269
    #define RNDM_PRIME     1000000007

    return (abs(RNDM_CONSTANT * ConvKey) % RNDM_PRIME);
}


BOOLEAN
PerfInfoAddToFileHash(
    PPERFINFO_ENTRY_TABLE HashTable,
    PFILE_OBJECT ObjectPointer
    )
/*++

Routine Description:

    This routine add a FileObject into the specified
    hash table if it is not already there. 

Arguments:

    HashTable - pointer to a hash table to be used.

    ObjectPointer - This is used as a key to identify a mapping.

Return Value:

    TRUE - If either the FileObject was in the table or we add it.
    FALSE - If the table is full.

--*/
{
    ULONG HashIndex;
    LONG i;
    BOOLEAN Result = FALSE;
    LONG TableSize = HashTable->NumberOfEntries;
    PVOID *Table;

    ASSERT (ObjectPointer != NULL);

    Table = HashTable->Table;
    //
    // Get the hashed index into the table where the entry ideally
    // should be at.
    //

    HashIndex = PerfInfoCalcHashValue((PVOID)&ObjectPointer,
                                      sizeof(ObjectPointer)) % TableSize;

    for (i = 0; i < TableSize; i++) {

        if(Table[HashIndex] == NULL) {
            //
            // Found a empty slot. Reference the object and insert
            // it into the table.
            //
            ObReferenceObject(ObjectPointer);
            Table[HashIndex] = ObjectPointer;

            Result = TRUE;
            break;
        } else if (Table[HashIndex] == ObjectPointer) {
            //
            // Found a slot. Reference the object and insert
            // it into the table.
            //
            Result = TRUE;
            break;
        }

        //
        // Try next slot.
        //
        HashIndex = (HashIndex + 1) % TableSize;
    }
    return Result;
}


NTSTATUS
PerfInfoFileNameRunDown (
    )
/*++

Routine Description:

    This routine walks through multiple lists to collect the names of all files.
    It includes:
    1. Handle table: for all file handles
    2. Process Vad for all file objects mapped in VAD.
    3. MmUnusedSegment List
    4. CcDirtySharedCacheMapList & CcCleanSharedCacheMapList

Arguments:

    None.

--*/
{
    PEPROCESS Process;
    ULONG AllocateBytes;
    PFILE_OBJECT *FileObjects;
    PFILE_OBJECT *File;
    PERFINFO_ENTRY_TABLE HashTable;
    extern POBJECT_TYPE IoFileObjectType;
    POBJECT_NAME_INFORMATION FileNameInfo;
    ULONG ReturnLen;
    NTSTATUS Status;
    LONG i;

    //
    // First create a temporary hash table to build the list of
    // files to walk through
    //
    AllocateBytes = PAGE_SIZE + sizeof(PVOID) * IoFileObjectType->TotalNumberOfObjects;

    //
    // Run up to page boundary
    //
    AllocateBytes = PERFINFO_ROUND_UP(AllocateBytes, PAGE_SIZE);

    HashTable.Table = ExAllocatePoolWithTag(NonPagedPool, AllocateBytes, PERFPOOLTAG);

    if (HashTable.Table == NULL) {
        return STATUS_NO_MEMORY;
    } else {
        //
        // Allocation Succeeded
        //
        HashTable.NumberOfEntries = AllocateBytes / sizeof(PVOID);
        RtlZeroMemory(HashTable.Table, AllocateBytes);
    }

    //
    // Allocate Buffers for FileNames
    //
    FileNameInfo = ExAllocatePoolWithTag (NonPagedPool, MAX_FILENAME_TO_LOG, PERFPOOLTAG);

    if (FileNameInfo == NULL) {
        ExFreePool(HashTable.Table);
        return STATUS_NO_MEMORY;
    }

    //
    // Walk through the Cc SharedCacheMapList
    //

    CcPerfFileRunDown(&HashTable);

    //
    // Now, walk through each process
    //
    for (Process = PsGetNextProcess (NULL);
         Process != NULL;
         Process = PsGetNextProcess (Process)) {

        //
        // First Walk the VAD tree
        //

        FileObjects = MmPerfVadTreeWalk(Process);
        if (FileObjects != NULL) {
            File = FileObjects;
            while (*File != NULL) {
                PerfInfoAddToFileHash(&HashTable, *File);
                ObDereferenceObject(*File);
                File += 1;
            }
            ExFreePool(FileObjects);
        }

        //
        // Next, walk the handle Table
        //
        ObPerfHandleTableWalk (Process, &HashTable);
    }

    //
    // Walk through the kernel handle table;
    //
    ObPerfHandleTableWalk(NULL, &HashTable);

    //
    // Walk through the MmUnusedSegmentList;
    //

    FileObjects = MmPerfUnusedSegmentsEnumerate();

    if (FileObjects != NULL) {
        File = FileObjects;
        while (*File != NULL) {
            PerfInfoAddToFileHash(&HashTable, *File);
            ObDereferenceObject(*File);
            File += 1;
        }
        ExFreePool(FileObjects);
    }

    //
    // Now we have walked through all list.
    // Log the filenames and dereference the objects.
    //

    for (i = 0; i < HashTable.NumberOfEntries; i++) {
        if (HashTable.Table[i]) {
            PFILE_OBJECT FileObject = HashTable.Table[i];

            Status = ObQueryNameString( FileObject,
                                        FileNameInfo,
                                        MAX_FILENAME_TO_LOG,
                                        &ReturnLen
                                        );

            if (NT_SUCCESS (Status)) {
                PerfInfoLogFileName(FileObject, &FileNameInfo->Name);
            }
            ObDereferenceObject(FileObject);
        }
    }

    //
    // Free the pool reserved.
    //
    ExFreePool(HashTable.Table);
    ExFreePool(FileNameInfo);

    return STATUS_SUCCESS;
}


NTSTATUS
PerfInfoProcessRunDown (
    )
/*++

Routine Description:

    This routine does the Process and thread rundown in the kernel mode.
    Since this routine is called only by global logger (i.e., trace from boot),
    no Sid info is collected.

Arguments:

    None.

Return Value:

    Status

--*/
{
    NTSTATUS Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_EXTENDED_THREAD_INFORMATION ThreadInfo;
    PCHAR Buffer;
    ULONG BufferSize = 4096;
    ULONG ReturnLength;

retry:
    Buffer = ExAllocatePoolWithTag(NonPagedPool, BufferSize, PERFPOOLTAG);

    if (!Buffer) {
        return STATUS_NO_MEMORY;
    }
    Status = ZwQuerySystemInformation( SystemExtendedProcessInformation,
                                       Buffer,
                                       BufferSize,
                                       &ReturnLength
                                       );

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        ExFreePool(Buffer);
        BufferSize = ReturnLength;
        goto retry;
    }

    if (NT_SUCCESS(Status)) {
        ULONG TotalOffset = 0;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) Buffer;
        while (TRUE) {
            PWMI_PROCESS_INFORMATION WmiProcessInfo;
            PWMI_EXTENDED_THREAD_INFORMATION WmiThreadInfo;
            PERFINFO_HOOK_HANDLE Hook;
            ANSI_STRING ProcessName;
            PCHAR AuxPtr;
            ULONG NameLength;
            ULONG ByteCount;
            ULONG SidLength = sizeof(ULONG);
            ULONG TmpSid = 0;
            ULONG i;

            //
            // Process Information
            //
            if ( ProcessInfo->ImageName.Buffer  && ProcessInfo->ImageName.Length > 0 ) {
                NameLength = ProcessInfo->ImageName.Length / sizeof(WCHAR) + 1;
            }
            else {
                NameLength = 1;
            }
            ByteCount = FIELD_OFFSET(WMI_PROCESS_INFORMATION, Sid) + SidLength + NameLength;

            Status = PerfInfoReserveBytes(&Hook, 
                                          WMI_LOG_TYPE_PROCESS_DC_START, 
                                          ByteCount);

            if (NT_SUCCESS(Status)){
                WmiProcessInfo = PERFINFO_HOOK_HANDLE_TO_DATA(Hook, PWMI_PROCESS_INFORMATION);

                WmiProcessInfo->ProcessId = HandleToUlong(ProcessInfo->UniqueProcessId);
                WmiProcessInfo->ParentId = HandleToUlong(ProcessInfo->InheritedFromUniqueProcessId);
                WmiProcessInfo->SessionId = ProcessInfo->SessionId;
                WmiProcessInfo->PageDirectoryBase = ProcessInfo->PageDirectoryBase;

                AuxPtr = (PCHAR) &WmiProcessInfo->Sid;
                RtlCopyMemory(AuxPtr, &TmpSid, SidLength);

                AuxPtr += SidLength;
                if (NameLength > 1) {
    
                    ProcessName.Buffer = AuxPtr;
                    ProcessName.MaximumLength = (USHORT) NameLength;
    
                    RtlUnicodeStringToAnsiString( &ProcessName,
                                                (PUNICODE_STRING) &ProcessInfo->ImageName,
                                                FALSE);
                    AuxPtr += NameLength - 1; //point to the place for the '\0'
                }
                *AuxPtr = '\0';

                PERF_FINISH_HOOK(Hook);
            }

            //
            // Thread Information
            //
            ThreadInfo = (PSYSTEM_EXTENDED_THREAD_INFORMATION) (ProcessInfo + 1);

            for (i=0; i < ProcessInfo->NumberOfThreads; i++) {
                Status = PerfInfoReserveBytes(&Hook, 
                                              WMI_LOG_TYPE_THREAD_DC_START, 
                                              sizeof(WMI_EXTENDED_THREAD_INFORMATION));
                if (NT_SUCCESS(Status)){
                    WmiThreadInfo = PERFINFO_HOOK_HANDLE_TO_DATA(Hook, PWMI_EXTENDED_THREAD_INFORMATION);
                    WmiThreadInfo->ProcessId =  HandleToUlong(ThreadInfo->ThreadInfo.ClientId.UniqueProcess);
                    WmiThreadInfo->ThreadId =  HandleToUlong(ThreadInfo->ThreadInfo.ClientId.UniqueThread);
                    WmiThreadInfo->StackBase = ThreadInfo->StackBase;
                    WmiThreadInfo->StackLimit = ThreadInfo->StackLimit;

                    WmiThreadInfo->UserStackBase = NULL;
                    WmiThreadInfo->UserStackLimit = NULL;
                    WmiThreadInfo->StartAddr = ThreadInfo->ThreadInfo.StartAddress;
                    WmiThreadInfo->Win32StartAddr = ThreadInfo->Win32StartAddress;
                    WmiThreadInfo->WaitMode = -1;
                    PERF_FINISH_HOOK(Hook);
                }

                ThreadInfo  += 1;
            }

            if (ProcessInfo->NextEntryOffset == 0) {
                break;
            } else {
                TotalOffset += ProcessInfo->NextEntryOffset;
                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &Buffer[TotalOffset];
            }
        }
    } 

    ExFreePool(Buffer);
    return Status;

}


NTSTATUS
PerfInfoSysModuleRunDown (
    )
/*++

Routine Description:

    This routine does the rundown for loaded drivers in the kernel mode.

Arguments:

    None.

Return Value:

    Status

--*/
{
    NTSTATUS Status;
    PRTL_PROCESS_MODULES            Modules;
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    PVOID Buffer;
    ULONG BufferSize = 4096;
    ULONG ReturnLength;
    ULONG i;

retry:
    Buffer = ExAllocatePoolWithTag(NonPagedPool, BufferSize, PERFPOOLTAG);

    if (!Buffer) {
        return STATUS_NO_MEMORY;
    }
    Status = ZwQuerySystemInformation( SystemModuleInformation,
                                       Buffer,
                                       BufferSize,
                                       &ReturnLength
                                       );

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        ExFreePool(Buffer);
        BufferSize = ReturnLength;
        goto retry;
    }

    if (NT_SUCCESS(Status)) {
        Modules = (PRTL_PROCESS_MODULES) Buffer;
        for (i = 0, ModuleInfo = & (Modules->Modules[0]);
             i < Modules->NumberOfModules;
             i ++, ModuleInfo ++) {

            PWMI_IMAGELOAD_INFORMATION ImageLoadInfo;
            UNICODE_STRING WstrModuleName;
            ANSI_STRING    AstrModuleName;
            ULONG          SizeModuleName;
            PERFINFO_HOOK_HANDLE Hook;
            ULONG ByteCount;

            RtlInitAnsiString( &AstrModuleName, (PCSZ) ModuleInfo->FullPathName);
            SizeModuleName = sizeof(WCHAR) * (AstrModuleName.Length) + sizeof(WCHAR);
            ByteCount = FIELD_OFFSET(WMI_IMAGELOAD_INFORMATION, FileName) 
                        + SizeModuleName;

            Status = PerfInfoReserveBytes(&Hook, WMI_LOG_TYPE_PROCESS_LOAD_IMAGE, ByteCount);

            if (NT_SUCCESS(Status)){
                ImageLoadInfo = PERFINFO_HOOK_HANDLE_TO_DATA(Hook, PWMI_IMAGELOAD_INFORMATION);
                ImageLoadInfo->ImageBase = ModuleInfo->ImageBase;
                ImageLoadInfo->ImageSize = ModuleInfo->ImageSize;
                ImageLoadInfo->ProcessId = HandleToUlong(NULL);
                WstrModuleName.Buffer    = (LPWSTR) &ImageLoadInfo->FileName[0];
                WstrModuleName.MaximumLength = (USHORT) SizeModuleName; 
                Status = RtlAnsiStringToUnicodeString(&WstrModuleName, & AstrModuleName, FALSE);
                if (!NT_SUCCESS(Status)){
                    ImageLoadInfo->FileName[0] = UNICODE_NULL;
                }

                PERF_FINISH_HOOK(Hook);
            }
        }

    } 

    ExFreePool(Buffer);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\perf\perfp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    perfp.h

Abstract:

    This module contains the definitions of data structures and macros
    used by kernel-mode logging in the performance data event log.

--*/

#ifndef _PERFP_
#define _PERFP_

#if _MSC_VER >= 1000
#pragma once
#endif

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable
#pragma warning(error:4705)   // Statement has no effect

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#include "ntos.h"

//
// Profiling structures
//
extern KPROFILE PerfInfoProfileObject; 
extern PERFINFO_SAMPLED_PROFILE_CACHE PerfProfileCache;
extern BOOLEAN PerfInfoSampledProfileCaching;
extern KPROFILE_SOURCE PerfInfoProfileSourceActive;
extern KPROFILE_SOURCE PerfInfoProfileSourceRequested;
extern KPROFILE_SOURCE PerfInfoProfileInterval;
extern LONG PerfInfoSampledProfileFlushInProgress;
extern PERFINFO_GROUPMASK PerfGlobalGroupMask;


#define PERFPOOLTAG 'freP'

NTSTATUS
PerfInfoReserveBytesWMI(
    PPERFINFO_HOOK_HANDLE Hook,
    USHORT HookId,
    ULONG BytesToReserve
    );

NTSTATUS
PerfInfoFileNameRunDown(
    );

NTSTATUS
PerfInfoProcessRunDown(
    );

NTSTATUS
PerfInfoSysModuleRunDown(
    );

VOID
PerfInfoProfileInit(
    );

VOID
PerfInfoProfileUninit(
    );

VOID
PerfSetLogging (
    PVOID MaskAddress
    );

#endif // _PERFP_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\perf\perfsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    perfsup.c

Abstract:

    This module contains support routines for performance traces.

--*/

#include "perfp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PerfInfoProfileInit)
#pragma alloc_text(PAGE, PerfInfoProfileUninit)
#pragma alloc_text(PAGE, PerfInfoStartLog)
#pragma alloc_text(PAGE, PerfInfoStopLog)
#endif //ALLOC_PRAGMA

extern NTSTATUS IoPerfInit();
extern NTSTATUS IoPerfReset();


VOID
PerfInfoProfileInit(
    )
/*++

Routine description:

    Starts the sampled profile and initializes the cache

Arguments:
    None

Return Value:
    None

--*/
{
#if !defined(NT_UP)
    PerfInfoSampledProfileCaching = FALSE;
#else
    PerfInfoSampledProfileCaching = TRUE;
#endif // !defined(NT_UP)
    PerfInfoSampledProfileFlushInProgress = 0;
    PerfProfileCache.Entries = 0;

    PerfInfoProfileSourceActive = PerfInfoProfileSourceRequested;

    KeSetIntervalProfile(PerfInfoProfileInterval, PerfInfoProfileSourceActive);
    KeInitializeProfile(&PerfInfoProfileObject,
                        NULL,
                        NULL,
                        0,
                        0,
                        0,
                        PerfInfoProfileSourceActive,
                        0
                        );
    KeStartProfile(&PerfInfoProfileObject, NULL);
}


VOID
PerfInfoProfileUninit(
    )
/*++

Routine description:

    Stops the sampled profile

Arguments:
    None

Return Value:
    None

--*/
{
    PerfInfoProfileSourceActive = ProfileMaximum;   // Invalid value stops us from
                                                    // collecting more samples
    KeStopProfile(&PerfInfoProfileObject);
    PerfInfoFlushProfileCache();
}


NTSTATUS
PerfInfoStartLog (
    PERFINFO_GROUPMASK *PGroupMask,
    PERFINFO_START_LOG_LOCATION StartLogLocation
    )

/*++

Routine Description:

    This routine is called by WMI as part of kernel logger initialization.

Arguments:

    GroupMask - Masks for what to log.  This pointer point to an allocated
                area in WMI LoggerContext.
    StartLogLocation - Indication of whether we're starting logging
                at boot time or while the system is running.  If
                we're starting at boot time, we don't need to snapshot
                the open files because there aren't any and we would
                crash if we tried to find the list.

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ProfileInitialized = FALSE;
    BOOLEAN ContextSwapStarted = FALSE;
    BOOLEAN IoPerfInitialized = FALSE;

    PERFINFO_CLEAR_GROUPMASK(&PerfGlobalGroupMask);

    //
    // Enable logging.
    //

    PPerfGlobalGroupMask = &PerfGlobalGroupMask;
    PerfSetLogging(PPerfGlobalGroupMask);

    if (PerfIsGroupOnInGroupMask(PERF_MEMORY, PGroupMask) ||
        PerfIsGroupOnInGroupMask(PERF_FILENAME, PGroupMask) ||
        PerfIsGroupOnInGroupMask(PERF_DRIVERS, PGroupMask)) {
            PERFINFO_OR_GROUP_WITH_GROUPMASK(PERF_FILENAME_ALL, PGroupMask);
    }


    if (StartLogLocation == PERFINFO_START_LOG_FROM_GLOBAL_LOGGER) {
        //
        // From the wmi global logger, need to do Rundown in kernel mode
        //
        if (PerfIsGroupOnInGroupMask(PERF_PROC_THREAD, PGroupMask)) {
            Status = PerfInfoProcessRunDown();
            if (!NT_SUCCESS(Status)) {
                goto Finish;
            }
        }

        if (PerfIsGroupOnInGroupMask(PERF_PROC_THREAD, PGroupMask)) {
            Status = PerfInfoSysModuleRunDown();
            if (!NT_SUCCESS(Status)) {
                goto Finish;
            }
        }
    }

    //
    // File Name Rundown code
    //
    if ((StartLogLocation != PERFINFO_START_LOG_AT_BOOT) && 
        PerfIsGroupOnInGroupMask(PERF_FILENAME_ALL, PGroupMask)) {
        PERFINFO_OR_GROUP_WITH_GROUPMASK(PERF_FILENAME_ALL, PPerfGlobalGroupMask);
        Status = PerfInfoFileNameRunDown();
        if (!NT_SUCCESS(Status)) {
            goto Finish;
        }
    }

    //
    // Initialize Perf Driver hooks
    //
    if (PerfIsGroupOnInGroupMask(PERF_DRIVERS, PGroupMask)) {
        Status = IoPerfInit();
        if (NT_SUCCESS(Status)) {
            IoPerfInitialized = TRUE;
        } else {
            goto Finish;
        }
    }

    //
    // Enable context swap tracing
    //
    if ( PerfIsGroupOnInGroupMask(PERF_CONTEXT_SWITCH, PGroupMask) ) {
        WmiStartContextSwapTrace();
        ContextSwapStarted = TRUE;
    }

    //
    // Sampled Profile
    //
    if (PerfIsGroupOnInGroupMask(PERF_PROFILE, PGroupMask)) {
        if ((KeGetPreviousMode() == KernelMode)  ||
            (SeSinglePrivilegeCheck(SeSystemProfilePrivilege, UserMode))) {
            PerfInfoProfileInit();
            ProfileInitialized = TRUE;
        } else {
            Status = STATUS_NO_SUCH_PRIVILEGE;
            goto Finish;
        }
    }

    //
    // See if we need to empty the working set to start
    //
    if (PerfIsGroupOnInGroupMask(PERF_FOOTPRINT, PGroupMask) ||
        PerfIsGroupOnInGroupMask(PERF_BIGFOOT, PGroupMask)) {
        MmEmptyAllWorkingSets ();
    }

Finish:

    if (!NT_SUCCESS(Status)) {
        //
        // Failed to turn on trace, clean up now.
        //

        if (ContextSwapStarted) {
            WmiStopContextSwapTrace();
        }

        if (ProfileInitialized) {
            PerfInfoProfileUninit();
        }

        if (IoPerfInitialized) {
            IoPerfReset();
        }

        //
        // Disable logging.
        //

        PPerfGlobalGroupMask = NULL;
        PerfSetLogging(NULL);

        PERFINFO_CLEAR_GROUPMASK(&PerfGlobalGroupMask);
    } else {
        *PPerfGlobalGroupMask = *PGroupMask;
    }

    return Status;
}


NTSTATUS
PerfInfoStopLog (
    )

/*++

Routine Description: 

    This routine turn off the PerfInfo trace hooks.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN DisableContextSwaps=FALSE;

    if (PPerfGlobalGroupMask == NULL) {
        return Status;
    }

    if (PERFINFO_IS_GROUP_ON(PERF_MEMORY)) {
        MmIdentifyPhysicalMemory();
    }

    if (PERFINFO_IS_GROUP_ON(PERF_PROFILE)) {
        PerfInfoProfileUninit();
    }

    if (PERFINFO_IS_GROUP_ON(PERF_DRIVERS)) {
        IoPerfReset();
    }

    if ( PERFINFO_IS_GROUP_ON(PERF_CONTEXT_SWITCH) ) {
        DisableContextSwaps = TRUE;
    }

    //
    // Reset the PPerfGlobalGroupMask.
    //

    PERFINFO_CLEAR_GROUPMASK(PPerfGlobalGroupMask);

    //
    // Disable logging.
    //

    PPerfGlobalGroupMask = NULL;
    PerfSetLogging(NULL);

    //
    // Disable context swap tracing.
    // IMPORTANT: This must be done AFTER the global flag is set to NULL!!!
    //
    if( DisableContextSwaps ) {

        WmiStopContextSwapTrace();
    }

    return (Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\pscid.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pscid.c

Abstract:

    This module implements the Client ID related services.

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PsLookupProcessThreadByCid)
#pragma alloc_text(PAGE, PsLookupProcessByProcessId)
#pragma alloc_text(PAGE, PsLookupThreadByThreadId)
#endif //ALLOC_PRAGMA

NTSTATUS
PsLookupProcessThreadByCid(
    __in PCLIENT_ID Cid,
    __deref_opt_out PEPROCESS *Process,
    __deref_out PETHREAD *Thread
    )

/*++

Routine Description:

    This function accepts The Client ID of a thread, and returns a
    referenced pointer to the thread, and possibly a referenced pointer
    to the process.

Arguments:

    Cid - Specifies the Client ID of the thread.

    Process - If specified, returns a referenced pointer to the process
        specified in the Cid.

    Thread - Returns a referenced pointer to the thread specified in the
        Cid.

Return Value:

    STATUS_SUCCESS - A process and thread were located based on the contents
        of the Cid.

    STATUS_INVALID_CID - The specified Cid is invalid.

--*/

{

    PHANDLE_TABLE_ENTRY CidEntry;
    PETHREAD lThread;
    PETHREAD CurrentThread;
    PEPROCESS lProcess;
    NTSTATUS Status;

    PAGED_CODE();


    lThread = NULL;

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    CidEntry = ExMapHandleToPointer(PspCidTable, Cid->UniqueThread);
    if (CidEntry != NULL) {
        lThread = (PETHREAD)CidEntry->Object;
        if (!ObReferenceObjectSafe (lThread)) {
            lThread = NULL;
        }
        ExUnlockHandleTableEntry(PspCidTable, CidEntry);
    }

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    Status = STATUS_INVALID_CID;
    if (lThread != NULL) {
        //
        // This could be a thread or a process. Check its a thread.
        //
        if (lThread->Tcb.Header.Type != ThreadObject ||
            lThread->Cid.UniqueProcess != Cid->UniqueProcess ||
            lThread->GrantedAccess == 0) {
            ObDereferenceObject (lThread);
        } else {
            *Thread = lThread;
            if (ARGUMENT_PRESENT (Process)) {
                lProcess = THREAD_TO_PROCESS (lThread);
                *Process = lProcess;
                //
                // Since the thread holds a reference to the process this reference does not have to
                // be protected.
                //
                ObReferenceObject (lProcess);
            }
            Status = STATUS_SUCCESS;
        }

    }

    return Status;
}


NTSTATUS
PsLookupProcessByProcessId(
    __in HANDLE ProcessId,
    __deref_out PEPROCESS *Process
    )

/*++

Routine Description:

    This function accepts the process id of a process and returns a
    referenced pointer to the process.

Arguments:

    ProcessId - Specifies the Process ID of the process.

    Process - Returns a referenced pointer to the process specified by the
        process id.

Return Value:

    STATUS_SUCCESS - A process was located based on the contents of
        the process id.

    STATUS_INVALID_PARAMETER - The process was not found.

--*/

{

    PHANDLE_TABLE_ENTRY CidEntry;
    PEPROCESS lProcess;
    PETHREAD CurrentThread;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_INVALID_PARAMETER;

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    CidEntry = ExMapHandleToPointer(PspCidTable, ProcessId);
    if (CidEntry != NULL) {
        lProcess = (PEPROCESS)CidEntry->Object;
        if (lProcess->Pcb.Header.Type == ProcessObject &&
            lProcess->GrantedAccess != 0) {
            if (ObReferenceObjectSafe(lProcess)) {
               *Process = lProcess;
                Status = STATUS_SUCCESS;
            }
        }

        ExUnlockHandleTableEntry(PspCidTable, CidEntry);
    }

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    return Status;
}


NTSTATUS
PsLookupThreadByThreadId(
    __in HANDLE ThreadId,
    __deref_out PETHREAD *Thread
    )

/*++

Routine Description:

    This function accepts the thread id of a thread and returns a
    referenced pointer to the thread.

Arguments:

    ThreadId - Specifies the Thread ID of the thread.

    Thread - Returns a referenced pointer to the thread specified by the
        thread id.

Return Value:

    STATUS_SUCCESS - A thread was located based on the contents of
        the thread id.

    STATUS_INVALID_PARAMETER - The thread was not found.

--*/

{

    PHANDLE_TABLE_ENTRY CidEntry;
    PETHREAD lThread;
    PETHREAD CurrentThread;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_INVALID_PARAMETER;

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    CidEntry = ExMapHandleToPointer(PspCidTable, ThreadId);
    if (CidEntry != NULL) {
        lThread = (PETHREAD)CidEntry->Object;
        if (lThread->Tcb.Header.Type == ThreadObject && lThread->GrantedAccess) {

            if (ObReferenceObjectSafe(lThread)) {
                *Thread = lThread;
                Status = STATUS_SUCCESS;
            }
        }

        ExUnlockHandleTableEntry(PspCidTable, CidEntry);
    }

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\kulookup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    kulookup.c

Abstract:

    The module implements the code necessary to lookup user mode entry points
    in the system DLL for exception dispatching and APC delivery.

--*/

#include "psp.h"
#pragma alloc_text(INIT, PspLookupKernelUserEntryPoints)

NTSTATUS
PspLookupKernelUserEntryPoints (
    VOID
    )

/*++

Routine Description:

    The function locates the address of the exception dispatch and user APC
    delivery routine in the system DLL and stores the respective addresses
    in the PCR.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{

    NTSTATUS Status;
    PSZ EntryName;

    //
    // Lookup the user mode "trampoline" code for exception dispatching
    //

    EntryName = "KiUserExceptionDispatcher";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          (PVOID *)&KeUserExceptionDispatcher);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("Ps: Cannot find user exception dispatcher address\n"));
        return Status;
    }

    //
    // Lookup the user mode "trampoline" code for APC dispatching
    //

    EntryName = "KiUserApcDispatcher";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          (PVOID *)&KeUserApcDispatcher);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("Ps: Cannot find user apc dispatcher address\n"));
        return Status;
    }

    //
    // Lookup the user mode "trampoline" code for callback dispatching.
    //

    EntryName = "KiUserCallbackDispatcher";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          (PVOID *)&KeUserCallbackDispatcher);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("Ps: Cannot find user callback dispatcher address\n"));
        return Status;
    }

    //
    // Lookup the user mode "trampoline" code for raising a usermode exception.
    //

    EntryName = "KiRaiseUserExceptionDispatcher";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          (PVOID *)&KeRaiseUserExceptionDispatcher);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("Ps: Cannot find raise user exception dispatcher address\n"));
        return Status;
    }

    //
    // Lookup the user mode SLIST exception labels.
    //

    EntryName = "ExpInterlockedPopEntrySListEnd";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          &KeUserPopEntrySListEnd);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("Ps: Cannot find user slist end address\n"));
        return Status;
    }

    EntryName = "ExpInterlockedPopEntrySListFault";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          &KeUserPopEntrySListFault);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("Ps: Cannot find user slist fault address\n"));
        return Status;
    }

    EntryName = "ExpInterlockedPopEntrySListResume";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          &KeUserPopEntrySListResume);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("Ps: Cannot find user slist resume address\n"));
        return Status;
    }

#if defined(_X86_)

    if (KeFeatureBits & KF_FAST_SYSCALL) {

        //
        // Get the addresses of the fast system call code.
        //

        EntryName = "KiFastSystemCall";
        Status = PspLookupSystemDllEntryPoint(EntryName,
                                              (PVOID *)&SharedUserData->SystemCall);

        if (!NT_SUCCESS(Status)) {
            KdPrint(("Ps: Cannot find fast system call address\n"));
            return Status;
        }

        //
        // Get the addresses of the fast system call return code.
        //

        EntryName = "KiFastSystemCallRet";
        Status = PspLookupSystemDllEntryPoint(EntryName,
                                              (PVOID *)&SharedUserData->SystemCallReturn);

        if (!NT_SUCCESS(Status)) {
            KdPrint(("Ps: Cannot find fast system call return address\n"));
            return Status;
        }

    } else {

        //
        // Get the addresses of the fast system call code.
        //

        EntryName = "KiIntSystemCall";
        Status = PspLookupSystemDllEntryPoint(EntryName,
                                              (PVOID *)&SharedUserData->SystemCall);

        if (!NT_SUCCESS(Status)) {
            KdPrint(("Ps: Cannot find int2e system call address\n"));
            return Status;
        }
    }

    //
    // Ret instruction to test no execute state of shared user data.
    //

    SharedUserData->TestRetInstruction = 0xc3;

#endif

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\create.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    create.c

Abstract:

    Process and Thread Creation.

--*/

#include "psp.h"

ULONG
PspUnhandledExceptionInSystemThread(
    IN PEXCEPTION_POINTERS ExceptionPointers
    );

#pragma alloc_text(PAGE, NtCreateThread)
#pragma alloc_text(PAGE, PsCreateSystemThread)
#pragma alloc_text(PAGE, PspCreateThread)
#pragma alloc_text(PAGE, NtCreateProcess)
#pragma alloc_text(PAGE, NtCreateProcessEx)
#pragma alloc_text(PAGE, PsCreateSystemProcess)
#pragma alloc_text(PAGE, PspCreateProcess)
#pragma alloc_text(PAGE, PsSetCreateProcessNotifyRoutine)
#pragma alloc_text(PAGE, PsSetCreateThreadNotifyRoutine)
#pragma alloc_text(PAGE, PsRemoveCreateThreadNotifyRoutine)
#pragma alloc_text(PAGE, PspUserThreadStartup)
#pragma alloc_text(PAGE, PsSetLoadImageNotifyRoutine)
#pragma alloc_text(PAGE, PsRemoveLoadImageNotifyRoutine)
#pragma alloc_text(PAGE, PsCallImageNotifyRoutines)
#pragma alloc_text(PAGE, PspUnhandledExceptionInSystemThread)
#pragma alloc_text(PAGE, PspSystemThreadStartup)
#pragma alloc_text(PAGE, PspImageNotifyTest)

extern UNICODE_STRING CmCSDVersionString;

#ifdef ALLOC_DATA_PRAGMA

#pragma data_seg("PAGEDATA")

#endif

LCID PsDefaultSystemLocaleId = 0;
LCID PsDefaultThreadLocaleId = 0;
LANGID PsDefaultUILanguageId = 0;
LANGID PsInstallUILanguageId = 0;

//
// The following two globals are present to make it easier to change
// working set sizes when debugging.
//

ULONG PsMinimumWorkingSet = 20;
ULONG PsMaximumWorkingSet = 45;

BOOLEAN PsImageNotifyEnabled = FALSE;

#ifdef ALLOC_DATA_PRAGMA

#pragma data_seg()

#endif

//
// Define the local storage for the process lock fast mutex.
//

NTSTATUS
NtCreateThread(
    __out PHANDLE ThreadHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in HANDLE ProcessHandle,
    __out PCLIENT_ID ClientId,
    __in PCONTEXT ThreadContext,
    __in PINITIAL_TEB InitialTeb,
    __in BOOLEAN CreateSuspended
    )

/*++

Routine Description:

    This system service API creates and initializes a thread object.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    DesiredAccess - Supplies the desired access modes to the new thread.

    ObjectAttributes - Supplies the object attributes of the new thread.

    ProcessHandle - Supplies a handle to the process that the thread is being
                    created within.

    ClientId - Returns the CLIENT_ID of the new thread.

    ThreadContext - Supplies an initial context for the new thread.

    InitialTeb - Supplies the initial contents for the thread's TEB.

    CreateSuspended - Supplies a value that controls whether or not a
                      thread is created in a suspended state.

--*/

{
    NTSTATUS Status;
    INITIAL_TEB CapturedInitialTeb;

    PAGED_CODE();


    //
    // Probe all arguments
    //

    try {
        if (KeGetPreviousMode () != KernelMode) {
            ProbeForWriteHandle (ThreadHandle);

            if (ARGUMENT_PRESENT (ClientId)) {
                ProbeForWriteSmallStructure (ClientId, sizeof (CLIENT_ID), sizeof (ULONG));
            }

            if (ARGUMENT_PRESENT (ThreadContext) ) {
                ProbeForReadSmallStructure (ThreadContext, sizeof (CONTEXT), CONTEXT_ALIGN);
            } else {
                return STATUS_INVALID_PARAMETER;
            }
            ProbeForReadSmallStructure (InitialTeb, sizeof (InitialTeb->OldInitialTeb), sizeof (ULONG));
        }

        CapturedInitialTeb.OldInitialTeb = InitialTeb->OldInitialTeb;
        if (CapturedInitialTeb.OldInitialTeb.OldStackBase == NULL &&
            CapturedInitialTeb.OldInitialTeb.OldStackLimit == NULL) {
            //
            // Since the structure size here is less than 64k we don't need to reprobe
            //
            CapturedInitialTeb = *InitialTeb;
        }
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    Status = PspCreateThread (ThreadHandle,
                              DesiredAccess,
                              ObjectAttributes,
                              ProcessHandle,
                              NULL,
                              ClientId,
                              ThreadContext,
                              &CapturedInitialTeb,
                              CreateSuspended,
                              NULL,
                              NULL);

    return Status;
}

NTSTATUS
PsCreateSystemThread(
    __out PHANDLE ThreadHandle,
    __in ULONG DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt  HANDLE ProcessHandle,
    __out_opt PCLIENT_ID ClientId,
    __in PKSTART_ROUTINE StartRoutine,
    __in_opt PVOID StartContext
    )

/*++

Routine Description:

    This routine creates and starts a system thread.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    DesiredAccess - Supplies the desired access modes to the new thread.

    ObjectAttributes - Supplies the object attributes of the new thread.

    ProcessHandle - Supplies a handle to the process that the thread is being
                    created within.  If this parameter is not specified, then
                    the initial system process is used.

    ClientId - Returns the CLIENT_ID of the new thread.

    StartRoutine - Supplies the address of the system thread start routine.

    StartContext - Supplies context for a system thread start routine.

--*/

{
    NTSTATUS Status;
    HANDLE SystemProcess;
    PEPROCESS ProcessPointer;

    PAGED_CODE();

    ProcessPointer = NULL;

    if (ARGUMENT_PRESENT (ProcessHandle)) {
        SystemProcess = ProcessHandle;
    } else {
        SystemProcess = NULL;
        ProcessPointer = PsInitialSystemProcess;
    }

    Status = PspCreateThread (ThreadHandle,
                              DesiredAccess,
                              ObjectAttributes,
                              SystemProcess,
                              ProcessPointer,
                              ClientId,
                              NULL,
                              NULL,
                              FALSE,
                              StartRoutine,
                              StartContext);

    return Status;
}

BOOLEAN PsUseImpersonationToken = FALSE;


NTSTATUS
PspCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    IN PEPROCESS ProcessPointer,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PCONTEXT ThreadContext OPTIONAL,
    IN PINITIAL_TEB InitialTeb OPTIONAL,
    IN BOOLEAN CreateSuspended,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This routine creates and initializes a thread object. It implements the
    foundation for NtCreateThread and for PsCreateSystemThread.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    DesiredAccess - Supplies the desired access modes to the new thread.

    ObjectAttributes - Supplies the object attributes of the new thread.

    ProcessHandle - Supplies a handle to the process that the thread is being
                    created within.

    ClientId - Returns the CLIENT_ID of the new thread.

    ThreadContext - Supplies a pointer to a context frame that represents the
                initial user-mode context for a user-mode thread. The absence
                of this parameter indicates that a system thread is being
                created.

    InitialTeb - Supplies the contents of certain fields for the new threads
                 TEB. This parameter is only examined if both a trap and
                 exception frame were specified.

    CreateSuspended - Supplies a value that controls whether or not a user-mode
                      thread is created in a suspended state.

    StartRoutine - Supplies the address of the system thread start routine.

    StartContext - Supplies context for a system thread start routine.

--*/

{

    HANDLE_TABLE_ENTRY CidEntry;
    NTSTATUS Status;
    PETHREAD Thread;
    PETHREAD CurrentThread;
    PEPROCESS Process;
    PTEB Teb;
    KPROCESSOR_MODE PreviousMode;
    HANDLE LocalThreadHandle;
    BOOLEAN AccessCheck;
    BOOLEAN MemoryAllocated;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    NTSTATUS accesst;
    LARGE_INTEGER CreateTime;
    ULONG OldActiveThreads;
    PEJOB Job;
    AUX_ACCESS_DATA AuxData;
    PACCESS_STATE AccessState;
    ACCESS_STATE LocalAccessState;

    PAGED_CODE();


    CurrentThread = PsGetCurrentThread ();

    if (StartRoutine != NULL) {
        PreviousMode = KernelMode;
    } else {
        PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);
    }

    Teb = NULL;

    Thread = NULL;
    Process = NULL;

    if (ProcessHandle != NULL) {
        //
        // Process object reference count is biased by one for each thread.
        // This accounts for the pointer given to the kernel that remains
        // in effect until the thread terminates (and becomes signaled)
        //

        Status = ObReferenceObjectByHandle (ProcessHandle,
                                            PROCESS_CREATE_THREAD,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);
    } else {
        if (StartRoutine != NULL) {
            ObReferenceObject (ProcessPointer);
            Process = ProcessPointer;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INVALID_HANDLE;
        }
    }

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // If the previous mode is user and the target process is the system
    // process, then the operation cannot be performed.
    //

    if ((PreviousMode != KernelMode) && (Process == PsInitialSystemProcess)) {
        ObDereferenceObject (Process);
        return STATUS_INVALID_HANDLE;
    }

    Status = ObCreateObject (PreviousMode,
                             PsThreadType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof(ETHREAD),
                             0,
                             0,
                             &Thread);

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (Process);
        return Status;
    }

    RtlZeroMemory (Thread, sizeof (ETHREAD));

    //
    // Initialize rundown protection for cross thread TEB refs etc.
    //
    ExInitializeRundownProtection (&Thread->RundownProtect);

    //
    // Assign this thread to the process so that from now on
    // we don't have to dereference in error paths.
    //
    Thread->ThreadsProcess = Process;

    Thread->Cid.UniqueProcess = Process->UniqueProcessId;

    CidEntry.Object = Thread;
    CidEntry.GrantedAccess = 0;
    Thread->Cid.UniqueThread = ExCreateHandle (PspCidTable, &CidEntry);

    if (Thread->Cid.UniqueThread == NULL) {
        ObDereferenceObject (Thread);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize Mm
    //

    Thread->ReadClusterSize = MmReadClusterSize;

    //
    // Initialize LPC
    //

    KeInitializeSemaphore (&Thread->LpcReplySemaphore, 0L, 1L);
    InitializeListHead (&Thread->LpcReplyChain);

    //
    // Initialize Io
    //

    InitializeListHead (&Thread->IrpList);

    //
    // Initialize Registry
    //

    InitializeListHead (&Thread->PostBlockList);

    //
    // Initialize the thread lock
    //

    PspInitializeThreadLock (Thread);

    KeInitializeSpinLock (&Thread->ActiveTimerListLock);
    InitializeListHead (&Thread->ActiveTimerListHead);


    if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
        ObDereferenceObject (Thread);
        return STATUS_PROCESS_IS_TERMINATING;
    }

    if (ARGUMENT_PRESENT (ThreadContext)) {

        //
        // User-mode thread. Create TEB etc
        //

        Status = MmCreateTeb (Process, InitialTeb, &Thread->Cid, &Teb);
        if (!NT_SUCCESS (Status)) {
            ExReleaseRundownProtection (&Process->RundownProtect);
            ObDereferenceObject (Thread);
            return Status;
        }


        try {
            //
            // Initialize kernel thread object for user mode thread.
            //

            Thread->StartAddress = (PVOID)CONTEXT_TO_PROGRAM_COUNTER(ThreadContext);

#if defined(_AMD64_)

            Thread->Win32StartAddress = (PVOID)ThreadContext->Rdx;

#elif defined(_X86_)

            Thread->Win32StartAddress = (PVOID)ThreadContext->Eax;

#else

#error "no target architecture"

#endif

        } except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();
        }

        if (NT_SUCCESS (Status)) {
            Status = KeInitThread (&Thread->Tcb,
                                   NULL,
                                   PspUserThreadStartup,
                                   (PKSTART_ROUTINE)NULL,
                                   Thread->StartAddress,
                                   ThreadContext,
                                   Teb,
                                   &Process->Pcb);
       }


    } else {

        Teb = NULL;
        //
        // Set the system thread bit thats kept for all time
        //
        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_SYSTEM);

        //
        // Initialize kernel thread object for kernel mode thread.
        //

        Thread->StartAddress = (PKSTART_ROUTINE) StartRoutine;
        Status = KeInitThread (&Thread->Tcb,
                               NULL,
                               PspSystemThreadStartup,
                               StartRoutine,
                               StartContext,
                               NULL,
                               NULL,
                               &Process->Pcb);
    }


    if (!NT_SUCCESS (Status)) {
        if (Teb != NULL) {
            MmDeleteTeb(Process, Teb);
        }
        ExReleaseRundownProtection (&Process->RundownProtect);
        ObDereferenceObject (Thread);
        return Status;
    }

    PspLockProcessExclusive (Process, CurrentThread);
    //
    // Process is exiting or has had delete process called
    // We check the calling threads termination status so we
    // abort any thread creates while ExitProcess is being called --
    // but the call is blocked only if the new thread would be created
    // in the terminating thread's process.
    //
    if ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_DELETE) != 0 ||
        (((CurrentThread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) != 0) &&
        (ThreadContext != NULL) &&
        (THREAD_TO_PROCESS(CurrentThread) == Process))) {

        PspUnlockProcessExclusive (Process, CurrentThread);

        KeUninitThread (&Thread->Tcb);

        if (Teb != NULL) {
            MmDeleteTeb(Process, Teb);
        }
        ExReleaseRundownProtection (&Process->RundownProtect);
        ObDereferenceObject(Thread);

        return STATUS_PROCESS_IS_TERMINATING;
    }


    OldActiveThreads = Process->ActiveThreads++;
    InsertTailList (&Process->ThreadListHead, &Thread->ThreadListEntry);

    KeStartThread (&Thread->Tcb);

    PspUnlockProcessExclusive (Process, CurrentThread);

    ExReleaseRundownProtection (&Process->RundownProtect);

    //
    // Failures that occur after this point cause the thread to
    // go through PspExitThread
    //


    if (OldActiveThreads == 0) {
        PERFINFO_PROCESS_CREATE (Process);

        if (PspCreateProcessNotifyRoutineCount != 0) {
            ULONG i;
            PEX_CALLBACK_ROUTINE_BLOCK CallBack;
            PCREATE_PROCESS_NOTIFY_ROUTINE Rtn;

            for (i=0; i<PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {
                CallBack = ExReferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i]);
                if (CallBack != NULL) {
                    Rtn = (PCREATE_PROCESS_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                    Rtn (Process->InheritedFromUniqueProcessId,
                         Process->UniqueProcessId,
                         TRUE);
                    ExDereferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i],
                                                CallBack);
                }
            }
        }
    }

    //
    // If the process has a job with a completion port,
    // AND if the process is really considered to be in the Job, AND
    // the process has not reported, report in
    //
    // This should really be done in add process to job, but can't
    // in this path because the process's ID isn't assigned until this point
    // in time
    //
    Job = Process->Job;
    if (Job != NULL && Job->CompletionPort &&
        !(Process->JobStatus & (PS_JOB_STATUS_NOT_REALLY_ACTIVE|PS_JOB_STATUS_NEW_PROCESS_REPORTED))) {

        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NEW_PROCESS_REPORTED);

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite (&Job->JobLock, TRUE);
        if (Job->CompletionPort != NULL) {
            IoSetIoCompletion (Job->CompletionPort,
                               Job->CompletionKey,
                               (PVOID)Process->UniqueProcessId,
                               STATUS_SUCCESS,
                               JOB_OBJECT_MSG_NEW_PROCESS,
                               FALSE);
        }
        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    PERFINFO_THREAD_CREATE(Thread, InitialTeb);

    //
    // Notify registered callout routines of thread creation.
    //

    if (PspCreateThreadNotifyRoutineCount != 0) {
        ULONG i;
        PEX_CALLBACK_ROUTINE_BLOCK CallBack;
        PCREATE_THREAD_NOTIFY_ROUTINE Rtn;

        for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
            CallBack = ExReferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i]);
            if (CallBack != NULL) {
                Rtn = (PCREATE_THREAD_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                Rtn (Thread->Cid.UniqueProcess,
                     Thread->Cid.UniqueThread,
                     TRUE);
                ExDereferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i],
                                            CallBack);
            }
        }
    }


    //
    // Reference count of thread is biased once for itself and once for the handle if we create it.
    //

    ObReferenceObjectEx (Thread, 2);

    if (CreateSuspended) {
        try {
            KeSuspendThread (&Thread->Tcb);
        } except ((GetExceptionCode () == STATUS_SUSPEND_COUNT_EXCEEDED)?
                     EXCEPTION_EXECUTE_HANDLER :
                     EXCEPTION_CONTINUE_SEARCH) {
        }
        //
        // If deletion was started after we suspended then wake up the thread
        //
        if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) {
            KeForceResumeThread (&Thread->Tcb);
        }
    }

    AccessState = NULL;
    if (!PsUseImpersonationToken) {
        AccessState = &LocalAccessState;
        Status = SeCreateAccessStateEx (NULL,
                                        ARGUMENT_PRESENT (ThreadContext)?PsGetCurrentProcessByThread (CurrentThread) : Process,
                                        AccessState,
                                        &AuxData,
                                        DesiredAccess,
                                        &PsThreadType->TypeInfo.GenericMapping);

        if (!NT_SUCCESS (Status)) {
            PS_SET_BITS (&Thread->CrossThreadFlags,
                         PS_CROSS_THREAD_FLAGS_DEADTHREAD);

            if (CreateSuspended) {
                (VOID) KeResumeThread (&Thread->Tcb);
            }
            KeReadyThread (&Thread->Tcb);
            ObDereferenceObjectEx (Thread, 2);

            return Status;
        }
    }

    Status = ObInsertObject (Thread,
                             AccessState,
                             DesiredAccess,
                             0,
                             NULL,
                             &LocalThreadHandle);

    if (AccessState != NULL) {
        SeDeleteAccessState (AccessState);
    }

    if (!NT_SUCCESS (Status)) {

        //
        // The insert failed. Terminate the thread.
        //

        //
        // This trick is used so that Dbgk doesn't report
        // events for dead threads
        //

        PS_SET_BITS (&Thread->CrossThreadFlags,
                     PS_CROSS_THREAD_FLAGS_DEADTHREAD);

        if (CreateSuspended) {
            KeResumeThread (&Thread->Tcb);
        }

    } else {

        try {

            *ThreadHandle = LocalThreadHandle;
            if (ARGUMENT_PRESENT (ClientId)) {
                *ClientId = Thread->Cid;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {

            PS_SET_BITS (&Thread->CrossThreadFlags,
                         PS_CROSS_THREAD_FLAGS_DEADTHREAD);

            if (CreateSuspended) {
                (VOID) KeResumeThread (&Thread->Tcb);
            }
            KeReadyThread (&Thread->Tcb);
            ObDereferenceObject (Thread);
            ObCloseHandle (LocalThreadHandle, PreviousMode);
            return GetExceptionCode();
        }
    }

    KeQuerySystemTime(&CreateTime);
    ASSERT ((CreateTime.HighPart & 0xf0000000) == 0);
    PS_SET_THREAD_CREATE_TIME(Thread, CreateTime);


    if ((Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) == 0) {
        Status = ObGetObjectSecurity (Thread,
                                      &SecurityDescriptor,
                                      &MemoryAllocated);
        if (!NT_SUCCESS (Status)) {
            //
            // This trick us used so that Dbgk doesn't report
            // events for dead threads
            //
            PS_SET_BITS (&Thread->CrossThreadFlags,
                         PS_CROSS_THREAD_FLAGS_DEADTHREAD);

            if (CreateSuspended) {
                KeResumeThread(&Thread->Tcb);
            }
            KeReadyThread (&Thread->Tcb);
            ObDereferenceObject (Thread);
            ObCloseHandle (LocalThreadHandle, PreviousMode);
            return Status;
        }

        //
        // Compute the subject security context
        //

        SubjectContext.ProcessAuditId = Process;
        SubjectContext.PrimaryToken = PsReferencePrimaryToken(Process);
        SubjectContext.ClientToken = NULL;

        AccessCheck = SeAccessCheck (SecurityDescriptor,
                                     &SubjectContext,
                                     FALSE,
                                     MAXIMUM_ALLOWED,
                                     0,
                                     NULL,
                                     &PsThreadType->TypeInfo.GenericMapping,
                                     PreviousMode,
                                     &Thread->GrantedAccess,
                                     &accesst);

        PsDereferencePrimaryTokenEx (Process, SubjectContext.PrimaryToken);

        ObReleaseObjectSecurity (SecurityDescriptor,
                                 MemoryAllocated);

        if (!AccessCheck) {
            Thread->GrantedAccess = 0;
        }

        Thread->GrantedAccess |= (THREAD_TERMINATE | THREAD_SET_INFORMATION | THREAD_QUERY_INFORMATION);

    } else {
        Thread->GrantedAccess = THREAD_ALL_ACCESS;
    }

    KeReadyThread (&Thread->Tcb);
    ObDereferenceObject (Thread);

    return Status;
}

NTSTATUS
NtCreateProcess(
    __out PHANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in HANDLE ParentProcess,
    __in BOOLEAN InheritObjectTable,
    __in_opt HANDLE SectionHandle,
    __in_opt HANDLE DebugPort,
    __in_opt HANDLE ExceptionPort
    )
{
    ULONG Flags = 0;

    if ((ULONG_PTR)SectionHandle & 1) {
        Flags |= PROCESS_CREATE_FLAGS_BREAKAWAY;
    }

    if ((ULONG_PTR) DebugPort & 1) {
        Flags |= PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT;
    }

    if (InheritObjectTable) {
        Flags |= PROCESS_CREATE_FLAGS_INHERIT_HANDLES;
    }

    return NtCreateProcessEx (ProcessHandle,
                              DesiredAccess,
                              ObjectAttributes OPTIONAL,
                              ParentProcess,
                              Flags,
                              SectionHandle,
                              DebugPort,
                              ExceptionPort,
                              0);
}

NTSTATUS
NtCreateProcessEx(
    __out PHANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in HANDLE ParentProcess,
    __in ULONG Flags,
    __in_opt HANDLE SectionHandle,
    __in_opt HANDLE DebugPort,
    __in_opt HANDLE ExceptionPort,
    __in ULONG JobMemberLevel
    )

/*++

Routine Description:

    This routine creates a process object.

Arguments:

    ProcessHandle - Returns the handle for the new process.

    DesiredAccess - Supplies the desired access modes to the new process.

    ObjectAttributes - Supplies the object attributes of the new process.
    .
    .
    .

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    if (KeGetPreviousMode() != KernelMode) {

        //
        // Probe all arguments
        //

        try {
            ProbeForWriteHandle (ProcessHandle);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    if (ARGUMENT_PRESENT (ParentProcess)) {
        Status = PspCreateProcess (ProcessHandle,
                                   DesiredAccess,
                                   ObjectAttributes,
                                   ParentProcess,
                                   Flags,
                                   SectionHandle,
                                   DebugPort,
                                   ExceptionPort,
                                   JobMemberLevel);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}


NTSTATUS
PsCreateSystemProcess(
    __out PHANDLE ProcessHandle,
    __in ULONG DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This routine creates a system process object. A system process
    has an address space that is initialized to an empty address space
    that maps the system.

    The process inherits its access token and other attributes from the
    initial system process. The process is created with an empty handle table.

Arguments:

    ProcessHandle - Returns the handle for the new process.

    DesiredAccess - Supplies the desired access modes to the new process.

    ObjectAttributes - Supplies the object attributes of the new process.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    Status = PspCreateProcess (ProcessHandle,
                               DesiredAccess,
                               ObjectAttributes,
                               PspInitialSystemProcessHandle,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               0);

    return Status;
}

NTSTATUS
PspCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess OPTIONAL,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel
    )

/*++

Routine Description:

    This routine creates and initializes a process object.  It implements the
    foundation for NtCreateProcess and for system initialization process
    creation.

Arguments:

    ProcessHandle - Returns the handle for the new process.

    DesiredAccess - Supplies the desired access modes to the new process.

    ObjectAttributes - Supplies the object attributes of the new process.

    ParentProcess - Supplies a handle to the process' parent process.  If this
                    parameter is not specified, then the process has no parent
                    and is created using the system address space.

    Flags         - Process creation flags

    SectionHandle - Supplies a handle to a section object to be used to create
                    the process' address space.  If this parameter is not
                    specified, then the address space is simply a clone of the
                    parent process' address space.

    DebugPort - Supplies a handle to a port object that will be used as the
                process' debug port.

    ExceptionPort - Supplies a handle to a port object that will be used as the
                    process' exception port.

    JobMemberLevel - Level for a create process in a jobset

--*/

{

    NTSTATUS Status;
    PEPROCESS Process;
    PEPROCESS CurrentProcess;
    PEPROCESS Parent;
    PETHREAD CurrentThread;
    KAFFINITY Affinity;
    KPRIORITY BasePriority;
    PVOID SectionObject;
    PVOID ExceptionPortObject;
    PVOID DebugPortObject;
    ULONG WorkingSetMinimum, WorkingSetMaximum;
    HANDLE LocalProcessHandle;
    KPROCESSOR_MODE PreviousMode;
    INITIAL_PEB InitialPeb;
    BOOLEAN CreatePeb;
    ULONG_PTR DirectoryTableBase[2];
    BOOLEAN AccessCheck;
    BOOLEAN MemoryAllocated;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    NTSTATUS accesst;
    NTSTATUS SavedStatus;
    ULONG ImageFileNameSize;
    HANDLE_TABLE_ENTRY CidEntry;
    PEJOB Job;
    PPEB Peb;
    AUX_ACCESS_DATA AuxData;
    PACCESS_STATE AccessState;
    ACCESS_STATE LocalAccessState;
    BOOLEAN UseLargePages;
    SCHAR QuantumReset;
#if defined(_WIN64)
    INITIAL_PEB32 InitialPeb32;
#endif

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);
    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);

    CreatePeb = FALSE;
    UseLargePages = FALSE;
    DirectoryTableBase[0] = 0;
    DirectoryTableBase[1] = 0;
    Peb = NULL;
    
    //
    // Reject bogus create parameters for future expansion
    //
    if (Flags&~PROCESS_CREATE_FLAGS_LEGAL_MASK) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Parent
    //

    if (ARGUMENT_PRESENT (ParentProcess)) {
        Status = ObReferenceObjectByHandle (ParentProcess,
                                            PROCESS_CREATE_PROCESS,
                                            PsProcessType,
                                            PreviousMode,
                                            &Parent,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        if (JobMemberLevel != 0 && Parent->Job == NULL) {
            ObDereferenceObject (Parent);
            return STATUS_INVALID_PARAMETER;
        }

        Affinity = Parent->Pcb.Affinity;
        WorkingSetMinimum = PsMinimumWorkingSet;
        WorkingSetMaximum = PsMaximumWorkingSet;


    } else {

        Parent = NULL;
        Affinity = KeActiveProcessors;
        WorkingSetMinimum = PsMinimumWorkingSet;
        WorkingSetMaximum = PsMaximumWorkingSet;
    }

    //
    // Create the process object
    //
    Status = ObCreateObject (PreviousMode,
                             PsProcessType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (EPROCESS),
                             0,
                             0,
                             &Process);

    if (!NT_SUCCESS (Status)) {
        goto exit_and_deref_parent;
    }

    //
    // The process object is created set to NULL. Errors
    // That occur after this step cause the process delete
    // routine to be entered.
    //
    // Teardown actions that occur in the process delete routine
    // do not need to be performed inline.
    //

    RtlZeroMemory (Process, sizeof(EPROCESS));
    ExInitializeRundownProtection (&Process->RundownProtect);
    PspInitializeProcessLock (Process);
    InitializeListHead (&Process->ThreadListHead);

#if defined(_WIN64)

    if (Flags & PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE) {
        PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_OVERRIDE_ADDRESS_SPACE);
    }

#endif

    PspInheritQuota (Process, Parent);
    ObInheritDeviceMap (Process, Parent);
    if (Parent != NULL) {
        Process->DefaultHardErrorProcessing = Parent->DefaultHardErrorProcessing;
        Process->InheritedFromUniqueProcessId = Parent->UniqueProcessId;

    } else {
        Process->DefaultHardErrorProcessing = PROCESS_HARDERROR_DEFAULT;
        Process->InheritedFromUniqueProcessId = NULL;
    }

    //
    // Section
    //

    if (ARGUMENT_PRESENT (SectionHandle)) {
        Status = ObReferenceObjectByHandle (SectionHandle,
                                            SECTION_MAP_EXECUTE,
                                            MmSectionObjectType,
                                            PreviousMode,
                                            &SectionObject,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }

    } else {
        SectionObject = NULL;
        if (Parent != PsInitialSystemProcess) {

            //
            // Fetch the section pointer from the parent process
            // as we will be cloning. Since the section pointer
            // is removed at last thread exit we need to protect against
            // process exit here to be safe.
            //

            if (ExAcquireRundownProtection (&Parent->RundownProtect)) {
                SectionObject = Parent->SectionObject;
                if (SectionObject != NULL) {
                    ObReferenceObject (SectionObject);
                }

                ExReleaseRundownProtection (&Parent->RundownProtect);
            }

            if (SectionObject == NULL) {
                Status = STATUS_PROCESS_IS_TERMINATING;
                goto exit_and_deref;
            }
        }
    }

    Process->SectionObject = SectionObject;

    //
    // DebugPort
    //

    if (ARGUMENT_PRESENT (DebugPort)) {
        Status = ObReferenceObjectByHandle (DebugPort,
                                            DEBUG_PROCESS_ASSIGN,
                                            DbgkDebugObjectType,
                                            PreviousMode,
                                            &DebugPortObject,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }

        Process->DebugPort = DebugPortObject;
        if (Flags&PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT) {
            PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT);
        }

    } else {
        if (Parent != NULL) {
            DbgkCopyProcessDebugPort (Process, Parent);
        }
    }

    //
    // ExceptionPort
    //

    if (ARGUMENT_PRESENT (ExceptionPort)) {
        Status = ObReferenceObjectByHandle (ExceptionPort,
                                            0,
                                            LpcPortObjectType,
                                            PreviousMode,
                                            &ExceptionPortObject,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }

        Process->ExceptionPort = ExceptionPortObject;
    }

    Process->ExitStatus = STATUS_PENDING;

    //
    // Clone parent's object table.
    // If no parent (booting) then use the current object table created in
    // ObInitSystem.
    //

    if (Parent != NULL) {

        //
        // Calculate address space
        //
        //      If Parent == PspInitialSystem
        //

        if (!MmCreateProcessAddressSpace (WorkingSetMinimum,
                                          Process,
                                          &DirectoryTableBase[0])) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit_and_deref;
        }

    } else {
        Process->ObjectTable = CurrentProcess->ObjectTable;

        //
        // Initialize the Working Set Mutex and address creation mutex
        // for this "hand built" process.
        // Normally, the call to MmInitializeAddressSpace initializes the
        // working set mutex, however, in this case, we have already initialized
        // the address space and we are now creating a second process using
        // the address space of the idle thread.
        //

        Status = MmInitializeHandBuiltProcess (Process, &DirectoryTableBase[0]);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
    }

    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_HAS_ADDRESS_SPACE);
    Process->Vm.MaximumWorkingSetSize = WorkingSetMaximum;
    KeInitializeProcess (&Process->Pcb,
                         NORMAL_BASE_PRIORITY,
                         Affinity,
                         &DirectoryTableBase[0],
                         (BOOLEAN)(Process->DefaultHardErrorProcessing & PROCESS_HARDERROR_ALIGNMENT_BIT));

    //
    //  Initialize the security fields of the process
    //  The parent may be null exactly once (during system init).
    //  Thereafter, a parent is always required so that we have a
    //  security context to duplicate for the new process.
    //

    Status = PspInitializeProcessSecurity (Parent, Process);
    if (!NT_SUCCESS (Status)) {
        goto exit_and_deref;
    }

    Process->PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;
    if (Parent != NULL) {
        if (Parent->PriorityClass == PROCESS_PRIORITY_CLASS_IDLE ||
            Parent->PriorityClass == PROCESS_PRIORITY_CLASS_BELOW_NORMAL) {
            Process->PriorityClass = Parent->PriorityClass;
        }

        //
        // if address space creation worked, then when going through
        // delete, we will attach. Of course, attaching means that the kprocess
        // must be initialized, so we delay the object stuff till here.
        //

        Status = ObInitProcess ((Flags&PROCESS_CREATE_FLAGS_INHERIT_HANDLES) ? Parent : NULL,
                                Process);

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }

    } else {
        Status = MmInitializeHandBuiltProcess2 (Process);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
    }

    Status = STATUS_SUCCESS;
    SavedStatus = STATUS_SUCCESS;

    //
    // Initialize the process address space
    // The address space has four possibilities
    //
    //      1 - Boot Process. Address space is initialized during
    //          MmInit. Parent is not specified.
    //
    //      2 - System Process. Address space is a virgin address
    //          space that only maps system space. Process is same
    //          as PspInitialSystemProcess.
    //
    //      3 - User Process (Cloned Address Space). Address space
    //          is cloned from the specified process.
    //
    //      4 - User Process (New Image Address Space). Address space
    //          is initialized so that it maps the specified section.
    //

    if (SectionHandle != NULL) {

        //
        // User Process (New Image Address Space). Don't specify Process to
        // clone, just SectionObject.
        //
        // Passing in the 4th parameter as below lets the EPROCESS struct contain its image file name, provided that
        // appropriate audit settings are enabled.  Memory is allocated inside of MmInitializeProcessAddressSpace
        // and pointed to by ImageFileName, so that must be freed in the process deletion routine (PspDeleteProcess())
        //

        Status = MmInitializeProcessAddressSpace (Process,
                                                  NULL,
                                                  SectionObject,
                                                  &Flags,
                                                  &(Process->SeAuditProcessCreationInfo.ImageFileName));

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }

        //
        // In order to support relocating executables, the proper status
        // (STATUS_IMAGE_NOT_AT_BASE) must be returned, so save it here.
        //

        SavedStatus = Status;
        CreatePeb = TRUE;
        UseLargePages = ((Flags & PROCESS_CREATE_FLAGS_LARGE_PAGES) != 0 ? TRUE : FALSE);

    } else if (Parent != NULL) {
        if (Parent != PsInitialSystemProcess) {
            Process->SectionBaseAddress = Parent->SectionBaseAddress;

            //
            // User Process ( Cloned Address Space ).  Don't specify section to
            // map, just Process to clone.
            //

            Status = MmInitializeProcessAddressSpace (Process,
                                                      Parent,
                                                      NULL,
                                                      &Flags,
                                                      NULL);

            if (!NT_SUCCESS (Status)) {
                goto exit_and_deref;
            }

            CreatePeb = TRUE;
            UseLargePages = ((Flags & PROCESS_CREATE_FLAGS_LARGE_PAGES) != 0 ? TRUE : FALSE);
            
            //
            // A cloned process isn't started from an image file, so we give it the name
            // of the process of which it is a clone, provided the original has a name.
            //

            if (Parent->SeAuditProcessCreationInfo.ImageFileName != NULL) {
                ImageFileNameSize = sizeof(OBJECT_NAME_INFORMATION) +
                                    Parent->SeAuditProcessCreationInfo.ImageFileName->Name.MaximumLength;

                Process->SeAuditProcessCreationInfo.ImageFileName =
                    ExAllocatePoolWithTag (PagedPool,
                                           ImageFileNameSize,
                                           'aPeS');

                if (Process->SeAuditProcessCreationInfo.ImageFileName != NULL) {
                    RtlCopyMemory (Process->SeAuditProcessCreationInfo.ImageFileName,
                                   Parent->SeAuditProcessCreationInfo.ImageFileName,
                                   ImageFileNameSize);

                    //
                    // The UNICODE_STRING in the process is self contained, so calculate the
                    // offset for the buffer.
                    //

                    Process->SeAuditProcessCreationInfo.ImageFileName->Name.Buffer =
                        (PUSHORT)(((PUCHAR) Process->SeAuditProcessCreationInfo.ImageFileName) +
                        sizeof(UNICODE_STRING));

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit_and_deref;
                }
            }

        } else {

            //
            // System Process.  Don't specify Process to clone or section to map
            //

            Flags &= ~PROCESS_CREATE_FLAGS_ALL_LARGE_PAGE_FLAGS;
            Status = MmInitializeProcessAddressSpace (Process,
                                                      NULL,
                                                      NULL,
                                                      &Flags,
                                                      NULL);

            if (!NT_SUCCESS (Status)) {
                goto exit_and_deref;
            }

            //
            // In case the image file name of this system process is ever queried, we give
            // a zero length UNICODE_STRING.
            //

            Process->SeAuditProcessCreationInfo.ImageFileName =
                ExAllocatePoolWithTag (PagedPool,
                                       sizeof(OBJECT_NAME_INFORMATION),
                                       'aPeS');

            if (Process->SeAuditProcessCreationInfo.ImageFileName != NULL) {
                RtlZeroMemory (Process->SeAuditProcessCreationInfo.ImageFileName,
                               sizeof(OBJECT_NAME_INFORMATION));
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit_and_deref;
            }
        }
    }

    //
    // Create the process ID
    //

    CidEntry.Object = Process;
    CidEntry.GrantedAccess = 0;
    Process->UniqueProcessId = ExCreateHandle (PspCidTable, &CidEntry);
    if (Process->UniqueProcessId == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_and_deref;
    }

    ExSetHandleTableOwner (Process->ObjectTable, Process->UniqueProcessId);

    //
    // Audit the process creation.
    //

    if (SeDetailedAuditingWithToken (NULL)) {
        SeAuditProcessCreation (Process);
    }

    //
    // See if the parent has a job. If so reference the job
    // and add the process in.
    //

    if (Parent) {
        Job = Parent->Job;
        if (Job != NULL && !(Job->LimitFlags & JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)) {
            if (Flags&PROCESS_CREATE_FLAGS_BREAKAWAY) {
                if (!(Job->LimitFlags & JOB_OBJECT_LIMIT_BREAKAWAY_OK)) {
                    Status = STATUS_ACCESS_DENIED;

                } else {
                    Status = STATUS_SUCCESS;
                }

            } else {
                Status = PspGetJobFromSet (Job, JobMemberLevel, &Process->Job);
                if (NT_SUCCESS (Status)) {
                    PACCESS_TOKEN Token, NewToken;
                    Job = Process->Job;
                    Status = PspAddProcessToJob (Job, Process);

                    //
                    // Duplicate a new process token if one is specified for the job
                    //

                    Token = Job->Token;
                    if (Token != NULL) {
                        Status = SeSubProcessToken (Token,
                                                    &NewToken,
                                                    FALSE,
                                                    Job->SessionId);

                        if (!NT_SUCCESS (Status)) {
                            goto exit_and_deref;
                        }

                        SeAssignPrimaryToken (Process, NewToken);    
                        ObDereferenceObject (NewToken);                    
                    }
                }
            }

            if (!NT_SUCCESS (Status)) {
                goto exit_and_deref;
            }
        }
    }

    if (Parent && CreatePeb) {

        //
        // For processes created w/ a section,
        // a new "virgin" PEB is created. Otherwise,
        // for forked processes, uses inherited PEB
        // with an updated mutant.
        //

        RtlZeroMemory (&InitialPeb, FIELD_OFFSET(INITIAL_PEB, Mutant));

        InitialPeb.Mutant = (HANDLE)(-1);
        InitialPeb.ImageUsesLargePages = (BOOLEAN) UseLargePages;
            
        if (SectionHandle != NULL) {
            Status = MmCreatePeb (Process, &InitialPeb, &Process->Peb);
            if (!NT_SUCCESS (Status)) {
                Process->Peb = NULL;
                goto exit_and_deref;
            }

            Peb =  Process->Peb;

        } else {
            SIZE_T BytesCopied;

            InitialPeb.InheritedAddressSpace = TRUE;
            Process->Peb = Parent->Peb;
            MmCopyVirtualMemory (CurrentProcess,
                                 &InitialPeb,
                                 Process,
                                 Process->Peb,
                                 sizeof (INITIAL_PEB),
                                 KernelMode,
                                 &BytesCopied);

#if defined(_WIN64)
            if (Process->Wow64Process != NULL) {
                
                RtlZeroMemory (&InitialPeb32, FIELD_OFFSET(INITIAL_PEB32, Mutant));
                InitialPeb32.Mutant = -1;
                InitialPeb32.InheritedAddressSpace = TRUE;
                InitialPeb32.ImageUsesLargePages = (BOOLEAN) UseLargePages;

                MmCopyVirtualMemory (CurrentProcess,
                                     &InitialPeb32,
                                     Process,
                                     Process->Wow64Process->Wow64,
                                     sizeof (INITIAL_PEB32),
                                     KernelMode,
                                     &BytesCopied);
            }
#endif

        }
    }

    Peb = Process->Peb;

    //
    // Add the process to the global list of processes.
    //

    PspLockProcessList (CurrentThread);
    InsertTailList (&PsActiveProcessHead, &Process->ActiveProcessLinks);
    PspUnlockProcessList (CurrentThread);
    AccessState = NULL;
    if (!PsUseImpersonationToken) {
        AccessState = &LocalAccessState;
        Status = SeCreateAccessStateEx (NULL,
                                        (Parent == NULL || Parent != PsInitialSystemProcess)?
                                           PsGetCurrentProcessByThread (CurrentThread) :
                                           PsInitialSystemProcess,
                                        AccessState,
                                        &AuxData,
                                        DesiredAccess,
                                        &PsProcessType->TypeInfo.GenericMapping);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
    }

    //
    // Insert the object. Once we do this is reachable from the outside world via
    // open by name. Open by ID is still disabled. Since its reachable
    // somebody might create a thread in the process and cause
    // rundown.
    //

    Status = ObInsertObject (Process,
                             AccessState,
                             DesiredAccess,
                             1,     // bias the refcnt by one for future process manipulations
                             NULL,
                             &LocalProcessHandle);

    if (AccessState != NULL) {
        SeDeleteAccessState (AccessState);
    }

    if (!NT_SUCCESS (Status)) {
        goto exit_and_deref_parent;
    }

    //
    // Compute the base priority and quantum reset values for the process and
    // set the memory priority.
    //

    ASSERT(IsListEmpty(&Process->ThreadListHead) == TRUE);

    BasePriority = PspComputeQuantumAndPriority(Process,
                                                PsProcessPriorityBackground,
                                                &QuantumReset);

    Process->Pcb.BasePriority = (SCHAR)BasePriority;
    Process->Pcb.QuantumReset = QuantumReset;

    //
    // As soon as a handle to the process is accessible, allow the process to
    // be deleted.
    //

    Process->GrantedAccess = PROCESS_TERMINATE;
    if (Parent && Parent != PsInitialSystemProcess) {
        Status = ObGetObjectSecurity (Process,
                                      &SecurityDescriptor,
                                      &MemoryAllocated);

        if (!NT_SUCCESS (Status)) {
            ObCloseHandle (LocalProcessHandle, PreviousMode);
            goto exit_and_deref;
        }

        //
        // Compute the subject security context
        //

        SubjectContext.ProcessAuditId = Process;
        SubjectContext.PrimaryToken = PsReferencePrimaryToken(Process);
        SubjectContext.ClientToken = NULL;
        AccessCheck = SeAccessCheck (SecurityDescriptor,
                                     &SubjectContext,
                                     FALSE,
                                     MAXIMUM_ALLOWED,
                                     0,
                                     NULL,
                                     &PsProcessType->TypeInfo.GenericMapping,
                                     PreviousMode,
                                     &Process->GrantedAccess,
                                     &accesst);

        PsDereferencePrimaryTokenEx (Process, SubjectContext.PrimaryToken);
        ObReleaseObjectSecurity (SecurityDescriptor,
                                 MemoryAllocated);

        if (!AccessCheck) {
            Process->GrantedAccess = 0;
        }

        //
        // It does not make any sense to create a process that can not
        // do anything to itself.
        // Note: Changes to this set of bits should be reflected in psquery.c
        // code, in PspSetPrimaryToken.
        //

        Process->GrantedAccess |= (PROCESS_VM_OPERATION |
                                   PROCESS_VM_READ |
                                   PROCESS_VM_WRITE |
                                   PROCESS_QUERY_INFORMATION |
                                   PROCESS_TERMINATE |
                                   PROCESS_CREATE_THREAD |
                                   PROCESS_DUP_HANDLE |
                                   PROCESS_CREATE_PROCESS |
                                   PROCESS_SET_INFORMATION |
                                   STANDARD_RIGHTS_ALL |
                                   PROCESS_SET_QUOTA);

    } else {
        Process->GrantedAccess = PROCESS_ALL_ACCESS;
    }

    KeQuerySystemTime (&Process->CreateTime);
    try {
        if (Peb != NULL && CurrentThread->Tcb.Teb != NULL) {
            ((PTEB)(CurrentThread->Tcb.Teb))->NtTib.ArbitraryUserPointer = Peb;
        }

        *ProcessHandle = LocalProcessHandle;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    if (SavedStatus != STATUS_SUCCESS) {
        Status = SavedStatus;
    }

exit_and_deref:
    ObDereferenceObject (Process);

exit_and_deref_parent:
    if (Parent != NULL) {
        ObDereferenceObject (Parent);
    }

    return Status;
}

NTSTATUS
PsSetCreateProcessNotifyRoutine(
    __in PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
    __in BOOLEAN Remove
    )

/*++

Routine Description:

    This function allows an installable file system to hook into process
    creation and deletion to track those events against their own internal
    data structures.

Arguments:

    NotifyRoutine - Supplies the address of a routine which is called at
        process creation and deletion. The routine is passed the unique Id
        of the created or deleted process and the parent process if it was
        created with the inherit handles option. If it was created without
        the inherit handle options, then the parent process Id will be NULL.
        The third parameter passed to the notify routine is TRUE if the process
        is being created and FALSE if it is being deleted.

        The callout for creation happens just after the first thread in the
        process has been created. The callout for deletion happens after the
        last thread in a process has terminated and the address space is about
        to be deleted. It is possible to get a deletion call without a creation
        call if the pathological case where a process is created and deleted
        without a thread ever being created.

    Remove - FALSE specifies to install the callout and TRUE specifies to
        remove the callout that mat

Return Value:

    STATUS_SUCCESS if successful, and STATUS_INVALID_PARAMETER if not.

--*/

{

    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    if (Remove) {
        for (i = 0; i < PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {

            //
            // Reference the callback so we can check its routine address.
            //
            CallBack = ExReferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i]);

            if (CallBack != NULL) {
                //
                // See if the routine matches our target
                //
                if ((PCREATE_PROCESS_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack) == NotifyRoutine) {

                    if (ExCompareExchangeCallBack (&PspCreateProcessNotifyRoutine[i],
                                                   NULL,
                                                   CallBack)) {

                        InterlockedDecrement ((PLONG) &PspCreateProcessNotifyRoutineCount);

                        ExDereferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i],
                                                    CallBack);

                        //
                        // Wait for any active callbacks to finish and free the block.
                        //
                        ExWaitForCallBacks (CallBack);
                    
                        ExFreeCallBack (CallBack);

                        return STATUS_SUCCESS;
                    }
                }
                ExDereferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i],
                                            CallBack);
            }
        }

        return STATUS_PROCEDURE_NOT_FOUND;
    } else {
        //
        // Allocate a new callback block.
        // 
        CallBack = ExAllocateCallBack ((PEX_CALLBACK_FUNCTION) NotifyRoutine, NULL);
        if (CallBack == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        for (i = 0; i < PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {
            //
            // Try and swap a null entry for the new block.
            //
            if (ExCompareExchangeCallBack (&PspCreateProcessNotifyRoutine[i],
                                           CallBack,
                                           NULL)) {
                InterlockedIncrement ((PLONG) &PspCreateProcessNotifyRoutineCount);
                return STATUS_SUCCESS;
            }
        }
        //
        // No slots left. Free the block and return.
        //
        ExFreeCallBack (CallBack);
        return STATUS_INVALID_PARAMETER;
    }

}

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    __in PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This function allows an installable file system to hook into thread
    creation and deletion to track those events against their own internal
    data structures.

Arguments:

    NotifyRoutine - Supplies the address of the routine which is called at
        thread creation and deletion. The routine is passed the unique Id
        of the created or deleted thread and the unique Id of the containing
        process. The third parameter passed to the notify routine is TRUE if
        the thread is being created and FALSE if it is being deleted.

Return Value:

    STATUS_SUCCESS if successful, and STATUS_INSUFFICIENT_RESOURCES if not.

--*/

{

    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    //
    // Allocate a new callback block.
    // 
    CallBack = ExAllocateCallBack ((PEX_CALLBACK_FUNCTION) NotifyRoutine, NULL);
    if (CallBack == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i += 1) {
        //
        // Try and swap a null entry for the new block.
        //
        if (ExCompareExchangeCallBack (&PspCreateThreadNotifyRoutine[i],
                                       CallBack,
                                       NULL)) {
            InterlockedIncrement ((PLONG) &PspCreateThreadNotifyRoutineCount);
            return STATUS_SUCCESS;
        }
    }
    //
    // No slots left. Free the block and return.
    //
    ExFreeCallBack (CallBack);
    return STATUS_INSUFFICIENT_RESOURCES;
}

NTSTATUS
PsRemoveCreateThreadNotifyRoutine (
    __in PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    )
/*++

Routine Description:

    This function allows an installable file system to unhook from thread
    creation and deletion.

Arguments:

    NotifyRoutine - Supplies the address of the routine which was previously
                    registered with PsSetCreateThreadNotifyRoutine

Return Value:

    STATUS_SUCCESS if successful, and STATUS_PROCEDURE_NOT_FOUND if not.

--*/
{
    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i += 1) {

        //
        // Reference the callback so we can check its routine address.
        //
        CallBack = ExReferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i]);

        if (CallBack != NULL) {
            //
            // See if the routine matches our target
            //
            if ((PCREATE_THREAD_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack) == NotifyRoutine) {

                if (ExCompareExchangeCallBack (&PspCreateThreadNotifyRoutine[i],
                                               NULL,
                                               CallBack)) {

                    InterlockedDecrement ((PLONG) &PspCreateThreadNotifyRoutineCount);

                    ExDereferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i],
                                                CallBack);

                    //
                    // Wait for any active callbacks to finish and free the block.
                    //
                    ExWaitForCallBacks (CallBack);
                    
                    ExFreeCallBack (CallBack);

                    return STATUS_SUCCESS;
                }
            }
            ExDereferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i],
                                        CallBack);
        }
    }

    return STATUS_PROCEDURE_NOT_FOUND;
}

VOID
PspUserThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is called by the kernel to start a user-mode thread.

Arguments:

    StartRoutine - Ignored.

    StartContext - Supplies the initial pc value for the thread.

Return Value:

    None.

--*/

{
    PETHREAD Thread;
    PEPROCESS Process;
    PTEB Teb;
    ULONG OldFlags;
    BOOLEAN KillThread;
    KIRQL OldIrql;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(StartRoutine);

    KeLowerIrql (PASSIVE_LEVEL);

    Thread = PsGetCurrentThread ();
    Process = PsGetCurrentProcessByThread (Thread);

    //
    // All threads start with an APC at LdrInitializeThunk
    //

    //
    // See if we need to terminate early because of a error in the create path
    //
    KillThread = FALSE;
    if ((Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_DEADTHREAD) != 0) {
        KillThread = TRUE;
    }

    //
    // Note: Initializing the TEB here is just to satisfy the compiler.
    //

    Teb = NtCurrentTeb ();

    if (!KillThread) {
        try {
            Teb->CurrentLocale = MmGetSessionLocaleId ();
            Teb->IdealProcessor = Thread->Tcb.IdealProcessor;
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    //
    // If the create worked then notify the debugger.
    //
    if ((Thread->CrossThreadFlags&
         (PS_CROSS_THREAD_FLAGS_DEADTHREAD|PS_CROSS_THREAD_FLAGS_HIDEFROMDBG)) == 0) {
        DbgkCreateThread (Thread, StartContext);
    }

    //
    // If something went wrong then terminate the thread
    //
    if (KillThread) {
        PspTerminateThreadByPointer (Thread,
                                     STATUS_THREAD_IS_TERMINATING,
                                     TRUE);
    } else {

        if (CCPF_IS_PREFETCHER_ENABLED()) {

            //
            // If this is the first thread we are starting up in this process,
            // prefetch the pages likely to be used when initializing the 
            // application into the system cache.
            //

            if ((Process->Flags & PS_PROCESS_FLAGS_LAUNCH_PREFETCHED) == 0) {

                OldFlags = PS_TEST_SET_BITS(&Process->Flags, PS_PROCESS_FLAGS_LAUNCH_PREFETCHED);

                if ((OldFlags & PS_PROCESS_FLAGS_LAUNCH_PREFETCHED) == 0) {

                    if (Process->SectionObject) {

                        //
                        // Notify cache manager of this application launch.
                        //

                        CcPfBeginAppLaunch(Process, Process->SectionObject);
                    }
                }
            }
        }

        //
        // Queue the initial APC to the thread
        //

        KeRaiseIrql (APC_LEVEL, &OldIrql);

        KiInitializeUserApc (PspGetBaseExceptionFrame (Thread),
                             PspGetBaseTrapFrame (Thread),
                             PspSystemDll.LoaderInitRoutine,
                             NULL,
                             PspSystemDll.DllBase,
                             NULL);

        KeLowerIrql (PASSIVE_LEVEL);
    }

    //
    // Fill in the system wide cookie if its zero
    //
    while (1) {
        ULONG Cookie;
        LARGE_INTEGER Time;
        PKPRCB Prcb;

        Cookie = SharedUserData->Cookie;
        if (Cookie != 0) {
            return;
        } else {
            KeQuerySystemTime (&Time);
            Prcb = KeGetCurrentPrcb ();
            Cookie = Time.LowPart ^ Time.HighPart ^ Prcb->InterruptTime ^ Prcb->MmPageFaultCount ^ (ULONG)(ULONG_PTR)&Time;
            InterlockedCompareExchange ((PLONG)&SharedUserData->Cookie, Cookie, 0);
        }
    }

}



ULONG
PspUnhandledExceptionInSystemThread(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
{
    KdPrint(("PS: Unhandled Kernel Mode Exception Pointers = 0x%p\n", ExceptionPointers));
    KdPrint(("Code %x Addr %p Info0 %p Info1 %p Info2 %p Info3 %p\n",
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress,
        ExceptionPointers->ExceptionRecord->ExceptionInformation[0],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[1],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[2],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[3]
        ));

    KeBugCheckEx(
        SYSTEM_THREAD_EXCEPTION_NOT_HANDLED,
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord,
        (ULONG_PTR)ExceptionPointers->ContextRecord);

//    return EXCEPTION_EXECUTE_HANDLER;
}

// PspUnhandledExceptionInSystemThread doesn't return, and the compiler
// sometimes gives 'unreachable code' warnings as a result.
#pragma warning(push)
#pragma warning(disable:4702)

VOID
PspSystemThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is called by the kernel to start a system thread.

Arguments:

    StartRoutine - Supplies the address of the system threads entry point.

    StartContext - Supplies a context value for the system thread.

Return Value:

    None.

--*/

{
    PETHREAD Thread;

    KeLowerIrql(0);

    Thread = PsGetCurrentThread ();

    try {
        if ((Thread->CrossThreadFlags&(PS_CROSS_THREAD_FLAGS_TERMINATED|PS_CROSS_THREAD_FLAGS_DEADTHREAD)) == 0) {
            (StartRoutine)(StartContext);
        }
    } except (PspUnhandledExceptionInSystemThread(GetExceptionInformation())) {
        KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);
    }
    PspTerminateThreadByPointer (Thread, STATUS_SUCCESS, TRUE);
}

#pragma warning(pop)



HANDLE
PsGetCurrentProcessId( VOID )
{
    return PsGetCurrentThread()->Cid.UniqueProcess;
}

HANDLE
PsGetCurrentThreadId( VOID )
{
    return PsGetCurrentThread()->Cid.UniqueThread;
}

BOOLEAN
PsGetVersion(
    __out_opt PULONG MajorVersion,
    __out_opt PULONG MinorVersion,
    __out_opt PULONG BuildNumber,
    __out_opt PUNICODE_STRING CSDVersion
    )
{
    if (ARGUMENT_PRESENT(MajorVersion)) {
        *MajorVersion = NtMajorVersion;
    }

    if (ARGUMENT_PRESENT(MinorVersion)) {
        *MinorVersion = NtMinorVersion;
    }

    if (ARGUMENT_PRESENT(BuildNumber)) {
        *BuildNumber = NtBuildNumber & 0x3FFF;
    }

    if (ARGUMENT_PRESENT(CSDVersion)) {
        *CSDVersion = CmCSDVersionString;
    }
    return (BOOLEAN)((NtBuildNumber >> 28) == 0xC);
}

NTSTATUS
PsSetLoadImageNotifyRoutine(
    __in PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This function allows a device driver to get notified for
    image loads. The notify is issued for both kernel and user
    mode image loads system-wide.

Arguments:

    NotifyRoutine - Supplies the address of a routine which is called at
        image load. The routine is passed information describing the
        image being loaded.

        The callout for creation happens just after the image is loaded
        into memory but before executiona of the image.

Return Value:

    STATUS_SUCCESS if successful, and STATUS_INVALID_PARAMETER if not.

--*/

{
    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    //
    // Allocate a new callback block.
    // 
    CallBack = ExAllocateCallBack ((PEX_CALLBACK_FUNCTION) NotifyRoutine, NULL);
    if (CallBack == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < PSP_MAX_LOAD_IMAGE_NOTIFY; i++) {
        //
        // Try and swap a null entry for the new block.
        //
        if (ExCompareExchangeCallBack (&PspLoadImageNotifyRoutine[i],
                                       CallBack,
                                       NULL)) {
            InterlockedIncrement ((PLONG) &PspLoadImageNotifyRoutineCount);
            PsImageNotifyEnabled = TRUE;
            return STATUS_SUCCESS;
        }
    }
    //
    // No slots left. Free the block and return.
    //
    ExFreeCallBack (CallBack);
    return STATUS_INSUFFICIENT_RESOURCES;
}

NTSTATUS
PsRemoveLoadImageNotifyRoutine(
    __in PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    )
/*++

Routine Description:

    This function allows an installable file system to unhook from image
    load notification.

Arguments:

    NotifyRoutine - Supplies the address of the routine which was previously
                    registered with PsSetLoadImageNotifyRoutine

Return Value:

    STATUS_SUCCESS if successful, and STATUS_PROCEDURE_NOT_FOUND if not.

--*/
{
    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    for (i = 0; i < PSP_MAX_LOAD_IMAGE_NOTIFY; i++) {

        //
        // Reference the callback so we can check its routine address.
        //
        CallBack = ExReferenceCallBackBlock (&PspLoadImageNotifyRoutine[i]);

        if (CallBack != NULL) {
            //
            // See if the routine matches our target
            //
            if ((PLOAD_IMAGE_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack) == NotifyRoutine) {

                if (ExCompareExchangeCallBack (&PspLoadImageNotifyRoutine[i],
                                               NULL,
                                               CallBack)) {

                    InterlockedDecrement ((PLONG) &PspLoadImageNotifyRoutineCount);

                    ExDereferenceCallBackBlock (&PspLoadImageNotifyRoutine[i],
                                                CallBack);

                    //
                    // Wait for any active callbacks to finish and free the block.
                    //
                    ExWaitForCallBacks (CallBack);
                    
                    ExFreeCallBack (CallBack);

                    return STATUS_SUCCESS;
                }
            }
            ExDereferenceCallBackBlock (&PspLoadImageNotifyRoutine[i],
                                        CallBack);
        }
    }

    return STATUS_PROCEDURE_NOT_FOUND;
}

VOID
PsCallImageNotifyRoutines(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,                // pid into which image is being mapped
    IN PIMAGE_INFO ImageInfo
    )
/*++

Routine Description:

    This function actually calls the registered image notify functions (on behalf)
    of mapview.c and sysload.c

Arguments:

    FullImageName - The name of the image being loaded

    ProcessId - The process that the image is being loaded into (0 for driver loads)

    ImageInfo - Various flags for the image

Return Value:

    None.

--*/

{
    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;
    PLOAD_IMAGE_NOTIFY_ROUTINE Rtn;

    PAGED_CODE();

    if (PsImageNotifyEnabled) {
        for (i=0; i < PSP_MAX_LOAD_IMAGE_NOTIFY; i++) {
            CallBack = ExReferenceCallBackBlock (&PspLoadImageNotifyRoutine[i]);
            if (CallBack != NULL) {
                Rtn = (PLOAD_IMAGE_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                Rtn (FullImageName,
                     ProcessId,
                     ImageInfo);
                ExDereferenceCallBackBlock (&PspLoadImageNotifyRoutine[i], CallBack);
            }
        }
    }
}

VOID
PspImageNotifyTest(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,
    IN PIMAGE_INFO ImageInfo
    )
/*++

Routine Description:

    This function is registered as a image notify routine on checked systems to test the interface.

Arguments:

    FullImageName - The name of the image being loaded

    ProcessId - The process that the image is being loaded into (0 for driver loads)

    ImageInfo - Various flags for the image

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER (FullImageName);
    UNREFERENCED_PARAMETER (ProcessId);
    UNREFERENCED_PARAMETER (ImageInfo);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psctx.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psctx.c

Abstract:

    This procedure implements Get/Set Context Thread

--*/

#include "psp.h"

VOID
PspQueueApcSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtGetContextThread)
#pragma alloc_text(PAGE, NtSetContextThread)
#pragma alloc_text(PAGE, PsGetContextThread)
#pragma alloc_text(PAGE, PsSetContextThread)
#pragma alloc_text(PAGE, NtQueueApcThread)
#pragma alloc_text(PAGE, PspQueueApcSpecialApc)
#endif

VOID
PspQueueApcSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (NormalRoutine);
    UNREFERENCED_PARAMETER (NormalContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    ExFreePool(Apc);
}

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    __in HANDLE ThreadHandle,
    __in PPS_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcArgument1,
    __in_opt PVOID ApcArgument2,
    __in_opt PVOID ApcArgument3
    )

/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait

Arguments:

    ThreadHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    ApcRoutine - Supplies the address of the APC routine to execute when the
        APC fires.

    ApcArgument1 - Supplies the first PVOID passed to the APC

    ApcArgument2 - Supplies the second PVOID passed to the APC

    ApcArgument3 - Supplies the third PVOID passed to the APC

Return Value:

    Returns an NT Status code indicating success or failure of the API

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    KPROCESSOR_MODE Mode;
    PKAPC Apc;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_SET_CONTEXT,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);
    if (NT_SUCCESS (st)) {
        st = STATUS_SUCCESS;
        if (IS_SYSTEM_THREAD (Thread)) {
            st = STATUS_INVALID_HANDLE;
        } else {
            Apc = ExAllocatePoolWithQuotaTag (NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                              sizeof(*Apc),
                                              'pasP');

            if (Apc == NULL) {
                st = STATUS_NO_MEMORY;
            } else {
                KeInitializeApc (Apc,
                                 &Thread->Tcb,
                                 OriginalApcEnvironment,
                                 PspQueueApcSpecialApc,
                                 NULL,
                                 (PKNORMAL_ROUTINE)ApcRoutine,
                                 UserMode,
                                 ApcArgument1);

                if (!KeInsertQueueApc (Apc, ApcArgument2, ApcArgument3, 0)) {
                    ExFreePool (Apc);
                    st = STATUS_UNSUCCESSFUL;
                }
            }
        }
        ObDereferenceObject (Thread);
    }

    return st;
}


NTSTATUS
PsGetContextThread(
    __in PETHREAD Thread,
    __inout PCONTEXT ThreadContext,
    __in KPROCESSOR_MODE Mode
    )

/*++

Routine Description:

    This function returns the usermode context of the specified thread. This
    function will fail if the specified thread is a system thread. It will
    return the wrong answer if the thread is a non-system thread that does
    not execute in user-mode.

Arguments:

    Thread -       Supplies a pointer to the thread object from
                   which to retrieve context information.

    ThreadContext - Supplies the address of a buffer that will receive
                    the context of the specified thread.

    Mode          - Mode to use for validation checks.

Return Value:

    None.

--*/

{

    ULONG ContextFlags=0;
    GETSETCONTEXT ContextFrame = {0};
    ULONG ContextLength=0;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    //
    // Get previous mode and reference specified thread.
    //

    CurrentThread = PsGetCurrentThread ();

    //
    // Attempt to get the context of the specified thread.
    //

    try {

        //
        // Set the default alignment, capture the context flags,
        // and set the default size of the context record.
        //

        if (Mode != KernelMode) {
            ProbeForReadSmallStructure (ThreadContext,
                                        FIELD_OFFSET (CONTEXT, ContextFlags) + sizeof (ThreadContext->ContextFlags),
                                        CONTEXT_ALIGN);
        }

        ContextFlags = ThreadContext->ContextFlags;

        //
        // We don't need to re-probe here so long as the structure is smaller
        // than the guard region
        //
        ContextLength = sizeof(CONTEXT);
        ASSERT (ContextLength < 0x10000);

#if defined(_X86_)
        //
        // CONTEXT_EXTENDED_REGISTERS is SET, then we want sizeof(CONTEXT) set above
        // otherwise (not set) we only want the old part of the context record.
        //
        if ((ContextFlags & CONTEXT_EXTENDED_REGISTERS) != CONTEXT_EXTENDED_REGISTERS) {
            ContextLength = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
        }
#endif

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    KeInitializeEvent (&ContextFrame.OperationComplete,
                       NotificationEvent,
                       FALSE);

    ContextFrame.Context.ContextFlags = ContextFlags;

    ContextFrame.Mode = Mode;
    if (Thread == CurrentThread) {
        ContextFrame.Apc.SystemArgument1 = NULL;
        ContextFrame.Apc.SystemArgument2 = Thread;
        KeEnterGuardedRegionThread (&CurrentThread->Tcb);
        PspGetSetContextSpecialApc (&ContextFrame.Apc,
                                    NULL,
                                    NULL,
                                    &ContextFrame.Apc.SystemArgument1,
                                    &ContextFrame.Apc.SystemArgument2);

        KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

        //
        // Move context to specfied context record. If an exception
        // occurs, then return the error.
        //

        try {
            RtlCopyMemory (ThreadContext,
                           &ContextFrame.Context,
                           ContextLength);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode ();
        }

    } else {
        KeInitializeApc (&ContextFrame.Apc,
                         &Thread->Tcb,
                         OriginalApcEnvironment,
                         PspGetSetContextSpecialApc,
                         NULL,
                         NULL,
                         KernelMode,
                         NULL);

        if (!KeInsertQueueApc (&ContextFrame.Apc, NULL, Thread, 2)) {
            Status = STATUS_UNSUCCESSFUL;

        } else {
            KeWaitForSingleObject (&ContextFrame.OperationComplete,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
            //
            // Move context to specfied context record. If an
            // exception occurs, then silently handle it and
            // return success.
            //

            try {
                RtlCopyMemory (ThreadContext,
                               &ContextFrame.Context,
                               ContextLength);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode ();
            }
        }
    }

    return Status;
}

NTSTATUS
NtGetContextThread(
    __in HANDLE ThreadHandle,
    __inout PCONTEXT ThreadContext
    )

/*++

Routine Description:

    This function returns the usermode context of the specified thread. This
    function will fail if the specified thread is a system thread. It will
    return the wrong answer if the thread is a non-system thread that does
    not execute in user-mode.

Arguments:

    ThreadHandle - Supplies an open handle to the thread object from
                   which to retrieve context information.  The handle
                   must allow THREAD_GET_CONTEXT access to the thread.

    ThreadContext - Supplies the address of a buffer that will receive
                    the context of the specified thread.

Return Value:

    None.

--*/

{

    KPROCESSOR_MODE Mode;
    NTSTATUS Status;
    PETHREAD Thread;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get previous mode and reference specified thread.
    //

    CurrentThread = PsGetCurrentThread ();
    Mode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_GET_CONTEXT,
                                        PsThreadType,
                                        Mode,
                                        &Thread,
                                        NULL);

    //
    // If the reference was successful, the check if the specified thread
    // is a system thread.
    //

    if (NT_SUCCESS (Status)) {

        //
        // If the thread is not a system thread, then attempt to get the
        // context of the thread.
        //

        if (IS_SYSTEM_THREAD (Thread) == FALSE) {

            Status = PsGetContextThread (Thread, ThreadContext, Mode);

        } else {
            Status = STATUS_INVALID_HANDLE;
        }

        ObDereferenceObject (Thread);
    }

    return Status;
}


NTSTATUS
PsSetContextThread(
    __in PETHREAD Thread,
    __in PCONTEXT ThreadContext,
    __in KPROCESSOR_MODE Mode
    )

/*++

Routine Description:

    This function sets the usermode context of the specified thread. This
    function will fail if the specified thread is a system thread. It will
    return the wrong answer if the thread is a non-system thread that does
    not execute in user-mode.

Arguments:

    Thread       - Supplies the thread object from
                   which to retrieve context information.

    ThreadContext - Supplies the address of a buffer that contains new
                    context for the specified thread.

    Mode          - Mode to use for validation checks.

Return Value:

    None.

--*/

{
    ULONG ContextFlags=0;
    GETSETCONTEXT ContextFrame;
    ULONG ContextLength=0;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    //
    // Get previous mode and reference specified thread.
    //

    CurrentThread = PsGetCurrentThread ();

    //
    // Attempt to get the context of the specified thread.
    //

    try {

        //
        // Capture the context flags,
        // and set the default size of the context record.
        //

        if (Mode != KernelMode) {
            ProbeForReadSmallStructure (ThreadContext,
                                        FIELD_OFFSET (CONTEXT, ContextFlags) + sizeof (ThreadContext->ContextFlags),
                                        CONTEXT_ALIGN);
        }

        //
        // We don't need to re-probe here so long as the structure is small
        // enough not to cross the guard region.
        //
        ContextFlags = ThreadContext->ContextFlags;
        ContextLength = sizeof (CONTEXT);
        ASSERT (ContextLength < 0x10000);

#if defined(_X86_)
        //
        // CONTEXT_EXTENDED_REGISTERS is SET, then we want sizeof(CONTEXT) set above
        // otherwise (not set) we only want the old part of the context record.
        //
        if ((ContextFlags & CONTEXT_EXTENDED_REGISTERS) != CONTEXT_EXTENDED_REGISTERS) {
            ContextLength = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
        } 
#endif

        RtlCopyMemory (&ContextFrame.Context, ThreadContext, ContextLength);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode ();
    }

    //
    // set the context of the target thread.
    //

    KeInitializeEvent (&ContextFrame.OperationComplete,
                       NotificationEvent,
                       FALSE);

    ContextFrame.Context.ContextFlags = ContextFlags;

    ContextFrame.Mode = Mode;
    if (Thread == CurrentThread) {
        ContextFrame.Apc.SystemArgument1 = (PVOID)1;
        ContextFrame.Apc.SystemArgument2 = Thread;
        KeEnterGuardedRegionThread (&CurrentThread->Tcb);
        PspGetSetContextSpecialApc (&ContextFrame.Apc,
                                    NULL,
                                    NULL,
                                    &ContextFrame.Apc.SystemArgument1,
                                    &ContextFrame.Apc.SystemArgument2);

        KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

    } else {
        KeInitializeApc (&ContextFrame.Apc,
                         &Thread->Tcb,
                         OriginalApcEnvironment,
                         PspGetSetContextSpecialApc,
                         NULL,
                         NULL,
                         KernelMode,
                         NULL);

        if (!KeInsertQueueApc (&ContextFrame.Apc, (PVOID)1, Thread, 2)) {
            Status = STATUS_UNSUCCESSFUL;

        } else {
            KeWaitForSingleObject (&ContextFrame.OperationComplete,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
        }
    }

    return Status;
}


NTSTATUS
NtSetContextThread(
    __in HANDLE ThreadHandle,
    __in PCONTEXT ThreadContext
    )
    
/*++

Routine Description:

    This function sets the usermode context of the specified thread. This
    function will fail if the specified thread is a system thread. It will
    return the wrong answer if the thread is a non-system thread that does
    not execute in user-mode.

Arguments:

    ThreadHandle - Supplies an open handle to the thread object from
                   which to retrieve context information.  The handle
                   must allow THREAD_SET_CONTEXT access to the thread.

    ThreadContext - Supplies the address of a buffer that contains new
                    context for the specified thread.

Return Value:

    None.

--*/

{
    KPROCESSOR_MODE Mode;
    NTSTATUS Status;
    PETHREAD Thread;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get previous mode and reference specified thread.
    //

    CurrentThread = PsGetCurrentThread ();
    Mode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_CONTEXT,
                                        PsThreadType,
                                        Mode,
                                        &Thread,
                                        NULL);

    //
    // If the reference was successful, the check if the specified thread
    // is a system thread.
    //

    if (NT_SUCCESS (Status)) {

        //
        // If the thread is not a system thread, then attempt to get the
        // context of the thread.
        //

        if (IS_SYSTEM_THREAD (Thread) == FALSE) {

            Status = PsSetContextThread (Thread, ThreadContext, Mode);

        } else {
            Status = STATUS_INVALID_HANDLE;
        }

        ObDereferenceObject (Thread);
    }

    return Status;
}

NTSTATUS
PsWrapApcWow64Thread (
    __inout PVOID *ApcContext,
    __inout PVOID *ApcRoutine)

/*++

Routine Description:

    This routine is used by kernel mode callers to queue APCs to a 32-bit thread
    running inside a Wow64 process. It wraps the original APC routine
    with a wrapper routine inside Wow64. The target Apc routine must be
    inside 32-bit code. This routine must be executed in the context of the
    Wow64 thread where the target APC is going to run in. The resulting ApcContext
    and ApcRoutine from this routine are used when initializing, using KeInitializeApc,
    to be queued later to a Wow64 thread.
    
    The API does nothing and succeeds on :
        - 32-bit systems.
        - native 64-bit processes on 64-bit systems.

Environment:

    Kernel mode only.

Arguments:

    ApcContext - Pointer to the original ApcContext parameter.

    ApcRoutine - Pointer to the original ApcRoutine that is targeted to run
        32-bit code.

Return:

    NTSTATUS.

--*/

{

    NTSTATUS NtStatus;

    NtStatus = STATUS_SUCCESS;

#if defined(_WIN64)
    
    if (PsGetCurrentProcess ()->Wow64Process != NULL) {
        
        try {
            Wow64KiWrapApcProc (ApcContext, ApcRoutine);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }
    }

#else

    UNREFERENCED_PARAMETER(ApcContext);
    UNREFERENCED_PARAMETER(ApcRoutine);

#endif

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psenum.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psenum.c

Abstract:

    This module enumerates the actve processes in the system

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PsEnumProcesses)
#pragma alloc_text(PAGE, PsGetNextProcess)
#pragma alloc_text(PAGE, PsQuitNextProcess)
#pragma alloc_text(PAGE, PsEnumProcessThreads)
#pragma alloc_text(PAGE, PsGetNextProcessThread)
#pragma alloc_text(PAGE, PsQuitNextProcessThread)
#pragma alloc_text(PAGE, PsGetNextJob)
#pragma alloc_text(PAGE, PsGetNextJobProcess)
#pragma alloc_text(PAGE, PsQuitNextJob)
#pragma alloc_text(PAGE, PsQuitNextJobProcess)
#pragma alloc_text(PAGE, PspGetNextJobProcess)
#pragma alloc_text(PAGE, PspQuitNextJobProcess)
#pragma alloc_text(PAGE, NtGetNextProcess)
#pragma alloc_text(PAGE, NtGetNextThread)
#endif

NTSTATUS
PsEnumProcesses (
    IN PROCESS_ENUM_ROUTINE CallBack,
    IN PVOID Context
    )
/*++

Routine Description:

    This function calls the callback routine for each active process in the system.
    Process objects in the process of being deleted are skipped.
    Returning anything but a success code from the callback routine terminates the enumeration at that point.
    Processes may be referenced and used later safely.

Arguments:

    CallBack - Routine to be called with its first parameter the enumerated process

Return Value:

    NTSTATUS - Status of call

--*/
{
    PLIST_ENTRY ListEntry;
    PEPROCESS Process, NewProcess;
    PETHREAD CurrentThread;
    NTSTATUS Status;

    Process = NULL;

    CurrentThread = PsGetCurrentThread ();

    PspLockProcessList (CurrentThread);

    for (ListEntry = PsActiveProcessHead.Flink;
         ListEntry != &PsActiveProcessHead;
         ListEntry = ListEntry->Flink) {

        NewProcess = CONTAINING_RECORD (ListEntry, EPROCESS, ActiveProcessLinks);
        if (ObReferenceObjectSafe (NewProcess)) {

            PspUnlockProcessList (CurrentThread);

            if (Process != NULL) {
                ObDereferenceObject (Process);
            }

            Process = NewProcess;

            Status = CallBack (Process, Context);

            if (!NT_SUCCESS (Status)) {
                ObDereferenceObject (Process);
                return Status;
            }

            PspLockProcessList (CurrentThread);

        }
    }

    PspUnlockProcessList (CurrentThread);

    if (Process != NULL) {
        ObDereferenceObject (Process);
    }

    return STATUS_SUCCESS;
}

PEPROCESS
PsGetNextProcess (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function allows code to enumerate all the active processes in the system.
    The first process (if Process is NULL) or subsequent process (if process not NULL) is returned on
    each call.
    If process is not NULL then this process must have previously been obtained by a call to PsGetNextProcess.
    Enumeration may be terminated early by calling PsQuitNextProcess on the last non-NULL process
    returned by PsGetNextProcess.

    Processes may be referenced and used later safely.

    For example, to enumerate all system processes in a loop use this code fragment:

    for (Process = PsGetNextProcess (NULL);
         Process != NULL;
         Process = PsGetNextProcess (Process)) {
         ...
         ...
         //
         // Early terminating conditions are handled like this:
         //
         if (NeedToBreakOutEarly) {
             PsQuitNextProcess (Process);
             break;
         }
    }
    

Arguments:

    Process - Process to get the next process from or NULL for the first process

Return Value:

    PEPROCESS - Next process or NULL if no more processes available

--*/
{
    PEPROCESS NewProcess = NULL;
    PETHREAD CurrentThread;
    PLIST_ENTRY ListEntry;

    CurrentThread = PsGetCurrentThread ();

    PspLockProcessList (CurrentThread);

    for (ListEntry = (Process == NULL) ? PsActiveProcessHead.Flink : Process->ActiveProcessLinks.Flink;
         ListEntry != &PsActiveProcessHead;
         ListEntry = ListEntry->Flink) {

        NewProcess = CONTAINING_RECORD (ListEntry, EPROCESS, ActiveProcessLinks);

        //
        // Processes are removed from this list during process objected deletion (object reference count goes
        // to zero). To prevent double deletion of the process we need to do a safe reference here.
        //
        if (ObReferenceObjectSafe (NewProcess)) {
            break;
        }
        NewProcess = NULL;
    }
    PspUnlockProcessList (CurrentThread);

    if (Process != NULL) {
        ObDereferenceObject (Process);
    }

    return NewProcess;
}


VOID
PsQuitNextProcess (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function is used to terminate early a process enumeration using PsGetNextProcess

Arguments:

    Process - Non-NULL process previously obtained by a call to PsGetNextProcess.

Return Value:

    None

--*/
{
    ObDereferenceObject (Process);
}

PETHREAD
PsGetNextProcessThread (
    IN PEPROCESS Process,
    IN PETHREAD Thread
    )
/*++

Routine Description:

    This function is used to enumerate the threads in a process.


Arguments:

    Process - Process to enumerate
    Thread  - Thread to start enumeration from. This must have been obtained from previous call to
              PsGetNextProcessThread. If NULL enumeration starts at the first non-terminating thread in the process.

Return Value:

    PETHREAD - Pointer to a non-terminated process thread or a NULL if there are non. This thread must be passed
               either to another call to PsGetNextProcessThread or PsQuitNextProcessThread.

--*/
{
    PLIST_ENTRY ListEntry;
    PETHREAD NewThread, CurrentThread;

    PAGED_CODE ();
 
    CurrentThread = PsGetCurrentThread ();

    PspLockProcessShared (Process, CurrentThread);

    for (ListEntry = (Thread == NULL) ? Process->ThreadListHead.Flink : Thread->ThreadListEntry.Flink;
         ;
         ListEntry = ListEntry->Flink) {
        if (ListEntry != &Process->ThreadListHead) {
            NewThread = CONTAINING_RECORD (ListEntry, ETHREAD, ThreadListEntry);
            //
            // Don't reference a thread thats in its delete routine
            //
            if (ObReferenceObjectSafe (NewThread)) {
                break;
            }
        } else {
            NewThread = NULL;
            break;
        }
    }
    PspUnlockProcessShared (Process, CurrentThread);

    if (Thread != NULL) {
        ObDereferenceObject (Thread);
    }
    return NewThread;
}

VOID
PsQuitNextProcessThread (
    IN PETHREAD Thread
    )
/*++

Routine Description:

    This function quits thread enumeration early.

Arguments:

    Thread - Thread obtained from a call to PsGetNextProcessThread

Return Value:

    None.

--*/
{
    ObDereferenceObject (Thread);
}

NTSTATUS
PsEnumProcessThreads (
    IN PEPROCESS Process,
    IN THREAD_ENUM_ROUTINE CallBack,
    IN PVOID Context
    )
/*++

Routine Description:

    This function calls the callback routine for each active thread in the process.
    Thread objects in the process of being deleted are skipped.
    Returning anything but a success code from the callback routine terminates the enumeration at that point.
    Thread may be referenced and used later safely.

Arguments:

    CallBack - Routine to be called with its first parameter the enumerated process

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = STATUS_SUCCESS;
    for (Thread = PsGetNextProcessThread (Process, NULL);
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {
        Status = CallBack (Process, Thread, Context);
        if (!NT_SUCCESS (Status)) {
            PsQuitNextProcessThread (Thread);
            break;
        }
    }
    return Status;
}

PEJOB
PsGetNextJob (
    IN PEJOB Job
    )
/*++

Routine Description:

    This function allows code to enumerate all the active jobs in the system.
    The first job (if Job is NULL) or subsequent jobs (if Job not NULL) is returned on
    each call.
    If Job is not NULL then this job must have previously been obtained by a call to PsGetNextJob.
    Enumeration may be terminated early by calling PsQuitNextJob on the last non-NULL job
    returned by PsGetNextJob.

    Jobs may be referenced and used later safely.

    For example, to enumerate all system jobs in a loop use this code fragment:

    for (Job = PsGetNextJob (NULL);
         Job != NULL;
         Job = PsGetNextJob (Job)) {
         ...
         ...
         //
         // Early terminating conditions are handled like this:
         //
         if (NeedToBreakOutEarly) {
             PsQuitNextJob (Job);
             break;
         }
    }
    

Arguments:

    Job - Job from a previous call to PsGetNextJob or NULL for the first job in the system

Return Value:

    PEJOB - Next job in the system or NULL if none available.

--*/
{
    PEJOB NewJob = NULL;
    PLIST_ENTRY ListEntry;
    PETHREAD CurrentThread;

    CurrentThread = PsGetCurrentThread ();

    PspLockJobListShared (CurrentThread);

    for (ListEntry = (Job == NULL) ? PspJobList.Flink : Job->JobLinks.Flink;
         ListEntry != &PspJobList;
         ListEntry = ListEntry->Flink) {

        NewJob = CONTAINING_RECORD (ListEntry, EJOB, JobLinks);

        //
        // Jobs are removed from this list during job objected deletion (object reference count goes
        // to zero). To prevent double deletion of the job we need to do a safe reference here.
        //
        if (ObReferenceObjectSafe (NewJob)) {
            break;
        }
        NewJob = NULL;
    }

    PspUnlockJobListShared (CurrentThread);

    if (Job != NULL) {
        ObDereferenceObject (Job);
    }

    return NewJob;
}


VOID
PsQuitNextJob (
    IN PEJOB Job
    )
/*++

Routine Description:

    This function is used to terminate early a job enumeration using PsGetNextJob

Arguments:

    Job - Non-NULL job previously obtained by a call to PsGetNextJob.

Return Value:

    None

--*/
{
    ObDereferenceObject (Job);
}

PEPROCESS
PsGetNextJobProcess (
    IN PEJOB Job,
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function is used to enumerate the processes in a job.


Arguments:

    Job     - Job to Enumerate
    Process - Process to start enumeration from. This must have been obtained from previous call to
              PsGetNextJobProcess. If NULL enumeration starts at the first non-terminating process in the Job.

Return Value:

    PEPROCESS - Pointer to a non-terminated process or a NULL if there are non. This process must be passed
                either to another call to PsGetNextJobProcess or PsQuitNextJobProcess.

--*/
{
    PLIST_ENTRY ListEntry;
    PEPROCESS NewProcess;
    PETHREAD CurrentThread;

    PAGED_CODE ();
 
    CurrentThread = PsGetCurrentThread ();

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

    for (ListEntry = (Process == NULL) ? Job->ProcessListHead.Flink : Process->JobLinks.Flink;
         ;
         ListEntry = ListEntry->Flink) {
        if (ListEntry != &Job->ProcessListHead) {
            NewProcess = CONTAINING_RECORD (ListEntry, EPROCESS, JobLinks);
            //
            // Don't reference a process thats in its delete routine
            //
            if (ObReferenceObjectSafe (NewProcess)) {
                break;
            }
        } else {
            NewProcess = NULL;
            break;
        }
    }

    ExReleaseResourceLite (&Job->JobLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);


    if (Process != NULL) {
        ObDereferenceObject (Process);
    }
    return NewProcess;
}

VOID
PsQuitNextJobProcess (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function quits job process enumeration early.

Arguments:

    Process - Process obtained from a call to PsGetNextJobProcess

Return Value:

    None.

--*/
{
    ObDereferenceObject (Process);
}

PEPROCESS
PspGetNextJobProcess (
    IN PEJOB Job,
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function is used to enumerate the processes in a job with the job lock held.


Arguments:

    Job     - Job to Enumerate
    Process - Process to start enumeration from. This must have been obtained from previous call to
              PsGetNextJobProcess. If NULL enumeration starts at the first non-terminating process in the Job.

Return Value:

    PEPROCESS - Pointer to a non-terminated process or a NULL if there are non. This process must be passed
                either to another call to PsGetNextJobProcess or PsQuitNextJobProcess.

--*/
{
    PLIST_ENTRY ListEntry;
    PEPROCESS NewProcess;

    PAGED_CODE ();
 
    for (ListEntry = (Process == NULL) ? Job->ProcessListHead.Flink : Process->JobLinks.Flink;
         ;
         ListEntry = ListEntry->Flink) {
        if (ListEntry != &Job->ProcessListHead) {
            NewProcess = CONTAINING_RECORD (ListEntry, EPROCESS, JobLinks);
            //
            // Don't reference a process thats in its delete routine
            //
            if (ObReferenceObjectSafe (NewProcess)) {
                break;
            }
        } else {
            NewProcess = NULL;
            break;
        }
    }

    if (Process != NULL) {
        ObDereferenceObjectDeferDelete (Process);
    }
    return NewProcess;
}

VOID
PspQuitNextJobProcess (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function quits job process enumeration early.

Arguments:

    Process - Process obtained from a call to PsGetNextJobProcess

Return Value:

    None.

--*/
{
    ObDereferenceObjectDeferDelete (Process);
}

NTSTATUS
NtGetNextProcess (
    __in HANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in ULONG HandleAttributes,
    __in ULONG Flags,
    __out PHANDLE NewProcessHandle
    )
/*++

Routine Description:

    This function gets the next for first process in the list of all processes in the system

Arguments:

    ProcessHandle - Process obtained from a previous call to NtGetNextProcess or NULL for the first process
    DesiredAccess - Access requested for process handle
    HandleAttributes - Handle attributes requested.
    Flags - Flags for the operation
    NewProcessHandle - Pointer to a handle value that is returned on success

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    KPROCESSOR_MODE PreviousMode;
    PEPROCESS Process, NewProcess;
    NTSTATUS Status;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    HANDLE Handle;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode ();

    //
    // Sanitize handle attributes
    //
    HandleAttributes = ObSanitizeHandleAttributes (HandleAttributes, PreviousMode);

    //
    // Validate pointer arguments
    //

    try {
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (NewProcessHandle);
        }
        *NewProcessHandle = NULL;
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    //
    // Check for inclusion of reserved flags and reject the call if present
    //

    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if (ProcessHandle == NULL) {
        Process = NULL;
    } else {
        Status = ObReferenceObjectByHandle (ProcessHandle,
                                            0,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    }

    NewProcess = PsGetNextProcess (Process);

    if (NewProcess == NULL) {
        return STATUS_NO_MORE_ENTRIES;
    }

    Status = SeCreateAccessState (&AccessState,
                                  &AuxData,
                                  DesiredAccess,
                                  &PsProcessType->TypeInfo.GenericMapping);

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (NewProcess);
        return Status;
    }

    if (SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
        if (AccessState.RemainingDesiredAccess & MAXIMUM_ALLOWED) {
            AccessState.PreviouslyGrantedAccess |= PROCESS_ALL_ACCESS;
        } else {
            AccessState.PreviouslyGrantedAccess |= AccessState.RemainingDesiredAccess;
        }
        AccessState.RemainingDesiredAccess = 0;
    }


    while (1) {
        if (NewProcess->GrantedAccess != 0) {

            Status = ObOpenObjectByPointer (NewProcess,
                                            HandleAttributes,
                                            &AccessState,
                                            0,
                                            PsProcessType,
                                            PreviousMode,
                                            &Handle);
            if (NT_SUCCESS (Status)) {
                try {
                    *NewProcessHandle = Handle;
                } except (ExSystemExceptionFilter ()) {
                    Status = GetExceptionCode ();
                }
                break;
            }

            if (Status != STATUS_ACCESS_DENIED) {
                break;
            }
        }

        NewProcess = PsGetNextProcess (NewProcess);

        if (NewProcess == NULL) {
            Status = STATUS_NO_MORE_ENTRIES;
            break;
        }
    }

    SeDeleteAccessState (&AccessState);

    if (NewProcess != NULL) {
        ObDereferenceObject (NewProcess);
    }

    return Status;
}

NTSTATUS
NtGetNextThread (
    __in HANDLE ProcessHandle,
    __in HANDLE ThreadHandle,
    __in ACCESS_MASK DesiredAccess,
    __in ULONG HandleAttributes,
    __in ULONG Flags,
    __out PHANDLE NewThreadHandle
    )
/*++

Routine Description:

    This function gets the next for first thread in a process

Arguments:

    ProcessHandle - Process that is being enumerated
    ThreadHandle - Last thread returned by the enumeration routine or NULL if the first is required
    DesiredAccess - Access requested for thread handle
    HandleAttributes - Handle attributes requested.
    Flags - Flags for the operation
    NewThreadHandle - Pointer to a handle value that is returned on success

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    KPROCESSOR_MODE PreviousMode;
    PEPROCESS Process;
    PETHREAD Thread, NewThread;
    NTSTATUS Status;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    HANDLE Handle;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode ();

    //
    // Sanitize handle attributes
    //

    HandleAttributes = ObSanitizeHandleAttributes (HandleAttributes, PreviousMode);

    //
    // Validate pointer arguments
    //

    try {
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (NewThreadHandle);
        }
        *NewThreadHandle = NULL;
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    //
    // Check for inclusion of reserved flags and reject the call if present
    //

    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    if (ThreadHandle == NULL) {
        Thread = NULL;
    } else {
        Status = ObReferenceObjectByHandle (ThreadHandle,
                                            0,
                                            PsProcessType,
                                            PreviousMode,
                                            &Thread,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            ObDereferenceObject (Process);
            return Status;
        }

        //
        // Make sure 
        //

        if (THREAD_TO_PROCESS (Thread) != Process) {
            ObDereferenceObject (Thread);
            ObDereferenceObject (Process);
            return STATUS_INVALID_PARAMETER;
        }
    }

    NewThread = PsGetNextProcessThread (Process, Thread);


    if (NewThread == NULL) {
        ObDereferenceObject (Process);
        return STATUS_NO_MORE_ENTRIES;
    }

    Status = SeCreateAccessState (&AccessState,
                                  &AuxData,
                                  DesiredAccess,
                                  &PsProcessType->TypeInfo.GenericMapping);

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (Process);
        ObDereferenceObject (NewThread);
        return Status;
    }

    if (SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
        if (AccessState.RemainingDesiredAccess & MAXIMUM_ALLOWED) {
            AccessState.PreviouslyGrantedAccess |= PROCESS_ALL_ACCESS;
        } else {
            AccessState.PreviouslyGrantedAccess |= AccessState.RemainingDesiredAccess;
        }
        AccessState.RemainingDesiredAccess = 0;
    }


    while (1) {

        if (NewThread->GrantedAccess != 0) {
            Status = ObOpenObjectByPointer (NewThread,
                                            HandleAttributes,
                                            &AccessState,
                                            0,
                                            PsThreadType,
                                            PreviousMode,
                                            &Handle);
            if (NT_SUCCESS (Status)) {
                try {
                    *NewThreadHandle = Handle;
                } except (ExSystemExceptionFilter ()) {
                    Status = GetExceptionCode ();
                }
                break;
            }

            if (Status != STATUS_ACCESS_DENIED) {
                break;
            }
        }

        NewThread = PsGetNextProcessThread (Process, NewThread);

        if (NewThread == NULL) {
            Status = STATUS_NO_MORE_ENTRIES;
            break;
        }
    }

    SeDeleteAccessState (&AccessState);

    ObDereferenceObject (Process);
    if (NewThread != NULL) {
        ObDereferenceObject (NewThread);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\pshelper.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pshelper.c

Abstract:

    EPROCESS and ETHREAD field access for NTOS-external components

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, PsIsProcessBeingDebugged)
#pragma alloc_text (PAGE, PsIsThreadImpersonating)
#pragma alloc_text (PAGE, PsReferenceProcessFilePointer)
#pragma alloc_text (PAGE, PsSetProcessWin32Process)
#pragma alloc_text (PAGE, PsSetProcessSecurityPort)
#pragma alloc_text (PAGE, PsSetJobUIRestrictionsClass)
#pragma alloc_text (PAGE, PsSetProcessWindowStation)
#pragma alloc_text (PAGE, PsGetProcessSecurityPort)
#pragma alloc_text (PAGE, PsSetThreadWin32Thread)
#pragma alloc_text (PAGE, PsGetProcessExitProcessCalled)
#pragma alloc_text (PAGE, PsGetThreadSessionId)
#pragma alloc_text (PAGE, PsSetProcessPriorityClass)
#pragma alloc_text (PAGE, PsIsSystemProcess)
#endif

/*++
--*/
#undef PsGetCurrentProcess
PEPROCESS
PsGetCurrentProcess(
    VOID
    )
{
    return _PsGetCurrentProcess();
}

ULONG PsGetCurrentProcessSessionId(
    VOID
    )
{
    return MmGetSessionId (_PsGetCurrentProcess());
}

#undef PsGetCurrentThread
PETHREAD
PsGetCurrentThread(
    VOID
    )
{
    return _PsGetCurrentThread();
}

PVOID
PsGetCurrentThreadStackBase(
    VOID
    )
{
    return KeGetCurrentThread()->StackBase;
}

PVOID
PsGetCurrentThreadStackLimit(
    VOID
    )
{
    return KeGetCurrentThread()->StackLimit;
}

CCHAR
PsGetCurrentThreadPreviousMode(
    VOID
    )
{
    return KeGetPreviousMode();
}

PERESOURCE
PsGetJobLock(
    __in PEJOB Job
    )
{
    return &Job->JobLock;
}

ULONG
PsGetJobSessionId(
    __in PEJOB Job
    )
{
    return Job->SessionId;
}

ULONG
PsGetJobUIRestrictionsClass(
    __in PEJOB Job
    )
{
    return Job->UIRestrictionsClass;
}

LONGLONG
PsGetProcessCreateTimeQuadPart(
    __in PEPROCESS Process
    )
{
    return Process->CreateTime.QuadPart;
}

PVOID
PsGetProcessDebugPort(
    __in PEPROCESS Process
    )
{
    return Process->DebugPort;
}


BOOLEAN
PsIsProcessBeingDebugged(
    __in PEPROCESS Process
    )
{
    if (Process->DebugPort != NULL) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
PsGetProcessExitProcessCalled(
    __in PEPROCESS Process
    )
{
    return (BOOLEAN) ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) != 0);
}

NTSTATUS
PsGetProcessExitStatus(
    __in PEPROCESS Process
    )
{
    return Process->ExitStatus;
}

HANDLE
PsGetProcessId(
    __in PEPROCESS Process
    )
{
    return Process->UniqueProcessId;
}


UCHAR *
PsGetProcessImageFileName(
    __in PEPROCESS Process
    )
{
    return Process->ImageFileName;
}


HANDLE
PsGetProcessInheritedFromUniqueProcessId(
    __in PEPROCESS Process
    )
{
    return Process->InheritedFromUniqueProcessId;
}


PEJOB
PsGetProcessJob(
    __in PEPROCESS Process
    )
{
    return Process->Job;
}


ULONG
PsGetProcessSessionId(
    __in PEPROCESS Process
    )
{
    return MmGetSessionId (Process);
}


ULONG
PsGetProcessSessionIdEx(
    __in PEPROCESS Process
    )
{
    return MmGetSessionIdEx (Process);
}


PVOID
PsGetProcessSectionBaseAddress(
    __in PEPROCESS Process
    )
{
    return Process->SectionBaseAddress;
}


PPEB
PsGetProcessPeb(
    __in PEPROCESS Process
    )
{
    return Process->Peb;
}


UCHAR
PsGetProcessPriorityClass(
    __in PEPROCESS Process
    )
{
    return Process->PriorityClass;
}

HANDLE
PsGetProcessWin32WindowStation(
    __in PEPROCESS Process
    )
{
    return Process->Win32WindowStation;
}



PVOID
PsGetProcessWin32Process(
    __in PEPROCESS Process
    )
{
    return Process->Win32Process;
}


PVOID
PsGetCurrentProcessWin32Process(
    VOID
    )
{
    return PsGetCurrentProcess()->Win32Process;
}


PVOID
PsGetProcessWow64Process(
    __in PEPROCESS Process
    )
{
    return PS_GET_WOW64_PROCESS (Process);
}


PVOID
PsGetCurrentProcessWow64Process(
    VOID
    )
{
    return PS_GET_WOW64_PROCESS (PsGetCurrentProcess());
}


HANDLE
PsGetThreadId(
    __in PETHREAD Thread
     )
{
    return Thread->Cid.UniqueThread;
}


CCHAR
PsGetThreadFreezeCount(
    __in PETHREAD Thread
    )
{
    return Thread->Tcb.FreezeCount;
}


BOOLEAN
PsGetThreadHardErrorsAreDisabled(
    __in PETHREAD Thread)
{
    return (BOOLEAN) (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0;
}


PEPROCESS
PsGetThreadProcess(
    __in PETHREAD Thread
    )
{
    return THREAD_TO_PROCESS(Thread);
}


PEPROCESS
PsGetCurrentThreadProcess(
    VOID
    )
{
    return THREAD_TO_PROCESS(_PsGetCurrentThread());
}



HANDLE
PsGetThreadProcessId(
    __in PETHREAD Thread
     )
{
    return Thread->Cid.UniqueProcess;
}


HANDLE
PsGetCurrentThreadProcessId(
    VOID
    )
{
    return _PsGetCurrentThread()->Cid.UniqueProcess;
}


ULONG
PsGetThreadSessionId(
    __in PETHREAD Thread
    )
{
    return MmGetSessionId (THREAD_TO_PROCESS(Thread));
}


PVOID
PsGetThreadTeb(
    __in PETHREAD Thread
    )
{
    return Thread->Tcb.Teb;
}


PVOID
PsGetCurrentThreadTeb(
    VOID
    )
{
    return _PsGetCurrentThread()->Tcb.Teb;
}


PVOID
PsGetThreadWin32Thread(
    __in PETHREAD Thread
     )
{
    return Thread->Tcb.Win32Thread;
}


PVOID
PsGetCurrentThreadWin32Thread(
    VOID
     )
{
    return _PsGetCurrentThread()->Tcb.Win32Thread;
}


PVOID
PsGetCurrentThreadWin32ThreadAndEnterCriticalRegion(
    __out PHANDLE ProcessId
     )
{
    PETHREAD Thread = _PsGetCurrentThread();
    *ProcessId = Thread->Cid.UniqueProcess;
    KeEnterCriticalRegionThread(&Thread->Tcb);
    return Thread->Tcb.Win32Thread;
}


BOOLEAN
PsIsSystemThread(
    __in PETHREAD Thread
     )
{
    return (BOOLEAN)(IS_SYSTEM_THREAD(Thread));
}


BOOLEAN
PsIsSystemProcess(
    __in PEPROCESS Process
     )
{
    return (BOOLEAN)(Process == PsInitialSystemProcess);
}


VOID
PsSetJobUIRestrictionsClass(
    __out PEJOB Job,
    __in ULONG UIRestrictionsClass
    )
{
    Job->UIRestrictionsClass = UIRestrictionsClass;
}


VOID
PsSetProcessPriorityClass(
    __out PEPROCESS Process,
    __in UCHAR PriorityClass
    )
{
    Process->PriorityClass = PriorityClass;
}


NTSTATUS
PsSetProcessWin32Process(
    __in PEPROCESS Process,
    __in PVOID Win32Process,
    __in PVOID PrevWin32Process
    )
{
    NTSTATUS Status;
    PETHREAD CurrentThread;

    Status = STATUS_SUCCESS;

    CurrentThread = _PsGetCurrentThread();

    PspLockProcessExclusive (Process, CurrentThread);

    if (Win32Process != NULL) {
        if ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_DELETE) == 0 && Process->Win32Process == NULL) {
            Process->Win32Process = Win32Process;
        } else {
            Status = STATUS_PROCESS_IS_TERMINATING;
        }
    } else {
        if (Process->Win32Process == PrevWin32Process) {
            Process->Win32Process = NULL;
        } else {
            Status = STATUS_UNSUCCESSFUL;       
        }
    }

    PspUnlockProcessExclusive (Process, CurrentThread);
 
    return Status;
}


VOID
PsSetProcessWindowStation(
    __out PEPROCESS Process,
    __in HANDLE Win32WindowStation
    )
{
     Process->Win32WindowStation = Win32WindowStation;
}


VOID
PsSetThreadHardErrorsAreDisabled(
    __in PETHREAD Thread,
    __in BOOLEAN HardErrorsAreDisabled
    )
{
    if (HardErrorsAreDisabled) {
        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    } else {
        PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    }
}


VOID
PsSetThreadWin32Thread(
    __inout PETHREAD Thread,
    __in PVOID Win32Thread,
    __in PVOID PrevWin32Thread
    )
{
    if (Win32Thread != NULL) {
        InterlockedExchangePointer(&Thread->Tcb.Win32Thread, Win32Thread);
    } else {
        InterlockedCompareExchangePointer(&Thread->Tcb.Win32Thread, Win32Thread, PrevWin32Thread);
    }
}


PVOID
PsGetProcessSecurityPort(
    __in PEPROCESS Process
    )
{
    return Process->SecurityPort ;
}


NTSTATUS
PsSetProcessSecurityPort(
    __out PEPROCESS Process,
    __in PVOID Port
    )
{
    Process->SecurityPort = Port;
    
    return STATUS_SUCCESS ;
}

BOOLEAN
PsIsThreadImpersonating (
    __in PETHREAD Thread
    )
/*++

Routine Description:

    This routine returns TRUE if the specified thread is impersonating otherwise it returns false.

Arguments:

    Thread - Thread to be queried

Return Value:

    BOOLEAN - TRUE: Thread is impersonating, FALSE: Thread is not impersonating.

--*/
{
    PAGED_CODE ();

    return (BOOLEAN) (PS_IS_THREAD_IMPERSONATING (Thread));
}


NTSTATUS
PsReferenceProcessFilePointer (
    IN PEPROCESS Process,
    OUT PVOID *OutFileObject
    )

/*++

Routine Description:

    This routine returns a referenced pointer to the FilePointer of Process.  
    This is a rundown protected wrapper around MmGetFileObjectForSection.

Arguments:

    Process - Supplies the process to query.

    OutFileObject - Returns the file object backing the requested section if
                    success is returned.

Return Value:

    NTSTATUS.
    
Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();
    
    if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
        return STATUS_UNSUCCESSFUL;
    }

    if (Process->SectionObject == NULL) {
        ExReleaseRundownProtection (&Process->RundownProtect);
        return STATUS_UNSUCCESSFUL;
    }

    FileObject = MmGetFileObjectForSection ((PVOID)Process->SectionObject);

    *OutFileObject = FileObject;

    ObReferenceObject (FileObject);

    ExReleaseRundownProtection (&Process->RundownProtect);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psdelete.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psdelete.c

Abstract:

    This module implements process and thread object termination and
    deletion.

--*/

#include "psp.h"

extern PEPROCESS ExpDefaultErrorPortProcess;


NTSTATUS
PspFreezeProcessWorker (
    PEPROCESS Process,
    PVOID Context
    );

VOID
PspCatchCriticalBreak(
    IN PCHAR Msg,
    IN PVOID  Object,
    IN PUCHAR ImageFileName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PsSetBBTNotifyRoutine)
#pragma alloc_text(PAGE, PspTerminateThreadByPointer)
#pragma alloc_text(PAGE, NtTerminateProcess)
#pragma alloc_text(PAGE, PsTerminateProcess)
#pragma alloc_text(PAGE, PspWaitForUsermodeExit)
#pragma alloc_text(PAGE, NtTerminateThread)
#pragma alloc_text(PAGE, PsTerminateSystemThread)
#pragma alloc_text(PAGE, PspNullSpecialApc)
#pragma alloc_text(PAGE, PsExitSpecialApc)
#pragma alloc_text(PAGE, PspExitApcRundown)
#pragma alloc_text(PAGE, PspExitNormalApc)
#pragma alloc_text(PAGE, PspCatchCriticalBreak)
#pragma alloc_text(PAGE, PspExitThread)
#pragma alloc_text(PAGE, PspExitProcess)
#pragma alloc_text(PAGE, PspProcessDelete)
#pragma alloc_text(PAGE, PspThreadDelete)
#pragma alloc_text(PAGE, NtRegisterThreadTerminatePort)
#pragma alloc_text(PAGE, PsGetProcessExitTime)
#pragma alloc_text(PAGE, PsShutdownSystem)
#pragma alloc_text(PAGE, PsWaitForAllProcesses)
#pragma alloc_text(PAGE, PspFreezeProcessWorker)
#pragma alloc_text(PAGE, PspTerminateProcess)
#endif


LARGE_INTEGER ShortTime = {(ULONG)(-10 * 1000 * 100), -1}; // 100 milliseconds


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
PBBT_NOTIFY_ROUTINE PspBBTNotifyRoutine = NULL;

ULONG
PsSetBBTNotifyRoutine(
    __in PBBT_NOTIFY_ROUTINE BBTNotifyRoutine
    )
{
    PAGED_CODE();

    PspBBTNotifyRoutine = BBTNotifyRoutine;

    return FIELD_OFFSET(KTHREAD,BBTData);
}

VOID
PspReaper(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine implements the thread reaper. The reaper is responsible
    for processing terminated threads. This includes:

        - deallocating their kernel stacks

        - releasing their process' CreateDelete lock

        - dereferencing their process

        - dereferencing themselves

Arguments:

    Context - NOT USED

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY NextEntry;
    PETHREAD Thread;

    UNREFERENCED_PARAMETER (Context);

    //
    // Remove the current list of threads from the reaper list and place a
    // marker in the reaper list head. This marker will prevent another
    // worker thread from being queued until all threads in the reaper list
    // have been processed.
    //

    do {

        NextEntry = InterlockedExchangePointer (&PsReaperListHead.Next,
                                                (PVOID)1);

        ASSERT ((NextEntry != NULL) && (NextEntry != (PVOID)1));
    
        //
        // Delete the respective kernel stack and dereference each thread
        // in the reaper list.
        //
    
        do {
    
            //
            // Wait until context is swapped for this thread.
            //
    
            Thread = CONTAINING_RECORD (NextEntry, ETHREAD, ReaperLink);
            KeWaitForContextSwap (&Thread->Tcb);
            MmDeleteKernelStack (Thread->Tcb.StackBase,
                                 (BOOLEAN)Thread->Tcb.LargeStack);
    
            Thread->Tcb.InitialStack = NULL;
            NextEntry = NextEntry->Next;
            ObDereferenceObject (Thread);
    
        } while ((NextEntry != NULL) && (NextEntry != (PVOID)1));

    } while (InterlockedCompareExchangePointer (&PsReaperListHead.Next,
                                                NULL,
                                                (PVOID)1) != (PVOID)1);

    return;
}

NTSTATUS
PspTerminateThreadByPointer(
    IN PETHREAD Thread,
    IN NTSTATUS ExitStatus,
    IN BOOLEAN DirectTerminate
    )

/*++

Routine Description:

    This function causes the specified thread to terminate.

Arguments:

    ThreadHandle - Supplies a referenced pointer to the thread to terminate.

    ExitStatus - Supplies the exit status associated with the thread.

    DirectTerminate - TRUE is its ok to exit without queing an APC, FALSE otherwise

--*/

{
    NTSTATUS Status;
    PKAPC    ExitApc=NULL;
    ULONG    OldMask;

    PAGED_CODE();

    if (Thread->CrossThreadFlags
    & PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION) {
      PspCatchCriticalBreak("Terminating critical thread 0x%p (in %s)\n",
                Thread,
                THREAD_TO_PROCESS(Thread)->ImageFileName);
    }

    if (DirectTerminate && Thread == PsGetCurrentThread()) {

        ASSERT (KeGetCurrentIrql() < APC_LEVEL);

        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_TERMINATED);

        PspExitThread (ExitStatus);

        //
        // Never Returns
        //

    } else {
        //
        // Cross thread deletion of system threads won't work.
        //
        if (IS_SYSTEM_THREAD (Thread)) {
            return STATUS_ACCESS_DENIED;
        }

        Status = STATUS_SUCCESS;

        while (1) {
            ExitApc = (PKAPC) ExAllocatePoolWithTag (NonPagedPool,
                                                     sizeof(KAPC),
                                                     'xEsP');
            if (ExitApc != NULL) {
                break;
            }
            KeDelayExecutionThread(KernelMode, FALSE, &ShortTime);
        }

        //
        // Mark the thread as terminating and call the exit function.
        //
        OldMask = PS_TEST_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_TERMINATED);

        //
        // If we are the first to set the terminating flag then queue the APC
        //

        if ((OldMask & PS_CROSS_THREAD_FLAGS_TERMINATED) == 0) {

            KeInitializeApc (ExitApc,
                             PsGetKernelThread (Thread),
                             OriginalApcEnvironment,
                             PsExitSpecialApc,
                             PspExitApcRundown,
                             PspExitNormalApc,
                             KernelMode,
                             ULongToPtr (ExitStatus));

            if (!KeInsertQueueApc (ExitApc, ExitApc, NULL, 2)) {
                //
                // If APC queuing is disabled then the thread is exiting anyway
                //
                ExFreePool (ExitApc);
                Status = STATUS_UNSUCCESSFUL;
            } else {
                //
                // We queued the APC to the thread. Wake up the thread if it was suspended.
                //
                KeForceResumeThread (&Thread->Tcb);

            }
        } else {
            ExFreePool (ExitApc);
        }
    }

    return Status;
}

NTSTATUS
NtTerminateProcess(
    __in_opt HANDLE ProcessHandle,
    __in NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the specified process and all of
    its threads to terminate.

Arguments:

    ProcessHandle - Supplies a handle to the process to terminate.

    ExitStatus - Supplies the exit status associated with the process.

Return Value:

    NTSTATUS - Status of operation

--*/

{

    PETHREAD Thread, Self;
    PEPROCESS Process;
    PEPROCESS CurrentProcess;
    NTSTATUS st;
    BOOLEAN ProcessHandleSpecified;
    PAGED_CODE();

    Self = PsGetCurrentThread();
    CurrentProcess = PsGetCurrentProcessByThread (Self);

    if (ARGUMENT_PRESENT (ProcessHandle)) {
        ProcessHandleSpecified = TRUE;
    } else {
        ProcessHandleSpecified = FALSE;
        ProcessHandle = NtCurrentProcess();
    }

    st = ObReferenceObjectByHandle (ProcessHandle,
                                    PROCESS_TERMINATE,
                                    PsProcessType,
                                    KeGetPreviousModeByThread(&Self->Tcb),
                                    &Process,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return(st);
    }

    if (Process->Flags & PS_PROCESS_FLAGS_BREAK_ON_TERMINATION) {
        PspCatchCriticalBreak ("Terminating critical process 0x%p (%s)\n",
                               Process,
                               Process->ImageFileName);
    }

    //
    // Acquire rundown protection just so we can give the right errors
    //

    if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
        ObDereferenceObject (Process);
        return STATUS_PROCESS_IS_TERMINATING;
    }

    //
    // Mark process as deleting except for the obscure delete self case.
    //
    if (ProcessHandleSpecified) {
        PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_PROCESS_DELETE);
    }

    st = STATUS_NOTHING_TO_TERMINATE;

    for (Thread = PsGetNextProcessThread (Process, NULL);
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        st = STATUS_SUCCESS;
        if (Thread != Self) {
            PspTerminateThreadByPointer (Thread, ExitStatus, FALSE);
        }
    }

    ExReleaseRundownProtection (&Process->RundownProtect);


    if (Process == CurrentProcess) {
        if (ProcessHandleSpecified) {

            ObDereferenceObject (Process);

            //
            // Never Returns
            //

            PspTerminateThreadByPointer (Self, ExitStatus, TRUE);
        }
    } else if (ExitStatus == DBG_TERMINATE_PROCESS) {
        DbgkClearProcessDebugObject (Process, NULL);
    }

    //
    // If there are no threads in this process then clear out its handle table.
    // Do the same for processes being debugged. This is so a process can never lock itself into the system
    // by debugging itself or have a handle open to itself.
    //
    if (st == STATUS_NOTHING_TO_TERMINATE || (Process->DebugPort != NULL && ProcessHandleSpecified)) {
        ObClearProcessHandleTable (Process);
        st = STATUS_SUCCESS;
    }

    ObDereferenceObject(Process);

    return st;
}

NTSTATUS
PsTerminateProcess(
    PEPROCESS Process,
    NTSTATUS Status
    )
{
    return PspTerminateProcess (Process, Status);
}

NTSTATUS
PspTerminateProcess(
    PEPROCESS Process,
    NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the specified process and all of
    its threads to terminate.

Arguments:

    ProcessHandle - Supplies a handle to the process to terminate.

    ExitStatus - Supplies the exit status associated with the process.

--*/

{

    PETHREAD Thread;
    NTSTATUS st;

    PAGED_CODE();


    if (Process->Flags
    & PS_PROCESS_FLAGS_BREAK_ON_TERMINATION) {
      PspCatchCriticalBreak("Terminating critical process 0x%p (%s)\n",
                Process,
                Process->ImageFileName);
    }

    //
    // Mark process as deleting
    //
    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_PROCESS_DELETE);

    st = STATUS_NOTHING_TO_TERMINATE;

    for (Thread = PsGetNextProcessThread (Process, NULL);
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        st = STATUS_SUCCESS;

        PspTerminateThreadByPointer (Thread, ExitStatus, FALSE);

    }

    //
    // If there are no threads in this process then clear out its handle table.
    // Do the same for processes being debugged. This is so a process can never lock itself into the system
    // by debugging itself or have a handle open to itself.
    //
    if (st == STATUS_NOTHING_TO_TERMINATE || Process->DebugPort != NULL) {
        ObClearProcessHandleTable (Process);
        st = STATUS_SUCCESS;
    }
    return st;
}


NTSTATUS
PspWaitForUsermodeExit(
    IN PEPROCESS         Process
    )

/*++

Routine Description:

    This function waits for a process's usermode threads to terminate.

Arguments:

    Process - Supplies a pointer to the process to wait for

    WaitMode - Supplies the mode to wait in

    LockMode - Supplies the way to wait for the process lock

Return Value:

    NTSTATUS - Status of call

--*/
{
    BOOLEAN     GotAThread;
    PETHREAD    Thread;

    do {
        GotAThread = FALSE;

        for (Thread = PsGetNextProcessThread (Process, NULL);
             Thread != NULL;
             Thread = PsGetNextProcessThread (Process, Thread)) {

            if (!IS_SYSTEM_THREAD (Thread) && !KeReadStateThread (&Thread->Tcb)) {
                ObReferenceObject (Thread);
                PsQuitNextProcessThread (Thread);
                GotAThread = TRUE;
                break;
            }
        }


        if (GotAThread) {
            KeWaitForSingleObject (Thread,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
            ObDereferenceObject (Thread);
        }
    } while (GotAThread);

    return STATUS_SUCCESS;
}

NTSTATUS
NtTerminateThread(
    __in_opt HANDLE ThreadHandle,
    __in NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the specified thread to terminate.

Arguments:

    ThreadHandle - Supplies a handle to the thread to terminate.

    ExitStatus - Supplies the exit status associated with the thread.

--*/

{

    PETHREAD Thread=NULL, ThisThread;
    PEPROCESS ThisProcess;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN Self = TRUE;

    PAGED_CODE();

    ThisThread = PsGetCurrentThread ();

    if (!ARGUMENT_PRESENT (ThreadHandle)) {
        //
        // This is part of the strange linkage between base\win32 and the kernel.
        // This routine gets called this way first and if it returns the base
        // code does an exit process call.
        //
        ThisProcess = PsGetCurrentProcessByThread (ThisThread);

        if (ThisProcess->ActiveThreads == 1) {
            return STATUS_CANT_TERMINATE_SELF;
        }
        Self = TRUE;
    } else {
        if (ThreadHandle != NtCurrentThread ()) {
            Status = ObReferenceObjectByHandle (ThreadHandle,
                                                THREAD_TERMINATE,
                                                PsThreadType,
                                                KeGetPreviousModeByThread (&ThisThread->Tcb),
                                                &Thread,
                                                NULL);
            if (!NT_SUCCESS (Status)) {
                return Status;
            }

            if (Thread == ThisThread) {
                ObDereferenceObject (Thread);
            } else {
                Self = FALSE;
            }
        }

    }

    if (Self) {
        PspTerminateThreadByPointer (ThisThread, ExitStatus, TRUE);
    } else {
        Status = PspTerminateThreadByPointer (Thread, ExitStatus, FALSE);
        ObDereferenceObject (Thread);
    }

    return Status;
}

NTSTATUS
PsTerminateSystemThread(
    __in NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the current thread, which must be a system
    thread, to terminate.

Arguments:

    ExitStatus - Supplies the exit status associated with the thread.

Return Value:

    NTSTATUS - Status of call

--*/

{
    PETHREAD Thread = PsGetCurrentThread();

    if (!IS_SYSTEM_THREAD (Thread)) {
        return STATUS_INVALID_PARAMETER;
    }

    return PspTerminateThreadByPointer (Thread, ExitStatus, TRUE);
}


VOID
PspNullSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

{

    PAGED_CODE();

    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    ExFreePool (Apc);
}

VOID
PsExitSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

{
    NTSTATUS ExitStatus;
    PETHREAD Thread;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    Thread = PsGetCurrentThread();

    if (((ULONG_PTR)Apc->SystemArgument2) & 1) {
        ExitStatus = (NTSTATUS)((LONG_PTR)Apc->NormalContext);
        PspExitApcRundown (Apc);
        PspExitThread (ExitStatus);
    }

}

VOID
PspExitApcRundown(
    IN PKAPC Apc
    )
{
    PAGED_CODE();

    ExFreePool(Apc);
}

VOID
PspExitNormalApc(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

{
    PETHREAD Thread;
    PKAPC ExitApc;

    PAGED_CODE();

    ASSERT (!(((ULONG_PTR)SystemArgument2) & 1));

    Thread = PsGetCurrentThread();

    ExitApc = (PKAPC) SystemArgument1;

    KeInitializeApc (ExitApc,
                     PsGetKernelThread(Thread),
                     OriginalApcEnvironment,
                     PsExitSpecialApc,
                     PspExitApcRundown,
                     PspExitNormalApc,
                     UserMode,
                     NormalContext);

    if (!KeInsertQueueApc (ExitApc, ExitApc,
                           (PVOID)((ULONG_PTR)SystemArgument2 | 1),
                           2)) {
        // Note that we'll get here if APC queueing has been
        // disabled -- on the other hand, in that case, the thread
        // is exiting anyway.
        PspExitApcRundown (ExitApc);
    }
    //
    // We just queued a user APC to this thread. User APC won't fire until we do an
    // alertable wait so we need to set this flag here.
    //
    Thread->Tcb.ApcState.UserApcPending = TRUE;
}

VOID
PspCatchCriticalBreak(
    IN PCHAR Msg,
    IN PVOID Object,
    IN PUCHAR ImageFileName
    )
{
    // The object is critical to the OS -- ask to break in, or bugcheck.
    char    Response[2];
    BOOLEAN Handled;

    PAGED_CODE();

    Handled = FALSE;

    if (KdDebuggerEnabled) {
        DbgPrint(Msg,
                 Object,
                 ImageFileName);

        while (! Handled
               && ! KdDebuggerNotPresent) {
            DbgPrompt("Break, or Ignore (bi)? ",
                      Response,
                      sizeof(Response));

            switch (Response[0]) {
            case 'b':
            case 'B':
                DbgBreakPoint();
                // Fall through
            case 'i':
            case 'I':
                Handled = TRUE;
                break;

            default:
                break;
            }
        }
    }

    if (!Handled) {
        //
        // No debugger -- bugcheck immediately
        //
        KeBugCheckEx(CRITICAL_OBJECT_TERMINATION,
                     (ULONG_PTR) ((DISPATCHER_HEADER *)Object)->Type,
                     (ULONG_PTR) Object,
                     (ULONG_PTR) ImageFileName,
                     (ULONG_PTR) Msg);
    }
}

DECLSPEC_NORETURN
VOID
PspExitThread(
    IN NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the currently executing thread to terminate.  This
    function is only called from within the process structure.  It is called
    either from mainline exit code to exit the current thread, or from
    PsExitSpecialApc (as a piggyback to user-mode PspExitNormalApc).

Arguments:

    ExitStatus - Supplies the exit status associated with the current thread.

Return Value:

    None.

--*/


{

    PETHREAD Thread;
    PETHREAD WaitThread;
    PETHREAD DerefThread;
    PEPROCESS Process;
    PKAPC Apc;
    PLIST_ENTRY Entry, FirstEntry;
    PTERMINATION_PORT TerminationPort, NextPort;
    LPC_CLIENT_DIED_MSG CdMsg;
    BOOLEAN LastThread;
    PTEB Teb;
    PPEB Peb;
    PACCESS_TOKEN ProcessToken;
    NTSTATUS Status;

    PAGED_CODE();

    Thread = PsGetCurrentThread();
    Process = THREAD_TO_PROCESS(Thread);

    if (Process != PsGetCurrentProcessByThread (Thread)) {
        KeBugCheckEx (INVALID_PROCESS_ATTACH_ATTEMPT,
                      (ULONG_PTR)Process,
                      (ULONG_PTR)Thread->Tcb.ApcState.Process,
                      (ULONG)Thread->Tcb.ApcStateIndex,
                      (ULONG_PTR)Thread);
    }

    KeLowerIrql(PASSIVE_LEVEL);

    if (Thread->ActiveExWorker) {
        KeBugCheckEx (ACTIVE_EX_WORKER_THREAD_TERMINATION,
                      (ULONG_PTR)Thread,
                      0,
                      0,
                      0);
    }

    if (Thread->Tcb.CombinedApcDisable != 0) {
        KeBugCheckEx (KERNEL_APC_PENDING_DURING_EXIT,
                      (ULONG_PTR)0,
                      (ULONG_PTR)Thread->Tcb.CombinedApcDisable,
                      (ULONG_PTR)0,
                      1);
    }


    //
    // Its time to start turning off various cross thread references.
    // Mark the thread as rundown and wait for accessors to exit.
    //
    ExWaitForRundownProtectionRelease (&Thread->RundownProtect);

    //
    // Clear any execution state associated with the thread
    //

    PoRundownThread(Thread);

    //
    // Notify registered callout routines of thread deletion.
    //

    PERFINFO_THREAD_DELETE(Thread);

    if (PspCreateThreadNotifyRoutineCount != 0) {
        ULONG i;
        PEX_CALLBACK_ROUTINE_BLOCK CallBack;
        PCREATE_THREAD_NOTIFY_ROUTINE Rtn;

        for (i=0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
            CallBack = ExReferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i]);
            if (CallBack != NULL) {
                Rtn = (PCREATE_THREAD_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                Rtn (Process->UniqueProcessId,
                     Thread->Cid.UniqueThread,
                     FALSE);
                ExDereferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i],
                                            CallBack);
            }
        }
    }

    LastThread = FALSE;
    DerefThread = NULL;

    PspLockProcessExclusive (Process, Thread);

    //
    // Say one less active thread. If we are the last then block creates and wait for the other threads to exit.
    //
    Process->ActiveThreads--;
    if (Process->ActiveThreads == 0) {
        PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_PROCESS_DELETE);

        LastThread = TRUE;
        if (ExitStatus == STATUS_THREAD_IS_TERMINATING) {
            if (Process->ExitStatus == STATUS_PENDING) {
                Process->ExitStatus = Process->LastThreadExitStatus;
            }
        } else {
            Process->ExitStatus = ExitStatus;
        }

        //
        // We are the last thread to leave the process. We have to wait till all the other threads have exited before we do.
        //
        for (Entry = Process->ThreadListHead.Flink;
             Entry != &Process->ThreadListHead;
             Entry = Entry->Flink) {

            WaitThread = CONTAINING_RECORD (Entry, ETHREAD, ThreadListEntry);
            if (WaitThread != Thread &&
                !KeReadStateThread (&WaitThread->Tcb) &&
                ObReferenceObjectSafe (WaitThread)) {

                PspUnlockProcessExclusive (Process, Thread);

                KeWaitForSingleObject (WaitThread,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                if (DerefThread != NULL) {
                    ObDereferenceObject (DerefThread);
                }
                DerefThread = WaitThread;
                PspLockProcessExclusive (Process, Thread);
            }
        }
    } else {
        if (ExitStatus != STATUS_THREAD_IS_TERMINATING) {
            Process->LastThreadExitStatus = ExitStatus;
        }
    }

    PspUnlockProcessExclusive (Process, Thread);

    if (DerefThread != NULL) {
        ObDereferenceObject (DerefThread);
    }


    //
    // If we need to send debug messages then do so.
    //

    if (Process->DebugPort != NULL) {
        //
        // Don't report system thread exit to the debugger as we don't report them.
        //
        if (!IS_SYSTEM_THREAD (Thread)) {
            if (LastThread) {
                DbgkExitProcess (Process->ExitStatus);
            } else {
                DbgkExitThread (ExitStatus);
            }
        }
    }

    if (KD_DEBUGGER_ENABLED) {

        if (Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION) {
            PspCatchCriticalBreak ("Critical thread 0x%p (in %s) exited\n",
                                   Thread,
                                   Process->ImageFileName);
        }
    } // End of critical thread/process exit detect

    if (LastThread &&
        (Process->Flags & PS_PROCESS_FLAGS_BREAK_ON_TERMINATION)) {
        if (KD_DEBUGGER_ENABLED) {
            PspCatchCriticalBreak ("Critical process 0x%p (%s) exited\n",
                                   Process,
                                   Process->ImageFileName);
        } else {
            KeBugCheckEx (CRITICAL_PROCESS_DIED,
                          (ULONG_PTR)Process,
                          0,
                          0,
                          0);
        }
    }


    ASSERT(Thread->Tcb.CombinedApcDisable == 0);

    //
    // Process the TerminationPort. This is only accessed from this thread
    //
    TerminationPort = Thread->TerminationPort;
    if (TerminationPort != NULL) {

        CdMsg.PortMsg.u1.s1.DataLength = sizeof(LARGE_INTEGER);
        CdMsg.PortMsg.u1.s1.TotalLength = sizeof(LPC_CLIENT_DIED_MSG);
        CdMsg.PortMsg.u2.s2.Type = LPC_CLIENT_DIED;
        CdMsg.PortMsg.u2.s2.DataInfoOffset = 0;

        do {

            CdMsg.CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME (Thread);
            while (1) {
                Status = LpcRequestPort (TerminationPort->Port, (PPORT_MESSAGE)&CdMsg);
                if (Status == STATUS_NO_MEMORY || Status == STATUS_INSUFFICIENT_RESOURCES) {
                    KeDelayExecutionThread (KernelMode, FALSE, &ShortTime);
                    continue;
                }
                break;
            }
            ObDereferenceObject (TerminationPort->Port);

            NextPort = TerminationPort->Next;

            ExFreePoolWithTag (TerminationPort, 'pTsP'|PROTECTED_POOL);

            TerminationPort = NextPort;

        } while (TerminationPort != NULL);
    } else {

        //
        // If there are no ports to send notifications to,
        // but there is an exception port, then we have to
        // send a client died message through the exception
        // port. This will allow a server a chance to get notification
        // if an app/thread dies before it even starts
        //
        //
        // We only send the exception if the thread creation really worked.
        // DeadThread is set when an NtCreateThread returns an error, but
        // the thread will actually execute this path. If DeadThread is not
        // set than the thread creation succeeded. The other place DeadThread
        // is set is when we were terminated without having any chance to move.
        // in this case, DeadThread is set and the exit status is set to
        // STATUS_THREAD_IS_TERMINATING
        //

        if ((ExitStatus == STATUS_THREAD_IS_TERMINATING &&
            (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD)) ||
            !(Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD)) {

            CdMsg.PortMsg.u1.s1.DataLength = sizeof (LARGE_INTEGER);
            CdMsg.PortMsg.u1.s1.TotalLength = sizeof (LPC_CLIENT_DIED_MSG);
            CdMsg.PortMsg.u2.s2.Type = LPC_CLIENT_DIED;
            CdMsg.PortMsg.u2.s2.DataInfoOffset = 0;
            if (Process->ExceptionPort != NULL) {
                CdMsg.CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME (Thread);
                while (1) {
                    Status = LpcRequestPort (Process->ExceptionPort, (PPORT_MESSAGE)&CdMsg);
                    if (Status == STATUS_NO_MEMORY || Status == STATUS_INSUFFICIENT_RESOURCES) {
                        KeDelayExecutionThread (KernelMode, FALSE, &ShortTime);
                        continue;
                    }
                    break;
                }
            }
        }
    }

    //
    // rundown the Win32 structures
    //

    if (Thread->Tcb.Win32Thread) {
        (PspW32ThreadCallout) (Thread, PsW32ThreadCalloutExit);
    }

    if (LastThread && Process->Win32Process) {
        (PspW32ProcessCallout) (Process, FALSE);
    }

    //
    // User/Gdi has been given a chance to clean up. Now make sure they didn't
    // leave the kernel stack locked which would happen if data was still live on
    // this stack, but was being used by another thread
    //

    if (!Thread->Tcb.EnableStackSwap) {
        KeBugCheckEx (KERNEL_STACK_LOCKED_AT_EXIT, 0, 0, 0, 0);
    }

    //
    // Rundown The Lists:
    //
    //      - Cancel Io By Thread
    //      - Cancel Timers
    //      - Cancel Registry Notify Requests pending against this thread
    //      - Perform kernel thread rundown
    //

    IoCancelThreadIo (Thread);
    ExTimerRundown ();
    CmNotifyRunDown (Thread);
    KeRundownThread ();

#if DBG

    //
    // See if we are exiting while holding a resource
    //

    ExCheckIfResourceOwned ();

#endif

    //
    // Delete the thread's TEB.  If the address of the TEB is in user
    // space, then this is a real user mode TEB.  If the address is in
    // system space, then this is a special system thread TEB allocated
    // from paged or nonpaged pool.
    //


    Teb = Thread->Tcb.Teb;
    if (Teb != NULL) {

        Peb = Process->Peb;

        try {

            //
            // Free the user mode stack on termination if we need to.
            //

            if ((Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) == 0) {
                
                SIZE_T Zero;
                PVOID BaseAddress;
                
                if (Teb->FreeStackOnTermination) {
                    
                    Zero = 0;
                    BaseAddress = Teb->DeallocationStack;
                    ZwFreeVirtualMemory (NtCurrentProcess (),
                                         &BaseAddress,
                                         &Zero,
                                         MEM_RELEASE);
                }

#if defined(_WIN64)
                if (Process->Wow64Process != NULL) {
                    PTEB32 Teb32;

                    Teb32 = WOW64_GET_TEB32_SAFE (Teb);
                    if (Teb32->FreeStackOnTermination) {

                        Zero = 0;
                        BaseAddress = UlongToPtr (Teb32->DeallocationStack);
                    
                        ZwFreeVirtualMemory (NtCurrentProcess (),
                                             &BaseAddress,
                                             &Zero,
                                             MEM_RELEASE);
                    }
                }
#endif
            }

            //
            // Close the debugger object associated with this thread if there is one.
            //
            if (Teb->DbgSsReserved[1] != NULL) {
                ObCloseHandle (Teb->DbgSsReserved[1], UserMode);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }

        MmDeleteTeb (Process, Teb);
        Thread->Tcb.Teb = NULL;
    }


    //
    // Let LPC component deal with message stack in Thread->LpcReplyMessage
    // but do it after the client ID becomes invalid.
    //

    LpcExitThread (Thread);

    Thread->ExitStatus = ExitStatus;
    KeQuerySystemTime (&Thread->ExitTime);


    ASSERT (Thread->Tcb.CombinedApcDisable == 0);

    if (LastThread) {

        Process->ExitTime = Thread->ExitTime;
        PspExitProcess (TRUE, Process);
            
        ProcessToken = PsReferencePrimaryToken (Process);
        if (SeDetailedAuditingWithToken (ProcessToken)) {
            SeAuditProcessExit (Process);
        }
        PsDereferencePrimaryTokenEx (Process, ProcessToken);

#if defined(_X86_)
        //
        // Rundown VDM DPCs
        //
        if (Process->VdmObjects != NULL) {
            VdmRundownDpcs (Process);
        }
#endif

        //
        // Rundown the handle table
        //
        ObKillProcess (Process);

        //
        // Release the image section
        //
        if (Process->SectionObject != NULL) {
            ObDereferenceObject (Process->SectionObject);
            Process->SectionObject = NULL;
        }

        if (Process->Job != NULL) {

            //
            // Now we can fold the process accounting into the job. Don't need to wait for
            // the delete routine.
            //

            PspExitProcessFromJob (Process->Job, Process);

        }

    }


    //
    // Rundown pending APCs. Protect against being frozen after we raise IRQL but before dispatcher lock is taken.
    //
    KeEnterCriticalRegionThread (&Thread->Tcb);

    //
    // Disable APC queueing for the current thread.
    //

    Thread->Tcb.ApcQueueable = FALSE;

    //
    // At this point we may have been frozen and the APC is pending. First we remove the suspend/freeze bias that
    // may exist and then drop IRQL. The suspend APC if present will fire and drop through. No further suspends are
    // allowed as the thread is marked to prevent APC's
    //
    KeForceResumeThread (&Thread->Tcb);
    KeLeaveCriticalRegionThread (&Thread->Tcb);

    //
    // flush user-mode APC queue
    //

    FirstEntry = KeFlushQueueApc (&Thread->Tcb, UserMode);

    if (FirstEntry != NULL) {

        Entry = FirstEntry;
        do {
            Apc = CONTAINING_RECORD (Entry, KAPC, ApcListEntry);
            Entry = Entry->Flink;

            //
            // If the APC has a rundown routine then call it. Otherwise
            // deallocate the APC
            //

            if (Apc->RundownRoutine) {
                (Apc->RundownRoutine) (Apc);
            } else {
                ExFreePool (Apc);
            }

        } while (Entry != FirstEntry);
    }

    if (LastThread) {
        MmCleanProcessAddressSpace (Process);
    }

    if (Thread->Tcb.BBTData && PspBBTNotifyRoutine) {
        (PspBBTNotifyRoutine) (&Thread->Tcb);
    }

    //
    // flush kernel-mode APC queue
    // There should never be any kernel mode APCs found this far
    // into thread termination. Since we go to PASSIVE_LEVEL upon
    // entering exit.
    //

    FirstEntry = KeFlushQueueApc (&Thread->Tcb, KernelMode);

    if (FirstEntry != NULL || Thread->Tcb.CombinedApcDisable != 0) {
        KeBugCheckEx (KERNEL_APC_PENDING_DURING_EXIT,
                      (ULONG_PTR)FirstEntry,
                      (ULONG_PTR)Thread->Tcb.CombinedApcDisable,
                      (ULONG_PTR)KeGetCurrentIrql(),
                      0);
    }


    //
    // Signal the process
    //

    if (LastThread) {
        KeSetProcess (&Process->Pcb, 0, FALSE);
    }

    //
    // Terminate the thread.
    //
    // N.B. There is no return from this call.
    //
    // N.B. The kernel inserts the current thread in the reaper list and
    //      activates a thread, if necessary, to reap the terminating thread.
    //

    KeTerminateThread (0L);
}

VOID
PspExitProcess(
    IN BOOLEAN LastThreadExit,
    IN PEPROCESS Process
    )
{
    ULONG ActualTime;
    PEJOB Job;
    PETHREAD CurrentThread;

    PAGED_CODE();

    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_PROCESS_EXITING);

    if (LastThreadExit) {

        PERFINFO_PROCESS_DELETE(Process);

        if (PspCreateProcessNotifyRoutineCount != 0) {
            ULONG i;
            PEX_CALLBACK_ROUTINE_BLOCK CallBack;
            PCREATE_PROCESS_NOTIFY_ROUTINE Rtn;

            for (i = 0; i < PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {
                CallBack = ExReferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i]);
                if (CallBack != NULL) {
                    Rtn = (PCREATE_PROCESS_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                    Rtn (Process->InheritedFromUniqueProcessId,
                         Process->UniqueProcessId,
                         FALSE);
                    ExDereferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i],
                                                CallBack);
                }
            }
        }

    }


    PoRundownProcess (Process);

    //
    // Dereference (close) the security port.  This will stop any authentication
    // or EFS requests from this process to the LSA process.  The "well known"
    // value of 1 will prevent the security system from try to re-establish the
    // connection during the process shutdown (e.g. when the rdr deletes a handle)
    //

    if (Process->SecurityPort) {

        if (Process->SecurityPort != ((PVOID) 1)) {
            ObDereferenceObject (Process->SecurityPort);

            Process->SecurityPort = (PVOID) 1 ;
        }
    }
    else {
        
        //
        // Even if there have never been any requests to the LSA process, i.e. the pointer
        // is NULL, set it to 1 anyway.  Filter drivers can apparently cause a network 
        // hop at this point.  This will prevent any such from deadlocking.
        //

        Process->SecurityPort = (PVOID) 1 ;
    }


    if (LastThreadExit) {


        //
        // If the current process has previously set the timer resolution,
        // then reset it.
        //

        if ((Process->Flags&PS_PROCESS_FLAGS_SET_TIMER_RESOLUTION) != 0) {
            ZwSetTimerResolution (KeMaximumIncrement, FALSE, &ActualTime);
        }

        Job = Process->Job;
        if (Job != NULL && Job->CompletionPort != NULL &&
            !(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE) &&
            !(Process->JobStatus & PS_JOB_STATUS_EXIT_PROCESS_REPORTED)) {

            ULONG_PTR ExitMessageId;

            switch (Process->ExitStatus) {
                case STATUS_GUARD_PAGE_VIOLATION      :
                case STATUS_DATATYPE_MISALIGNMENT     :
                case STATUS_BREAKPOINT                :
                case STATUS_SINGLE_STEP               :
                case STATUS_ACCESS_VIOLATION          :
                case STATUS_IN_PAGE_ERROR             :
                case STATUS_ILLEGAL_INSTRUCTION       :
                case STATUS_NONCONTINUABLE_EXCEPTION  :
                case STATUS_INVALID_DISPOSITION       :
                case STATUS_ARRAY_BOUNDS_EXCEEDED     :
                case STATUS_FLOAT_DENORMAL_OPERAND    :
                case STATUS_FLOAT_DIVIDE_BY_ZERO      :
                case STATUS_FLOAT_INEXACT_RESULT      :
                case STATUS_FLOAT_INVALID_OPERATION   :
                case STATUS_FLOAT_OVERFLOW            :
                case STATUS_FLOAT_STACK_CHECK         :
                case STATUS_FLOAT_UNDERFLOW           :
                case STATUS_INTEGER_DIVIDE_BY_ZERO    :
                case STATUS_INTEGER_OVERFLOW          :
                case STATUS_PRIVILEGED_INSTRUCTION    :
                case STATUS_STACK_OVERFLOW            :
                case STATUS_CONTROL_C_EXIT            :
                case STATUS_FLOAT_MULTIPLE_FAULTS     :
                case STATUS_FLOAT_MULTIPLE_TRAPS      :
                case STATUS_REG_NAT_CONSUMPTION       :
                    ExitMessageId = JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS;
                    break;
                default:
                    ExitMessageId = JOB_OBJECT_MSG_EXIT_PROCESS;
                    break;
            }

            PS_SET_CLEAR_BITS (&Process->JobStatus,
                               PS_JOB_STATUS_EXIT_PROCESS_REPORTED,
                               PS_JOB_STATUS_LAST_REPORT_MEMORY);

            CurrentThread = PsGetCurrentThread ();

            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

            if (Job->CompletionPort != NULL) {
                IoSetIoCompletion (Job->CompletionPort,
                                   Job->CompletionKey,
                                   (PVOID)Process->UniqueProcessId,
                                   STATUS_SUCCESS,
                                   ExitMessageId,
                                   FALSE);
            }

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        }

        if (CCPF_IS_PREFETCHER_ACTIVE ()) {

            //
            // Let prefetcher know that this process is exiting.
            //

            CcPfProcessExitNotification (Process);
        }

    } else {
        MmCleanProcessAddressSpace (Process);
    }

}

VOID
PspProcessDelete(
    IN PVOID Object
    )
{
    PEPROCESS Process;
    PETHREAD CurrentThread;
    KAPC_STATE ApcState;

    PAGED_CODE();

    Process = (PEPROCESS)Object;

    //
    // Zero the GrantedAccess field so the system will not panic
    // when this process is missing from the PsActiveProcess list
    // but is still found in the CID table.
    //

#if defined(_AMD64_)

    Process->GrantedAccess = 0;

#endif

    //
    // Remove the process from the global list
    //
    if (Process->ActiveProcessLinks.Flink != NULL) {
        CurrentThread = PsGetCurrentThread ();

        PspLockProcessList (CurrentThread);
        RemoveEntryList (&Process->ActiveProcessLinks);
        PspUnlockProcessList (CurrentThread);
    }

    if (Process->SeAuditProcessCreationInfo.ImageFileName != NULL) {
        ExFreePool (Process->SeAuditProcessCreationInfo.ImageFileName);
        Process->SeAuditProcessCreationInfo.ImageFileName = NULL;
    }

    if (Process->Job != NULL) {
        PspRemoveProcessFromJob (Process->Job, Process);
        ObDereferenceObjectDeferDelete (Process->Job);
        Process->Job = NULL;
    }

    KeTerminateProcess (&Process->Pcb);


    if (Process->DebugPort != NULL) {
        ObDereferenceObject (Process->DebugPort);
        Process->DebugPort = NULL;
    }
    if (Process->ExceptionPort != NULL) {
        ObDereferenceObject (Process->ExceptionPort);
        Process->ExceptionPort = NULL;
    }

    if (Process->SectionObject != NULL) {
        ObDereferenceObject (Process->SectionObject);
        Process->SectionObject = NULL;
    }

    PspDeleteLdt (Process );
    PspDeleteVdmObjects (Process);

    if (Process->ObjectTable != NULL) {
        KeStackAttachProcess (&Process->Pcb, &ApcState);
        ObKillProcess (Process);
        KeUnstackDetachProcess (&ApcState);
    }


    if (Process->Flags&PS_PROCESS_FLAGS_HAS_ADDRESS_SPACE) {

        //
        // Clean address space of the process
        //

        KeStackAttachProcess (&Process->Pcb, &ApcState);

        PspExitProcess (FALSE, Process);

        KeUnstackDetachProcess (&ApcState);

        MmDeleteProcessAddressSpace (Process);
    }

    if (Process->UniqueProcessId) {
        if (!(ExDestroyHandle (PspCidTable, Process->UniqueProcessId, NULL))) {
            KeBugCheck (CID_HANDLE_DELETION);
        }
    }

    PspDeleteProcessSecurity (Process);


    if (Process->WorkingSetWatch != NULL) {
        ExFreePool (Process->WorkingSetWatch);
        PsReturnProcessNonPagedPoolQuota (Process, WS_CATCH_SIZE);
    }

    ObDereferenceDeviceMap (Process);
    PspDereferenceQuota (Process);

#if !defined(_X86_) && !defined(_AMD64_)
    {
        //
        // Free any alignment exception tracking structures that might
        // have been around to support a user-mode debugger.
        //

        PALIGNMENT_EXCEPTION_TABLE ExceptionTable;
        PALIGNMENT_EXCEPTION_TABLE NextExceptionTable;

        ExceptionTable = Process->Pcb.AlignmentExceptionTable;
        while (ExceptionTable != NULL) {

            NextExceptionTable = ExceptionTable->Next;
            ExFreePool( ExceptionTable );
            ExceptionTable = NextExceptionTable;
        }
    }
#endif

}

VOID
PspThreadDelete(
    IN PVOID Object
    )
{
    PETHREAD Thread;
    PETHREAD CurrentThread;
    PEPROCESS Process;

    PAGED_CODE();

    Thread = (PETHREAD) Object;

    ASSERT(Thread->Tcb.Win32Thread == NULL);

    if (Thread->Tcb.InitialStack) {
        MmDeleteKernelStack(Thread->Tcb.StackBase,
                            (BOOLEAN)Thread->Tcb.LargeStack);
    }

    if (Thread->Cid.UniqueThread != NULL) {
        if (!ExDestroyHandle (PspCidTable, Thread->Cid.UniqueThread, NULL)) {
            KeBugCheck(CID_HANDLE_DELETION);
        }
    }

    PspDeleteThreadSecurity (Thread);

    Process = THREAD_TO_PROCESS(Thread);
    if (Process) {
        //
        // Remove the thread from the process if it was ever inserted.
        //
        if (Thread->ThreadListEntry.Flink != NULL) {

            CurrentThread = PsGetCurrentThread ();

            PspLockProcessExclusive (Process, CurrentThread);

            RemoveEntryList (&Thread->ThreadListEntry);

            PspUnlockProcessExclusive (Process, CurrentThread);
        }

        ObDereferenceObject(Process);
    }
}

NTSTATUS
NtRegisterThreadTerminatePort(
    __in HANDLE PortHandle
    )

/*++

Routine Description:

    This API allows a thread to register a port to be notified upon
    thread termination.

Arguments:

    PortHandle - Supplies an open handle to a port object that will be
        sent a termination message when the thread terminates.

--*/

{

    PVOID Port;
    PTERMINATION_PORT TerminationPort;
    NTSTATUS st;
    PETHREAD Thread;

    PAGED_CODE();

    Thread = PsGetCurrentThread ();

    st = ObReferenceObjectByHandle (PortHandle,
                                    0,
                                    LpcPortObjectType,
                                    KeGetPreviousModeByThread(&Thread->Tcb),
                                    &Port,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    TerminationPort = ExAllocatePoolWithQuotaTag (PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                                  sizeof(TERMINATION_PORT),
                                                  'pTsP'|PROTECTED_POOL);
    if (TerminationPort == NULL) {
        ObDereferenceObject (Port);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    TerminationPort->Port = Port;
    TerminationPort->Next = Thread->TerminationPort;

    Thread->TerminationPort = TerminationPort;

    return STATUS_SUCCESS;
}

LARGE_INTEGER
PsGetProcessExitTime(
    VOID
    )

/*++

Routine Description:

    This routine returns the exit time for the current process.

Arguments:

    None.

Return Value:

    The function value is the exit time for the current process.

Note:

    This routine assumes that the caller wants an error log entry within the
    bounds of the maximum size.

--*/

{
    PAGED_CODE();

    //
    // Simply return the exit time for this process.
    //

    return PsGetCurrentProcess()->ExitTime;
}


#undef PsIsThreadTerminating

BOOLEAN
PsIsThreadTerminating(
    __in PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns TRUE if the specified thread is in the process of
    terminating.

Arguments:

    Thread - Supplies a pointer to the thread to be checked for termination.

Return Value:

    TRUE is returned if the thread is terminating, else FALSE is returned.

--*/

{
    //
    // Simply return whether or not the thread is in the process of terminating.
    //

    if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) {
        return TRUE;
    } else {
        return FALSE;
    }
}



NTSTATUS
PspFreezeProcessWorker (
    PEPROCESS Process,
    PVOID Context
    )
/*++

Routine Description:

    This function is the enumeration worker to suspend all processes.

Arguments:

    Process - Current process being enumerated
    Context - Unused context value

Return Value:

    NTSTATUS - Always returns true to continue enumeration

--*/
{

    UNREFERENCED_PARAMETER (Context);

    if (Process != PsInitialSystemProcess &&
        Process != PsIdleProcess &&
        Process != ExpDefaultErrorPortProcess) {

        if (Process->ExceptionPort != NULL) {
            LpcDisconnectPort (Process->ExceptionPort);
        }
        if ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) == 0) {
            PsSuspendProcess (Process);
        }
    }

    return STATUS_SUCCESS;
}

BOOLEAN PsContinueWaiting = FALSE;


LOGICAL
PsShutdownSystem (
    VOID
  )
/*++

Routine Description:

    This function shuts down ps, killing all non-system threads.

Arguments:

    None.

Return Value:

    Returns TRUE if all processes were terminated, FALSE if not.

--*/

{
    PEPROCESS     Process;
    PETHREAD      Thread;
    ULONG         NumProcs;
    ULONG         i;
    ULONG         MaxPasses;
    NTSTATUS      Status;
    LARGE_INTEGER Timeout = {(ULONG)(-10 * 1000 * 1000 * 100), -1};
    LOGICAL       Retval;

#define WAIT_BATCH THREAD_WAIT_OBJECTS
    PKPROCESS     WaitProcs[WAIT_BATCH];
    BOOLEAN       First;

    PAGED_CODE();

    Retval = TRUE;
    //
    // Some processes wait for other processes to die and then initiate actions.
    // Killing all processes without letting any execute any usermode code
    // prevents any unwanted initiated actions.
    //

    Thread = PsGetCurrentThread();

    if (InterlockedCompareExchangePointer(&PspShutdownThread,
                                          Thread,
                                          0) != 0) {
        // Some other thread is already in shutdown -- bail
        return FALSE;
    }

    PsEnumProcesses (PspFreezeProcessWorker, NULL);


    //
    // This loop kills all the processes and then waits for one of a subset
    // of them to die.  They must all be killed first (before any can be waited
    // on) so that any process like a debuggee that is waiting for a debugger
    // won't stall us.
    //
    // Driver unload won't occur until the last handle goes away for a device.
    //

    MaxPasses = 0;
    First = TRUE;
    do {
        NumProcs = 0;

        Status = STATUS_SUCCESS;
        for (Process = PsGetNextProcess (NULL);
             Process != NULL;
             Process = PsGetNextProcess (Process)) {

            if (Process != PsInitialSystemProcess &&
                Process != PsIdleProcess &&
                Process != ExpDefaultErrorPortProcess) {

                ASSERT (MmGetSessionId (Process) == 0);

                Status = PsTerminateProcess (Process,
                                             STATUS_SYSTEM_SHUTDOWN);

                //
                // If there is space save the referenced process away so
                // we can wait on it.  Don't wait on processes with no
                // threads as they will only exit when the last handle goes.
                //

                if ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) == 0 &&
                    Status != STATUS_NOTHING_TO_TERMINATE &&
                    NumProcs < WAIT_BATCH) {

                    ObReferenceObject (Process);
                    WaitProcs[NumProcs++] = &Process->Pcb;
                }
            }
        }
        First = FALSE;

        //
        // Wait for one of a small set of the processes to exit.
        //

        if (NumProcs != 0) {
            Status = KeWaitForMultipleObjects (NumProcs,
                                               WaitProcs,
                                               WaitAny,
                                               Executive,
                                               KernelMode,
                                               FALSE,
                                               &Timeout,
                                               NULL);

           for (i = 0; i < NumProcs; i++) {
               Process = CONTAINING_RECORD(WaitProcs[i],
                                           EPROCESS,
                                           Pcb);

               ObDereferenceObject (Process);
           }
        }

        //
        // Don't let an unkillable process stop shutdown from finishing.
        // ASSERT on checked builds so the faulty component causing this
        // can be debugged and fixed.
        //
        if (NumProcs > 0 && Status == STATUS_TIMEOUT) {
            MaxPasses += 1;
            if (MaxPasses > 10) {
                ASSERT (FALSE);
                if (!PsContinueWaiting) {
                    Retval = FALSE;
                    break;
                }
            }
        } else {
            MaxPasses = 0;
        }

    } while (NumProcs > 0);

    if (PoCleanShutdownEnabled()  && ExpDefaultErrorPortProcess) {
        // Explicitly kill csrss -- we don't want to do this in the loop,
        // because we don't want to wait on it, because it has system
        // threads which will exit later.  But we can terminate the user
        // threads, now that everything else has died (we can't terminate
        // them earlier, because DestroyWindowStation()/TerminateConsole()
        // depends on them being around).

        PsTerminateProcess(ExpDefaultErrorPortProcess,
                           STATUS_SYSTEM_SHUTDOWN);

        // Now, make sure that csrss's usermode threads have gotten a
        // chance to terminate.
        PspWaitForUsermodeExit(ExpDefaultErrorPortProcess);
    }

    // And we're done.

    PspShutdownJobLimits();
    MmUnmapViewOfSection(PsInitialSystemProcess, PspSystemDll.DllBase);
    ObDereferenceObject(PspSystemDll.Section);
    ZwClose(PspInitialSystemProcessHandle);
    PspInitialSystemProcessHandle = NULL;

    // Disconnect the system process's LSA security port
    if (PsInitialSystemProcess->SecurityPort) {
        if (PsInitialSystemProcess->SecurityPort != ((PVOID) 1 ))
        {
            ObDereferenceObject(PsInitialSystemProcess->SecurityPort);

            PsInitialSystemProcess->SecurityPort = (PVOID) 1 ;
        }

    }

    return Retval;
}

BOOLEAN
PsWaitForAllProcesses (
    VOID)
/*++

Routine Description:

    This function waits for all the processes to terminate.

Arguments:

    None.

Return Value:

    Returns TRUE if all processes were terminated, FALSE if not.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Timeout = {(ULONG)-(100 * 1000), -1};
    ULONG MaxPasses;
    BOOLEAN Wait;
    PEPROCESS Process;
    PEPROCESS WaitProcess=NULL;

    MaxPasses = 0;
    while (1) {
        Wait = FALSE;
        for (Process = PsGetNextProcess (NULL);
             Process != NULL;
             Process = PsGetNextProcess (Process)) {

            if (Process != PsInitialSystemProcess &&
                Process != PsIdleProcess &&
                (Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) != 0) {
                if (Process->ObjectTable != NULL) {
                    Wait = TRUE;
                    WaitProcess = Process;
                    ObReferenceObject (WaitProcess);
                    PsQuitNextProcess (WaitProcess);
                    break;
                }
            }
        }

        if (Wait) {
            Status = KeWaitForSingleObject (WaitProcess,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            &Timeout);

            ObDereferenceObject (WaitProcess);

            if (Status == STATUS_TIMEOUT) {
                MaxPasses += 1;
                Timeout.QuadPart *= 2;
                if (MaxPasses > 13) {
                    KdPrint (("PS: %d process left in the system after termination\n",
                             PsProcessType->TotalNumberOfObjects));
                    return FALSE;
                }
            }
        } else {
            return TRUE;
        }
    }

    return TRUE;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psimpers.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psimpers.c

Abstract:

    This module implements the NtImpersonateThread() service.

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtImpersonateThread)
#endif //ALLOC_PRAGMA


NTSTATUS
NtImpersonateThread(
    __in HANDLE ServerThreadHandle,
    __in HANDLE ClientThreadHandle,
    __in PSECURITY_QUALITY_OF_SERVICE SecurityQos
    )

/*++

Routine Description:

    This routine is used to cause the server thread to impersonate the client
    thread.  The impersonation is done according to the specified quality
    of service parameters.



Arguments:

    ServerThreadHandle - Is a handle to the server thread (the impersonator, or
        doing the impersonation).  This handle must be open for
        THREAD_IMPERSONATE access.

    ClientThreadHandle - Is a handle to the Client thread (the impersonatee, or
        one being impersonated).   This handle must be open for
        THREAD_DIRECT_IMPERSONATION access.


    SecurityQos - A pointer to security quality of service information
        indicating what form of impersonation is to be performed.



Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.


--*/

{


    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD ClientThread, ServerThread;
    SECURITY_QUALITY_OF_SERVICE CapturedQos;
    SECURITY_CLIENT_CONTEXT ClientSecurityContext;

    //
    // Get previous processor mode and probe and capture arguments if necessary
    //

    PreviousMode = KeGetPreviousMode();

    try {

        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (SecurityQos,
                                        sizeof (SECURITY_QUALITY_OF_SERVICE),
                                        sizeof (ULONG));
        }
        CapturedQos = *SecurityQos;

    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }



    //
    // Reference the client thread, checking for appropriate access.
    //

    Status = ObReferenceObjectByHandle (ClientThreadHandle,           // Handle
                                        THREAD_DIRECT_IMPERSONATION,  // DesiredAccess
                                        PsThreadType,                 // ObjectType
                                        PreviousMode,                 // AccessMode
                                        &ClientThread,                // Object
                                        NULL);                        // GrantedAccess

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Reference the client thread, checking for appropriate access.
    //

    Status = ObReferenceObjectByHandle (ServerThreadHandle,           // Handle
                                        THREAD_IMPERSONATE,           // DesiredAccess
                                        PsThreadType,                 // ObjectType
                                        PreviousMode,                 // AccessMode
                                        &ServerThread,                // Object
                                        NULL);                        // GrantedAccess

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (ClientThread);
        return Status;
    }


    //
    // Get the client's security context
    //

    Status = SeCreateClientSecurity (ClientThread,             // ClientThread
                                     &CapturedQos,             // SecurityQos
                                     FALSE,                    // ServerIsRemote
                                     &ClientSecurityContext);  // ClientContext

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (ServerThread);
        ObDereferenceObject (ClientThread);
        return Status;
    }


    //
    // Impersonate the client
    //

    Status = SeImpersonateClientEx (&ClientSecurityContext, ServerThread);

    SeDeleteClientSecurity (&ClientSecurityContext);

    //
    // Done.
    //


    ObDereferenceObject (ServerThread);
    ObDereferenceObject (ClientThread);

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psinit.c

Abstract:

    Process Structure Initialization.

--*/

#include "psp.h"

extern ULONG PsMinimumWorkingSet;
extern ULONG PsMaximumWorkingSet;

#ifdef ALLOC_DATA_PRAGMA

#pragma const_seg("PAGECONST")
#pragma data_seg("PAGEDATA")

#endif

#define NTDLL_PATH_NAME L"\\SystemRoot\\System32\\ntdll.dll"
const UNICODE_STRING PsNtDllPathName = {
	sizeof(NTDLL_PATH_NAME) - sizeof(UNICODE_NULL),
	sizeof(NTDLL_PATH_NAME),
	NTDLL_PATH_NAME
};

ULONG PsPrioritySeparation; // nonpaged
BOOLEAN PspUseJobSchedulingClasses = FALSE;
PACCESS_TOKEN PspBootAccessToken = NULL;
HANDLE PspInitialSystemProcessHandle = NULL;
PHANDLE_TABLE PspCidTable; // nonpaged
SYSTEM_DLL PspSystemDll = {NULL};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#pragma data_seg("INITDATA")
#endif
ULONG PsRawPrioritySeparation = 0;
ULONG PsEmbeddedNTMask = 0;

NTSTATUS
LookupEntryPoint (
    IN PVOID DllBase,
    IN PSZ NameOfEntryPoint,
    OUT PVOID *AddressOfEntryPoint
    );

const GENERIC_MAPPING PspProcessMapping = {
    STANDARD_RIGHTS_READ |
        PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
    STANDARD_RIGHTS_WRITE |
        PROCESS_CREATE_PROCESS | PROCESS_CREATE_THREAD |
        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_DUP_HANDLE |
        PROCESS_TERMINATE | PROCESS_SET_QUOTA |
        PROCESS_SET_INFORMATION | PROCESS_SET_PORT,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    PROCESS_ALL_ACCESS
};

const GENERIC_MAPPING PspThreadMapping = {
    STANDARD_RIGHTS_READ |
        THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION,
    STANDARD_RIGHTS_WRITE |
        THREAD_TERMINATE | THREAD_SUSPEND_RESUME | THREAD_ALERT |
        THREAD_SET_INFORMATION | THREAD_SET_CONTEXT,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    THREAD_ALL_ACCESS
};

const GENERIC_MAPPING PspJobMapping = {
    STANDARD_RIGHTS_READ |
        JOB_OBJECT_QUERY,
    STANDARD_RIGHTS_WRITE |
        JOB_OBJECT_ASSIGN_PROCESS | JOB_OBJECT_SET_ATTRIBUTES | JOB_OBJECT_TERMINATE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    THREAD_ALL_ACCESS
};

#ifdef ALLOC_DATA_PRAGMA

#pragma data_seg()
#pragma const_seg("PAGECONST")

#endif

#pragma alloc_text(INIT, PsInitSystem)
#pragma alloc_text(INIT, PspInitPhase0)
#pragma alloc_text(INIT, PspInitPhase1)
#pragma alloc_text(INIT, PspInitializeSystemDll)
#pragma alloc_text(INIT, PspLookupSystemDllEntryPoint)
#pragma alloc_text(INIT, PspNameToOrdinal)
#pragma alloc_text(PAGE, PsLocateSystemDll)
#pragma alloc_text(PAGE, PsMapSystemDll)
#pragma alloc_text(PAGE, PsChangeQuantumTable)

//
// Process Structure Global Data
//

POBJECT_TYPE PsThreadType;
POBJECT_TYPE PsProcessType;
PEPROCESS PsInitialSystemProcess;
PVOID PsSystemDllDllBase;
ULONG PspDefaultPagedLimit;
ULONG PspDefaultNonPagedLimit;
ULONG PspDefaultPagefileLimit;
SCHAR PspForegroundQuantum[3];

EPROCESS_QUOTA_BLOCK PspDefaultQuotaBlock;
BOOLEAN PspDoingGiveBacks;
POBJECT_TYPE PsJobType;
KGUARDED_MUTEX PspJobListLock;
KSPIN_LOCK PspQuotaLock;
LIST_ENTRY PspJobList;

SINGLE_LIST_ENTRY PsReaperListHead;
WORK_QUEUE_ITEM PsReaperWorkItem;
PVOID PsSystemDllBase;
#define PSP_1MB (1024*1024)

//
// List head and mutex that links all processes that have been initialized
//

KGUARDED_MUTEX PspActiveProcessMutex;
LIST_ENTRY PsActiveProcessHead;
PEPROCESS PsIdleProcess;
PETHREAD PspShutdownThread;

BOOLEAN
PsInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function performs process structure initialization.
    It is called during phase 0 and phase 1 initialization. Its
    function is to dispatch to the appropriate phase initialization
    routine.

Arguments:

    Phase - Supplies the initialization phase number.

    LoaderBlock - Supplies a pointer to a loader parameter block.

Return Value:

    TRUE - Initialization succeeded.

    FALSE - Initialization failed.

--*/

{
    UNREFERENCED_PARAMETER (Phase);

    switch (InitializationPhase) {

    case 0 :
        return PspInitPhase0(LoaderBlock);
    case 1 :
        return PspInitPhase1(LoaderBlock);
    default:
        KeBugCheckEx(UNEXPECTED_INITIALIZATION_CALL, 1, InitializationPhase, 0, 0);
    }
}

BOOLEAN
PspInitPhase0 (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine performs phase 0 process structure initialization.
    During this phase, the initial system process, phase 1 initialization
    thread, and reaper threads are created. All object types and other
    process structures are created and initialized.

Arguments:

    None.

Return Value:

    TRUE - Initialization was successful.

    FALSE - Initialization Failed.

--*/

{

    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    HANDLE ThreadHandle;
    PETHREAD Thread;
    MM_SYSTEMSIZE SystemSize;
    ULONG i;
#if DBG
    NTSTATUS Status;
#endif

    SystemSize = MmQuerySystemSize ();
    PspDefaultPagefileLimit = (ULONG)-1;

#ifdef _WIN64
    if (sizeof (TEB) > 8192 || sizeof (PEB) > 4096) {
#else
    if (sizeof (TEB) > 4096 || sizeof (PEB) > 4096) {
#endif
        KeBugCheckEx (PROCESS_INITIALIZATION_FAILED, 99, sizeof (TEB), sizeof (PEB), 99);
    }

    switch (SystemSize) {

        case MmMediumSystem :
            PsMinimumWorkingSet += 10;
            PsMaximumWorkingSet += 100;
            break;

        case MmLargeSystem :
            PsMinimumWorkingSet += 30;
            PsMaximumWorkingSet += 300;
            break;

        case MmSmallSystem :
        default:
            break;
    }

    //
    // Initialize all the callback structures
    //

    for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
        ExInitializeCallBack (&PspCreateThreadNotifyRoutine[i]);
    }

    for (i = 0; i < PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {
        ExInitializeCallBack (&PspCreateProcessNotifyRoutine[i]);
    }

    for (i = 0; i < PSP_MAX_LOAD_IMAGE_NOTIFY; i++) {
        ExInitializeCallBack (&PspLoadImageNotifyRoutine[i]);
    }


    PsChangeQuantumTable (FALSE, PsRawPrioritySeparation);

    //
    // Quotas grow as needed automatically
    //

    if (PspDefaultNonPagedLimit == 0 && PspDefaultPagedLimit == 0) {
        PspDoingGiveBacks = TRUE;
    } else {
        PspDoingGiveBacks = FALSE;
    }


    PspDefaultPagedLimit *= PSP_1MB;
    PspDefaultNonPagedLimit *= PSP_1MB;

    if (PspDefaultPagefileLimit != -1) {
        PspDefaultPagefileLimit *= PSP_1MB;
    }


    //
    // Initialize active process list head and mutex
    //

    InitializeListHead (&PsActiveProcessHead);

    PspInitializeProcessListLock ();

    //
    // Initialize the process security fields lock
    //


    PsIdleProcess = PsGetCurrentProcess();

    PspInitializeProcessLock (PsIdleProcess);
    ExInitializeRundownProtection (&PsIdleProcess->RundownProtect);
    InitializeListHead (&PsIdleProcess->ThreadListHead);


    PsIdleProcess->Pcb.KernelTime = 0;
    PsIdleProcess->Pcb.KernelTime = 0;

    //
    // Initialize the shutdown thread pointer
    //
    PspShutdownThread = NULL;

    //
    // Initialize the common fields of the Object Type Prototype record
    //

    RtlZeroMemory (&ObjectTypeInitializer, sizeof (ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof (ObjectTypeInitializer);
    ObjectTypeInitializer.SecurityRequired = TRUE;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.InvalidAttributes = OBJ_PERMANENT |
                                              OBJ_EXCLUSIVE |
                                              OBJ_OPENIF;


    //
    // Create Object types for Thread and Process Objects.
    //

    RtlInitUnicodeString (&NameString, L"Process");
    ObjectTypeInitializer.DefaultPagedPoolCharge = PSP_PROCESS_PAGED_CHARGE;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = PSP_PROCESS_NONPAGED_CHARGE;
    ObjectTypeInitializer.DeleteProcedure = PspProcessDelete;
    ObjectTypeInitializer.ValidAccessMask = PROCESS_ALL_ACCESS;
    ObjectTypeInitializer.GenericMapping = PspProcessMapping;

    if (!NT_SUCCESS (ObCreateObjectType (&NameString,
                                         &ObjectTypeInitializer,
                                         (PSECURITY_DESCRIPTOR) NULL,
                                         &PsProcessType))) {
        return FALSE;
    }

    RtlInitUnicodeString (&NameString, L"Thread");
    ObjectTypeInitializer.DefaultPagedPoolCharge = PSP_THREAD_PAGED_CHARGE;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = PSP_THREAD_NONPAGED_CHARGE;
    ObjectTypeInitializer.DeleteProcedure = PspThreadDelete;
    ObjectTypeInitializer.ValidAccessMask = THREAD_ALL_ACCESS;
    ObjectTypeInitializer.GenericMapping = PspThreadMapping;

    if (!NT_SUCCESS (ObCreateObjectType (&NameString,
                                         &ObjectTypeInitializer,
                                         (PSECURITY_DESCRIPTOR) NULL,
                                         &PsThreadType))) {
        return FALSE;
    }


    RtlInitUnicodeString (&NameString, L"Job");
    ObjectTypeInitializer.DefaultPagedPoolCharge = 0;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof (EJOB);
    ObjectTypeInitializer.DeleteProcedure = PspJobDelete;
    ObjectTypeInitializer.CloseProcedure = PspJobClose;
    ObjectTypeInitializer.ValidAccessMask = JOB_OBJECT_ALL_ACCESS;
    ObjectTypeInitializer.GenericMapping = PspJobMapping;
    ObjectTypeInitializer.InvalidAttributes = 0;

    if (!NT_SUCCESS (ObCreateObjectType (&NameString,
                                         &ObjectTypeInitializer,
                                         (PSECURITY_DESCRIPTOR) NULL,
                                         &PsJobType))) {
        return FALSE;
    }


    //
    // Initialize job list head and mutex
    //

    PspInitializeJobStructures ();
    
    InitializeListHead (&PspWorkingSetChangeHead.Links);

    PspInitializeWorkingSetChangeLock ();

    //
    // Initialize CID handle table.
    //
    // N.B. The CID handle table is removed from the handle table list so
    //      it will not be enumerated for object handle queries.
    //

    PspCidTable = ExCreateHandleTable (NULL);
    if (PspCidTable == NULL) {
        return FALSE;
    }

    //
    // Set PID and TID reuse to strict FIFO. This isn't absolutely needed but
    // it makes tracking audits easier.
    //
    ExSetHandleTableStrictFIFO (PspCidTable);

    ExRemoveHandleTable (PspCidTable);

#if defined(i386)

    //
    // Ldt Initialization
    //

    if ( !NT_SUCCESS (PspLdtInitialize ()) ) {
        return FALSE;
    }

    //
    // Vdm support Initialization
    //

    if (!NT_SUCCESS (PspVdmInitialize ())) {
        return FALSE;
    }

#endif

    //
    // Initialize Reaper Data Structures
    //

    PsReaperListHead.Next = NULL;

    ExInitializeWorkItem (&PsReaperWorkItem, PspReaper, NULL);

    //
    // Get a pointer to the system access token.
    // This token is used by the boot process, so we can take the pointer
    // from there.
    //

    PspBootAccessToken = ExFastRefGetObject (PsIdleProcess->Token);

    InitializeObjectAttributes (&ObjectAttributes,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!NT_SUCCESS (PspCreateProcess (&PspInitialSystemProcessHandle,
                                       PROCESS_ALL_ACCESS,
                                       &ObjectAttributes,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0))) {
        return FALSE;
    }

    if (!NT_SUCCESS (ObReferenceObjectByHandle (PspInitialSystemProcessHandle,
                                                0L,
                                                PsProcessType,
                                                KernelMode,
                                                &PsInitialSystemProcess,
                                                NULL))) {

        return FALSE;
    }

    strcpy((char *) &PsIdleProcess->ImageFileName[0], "Idle");
    strcpy((char *) &PsInitialSystemProcess->ImageFileName[0], "System");

    //
    // The system process can allocate resources, and its name may be queried by 
    // NtQueryInfomationProcess and various audits.  We must explicitly allocate memory 
    // for this field of the System EPROCESS, and initialize it appropriately.  In this 
    // case, appropriate initialization means zeroing the memory.
    //

    PsInitialSystemProcess->SeAuditProcessCreationInfo.ImageFileName =
        ExAllocatePoolWithTag (PagedPool, 
                               sizeof(OBJECT_NAME_INFORMATION), 
                               'aPeS');

    if (PsInitialSystemProcess->SeAuditProcessCreationInfo.ImageFileName != NULL) {
        RtlZeroMemory (PsInitialSystemProcess->SeAuditProcessCreationInfo.ImageFileName, 
                       sizeof (OBJECT_NAME_INFORMATION));
    } else {
        return FALSE;
    }

    //
    // Phase 1 System initialization
    //

    if (!NT_SUCCESS (PsCreateSystemThread (&ThreadHandle,
                                           THREAD_ALL_ACCESS,
                                           &ObjectAttributes,
                                           0L,
                                           NULL,
                                           Phase1Initialization,
                                           (PVOID)LoaderBlock))) {
        return FALSE;
    }


    if (!NT_SUCCESS (ObReferenceObjectByHandle (ThreadHandle,
                                                0L,
                                                PsThreadType,
                                                KernelMode,
                                                &Thread,
                                                NULL))) {
        return FALSE;
    }

    ZwClose (ThreadHandle);

//
// On checked systems install an image callout routine
//
#if DBG

    Status = PsSetLoadImageNotifyRoutine (PspImageNotifyTest);
    if (!NT_SUCCESS (Status)) {
        return FALSE;
    }

#endif

    return TRUE;
}

BOOLEAN
PspInitPhase1 (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine performs phase 1 process structure initialization.
    During this phase, the system DLL is located and relevant entry
    points are extracted.

Arguments:

    None.

Return Value:

    TRUE - Initialization was successful.

    FALSE - Initialization Failed.

--*/

{

    NTSTATUS st;

    UNREFERENCED_PARAMETER (LoaderBlock);

    PspInitializeJobStructuresPhase1 ();

    st = PspInitializeSystemDll ();

    if (!NT_SUCCESS (st)) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
PsLocateSystemDll (
    BOOLEAN ReplaceExisting
    )

/*++

Routine Description:

    This function locates the system dll and creates a section for the
    DLL and maps it into the system process.

Arguments:

    None.

Return Value:

    TRUE - Initialization was successful.

    FALSE - Initialization Failed.

--*/

{

    HANDLE File;
    HANDLE Section;
    NTSTATUS st;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    PVOID NtDllSection;

    //
    // First see if we need to load this DLL at all.
    //
    if (ExVerifySuite (EmbeddedNT) && (PsEmbeddedNTMask&PS_EMBEDDED_NO_USERMODE)) {
        return STATUS_SUCCESS;
    }

    if (!ReplaceExisting) {

        ExInitializePushLock(&PspSystemDll.DllLock);
    }

    //
    // Initialize the system DLL
    //

    InitializeObjectAttributes (&ObjectAttributes,
                                (PUNICODE_STRING) &PsNtDllPathName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    st = ZwOpenFile (&File,
                     SYNCHRONIZE | FILE_EXECUTE,
                     &ObjectAttributes,
                     &IoStatus,
                     FILE_SHARE_READ,
                     0);

    if (!NT_SUCCESS (st)) {

#if DBG
        DbgPrint("PS: PsLocateSystemDll - NtOpenFile( NTDLL.DLL ) failed.  Status == %lx\n",
                 st);
#endif
        if (ReplaceExisting) {
            return st;
        }

        KeBugCheckEx (PROCESS1_INITIALIZATION_FAILED, st, 2, 0, 0);
    }

    st = MmCheckSystemImage (File, TRUE);

    if (st == STATUS_IMAGE_CHECKSUM_MISMATCH ||
        st == STATUS_INVALID_IMAGE_PROTECT) {

        ULONG_PTR ErrorParameters;
        ULONG ErrorResponse;

        //
        // Hard error time. A driver is corrupt.
        //

        ErrorParameters = (ULONG_PTR)&PsNtDllPathName;

        NtRaiseHardError (st,
                          1,
                          1,
                          &ErrorParameters,
                          OptionOk,
                          &ErrorResponse);
        return st;
    }

    st = ZwCreateSection (&Section,
                          SECTION_ALL_ACCESS,
                          NULL,
                          0,
                          PAGE_EXECUTE,
                          SEC_IMAGE,
                          File);
    ZwClose (File);

    if (!NT_SUCCESS (st)) {
#if DBG
        DbgPrint("PS: PsLocateSystemDll: NtCreateSection Status == %lx\n",st);
#endif
        if (ReplaceExisting) {
            return st;
        }
        KeBugCheckEx (PROCESS1_INITIALIZATION_FAILED, st, 3, 0, 0);
    }

    //
    // Now that we have the section, reference it, store its address in the
    // PspSystemDll and then close handle to the section.
    //

    st = ObReferenceObjectByHandle (Section,
                                    SECTION_ALL_ACCESS,
                                    MmSectionObjectType,
                                    KernelMode,
                                    &NtDllSection,
                                    NULL);

    ZwClose (Section);

    if (!NT_SUCCESS (st)) {
        
        if (ReplaceExisting) {
            return st;
        }
        KeBugCheckEx(PROCESS1_INITIALIZATION_FAILED,st,4,0,0);
    }

    if (ReplaceExisting) {

        PVOID ExistingSection;

        KeEnterCriticalRegion();
        ExAcquirePushLockExclusive(&PspSystemDll.DllLock);

        ExistingSection = PspSystemDll.Section;

        PspSystemDll.Section = NtDllSection;

        ExReleasePushLockExclusive(&PspSystemDll.DllLock);
        KeLeaveCriticalRegion();

        if (ExistingSection) {
            
            ObDereferenceObject(ExistingSection);
        }

    } else {
        
        PspSystemDll.Section = NtDllSection;

        //
        // Map the system dll into the user part of the address space
        //

        st = PsMapSystemDll (PsGetCurrentProcess (), &PspSystemDll.DllBase, FALSE);
        PsSystemDllDllBase = PspSystemDll.DllBase;

        if (!NT_SUCCESS (st)) {
            KeBugCheckEx (PROCESS1_INITIALIZATION_FAILED, st, 5, 0, 0);
        }
        PsSystemDllBase = PspSystemDll.DllBase;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PsMapSystemDll (
    IN PEPROCESS Process,
    OUT PVOID *DllBase OPTIONAL,
    IN LOGICAL UseLargePages
    )

/*++

Routine Description:

    This function maps the system DLL into the specified process.

Arguments:

    Process - Supplies the address of the process to map the DLL into.

    DllBase - Receives a pointer to the base address of the system DLL.

    UseLargePages - Attempt the map using large pages. If this fails,
        the map is automatically performed using small pages.

--*/

{
    NTSTATUS st;
    PVOID ViewBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    PVOID CapturedSection;

    PAGED_CODE();

    ViewBase = NULL;
    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    
    KeEnterCriticalRegion();
    ExAcquirePushLockShared(&PspSystemDll.DllLock);

    CapturedSection = PspSystemDll.Section;
    ObReferenceObject(CapturedSection);
    
    ExReleasePushLockShared(&PspSystemDll.DllLock);
    KeLeaveCriticalRegion();

    //
    // Map the system dll into the user part of the address space
    //

    st = MmMapViewOfSection(
            CapturedSection,
            Process,
            &ViewBase,
            0L,
            0L,
            &SectionOffset,
            &ViewSize,
            ViewShare,
            (UseLargePages ? MEM_LARGE_PAGES : 0L),
            PAGE_READWRITE
            );
    
    ObDereferenceObject(CapturedSection);

    if (st != STATUS_SUCCESS) {
#if DBG
        DbgPrint("PS: Unable to map system dll at based address.\n");
#endif
        st = STATUS_CONFLICTING_ADDRESSES;
    }

    if (ARGUMENT_PRESENT (DllBase)) {
        *DllBase = ViewBase;
    }

    return st;
}

NTSTATUS
PspInitializeSystemDll (
    VOID
    )

/*++

Routine Description:

    This function initializes the system DLL and locates
    various entrypoints within the DLL.

Arguments:

    None.

--*/

{
    NTSTATUS st;
    PSZ dll_entrypoint;

    //
    // If we skipped dll load because we are kernel only then exit now.
    //
    if (PsSystemDllDllBase == NULL) {
        return STATUS_SUCCESS;
    }
    //
    // Locate the important system dll entrypoints
    //

    dll_entrypoint = "LdrInitializeThunk";

    st = PspLookupSystemDllEntryPoint (dll_entrypoint,
                                       (PVOID) &PspSystemDll.LoaderInitRoutine);

    if (!NT_SUCCESS (st)) {
#if DBG
        DbgPrint("PS: Unable to locate LdrInitializeThunk in system dll\n");
#endif
        KeBugCheckEx (PROCESS1_INITIALIZATION_FAILED, st, 6, 0, 0);
    }


    st = PspLookupKernelUserEntryPoints ();

    if ( !NT_SUCCESS (st)) {
        KeBugCheckEx(PROCESS1_INITIALIZATION_FAILED,st,8,0,0);
     }

    KdUpdateDataBlock ();

    return st;
}

NTSTATUS
PspLookupSystemDllEntryPoint (
    IN PSZ NameOfEntryPoint,
    OUT PVOID *AddressOfEntryPoint
    )

{
    return LookupEntryPoint (PspSystemDll.DllBase,
                             NameOfEntryPoint,
                             AddressOfEntryPoint);
}

const SCHAR PspFixedQuantums[6] = {3*THREAD_QUANTUM,
                                   3*THREAD_QUANTUM,
                                   3*THREAD_QUANTUM,
                                   6*THREAD_QUANTUM,
                                   6*THREAD_QUANTUM,
                                   6*THREAD_QUANTUM};

const SCHAR PspVariableQuantums[6] = {1*THREAD_QUANTUM,
                                      2*THREAD_QUANTUM,
                                      3*THREAD_QUANTUM,
                                      2*THREAD_QUANTUM,
                                      4*THREAD_QUANTUM,
                                      6*THREAD_QUANTUM};

//
// The table is ONLY used when fixed quantums are selected.
//

const SCHAR PspJobSchedulingClasses[PSP_NUMBER_OF_SCHEDULING_CLASSES] = {1*THREAD_QUANTUM,   // long fixed 0
                                                                         2*THREAD_QUANTUM,   // long fixed 1...
                                                                         3*THREAD_QUANTUM,
                                                                         4*THREAD_QUANTUM,
                                                                         5*THREAD_QUANTUM,
                                                                         6*THREAD_QUANTUM,   // DEFAULT
                                                                         7*THREAD_QUANTUM,
                                                                         8*THREAD_QUANTUM,
                                                                         9*THREAD_QUANTUM,
                                                                         10*THREAD_QUANTUM};   // long fixed 9

VOID
PsChangeQuantumTable (
    BOOLEAN ModifyActiveProcesses,
    ULONG PrioritySeparation
    )
{

    PEPROCESS Process;
    PETHREAD CurrentThread;
    PLIST_ENTRY NextProcess;
    ULONG QuantumIndex;
    SCHAR QuantumReset;
    SCHAR const* QuantumTableBase;
    PEJOB Job;

    //
    // extract priority separation value
    //
    switch (PrioritySeparation & PROCESS_PRIORITY_SEPARATION_MASK) {
    case 3:
        PsPrioritySeparation = PROCESS_PRIORITY_SEPARATION_MAX;
        break;

    default:
        PsPrioritySeparation = PrioritySeparation & PROCESS_PRIORITY_SEPARATION_MASK;
        break;
    }

    //
    // determine if we are using fixed or variable quantums
    //

    switch (PrioritySeparation & PROCESS_QUANTUM_VARIABLE_MASK) {
    case PROCESS_QUANTUM_VARIABLE_VALUE:
        QuantumTableBase = PspVariableQuantums;
        break;

    case PROCESS_QUANTUM_FIXED_VALUE:
        QuantumTableBase = PspFixedQuantums;
        break;

    case PROCESS_QUANTUM_VARIABLE_DEF:
    default:
        if (MmIsThisAnNtAsSystem ()) {
            QuantumTableBase = PspFixedQuantums;

        } else {
            QuantumTableBase = PspVariableQuantums;
        }

        break;
    }

    //
    // determine if we are using long or short
    //
    switch (PrioritySeparation & PROCESS_QUANTUM_LONG_MASK) {
    case PROCESS_QUANTUM_LONG_VALUE:
        QuantumTableBase = QuantumTableBase + 3;
        break;

    case PROCESS_QUANTUM_SHORT_VALUE:
        break;

    case PROCESS_QUANTUM_LONG_DEF:
    default:
        if (MmIsThisAnNtAsSystem ()) {
            QuantumTableBase = QuantumTableBase + 3;
        }

        break;
    }

    //
    // Job Scheduling classes are ONLY meaningful if long fixed quantums
    // are selected. In practice, this means stock NTS configurations
    //

    if (QuantumTableBase == &PspFixedQuantums[3]) {
        PspUseJobSchedulingClasses = TRUE;

    } else {
        PspUseJobSchedulingClasses = FALSE;
    }

    RtlCopyMemory (PspForegroundQuantum, QuantumTableBase, sizeof(PspForegroundQuantum));
    if (ModifyActiveProcesses) {
        CurrentThread = PsGetCurrentThread ();
        PspLockProcessList (CurrentThread);
        NextProcess = PsActiveProcessHead.Flink;
        while (NextProcess != &PsActiveProcessHead) {
            Process = CONTAINING_RECORD(NextProcess,
                                        EPROCESS,
                                        ActiveProcessLinks);

            if (Process->Vm.Flags.MemoryPriority == MEMORY_PRIORITY_BACKGROUND) {
                QuantumIndex = 0;
            } else {
                QuantumIndex = PsPrioritySeparation;
            }

            if (Process->PriorityClass != PROCESS_PRIORITY_CLASS_IDLE) {

                //
                // If the process is contained within a JOB, AND we are
                // running Fixed, Long Quantums, use the quantum associated
                // with the Job's scheduling class
                //

                Job = Process->Job;
                if (Job != NULL && PspUseJobSchedulingClasses) {
                    QuantumReset = PspJobSchedulingClasses[Job->SchedulingClass];

                } else {
                    QuantumReset = PspForegroundQuantum[QuantumIndex];
                }

            } else {
                QuantumReset = THREAD_QUANTUM;
            }

            KeSetQuantumProcess(&Process->Pcb, QuantumReset);
            NextProcess = NextProcess->Flink;
        }

        PspUnlockProcessList (CurrentThread);
    }

    return;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psjob.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psjob.c

Abstract:

    This module implements bulk of the job object support

--*/

#include "psp.h"
#include "winerror.h"

#pragma alloc_text(INIT, PspInitializeJobStructures)
#pragma alloc_text(INIT, PspInitializeJobStructuresPhase1)

#pragma alloc_text(PAGE, NtCreateJobObject)
#pragma alloc_text(PAGE, NtOpenJobObject)
#pragma alloc_text(PAGE, NtAssignProcessToJobObject)
#pragma alloc_text(PAGE, NtQueryInformationJobObject)
#pragma alloc_text(PAGE, NtSetInformationJobObject)
#pragma alloc_text(PAGE, NtTerminateJobObject)
#pragma alloc_text(PAGE, NtIsProcessInJob)
#pragma alloc_text(PAGE, NtCreateJobSet)
#pragma alloc_text(PAGE, PspJobDelete)
#pragma alloc_text(PAGE, PspJobClose)
#pragma alloc_text(PAGE, PspAddProcessToJob)
#pragma alloc_text(PAGE, PspRemoveProcessFromJob)
#pragma alloc_text(PAGE, PspExitProcessFromJob)
#pragma alloc_text(PAGE, PspApplyJobLimitsToProcessSet)
#pragma alloc_text(PAGE, PspApplyJobLimitsToProcess)
#pragma alloc_text(PAGE, PspTerminateAllProcessesInJob)
#pragma alloc_text(PAGE, PspFoldProcessAccountingIntoJob)
#pragma alloc_text(PAGE, PspCaptureTokenFilter)
#pragma alloc_text(PAGE, PsReportProcessMemoryLimitViolation)
#pragma alloc_text(PAGE, PspJobTimeLimitsWork)
#pragma alloc_text(PAGE, PsEnforceExecutionTimeLimits)
#pragma alloc_text(PAGE, PspShutdownJobLimits)
#pragma alloc_text(PAGE, PspGetJobFromSet)
#pragma alloc_text(PAGE, PsChangeJobMemoryUsage)
#pragma alloc_text(PAGE, PspWin32SessionCallout)

extern POBJECT_TYPE IoCompletionObjectType;

KDPC PspJobTimeLimitsDpc;
KTIMER PspJobTimeLimitsTimer;
WORK_QUEUE_ITEM PspJobTimeLimitsWorkItem;
KGUARDED_MUTEX PspJobTimeLimitsLock;
BOOLEAN PspJobTimeLimitsShuttingDown;

#define PSP_ONE_SECOND      (10 * (1000*1000))
#define PSP_JOB_TIME_LIMITS_TIME    -7

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
LARGE_INTEGER PspJobTimeLimitsInterval = {0};
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif


NTSTATUS
NTAPI
NtCreateJobObject (
    __out PHANDLE JobHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes
    )
{

    PEJOB Job;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a job object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);
    try {

        //
        // Probe output handle address if
        // necessary.
        //

        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (JobHandle);
        }
        *JobHandle = NULL;

    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode();
    }

    //
    // Allocate job object.
    //

    Status = ObCreateObject (PreviousMode,
                             PsJobType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (EJOB),
                             0,
                             0,
                             &Job);

    //
    // If the job object was successfully allocated, then initialize it
    // and attempt to insert the job object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {

        RtlZeroMemory (Job, sizeof (EJOB));
        InitializeListHead (&Job->ProcessListHead);
        InitializeListHead (&Job->JobSetLinks);
        KeInitializeEvent (&Job->Event, NotificationEvent, FALSE);
        PspInitializeJobLimitsLock (Job);

        //
        // Job Object gets the SessionId of the Process creating the Job
        // We will use this sessionid to restrict the processes that can
        // be added to a job.
        //
        Job->SessionId = MmGetSessionId (PsGetCurrentProcessByThread (CurrentThread));

        //
        // Initialize the scheduling class for the Job
        //
        Job->SchedulingClass = PSP_DEFAULT_SCHEDULING_CLASSES;

        ExInitializeResourceLite (&Job->JobLock);

        PspLockJobListExclusive (CurrentThread);

        InsertTailList (&PspJobList, &Job->JobLinks);

        PspUnlockJobListExclusive (CurrentThread);


        Status = ObInsertObject (Job,
                                 NULL,
                                 DesiredAccess,
                                 0,
                                 NULL,
                                 &Handle);

        //
        // If the job object was successfully inserted in the current
        // process' handle table, then attempt to write the job object
        // handle value.
        //
        if (NT_SUCCESS (Status)) {
            try {
                *JobHandle = Handle;
            } except (ExSystemExceptionFilter ()) {
                 Status = GetExceptionCode ();
            }
        }
    }
    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NTAPI
NtOpenJobObject(
    __out PHANDLE JobHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the job object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    PreviousMode = KeGetPreviousMode ();

    if (PreviousMode != KernelMode) {
        try {

            //
            // Probe output handle address
            // if necessary.
            //

            ProbeForWriteHandle (JobHandle);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // If an exception occurs during the probe of the output job handle,
            // then always handle the exception and return the exception code as the
            // status value.
            //

            return GetExceptionCode ();
        }
    }


    //
    // Open handle to the event object with the specified desired access.
    //

    Status = ObOpenObjectByName (ObjectAttributes,
                                 PsJobType,
                                 PreviousMode,
                                 NULL,
                                 DesiredAccess,
                                 NULL,
                                 &Handle);

    //
    // If the open was successful, then attempt to write the job object
    // handle value. If the write attempt fails then just report an error.
    // When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS (Status)) {
        try {
            *JobHandle = Handle;
        } except(ExSystemExceptionFilter ()) {
            return GetExceptionCode ();
        }
    }

    return Status;
}

NTSTATUS
NTAPI
NtAssignProcessToJobObject(
    __in HANDLE JobHandle,
    __in HANDLE ProcessHandle
    )
{
    PEJOB Job;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    NTSTATUS Status, Status1;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN IsAdmin;
    PACCESS_TOKEN JobToken, NewToken = NULL;
    ULONG SessionId;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    //
    // Now reference the job object. Then we need to lock the process and check again
    //

    Status = ObReferenceObjectByHandle (JobHandle,
                                        JOB_OBJECT_ASSIGN_PROCESS,
                                        PsJobType,
                                        PreviousMode,
                                        &Job,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    JobToken = Job->Token;
       
    //
    // Reference the process object, lock the process, test for already been assigned
    //

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_QUOTA | PROCESS_TERMINATE |
                                            ((JobToken != NULL)?PROCESS_SET_INFORMATION:0),
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (Job);
        return Status;
    }

    //
    // Quick Check for prior assignment
    //

    if (Process->Job) {
        Status = STATUS_ACCESS_DENIED;
        goto deref_and_return_status;
    }

    //
    // We only allow a process that is running in the Job creator's hydra session
    // to be assigned to the job.
    //

    SessionId = MmGetSessionId (Process);
    if (SessionId != Job->SessionId) {
        Status = STATUS_ACCESS_DENIED;
        goto deref_and_return_status;
    }

    //
    // Security Rules:  If the job has no-admin set, and it is running
    // as admin, that's not allowed
    //

    if (Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_NO_ADMIN) {
        PACCESS_TOKEN Token;

        Token = PsReferencePrimaryToken (Process);

        IsAdmin = SeTokenIsAdmin (Token);

        PsDereferencePrimaryTokenEx (Process, Token);

        if (IsAdmin) {
            Status = STATUS_ACCESS_DENIED;
            goto deref_and_return_status;
        }
    }

    //
    // Duplicate the primary token so we can assign it to the process.
    //
    if (JobToken != NULL) {
        Status = SeSubProcessToken (JobToken,
                                    &NewToken,
                                    FALSE,
                                    SessionId);

        if (!NT_SUCCESS (Status)) {
            goto deref_and_return_status;
        }
    }

    if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
        Status = STATUS_PROCESS_IS_TERMINATING;
        if (JobToken != NULL) {
            ObDereferenceObject (NewToken);
        }
        goto deref_and_return_status;
    }


    //
    // ref the job for the process
    //

    ObReferenceObject (Job);

    if (InterlockedCompareExchangePointer (&Process->Job, Job, NULL) != NULL) {
        ExReleaseRundownProtection (&Process->RundownProtect);
        ObDereferenceObject (Process);
        ObDereferenceObjectEx (Job, 2);
        if (JobToken != NULL) {
            ObDereferenceObject (NewToken);
        }
        return STATUS_ACCESS_DENIED;
    }
    //
    // If the job has a token filter established,
    // use it to filter the
    //
    ExReleaseRundownProtection (&Process->RundownProtect);

    Status = PspAddProcessToJob (Job, Process);
    if (!NT_SUCCESS (Status)) {

        Status1 = PspTerminateProcess (Process, ERROR_NOT_ENOUGH_QUOTA);
        if (NT_SUCCESS (Status1)) {

            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

            Job->TotalTerminatedProcesses++;

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        }
    }

    //
    // If the job has UI restrictions and this is a GUI process, call ntuser
    //
    if ((Job->UIRestrictionsClass != JOB_OBJECT_UILIMIT_NONE) &&
         (Process->Win32Process != NULL)) {
        WIN32_JOBCALLOUT_PARAMETERS Parms;

        Parms.Job = Job;
        Parms.CalloutType = PsW32JobCalloutAddProcess;
        Parms.Data = Process->Win32Process;

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceExclusiveLite(&Job->JobLock, TRUE);

        PspWin32SessionCallout(PspW32JobCallout, &Parms, Job->SessionId);

        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    if (JobToken != NULL) {
        Status1 = PspSetPrimaryToken (NULL, Process, NULL, NewToken, TRUE);
        ObDereferenceObject (NewToken);
        //
        // Only bad callers should fail here.
        //
        ASSERT (NT_SUCCESS (Status1));
    }

deref_and_return_status:

    ObDereferenceObject (Process);
    ObDereferenceObject (Job);

    return Status;
}

NTSTATUS
PspAddProcessToJob(
    PEJOB Job,
    PEPROCESS Process
    )
{

    NTSTATUS Status;
    PETHREAD CurrentThread;
    SIZE_T MinWs,MaxWs;
    KAPC_STATE ApcState;
    ULONG SetLimit;

    PAGED_CODE();


    CurrentThread = PsGetCurrentThread ();

    Status = STATUS_SUCCESS;


    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

    InsertTailList (&Job->ProcessListHead, &Process->JobLinks);

    //
    // Update relevant ADD accounting info.
    //

    Job->TotalProcesses++;
    Job->ActiveProcesses++;

    //
    // Test for active process count exceeding limit
    //

    if ((Job->LimitFlags & JOB_OBJECT_LIMIT_ACTIVE_PROCESS) &&
        Job->ActiveProcesses > Job->ActiveProcessLimit) {

        PS_SET_CLEAR_BITS (&Process->JobStatus,
                           PS_JOB_STATUS_NOT_REALLY_ACTIVE | PS_JOB_STATUS_ACCOUNTING_FOLDED,
                           PS_JOB_STATUS_LAST_REPORT_MEMORY);

        if (Job->CompletionPort != NULL) {
            IoSetIoCompletion (Job->CompletionPort,
                               Job->CompletionKey,
                               NULL,
                               STATUS_SUCCESS,
                               JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT,
                               TRUE);
        }

        Status = STATUS_QUOTA_EXCEEDED;
    }

    if ((Job->LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME) && KeReadStateEvent (&Job->Event)) {
        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE | PS_JOB_STATUS_ACCOUNTING_FOLDED);

        Status = STATUS_QUOTA_EXCEEDED;
    }

    //
    // If the last handle to the job has been closed and the kill on close option is set
    // we don't let new processes enter the job. This is to make cleanup solid.
    //

    if (PS_TEST_ALL_BITS_SET (Job->JobFlags, PS_JOB_FLAGS_CLOSE_DONE|JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE)) {
        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE | PS_JOB_STATUS_ACCOUNTING_FOLDED);
        Status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS (Status)) {

        PspApplyJobLimitsToProcess (Job, Process);

        if (Job->CompletionPort != NULL &&
            Process->UniqueProcessId &&
            !(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE) &&
            !(Process->JobStatus & PS_JOB_STATUS_NEW_PROCESS_REPORTED)) {

            PS_SET_CLEAR_BITS (&Process->JobStatus,
                               PS_JOB_STATUS_NEW_PROCESS_REPORTED,
                               PS_JOB_STATUS_LAST_REPORT_MEMORY);

            IoSetIoCompletion (Job->CompletionPort,
                               Job->CompletionKey,
                               (PVOID)Process->UniqueProcessId,
                               STATUS_SUCCESS,
                               JOB_OBJECT_MSG_NEW_PROCESS,
                               FALSE);
        }

    } else {
        Job->ActiveProcesses--;
    }

    ExReleaseResourceLite (&Job->JobLock);

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    if (NT_SUCCESS (Status)) {

        //
        // We can't attach with APCs diabled so we have to unlock attach and then check
        // working set limits.
        //

        KeStackAttachProcess (&Process->Pcb, &ApcState);

        KeEnterGuardedRegionThread (&CurrentThread->Tcb);

        ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

        MinWs = Job->MinimumWorkingSetSize;
        MaxWs = Job->MaximumWorkingSetSize;
        if (Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
            SetLimit = MM_WORKING_SET_MAX_HARD_ENABLE;
        } else {
            SetLimit = MM_WORKING_SET_MAX_HARD_DISABLE;
        }

        PspLockWorkingSetChangeExclusiveUnsafe ();

        ExReleaseResourceLite (&Job->JobLock);

        //
        // See if we need to apply WS limits
        //

        if (SetLimit != MM_WORKING_SET_MAX_HARD_DISABLE) {

            MmAdjustWorkingSetSize (MinWs,
                                    MaxWs,
                                    FALSE,
                                    TRUE);

        }
        MmEnforceWorkingSetLimit (Process, SetLimit);

        PspUnlockWorkingSetChangeExclusiveUnsafe ();

        KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

        KeUnstackDetachProcess (&ApcState);


        if (!MmAssignProcessToJob (Process)) {
            Status = STATUS_QUOTA_EXCEEDED;
        }

    }

    return Status;
}

//
// Only callable from process delete routine !
// This means that if the above fails, failure is termination of the process !
//
VOID
PspRemoveProcessFromJob(
    PEJOB Job,
    PEPROCESS Process
    )
{
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

    RemoveEntryList (&Process->JobLinks);

    //
    // Update REMOVE accounting info
    //


    if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
        Job->ActiveProcesses--;
        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE);
    }

    PspFoldProcessAccountingIntoJob (Job, Process);

    ExReleaseResourceLite (&Job->JobLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

VOID
PspExitProcessFromJob(
    PEJOB Job,
    PEPROCESS Process
    )
{
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite(&Job->JobLock, TRUE);

    //
    // Update REMOVE accounting info
    //


    if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
        Job->ActiveProcesses--;
        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE);
    }

    PspFoldProcessAccountingIntoJob(Job,Process);

    ExReleaseResourceLite(&Job->JobLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

VOID
PspJobDelete(
    IN PVOID Object
    )
{
    PEJOB Job, tJob;
    WIN32_JOBCALLOUT_PARAMETERS Parms;
    PPS_JOB_TOKEN_FILTER Filter;
    PETHREAD CurrentThread;

    PAGED_CODE();

    Job = (PEJOB) Object;

    //
    // call ntuser to delete its job structure
    //

    Parms.Job = Job;
    Parms.CalloutType = PsW32JobCalloutTerminate;
    Parms.Data = NULL;

    CurrentThread = PsGetCurrentThread ();

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite(&Job->JobLock, TRUE);

    PspWin32SessionCallout(PspW32JobCallout, &Parms, Job->SessionId);

    ExReleaseResourceLite(&Job->JobLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    Job->LimitFlags = 0;

    if (Job->CompletionPort != NULL) {
        ObDereferenceObject (Job->CompletionPort);
        Job->CompletionPort = NULL;
    }


    //
    // Remove Job on Job List and job set
    //

    tJob = NULL;

    PspLockJobListExclusive (CurrentThread);

    RemoveEntryList (&Job->JobLinks);

    //
    // If we are part of a jobset then we must be the pinning job. We must pass on the pin to the next
    // job in the chain.
    //
    if (!IsListEmpty (&Job->JobSetLinks)) {
        tJob = CONTAINING_RECORD (Job->JobSetLinks.Flink, EJOB, JobSetLinks);
        RemoveEntryList (&Job->JobSetLinks);
    }

    PspUnlockJobListExclusive (CurrentThread);

    //
    // Removing the pin from the job set can cause a cascade of deletes that would cause a stack overflow
    // as we recursed at this point. We break recursion by forcing the deferred delete path here.
    //
    if (tJob != NULL) {
        ObDereferenceObjectDeferDelete (tJob);
    }

    //
    // Free Security clutter:
    //

    if (Job->Token != NULL) {
        ObDereferenceObject (Job->Token);
        Job->Token = NULL;
    }

    Filter = Job->Filter;
    if (Filter != NULL) {
        if (Filter->CapturedSids != NULL) {
            ExFreePool (Filter->CapturedSids);
        }

        if (Filter->CapturedPrivileges != NULL) {
            ExFreePool (Filter->CapturedPrivileges);
        }

        if (Filter->CapturedGroups != NULL) {
            ExFreePool (Filter->CapturedGroups);
        }

        ExFreePool (Filter);

    }

    ExDeleteResourceLite (&Job->JobLock);
}

VOID
PspJobClose (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )
/*++

Routine Description:

    Called by the object manager when a handle is closed to the object.

Arguments:

    Process - Process doing the close
    Object - Job object being closed
    GrantedAccess - Access ranted for this handle
    ProcessHandleCount - Unused and unmaintained by OB
    SystemHandleCount - Current handle count for this object

Return Value:

    None.

--*/
{
    PEJOB Job = Object;
    PVOID Port;
    PETHREAD CurrentThread;

    PAGED_CODE ();

    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);
    //
    // If this isn't the last handle then do nothing.
    //
    if (SystemHandleCount > 1) {
        return;
    }

    CurrentThread = PsGetCurrentThread ();



    //
    // Mark the job has having its last handle closed.
    // This is used to prevent new processes entering a job
    // marked as terminate on close and also prevents a completion
    // port being set on a torn down job. Completion ports
    // are removed on last handle close.
    //

    PS_SET_BITS (&Job->JobFlags, PS_JOB_FLAGS_CLOSE_DONE);

    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

    if (Job->LimitFlags&JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE) {

        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

        PspTerminateAllProcessesInJob (Job, STATUS_SUCCESS, FALSE);

        KeEnterGuardedRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);
    }

    PspLockJobLimitsExclusiveUnsafe (Job);

    //
    // Release the completion port
    //

    Port = Job->CompletionPort;
    Job->CompletionPort = NULL;


    PspUnlockJobLimitsExclusiveUnsafe (Job);

    ExReleaseResourceLite (&Job->JobLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

    if (Port != NULL) {
        ObDereferenceObject (Port);
    }
}


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const ULONG PspJobInfoLengths[] = {
    sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),         // JobObjectBasicAccountingInformation
    sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION),              // JobObjectBasicLimitInformation
    sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST),                // JobObjectBasicProcessIdList
    sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS),                // JobObjectBasicUIRestrictions
    sizeof(JOBOBJECT_SECURITY_LIMIT_INFORMATION),           // JobObjectSecurityLimitInformation
    sizeof(JOBOBJECT_END_OF_JOB_TIME_INFORMATION),          // JobObjectEndOfJobTimeInformation
    sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT),            // JobObjectAssociateCompletionPortInformation
    sizeof(JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),  // JobObjectBasicAndIoAccountingInformation
    sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),           // JobObjectExtendedLimitInformation
    sizeof(JOBOBJECT_JOBSET_INFORMATION),                   // JobObjectJobSetInformation
    0
    };

const ULONG PspJobInfoAlign[] = {
    sizeof(ULONG),                                  // JobObjectBasicAccountingInformation
    sizeof(ULONG),                                  // JobObjectBasicLimitInformation
    sizeof(ULONG),                                  // JobObjectBasicProcessIdList
    sizeof(ULONG),                                  // JobObjectBasicUIRestrictions
    sizeof(ULONG),                                  // JobObjectSecurityLimitInformation
    sizeof(ULONG),                                  // JobObjectEndOfJobTimeInformation
    sizeof(PVOID),                                  // JobObjectAssociateCompletionPortInformation
    sizeof(ULONG),                                  // JobObjectBasicAndIoAccountingInformation
    sizeof(ULONG),                                  // JobObjectExtendedLimitInformation
    TYPE_ALIGNMENT (JOBOBJECT_JOBSET_INFORMATION),  // JobObjectJobSetInformation
    0
    };

NTSTATUS
NtQueryInformationJobObject(
    __in_opt HANDLE JobHandle,
    __in JOBOBJECTINFOCLASS JobObjectInformationClass,
    __out_bcount(JobObjectInformationLength) PVOID JobObjectInformation,
    __in ULONG JobObjectInformationLength,
    __out_opt PULONG ReturnLength
    )
{
    PEJOB Job;
    KPROCESSOR_MODE PreviousMode;
    JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION AccountingInfo;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ExtendedLimitInfo;
    JOBOBJECT_BASIC_UI_RESTRICTIONS BasicUIRestrictions;
    JOBOBJECT_SECURITY_LIMIT_INFORMATION SecurityLimitInfo;
    JOBOBJECT_JOBSET_INFORMATION JobSetInformation;
    JOBOBJECT_END_OF_JOB_TIME_INFORMATION EndOfJobInfo;
    NTSTATUS st=STATUS_SUCCESS;
    ULONG RequiredLength, RequiredAlign, ActualReturnLength;
    PVOID ReturnData=NULL;
    PEPROCESS Process;
    PLIST_ENTRY Next;
    PULONG_PTR NextProcessIdSlot;
    ULONG WorkingLength;
    PJOBOBJECT_BASIC_PROCESS_ID_LIST IdList;
    PUCHAR CurrentOffset;
    PTOKEN_GROUPS WorkingGroup;
    PTOKEN_PRIVILEGES WorkingPrivs;
    ULONG RemainingSidBuffer;
    PSID TargetSidBuffer;
    PSID RemainingSid;
    BOOLEAN AlreadyCopied;
    PPS_JOB_TOKEN_FILTER Filter;
    PETHREAD CurrentThread;
    KPROCESS_VALUES Values;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    //
    // Get previous processor mode and probe output argument if necessary.
    //

    if (JobObjectInformationClass >= MaxJobObjectInfoClass || JobObjectInformationClass <= 0) {
        return STATUS_INVALID_INFO_CLASS;
    }

    RequiredLength = PspJobInfoLengths[JobObjectInformationClass-1];
    RequiredAlign = PspJobInfoAlign[JobObjectInformationClass-1];
    ActualReturnLength = RequiredLength;

    if (JobObjectInformationLength != RequiredLength) {

        //
        // BasicProcessIdList is variable length, so make sure header is
        // ok. Can not enforce an exact match !  Security Limits can be
        // as well, due to the token groups and privs
        //
        if ((JobObjectInformationClass == JobObjectBasicProcessIdList) ||
            (JobObjectInformationClass == JobObjectSecurityLimitInformation)) {
            if (JobObjectInformationLength < RequiredLength) {
                return STATUS_INFO_LENGTH_MISMATCH;
            } else {
                RequiredLength = JobObjectInformationLength;
            }
        } else {
            return STATUS_INFO_LENGTH_MISMATCH;
        }
    }


    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {
        try {
            //
            // Since these functions don't change any state thats not reversible
            // in the error paths we only probe the output buffer for write access.
            // This improves performance by not touching the buffer multiple times
            // And only writing the portions of the buffer that change.
            //

            ProbeForRead (JobObjectInformation,
                          JobObjectInformationLength,
                          RequiredAlign);

            if (ARGUMENT_PRESENT (ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    //
    // reference the job
    //

    if (ARGUMENT_PRESENT (JobHandle)) {
        st = ObReferenceObjectByHandle (JobHandle,
                                        JOB_OBJECT_QUERY,
                                        PsJobType,
                                        PreviousMode,
                                        &Job,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }
    } else {

        //
        // if the current process has a job, NULL means the job of the
        // current process. Query is always allowed for this case
        //

        Process = PsGetCurrentProcessByThread (CurrentThread);

        if (Process->Job != NULL) {
            Job = Process->Job;
            ObReferenceObject (Job);
        } else {
            return STATUS_ACCESS_DENIED;
        }
    }

    AlreadyCopied = FALSE;


    //
    // Check argument validity.
    //

    switch (JobObjectInformationClass) {

    case JobObjectBasicAccountingInformation:
    case JobObjectBasicAndIoAccountingInformation:

        //
        // These two cases are identical, EXCEPT that with AndIo, IO information
        // is returned as well, but the first part of the local is identical to
        // basic, and the shorter return'd data length chops what we return.
        //

        RtlZeroMemory (&AccountingInfo.IoInfo,sizeof(AccountingInfo.IoInfo));

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

        AccountingInfo.BasicInfo.TotalUserTime = Job->TotalUserTime;
        AccountingInfo.BasicInfo.TotalKernelTime = Job->TotalKernelTime;
        AccountingInfo.BasicInfo.ThisPeriodTotalUserTime = Job->ThisPeriodTotalUserTime;
        AccountingInfo.BasicInfo.ThisPeriodTotalKernelTime = Job->ThisPeriodTotalKernelTime;
        AccountingInfo.BasicInfo.TotalPageFaultCount = Job->TotalPageFaultCount;

        AccountingInfo.BasicInfo.TotalProcesses = Job->TotalProcesses;
        AccountingInfo.BasicInfo.ActiveProcesses = Job->ActiveProcesses;
        AccountingInfo.BasicInfo.TotalTerminatedProcesses = Job->TotalTerminatedProcesses;

        AccountingInfo.IoInfo.ReadOperationCount = Job->ReadOperationCount;
        AccountingInfo.IoInfo.WriteOperationCount = Job->WriteOperationCount;
        AccountingInfo.IoInfo.OtherOperationCount = Job->OtherOperationCount;
        AccountingInfo.IoInfo.ReadTransferCount = Job->ReadTransferCount;
        AccountingInfo.IoInfo.WriteTransferCount = Job->WriteTransferCount;
        AccountingInfo.IoInfo.OtherTransferCount = Job->OtherTransferCount;

        //
        // Add in the time and page faults for each process
        //

        Next = Job->ProcessListHead.Flink;

        while (Next != &Job->ProcessListHead) {

            Process = (PEPROCESS)(CONTAINING_RECORD(Next, EPROCESS, JobLinks));
            if (!(Process->JobStatus & PS_JOB_STATUS_ACCOUNTING_FOLDED)) {

                KeQueryValuesProcess (&Process->Pcb, &Values);

                AccountingInfo.BasicInfo.TotalUserTime.QuadPart += Values.UserTime;
                AccountingInfo.BasicInfo.TotalKernelTime.QuadPart += Values.KernelTime;
                AccountingInfo.BasicInfo.ThisPeriodTotalUserTime.QuadPart += Values.UserTime;
                AccountingInfo.BasicInfo.ThisPeriodTotalKernelTime.QuadPart += Values.KernelTime;
                AccountingInfo.BasicInfo.TotalPageFaultCount += Process->Vm.PageFaultCount;

                AccountingInfo.IoInfo.ReadOperationCount += Values.ReadOperationCount;
                AccountingInfo.IoInfo.WriteOperationCount += Values.WriteOperationCount;
                AccountingInfo.IoInfo.OtherOperationCount += Values.OtherOperationCount;
                AccountingInfo.IoInfo.ReadTransferCount += Values.ReadTransferCount;
                AccountingInfo.IoInfo.WriteTransferCount += Values.WriteTransferCount;
                AccountingInfo.IoInfo.OtherTransferCount += Values.OtherTransferCount;
            }

            Next = Next->Flink;
        }

        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        ReturnData = &AccountingInfo;
        st = STATUS_SUCCESS;

        break;

    case JobObjectExtendedLimitInformation:
    case JobObjectBasicLimitInformation:

        //
        // Get the Basic Information
        //
        KeEnterGuardedRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

        ExtendedLimitInfo.BasicLimitInformation.LimitFlags = Job->LimitFlags;
        ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize = Job->MinimumWorkingSetSize;
        ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize = Job->MaximumWorkingSetSize;
        ExtendedLimitInfo.BasicLimitInformation.ActiveProcessLimit = Job->ActiveProcessLimit;
        ExtendedLimitInfo.BasicLimitInformation.PriorityClass = (ULONG)Job->PriorityClass;
        ExtendedLimitInfo.BasicLimitInformation.SchedulingClass = Job->SchedulingClass;
        ExtendedLimitInfo.BasicLimitInformation.Affinity = (ULONG_PTR)Job->Affinity;
        ExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart = Job->PerProcessUserTimeLimit.QuadPart;
        ExtendedLimitInfo.BasicLimitInformation.PerJobUserTimeLimit.QuadPart = Job->PerJobUserTimeLimit.QuadPart;


        if (JobObjectInformationClass == JobObjectExtendedLimitInformation) {

            //
            // Get Extended Information
            //

            PspLockJobLimitsSharedUnsafe (Job);

            ExtendedLimitInfo.ProcessMemoryLimit = Job->ProcessMemoryLimit << PAGE_SHIFT;
            ExtendedLimitInfo.JobMemoryLimit = Job->JobMemoryLimit << PAGE_SHIFT;
            ExtendedLimitInfo.PeakJobMemoryUsed = Job->PeakJobMemoryUsed << PAGE_SHIFT;

            ExtendedLimitInfo.PeakProcessMemoryUsed = Job->PeakProcessMemoryUsed << PAGE_SHIFT;

            PspUnlockJobLimitsSharedUnsafe (Job);

            ExReleaseResourceLite(&Job->JobLock);
            KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
            //
            // Zero un-used I/O counters
            //
            RtlZeroMemory (&ExtendedLimitInfo.IoInfo, sizeof (ExtendedLimitInfo.IoInfo));

            ReturnData = &ExtendedLimitInfo;

        } else {

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

            ReturnData = &ExtendedLimitInfo.BasicLimitInformation;

        }

        st = STATUS_SUCCESS;

        break;

    case JobObjectBasicUIRestrictions:

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite(&Job->JobLock, TRUE);

        BasicUIRestrictions.UIRestrictionsClass = Job->UIRestrictionsClass;

        ExReleaseResourceLite(&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        ReturnData = &BasicUIRestrictions;
        st = STATUS_SUCCESS;

        break;

    case JobObjectBasicProcessIdList:

        IdList = (PJOBOBJECT_BASIC_PROCESS_ID_LIST)JobObjectInformation;
        NextProcessIdSlot = &IdList->ProcessIdList[0];
        WorkingLength = FIELD_OFFSET(JOBOBJECT_BASIC_PROCESS_ID_LIST, ProcessIdList);

        AlreadyCopied = TRUE;

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

        try {

            //
            // Accounted for in the workinglength = 2*sizeof(ULONG)
            //

            IdList->NumberOfAssignedProcesses = Job->ActiveProcesses;
            IdList->NumberOfProcessIdsInList = 0;

            Next = Job->ProcessListHead.Flink;

            while (Next != &Job->ProcessListHead) {

                Process = (PEPROCESS)(CONTAINING_RECORD (Next, EPROCESS, JobLinks));
                if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
                    if (!Process->UniqueProcessId) {
                        IdList->NumberOfAssignedProcesses--;
                    } else {
                        if ((RequiredLength - WorkingLength) >= sizeof (ULONG_PTR)) {
                            *NextProcessIdSlot++ = (ULONG_PTR)Process->UniqueProcessId;
                            WorkingLength += sizeof(ULONG_PTR);
                            IdList->NumberOfProcessIdsInList++;
                        } else {
                            st = STATUS_BUFFER_OVERFLOW;
                            ActualReturnLength = WorkingLength;
                            break;
                        }
                    }
                }
                Next = Next->Flink;
            }
            ActualReturnLength = WorkingLength;

        } except (ExSystemExceptionFilter ()) {
            st = GetExceptionCode ();
            ActualReturnLength = 0;
        }
        ExReleaseResourceLite(&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        break;

    case JobObjectSecurityLimitInformation:

        RtlZeroMemory (&SecurityLimitInfo, sizeof (SecurityLimitInfo));

        ReturnData = &SecurityLimitInfo;

        st = STATUS_SUCCESS;

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite(&Job->JobLock, TRUE);

        SecurityLimitInfo.SecurityLimitFlags = Job->SecurityLimitFlags;

        //
        // If a filter is present, then we have an ugly marshalling to do.
        //

        Filter = Job->Filter;
        if (Filter != NULL) {

            WorkingLength = 0;

            //
            // For each field, if it is present, include the extra stuff
            //

            if (Filter->CapturedSidsLength > 0) {
                WorkingLength += Filter->CapturedSidsLength + sizeof (ULONG);
            }

            if (Filter->CapturedGroupsLength > 0) {
                WorkingLength += Filter->CapturedGroupsLength + sizeof (ULONG);
            }

            if (Filter->CapturedPrivilegesLength > 0) {
                WorkingLength += Filter->CapturedPrivilegesLength + sizeof (ULONG);
            }

            RequiredLength -= sizeof (SecurityLimitInfo);

            if (WorkingLength > RequiredLength) {
                st = STATUS_BUFFER_OVERFLOW ;
                ActualReturnLength = WorkingLength + sizeof (SecurityLimitInfo);
                goto unlock;
            }

            CurrentOffset = (PUCHAR) (JobObjectInformation) + sizeof (SecurityLimitInfo);

            try {

                if (Filter->CapturedSidsLength > 0) {
                    WorkingGroup = (PTOKEN_GROUPS) CurrentOffset;

                    CurrentOffset += sizeof (ULONG);

                    SecurityLimitInfo.RestrictedSids = WorkingGroup;

                    WorkingGroup->GroupCount = Filter->CapturedSidCount;

                    TargetSidBuffer = (PSID) (CurrentOffset +
                                              sizeof (SID_AND_ATTRIBUTES) *
                                              Filter->CapturedSidCount);

                    st = RtlCopySidAndAttributesArray (Filter->CapturedSidCount,
                                                       Filter->CapturedSids,
                                                       WorkingLength,
                                                       WorkingGroup->Groups,
                                                       TargetSidBuffer,
                                                       &RemainingSid,
                                                       &RemainingSidBuffer);

                    CurrentOffset += Filter->CapturedSidsLength;

                }

                if (!NT_SUCCESS (st)) {
                    leave;
                }

                if (Filter->CapturedGroupsLength > 0) {
                    WorkingGroup = (PTOKEN_GROUPS) CurrentOffset;

                    CurrentOffset += sizeof (ULONG);

                    SecurityLimitInfo.SidsToDisable = WorkingGroup;

                    WorkingGroup->GroupCount = Filter->CapturedGroupCount;

                    TargetSidBuffer = (PSID) (CurrentOffset +
                                              sizeof (SID_AND_ATTRIBUTES) *
                                              Filter->CapturedGroupCount);

                    st = RtlCopySidAndAttributesArray (Filter->CapturedGroupCount,
                                                       Filter->CapturedGroups,
                                                       WorkingLength,
                                                       WorkingGroup->Groups,
                                                       TargetSidBuffer,
                                                       &RemainingSid,
                                                       &RemainingSidBuffer);

                    CurrentOffset += Filter->CapturedGroupsLength;

                }

                if (!NT_SUCCESS (st)) {
                    leave;
                }

                if (Filter->CapturedPrivilegesLength > 0) {
                    WorkingPrivs = (PTOKEN_PRIVILEGES) CurrentOffset;

                    CurrentOffset += sizeof (ULONG);

                    SecurityLimitInfo.PrivilegesToDelete = WorkingPrivs;

                    WorkingPrivs->PrivilegeCount = Filter->CapturedPrivilegeCount;

                    RtlCopyMemory (WorkingPrivs->Privileges,
                                   Filter->CapturedPrivileges,
                                   Filter->CapturedPrivilegesLength);

                }



            } except (EXCEPTION_EXECUTE_HANDLER) {
                st = GetExceptionCode ();
                ActualReturnLength = 0 ;
            }

        }
unlock:
        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        AlreadyCopied = TRUE;

        if (NT_SUCCESS (st)) {
            try {
                RtlCopyMemory (JobObjectInformation,
                               &SecurityLimitInfo,
                               sizeof (SecurityLimitInfo));
            }  except (EXCEPTION_EXECUTE_HANDLER) {
                st = GetExceptionCode ();
                ActualReturnLength = 0 ;
                break;
            }
        }

        break;

    case JobObjectJobSetInformation:

        PspLockJobListShared (CurrentThread);

        JobSetInformation.MemberLevel = Job->MemberLevel;

        PspUnlockJobListShared (CurrentThread);

        ReturnData = &JobSetInformation;
        st = STATUS_SUCCESS;

        break;

    case JobObjectEndOfJobTimeInformation:

        EndOfJobInfo.EndOfJobTimeAction = Job->EndOfJobTimeAction;

        ReturnData = &EndOfJobInfo;
        st = STATUS_SUCCESS;
        break;

    default:

        st = STATUS_INVALID_INFO_CLASS;
    }


    //
    // Finish Up
    //

    ObDereferenceObject (Job);


    if (NT_SUCCESS (st)) {

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            if (!AlreadyCopied) {
                RtlCopyMemory (JobObjectInformation, ReturnData, RequiredLength);
            }

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = ActualReturnLength;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    return st;

}

NTSTATUS
NtSetInformationJobObject(
    __in HANDLE JobHandle,
    __in JOBOBJECTINFOCLASS JobObjectInformationClass,
    __in_bcount(JobObjectInformationLength) PVOID JobObjectInformation,
    __in ULONG JobObjectInformationLength
    )
{
    PEJOB Job;
    EJOB LocalJob={0};
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ExtendedLimitInfo={0};
    JOBOBJECT_BASIC_UI_RESTRICTIONS BasicUIRestrictions={0};
    JOBOBJECT_SECURITY_LIMIT_INFORMATION SecurityLimitInfo={0};
    JOBOBJECT_END_OF_JOB_TIME_INFORMATION EndOfJobInfo={0};
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT AssociateInfo={0};
    ULONG RequiredAccess;
    ULONG RequiredLength, RequiredAlign;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    BOOLEAN HasPrivilege;
    BOOLEAN IsChild=FALSE;
    PLIST_ENTRY Next;
    PPS_JOB_TOKEN_FILTER Filter;
    PVOID IoCompletion;
    PACCESS_TOKEN LocalToken;
    ULONG ValidFlags;
    ULONG LimitFlags;
    BOOLEAN ProcessWorkingSetHead = FALSE;
    PJOB_WORKING_SET_CHANGE_RECORD WsChangeRecord;

    PAGED_CODE();

    //
    // Get previous processor mode and probe output argument if necessary.
    //

    if (JobObjectInformationClass >= MaxJobObjectInfoClass || JobObjectInformationClass <= 0) {
        return STATUS_INVALID_INFO_CLASS;
    }

    RequiredLength = PspJobInfoLengths[JobObjectInformationClass-1];
    RequiredAlign = PspJobInfoAlign[JobObjectInformationClass-1];

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {
        try {

            ProbeForRead (JobObjectInformation,
                          JobObjectInformationLength,
                          RequiredAlign);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    if (JobObjectInformationLength != RequiredLength) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // reference the job
    //

    if (JobObjectInformationClass == JobObjectSecurityLimitInformation) {
        RequiredAccess = JOB_OBJECT_SET_SECURITY_ATTRIBUTES;
    } else {
        RequiredAccess = JOB_OBJECT_SET_ATTRIBUTES;
    }

    st = ObReferenceObjectByHandle (JobHandle,
                                    RequiredAccess,
                                    PsJobType,
                                    PreviousMode,
                                    &Job,
                                    NULL);
    if (!NT_SUCCESS (st)) {
        return st;
    }

    KeEnterGuardedRegionThread (&CurrentThread->Tcb);

    //
    // Check argument validity.
    //

    switch (JobObjectInformationClass) {

    case JobObjectExtendedLimitInformation:
    case JobObjectBasicLimitInformation:
        try {
            RtlCopyMemory (&ExtendedLimitInfo, JobObjectInformation, RequiredLength);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        if (NT_SUCCESS (st)) {
            //
            // sanity check LimitFlags
            //
            if (JobObjectInformationClass == JobObjectBasicLimitInformation) {
                ValidFlags = JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS;
            } else {
                ValidFlags = JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS;
            }

            if (ExtendedLimitInfo.BasicLimitInformation.LimitFlags & ~ValidFlags) {
                st = STATUS_INVALID_PARAMETER;
            } else {

                LimitFlags = ExtendedLimitInfo.BasicLimitInformation.LimitFlags;

                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                //
                // Deal with each of the various limit flags
                //

                LocalJob.LimitFlags = Job->LimitFlags;


                //
                // ACTIVE PROCESS LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_ACTIVE_PROCESS) {

                    //
                    // Active Process Limit is NOT retroactive. New processes are denied,
                    // but existing ones are not killed just because the limit is
                    // reduced.
                    //

                    LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
                    LocalJob.ActiveProcessLimit = ExtendedLimitInfo.BasicLimitInformation.ActiveProcessLimit;
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
                    LocalJob.ActiveProcessLimit = 0;
                }

                //
                // PRIORITY CLASS LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS) {

                    if (ExtendedLimitInfo.BasicLimitInformation.PriorityClass > PROCESS_PRIORITY_CLASS_ABOVE_NORMAL) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        if (ExtendedLimitInfo.BasicLimitInformation.PriorityClass == PROCESS_PRIORITY_CLASS_HIGH ||
                            ExtendedLimitInfo.BasicLimitInformation.PriorityClass == PROCESS_PRIORITY_CLASS_REALTIME) {

                            //
                            // Increasing the base priority of a process is a
                            // privileged operation.  Check for the privilege
                            // here.
                            //

                            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                                    JobHandle,
                                                                    JOB_OBJECT_SET_ATTRIBUTES,
                                                                    PreviousMode);

                            if (!HasPrivilege) {
                                st = STATUS_PRIVILEGE_NOT_HELD;
                            }
                        }

                        if (NT_SUCCESS (st)) {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;
                            LocalJob.PriorityClass = (UCHAR)ExtendedLimitInfo.BasicLimitInformation.PriorityClass;
                        }
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_PRIORITY_CLASS;
                    LocalJob.PriorityClass = 0;
                }

                //
                // SCHEDULING CLASS LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_SCHEDULING_CLASS) {

                    if (ExtendedLimitInfo.BasicLimitInformation.SchedulingClass >= PSP_NUMBER_OF_SCHEDULING_CLASSES) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        if (ExtendedLimitInfo.BasicLimitInformation.SchedulingClass > PSP_DEFAULT_SCHEDULING_CLASSES) {

                            //
                            // Increasing above the default scheduling class
                            // is a
                            // privileged operation.  Check for the privilege
                            // here.
                            //

                            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                                    JobHandle,
                                                                    JOB_OBJECT_SET_ATTRIBUTES,
                                                                    PreviousMode);

                            if (!HasPrivilege) {
                                st = STATUS_PRIVILEGE_NOT_HELD;
                            }
                        }

                        if (NT_SUCCESS (st)) {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
                            LocalJob.SchedulingClass = ExtendedLimitInfo.BasicLimitInformation.SchedulingClass;
                        }
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
                    LocalJob.SchedulingClass = PSP_DEFAULT_SCHEDULING_CLASSES ;
                }

                //
                // AFFINITY LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_AFFINITY) {

                    if (!ExtendedLimitInfo.BasicLimitInformation.Affinity ||
                        (ExtendedLimitInfo.BasicLimitInformation.Affinity != (ExtendedLimitInfo.BasicLimitInformation.Affinity & KeActiveProcessors))) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_AFFINITY;
                        LocalJob.Affinity = (KAFFINITY)ExtendedLimitInfo.BasicLimitInformation.Affinity;
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_AFFINITY;
                    LocalJob.Affinity = 0;
                }

                //
                // PROCESS TIME LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_PROCESS_TIME) {

                    if (!ExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_TIME;
                        LocalJob.PerProcessUserTimeLimit.QuadPart = ExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart;
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_PROCESS_TIME;
                    LocalJob.PerProcessUserTimeLimit.QuadPart = 0;
                }

                //
                // JOB TIME LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME) {

                    if (!ExtendedLimitInfo.BasicLimitInformation.PerJobUserTimeLimit.QuadPart) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_JOB_TIME;
                        LocalJob.PerJobUserTimeLimit.QuadPart = ExtendedLimitInfo.BasicLimitInformation.PerJobUserTimeLimit.QuadPart;
                    }
                } else {
                    if (LimitFlags & JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME) {

                        //
                        // If we are supposed to preserve existing job time limits, then
                        // preserve them !
                        //

                        LocalJob.LimitFlags |= (Job->LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME);
                        LocalJob.PerJobUserTimeLimit.QuadPart = Job->PerJobUserTimeLimit.QuadPart;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_TIME;
                        LocalJob.PerJobUserTimeLimit.QuadPart = 0;
                    }
                }

                //
                // WORKING SET LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {


                    //
                    // the only issue with this check is that when we enforce through the
                    // processes, we may find a process that can not handle the new working set
                    // limit because it will make the process's working set not fluid
                    //

                    if ((ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize == 0 &&
                         ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize == 0)                 ||

                         (ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize == (SIZE_T)-1 &&
                         ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize == (SIZE_T)-1)        ||

                         (ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize >
                            ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize)                   ) {


                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        if (ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize <= PsMinimumWorkingSet ||
                            SeSinglePrivilegeCheck (SeIncreaseBasePriorityPrivilege,
                                                    PreviousMode)) {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_WORKINGSET;
                            LocalJob.MinimumWorkingSetSize = ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize;
                            LocalJob.MaximumWorkingSetSize = ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize;

                        } else {
                            st = STATUS_PRIVILEGE_NOT_HELD;
                        }
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_WORKINGSET;
                    LocalJob.MinimumWorkingSetSize = 0;
                    LocalJob.MaximumWorkingSetSize = 0;
                }

                if (JobObjectInformationClass == JobObjectExtendedLimitInformation) {
                    //
                    // PROCESS MEMORY LIMIT
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY) {
                        if (ExtendedLimitInfo.ProcessMemoryLimit < PAGE_SIZE) {
                            st = STATUS_INVALID_PARAMETER;
                        } else {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
                            LocalJob.ProcessMemoryLimit = ExtendedLimitInfo.ProcessMemoryLimit >> PAGE_SHIFT;
                        }
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_PROCESS_MEMORY;
                        LocalJob.ProcessMemoryLimit = 0;
                    }

                    //
                    // JOB WIDE MEMORY LIMIT
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_JOB_MEMORY) {
                        if (ExtendedLimitInfo.JobMemoryLimit < PAGE_SIZE) {
                            st = STATUS_INVALID_PARAMETER;
                        } else {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_JOB_MEMORY;
                            LocalJob.JobMemoryLimit = ExtendedLimitInfo.JobMemoryLimit >> PAGE_SHIFT;
                        }
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_MEMORY;
                        LocalJob.JobMemoryLimit = 0;
                    }

                    //
                    // JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION) {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;
                    }

                    //
                    // JOB_OBJECT_LIMIT_BREAKAWAY_OK
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_BREAKAWAY_OK) {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_BREAKAWAY_OK;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_BREAKAWAY_OK;
                    }

                    //
                    // JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK) {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;
                    }
                    //
                    // JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE) {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
                    }
                }

                if (NT_SUCCESS (st)) {

                    //
                    // Copy LocalJob to Job
                    //

                    Job->LimitFlags = LocalJob.LimitFlags;
                    Job->MinimumWorkingSetSize = LocalJob.MinimumWorkingSetSize;
                    Job->MaximumWorkingSetSize = LocalJob.MaximumWorkingSetSize;
                    Job->ActiveProcessLimit = LocalJob.ActiveProcessLimit;
                    Job->Affinity = LocalJob.Affinity;
                    Job->PriorityClass = LocalJob.PriorityClass;
                    Job->SchedulingClass = LocalJob.SchedulingClass;
                    Job->PerProcessUserTimeLimit.QuadPart = LocalJob.PerProcessUserTimeLimit.QuadPart;
                    Job->PerJobUserTimeLimit.QuadPart = LocalJob.PerJobUserTimeLimit.QuadPart;

                    if (JobObjectInformationClass == JobObjectExtendedLimitInformation) {
                        PspLockJobLimitsExclusiveUnsafe (Job);
                        Job->ProcessMemoryLimit = LocalJob.ProcessMemoryLimit;
                        Job->JobMemoryLimit = LocalJob.JobMemoryLimit;
                        PspUnlockJobLimitsExclusiveUnsafe (Job);
                    }

                    if (LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME) {

                        //
                        // Take any signaled processes and fold their accounting
                        // into the job. This way a process that exited clean but still
                        // is open won't impact the next period
                        //

                        Next = Job->ProcessListHead.Flink;

                        while (Next != &Job->ProcessListHead) {

                            Process = (PEPROCESS)(CONTAINING_RECORD(Next, EPROCESS, JobLinks));

                            //
                            // see if process has been signaled.
                            // This indicates that the process has exited. We can't do
                            // this in the exit path because of the lock order problem
                            // between the process lock and the job lock since in exit
                            // we hold the process lock for a long time and can't drop
                            // it until thread termination
                            //

                            if (KeReadStateProcess (&Process->Pcb)) {
                                PspFoldProcessAccountingIntoJob (Job, Process);
                            } else {
                                ULONG TotalUser;
                                LARGE_INTEGER ProcessTime;

                                //
                                // running processes have their current runtime
                                // added to the programmed limit. This way, you
                                // can set a limit on a job with processes in the
                                // job and not have previous runtimes count against
                                // the limit
                                //

                                if (!(Process->JobStatus & PS_JOB_STATUS_ACCOUNTING_FOLDED)) {
                                    KeQueryRuntimeProcess (&Process->Pcb, &TotalUser);
                                    ProcessTime.QuadPart = UInt32x32To64 (TotalUser, KeMaximumIncrement);
                                    Job->PerJobUserTimeLimit.QuadPart += ProcessTime.QuadPart;
                                }
                            }

                            Next = Next->Flink;
                        }


                        //
                        // clear period times and reset the job
                        //

                        Job->ThisPeriodTotalUserTime.QuadPart = 0;
                        Job->ThisPeriodTotalKernelTime.QuadPart = 0;

                        KeClearEvent (&Job->Event);

                    }

                    if (Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
                        PspLockWorkingSetChangeExclusiveUnsafe ();
                        PspWorkingSetChangeHead.MinimumWorkingSetSize = Job->MinimumWorkingSetSize;
                        PspWorkingSetChangeHead.MaximumWorkingSetSize = Job->MaximumWorkingSetSize;
                        ProcessWorkingSetHead = TRUE;
                    }

                    PspApplyJobLimitsToProcessSet (Job);

                }
                ExReleaseResourceLite (&Job->JobLock);
            }

        }
        break;

    case JobObjectBasicUIRestrictions:

        try {
            RtlCopyMemory (&BasicUIRestrictions, JobObjectInformation, RequiredLength);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        if (NT_SUCCESS (st)) {
            //
            // sanity check UIRestrictionsClass
            //
            if (BasicUIRestrictions.UIRestrictionsClass & ~JOB_OBJECT_UI_VALID_FLAGS) {
                st = STATUS_INVALID_PARAMETER;
            } else {

                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                //
                // Check for switching between UI restrictions
                //

                if (Job->UIRestrictionsClass ^ BasicUIRestrictions.UIRestrictionsClass) {

                    //
                    // notify ntuser that the UI restrictions have changed
                    //
                    WIN32_JOBCALLOUT_PARAMETERS Parms;

                    Parms.Job = Job;
                    Parms.CalloutType = PsW32JobCalloutSetInformation;
                    Parms.Data = ULongToPtr (BasicUIRestrictions.UIRestrictionsClass);

                    PspWin32SessionCallout (PspW32JobCallout, &Parms, Job->SessionId);
                }


                //
                // save the UI restrictions into the job object
                //

                Job->UIRestrictionsClass = BasicUIRestrictions.UIRestrictionsClass;

                ExReleaseResourceLite (&Job->JobLock);
            }
        }
        break;

        //
        // SECURITY LIMITS
        //

    case JobObjectSecurityLimitInformation:

        try {
            RtlCopyMemory (&SecurityLimitInfo,
                           JobObjectInformation,
                           RequiredLength);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }


        if (NT_SUCCESS (st)) {

            if (SecurityLimitInfo.SecurityLimitFlags & (~JOB_OBJECT_SECURITY_VALID_FLAGS)) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);
                //
                // Deal with specific options.  Basic rules:  Once a
                // flag is on, it is always on (so even with a handle to
                // the job, a process could not lift the security
                // restrictions).
                //

                if (SecurityLimitInfo.SecurityLimitFlags & JOB_OBJECT_SECURITY_NO_ADMIN) {
                    Job->SecurityLimitFlags |= JOB_OBJECT_SECURITY_NO_ADMIN ;

                    if (Job->Token) {
                        if (SeTokenIsAdmin (Job->Token)) {
                            Job->SecurityLimitFlags &= (~JOB_OBJECT_SECURITY_NO_ADMIN);

                            st = STATUS_INVALID_PARAMETER;
                        }
                    }
                }

                if (SecurityLimitInfo.SecurityLimitFlags & JOB_OBJECT_SECURITY_RESTRICTED_TOKEN ) {
                    if (Job->SecurityLimitFlags & (JOB_OBJECT_SECURITY_ONLY_TOKEN | JOB_OBJECT_SECURITY_FILTER_TOKENS)) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        Job->SecurityLimitFlags |= JOB_OBJECT_SECURITY_RESTRICTED_TOKEN;
                    }
                }

                //
                // The forcible token is a little more interesting.  It
                // cannot be reset, so if there is a pointer there already,
                // fail the call.  If a filter is already in place, this is
                // not allowed, either.  If no-admin is set, it is checked
                // at the end, once the token has been ref'd.
                //

                if (SecurityLimitInfo.SecurityLimitFlags & JOB_OBJECT_SECURITY_ONLY_TOKEN) {
                    if (Job->Token ||
                         (Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_FILTER_TOKENS)) {
                        st = STATUS_INVALID_PARAMETER ;
                    } else {
                        st = ObReferenceObjectByHandle(SecurityLimitInfo.JobToken,
                                                       TOKEN_ASSIGN_PRIMARY |
                                                           TOKEN_IMPERSONATE |
                                                           TOKEN_DUPLICATE,
                                                       SeTokenObjectType,
                                                       PreviousMode,
                                                       &LocalToken,
                                                       NULL);

                        if (NT_SUCCESS (st)) {
                            if (SeTokenType (LocalToken) != TokenPrimary) {
                                st = STATUS_BAD_TOKEN_TYPE;
                            } else {
                                st = SeIsChildTokenByPointer (LocalToken,
                                                              &IsChild);
                            }

                            if (!NT_SUCCESS (st)) {
                                ObDereferenceObject (LocalToken);
                            }
                        }


                        if (NT_SUCCESS (st)) {
                            //
                            // If the token supplied is not a restricted token
                            // based on the caller's ID, then they must have
                            // assign primary privilege in order to associate
                            // the token with the job.
                            //

                            if (!IsChild) {
                                HasPrivilege = SeCheckPrivilegedObject (SeAssignPrimaryTokenPrivilege,
                                                                        JobHandle,
                                                                        JOB_OBJECT_SET_SECURITY_ATTRIBUTES,
                                                                        PreviousMode);

                                if (!HasPrivilege) {
                                    st = STATUS_PRIVILEGE_NOT_HELD;
                                }
                            }

                            if (NT_SUCCESS (st)) {

                                //
                                // Not surprisingly, specifying no-admin and
                                // supplying an admin token is a no-no.
                                //

                                if ((Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_NO_ADMIN) &&
                                     SeTokenIsAdmin (LocalToken)) {
                                    st = STATUS_INVALID_PARAMETER;

                                    ObDereferenceObject (LocalToken);

                                } else {
                                    //
                                    // Grab a reference to the token into the job
                                    // object
                                    //
                                    KeMemoryBarrier ();
                                    Job->Token = LocalToken;
                                    Job->SecurityLimitFlags |= JOB_OBJECT_SECURITY_ONLY_TOKEN;
                                }

                            } else {
                                //
                                // This is the token was a child or otherwise ok,
                                // but assign primary was not held, so the
                                // request was rejected.
                                //

                                ObDereferenceObject (LocalToken);
                            }

                        }

                    }
                }

                if (SecurityLimitInfo.SecurityLimitFlags & JOB_OBJECT_SECURITY_FILTER_TOKENS ) {
                    if (Job->SecurityLimitFlags & (JOB_OBJECT_SECURITY_ONLY_TOKEN | JOB_OBJECT_SECURITY_FILTER_TOKENS)) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        //
                        // capture the token restrictions
                        //

                        st = PspCaptureTokenFilter (PreviousMode,
                                                    &SecurityLimitInfo,
                                                    &Filter);

                        if (NT_SUCCESS (st)) {
                            KeMemoryBarrier ();
                            Job->SecurityLimitFlags |= JOB_OBJECT_SECURITY_FILTER_TOKENS;
                            Job->Filter = Filter;
                        }

                    }
                }

                ExReleaseResourceLite (&Job->JobLock);
            }
        }
        break;

    case JobObjectEndOfJobTimeInformation:

        try {
            RtlCopyMemory (&EndOfJobInfo, JobObjectInformation, RequiredLength);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        if (NT_SUCCESS (st)) {
            //
            // sanity check LimitFlags
            //
            if (EndOfJobInfo.EndOfJobTimeAction > JOB_OBJECT_POST_AT_END_OF_JOB) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);
                Job->EndOfJobTimeAction = EndOfJobInfo.EndOfJobTimeAction;
                ExReleaseResourceLite (&Job->JobLock);
            }
        }
        break;

    case JobObjectAssociateCompletionPortInformation:

        try {
            RtlCopyMemory (&AssociateInfo, JobObjectInformation, RequiredLength);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        if ( NT_SUCCESS(st) ) {
            if (Job->CompletionPort || AssociateInfo.CompletionPort == NULL) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                st = ObReferenceObjectByHandle (AssociateInfo.CompletionPort,
                                                IO_COMPLETION_MODIFY_STATE,
                                                IoCompletionObjectType,
                                                PreviousMode,
                                                &IoCompletion,
                                                NULL);

                if (NT_SUCCESS(st)) {
                    ExAcquireResourceExclusiveLite(&Job->JobLock, TRUE);

                    //
                    // If the job already has a completion port or if the job has been rundown
                    // then reject the request.
                    //
                    if (Job->CompletionPort != NULL || (Job->JobFlags&PS_JOB_FLAGS_CLOSE_DONE) != 0) {
                        ExReleaseResourceLite(&Job->JobLock);

                        ObDereferenceObject (IoCompletion);
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        Job->CompletionKey = AssociateInfo.CompletionKey;

                        KeMemoryBarrier ();
                        Job->CompletionPort = IoCompletion;
                        //
                        // Now whip through ALL existing processes in the job
                        // and send notification messages
                        //

                        Next = Job->ProcessListHead.Flink;

                        while (Next != &Job->ProcessListHead) {

                            Process = (PEPROCESS)(CONTAINING_RECORD(Next,EPROCESS,JobLinks));

                            //
                            // If the process is really considered part of the job, has
                            // been assigned its id, and has not yet checked in, do it now
                            //

                            if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)
                                 && Process->UniqueProcessId
                                 && !(Process->JobStatus & PS_JOB_STATUS_NEW_PROCESS_REPORTED)) {

                                PS_SET_CLEAR_BITS (&Process->JobStatus,
                                                   PS_JOB_STATUS_NEW_PROCESS_REPORTED,
                                                   PS_JOB_STATUS_LAST_REPORT_MEMORY);

                                IoSetIoCompletion(
                                    Job->CompletionPort,
                                    Job->CompletionKey,
                                    (PVOID)Process->UniqueProcessId,
                                    STATUS_SUCCESS,
                                    JOB_OBJECT_MSG_NEW_PROCESS,
                                    FALSE
                                    );

                            }
                            Next = Next->Flink;
                        }
                        ExReleaseResourceLite(&Job->JobLock);
                    }
                }
            }
        }
        break;


    default:

        st = STATUS_INVALID_INFO_CLASS;
    }


    //
    // Working Set Changes are processed outside of the job lock.
    //
    // calling MmAdjust CAN NOT cause MM to call PsChangeJobMemoryUsage !
    //

    if (ProcessWorkingSetHead) {
        LIST_ENTRY FreeList;
        KAPC_STATE ApcState;

        InitializeListHead (&FreeList);
        while (!IsListEmpty (&PspWorkingSetChangeHead.Links)) {
            Next = RemoveHeadList(&PspWorkingSetChangeHead.Links);
            InsertTailList (&FreeList, Next);
            WsChangeRecord = CONTAINING_RECORD(Next,JOB_WORKING_SET_CHANGE_RECORD,Links);

            KeStackAttachProcess(&WsChangeRecord->Process->Pcb, &ApcState);

            MmAdjustWorkingSetSize (PspWorkingSetChangeHead.MinimumWorkingSetSize,
                                    PspWorkingSetChangeHead.MaximumWorkingSetSize,
                                    FALSE,
                                    TRUE);

            //
            // call MM to Enable hard workingset
            //

            MmEnforceWorkingSetLimit(WsChangeRecord->Process,
                                     MM_WORKING_SET_MAX_HARD_ENABLE);
            KeUnstackDetachProcess(&ApcState);
        }
        PspUnlockWorkingSetChangeExclusiveUnsafe ();

        while (!IsListEmpty (&FreeList)) {
            Next = RemoveHeadList(&FreeList);
            WsChangeRecord = CONTAINING_RECORD(Next,JOB_WORKING_SET_CHANGE_RECORD,Links);

            ObDereferenceObject (WsChangeRecord->Process);
            ExFreePool (WsChangeRecord);
        }
    }

    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);


    //
    // Finish Up
    //

    ObDereferenceObject(Job);

    return st;
}

VOID
PspApplyJobLimitsToProcessSet(
    PEJOB Job
    )
{
    PEPROCESS Process;
    PJOB_WORKING_SET_CHANGE_RECORD WsChangeRecord;

    PAGED_CODE();

    //
    // The job object is held exclusive by the caller
    //

    for (Process = PspGetNextJobProcess (Job, NULL);
         Process != NULL;
         Process = PspGetNextJobProcess (Job, Process)) {

        if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
            if (Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
                WsChangeRecord = ExAllocatePoolWithTag (PagedPool,
                                                        sizeof(*WsChangeRecord),
                                                        'rCsP');
                if (WsChangeRecord != NULL) {
                    WsChangeRecord->Process = Process;
                    ObReferenceObject (Process);
                    InsertTailList(&PspWorkingSetChangeHead.Links,&WsChangeRecord->Links);
                }
            }
            PspApplyJobLimitsToProcess(Job,Process);
        }
    }
}

VOID
PspApplyJobLimitsToProcess(
    PEJOB Job,
    PEPROCESS Process
    )
{
    PETHREAD CurrentThread;
    PAGED_CODE();

    //
    // The job object is held exclusive by the caller
    //

    if (Job->LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS) {
        Process->PriorityClass = Job->PriorityClass;
        PsSetProcessPriorityByClass(Process,
                                    Process->Vm.Flags.MemoryPriority == MEMORY_PRIORITY_FOREGROUND ?
                                        PsProcessPriorityForeground : PsProcessPriorityBackground);
    }

    CurrentThread = PsGetCurrentThread ();
    if ( Job->LimitFlags & JOB_OBJECT_LIMIT_AFFINITY ) {
        PspLockProcessExclusive (Process, CurrentThread);
        KeSetAffinityProcess (&Process->Pcb, Job->Affinity);
        PspUnlockProcessExclusive (Process, CurrentThread);
    }

    if (!(Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET)) {

        //
        // call MM to disable hard workingset
        //

        MmEnforceWorkingSetLimit(Process, MM_WORKING_SET_MAX_HARD_DISABLE);
    }

    PspLockJobLimitsShared (Job, CurrentThread);
    if (Job->LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY) {
        Process->CommitChargeLimit = Job->ProcessMemoryLimit;

    } else {
        Process->CommitChargeLimit = 0;
    }

    PspUnlockJobLimitsShared (Job, CurrentThread);

    //
    // If the process is NOT IDLE Priority Class, and long fixed quantums
    // are in use, use the scheduling class stored in the job object for this process
    //
    if (Process->PriorityClass != PROCESS_PRIORITY_CLASS_IDLE) {
        if (PspUseJobSchedulingClasses ) {
            KeSetQuantumProcess(&Process->Pcb,
                                PspJobSchedulingClasses[Job->SchedulingClass]);
        }

        //
        // if the scheduling class is PSP_NUMBER_OF_SCHEDULING_CLASSES-1, then
        // give this process non-preemptive scheduling
        //

        if (Job->SchedulingClass == PSP_NUMBER_OF_SCHEDULING_CLASSES-1) {
            KeSetDisableQuantumProcess (&Process->Pcb,TRUE);

        } else {
            KeSetDisableQuantumProcess (&Process->Pcb,FALSE);
        }
    }

    return;
}

NTSTATUS
NtTerminateJobObject(
    __in HANDLE JobHandle,
    __in NTSTATUS ExitStatus
    )
{
    PEJOB Job;
    NTSTATUS st;
    KPROCESSOR_MODE PreviousMode;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    st = ObReferenceObjectByHandle (JobHandle,
                                    JOB_OBJECT_TERMINATE,
                                    PsJobType,
                                    PreviousMode,
                                    &Job,
                                    NULL);
    if (!NT_SUCCESS (st)) {
        return st;
    }

    PspTerminateAllProcessesInJob (Job, ExitStatus, FALSE);

    ObDereferenceObject (Job);

    return st;
}

VOID
PsEnforceExecutionTimeLimits(
    VOID
    )
{
    LARGE_INTEGER RunningJobTime;
    LARGE_INTEGER ProcessTime;
    PEJOB Job;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    NTSTATUS Status;
    BOOLEAN KilledSome;

    PAGED_CODE();


    CurrentThread = PsGetCurrentThread ();

    //
    // Look at each job. If time limits are set for the job, then enforce them
    //

    for (Job = PsGetNextJob (NULL);
         Job != NULL;
         Job = PsGetNextJob (Job)) {

        if (Job->LimitFlags & (JOB_OBJECT_LIMIT_PROCESS_TIME | JOB_OBJECT_LIMIT_JOB_TIME)) {

            for (Process = PsGetNextJobProcess (Job, NULL);
                 Process != NULL;
                 Process = PsGetNextJobProcess (Job, Process)) {

                //
                // Job looks like a candidate for time enforcing. Need to get the
                // job lock to be sure, but we don't want to hang waiting for the
                // job lock, so skip the job until next time around if we need to
                //
                //

                KeEnterCriticalRegionThread (&CurrentThread->Tcb);
                if (ExAcquireResourceExclusiveLite (&Job->JobLock, FALSE)) {


                    //
                    // Job is setup for time limits
                    //

                    RunningJobTime.QuadPart = Job->ThisPeriodTotalUserTime.QuadPart;

                    if (Job->LimitFlags & (JOB_OBJECT_LIMIT_PROCESS_TIME | JOB_OBJECT_LIMIT_JOB_TIME)) {
                        ULONG TotalUser;

                        KeQueryRuntimeProcess (&Process->Pcb, &TotalUser);
                        ProcessTime.QuadPart = UInt32x32To64 (TotalUser, KeMaximumIncrement);

                        if (!(Process->JobStatus & PS_JOB_STATUS_ACCOUNTING_FOLDED)) {
                            RunningJobTime.QuadPart += ProcessTime.QuadPart;
                        }

                        if (Job->LimitFlags & JOB_OBJECT_LIMIT_PROCESS_TIME ) {
                            if (ProcessTime.QuadPart > Job->PerProcessUserTimeLimit.QuadPart) {

                                //
                                // Process Time Limit has been exceeded.
                                //
                                // Reference the process. Assert that it is not in its
                                // delete routine. If all is OK, then delete and dereference
                                // the process
                                //


                                if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
                                    PS_SET_CLEAR_BITS (&Process->JobStatus,
                                                       PS_JOB_STATUS_NOT_REALLY_ACTIVE,
                                                       PS_JOB_STATUS_LAST_REPORT_MEMORY);

                                    ExReleaseResourceLite (&Job->JobLock);
                                    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

                                    Status = PspTerminateProcess (Process, ERROR_NOT_ENOUGH_QUOTA);

                                    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
                                    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);


                                    if (NT_SUCCESS (Status)) {

                                        Job->TotalTerminatedProcesses++;
                                        Job->ActiveProcesses--;

                                        if (Job->CompletionPort != NULL) {
                                            IoSetIoCompletion (Job->CompletionPort,
                                                               Job->CompletionKey,
                                                               (PVOID)Process->UniqueProcessId,
                                                               STATUS_SUCCESS,
                                                               JOB_OBJECT_MSG_END_OF_PROCESS_TIME,
                                                               FALSE);
                                        }
                                        PspFoldProcessAccountingIntoJob(Job,Process);

                                    }
                                }
                            }
                        }
                    }
                    if (Job->LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME) {
                        if (RunningJobTime.QuadPart > Job->PerJobUserTimeLimit.QuadPart ) {

                            //
                            // Job Time Limit has been exceeded.
                            //
                            // Perform the appropriate action
                            //

                            switch (Job->EndOfJobTimeAction) {

                            case JOB_OBJECT_TERMINATE_AT_END_OF_JOB:

                                ExReleaseResourceLite (&Job->JobLock);
                                KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

                                KilledSome = PspTerminateAllProcessesInJob (Job, ERROR_NOT_ENOUGH_QUOTA, TRUE);

                                if (!KilledSome) {
                                    continue;
                                }

                                KeEnterCriticalRegionThread (&CurrentThread->Tcb);
                                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                                if (Job->ActiveProcesses == 0 && Job->CompletionPort) {
                                    IoSetIoCompletion (Job->CompletionPort,
                                                       Job->CompletionKey,
                                                       NULL,
                                                       STATUS_SUCCESS,
                                                       JOB_OBJECT_MSG_END_OF_JOB_TIME,
                                                       FALSE);
                                }
                                break;

                            case JOB_OBJECT_POST_AT_END_OF_JOB:

                                if (Job->CompletionPort) {
                                    Status = IoSetIoCompletion (Job->CompletionPort,
                                                                Job->CompletionKey,
                                                                NULL,
                                                                STATUS_SUCCESS,
                                                                JOB_OBJECT_MSG_END_OF_JOB_TIME,
                                                                FALSE);
                                    if (NT_SUCCESS (Status)) {

                                        //
                                        // Clear job level time limit
                                        //

                                        Job->LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_TIME;
                                        Job->PerJobUserTimeLimit.QuadPart = 0;
                                    }
                                } else {

                                    ExReleaseResourceLite (&Job->JobLock);
                                    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

                                    PspTerminateAllProcessesInJob (Job, ERROR_NOT_ENOUGH_QUOTA, TRUE);

                                    continue;
                                }
                                break;
                            }
                        }

                    }

                    ExReleaseResourceLite (&Job->JobLock);
                }
                KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            }
        }
    }
}

BOOLEAN
PspTerminateAllProcessesInJob(
    PEJOB Job,
    NTSTATUS Status,
    BOOLEAN IncCounter
    )
{
    PEPROCESS Process;
    BOOLEAN TerminatedAProcess;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();
    TerminatedAProcess = FALSE;

    for (Process = PsGetNextJobProcess (Job, NULL);
         Process != NULL;
         Process = PsGetNextJobProcess (Job, Process)) {

        if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {

            if (NT_SUCCESS (PspTerminateProcess (Process, Status))) {

                KeEnterCriticalRegionThread (&CurrentThread->Tcb);
                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
                    PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE);

                    if (IncCounter) {
                        Job->TotalTerminatedProcesses++;
                    }

                    Job->ActiveProcesses--;

                    if (Job->ActiveProcesses == 0) {
                        KeSetEvent (&Job->Event,0,FALSE);
                    }

                    PspFoldProcessAccountingIntoJob (Job, Process);


                    TerminatedAProcess = TRUE;
                }

                ExReleaseResourceLite (&Job->JobLock);
                KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            }
        }
    }
    return TerminatedAProcess;
}


VOID
PspFoldProcessAccountingIntoJob(
    PEJOB Job,
    PEPROCESS Process
    )

{

    KPROCESS_VALUES Values;

    if (!(Process->JobStatus & PS_JOB_STATUS_ACCOUNTING_FOLDED)) {

        KeQueryValuesProcess (&Process->Pcb, &Values);
        Job->TotalUserTime.QuadPart += Values.UserTime;
        Job->TotalKernelTime.QuadPart += Values.KernelTime;
        Job->ThisPeriodTotalUserTime.QuadPart += Values.UserTime;
        Job->ThisPeriodTotalKernelTime.QuadPart += Values.KernelTime;

        Job->ReadOperationCount += Values.ReadOperationCount;
        Job->WriteOperationCount += Values.WriteOperationCount;
        Job->OtherOperationCount += Values.OtherOperationCount;
        Job->ReadTransferCount += Values.ReadTransferCount;
        Job->WriteTransferCount += Values.WriteTransferCount;
        Job->OtherTransferCount += Values.OtherTransferCount;

        Job->TotalPageFaultCount += Process->Vm.PageFaultCount;


        if ( Process->CommitChargePeak > Job->PeakProcessMemoryUsed ) {
            Job->PeakProcessMemoryUsed = Process->CommitChargePeak;
        }

        PS_SET_CLEAR_BITS (&Process->JobStatus,
                           PS_JOB_STATUS_ACCOUNTING_FOLDED,
                           PS_JOB_STATUS_LAST_REPORT_MEMORY);

        if (Job->CompletionPort && Job->ActiveProcesses == 0) {
            IoSetIoCompletion(
                Job->CompletionPort,
                Job->CompletionKey,
                NULL,
                STATUS_SUCCESS,
                JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO,
                FALSE
                );
            }
        }
}

NTSTATUS
PspCaptureTokenFilter(
    KPROCESSOR_MODE PreviousMode,
    PJOBOBJECT_SECURITY_LIMIT_INFORMATION SecurityLimitInfo,
    PPS_JOB_TOKEN_FILTER * TokenFilter
    )
{
    NTSTATUS Status ;
    PPS_JOB_TOKEN_FILTER Filter ;

    Filter = ExAllocatePoolWithTag (NonPagedPool,
                                    sizeof (PS_JOB_TOKEN_FILTER),
                                    'fTsP');

    if (!Filter)
    {
        *TokenFilter = NULL;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (Filter, sizeof (PS_JOB_TOKEN_FILTER));

    try {

        Status = STATUS_SUCCESS;

        //
        //  Capture Sids to remove
        //

        if (ARGUMENT_PRESENT (SecurityLimitInfo->SidsToDisable)) {

            ProbeForReadSmallStructure (SecurityLimitInfo->SidsToDisable,
                                        sizeof (TOKEN_GROUPS),
                                        sizeof (ULONG));

            Filter->CapturedGroupCount = SecurityLimitInfo->SidsToDisable->GroupCount;

            Status = SeCaptureSidAndAttributesArray(
                        SecurityLimitInfo->SidsToDisable->Groups,
                        Filter->CapturedGroupCount,
                        PreviousMode,
                        NULL, 0,
                        NonPagedPool,
                        TRUE,
                        &Filter->CapturedGroups,
                        &Filter->CapturedGroupsLength);
        }

        //
        //  Capture PrivilegesToDelete
        //

        if (NT_SUCCESS (Status) &&
            ARGUMENT_PRESENT (SecurityLimitInfo->PrivilegesToDelete)) {

            ProbeForReadSmallStructure (SecurityLimitInfo->PrivilegesToDelete,
                                        sizeof (TOKEN_PRIVILEGES),
                                        sizeof (ULONG));

            Filter->CapturedPrivilegeCount = SecurityLimitInfo->PrivilegesToDelete->PrivilegeCount;

            Status = SeCaptureLuidAndAttributesArray(
                         SecurityLimitInfo->PrivilegesToDelete->Privileges,
                         Filter->CapturedPrivilegeCount,
                         PreviousMode,
                         NULL, 0,
                         NonPagedPool,
                         TRUE,
                         &Filter->CapturedPrivileges,
                         &Filter->CapturedPrivilegesLength);

        }

        //
        //  Capture Restricted Sids
        //

        if (NT_SUCCESS(Status) &&
            ARGUMENT_PRESENT(SecurityLimitInfo->RestrictedSids)) {

            ProbeForReadSmallStructure (SecurityLimitInfo->RestrictedSids,
                                        sizeof (TOKEN_GROUPS),
                                        sizeof (ULONG));

            Filter->CapturedSidCount = SecurityLimitInfo->RestrictedSids->GroupCount;

            Status = SeCaptureSidAndAttributesArray(
                        SecurityLimitInfo->RestrictedSids->Groups,
                        Filter->CapturedSidCount,
                        PreviousMode,
                        NULL, 0,
                        NonPagedPool,
                        TRUE,
                        &Filter->CapturedSids,
                        &Filter->CapturedSidsLength);

        }



    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode ();
    }  // end_try

    if (!NT_SUCCESS (Status)) {
        if (Filter->CapturedSids) {
            ExFreePool (Filter->CapturedSids);
        }

        if (Filter->CapturedPrivileges) {
            ExFreePool (Filter->CapturedPrivileges);
        }

        if (Filter->CapturedGroups) {
            ExFreePool (Filter->CapturedGroups);
        }

        ExFreePool (Filter);

        Filter = NULL;

    }

    *TokenFilter = Filter;

    return Status;
}



BOOLEAN
PsChangeJobMemoryUsage(
    IN ULONG Flags,
    IN SSIZE_T Amount
    )
{
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PEJOB Job;
    SIZE_T CurrentJobMemoryUsed;
    BOOLEAN ReturnValue;

    if ((Flags & PS_JOB_STATUS_REPORT_COMMIT_CHANGES) == 0) {

        //
        // Calls with PS_JOB_STATUS_REPORT_PHYSICAL_PAGE_CHANGES
        // are already happening, but we don't have handling for them yet.
        //

        return TRUE;
    }

    ReturnValue = TRUE;
    CurrentThread = PsGetCurrentThread ();
    Process = PsGetCurrentProcessByThread (CurrentThread);
    Job = Process->Job;
    if ( Job ) {
        //
        // This routine can be called while holding the process lock (during
        // teb deletion... So instead of using the job lock, we must use the
        // memory limits lock. The lock order is always (job lock followed by
        // process lock. The memory limits lock never nests or calls other
        // code while held. It can be grapped while holding the job lock, or
        // the process lock.
        //
        PspLockJobLimitsShared (Job, CurrentThread);


        CurrentJobMemoryUsed = Job->CurrentJobMemoryUsed + Amount;

        if ( Job->LimitFlags & JOB_OBJECT_LIMIT_JOB_MEMORY &&
             CurrentJobMemoryUsed > Job->JobMemoryLimit ) {
            CurrentJobMemoryUsed = Job->CurrentJobMemoryUsed;
            ReturnValue = FALSE;



            //
            // Tell the job port that commit has been exceeded, and process id x
            // was the one that hit it.
            //

            if ( Job->CompletionPort
                 && Process->UniqueProcessId
                 && (Process->JobStatus & PS_JOB_STATUS_NEW_PROCESS_REPORTED)
                 && (Process->JobStatus & PS_JOB_STATUS_LAST_REPORT_MEMORY) == 0) {

                PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_LAST_REPORT_MEMORY);
                IoSetIoCompletion(
                    Job->CompletionPort,
                    Job->CompletionKey,
                    (PVOID)Process->UniqueProcessId,
                    STATUS_SUCCESS,
                    JOB_OBJECT_MSG_JOB_MEMORY_LIMIT,
                    TRUE
                    );

            }
        }

        if (ReturnValue) {
            Job->CurrentJobMemoryUsed = CurrentJobMemoryUsed;

            //
            // Update current and peak counters if this is an addition.
            //

            if (Amount > 0) {
                if (CurrentJobMemoryUsed > Job->PeakJobMemoryUsed) {
                    Job->PeakJobMemoryUsed = CurrentJobMemoryUsed;
                }

                if (Process->CommitCharge + Amount > Job->PeakProcessMemoryUsed) {
                    Job->PeakProcessMemoryUsed = Process->CommitCharge + Amount;
                }
            }
        }

        PspUnlockJobLimitsShared (Job, CurrentThread);
    }

    return ReturnValue;
}


VOID
PsReportProcessMemoryLimitViolation(
    VOID
    )
{
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PEJOB Job;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();
    Process = PsGetCurrentProcessByThread (CurrentThread);
    Job = Process->Job;
    if (Job != NULL && (Job->LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY)) {

        PspLockJobLimitsShared (Job, CurrentThread);

        //
        // Tell the job port that commit has been exceeded, and process id x
        // was the one that hit it.
        //

        if (Job->CompletionPort &&
            Process->UniqueProcessId &&
            (Process->JobStatus & PS_JOB_STATUS_NEW_PROCESS_REPORTED) &&
            (Process->JobStatus & PS_JOB_STATUS_LAST_REPORT_MEMORY) == 0) {

            PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_LAST_REPORT_MEMORY);
            IoSetIoCompletion(
                Job->CompletionPort,
                Job->CompletionKey,
                (PVOID)Process->UniqueProcessId,
                STATUS_SUCCESS,
                JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT,
                TRUE
                );

        }

        PspUnlockJobLimitsShared (Job, CurrentThread);

    }
}

VOID
PspJobTimeLimitsWork(
    IN PVOID Context
    )
{
    PETHREAD CurrentThread;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Context);

    PsEnforceExecutionTimeLimits();

    CurrentThread = PsGetCurrentThread ();

    //
    // Reset timer
    //

    PspLockJobTimeLimitsShared (CurrentThread);

    if (!PspJobTimeLimitsShuttingDown) {
        KeSetTimer (&PspJobTimeLimitsTimer,
                    PspJobTimeLimitsInterval,
                    &PspJobTimeLimitsDpc);
    }

    PspUnlockJobTimeLimitsShared (CurrentThread);
}


VOID
PspJobTimeLimitsDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);
    ExQueueWorkItem(&PspJobTimeLimitsWorkItem, DelayedWorkQueue);
}

VOID
PspInitializeJobStructures(
    )
{

    //
    // Initialize job list head and mutex
    //

    InitializeListHead (&PspJobList); 

    PspInitializeJobListLock ();

    //
    // Initialize job time limits timer, etc
    //

    PspInitializeJobTimeLimitsLock ();

    PspJobTimeLimitsShuttingDown = FALSE;

    KeInitializeDpc (&PspJobTimeLimitsDpc,
                     PspJobTimeLimitsDpcRoutine,
                     NULL);

    ExInitializeWorkItem (&PspJobTimeLimitsWorkItem, PspJobTimeLimitsWork, NULL);
    KeInitializeTimer (&PspJobTimeLimitsTimer);

    PspJobTimeLimitsInterval.QuadPart = Int32x32To64(PSP_ONE_SECOND,
                                                     PSP_JOB_TIME_LIMITS_TIME);
}

VOID
PspInitializeJobStructuresPhase1(
    )
{
    //
    // Wait until Phase1 executive initialization completes (ie: the worker
    // queues must be initialized) before setting off our DPC timer (which
    // queues work items!).
    //

    KeSetTimer (&PspJobTimeLimitsTimer,
                PspJobTimeLimitsInterval,
                &PspJobTimeLimitsDpc);
}

VOID
PspShutdownJobLimits(
    VOID
    )
{
    PETHREAD CurrentThread;


    CurrentThread = PsGetCurrentThread ();

    // Cancel the job time limits enforcement worker

    PspLockJobTimeLimitsExclusive (CurrentThread);

    PspJobTimeLimitsShuttingDown = TRUE;

    KeCancelTimer (&PspJobTimeLimitsTimer);

    PspUnlockJobTimeLimitsExclusive (CurrentThread);
}

NTSTATUS
NtIsProcessInJob (
    __in HANDLE ProcessHandle,
    __in_opt HANDLE JobHandle
    )
/*++

Routine Description:

    This finds out if a process is in a specific or any job

Arguments:

    ProcessHandle - Handle to process to be checked
    JobHandle - Handle of job to check process against, May be NULL to do general query.

Return Value:

    NTSTATUS - Status of call

--*/
{
    KPROCESSOR_MODE PreviousMode;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PEJOB Job;
    NTSTATUS Status;

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (ProcessHandle != NtCurrentProcess ()) {
        Status = ObReferenceObjectByHandle (ProcessHandle,
                                            PROCESS_QUERY_INFORMATION,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    } else {
        Process = PsGetCurrentProcessByThread (CurrentThread);
    }

    if (JobHandle == NULL) {
        Job = Process->Job;
    } else {
        Status = ObReferenceObjectByHandle (JobHandle,
                                            JOB_OBJECT_QUERY,
                                            PsJobType,
                                            PreviousMode,
                                            &Job,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
             goto exit_and_clean;
        }
    }

    if (Process->Job == NULL || Process->Job != Job) {
        Status = STATUS_PROCESS_NOT_IN_JOB;
    } else {
        Status = STATUS_PROCESS_IN_JOB;
    }

    if (JobHandle != NULL) {
        ObDereferenceObject (Job);
    }

exit_and_clean:

    if (ProcessHandle != NtCurrentProcess ()) {
        ObDereferenceObject (Process);
    }
    return Status;
}

NTSTATUS
PspGetJobFromSet (
    IN PEJOB ParentJob,
    IN ULONG JobMemberLevel,
    OUT PEJOB *pJob)
/*++

Routine Description:

    The function selects the job a process will run in. Either the same job as the parent or a job in the same
    job set as the parent but with a JobMemberLevel >= to the parents level/

Arguments:

    ParentJob - Job the parent is in.
    JobMemberLevel - Member level requested for this process. Zero for use parents job.
    Pjob - Returned job to place process in.

Return Value:

    NTSTATUS - Status of call

--*/
{
    PLIST_ENTRY Entry;
    PEJOB Job;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    //
    // This is the normal case. We are not asking to be moved jobs or we are asking for our current level
    //

    if (JobMemberLevel == 0) {
        ObReferenceObject (ParentJob);
        *pJob = ParentJob;
        return STATUS_SUCCESS;
    }

    Status = STATUS_ACCESS_DENIED;

    CurrentThread = PsGetCurrentThread ();

    PspLockJobListShared (CurrentThread);

    if (ParentJob->MemberLevel != 0 && ParentJob->MemberLevel <= JobMemberLevel) {

        for (Entry = ParentJob->JobSetLinks.Flink;
             Entry != &ParentJob->JobSetLinks;
             Entry = Entry->Flink) {

             Job = CONTAINING_RECORD (Entry, EJOB, JobSetLinks);
             if (Job->MemberLevel == JobMemberLevel &&
                 ObReferenceObjectSafe (Job)) {
                 *pJob = Job;
                 Status = STATUS_SUCCESS;
                 break;
             }
        }
    }
    PspUnlockJobListShared (CurrentThread);

    return Status;
}

NTSTATUS
NtCreateJobSet (
    __in ULONG NumJob,
    __in_ecount(NumJob) PJOB_SET_ARRAY UserJobSet,
    __in ULONG Flags
    )
/*++

Routine Description:

    This function creates a job set from multiple job objects.

Arguments:

    NumJob     - Number of jobs in JobSet
    UserJobSet - Pointer to array of jobs to combine
    Flags      - Flags mask for future expansion

Return Value:

    NTSTATUS - Status of call

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG_PTR BufLen;
    PJOB_SET_ARRAY JobSet;
    ULONG JobsProcessed;
    PEJOB Job;
    ULONG MinMemberLevel;
    PEJOB HeadJob;
    PLIST_ENTRY ListEntry;
    PETHREAD CurrentThread;

    //
    // Flags must be zero and number of jobs >= 2 and not overflow when the length is calculated
    //
    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if (NumJob <= 1 || NumJob > MAXULONG_PTR / sizeof (JobSet[0])) {
        return STATUS_INVALID_PARAMETER;
    }

    BufLen = NumJob * sizeof (JobSet[0]);

    JobSet = ExAllocatePoolWithQuotaTag (PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, BufLen, 'bjsP');
    if (JobSet == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    try {
        if (PreviousMode == UserMode) {
            ProbeForRead (UserJobSet, BufLen, TYPE_ALIGNMENT (JOB_SET_ARRAY));
        }
        RtlCopyMemory (JobSet, UserJobSet, BufLen);
    } except (ExSystemExceptionFilter ()) {
        ExFreePool (JobSet);
        return GetExceptionCode ();
    }

    MinMemberLevel = 0;
    Status = STATUS_SUCCESS;
    for (JobsProcessed = 0; JobsProcessed < NumJob; JobsProcessed++) {
        if (JobSet[JobsProcessed].MemberLevel <= MinMemberLevel || JobSet[JobsProcessed].Flags != 0) {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        MinMemberLevel = JobSet[JobsProcessed].MemberLevel;

        Status = ObReferenceObjectByHandle (JobSet[JobsProcessed].JobHandle,
                                            JOB_OBJECT_QUERY,
                                            PsJobType,
                                            PreviousMode,
                                            &Job,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            break;
        }
        JobSet[JobsProcessed].JobHandle = Job;
    }

    if (!NT_SUCCESS (Status)) {
        while (JobsProcessed-- > 0) {
            Job = JobSet[JobsProcessed].JobHandle;
            ObDereferenceObject (Job);
        }
        ExFreePool (JobSet);
        return Status;
    }

    HeadJob = NULL;

    PspLockJobListExclusive (CurrentThread);

    for (JobsProcessed = 0; JobsProcessed < NumJob; JobsProcessed++) {
        Job = JobSet[JobsProcessed].JobHandle;

        //
        // If we are already in a job set then reject this call.
        //
        if (Job->MemberLevel != 0) {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (HeadJob != NULL) {
            if (HeadJob == Job) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            InsertTailList (&HeadJob->JobSetLinks, &Job->JobSetLinks);
        } else {
            HeadJob = Job;
        }
        Job->MemberLevel = JobSet[JobsProcessed].MemberLevel;
    }

    if (!NT_SUCCESS (Status)) {
        if (HeadJob) {
            while (!IsListEmpty (&HeadJob->JobSetLinks)) {
                ListEntry = RemoveHeadList (&HeadJob->JobSetLinks);
                Job = CONTAINING_RECORD (ListEntry, EJOB, JobSetLinks);
                Job->MemberLevel = 0;
                InitializeListHead (&Job->JobSetLinks);
            }
            HeadJob->MemberLevel = 0;
        }
    }

    PspUnlockJobListExclusive (CurrentThread);

    //
    // Dereference all the objects in the error path. If we succeeded then pin all but the first object by
    // leaving the reference there.
    //
    if (!NT_SUCCESS (Status)) {
        for (JobsProcessed = 0; JobsProcessed < NumJob; JobsProcessed++) {
            Job = JobSet[JobsProcessed].JobHandle;
            ObDereferenceObject (Job);
        }
    } else {
        Job = JobSet[0].JobHandle;
        ObDereferenceObject (Job);
    }

    ExFreePool (JobSet);

    return Status;
}

NTSTATUS
PspWin32SessionCallout(
    IN  PKWIN32_JOB_CALLOUT CalloutRoutine,
    IN  PKWIN32_JOBCALLOUT_PARAMETERS Parameters,
    IN  ULONG SessionId
    )
/*++

Routine Description:

    This routine calls the specified callout routine in session space, for the
    specified session.

Parameters:

    CalloutRoutine - Callout routine in session space.

    Parameters     - Parameters to pass the callout routine.

    SessionId      - Specifies the ID of the session in which the specified
                     callout routine is to be called.

Return Value:

    Status code that indicates whether or not the function was successful.

Notes:

    Returns STATUS_NOT_FOUND if the specified session was not found.

--*/
{
    NTSTATUS Status;
    PVOID OpaqueSession;
    KAPC_STATE ApcState;
    PEPROCESS Process;

    PAGED_CODE();

    //
    // Make sure we have all the information we need to deliver notification.
    //
    if (CalloutRoutine == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the callout routine in session space.
    //
    ASSERT(MmIsSessionAddress((PVOID)CalloutRoutine));

    Process = PsGetCurrentProcess();
    if ((Process->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
        (SessionId == MmGetSessionId (Process))) {
        //
        // If the call is from a user mode process, and we are asked to call the
        // current session, call directly.
        //
        (CalloutRoutine)(Parameters);

        Status = STATUS_SUCCESS;

    } else {
        //
        // Reference the session object for the specified session.
        //
        OpaqueSession = MmGetSessionById (SessionId);
        if (OpaqueSession == NULL) {
            return STATUS_NOT_FOUND;
        }

        //
        // Attach to the specified session.
        //
        Status = MmAttachSession(OpaqueSession, &ApcState);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL,
                       "PspWin32SessionCallout: "
                       "could not attach to 0x%p, session %d for registered notification callout @ 0x%p\n",
                       OpaqueSession,
                       SessionId,
                       CalloutRoutine));
            MmQuitNextSession(OpaqueSession);
            return Status;
        }

        //
        // Dispatch notification to the callout routine.
        //
        (CalloutRoutine)(Parameters);

        //
        // Detach from the session.
        //
        Status = MmDetachSession (OpaqueSession, &ApcState);
        ASSERT(NT_SUCCESS(Status));

        //
        // Dereference the session object.
        //
        Status = MmQuitNextSession (OpaqueSession);
        ASSERT(NT_SUCCESS(Status));
    }

    return Status;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psopen.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psopen.c

Abstract:

    This module implements Process and Thread open.
    This module also contains NtRegisterThreadTerminationPort.

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtOpenProcess)
#pragma alloc_text(PAGE, NtOpenThread)
#endif

NTSTATUS
NtOpenProcess (
    __out PHANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PCLIENT_ID ClientId
    )

/*++

Routine Description:

    This function opens a handle to a process object with the specified
    desired access.

    The object is located either by name, or by locating a thread whose
    Client ID matches the specified Client ID and then opening that thread's
    process.

Arguments:

    ProcessHandle - Supplies a pointer to a variable that will receive
        the process object handle.

    DesiredAccess - Supplies the desired types of access for the process
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.
        If the ObjectName field is specified, then ClientId must not be
        specified.

    ClientId - Supplies a pointer to a ClientId that if supplied
        specifies the thread whose process is to be opened. If this
        argument is specified, then ObjectName field of the ObjectAttributes
        structure must not be specified.

Return Value:

    NTSTATUS - Status of call

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS Process;
    PETHREAD Thread;
    CLIENT_ID CapturedCid={0};
    BOOLEAN ObjectNamePresent;
    BOOLEAN ClientIdPresent;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    ULONG Attributes;

    PAGED_CODE();

    //
    // Make sure that only one of either ClientId or ObjectName is
    // present.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Since we need to look at the ObjectName field, probe
        // ObjectAttributes and capture object name present indicator.
        //

        try {

            ProbeForWriteHandle (ProcessHandle);

            ProbeForReadSmallStructure (ObjectAttributes,
                                        sizeof(OBJECT_ATTRIBUTES),
                                        sizeof(ULONG));
            ObjectNamePresent = (BOOLEAN)ARGUMENT_PRESENT (ObjectAttributes->ObjectName);
            Attributes = ObSanitizeHandleAttributes (ObjectAttributes->Attributes, UserMode);

            if (ARGUMENT_PRESENT (ClientId)) {
                ProbeForReadSmallStructure (ClientId, sizeof (CLIENT_ID), sizeof (ULONG));
                CapturedCid = *ClientId;
                ClientIdPresent = TRUE;
            } else {
                ClientIdPresent = FALSE;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    } else {
        ObjectNamePresent = (BOOLEAN)ARGUMENT_PRESENT (ObjectAttributes->ObjectName);
        Attributes = ObSanitizeHandleAttributes (ObjectAttributes->Attributes, KernelMode);
        if (ARGUMENT_PRESENT (ClientId)) {
            CapturedCid = *ClientId;
            ClientIdPresent = TRUE;
        } else {
            ClientIdPresent = FALSE;
        }
    }

    if (ObjectNamePresent && ClientIdPresent) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

    //
    // Create an AccessState here, because the caller may have
    // DebugPrivilege, which requires us to make special adjustments
    // to his desired access mask.  We do this by modifying the
    // internal fields in the AccessState to achieve the effect
    // we desire.
    //

    Status = SeCreateAccessState(
                 &AccessState,
                 &AuxData,
                 DesiredAccess,
                 &PsProcessType->TypeInfo.GenericMapping
                 );

    if ( !NT_SUCCESS(Status) ) {

        return Status;
    }

    //
    // Check here to see if the caller has SeDebugPrivilege.  If
    // he does, we will allow him any access he wants to the process.
    // We do this by clearing the DesiredAccess in the AccessState
    // and recording what we want him to have in the PreviouslyGrantedAccess
    // field.
    //
    // Note that this routine performs auditing as appropriate.
    //

    if (SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {

        if ( AccessState.RemainingDesiredAccess & MAXIMUM_ALLOWED ) {
            AccessState.PreviouslyGrantedAccess |= PROCESS_ALL_ACCESS;

        } else {

            AccessState.PreviouslyGrantedAccess |= ( AccessState.RemainingDesiredAccess );
        }

        AccessState.RemainingDesiredAccess = 0;

    }

    if (ObjectNamePresent) {

        //
        // Open handle to the process object with the specified desired access,
        // set process handle value, and return service completion status.
        //

        Status = ObOpenObjectByName(
                    ObjectAttributes,
                    PsProcessType,
                    PreviousMode,
                    &AccessState,
                    0,
                    NULL,
                    &Handle
                    );

        SeDeleteAccessState( &AccessState );

        if ( NT_SUCCESS(Status) ) {
            try {
                *ProcessHandle = Handle;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }

        return Status;
    }

    if ( ClientIdPresent ) {

        Thread = NULL;
        if (CapturedCid.UniqueThread) {
            Status = PsLookupProcessThreadByCid(
                        &CapturedCid,
                        &Process,
                        &Thread
                        );

            if (!NT_SUCCESS(Status)) {
                SeDeleteAccessState( &AccessState );
                return Status;
            }
        } else {
            Status = PsLookupProcessByProcessId(
                        CapturedCid.UniqueProcess,
                        &Process
                        );

            if ( !NT_SUCCESS(Status) ) {
                SeDeleteAccessState( &AccessState );
                return Status;
            }
        }

        //
        // OpenObjectByAddress
        //

        Status = ObOpenObjectByPointer(
                    Process,
                    Attributes,
                    &AccessState,
                    0,
                    PsProcessType,
                    PreviousMode,
                    &Handle
                    );

        SeDeleteAccessState( &AccessState );

        if (Thread) {
            ObDereferenceObject(Thread);
        }

        ObDereferenceObject(Process);

        if (NT_SUCCESS (Status)) {

            try {
                *ProcessHandle = Handle;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }

        return Status;

    }

    return STATUS_INVALID_PARAMETER_MIX;
}

NTSTATUS
NtOpenThread (
    __out PHANDLE ThreadHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PCLIENT_ID ClientId
    )

/*++

Routine Description:

    This function opens a handle to a thread object with the specified
    desired access.

    The object is located either by name, or by locating a thread whose
    Client ID matches the specified Client ID.

Arguments:

    ThreadHandle - Supplies a pointer to a variable that will receive
        the thread object handle.

    DesiredAccess - Supplies the desired types of access for the Thread
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.
        If the ObjectName field is specified, then ClientId must not be
        specified.

    ClientId - Supplies a pointer to a ClientId that if supplied
        specifies the thread whose thread is to be opened. If this
        argument is specified, then ObjectName field of the ObjectAttributes
        structure must not be specified.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD Thread;
    CLIENT_ID CapturedCid={0};
    BOOLEAN ObjectNamePresent;
    BOOLEAN ClientIdPresent;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    ULONG HandleAttributes;

    PAGED_CODE();

    //
    // Make sure that only one of either ClientId or ObjectName is
    // present.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Since we need to look at the ObjectName field, probe
        // ObjectAttributes and capture object name present indicator.
        //

        try {

            ProbeForWriteHandle(ThreadHandle);

            ProbeForReadSmallStructure (ObjectAttributes,
                                        sizeof(OBJECT_ATTRIBUTES),
                                        sizeof(ULONG));
            ObjectNamePresent = (BOOLEAN)ARGUMENT_PRESENT(ObjectAttributes->ObjectName);
            HandleAttributes = ObSanitizeHandleAttributes (ObjectAttributes->Attributes, UserMode);

            if (ARGUMENT_PRESENT(ClientId)) {
                ProbeForReadSmallStructure (ClientId, sizeof(CLIENT_ID), sizeof(ULONG));
                CapturedCid = *ClientId;
                ClientIdPresent = TRUE;
            } else {
                ClientIdPresent = FALSE;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    } else {
        ObjectNamePresent = (BOOLEAN) ARGUMENT_PRESENT(ObjectAttributes->ObjectName);
        HandleAttributes = ObSanitizeHandleAttributes (ObjectAttributes->Attributes, KernelMode);
        if (ARGUMENT_PRESENT(ClientId)) {
            CapturedCid = *ClientId;
            ClientIdPresent = TRUE;
        } else {
            ClientIdPresent = FALSE;
        }
    }

    if (ObjectNamePresent && ClientIdPresent) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

    Status = SeCreateAccessState(
                 &AccessState,
                 &AuxData,
                 DesiredAccess,
                 &PsProcessType->TypeInfo.GenericMapping
                 );

    if (!NT_SUCCESS (Status)) {

        return Status;
    }

    //
    // Check here to see if the caller has SeDebugPrivilege.  If
    // he does, we will allow him any access he wants to the process.
    // We do this by clearing the DesiredAccess in the AccessState
    // and recording what we want him to have in the PreviouslyGrantedAccess
    // field.

    if (SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {

        if ( AccessState.RemainingDesiredAccess & MAXIMUM_ALLOWED ) {
            AccessState.PreviouslyGrantedAccess |= THREAD_ALL_ACCESS;

        } else {
 
            AccessState.PreviouslyGrantedAccess |= ( AccessState.RemainingDesiredAccess );
        }

        AccessState.RemainingDesiredAccess = 0;

    }

    if ( ObjectNamePresent ) {

        //
        // Open handle to the Thread object with the specified desired access,
        // set Thread handle value, and return service completion status.
        //

        Status = ObOpenObjectByName(
                    ObjectAttributes,
                    PsThreadType,
                    PreviousMode,
                    &AccessState,
                    0,
                    NULL,
                    &Handle
                    );

        SeDeleteAccessState( &AccessState );

        if ( NT_SUCCESS(Status) ) {
            try {
                *ThreadHandle = Handle;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }
        return Status;
    }

    if ( ClientIdPresent ) {

        if ( CapturedCid.UniqueProcess ) {
            Status = PsLookupProcessThreadByCid(
                        &CapturedCid,
                        NULL,
                        &Thread
                        );

            if ( !NT_SUCCESS(Status) ) {
                SeDeleteAccessState( &AccessState );
                return Status;
            }
        } else {
            Status = PsLookupThreadByThreadId(
                        CapturedCid.UniqueThread,
                        &Thread
                        );

            if ( !NT_SUCCESS(Status) ) {
                SeDeleteAccessState( &AccessState );
                return Status;
            }

        }

        Status = ObOpenObjectByPointer(
                    Thread,
                    HandleAttributes,
                    &AccessState,
                    0,
                    PsThreadType,
                    PreviousMode,
                    &Handle
                    );

        SeDeleteAccessState( &AccessState );
        ObDereferenceObject(Thread);

        if ( NT_SUCCESS(Status) ) {

            try {
                *ThreadHandle = Handle;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }

        return Status;

    }

    return STATUS_INVALID_PARAMETER_MIX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psp.h

Abstract:

    Private Interfaces for process structure.

--*/

#ifndef _PSP_
#define _PSP_

#pragma warning(disable:4054)   // Cast of function pointer to PVOID
#pragma warning(disable:4055)   // Cast of function pointer
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4152)   // Casting function pointers
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4327)   // alignment on assignment
#pragma warning(disable:4328)   // alignment on assignment

#include "ntos.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"
#include "ki.h"
#if defined(_X86_)
#include <vdmntos.h>
#endif
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <string.h>
#if defined(_WIN64)
#include <wow64t.h>
#endif

//
// Working Set Watcher is 8kb. This lets us watch about 4mb of working
// set.
//

#define WS_CATCH_SIZE 8192
#define WS_OVERHEAD 16
#define MAX_WS_CATCH_INDEX (((WS_CATCH_SIZE-WS_OVERHEAD)/sizeof(PROCESS_WS_WATCH_INFORMATION)) - 2)

//
// Process Quota Charges:
//
//  PagedPool
//      Directory Base Page - PAGE_SIZE
//
//  NonPaged
//      Object Body         - sizeof(EPROCESS)
//

#define PSP_PROCESS_PAGED_CHARGE    (PAGE_SIZE)
#define PSP_PROCESS_NONPAGED_CHARGE (sizeof(EPROCESS))

//
// Thread Quota Charges:
//
//  PagedPool
//      Kernel Stack        - 0
//
//  NonPaged
//      Object Body         - sizeof(ETHREAD)
//

#define PSP_THREAD_PAGED_CHARGE     (0)
#define PSP_THREAD_NONPAGED_CHARGE  (sizeof(ETHREAD))

//
// Define routines to get trap and exception frame addresses
//

#define PSPALIGN_DOWN(address,amt) ((ULONG)(address) & ~(( amt ) - 1))

#define PSPALIGN_UP(address,amt) (PSPALIGN_DOWN( (address + (amt) - 1), (amt) ))


#if defined(_AMD64_)

FORCEINLINE
PKTRAP_FRAME
PspGetBaseTrapFrame (
    PETHREAD Thread
    )

{
    ULONG64 InitialStack;
    PKERNEL_STACK_CONTROL StackControl;

    InitialStack = (ULONG64)Thread->Tcb.InitialStack;
    StackControl = (PKERNEL_STACK_CONTROL)InitialStack;
    while (StackControl->Previous.StackBase != 0) {
        InitialStack = StackControl->Previous.InitialStack;
        StackControl = (PKERNEL_STACK_CONTROL)InitialStack;
    }

    return (PKTRAP_FRAME)(InitialStack - KTRAP_FRAME_LENGTH);
}

#define PspGetBaseExceptionFrame(Thread) ((PKEXCEPTION_FRAME)((ULONG_PTR)PspGetBaseTrapFrame(Thread) - \
                                                              KEXCEPTION_FRAME_LENGTH))

#elif defined(_X86_)

#define PspGetBaseTrapFrame(Thread) (PKTRAP_FRAME)((ULONG_PTR)Thread->Tcb.InitialStack - \
                                                   PSPALIGN_UP(sizeof(KTRAP_FRAME),KTRAP_FRAME_ALIGN) - \
                                                   sizeof(FX_SAVE_AREA))

#define PspGetBaseExceptionFrame(Thread) (NULL)

#else

#error "no target architecture"

#endif // defined(_AMD64_)

typedef struct _GETSETCONTEXT {
    KAPC Apc;
    KPROCESSOR_MODE Mode;
    KEVENT OperationComplete;
    CONTEXT Context;
    KNONVOLATILE_CONTEXT_POINTERS NonVolatileContext;
} GETSETCONTEXT, *PGETSETCONTEXT;

typedef struct _SYSTEM_DLL {
    PVOID Section;
    PVOID DllBase;
    PKNORMAL_ROUTINE LoaderInitRoutine;
    EX_PUSH_LOCK DllLock;
} SYSTEM_DLL, PSYSTEM_DLL;

typedef struct _JOB_WORKING_SET_CHANGE_HEAD {
    LIST_ENTRY Links;
    KGUARDED_MUTEX Lock;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
} JOB_WORKING_SET_CHANGE_HEAD, *PJOB_WORKING_SET_CHANGE_HEAD;

typedef struct _JOB_WORKING_SET_CHANGE_RECORD {
    LIST_ENTRY Links;
    PEPROCESS Process;
} JOB_WORKING_SET_CHANGE_RECORD, *PJOB_WORKING_SET_CHANGE_RECORD;

JOB_WORKING_SET_CHANGE_HEAD PspWorkingSetChangeHead;

typedef struct _PRIV_CHECK_CTX {
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    PRIVILEGE_SET RequiredPrivileges;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN AccessGranted;
} PRIV_CHECK_CTX, *PPRIV_CHECK_CTX;

LOGICAL
PspSinglePrivCheck (
    IN LUID PrivilegeValue,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PPRIV_CHECK_CTX PrivCtx
    );

VOID
PspSinglePrivCheckAudit (
    IN LOGICAL PrivUsed,
    IN PPRIV_CHECK_CTX PrivCtx
    );

//
// Private Entry Points
//

VOID
PspProcessDump(
    IN PVOID Object,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );

VOID
PspProcessDelete(
    IN PVOID Object
    );


VOID
PspThreadDump(
    IN PVOID Object,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );

VOID
PspInheritQuota(
    IN PEPROCESS NewProcess,
    IN PEPROCESS ParentProcess
    );

VOID
PspDereferenceQuota(
    IN PEPROCESS Process
    );

VOID
PspThreadDelete(
    IN PVOID Object
    );

NTSTATUS
PspWriteTebImpersonationInfo (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    );

//
// Initialization and loader entrypoints
//

BOOLEAN
PspInitPhase0 (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

BOOLEAN
PspInitPhase1 (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
PspInitializeSystemDll( VOID );

NTSTATUS
PspLookupSystemDllEntryPoint(
    IN PSZ EntryPointName,
    OUT PVOID *EntryPointAddress
    );

NTSTATUS
PspLookupKernelUserEntryPoints(
    VOID
    );

USHORT
PspNameToOrdinal(
    IN PSZ EntryPointName,
    IN ULONG DllBase,
    IN ULONG NumberOfNames,
    IN PULONG NameTableBase,
    IN PUSHORT OrdinalTableBase
    );

//
// Internal Creation Functions
//

NTSTATUS
PspCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess OPTIONAL,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel
    );

#define PSP_MAX_CREATE_PROCESS_NOTIFY 8

//
// Define process callouts. These are of type PCREATE_PROCESS_NOTIFY_ROUTINE 
// Called on process create and delete.
//
ULONG PspCreateProcessNotifyRoutineCount;
EX_CALLBACK PspCreateProcessNotifyRoutine[PSP_MAX_CREATE_PROCESS_NOTIFY];

#define PSP_MAX_CREATE_THREAD_NOTIFY 8

//
// Define thread callouts. These are of type PCREATE_THREAD_NOTIFY_ROUTINE
// Called on thread create and delete.
//
ULONG PspCreateThreadNotifyRoutineCount;
EX_CALLBACK PspCreateThreadNotifyRoutine[PSP_MAX_CREATE_THREAD_NOTIFY];


#define PSP_MAX_LOAD_IMAGE_NOTIFY 8

//
// Define image load callbacks. These are of type PLOAD_IMAGE_NOTIFY_ROUTINE 
// Called on image load.
//
ULONG PspLoadImageNotifyRoutineCount;
EX_CALLBACK PspLoadImageNotifyRoutine[PSP_MAX_LOAD_IMAGE_NOTIFY];


NTSTATUS
PspCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    IN PEPROCESS ProcessPointer,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PCONTEXT ThreadContext OPTIONAL,
    IN PINITIAL_TEB InitialTeb OPTIONAL,
    IN BOOLEAN CreateSuspended,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext
    );

//
// Startup Routines
//

VOID
PspUserThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    );

VOID
PspSystemThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    );

VOID
PspReaper(
    IN PVOID StartContext
    );

VOID
PspNullSpecialApc(
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

//
// Thread Exit Support
//

VOID
PspExitApcRundown(
    IN PKAPC Apc
    );

DECLSPEC_NORETURN
VOID
PspExitThread(
    IN NTSTATUS ExitStatus
    );

NTSTATUS
PspTerminateThreadByPointer(
    IN PETHREAD Thread,
    IN NTSTATUS ExitStatus,
    IN BOOLEAN DirectTerminate
    );


VOID
PspExitSpecialApc(
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
PspExitProcess(
    IN BOOLEAN TrimAddressSpace,
    IN PEPROCESS Process
    );

NTSTATUS
PspWaitForUsermodeExit(
    IN PEPROCESS         Process
    );

//
// Context Management
//

VOID
PspSetContext(
    OUT PKTRAP_FRAME TrapFrame,
    OUT PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext,
    IN PCONTEXT Context,
    KPROCESSOR_MODE Mode
    );

VOID
PspGetContext(
    IN PKTRAP_FRAME TrapFrame,
    IN PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext,
    IN OUT PCONTEXT Context
    );

VOID
PspGetSetContextSpecialApc(
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
PspExitNormalApc(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// private security routines
//

NTSTATUS
PspInitializeProcessSecurity(
    IN PEPROCESS Parent OPTIONAL,
    IN PEPROCESS Child
    );

VOID
PspDeleteProcessSecurity(
  IN PEPROCESS Process
  );

VOID
PspInitializeThreadSecurity(
    IN PEPROCESS Process,
    IN PETHREAD Thread
    );

VOID
PspDeleteThreadSecurity(
    IN PETHREAD Thread
    );

NTSTATUS
PspAssignPrimaryToken(
    IN PEPROCESS Process,
    IN HANDLE Token OPTIONAL,
    IN PACCESS_TOKEN TokenPointer OPTIONAL
    );

NTSTATUS
PspSetPrimaryToken(
    IN HANDLE ProcessHandle,
    IN PEPROCESS ProcessPointer OPTIONAL, 
    IN HANDLE TokenHandle OPTIONAL,
    IN PACCESS_TOKEN TokenPointer OPTIONAL,
    IN BOOLEAN PrivilegeChecked
    );

//
// Ldt support routines
//

#if defined(i386)
NTSTATUS
PspLdtInitialize(
    );
#endif

//
// Vdm support Routines

#if defined(i386)
NTSTATUS
PspVdmInitialize(
    );
#endif

NTSTATUS
PspQueryLdtInformation(
    IN PEPROCESS Process,
    OUT PVOID LdtInformation,
    IN ULONG LdtInformationLength,
    OUT PULONG ReturnLength
    );

NTSTATUS
PspSetLdtInformation(
    IN PEPROCESS Process,
    IN PVOID LdtInformation,
    IN ULONG LdtInformationLength
    );

NTSTATUS
PspSetLdtSize(
    IN PEPROCESS Process,
    IN PVOID LdtSize,
    IN ULONG LdtSizeLength
    );

VOID
PspDeleteLdt(
    IN PEPROCESS Process
    );

//
// Io handling support routines
//


NTSTATUS
PspSetProcessIoHandlers(
    IN PEPROCESS Process,
    IN PVOID IoHandlerInformation,
    IN ULONG IoHandlerLength
    );

VOID
PspDeleteVdmObjects(
    IN PEPROCESS Process
    );

NTSTATUS
PspQueryDescriptorThread (
    PETHREAD Thread,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
    );

//
// Job Object Support Routines
//

VOID
PspInitializeJobStructures(
    VOID
    );

VOID
PspInitializeJobStructuresPhase1(
    VOID
    );

VOID
PspJobTimeLimitsWork(
    IN PVOID Context
    );

VOID
PspJobTimeLimitsDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
PspJobDelete(
    IN PVOID Object
    );

VOID
PspJobClose (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

NTSTATUS
PspAddProcessToJob(
    PEJOB Job,
    PEPROCESS Process
    );

VOID
PspRemoveProcessFromJob(
    PEJOB Job,
    PEPROCESS Process
    );

VOID
PspExitProcessFromJob(
    PEJOB Job,
    PEPROCESS Process
    );

VOID
PspApplyJobLimitsToProcessSet(
    PEJOB Job
    );

VOID
PspApplyJobLimitsToProcess(
    PEJOB Job,
    PEPROCESS Process
    );

BOOLEAN
PspTerminateAllProcessesInJob(
    PEJOB Job,
    NTSTATUS Status,
    BOOLEAN IncCounter
    );

VOID
PspFoldProcessAccountingIntoJob(
    PEJOB Job,
    PEPROCESS Process
    );

NTSTATUS
PspCaptureTokenFilter(
    KPROCESSOR_MODE PreviousMode,
    PJOBOBJECT_SECURITY_LIMIT_INFORMATION SecurityLimitInfo,
    PPS_JOB_TOKEN_FILTER * TokenFilter
    );

KPRIORITY
PspComputeQuantumAndPriority(
    __inout PEPROCESS Process,
    __in PSPROCESSPRIORITYMODE PriorityMode,
    __out PSCHAR QuantumReset
    );

VOID
PspShutdownJobLimits(
    VOID
    );

NTSTATUS
PspTerminateProcess(
    PEPROCESS Process,
    NTSTATUS Status
    );


NTSTATUS
PspGetJobFromSet (
    IN PEJOB ParentJob,
    IN ULONG JobMemberLevel,
    OUT PEJOB *pJob);

NTSTATUS
PspWin32SessionCallout(
    IN  PKWIN32_JOB_CALLOUT CalloutRoutine,
    IN  PKWIN32_JOBCALLOUT_PARAMETERS Parameters,
    IN  ULONG SessionId
    );


//
// This test routine is called on checked systems to test this path
//
VOID
PspImageNotifyTest(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,
    IN PIMAGE_INFO ImageInfo
    );

PEPROCESS
PspGetNextJobProcess (
    IN PEJOB Job,
    IN PEPROCESS Process
    );

VOID
PspQuitNextJobProcess (
    IN PEPROCESS Process
    );

VOID
PspInsertQuotaBlock (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock
    );



VOID
FORCEINLINE
PspInitializeProcessLock (
    IN PEPROCESS Process
    )
{
    ExInitializePushLock (&Process->ProcessLock);
}

VOID
FORCEINLINE
PspLockProcessExclusive (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockExclusive (&Process->ProcessLock);
}

VOID
FORCEINLINE
PspLockProcessShared (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockShared (&Process->ProcessLock);
}

VOID
FORCEINLINE
PspUnlockProcessShared (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    ExReleasePushLockShared (&Process->ProcessLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockProcessExclusive (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    ExReleasePushLockExclusive (&Process->ProcessLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}


//
// Define macros to lock the security fields of the process and thread
//

VOID
FORCEINLINE
PspLockProcessSecurityExclusive (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    PspLockProcessExclusive (Process, CurrentThread);
}

VOID
FORCEINLINE
PspLockProcessSecurityShared (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    PspLockProcessShared (Process, CurrentThread);
}

VOID
FORCEINLINE
PspUnlockProcessSecurityShared (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    PspUnlockProcessShared (Process, CurrentThread);
}

VOID
FORCEINLINE
PspUnlockProcessSecurityExclusive (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    PspUnlockProcessExclusive (Process, CurrentThread);
}


VOID
FORCEINLINE
PspInitializeThreadLock (
    IN PETHREAD Thread
    )
{
    ExInitializePushLock (&Thread->ThreadLock);
}

VOID
FORCEINLINE
PspLockThreadSecurityExclusive (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
{
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockExclusive (&Thread->ThreadLock);
}

VOID
FORCEINLINE
PspLockThreadSecurityShared (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
{
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockShared (&Thread->ThreadLock);
}


VOID
FORCEINLINE
PspUnlockThreadSecurityShared (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
{
    ExReleasePushLockShared (&Thread->ThreadLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockThreadSecurityExclusive (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
{
    ExReleasePushLockExclusive (&Thread->ThreadLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

//
// Define macros to lock the global process list
//

extern KGUARDED_MUTEX PspActiveProcessMutex;

VOID
FORCEINLINE
PspInitializeProcessListLock (
    VOID
    )
{
    KeInitializeGuardedMutex (&PspActiveProcessMutex);
};

VOID
FORCEINLINE
PspLockProcessList (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspActiveProcessMutex);
}

VOID
FORCEINLINE
PspUnlockProcessList (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspActiveProcessMutex);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

//
// Routines to lock and unlock the job list mutex
//

extern KGUARDED_MUTEX PspJobListLock;

VOID
FORCEINLINE
PspInitializeJobListLock (
    VOID
    )
{
    KeInitializeGuardedMutex (&PspJobListLock);
}


VOID
FORCEINLINE
PspLockJobListExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspJobListLock);
}

VOID
FORCEINLINE
PspLockJobListShared (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspJobListLock);
}

VOID
FORCEINLINE
PspUnlockJobListExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspJobListLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockJobListShared (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspJobListLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

//
// Routines to lock the job memory list lock
//

VOID
FORCEINLINE
PspInitializeJobLimitsLock (
    IN PEJOB Job
    )
{
    KeInitializeGuardedMutex (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspLockJobLimitsExclusive (
    IN PEJOB    Job,
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspLockJobLimitsExclusiveUnsafe (
    IN PEJOB    Job
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeAcquireGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspLockJobLimitsShared (
    IN PEJOB    Job,
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspLockJobLimitsSharedUnsafe (
    IN PEJOB Job
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeAcquireGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspUnlockJobLimitsExclusive (
    IN PEJOB    Job,
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&Job->MemoryLimitsLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockJobLimitsExclusiveUnsafe (
    IN PEJOB Job
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeReleaseGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspUnlockJobLimitsShared (
    IN PEJOB    Job,
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&Job->MemoryLimitsLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockJobLimitsSharedUnsafe (
    IN PEJOB Job
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeReleaseGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

//
// Routines to lock job time limits structures
//
extern KGUARDED_MUTEX PspJobTimeLimitsLock;

VOID
FORCEINLINE
PspInitializeJobTimeLimitsLock (
    VOID
    )
{
    KeInitializeGuardedMutex (&PspJobTimeLimitsLock);
}

VOID
FORCEINLINE
PspLockJobTimeLimitsExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspJobTimeLimitsLock);
}

VOID
FORCEINLINE
PspUnlockJobTimeLimitsExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspJobTimeLimitsLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspLockJobTimeLimitsShared (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspJobTimeLimitsLock);
}

VOID
FORCEINLINE
PspUnlockJobTimeLimitsShared (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspJobTimeLimitsLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

//
// Routines for locking working set change lock
//
VOID
FORCEINLINE
PspInitializeWorkingSetChangeLock (
    VOID
    )
{
    KeInitializeGuardedMutex (&PspWorkingSetChangeHead.Lock);
}

VOID
FORCEINLINE
PspLockWorkingSetChangeExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspWorkingSetChangeHead.Lock);
}

VOID
FORCEINLINE
PspUnlockWorkingSetChangeExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspWorkingSetChangeHead.Lock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspLockWorkingSetChangeExclusiveUnsafe (
    VOID
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeAcquireGuardedMutexUnsafe (&PspWorkingSetChangeHead.Lock);
}

VOID
FORCEINLINE
PspUnlockWorkingSetChangeExclusiveUnsafe (
    VOID
    )
{
    KeReleaseGuardedMutexUnsafe (&PspWorkingSetChangeHead.Lock);
    ASSERT (KeAreAllApcsDisabled());
}

//
//
// Global Data
//

extern PHANDLE_TABLE PspCidTable;
extern HANDLE PspInitialSystemProcessHandle;
extern PACCESS_TOKEN PspBootAccessToken;
extern SYSTEM_DLL PspSystemDll;
extern PETHREAD PspShutdownThread;

extern ULONG PspDefaultPagedLimit;
extern ULONG PspDefaultNonPagedLimit;
extern ULONG PspDefaultPagefileLimit;
extern ULONG PsMinimumWorkingSet;

extern EPROCESS_QUOTA_BLOCK PspDefaultQuotaBlock;
extern BOOLEAN PspDoingGiveBacks;

extern PKWIN32_PROCESS_CALLOUT PspW32ProcessCallout;
extern PKWIN32_THREAD_CALLOUT PspW32ThreadCallout;
extern PKWIN32_JOB_CALLOUT PspW32JobCallout;
extern ULONG PspW32ProcessSize;
extern ULONG PspW32ThreadSize;
extern SCHAR PspForegroundQuantum[3];


#define PSP_NUMBER_OF_SCHEDULING_CLASSES    10
#define PSP_DEFAULT_SCHEDULING_CLASSES      5

extern const SCHAR PspJobSchedulingClasses[PSP_NUMBER_OF_SCHEDULING_CLASSES];
extern BOOLEAN PspUseJobSchedulingClasses;

extern LIST_ENTRY PspJobList;
extern KDPC PspJobLimeLimitsDpc;
extern KTIMER PspJobTimeLimitsTimer;
extern WORK_QUEUE_ITEM PspJobTimeLimitsWorkItem;
extern KSPIN_LOCK PspQuotaLock;

#endif // _PSP_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psquota.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psquota.c

Abstract:

    This module implements the quota mechanism for NT

Revision History:

    Changed to be mostly lock free. Preserved the basic design in terms of how quota is managed.

--*/

#include "psp.h"

LIST_ENTRY PspQuotaBlockList; // List of all quota blocks except the default

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, PsInitializeQuotaSystem)
#pragma alloc_text (PAGE, PspInheritQuota)
#pragma alloc_text (PAGE, PspDereferenceQuota)
#pragma alloc_text (PAGE, PsChargeSharedPoolQuota)
#pragma alloc_text (PAGE, PsReturnSharedPoolQuota)
#endif


VOID
PsInitializeQuotaSystem (
    VOID
    )
/*++

Routine Description:

    This function initializes the quota system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KeInitializeSpinLock(&PspQuotaLock);

    PspDefaultQuotaBlock.ReferenceCount = 1;
    PspDefaultQuotaBlock.ProcessCount = 1;
    PspDefaultQuotaBlock.QuotaEntry[PsPagedPool].Limit    = (SIZE_T)-1;
    PspDefaultQuotaBlock.QuotaEntry[PsNonPagedPool].Limit = (SIZE_T)-1;
    PspDefaultQuotaBlock.QuotaEntry[PsPageFile].Limit     = (SIZE_T)-1;

    PsGetCurrentProcess()->QuotaBlock = &PspDefaultQuotaBlock;

    InitializeListHead (&PspQuotaBlockList);
}

VOID
PspInsertQuotaBlock (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock
    )
/*++

Routine Description:

    This routines as a new quota block to the global list of system quota blocks.

Arguments:

    QuotaBlock - Quota block to be inserted into the list.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    ExAcquireSpinLock (&PspQuotaLock, &OldIrql);
    InsertTailList (&PspQuotaBlockList, &QuotaBlock->QuotaList);
    ExReleaseSpinLock (&PspQuotaLock, OldIrql);
}

VOID
PspDereferenceQuotaBlock (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock
    )
/*++

Routine Description:

    This removes a single reference from a quota block and deletes the block if it was the last.

Arguments:

    QuotaBlock - Quota block to dereference

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    SIZE_T ReturnQuota;
    PS_QUOTA_TYPE QuotaType;

    if (InterlockedDecrement ((PLONG) &QuotaBlock->ReferenceCount) == 0) {

        ExAcquireSpinLock (&PspQuotaLock, &OldIrql);

        RemoveEntryList (&QuotaBlock->QuotaList);

        //
        // Free any unreturned quota;
        //
        for (QuotaType = PsNonPagedPool;
             QuotaType <= PsPagedPool;
             QuotaType++) {
            ReturnQuota = QuotaBlock->QuotaEntry[QuotaType].Return + QuotaBlock->QuotaEntry[QuotaType].Limit;
            if (ReturnQuota > 0) {
                MmReturnPoolQuota (QuotaType, ReturnQuota);
            }
        }

        ExReleaseSpinLock (&PspQuotaLock, OldIrql);

        ExFreePool (QuotaBlock);
    }
}

SIZE_T
FORCEINLINE
PspInterlockedExchangeQuota (
    IN PSIZE_T pQuota,
    IN SIZE_T NewQuota)
/*++

Routine Description:

    This function does an interlocked exchange on a quota variable.

Arguments:

    pQuota   - Pointer to a quota entry to exchange into

    NewQuota - The new value to exchange into the quota location.

Return Value:

    SIZE_T - Old value that was contained in the quota variable

--*/
{
#if !defined(_WIN64)
    return InterlockedExchange ((PLONG) pQuota, NewQuota);
#else
    return InterlockedExchange64 ((PLONGLONG) pQuota, NewQuota);
#endif    
}

SIZE_T
FORCEINLINE
PspInterlockedCompareExchangeQuota (
    IN PSIZE_T pQuota,
    IN SIZE_T NewQuota,
    IN SIZE_T OldQuota
   )
/*++

Routine Description:

    This function performs a compare exchange operation on a quota variable

Arguments:

    pQuota - Pointer to the quota variable being changed
    NewQuota - New value to place in the quota variable
    OldQuota - The current contents of the quota variable

Return Value:

    SIZE_T - The old contents of the variable

--*/
{
#if !defined(_WIN64)
    return InterlockedCompareExchange ((PLONG) pQuota, NewQuota, OldQuota);
#else
    return InterlockedCompareExchange64 ((PLONGLONG)pQuota, NewQuota, OldQuota);
#endif
}

SIZE_T
PspReleaseReturnedQuota (
    IN PS_QUOTA_TYPE QuotaType
    )
/*++

Routine Description:

    This function walks the list of system quota blocks and returns any non-returned quota.
    This function is called when we are about to fail a quota charge and we want to try and
    free some resources up.

Arguments:

    QuotaType - Type of quota to scan for.

Return Value:

    SIZE_T - Amount of that quota returned to the system.

--*/
{
    SIZE_T ReturnQuota, Usage, Limit;
    PLIST_ENTRY ListEntry;
    PEPROCESS_QUOTA_BLOCK QuotaBlock;

    ReturnQuota = 0;
    ListEntry = PspQuotaBlockList.Flink;
    while (1) {
        if (ListEntry == &PspQuotaBlockList) {
            break;
        }
        QuotaBlock = CONTAINING_RECORD (ListEntry, EPROCESS_QUOTA_BLOCK, QuotaList);
        //
        // Gather up any unreturned quota;
        //
        ReturnQuota += PspInterlockedExchangeQuota (&QuotaBlock->QuotaEntry[QuotaType].Return, 0);
        //
        // If no more processes are associated with this block then trim its limit back. This
        // block can only have quota returned at this point.
        //
        if (QuotaBlock->ProcessCount == 0) {
            Usage = QuotaBlock->QuotaEntry[QuotaType].Usage;
            Limit = QuotaBlock->QuotaEntry[QuotaType].Limit;
            if (Limit > Usage) {
                if (PspInterlockedCompareExchangeQuota (&QuotaBlock->QuotaEntry[QuotaType].Limit,
                                                        Usage,
                                                        Limit) == Limit) {
                    ReturnQuota += Limit - Usage;
                }
            }
        }

        ListEntry = ListEntry->Flink;
        
    }
    if (ReturnQuota > 0) {
        MmReturnPoolQuota (QuotaType, ReturnQuota);
    }

    return ReturnQuota;
}



//
// Interfaces return different status values for differen quotas. These are the values.
//
const static NTSTATUS PspQuotaStatus[PsQuotaTypes] = {STATUS_QUOTA_EXCEEDED,
                                                      STATUS_QUOTA_EXCEEDED,
                                                      STATUS_PAGEFILE_QUOTA_EXCEEDED};

VOID
FORCEINLINE
PspInterlockedMaxQuota (
    IN PSIZE_T pQuota,
    IN SIZE_T NewQuota
    )
/*++

Routine Description:

    This function makes sure that the target contains a value that >= to the new quota value.
    This is used to maintain peak values.

Arguments:

    pQuota - Pointer to a quota variable
    NewQuota - New value to be used in the maximum comparison.

Return Value:

    None.

--*/
{
    SIZE_T Quota;

    Quota = *pQuota;
    while (1) {
        if (NewQuota <= Quota) {
            break;
        }
        //
        // This looks strange because we don't care if the exchanged succeeded. We only
        // care that the quota is greater than our new quota.
        //
        Quota = PspInterlockedCompareExchangeQuota (pQuota,
                                                    NewQuota,
                                                    Quota);
    }
}

SIZE_T
FORCEINLINE
PspInterlockedAddQuota (
    IN PSIZE_T pQuota,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function adds the specified amount on to the target quota

Arguments:

    pQuota - Pointer to a quota variable to be modified
    Amount - Amount to be added to the quota

Return Value:

    SIZE_T - New value of quota variable after the addition was performed

--*/
{
#if !defined(_WIN64)
    return InterlockedExchangeAdd ((PLONG) pQuota, Amount) + Amount;
#else
    return InterlockedExchangeAdd64 ((PLONGLONG) pQuota, Amount) + Amount;
#endif
}

SIZE_T
FORCEINLINE
PspInterlockedSubtractQuota (
    IN PSIZE_T pUsage,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function subtracts the specified amount on to the target quota

Arguments:

    pQuota - Pointer to a quota variable to be modified
    Amount - Amount to be subtracted from the quota

Return Value:

    SIZE_T - New value of quota variable after the subtraction was performed

--*/
{
#if !defined(_WIN64)
    return InterlockedExchangeAdd ((PLONG) pUsage, -(LONG)Amount) - Amount;
#else
    return InterlockedExchangeAdd64 ((PLONGLONG) pUsage, -(LONGLONG)Amount) - Amount;
#endif
}


BOOLEAN
PspExpandQuota (
    IN PS_QUOTA_TYPE QuotaType,
    IN PEPROCESS_QUOTA_ENTRY QE,
    IN SIZE_T Usage,
    IN SIZE_T Amount,
    OUT SIZE_T *pLimit
    )
/*++

Routine Description:

    This function charges the specified quota to a process quota block

Arguments:

    QuotaType  - The quota being charged. One of PsNonPagedPool, PsPagedPool or PsPageFile.
    QE         - Quota entry being modified
    Usage      - The current quota usage
    Amount     - The amount of quota being charged.
    pLimit     - The new limit

Return Value:

    BOOLEAN - TRUE if quota expansion succeeded.

--*/
{
    SIZE_T Limit, NewLimit;
    KIRQL OldIrql;

    //
    // We need to attempt quota expansion for this request.
    // Acquire the global lock and see if somebody else changed the limit.
    // We don't want to do too many expansions. If somebody else did it
    // then we want to use theirs if possible.
    //
    ExAcquireSpinLock (&PspQuotaLock, &OldIrql);

    //
    // Refetch limit information. Another thread may have done limit expansion/contraction.
    // By refetching limit we preserve the order we established above.
    //
    Limit = QE->Limit;

    //
    // If the request could be satisfied now then repeat.
    //
    if (Usage + Amount <= Limit) {
        ExReleaseSpinLock (&PspQuotaLock, OldIrql);
        *pLimit = Limit;
        return TRUE;
    }
    //
    // If expansion is currently enabled then attempt it.
    // If this fails then scavenge any returns from all the
    // quota blocks in the system and try again.
    //
    if (((QuotaType == PsNonPagedPool)?PspDefaultNonPagedLimit:PspDefaultPagedLimit) == 0) {
       if (MmRaisePoolQuota (QuotaType, Limit, &NewLimit) ||
            (PspReleaseReturnedQuota (QuotaType) > 0 &&
             MmRaisePoolQuota (QuotaType, Limit, &NewLimit))) {
            //
            // We refetch limit here but that doesn't violate the ordering
            //
            Limit = PspInterlockedAddQuota (&QE->Limit, NewLimit - Limit);
            ExReleaseSpinLock (&PspQuotaLock, OldIrql);
            *pLimit = Limit;
            return TRUE;
        }
    }

    ExReleaseSpinLock (&PspQuotaLock, OldIrql);

    *pLimit = Limit;

    return FALSE;
}

NTSTATUS
FORCEINLINE
PspChargeQuota (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock,
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount)
/*++

Routine Description:

    This function charges the specified quota to a process quota block

Arguments:

    QuotaBlock - Quota block to make charges to.
    Process    - Process that is being charged.
    QuotaType  - The quota being charged. One of PsNonPagedPool, PsPagedPool or PsPageFile.
    Amount     - The amount of quota being charged.

Return Value:

    NTSTATUS - Status of the operation

--*/
{
    PEPROCESS_QUOTA_ENTRY QE;
    SIZE_T Usage, Limit, NewUsage, tUsage, Extra;

    QE = &QuotaBlock->QuotaEntry[QuotaType];

    //
    // It is very likely that the quota entry will be modified, so bring it in to the
    // cache as exclusive now.
    //

    Usage = ReadForWriteAccess(&QE->Usage);

    //
    // This memory barrier is important. In order not to have to recheck the limit after
    // we charge the quota we only ever reduce the limit by the same amount we are about
    // to reduce the usage by. Using an out of data limit will only allow us to over charge
    // by an amount another thread is just about to release.
    //

    KeMemoryBarrier ();

    Limit = QE->Limit;
    while (1) {
        NewUsage = Usage + Amount;
        //
        // Wrapping cases are always rejected
        //
        if (NewUsage < Usage) {
            return PspQuotaStatus [QuotaType];
        }
        //
        // If its within the limits then try and grab the quota
        //
        if (NewUsage <= Limit) {
            tUsage = PspInterlockedCompareExchangeQuota (&QE->Usage,
                                                         NewUsage,
                                                         Usage);
            if (tUsage == Usage) {
                //
                // Update the Peak value
                //
                PspInterlockedMaxQuota (&QE->Peak, NewUsage);
                //
                // Update the process counts if needed
                //
                if (Process != NULL) {
                    NewUsage = PspInterlockedAddQuota (&Process->QuotaUsage[QuotaType], Amount);
                    //
                    // Update the peak value
                    //
                    PspInterlockedMaxQuota (&Process->QuotaPeak[QuotaType], NewUsage);
                }
                return STATUS_SUCCESS;
            }
            //
            // The usage has changed under us. We have a new usage from the exchange
            // but must refetch the limit to preserve the ordering we established
            // above this loop. We don't need a memory barrier as we obtained
            // the new value via an interlocked operation and they contain barriers.
            //
            Usage = tUsage;

            KeMemoryBarrier ();

            Limit = QE->Limit;
            continue;
        }

        //
        // Page file quota is not increased
        //
        if (QuotaType == PsPageFile) {
            return PspQuotaStatus [QuotaType];
        } else {
            //
            // First try and grab any returns that this process has made.
            //
            Extra = PspInterlockedExchangeQuota (&QE->Return, 0);
            if (Extra > 0) {
                //
                // We had some returns so add this to the limit. We can retry the
                // acquire with the new limit. We refetch the limit here but that
                // doesn't violate the state we set up at the top of the loop.
                // The state is that we read the Usage before we read the limit.
                //
                Limit = PspInterlockedAddQuota (&QE->Limit, Extra);
                continue;
            }
            //
            // Try to expand quota if we can
            //
            if (PspExpandQuota (QuotaType, QE, Usage, Amount, &Limit)) {
                //
                // We refetched limit here but that doesn't violate the ordering
                //
                continue;
            }

            return PspQuotaStatus [QuotaType];
        }
    }
}

VOID
PspGivebackQuota (
    IN PS_QUOTA_TYPE QuotaType,
    IN PEPROCESS_QUOTA_ENTRY QE
    )
/*++

Routine Description:

    This function returns excess freed quota to MM

Arguments:

    QuotaType  - The quota being returned. One of PsNonPagedPool, PsPagedPool or PsPageFile.
    QE -  Quote entry to return to

Return Value:

    None.

--*/
{
    SIZE_T GiveBack;
    KIRQL OldIrql;

    //
    // Acquire a global spinlock so we only have one thread giving back to the system
    //
    ExAcquireSpinLock (&PspQuotaLock, &OldIrql);
    GiveBack = PspInterlockedExchangeQuota (&QE->Return, 0);
    if (GiveBack > 0) {
        MmReturnPoolQuota (QuotaType, GiveBack);
    }
    ExReleaseSpinLock (&PspQuotaLock, OldIrql);
}

VOID
FORCEINLINE
PspReturnQuota (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock,
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount)
/*++

Routine Description:

    This function returns previously charged quota to the quota block

Arguments:

    QuotaBlock - Quota block to return charges to.
    Process    - Process that was originaly charged.
    QuotaType  - The quota being returned. One of PsNonPagedPool, PsPagedPool or PsPageFile.
    Amount     - The amount of quota being returned.

Return Value:

    None.

--*/
{
    PEPROCESS_QUOTA_ENTRY QE;
    SIZE_T Usage, NewUsage, tUsage, tAmount, rAmount, Limit, NewLimit, tLimit;
    SIZE_T GiveBackLimit, GiveBack;

    QE = &QuotaBlock->QuotaEntry[QuotaType];

    //
    // It is very likely that the quota entry will be modified, so bring it in to the
    // cache as exclusive now.
    //

    Usage = ReadForWriteAccess(&QE->Usage);
    Limit = QE->Limit;

    //
    // We need to give back quota here if we have lots to return.
    //
#define PSMINGIVEBACK ((MMPAGED_QUOTA_INCREASE > MMNONPAGED_QUOTA_INCREASE)?MMNONPAGED_QUOTA_INCREASE:MMPAGED_QUOTA_INCREASE)
    if (Limit - Usage >  PSMINGIVEBACK && Limit > Usage) {
        if (QuotaType != PsPageFile  && QuotaBlock != &PspDefaultQuotaBlock && PspDoingGiveBacks) {
            if (QuotaType == PsPagedPool) {
                GiveBackLimit = MMPAGED_QUOTA_INCREASE;
            } else {
                GiveBackLimit = MMNONPAGED_QUOTA_INCREASE;
            }
            if (GiveBackLimit > Amount) {
                GiveBack = Amount;
            } else {
                GiveBack = GiveBackLimit;
            }
            NewLimit = Limit - GiveBack;
            tLimit = PspInterlockedCompareExchangeQuota (&QE->Limit,
                                                         NewLimit,
                                                         Limit);
            
            if (tLimit == Limit) {
                //
                // We succeeded in shrinking the limit. Add this reduction to the return field.
                // If returns exceed a threshold then give the lot back to MM.
                //
                GiveBack = PspInterlockedAddQuota (&QE->Return, GiveBack);
                if (GiveBack > GiveBackLimit) {
                    PspGivebackQuota (QuotaType, QE);
                }
            }
        }
    }

    //
    // Now return the quota to the usage field.
    // The charge might have been split across the default quota block and
    // a new quota block. We have to handle this case here by first returning
    // quota to the specified quota block then skipping to the default.
    //
    rAmount = Amount;
    while (1) {
        if (rAmount > Usage) {
            tAmount = Usage;
            NewUsage = 0;
        } else {
            tAmount = rAmount;
            NewUsage = Usage - rAmount;
        }

        tUsage = PspInterlockedCompareExchangeQuota (&QE->Usage,
                                                     NewUsage,
                                                     Usage);
        if (tUsage == Usage) {
            //
            // Update the process counts if needed
            //
            if (Process != NULL) {
                ASSERT (tAmount <= Process->QuotaUsage[QuotaType]);
                NewUsage = PspInterlockedSubtractQuota (&Process->QuotaUsage[QuotaType], tAmount);
            }
            rAmount = rAmount - tAmount;
            if (rAmount == 0) {
                return;
            }
            ASSERT (QuotaBlock != &PspDefaultQuotaBlock);
            if (QuotaBlock == &PspDefaultQuotaBlock) {
                return;
            }
            QuotaBlock = &PspDefaultQuotaBlock;
            QE = &QuotaBlock->QuotaEntry[QuotaType];
            Usage = QE->Usage;
        } else {
            Usage = tUsage;
        }

    }
}

PEPROCESS_QUOTA_BLOCK
PsChargeSharedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T PagedAmount,
    IN SIZE_T NonPagedAmount
    )

/*++

Routine Description:

    This function charges shared pool quota of the specified pool type
    to the specified process's pooled quota block.  If the quota charge
    would exceed the limits allowed to the process, then an exception is
    raised and quota is not charged.

Arguments:

    Process - Supplies the process to charge quota to.

    PagedAmount - Supplies the amount of paged pool quota to charge.

    PagedAmount - Supplies the amount of non paged pool quota to charge.

Return Value:

    NULL - Quota was exceeded

    NON-NULL - A referenced pointer to the quota block that was charged

--*/

{
    PEPROCESS_QUOTA_BLOCK QuotaBlock;
    NTSTATUS Status;

    ASSERT((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    if (Process == PsInitialSystemProcess) {
        return (PEPROCESS_QUOTA_BLOCK) 1;
    }

    QuotaBlock = Process->QuotaBlock;

    if (PagedAmount > 0) {
        Status = PspChargeQuota (QuotaBlock, NULL, PsPagedPool, PagedAmount);
        if (!NT_SUCCESS (Status)) {
            return NULL;
        }
    }
    if (NonPagedAmount > 0) {
        Status = PspChargeQuota (QuotaBlock, NULL, PsNonPagedPool, NonPagedAmount);
        if (!NT_SUCCESS (Status)) {
            if (PagedAmount > 0) {
                PspReturnQuota (QuotaBlock, NULL, PsPagedPool, PagedAmount);
            }
            return NULL;
        }
    }

    InterlockedIncrement ((PLONG) &QuotaBlock->ReferenceCount);
    return QuotaBlock;
}


VOID
PsReturnSharedPoolQuota(
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock,
    IN SIZE_T PagedAmount,
    IN SIZE_T NonPagedAmount
    )

/*++

Routine Description:

    This function returns pool quota of the specified pool type to the
    specified process.

Arguments:

    QuotaBlock - Supplies the quota block to return quota to.

    PagedAmount - Supplies the amount of paged pool quota to return.

    PagedAmount - Supplies the amount of non paged pool quota to return.

Return Value:

    None.

--*/

{
    //
    // if we bypassed the quota charge, don't do anything here either
    //

    if (QuotaBlock == (PEPROCESS_QUOTA_BLOCK) 1) {
        return;
    }

    if (PagedAmount > 0) {
        PspReturnQuota (QuotaBlock, NULL, PsPagedPool, PagedAmount);
    }

    if (NonPagedAmount > 0) {
        PspReturnQuota (QuotaBlock, NULL, PsNonPagedPool, NonPagedAmount);
    }

    PspDereferenceQuotaBlock (QuotaBlock);
}

VOID
PsChargePoolQuota(
    __in PEPROCESS Process,
    __in POOL_TYPE PoolType,
    __in ULONG_PTR Amount
    )

/*++

Routine Description:

    This function charges pool quota of the specified pool type to
    the specified process. If the quota charge would exceed the limits
    allowed to the process, then an exception is raised and quota is
    not charged.

Arguments:

    Process - Supplies the process to charge quota to.

    PoolType - Supplies the type of pool quota to charge.

    Amount - Supplies the amount of pool quota to charge.

Return Value:

    Raises STATUS_QUOTA_EXCEEDED if the quota charge would exceed the
        limits allowed to the process.

--*/
{
    NTSTATUS Status;

    Status = PsChargeProcessPoolQuota (Process,
                                       PoolType,
                                       Amount);
    if (!NT_SUCCESS (Status)) {
        ExRaiseStatus (Status);
    }
}

NTSTATUS
PsChargeProcessPoolQuota(
    __in PEPROCESS Process,
    __in POOL_TYPE PoolType,
    __in ULONG_PTR Amount
    )

/*++

Routine Description:

    This function charges pool quota of the specified pool type to
    the specified process. If the quota charge would exceed the limits
    allowed to the process, then an exception is raised and quota is
    not charged.

Arguments:

    Process - Supplies the process to charge quota to.

    PoolType - Supplies the type of pool quota to charge.

    Amount - Supplies the amount of pool quota to charge.

Return Value:

    NTSTATUS - Status of operation

--*/

{
    ASSERT ((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    ASSERT (PoolType == PagedPool || PoolType == NonPagedPool);

    __assume (PoolType == PagedPool || PoolType == NonPagedPool);


    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }

    return PspChargeQuota (Process->QuotaBlock, Process, PoolType, Amount);
}

VOID
PsReturnPoolQuota(
    __in PEPROCESS Process,
    __in POOL_TYPE PoolType,
    __in ULONG_PTR Amount
    )

/*++

Routine Description:

    This function returns pool quota of the specified pool type to the
    specified process.

Arguments:

    Process - Supplies the process to return quota to.

    PoolType - Supplies the type of pool quota to return.

    Amount - Supplies the amount of pool quota to return

Return Value:

    Raises STATUS_QUOTA_EXCEEDED if the quota charge would exceed the
        limits allowed to the process.

--*/

{
    ASSERT((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    ASSERT (PoolType == PagedPool || PoolType == NonPagedPool);

    __assume (PoolType == PagedPool || PoolType == NonPagedPool);

    if (Process == PsInitialSystemProcess) {
        return;
    }

    PspReturnQuota (Process->QuotaBlock, Process, PoolType, Amount);
    return;
}

VOID
PspInheritQuota(
    IN PEPROCESS NewProcess,
    IN PEPROCESS ParentProcess
    )
{
    PEPROCESS_QUOTA_BLOCK QuotaBlock;

    if (ParentProcess) {
        QuotaBlock = ParentProcess->QuotaBlock;
    } else {
        QuotaBlock = &PspDefaultQuotaBlock;
    }

    InterlockedIncrement ((PLONG) &QuotaBlock->ReferenceCount);
    InterlockedIncrement ((PLONG) &QuotaBlock->ProcessCount);
    NewProcess->QuotaBlock = QuotaBlock;
}

VOID
PspDereferenceQuota (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function is called at process object deletion to remove the quota block.

Arguments:

    Process - Supplies the process to return quota to.


Return Value:

    None.

--*/
{
    PEPROCESS_QUOTA_BLOCK QuotaBlock;

    ASSERT (Process->QuotaUsage[PsNonPagedPool] == 0);

    ASSERT (Process->QuotaUsage[PsPagedPool]    == 0);

    ASSERT (Process->QuotaUsage[PsPageFile]     == 0);

    QuotaBlock = Process->QuotaBlock;

    InterlockedDecrement ((PLONG) &QuotaBlock->ProcessCount);
    PspDereferenceQuotaBlock (QuotaBlock);
}

NTSTATUS
PsChargeProcessQuota (
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to charge against the specified quota.

Arguments:

    Process   - Supplies the process to charge against.
    QuotaType - Type of quota being charged
    Amount    - Amount of quota being charged


Return Value:

    NTSTATUS - Status of operation

--*/
{
    ASSERT ((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }

    return PspChargeQuota (Process->QuotaBlock, Process, QuotaType, Amount);
}

VOID
PsReturnProcessQuota (
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to return previously charged quota to the specified process

Arguments:

    Process   - Supplies the process that was previously charged.
    QuotaType - Type of quota being returned
    Amount    - Amount of quota being returned


Return Value:

    NTSTATUS - Status of operation

--*/
{
    ASSERT ((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    if (Process == PsInitialSystemProcess) {
        return;
    }

    PspReturnQuota (Process->QuotaBlock, Process, QuotaType, Amount);
}

NTSTATUS
PsChargeProcessNonPagedPoolQuota(
    __in PEPROCESS Process,
    __in SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to charge non-paged pool quota against the specified process.

Arguments:

    Process   - Supplies the process to charge against.
    Amount    - Amount of quota being charged


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }
    return PspChargeQuota (Process->QuotaBlock, Process, PsNonPagedPool, Amount);
}

VOID
PsReturnProcessNonPagedPoolQuota(
    __in PEPROCESS Process,
    __in SIZE_T Amount
    )
    
/*++

Routine Description:

    This function is called to return previously charged non-paged pool quota to the specified process

Arguments:

    Process   - Supplies the process that was previously charged.
    Amount    - Amount of quota being returned


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return;
    }
    PspReturnQuota (Process->QuotaBlock, Process, PsNonPagedPool, Amount);
}

NTSTATUS
PsChargeProcessPagedPoolQuota(
    __in PEPROCESS Process,
    __in SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to charge paged pool quota against the specified process.

Arguments:

    Process   - Supplies the process to charge against.
    Amount    - Amount of quota being charged


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }
    return PspChargeQuota (Process->QuotaBlock, Process, PsPagedPool, Amount);
}

VOID
PsReturnProcessPagedPoolQuota(
    __in PEPROCESS Process,
    __in SIZE_T Amount
    )
    
/*++

Routine Description:

    This function is called to return previously charged paged pool quota to the specified process

Arguments:

    Process   - Supplies the process that was previously charged.
    Amount    - Amount of quota being returned


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return;
    }
    PspReturnQuota (Process->QuotaBlock, Process, PsPagedPool, Amount);
}

NTSTATUS
PsChargeProcessPageFileQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to charge page file quota against the specified process.

Arguments:

    Process   - Supplies the process to charge against.
    Amount    - Amount of quota being charged


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }
    return PspChargeQuota (Process->QuotaBlock, Process, PsPageFile, Amount);
}

VOID
PsReturnProcessPageFileQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to return previously charged page file quota to the specified process

Arguments:

    Process   - Supplies the process that was previously charged.
    Amount    - Amount of quota being returned


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return;
    }
    PspReturnQuota (Process->QuotaBlock, Process, PsPageFile, Amount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psspnd.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psspnd.c

Abstract:

    This module implements NtSuspendThread and NtResumeThread

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtSuspendThread)
#pragma alloc_text(PAGE, NtResumeThread)
#pragma alloc_text(PAGE, NtAlertThread)
#pragma alloc_text(PAGE, NtAlertResumeThread)
#pragma alloc_text(PAGE, NtTestAlert)
#pragma alloc_text(PAGE, NtSuspendProcess)
#pragma alloc_text(PAGE, NtResumeProcess)

#pragma alloc_text(PAGE, PsSuspendThread)
#pragma alloc_text(PAGE, PsSuspendProcess)
#pragma alloc_text(PAGE, PsResumeProcess)
#pragma alloc_text(PAGE, PsResumeThread)
#endif

NTSTATUS
PsSuspendThread (
    IN PETHREAD Thread,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )
/*++

Routine Description:

    This function suspends the target thread, and optionally
    returns the previous suspend count.

Arguments:

    ThreadHandle - Supplies a handle to the thread object to suspend.

    PreviousSuspendCount - An optional parameter, that if specified
        points to a variable that receives the thread's previous suspend
        count.

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    ULONG LocalPreviousSuspendCount = 0;

    PAGED_CODE();

    if (Thread == PsGetCurrentThread ()) {
        try {
            LocalPreviousSuspendCount = (ULONG) KeSuspendThread (&Thread->Tcb);
            Status = STATUS_SUCCESS;
        } except ((GetExceptionCode () == STATUS_SUSPEND_COUNT_EXCEEDED)?
                     EXCEPTION_EXECUTE_HANDLER :
                     EXCEPTION_CONTINUE_SEARCH) {
            Status = GetExceptionCode();
        }
    } else {
        //
        // Protect the remote thread from being rundown.
        //
        if (ExAcquireRundownProtection (&Thread->RundownProtect)) {

            //
            // Don't allow suspend if we are being deleted
            //
            if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) {
                Status = STATUS_THREAD_IS_TERMINATING;
            } else {
                try {
                    LocalPreviousSuspendCount = (ULONG) KeSuspendThread (&Thread->Tcb);
                    Status = STATUS_SUCCESS;
                } except ((GetExceptionCode () == STATUS_SUSPEND_COUNT_EXCEEDED)?
                              EXCEPTION_EXECUTE_HANDLER :
                              EXCEPTION_CONTINUE_SEARCH) {
                    Status = GetExceptionCode();
                }
                //
                // If deletion was started after we suspended then wake up the thread
                //
                if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) {
                    KeForceResumeThread (&Thread->Tcb);
                    LocalPreviousSuspendCount = 0;
                    Status = STATUS_THREAD_IS_TERMINATING;
                }
            }
            ExReleaseRundownProtection (&Thread->RundownProtect);
        } else {
            Status = STATUS_THREAD_IS_TERMINATING;
        }
    }

    if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
        *PreviousSuspendCount = LocalPreviousSuspendCount;
    }
    return Status;
}

NTSTATUS
PsSuspendProcess (
    PEPROCESS Process
    )
/*++

Routine Description:

    This function suspends all the PS threads in a process.

Arguments:

    Process - Process whose threads are to be suspended

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    NTSTATUS Status;
    PETHREAD Thread;

    PAGED_CODE ();


    if (ExAcquireRundownProtection (&Process->RundownProtect)) {

        for (Thread = PsGetNextProcessThread (Process, NULL);
             Thread != NULL;
             Thread = PsGetNextProcessThread (Process, Thread)) {

            PsSuspendThread (Thread, NULL);
        }

        ExReleaseRundownProtection (&Process->RundownProtect);

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_PROCESS_IS_TERMINATING;
    }

    return Status;
}

NTSTATUS
PsResumeProcess (
    PEPROCESS Process
    )
/*++

Routine Description:

    This function resumes all the PS threads in a process.

Arguments:

    Process - Process whose threads are to be suspended

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    NTSTATUS Status;
    PETHREAD Thread;

    PAGED_CODE ();

    if (ExAcquireRundownProtection (&Process->RundownProtect)) {

        for (Thread = PsGetNextProcessThread (Process, NULL);
             Thread != NULL;
             Thread = PsGetNextProcessThread (Process, Thread)) {

            KeResumeThread (&Thread->Tcb);
        }

        ExReleaseRundownProtection (&Process->RundownProtect);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_PROCESS_IS_TERMINATING;
    }

    return Status;
}

NTSTATUS
NtSuspendThread(
    __in HANDLE ThreadHandle,
    __out_opt PULONG PreviousSuspendCount
    )
    
/*++

Routine Description:

    This function suspends the target thread, and optionally
    returns the previous suspend count.

Arguments:

    ThreadHandle - Supplies a handle to the thread object to suspend.

    PreviousSuspendCount - An optional parameter, that if specified
        points to a variable that receives the thread's previous suspend
        count.

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    ULONG LocalPreviousSuspendCount;
    KPROCESSOR_MODE Mode;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    try {

        if (Mode != KernelMode) {
            if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
                ProbeForWriteUlong (PreviousSuspendCount);
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_SUSPEND_RESUME,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    st = PsSuspendThread (Thread, &LocalPreviousSuspendCount);

    ObDereferenceObject (Thread);

    try {

        if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
            *PreviousSuspendCount = LocalPreviousSuspendCount;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        st = GetExceptionCode ();

    }

    return st;

}

NTSTATUS
PsResumeThread (
    IN PETHREAD Thread,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )
/*++

Routine Description:

    This function resumes a thread that was previously suspended

Arguments:

    Thread - Thread to resume
    
    PreviousSuspendCount - Optional address of a ULONG to place the previous suspend count in

Return Value:

    NTSTATUS - Status of call

--*/
{
    ULONG LocalPreviousSuspendCount;

    PAGED_CODE();

    LocalPreviousSuspendCount = (ULONG) KeResumeThread (&Thread->Tcb);

    if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
        *PreviousSuspendCount = LocalPreviousSuspendCount;
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS
NtResumeThread(
    __in HANDLE ThreadHandle,
    __out_opt PULONG PreviousSuspendCount
    )

/*++

Routine Description:

    This function resumes a thread that was previously suspended

Arguments:

    ThreadHandle - Handle to thread to resume
    
    PreviousSuspendCount - Optional address of a ULONG to place the previous suspend count in

Return Value:

    NTSTATUS - Status of call

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    KPROCESSOR_MODE Mode;
    ULONG LocalPreviousSuspendCount;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    try {

        if (Mode != KernelMode) {
            if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
                ProbeForWriteUlong (PreviousSuspendCount);
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode ();
    }

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_SUSPEND_RESUME,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    PsResumeThread (Thread, &LocalPreviousSuspendCount);

    ObDereferenceObject (Thread);

    try {
        if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
            *PreviousSuspendCount = LocalPreviousSuspendCount;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode ();
    }

    return STATUS_SUCCESS;

}

NTSTATUS
NtSuspendProcess (
    __in HANDLE ProcessHandle
    )
/*++

Routine Description:

    This function suspends all none-exiting threads in the target process

Arguments:

    ProcessHandle - Supplies an open handle to the process to be suspended

Return Value:

    NTSTATUS - Status of operation

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS Process;

    PAGED_CODE();


    PreviousMode = KeGetPreviousMode ();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (NT_SUCCESS (Status)) {
        Status = PsSuspendProcess (Process);
        ObDereferenceObject (Process);
    }

    return Status;
}

NTSTATUS
NtResumeProcess (
    __in HANDLE ProcessHandle
    )
/*++

Routine Description:

    This function suspends all none-exiting threads in the target process

Arguments:

    ProcessHandle - Supplies an open handle to the process to be suspended

Return Value:

    NTSTATUS - Status of operation

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS Process;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode ();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (NT_SUCCESS (Status)) {
        Status = PsResumeProcess (Process);
        ObDereferenceObject (Process);
    }

    return Status;
}

NTSTATUS
NtAlertThread(
    __in HANDLE ThreadHandle
    )

/*++

Routine Description:

    This function alerts the target thread using the previous mode
    as the mode of the alert.

Arguments:

    ThreadHandle - Supplies an open handle to the thread to be alerted

Return Value:

    NTSTATUS - Status of operation

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    KPROCESSOR_MODE Mode;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_ALERT,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    KeAlertThread (&Thread->Tcb,Mode);

    ObDereferenceObject (Thread);

    return STATUS_SUCCESS;

}


NTSTATUS
NtAlertResumeThread(
    __in HANDLE ThreadHandle,
    __out_opt PULONG PreviousSuspendCount
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    NTSTATUS - Status of operation

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    ULONG LocalPreviousSuspendCount;
    KPROCESSOR_MODE Mode;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    try {


        if (Mode != KernelMode ) {
            if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
                ProbeForWriteUlong (PreviousSuspendCount);
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_SUSPEND_RESUME,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    LocalPreviousSuspendCount = (ULONG) KeAlertResumeThread (&Thread->Tcb);

    ObDereferenceObject (Thread);

    try {

        if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
            *PreviousSuspendCount = LocalPreviousSuspendCount;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode ();
    }

    return STATUS_SUCCESS;
}


NTSTATUS
NtTestAlert(
    VOID
    )

/*++

Routine Description:

    This function tests the alert flag inside the current thread. If
    an alert is pending for the previous mode, then the alerted status
    is returned, pending APC's may also be delivered at this time.

Arguments:

    None

Return Value:

    STATUS_ALERTED - An alert was pending for the current thread at the
        time this function was called.

    STATUS_SUCCESS - No alert was pending for this thread.

--*/

{

    PAGED_CODE();

    if (KeTestAlertThread(KeGetPreviousMode ())) {
        return STATUS_ALERTED;
    } else {
        return STATUS_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\psquery.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psquery.c

Abstract:

    This module implements the set and query functions for
    process and thread objects.

--*/

#include "psp.h"
#include "winerror.h"

#if defined(_WIN64)
#include <wow64t.h>
#endif

//
// Process Pooled Quota Usage and Limits
//  NtQueryInformationProcess using ProcessPooledUsageAndLimits
//

//
// this is the csrss process !
//
extern PEPROCESS ExpDefaultErrorPortProcess;
BOOLEAN PsWatchEnabled = FALSE;



#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const KPRIORITY PspPriorityTable[PROCESS_PRIORITY_CLASS_ABOVE_NORMAL+1] = {8,4,8,13,24,6,10};


NTSTATUS
PsConvertToGuiThread(
    VOID
    );

NTSTATUS
PspQueryWorkingSetWatch(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
PspQueryQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
PspQueryPooledQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
PspSetQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    IN KPROCESSOR_MODE PreviousMode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PsEstablishWin32Callouts)
#pragma alloc_text(PAGE, PsConvertToGuiThread)
#pragma alloc_text(PAGE, NtQueryInformationProcess)
#pragma alloc_text(PAGE, NtSetInformationProcess)
#pragma alloc_text(PAGE, NtQueryPortInformationProcess)
#pragma alloc_text(PAGE, NtQueryInformationThread)
#pragma alloc_text(PAGE, NtSetInformationThread)
#pragma alloc_text(PAGE, PsSetProcessPriorityByClass)
#pragma alloc_text(PAGE, PspComputeQuantumAndPriority)
#pragma alloc_text(PAGE, PspSetPrimaryToken)
#pragma alloc_text(PAGE, PspSetQuotaLimits)
#pragma alloc_text(PAGE, PspQueryQuotaLimits)
#pragma alloc_text(PAGE, PspQueryPooledQuotaLimits)
#pragma alloc_text(PAGE, NtGetCurrentProcessorNumber)
#pragma alloc_text(PAGELK, PspQueryWorkingSetWatch)
#endif

NTSTATUS
PspQueryWorkingSetWatch(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    PPAGEFAULT_HISTORY WorkingSetCatcher;
    ULONG SpaceNeeded;
    PEPROCESS Process;
    KIRQL OldIrql;
    NTSTATUS st;

    UNREFERENCED_PARAMETER (ProcessInformationClass);

    st = ObReferenceObjectByHandle (ProcessHandle,
                                    PROCESS_QUERY_INFORMATION,
                                    PsProcessType,
                                    PreviousMode,
                                    (PVOID *)&Process,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    WorkingSetCatcher = Process->WorkingSetWatch;
    if (WorkingSetCatcher == NULL) {
        ObDereferenceObject (Process);
        return STATUS_UNSUCCESSFUL;
    }

    MmLockPageableSectionByHandle (ExPageLockHandle);
    ExAcquireSpinLock (&WorkingSetCatcher->SpinLock,&OldIrql);

    if (WorkingSetCatcher->CurrentIndex) {

        //
        // Null Terminate the first empty entry in the buffer
        //

        WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingPc = NULL;

        //Store a special Va value if the buffer was full and
        //page faults could have been lost

        if (WorkingSetCatcher->CurrentIndex != WorkingSetCatcher->MaxIndex) {
            WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingVa = NULL;
        } else {
            WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingVa = (PVOID) 1;
        }

        SpaceNeeded = (WorkingSetCatcher->CurrentIndex+1) * sizeof(PROCESS_WS_WATCH_INFORMATION);
    } else {
        ExReleaseSpinLock (&WorkingSetCatcher->SpinLock, OldIrql);
        MmUnlockPageableImageSection (ExPageLockHandle);
        ObDereferenceObject (Process);
        return STATUS_NO_MORE_ENTRIES;
    }

    if (ProcessInformationLength < SpaceNeeded) {
        ExReleaseSpinLock (&WorkingSetCatcher->SpinLock, OldIrql);
        MmUnlockPageableImageSection (ExPageLockHandle);
        ObDereferenceObject (Process);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Mark the Working Set buffer as full and then drop the lock
    // and copy the bytes
    //

    WorkingSetCatcher->CurrentIndex = MAX_WS_CATCH_INDEX;

    ExReleaseSpinLock (&WorkingSetCatcher->SpinLock,OldIrql);

    try {
        RtlCopyMemory (ProcessInformation, &WorkingSetCatcher->WatchInfo[0], SpaceNeeded);
        if (ARGUMENT_PRESENT (ReturnLength) ) {
            *ReturnLength = SpaceNeeded;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        st = GetExceptionCode ();
    }

    ExAcquireSpinLock (&WorkingSetCatcher->SpinLock, &OldIrql);
    WorkingSetCatcher->CurrentIndex = 0;
    ExReleaseSpinLock (&WorkingSetCatcher->SpinLock, OldIrql);

    MmUnlockPageableImageSection (ExPageLockHandle);
    ObDereferenceObject (Process);

    return st;
}

NTSTATUS
PspQueryQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    QUOTA_LIMITS_EX QuotaLimits={0};
    PEPROCESS Process;
    NTSTATUS Status;
    PEPROCESS_QUOTA_BLOCK QuotaBlock;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    ULONG HardEnforcement;
    KAPC_STATE ApcState;

    UNREFERENCED_PARAMETER (ProcessInformationClass);

    if (ProcessInformationLength != sizeof (QUOTA_LIMITS) &&
        ProcessInformationLength != sizeof (QUOTA_LIMITS_EX)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    QuotaBlock = Process->QuotaBlock;

    if (QuotaBlock != &PspDefaultQuotaBlock) {
        QuotaLimits.PagedPoolLimit = QuotaBlock->QuotaEntry[PsPagedPool].Limit;
        QuotaLimits.NonPagedPoolLimit = QuotaBlock->QuotaEntry[PsNonPagedPool].Limit;
        QuotaLimits.PagefileLimit = QuotaBlock->QuotaEntry[PsPageFile].Limit;
    } else {
        QuotaLimits.PagedPoolLimit = (SIZE_T)-1;
        QuotaLimits.NonPagedPoolLimit = (SIZE_T)-1;
        QuotaLimits.PagefileLimit = (SIZE_T)-1;
    }

    QuotaLimits.TimeLimit.LowPart = 0xffffffff;
    QuotaLimits.TimeLimit.HighPart = 0xffffffff;

    KeStackAttachProcess (&Process->Pcb, &ApcState);

    Status = MmQueryWorkingSetInformation (&PeakWorkingSetSize,
                                           &WorkingSetSize,
                                           &QuotaLimits.MinimumWorkingSetSize,
                                           &QuotaLimits.MaximumWorkingSetSize,
                                           &HardEnforcement);
    KeUnstackDetachProcess (&ApcState);

    if (HardEnforcement & MM_WORKING_SET_MIN_HARD_ENABLE) {
        QuotaLimits.Flags = QUOTA_LIMITS_HARDWS_MIN_ENABLE;
    } else {
        QuotaLimits.Flags = QUOTA_LIMITS_HARDWS_MIN_DISABLE;
    }

    if (HardEnforcement & MM_WORKING_SET_MAX_HARD_ENABLE) {
        QuotaLimits.Flags |= QUOTA_LIMITS_HARDWS_MAX_ENABLE;
    } else {
        QuotaLimits.Flags |= QUOTA_LIMITS_HARDWS_MAX_DISABLE;
    }

    ObDereferenceObject (Process);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    //
    // Either of these may cause an access violation. The
    // exception handler will return access violation as
    // status code.
    //

    try {
        ASSERT (ProcessInformationLength <= sizeof (QuotaLimits));

        RtlCopyMemory (ProcessInformation, &QuotaLimits, ProcessInformationLength);

        if (ARGUMENT_PRESENT (ReturnLength)) {
            *ReturnLength = ProcessInformationLength;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode ();
    }

    return Status;
}

NTSTATUS
PspQueryPooledQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    PEPROCESS Process;
    NTSTATUS st;
    PEPROCESS_QUOTA_BLOCK QuotaBlock;
    POOLED_USAGE_AND_LIMITS UsageAndLimits;

    UNREFERENCED_PARAMETER (ProcessInformationClass);

    if (ProcessInformationLength != (ULONG) sizeof (POOLED_USAGE_AND_LIMITS)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    st = ObReferenceObjectByHandle (ProcessHandle,
                                    PROCESS_QUERY_INFORMATION,
                                    PsProcessType,
                                    PreviousMode,
                                    &Process,
                                    NULL);
    if (!NT_SUCCESS (st)) {
        return st;
    }


    QuotaBlock = Process->QuotaBlock;

    UsageAndLimits.PagedPoolLimit        = QuotaBlock->QuotaEntry[PsPagedPool].Limit;
    UsageAndLimits.NonPagedPoolLimit     = QuotaBlock->QuotaEntry[PsNonPagedPool].Limit;
    UsageAndLimits.PagefileLimit         = QuotaBlock->QuotaEntry[PsPageFile].Limit;


    UsageAndLimits.PagedPoolUsage        = QuotaBlock->QuotaEntry[PsPagedPool].Usage;
    UsageAndLimits.NonPagedPoolUsage     = QuotaBlock->QuotaEntry[PsNonPagedPool].Usage;
    UsageAndLimits.PagefileUsage         = QuotaBlock->QuotaEntry[PsPageFile].Usage;

    UsageAndLimits.PeakPagedPoolUsage    = QuotaBlock->QuotaEntry[PsPagedPool].Peak;
    UsageAndLimits.PeakNonPagedPoolUsage = QuotaBlock->QuotaEntry[PsNonPagedPool].Peak;
    UsageAndLimits.PeakPagefileUsage     = QuotaBlock->QuotaEntry[PsPageFile].Peak;

    //
    // Since the quota charge and return are lock free we may see Peak and Limit out of step.
    // Usage <= Limit and Usage <= Peak
    // Since Limit is adjusted up and down it does not hold that Peak <= Limit.
    //
#define PSMAX(a,b) (((a) > (b))?(a):(b))

    UsageAndLimits.PagedPoolLimit        = PSMAX (UsageAndLimits.PagedPoolLimit,    UsageAndLimits.PagedPoolUsage);
    UsageAndLimits.NonPagedPoolLimit     = PSMAX (UsageAndLimits.NonPagedPoolLimit, UsageAndLimits.NonPagedPoolUsage);
    UsageAndLimits.PagefileLimit         = PSMAX (UsageAndLimits.PagefileLimit,     UsageAndLimits.PagefileUsage);

    UsageAndLimits.PeakPagedPoolUsage    = PSMAX (UsageAndLimits.PeakPagedPoolUsage,    UsageAndLimits.PagedPoolUsage);
    UsageAndLimits.PeakNonPagedPoolUsage = PSMAX (UsageAndLimits.PeakNonPagedPoolUsage, UsageAndLimits.NonPagedPoolUsage);
    UsageAndLimits.PeakPagefileUsage     = PSMAX (UsageAndLimits.PeakPagefileUsage,     UsageAndLimits.PagefileUsage);

    ObDereferenceObject(Process);

    //
    // Either of these may cause an access violation. The
    // exception handler will return access violation as
    // status code. No further cleanup needs to be done.
    //

    try {
        *(PPOOLED_USAGE_AND_LIMITS) ProcessInformation = UsageAndLimits;

        if (ARGUMENT_PRESENT(ReturnLength) ) {
            *ReturnLength = sizeof(POOLED_USAGE_AND_LIMITS);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PspSetPrimaryToken(
    IN HANDLE ProcessHandle OPTIONAL,
    IN PEPROCESS ProcessPointer OPTIONAL,
    IN HANDLE TokenHandle OPTIONAL,
    IN PACCESS_TOKEN TokenPointer OPTIONAL,
    IN BOOLEAN PrivilegeChecked
    )
/*++

    Sets the primary token for a process.
    The token and process supplied can be either by
    handle or by pointer.

--*/
{
    NTSTATUS Status;
    BOOLEAN HasPrivilege;
    BOOLEAN IsChildToken;
    BOOLEAN IsSiblingToken;
    PEPROCESS Process;
    KPROCESSOR_MODE PreviousMode;
    ACCESS_MASK GrantedAccess;
    PACCESS_TOKEN Token;

    //
    // Check to see if the supplied token is a child of the caller's
    // token. If so, we don't need to do the privilege check.
    //

    PreviousMode = KeGetPreviousMode ();

    if (TokenPointer == NULL) {
        //
        // Reference the specified token, and make sure it can be assigned
        // as a primary token.
        //

        Status = ObReferenceObjectByHandle (TokenHandle,
                                            TOKEN_ASSIGN_PRIMARY,
                                            SeTokenObjectType,
                                            PreviousMode,
                                            &Token,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    } else {
        Token = TokenPointer;
    }

    //
    // If the privilege check has already been done (when the token was
    // assign to a job for example). We don't want to do it here.
    //
    if (!PrivilegeChecked) {
        Status = SeIsChildTokenByPointer (Token,
                                          &IsChildToken);

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref_token;
        }

        if (!IsChildToken) {

            Status = SeIsSiblingTokenByPointer (Token,
                                                &IsSiblingToken);

            if (!NT_SUCCESS (Status)) {
                goto exit_and_deref_token;
            }

            if (!IsSiblingToken) {

                //
                // SeCheckPrivilegedObject will perform auditing as appropriate
                //

                HasPrivilege = SeCheckPrivilegedObject (SeAssignPrimaryTokenPrivilege,
                                                        ProcessHandle,
                                                        PROCESS_SET_INFORMATION,
                                                        PreviousMode);

                if (!HasPrivilege) {

                    Status = STATUS_PRIVILEGE_NOT_HELD;

                    goto exit_and_deref_token;
                }
            }

        }

    }

    if (ProcessPointer == NULL) {
        Status = ObReferenceObjectByHandle (ProcessHandle,
                                            PROCESS_SET_INFORMATION,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);

        if (!NT_SUCCESS (Status)) {

            goto exit_and_deref_token;
        }
    } else {
        Process = ProcessPointer;
    }


    //
    // Check for proper access to the token, and assign the primary
    // token for the process.
    //

    Status = PspAssignPrimaryToken (Process, NULL, Token);

    //
    // Recompute the process's access to itself for use
    // with the CurrentProcess() pseudo handle.
    //

    if (NT_SUCCESS (Status)) {

        NTSTATUS accesst;
        BOOLEAN AccessCheck;
        BOOLEAN MemoryAllocated;
        PSECURITY_DESCRIPTOR SecurityDescriptor;
        SECURITY_SUBJECT_CONTEXT SubjectContext;

        Status = ObGetObjectSecurity (Process,
                                      &SecurityDescriptor,
                                      &MemoryAllocated);

        if (NT_SUCCESS (Status)) {
            SubjectContext.ProcessAuditId = Process;
            SubjectContext.PrimaryToken = PsReferencePrimaryToken (Process);
            SubjectContext.ClientToken = NULL;
            AccessCheck = SeAccessCheck (SecurityDescriptor,
                                         &SubjectContext,
                                         FALSE,
                                         MAXIMUM_ALLOWED,
                                         0,
                                         NULL,
                                         &PsProcessType->TypeInfo.GenericMapping,
                                         PreviousMode,
                                         &GrantedAccess,
                                         &accesst);

            PsDereferencePrimaryTokenEx(Process, SubjectContext.PrimaryToken);
            ObReleaseObjectSecurity (SecurityDescriptor,
                                     MemoryAllocated);

            if (!AccessCheck) {
                GrantedAccess = 0;
            }

            //
            // To keep consistency with process creation, grant these
            // bits otherwise CreateProcessAsUser messes up really badly for
            // restricted tokens and we end up with a process that has no
            // access to itself when new token is set on the suspended
            // process.
            //
            GrantedAccess |= (PROCESS_VM_OPERATION | PROCESS_VM_READ |
                              PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION |
                              PROCESS_TERMINATE | PROCESS_CREATE_THREAD |
                              PROCESS_DUP_HANDLE | PROCESS_CREATE_PROCESS |
                              PROCESS_SET_INFORMATION | STANDARD_RIGHTS_ALL |
                              PROCESS_SET_QUOTA);

            Process->GrantedAccess = GrantedAccess;
        }
        //
        // Since the process token is being set,
        // Set the device map for process to NULL.
        // During the next reference to the process' device map,
        // the object manager will set the device map for the process
        //
        if (ObIsLUIDDeviceMapsEnabled() != 0) {
            ObDereferenceDeviceMap( Process );
        }
    }

    if (ProcessPointer == NULL) {
        ObDereferenceObject (Process);
    }

exit_and_deref_token:

    if (TokenPointer == NULL) {
        ObDereferenceObject (Token);
    }

    return Status;
}


NTSTATUS
NtQueryInformationProcess(
    __in HANDLE ProcessHandle,
    __in PROCESSINFOCLASS ProcessInformationClass,
    __out_bcount(ProcessInformationLength) PVOID ProcessInformation,
    __in ULONG ProcessInformationLength,
    __out_opt PULONG ReturnLength
    )
{
    PEPROCESS Process;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    PROCESS_BASIC_INFORMATION BasicInfo;
    VM_COUNTERS_EX VmCounters;
    IO_COUNTERS IoCounters;
    KERNEL_USER_TIMES SysUserTime;
    HANDLE DebugPort;
    ULONG ExecuteOptions;
    ULONG HandleCount;
    ULONG DefaultHardErrorMode;
    ULONG DisableBoost;
    ULONG BreakOnTerminationEnabled;
    PPROCESS_DEVICEMAP_INFORMATION DeviceMapInfo;
    PROCESS_SESSION_INFORMATION SessionInfo;
    PROCESS_PRIORITY_CLASS PriorityClass;
    ULONG_PTR Wow64Info;
    ULONG Flags;
    PUNICODE_STRING pTempNameInfo;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    ULONG HardEnforcement;
    KAPC_STATE ApcState;
    ULONG TotalKernel;
    ULONG TotalUser;
    KPROCESS_VALUES Values;

    PAGED_CODE();

    //
    // Get previous processor mode and probe output argument if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            //
            // Since these functions don't change any state thats not reversible
            // in the error paths we only probe the output buffer for write access.
            // This improves performance by not touching the buffer multiple times
            // And only writing the portions of the buffer that change.
            //
            ProbeForRead (ProcessInformation,
                          ProcessInformationLength,
                          sizeof (ULONG));

            if (ARGUMENT_PRESENT (ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    switch ( ProcessInformationClass ) {

    case ProcessImageFileName:
        {
            ULONG LengthNeeded = 0;

            st = ObReferenceObjectByHandle (ProcessHandle,
                                            PROCESS_QUERY_INFORMATION,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);

            if (!NT_SUCCESS (st)) {
                return st;
            }

            //
            // SeLocateProcessImageName will allocate space for a UNICODE_STRING and point pTempNameInfo
            // at that string.  This memory will be freed later in the routine.
            //

            st = SeLocateProcessImageName (Process, &pTempNameInfo);

            if (!NT_SUCCESS(st)) {
                ObDereferenceObject(Process);
                return st;
            }

            LengthNeeded = sizeof(UNICODE_STRING) + pTempNameInfo->MaximumLength;

            //
            // Either of these may cause an access violation. The
            // exception handler will return access violation as
            // status code. No further cleanup needs to be done.
            //

            try {

                if (ARGUMENT_PRESENT(ReturnLength) ) {
                    *ReturnLength = LengthNeeded;
                }

                if (ProcessInformationLength >= LengthNeeded) {
                    RtlCopyMemory(
                        ProcessInformation,
                        pTempNameInfo,
                        sizeof(UNICODE_STRING) + pTempNameInfo->MaximumLength
                        );
                    ((PUNICODE_STRING) ProcessInformation)->Buffer = (PWSTR)((PUCHAR) ProcessInformation + sizeof(UNICODE_STRING));

                } else {
                    st = STATUS_INFO_LENGTH_MISMATCH;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                st = GetExceptionCode ();
            }

            ObDereferenceObject(Process);
            ExFreePool( pTempNameInfo );

            return st;

        }

    case ProcessWorkingSetWatch:

        return PspQueryWorkingSetWatch (ProcessHandle,
                                        ProcessInformationClass,
                                        ProcessInformation,
                                        ProcessInformationLength,
                                        ReturnLength,
                                        PreviousMode);

    case ProcessBasicInformation:

        if (ProcessInformationLength != (ULONG) sizeof(PROCESS_BASIC_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        BasicInfo.ExitStatus = Process->ExitStatus;
        BasicInfo.PebBaseAddress = Process->Peb;
        BasicInfo.AffinityMask = Process->Pcb.Affinity;
        BasicInfo.BasePriority = Process->Pcb.BasePriority;
        BasicInfo.UniqueProcessId = (ULONG_PTR)Process->UniqueProcessId;
        BasicInfo.InheritedFromUniqueProcessId = (ULONG_PTR)Process->InheritedFromUniqueProcessId;

        ObDereferenceObject(Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PPROCESS_BASIC_INFORMATION) ProcessInformation = BasicInfo;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(PROCESS_BASIC_INFORMATION);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessDefaultHardErrorMode:

        if (ProcessInformationLength != sizeof(ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        DefaultHardErrorMode = Process->DefaultHardErrorProcessing;

        ObDereferenceObject(Process);

        try {
            *(PULONG) ProcessInformation = DefaultHardErrorMode;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessQuotaLimits:

        return PspQueryQuotaLimits (ProcessHandle,
                                    ProcessInformationClass,
                                    ProcessInformation,
                                    ProcessInformationLength,
                                    ReturnLength,
                                    PreviousMode);

    case ProcessPooledUsageAndLimits:

        return PspQueryPooledQuotaLimits (ProcessHandle,
                                          ProcessInformationClass,
                                          ProcessInformation,
                                          ProcessInformationLength,
                                          ReturnLength,
                                          PreviousMode);

    case ProcessIoCounters:

        if (ProcessInformationLength != (ULONG) sizeof (IO_COUNTERS)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Query process I/O statistics.
        //

        KeQueryValuesProcess (&Process->Pcb, &Values);
        IoCounters.ReadOperationCount = Values.ReadOperationCount;
        IoCounters.WriteOperationCount = Values.WriteOperationCount;
        IoCounters.OtherOperationCount = Values.OtherOperationCount;
        IoCounters.ReadTransferCount = Values.ReadTransferCount;
        IoCounters.WriteTransferCount = Values.WriteTransferCount;
        IoCounters.OtherTransferCount = Values.OtherTransferCount;
        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PIO_COUNTERS) ProcessInformation = IoCounters;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(IO_COUNTERS);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessVmCounters:

        if (ProcessInformationLength != (ULONG) sizeof (VM_COUNTERS)
            && ProcessInformationLength != (ULONG) sizeof (VM_COUNTERS_EX)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }


        //
        // Note: At some point, we might have to grab the statistics
        // lock to reliably read this stuff
        //

        VmCounters.PeakVirtualSize = Process->PeakVirtualSize;
        VmCounters.VirtualSize = Process->VirtualSize;
        VmCounters.PageFaultCount = Process->Vm.PageFaultCount;

        KeStackAttachProcess (&Process->Pcb, &ApcState);

        st = MmQueryWorkingSetInformation (&VmCounters.PeakWorkingSetSize,
                                           &VmCounters.WorkingSetSize,
                                           &MinimumWorkingSetSize,
                                           &MaximumWorkingSetSize,
                                           &HardEnforcement);


        KeUnstackDetachProcess (&ApcState);

        VmCounters.QuotaPeakPagedPoolUsage = Process->QuotaPeak[PsPagedPool];
        VmCounters.QuotaPagedPoolUsage = Process->QuotaUsage[PsPagedPool];
        VmCounters.QuotaPeakNonPagedPoolUsage = Process->QuotaPeak[PsNonPagedPool];
        VmCounters.QuotaNonPagedPoolUsage = Process->QuotaUsage[PsNonPagedPool];
        VmCounters.PagefileUsage = ((SIZE_T) Process->QuotaUsage[PsPageFile]) << PAGE_SHIFT;
        VmCounters.PeakPagefileUsage = ((SIZE_T) Process->QuotaPeak[PsPageFile]) << PAGE_SHIFT;
        VmCounters.PrivateUsage = ((SIZE_T) Process->CommitCharge) << PAGE_SHIFT;

        ObDereferenceObject (Process);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            RtlCopyMemory(ProcessInformation,
                          &VmCounters,
                          ProcessInformationLength);
            
            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = ProcessInformationLength;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessTimes:

        if ( ProcessInformationLength != (ULONG) sizeof(KERNEL_USER_TIMES) ) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Query the process kernel and user runtime.
        //

        TotalKernel = KeQueryRuntimeProcess (&Process->Pcb, &TotalUser);
        SysUserTime.KernelTime.QuadPart = UInt32x32To64(TotalKernel,
                                                        KeMaximumIncrement);

        SysUserTime.UserTime.QuadPart = UInt32x32To64(TotalUser,
                                                      KeMaximumIncrement);

        SysUserTime.CreateTime = Process->CreateTime;
        SysUserTime.ExitTime = Process->ExitTime;
        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PKERNEL_USER_TIMES) ProcessInformation = SysUserTime;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (KERNEL_USER_TIMES);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessDebugPort :

        //
        if (ProcessInformationLength != (ULONG) sizeof (HANDLE)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (Process->DebugPort == NULL) {

            DebugPort = NULL;

        } else {

            DebugPort = (HANDLE)-1;

        }

        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PHANDLE) ProcessInformation = DebugPort;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(HANDLE);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessDebugObjectHandle :
        //
        if (ProcessInformationLength != sizeof (HANDLE)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = DbgkOpenProcessDebugPort (Process,
                                       PreviousMode,
                                       &DebugPort);

        if (!NT_SUCCESS (st)) {
            DebugPort = NULL;
        }

        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PHANDLE) ProcessInformation = DebugPort;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (HANDLE);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            if (DebugPort != NULL) {
                ObCloseHandle (DebugPort, PreviousMode);
            }
            return GetExceptionCode ();
        }

        return st;

    case ProcessDebugFlags :

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        try {
            *(PULONG) ProcessInformation = (Process->Flags&PS_PROCESS_FLAGS_NO_DEBUG_INHERIT)?0:PROCESS_DEBUG_INHERIT;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(HANDLE);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        ObDereferenceObject (Process);

        return st;


    case ProcessHandleCount :

        if (ProcessInformationLength != (ULONG) sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        HandleCount = ObGetProcessHandleCount (Process);

        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PULONG) ProcessInformation = HandleCount;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessLdtInformation :

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspQueryLdtInformation (Process,
                                     ProcessInformation,
                                     ProcessInformationLength,
                                     ReturnLength);

        ObDereferenceObject(Process);
        return st;


    case ProcessWx86Information :

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Flags = Process->Flags & PS_PROCESS_FLAGS_VDM_ALLOWED ? 1 : 0;

        ObDereferenceObject (Process);

        //
        // The returned flags is used as a BOOLEAN to indicate whether the
        // ProcessHandle specifies a NtVdm Process.  In another words, the caller
        // can simply do a
        //      if (ReturnedValue == TRUE) {
        //          a ntvdm process;
        //      } else {
        //          NOT a ntvdm process;
        //      }
        //

        try {
            *(PULONG)ProcessInformation = Flags;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

    case ProcessPriorityBoost:
        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        DisableBoost = Process->Pcb.DisableBoost ? 1 : 0;

        ObDereferenceObject (Process);

        try {
            *(PULONG)ProcessInformation = DisableBoost;

            if (ARGUMENT_PRESENT( ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

    case ProcessDeviceMap:
        DeviceMapInfo = (PPROCESS_DEVICEMAP_INFORMATION)ProcessInformation;
        if (ProcessInformationLength < sizeof (DeviceMapInfo->Query)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        if (ProcessInformationLength == sizeof (PROCESS_DEVICEMAP_INFORMATION_EX)) {
            try {
                Flags = ((PPROCESS_DEVICEMAP_INFORMATION_EX)DeviceMapInfo)->Flags;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
            if ( (Flags & ~(PROCESS_LUID_DOSDEVICES_ONLY)) ||
                 (ObIsLUIDDeviceMapsEnabled () == 0) ) {
                return STATUS_INVALID_PARAMETER;
            }
        } else if (ProcessInformationLength == sizeof (DeviceMapInfo->Query)) {
            Flags = 0;
        } else {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = ObQueryDeviceMapInformation (Process, DeviceMapInfo, Flags);
        ObDereferenceObject(Process);

        if (NT_SUCCESS (st) && ARGUMENT_PRESENT (ReturnLength)) {
            try {
                *ReturnLength = ProcessInformationLength;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
        }
        return st;

    case ProcessSessionInformation :

        if (ProcessInformationLength != (ULONG) sizeof (PROCESS_SESSION_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        SessionInfo.SessionId = MmGetSessionId (Process);

        ObDereferenceObject (Process);

        try {
            *(PPROCESS_SESSION_INFORMATION) ProcessInformation = SessionInfo;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof(PROCESS_SESSION_INFORMATION);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;



    case ProcessPriorityClass:

        if (ProcessInformationLength != sizeof (PROCESS_PRIORITY_CLASS)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        PriorityClass.Foreground = FALSE;
        PriorityClass.PriorityClass = Process->PriorityClass;

        ObDereferenceObject (Process);

        try {
            *(PPROCESS_PRIORITY_CLASS) ProcessInformation = PriorityClass;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof(PROCESS_PRIORITY_CLASS);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;


    case ProcessWow64Information:

        if (ProcessInformationLength != sizeof (ULONG_PTR)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        Wow64Info = 0;

        //
        // Acquire process rundown protection as we are about to look at process structures torn down at
        // process exit.
        //
        if (ExAcquireRundownProtection (&Process->RundownProtect)) {
            PWOW64_PROCESS Wow64Process;

            if ((Wow64Process = PS_GET_WOW64_PROCESS (Process)) != NULL) {
                Wow64Info = (ULONG_PTR)(Wow64Process->Wow64);
            }

            ExReleaseRundownProtection (&Process->RundownProtect);
        }


        ObDereferenceObject (Process);

        try {
            *(PULONG_PTR)ProcessInformation = Wow64Info;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG_PTR);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;


    case ProcessLUIDDeviceMapsEnabled:

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            *(PULONG)ProcessInformation = ObIsLUIDDeviceMapsEnabled ();

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessBreakOnTermination:

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (Process->Flags & PS_PROCESS_FLAGS_BREAK_ON_TERMINATION) {

            BreakOnTerminationEnabled = 1;

        } else {

            BreakOnTerminationEnabled = 0;

        }

        ObDereferenceObject (Process);

        try {

            *(PULONG)ProcessInformation = BreakOnTerminationEnabled;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessHandleTracing: {
        PPROCESS_HANDLE_TRACING_QUERY Pht;
        PHANDLE_TABLE HandleTable;
        PHANDLE_TRACE_DEBUG_INFO DebugInfo;
        HANDLE_TRACE_DB_ENTRY Trace;
        PPROCESS_HANDLE_TRACING_ENTRY NextTrace;
        ULONG StacksLeft;
        ULONG i, j;

        if (ProcessInformationLength < FIELD_OFFSET (PROCESS_HANDLE_TRACING_QUERY,
                                                     HandleTrace)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        Pht = (PPROCESS_HANDLE_TRACING_QUERY) ProcessInformation;
        StacksLeft = (ProcessInformationLength - FIELD_OFFSET (PROCESS_HANDLE_TRACING_QUERY,
                                                              HandleTrace)) /
                     sizeof (Pht->HandleTrace[0]);
        NextTrace = &Pht->HandleTrace[0];

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }
        HandleTable = ObReferenceProcessHandleTable (Process);

        if (HandleTable != NULL) {
            DebugInfo = ExReferenceHandleDebugInfo (HandleTable);
            if (DebugInfo != NULL) {
                try {
                    Pht->TotalTraces = 0;
                    j = DebugInfo->CurrentStackIndex % DebugInfo->TableSize;
                    for (i = 0; i < DebugInfo->TableSize; i++) {
                        RtlCopyMemory (&Trace, &DebugInfo->TraceDb[j], sizeof (Trace));
                        if ((Pht->Handle == Trace.Handle || Pht->Handle == 0) && Trace.Type != 0) {
                            Pht->TotalTraces++;
                            if (StacksLeft > 0) {
                                StacksLeft--;
                                NextTrace->Handle = Trace.Handle;
                                NextTrace->ClientId = Trace.ClientId;
                                NextTrace->Type = Trace.Type;
                                RtlCopyMemory (NextTrace->Stacks,
                                               Trace.StackTrace,
                                               min (sizeof (NextTrace->Stacks),
                                                    sizeof (Trace.StackTrace)));
                                NextTrace++;

                            } else {
                                st = STATUS_INFO_LENGTH_MISMATCH;
                            }
                        }
                        if (j == 0) {
                            j = DebugInfo->TableSize - 1;
                        } else {
                            j--;
                        }
                    }
                    if (ARGUMENT_PRESENT (ReturnLength)) {
                        *ReturnLength = (ULONG) ((PUCHAR) NextTrace - (PUCHAR) Pht);
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    st = GetExceptionCode ();
                }

                ExDereferenceHandleDebugInfo (HandleTable, DebugInfo);

            } else {
                st = STATUS_INVALID_PARAMETER;
            }
            ObDereferenceProcessHandleTable (Process);
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject(Process);
        return st;
    }

    case ProcessExecuteFlags:

        //
        // This code queries the execution flags for the current process.
        //

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        if (ProcessHandle != NtCurrentProcess ()) {
            return STATUS_INVALID_PARAMETER;
        }

        st = MmGetExecuteOptions (&ExecuteOptions);
        if (NT_SUCCESS(st)) {
            try {
                *(PULONG)ProcessInformation = ExecuteOptions;
                if (ARGUMENT_PRESENT (ReturnLength)) {
                    *ReturnLength = sizeof(ULONG);
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                st = GetExceptionCode ();
            }
        }

        return st;

    case ProcessCookie: {
        ULONG Cookie;
        LARGE_INTEGER Time;
        PKPRCB Prcb;
  

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        if (ProcessHandle != NtCurrentProcess ()) {
            return STATUS_INVALID_PARAMETER;
        }

        Process = PsGetCurrentProcess ();

        while (1) {
            Cookie = Process->Cookie;
            if (Cookie != 0) {

                try {
                    *(PULONG)ProcessInformation = Process->Cookie;

                    if (ARGUMENT_PRESENT (ReturnLength)) {
                        *ReturnLength = sizeof (ULONG);
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    return GetExceptionCode ();
                }

                return STATUS_SUCCESS;

            } else {
                KeQuerySystemTime (&Time);
                Prcb = KeGetCurrentPrcb ();
                Cookie = Time.LowPart ^ Time.HighPart ^ Prcb->InterruptTime ^ Prcb->KeSystemCalls;
                InterlockedCompareExchange ((PLONG)&Process->Cookie, Cookie, 0);
            }
        }
    }

    case ProcessImageInformation:

        //
        // This code queries the section image information for the current
        // process.
        //

        if (ProcessInformationLength != sizeof (SECTION_IMAGE_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        if (ProcessHandle != NtCurrentProcess ()) {
            return STATUS_INVALID_PARAMETER;
        }

        try {
            MmGetImageInformation((PSECTION_IMAGE_INFORMATION)ProcessInformation);
            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (SECTION_IMAGE_INFORMATION);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    default:
        return STATUS_INVALID_INFO_CLASS;
    }
}

NTSTATUS
NtQueryPortInformationProcess(
    VOID
    )

/*++

Routine Description:

    This function tests whether a debug port or an exception port is attached
    to the current process and returns a corresponding value. This function is
    used to bypass raising an exception through the system when no associated
    ports are present.

    N.B. This system service is obsolete.

Arguments:

    None.

Return Value:

    TRUE is always returned.

--*/

{

    return TRUE;
}

NTSTATUS
PspSetQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    PEPROCESS Process;
    PETHREAD CurrentThread;
    QUOTA_LIMITS_EX RequestedLimits;
    PEPROCESS_QUOTA_BLOCK NewQuotaBlock;
    NTSTATUS st, ReturnStatus;
    BOOLEAN OkToIncrease, IgnoreError;
    PEJOB Job;
    KAPC_STATE ApcState;
    ULONG EnableHardLimits;
    BOOLEAN PurgeRequest, UnprivilegedOperation, PrivilegeUsed, FreeCtx, IncreasePerformed;
    PRIV_CHECK_CTX PrivCtx;


    UNREFERENCED_PARAMETER (ProcessInformationClass);

    try {

        if (ProcessInformationLength == sizeof (QUOTA_LIMITS)) {
            RtlCopyMemory (&RequestedLimits,
                           ProcessInformation,
                           sizeof (QUOTA_LIMITS));
            RequestedLimits.Reserved1 = 0;
            RequestedLimits.Reserved2 = 0;
            RequestedLimits.Reserved3 = 0;
            RequestedLimits.Reserved4 = 0;
            RequestedLimits.Reserved5 = 0;
            RequestedLimits.Flags = 0;
        } else if (ProcessInformationLength == sizeof (QUOTA_LIMITS_EX)) {
            RequestedLimits = *(PQUOTA_LIMITS_EX) ProcessInformation;
        } else {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    //
    // All unused flags must be zero
    //
    if (RequestedLimits.Flags & ~(QUOTA_LIMITS_HARDWS_MAX_ENABLE|QUOTA_LIMITS_HARDWS_MAX_DISABLE|
                                  QUOTA_LIMITS_HARDWS_MIN_ENABLE|QUOTA_LIMITS_HARDWS_MIN_DISABLE)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disallow both enable and disable bits set at the same time.
    //
    if (PS_TEST_ALL_BITS_SET (RequestedLimits.Flags, QUOTA_LIMITS_HARDWS_MIN_ENABLE|QUOTA_LIMITS_HARDWS_MIN_DISABLE) ||
        PS_TEST_ALL_BITS_SET (RequestedLimits.Flags, QUOTA_LIMITS_HARDWS_MAX_ENABLE|QUOTA_LIMITS_HARDWS_MAX_DISABLE)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // See if we are changing the hard limits or not
    //

    EnableHardLimits = 0;

    if (RequestedLimits.Flags&QUOTA_LIMITS_HARDWS_MIN_ENABLE) {
        EnableHardLimits = MM_WORKING_SET_MIN_HARD_ENABLE;
    } else if (RequestedLimits.Flags&QUOTA_LIMITS_HARDWS_MIN_DISABLE) {
        EnableHardLimits = MM_WORKING_SET_MIN_HARD_DISABLE;
    }

    if (RequestedLimits.Flags&QUOTA_LIMITS_HARDWS_MAX_ENABLE) {
        EnableHardLimits |= MM_WORKING_SET_MAX_HARD_ENABLE;
    } else if (RequestedLimits.Flags&QUOTA_LIMITS_HARDWS_MAX_DISABLE) {
        EnableHardLimits |= MM_WORKING_SET_MAX_HARD_DISABLE;
    }


    //
    // All reserved fields must be zero
    //
    if (RequestedLimits.Reserved1 != 0 || RequestedLimits.Reserved2 != 0 ||
        RequestedLimits.Reserved3 != 0 || RequestedLimits.Reserved4 != 0 ||
        RequestedLimits.Reserved5 != 0) {
        return STATUS_INVALID_PARAMETER;
    }


    st = ObReferenceObjectByHandle (ProcessHandle,
                                    PROCESS_SET_QUOTA,
                                    PsProcessType,
                                    PreviousMode,
                                    &Process,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    CurrentThread = PsGetCurrentThread ();

    //
    // Now we are ready to set the quota limits for the process
    //
    // If the process already has a quota block, then all we allow
    // is working set changes.
    //
    // If the process has no quota block, all that can be done is a
    // quota set operation.
    //
    // If a quota field is zero, we pick the value.
    //
    // Setting quotas requires the SeIncreaseQuotaPrivilege (except for
    // working set size since this is only advisory).
    //


    ReturnStatus = STATUS_SUCCESS;

    if ((Process->QuotaBlock == &PspDefaultQuotaBlock) &&
         (RequestedLimits.MinimumWorkingSetSize == 0 || RequestedLimits.MaximumWorkingSetSize == 0)) {

        //
        // You must have a privilege to assign quotas
        //

        if (!SeSinglePrivilegeCheck (SeIncreaseQuotaPrivilege, PreviousMode)) {
            ObDereferenceObject (Process);
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        NewQuotaBlock = ExAllocatePoolWithTag (NonPagedPool, sizeof(*NewQuotaBlock), 'bQsP');
        if (NewQuotaBlock == NULL) {
            ObDereferenceObject (Process);
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory (NewQuotaBlock, sizeof (*NewQuotaBlock));

        //
        // Initialize the quota block
        //
        NewQuotaBlock->ReferenceCount = 1;
        NewQuotaBlock->ProcessCount   = 1;

        NewQuotaBlock->QuotaEntry[PsNonPagedPool].Peak  = Process->QuotaPeak[PsNonPagedPool];
        NewQuotaBlock->QuotaEntry[PsPagedPool].Peak     = Process->QuotaPeak[PsPagedPool];
        NewQuotaBlock->QuotaEntry[PsPageFile].Peak      = Process->QuotaPeak[PsPageFile];

        //
        // Now compute limits
        //

        //
        // Get the defaults that the system would pick.
        //

        NewQuotaBlock->QuotaEntry[PsPagedPool].Limit    = PspDefaultPagedLimit;
        NewQuotaBlock->QuotaEntry[PsNonPagedPool].Limit = PspDefaultNonPagedLimit;
        NewQuotaBlock->QuotaEntry[PsPageFile].Limit     = PspDefaultPagefileLimit;

        // Everything is set. Now double check to quota block field
        // If we still have no quota block then assign and succeed.
        // Otherwise punt.
        //

        if (InterlockedCompareExchangePointer (&Process->QuotaBlock,
                                               NewQuotaBlock,
                                               &PspDefaultQuotaBlock) != &PspDefaultQuotaBlock) {
            ExFreePool (NewQuotaBlock);
        } else {
            PspInsertQuotaBlock (NewQuotaBlock);
        }


    } else {

        //
        // Only allow a working set size change
        //

        if (RequestedLimits.MinimumWorkingSetSize &&
            RequestedLimits.MaximumWorkingSetSize) {

            //
            // See if the caller just wants to purge the working set.
            // This is an unprivileged operation.
            //
            if (RequestedLimits.MinimumWorkingSetSize == (SIZE_T)-1 &&
                RequestedLimits.MaximumWorkingSetSize == (SIZE_T)-1) {
                PurgeRequest = TRUE;
                OkToIncrease = FALSE;
                FreeCtx = FALSE;
            } else {
                PurgeRequest = FALSE;

                OkToIncrease = (BOOLEAN) PspSinglePrivCheck (SeIncreaseBasePriorityPrivilege, PreviousMode, &PrivCtx);
                FreeCtx = TRUE;
            }

            PrivilegeUsed = FALSE;
            do {
                IgnoreError = FALSE;
                UnprivilegedOperation = FALSE;

                KeStackAttachProcess (&Process->Pcb, &ApcState);


                KeEnterGuardedRegionThread (&CurrentThread->Tcb);

                Job = Process->Job;
                if (Job != NULL) {
                    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                    if (Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
                        //
                        // Don't let a process in a job change if job limits are applied
                        // except purge requests which can always be done.
                        //

                        EnableHardLimits = MM_WORKING_SET_MAX_HARD_ENABLE;
                        OkToIncrease = TRUE;
                        UnprivilegedOperation = TRUE;
                        IgnoreError = TRUE; // we must always set enforcement value

                        if (!PurgeRequest) {
                            RequestedLimits.MinimumWorkingSetSize = Job->MinimumWorkingSetSize;
                            RequestedLimits.MaximumWorkingSetSize = Job->MaximumWorkingSetSize;
                        }
                    }

                    PspLockWorkingSetChangeExclusiveUnsafe ();

                    ExReleaseResourceLite (&Job->JobLock);
                }

                ReturnStatus = MmAdjustWorkingSetSizeEx (RequestedLimits.MinimumWorkingSetSize,
                                                         RequestedLimits.MaximumWorkingSetSize,
                                                         FALSE,
                                                         OkToIncrease,
                                                         EnableHardLimits,
                                                         &IncreasePerformed);

                if (!NT_SUCCESS (ReturnStatus) && IgnoreError) {
                    MmEnforceWorkingSetLimit (Process,
                                              EnableHardLimits);
                }

                if (Job != NULL) {
                    PspUnlockWorkingSetChangeExclusiveUnsafe ();
                }

                KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

                KeUnstackDetachProcess (&ApcState);

                if (IncreasePerformed && !UnprivilegedOperation) {
                    PrivilegeUsed = TRUE;
                }

                //
                // We loop here in case this process was added to a job
                // after we checked but before we set the limits
                //

            } while (Process->Job != Job);

            if (FreeCtx) {
                PspSinglePrivCheckAudit (PrivilegeUsed,
                                         &PrivCtx);
            }
        }
    }

    ObDereferenceObject(Process);

    return ReturnStatus;
}

NTSTATUS
NtSetInformationProcess(
    __in HANDLE ProcessHandle,
    __in PROCESSINFOCLASS ProcessInformationClass,
    __in_bcount(ProcessInformationLength) PVOID ProcessInformation,
    __in ULONG ProcessInformationLength
    )

/*++

Routine Description:

    This function sets the state of a process object.

Arguments:

    ProcessHandle - Supplies a handle to a process object.

    ProcessInformationClass - Supplies the class of information being
        set.

    ProcessInformation - Supplies a pointer to a record that contains the
        information to set.

    ProcessInformationLength - Supplies the length of the record that contains
        the information to set.

--*/

{

    PEPROCESS Process;
    PETHREAD Thread;
    PETHREAD CurrentThread;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    KPRIORITY BasePriority;
    ULONG BoostValue;
    ULONG DefaultHardErrorMode;
    ULONG ExecuteOptions;
    PVOID ExceptionPort;
    BOOLEAN EnableAlignmentFaultFixup;
    HANDLE ExceptionPortHandle;
    ULONG ProbeAlignment;
    HANDLE PrimaryTokenHandle;
    BOOLEAN HasPrivilege = FALSE;
    UCHAR MemoryPriority;
    PROCESS_PRIORITY_CLASS LocalPriorityClass;
    PROCESS_FOREGROUND_BACKGROUND LocalForeground;
    KAFFINITY Affinity, AffinityWithMasks;
    ULONG DisableBoost;
    BOOLEAN bDisableBoost;
    PPROCESS_DEVICEMAP_INFORMATION DeviceMapInfo;
    HANDLE DirectoryHandle;
    PROCESS_SESSION_INFORMATION SessionInfo;
    ULONG EnableBreakOnTermination;
    PEJOB Job;

    PAGED_CODE();

    //
    // Get previous processor mode and probe input argument if necessary.
    //

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {

        if (ProcessInformationClass == ProcessBasePriority) {
            ProbeAlignment = sizeof (KPRIORITY);
        } else if (ProcessInformationClass == ProcessEnableAlignmentFaultFixup) {
            ProbeAlignment = sizeof (BOOLEAN);
        } else if (ProcessInformationClass == ProcessForegroundInformation) {
            ProbeAlignment = sizeof (PROCESS_FOREGROUND_BACKGROUND);
        } else if (ProcessInformationClass == ProcessPriorityClass) {
            ProbeAlignment = sizeof (BOOLEAN);
        } else if (ProcessInformationClass == ProcessAffinityMask) {
            ProbeAlignment = sizeof (ULONG_PTR);
        } else {
            ProbeAlignment = sizeof (ULONG);
        }

        try {

            ProbeForRead (ProcessInformation,
                          ProcessInformationLength,
                          ProbeAlignment);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    //
    // Check argument validity.
    //

    switch (ProcessInformationClass) {

    case ProcessWorkingSetWatch: {
        PPAGEFAULT_HISTORY WorkingSetCatcher;

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PsChargeProcessNonPagedPoolQuota (Process, WS_CATCH_SIZE);
        if (NT_SUCCESS (st)) {

            WorkingSetCatcher = ExAllocatePoolWithTag (NonPagedPool, WS_CATCH_SIZE, 'sWsP');
            if (!WorkingSetCatcher) {
                st = STATUS_NO_MEMORY;
            } else {

                PsWatchEnabled = TRUE;
                WorkingSetCatcher->CurrentIndex = 0;
                WorkingSetCatcher->MaxIndex = MAX_WS_CATCH_INDEX;
                KeInitializeSpinLock (&WorkingSetCatcher->SpinLock);

                //
                // This only ever goes on the process and isn't removed till process object deletion.
                // We just need to protect against multiple callers here.
                //
                if (InterlockedCompareExchangePointer (&Process->WorkingSetWatch,
                                                       WorkingSetCatcher, NULL) == NULL) {
                    st = STATUS_SUCCESS;
                } else {
                    ExFreePool (WorkingSetCatcher);
                    st = STATUS_PORT_ALREADY_SET;
                }
            }
            if (!NT_SUCCESS (st)) {
                PsReturnProcessNonPagedPoolQuota (Process, WS_CATCH_SIZE);
            }
        }

        ObDereferenceObject (Process);

        return st;
    }

    case ProcessBasePriority: {


        //
        // THIS ITEM CODE IS OBSOLETE !
        //

        if (ProcessInformationLength != sizeof (KPRIORITY)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            BasePriority = *(KPRIORITY *)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        if (BasePriority & 0x80000000) {
            MemoryPriority = MEMORY_PRIORITY_FOREGROUND;
            BasePriority &= ~0x80000000;
        } else {
            MemoryPriority = MEMORY_PRIORITY_BACKGROUND;
        }

        if (BasePriority > HIGH_PRIORITY ||
            BasePriority <= LOW_PRIORITY) {

            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        if (BasePriority > Process->Pcb.BasePriority) {

            //
            // Increasing the base priority of a process is a
            // privileged operation.  Check for the privilege
            // here.
            //

            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                    ProcessHandle,
                                                    PROCESS_SET_INFORMATION,
                                                    PreviousMode);

            if (!HasPrivilege) {

                ObDereferenceObject (Process);
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        KeSetPriorityAndQuantumProcess (&Process->Pcb, BasePriority, 0);
        MmSetMemoryPriorityProcess (Process, MemoryPriority);
        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessPriorityClass: {
        if (ProcessInformationLength != sizeof (PROCESS_PRIORITY_CLASS)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            LocalPriorityClass = *(PPROCESS_PRIORITY_CLASS)ProcessInformation;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (LocalPriorityClass.PriorityClass > PROCESS_PRIORITY_CLASS_ABOVE_NORMAL) {
            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        if (LocalPriorityClass.PriorityClass != Process->PriorityClass &&
            LocalPriorityClass.PriorityClass == PROCESS_PRIORITY_CLASS_REALTIME) {

            //
            // Increasing the base priority of a process is a
            // privileged operation.  Check for the privilege
            // here.
            //

            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                    ProcessHandle,
                                                    PROCESS_SET_INFORMATION,
                                                    PreviousMode);

            if (!HasPrivilege) {

                ObDereferenceObject (Process);
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        //
        // If the process has a job object, override whatever the process
        // is calling with with the value from the job object
        //
        Job = Process->Job;
        if (Job != NULL) {
            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

            if (Job->LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS) {
                LocalPriorityClass.PriorityClass = Job->PriorityClass;
            }

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        }

        Process->PriorityClass = LocalPriorityClass.PriorityClass;

        PsSetProcessPriorityByClass (Process,
                                     LocalPriorityClass.Foreground ?
                                         PsProcessPriorityForeground : PsProcessPriorityBackground);

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessForegroundInformation: {

        if (ProcessInformationLength != sizeof (PROCESS_FOREGROUND_BACKGROUND)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            LocalForeground = *(PPROCESS_FOREGROUND_BACKGROUND)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        PsSetProcessPriorityByClass (Process,
                                     LocalForeground.Foreground ?
                                         PsProcessPriorityForeground : PsProcessPriorityBackground);

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessRaisePriority: {
        //
        // This code is used to boost the priority of all threads
        // within a process. It cannot be used to change a thread into
        // a realtime class, or to lower the priority of a thread. The
        // argument is a boost value that is added to the base priority
        // of the specified process.
        //


        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            BoostValue = *(PULONG)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Get the process create/delete lock and walk through the
        // thread list boosting each thread.
        //


        if (ExAcquireRundownProtection (&Process->RundownProtect)) {
            for (Thread = PsGetNextProcessThread (Process, NULL);
                 Thread != NULL;
                 Thread = PsGetNextProcessThread (Process, Thread)) {

                 KeBoostPriorityThread (&Thread->Tcb, (KPRIORITY)BoostValue);
            }
            ExReleaseRundownProtection (&Process->RundownProtect);
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject (Process);

        return st;
    }

    case ProcessDefaultHardErrorMode: {
        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            DefaultHardErrorMode = *(PULONG)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Process->DefaultHardErrorProcessing = DefaultHardErrorMode;
        if (DefaultHardErrorMode & PROCESS_HARDERROR_ALIGNMENT_BIT) {
            KeSetAutoAlignmentProcess (&Process->Pcb,TRUE);
        } else {
            KeSetAutoAlignmentProcess (&Process->Pcb,FALSE);
        }

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessQuotaLimits: {
        return PspSetQuotaLimits (ProcessHandle,
                                  ProcessInformationClass,
                                  ProcessInformation,
                                  ProcessInformationLength,
                                  PreviousMode);
    }

    case ProcessExceptionPort : {
        if (ProcessInformationLength != sizeof (HANDLE)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            ExceptionPortHandle = *(PHANDLE) ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }



        st = ObReferenceObjectByHandle (ExceptionPortHandle,
                                        0,
                                        LpcPortObjectType,
                                        PreviousMode,
                                        &ExceptionPort,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            ObDereferenceObject (ExceptionPort);
            return st;
        }

        //
        // We are only allowed to put the exception port on. It doesn't get removed till process delete.
        //
        if (InterlockedCompareExchangePointer (&Process->ExceptionPort, ExceptionPort, NULL) == NULL) {
            st = STATUS_SUCCESS;
        } else {
            ObDereferenceObject (ExceptionPort);
            st = STATUS_PORT_ALREADY_SET;
        }
        ObDereferenceObject (Process);

        return st;
    }

    case ProcessAccessToken : {

        if (ProcessInformationLength != sizeof (PROCESS_ACCESS_TOKEN)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            PrimaryTokenHandle  = ((PROCESS_ACCESS_TOKEN *)ProcessInformation)->Token;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }


        st = PspSetPrimaryToken (ProcessHandle,
                                 NULL,
                                 PrimaryTokenHandle,
                                 NULL,
                                 FALSE);

        return st;
    }


    case ProcessLdtInformation:

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION | PROCESS_VM_WRITE,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspSetLdtInformation (Process,
                                   ProcessInformation,
                                   ProcessInformationLength);

        ObDereferenceObject (Process);
        return st;

    case ProcessLdtSize:

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION | PROCESS_VM_WRITE,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspSetLdtSize (Process,
                            ProcessInformation,
                            ProcessInformationLength);

        ObDereferenceObject(Process);
        return st;

    case ProcessIoPortHandlers:

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspSetProcessIoHandlers (Process,
                                      ProcessInformation,
                                      ProcessInformationLength);

        ObDereferenceObject (Process);

        return st;

    case ProcessUserModeIOPL:

        //
        // Must make sure the caller is a trusted subsystem with the
        // appropriate privilege level before executing this call.
        // If the calls returns FALSE we must return an error code.
        //

        if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (NT_SUCCESS (st)) {

#if defined (_X86_)

            Ke386SetIOPL ();

#endif

            ObDereferenceObject (Process);
        }

        return st;

        //
        // Enable/disable auto-alignment fixup for a process and all its threads.
        //

    case ProcessEnableAlignmentFaultFixup: {

        if (ProcessInformationLength != sizeof (BOOLEAN)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            EnableAlignmentFaultFixup = *(PBOOLEAN)ProcessInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (EnableAlignmentFaultFixup) {
            Process->DefaultHardErrorProcessing |= PROCESS_HARDERROR_ALIGNMENT_BIT;
        } else {
            Process->DefaultHardErrorProcessing &= ~PROCESS_HARDERROR_ALIGNMENT_BIT;
        }

        KeSetAutoAlignmentProcess (&(Process->Pcb), EnableAlignmentFaultFixup);

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessWx86Information : {

        ULONG  VdmAllowedFlags;

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {

            VdmAllowedFlags = *(PULONG)ProcessInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        //
        // Must make sure the caller is a trusted subsystem with the
        // appropriate privilege level before executing this call.
        // If the calls returns FALSE we must return an error code.
        //
        if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        //
        // Make sure the ProcessHandle is indeed a process handle.
        //

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (NT_SUCCESS (st)) {

            //
            // For now, non zero Flags will allowed VDM.
            //

            if (VdmAllowedFlags) {
                PS_SET_BITS(&Process->Flags, PS_PROCESS_FLAGS_VDM_ALLOWED);
            } else {
                PS_CLEAR_BITS(&Process->Flags, PS_PROCESS_FLAGS_VDM_ALLOWED);
            }
            ObDereferenceObject(Process);
        }

        return st;
    }

    case ProcessAffinityMask:

        if (ProcessInformationLength != sizeof (KAFFINITY)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            Affinity = *(PKAFFINITY)ProcessInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        AffinityWithMasks = Affinity & KeActiveProcessors;

        if (!Affinity || (AffinityWithMasks != Affinity)) {
            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // If the process has a job object, override whatever the process
        // is calling with with the value from the job object
        //
        Job = Process->Job;
        if (Job != NULL) {
            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

            if (Job->LimitFlags & JOB_OBJECT_LIMIT_AFFINITY) {
                AffinityWithMasks = Job->Affinity;
            }

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        }

        if (ExAcquireRundownProtection (&Process->RundownProtect)) {

            PspLockProcessExclusive (Process, CurrentThread);

            KeSetAffinityProcess (&Process->Pcb, AffinityWithMasks);

            PspUnlockProcessExclusive (Process, CurrentThread);

            ExReleaseRundownProtection (&Process->RundownProtect);

            st = STATUS_SUCCESS;
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }
        ObDereferenceObject (Process);
        return st;

    case ProcessPriorityBoost:
        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            DisableBoost = *(PULONG)ProcessInformation;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        bDisableBoost = (DisableBoost ? TRUE : FALSE);

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Acquire rundown protection to give back the correct error
        // if the process has or is being terminated.
        //


        if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
            st = STATUS_PROCESS_IS_TERMINATING;
        } else {
            PLIST_ENTRY Next;

            PspLockProcessExclusive (Process, CurrentThread);

            KeSetDisableBoostProcess(&Process->Pcb, bDisableBoost);

            for (Next = Process->ThreadListHead.Flink;
                 Next != &Process->ThreadListHead;
                 Next = Next->Flink) {
                Thread = (PETHREAD)(CONTAINING_RECORD(Next, ETHREAD, ThreadListEntry));
                KeSetDisableBoostThread (&Thread->Tcb, bDisableBoost);
            }

            PspUnlockProcessExclusive (Process, CurrentThread);

            ExReleaseRundownProtection (&Process->RundownProtect);
        }

        ObDereferenceObject (Process);
        return st;

    case ProcessDebugFlags : {
        ULONG Flags;

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        try {
            Flags = *(PULONG) ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Flags = 0;
            st = GetExceptionCode ();
        }
        if (NT_SUCCESS (st)) {
            if (Flags & ~PROCESS_DEBUG_INHERIT) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                if (Flags&PROCESS_DEBUG_INHERIT) {
                    PS_CLEAR_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT);
                } else {
                    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT);
                }
            }
        }

        ObDereferenceObject (Process);

        return st;
    }

    case ProcessDeviceMap:
        DeviceMapInfo = (PPROCESS_DEVICEMAP_INFORMATION)ProcessInformation;
        if (ProcessInformationLength != sizeof (DeviceMapInfo->Set)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            DirectoryHandle = DeviceMapInfo->Set.DirectoryHandle;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        //
        // The devmap fields here are synchronized using a private ob spinlock. We don't need to protect with a
        // lock at this level.
        //
        st = ObSetDeviceMap (Process, DirectoryHandle);

        ObDereferenceObject (Process);
        return st;

    case ProcessSessionInformation :

        //
        // Update Multi-User session specific process information
        //
        if (ProcessInformationLength != (ULONG) sizeof (PROCESS_SESSION_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            SessionInfo = *(PPROCESS_SESSION_INFORMATION) ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        //
        // We only allow TCB to set SessionId's
        //
        if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        //
        // Reference process object
        //
        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION | PROCESS_SET_SESSIONID,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Update SessionId in the Token
        //
        if (SessionInfo.SessionId != MmGetSessionId (Process)) {
            st = STATUS_ACCESS_DENIED;
        } else {
            st = STATUS_SUCCESS;
        }

        ObDereferenceObject (Process);

        return( st );

    case ProcessBreakOnTermination:

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {

            EnableBreakOnTermination = *(PULONG)ProcessInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (!SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if ( EnableBreakOnTermination ) {

            PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_BREAK_ON_TERMINATION);

        } else {

            PS_CLEAR_BITS (&Process->Flags, PS_PROCESS_FLAGS_BREAK_ON_TERMINATION);

        }

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;

    case ProcessHandleTracing: {

        PPROCESS_HANDLE_TRACING_ENABLE_EX Pht;
        PHANDLE_TABLE HandleTable;
        ULONG Slots;

        Slots = 0;

        //
        // Zero length disables otherwise we enable
        //
        if (ProcessInformationLength != 0) {
            if (ProcessInformationLength != sizeof (PROCESS_HANDLE_TRACING_ENABLE) &&
                ProcessInformationLength != sizeof (PROCESS_HANDLE_TRACING_ENABLE_EX)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Pht = (PPROCESS_HANDLE_TRACING_ENABLE_EX) ProcessInformation;


            try {
                if (Pht->Flags != 0) {
                    return STATUS_INVALID_PARAMETER;
                }
                if (ProcessInformationLength == sizeof (PROCESS_HANDLE_TRACING_ENABLE_EX)) {
                    Slots = Pht->TotalSlots;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }
        HandleTable = ObReferenceProcessHandleTable (Process);

        if (HandleTable != NULL) {
            if (ProcessInformationLength != 0) {
                st = ExEnableHandleTracing (HandleTable, Slots);
            } else {
                st = ExDisableHandleTracing (HandleTable);
            }
            ObDereferenceProcessHandleTable (Process);
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject(Process);
        return st;
    }

    case ProcessExecuteFlags:

        //
        // This code is used to enable execution flags for user thread stacks
        // within a process.
        //

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        if (ProcessHandle != NtCurrentProcess ()) {
            return STATUS_INVALID_PARAMETER;
        }

        try {
            ExecuteOptions = *(PULONG)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = MmSetExecuteOptions (ExecuteOptions);

        return st;

    default:
        return STATUS_INVALID_INFO_CLASS;
    }
}


NTSTATUS
NtQueryInformationThread(
    __in HANDLE ThreadHandle,
    __in THREADINFOCLASS ThreadInformationClass,
    __out_bcount(ThreadInformationLength) PVOID ThreadInformation,
    __in ULONG ThreadInformationLength,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This function queries the state of a thread object and returns the
    requested information in the specified record structure.

Arguments:

    ThreadHandle - Supplies a handle to a thread object.

    ThreadInformationClass - Supplies the class of information being
        requested.

    ThreadInformation - Supplies a pointer to a record that is to
        receive the requested information.

    ThreadInformationLength - Supplies the length of the record that is
        to receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that is to
        receive the actual length of information that is returned.

--*/

{

    LARGE_INTEGER PerformanceCount;
    PETHREAD Thread;
    PEPROCESS Process;
    ULONG LastThread;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    THREAD_BASIC_INFORMATION BasicInfo;
    KERNEL_USER_TIMES SysUserTime;
    PVOID Win32StartAddressValue;
    ULONG DisableBoost;
    ULONG IoPending ;
    ULONG BreakOnTerminationEnabled;
    PETHREAD CurrentThread;
    ULONG ThreadTerminated;
    //
    // Get previous processor mode and probe output argument if necessary.
    //

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {
        try {
            //
            // Since these functions don't change any state thats not reversible
            // in the error paths we only probe the output buffer for write access.
            // This improves performance by not touching the buffer multiple times
            // And only writing the portions of the buffer that change.
            //

            ProbeForRead (ThreadInformation,
                          ThreadInformationLength,
                          sizeof(ULONG));

            if (ARGUMENT_PRESENT( ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    //
    // Check argument validity.
    //

    switch (ThreadInformationClass) {

    case ThreadBasicInformation:

        if (ThreadInformationLength != (ULONG) sizeof (THREAD_BASIC_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (KeReadStateThread (&Thread->Tcb)) {
            BasicInfo.ExitStatus = Thread->ExitStatus;
        } else {
            BasicInfo.ExitStatus = STATUS_PENDING;
        }

        BasicInfo.TebBaseAddress = (PTEB) Thread->Tcb.Teb;
        BasicInfo.ClientId = Thread->Cid;
        BasicInfo.AffinityMask = Thread->Tcb.Affinity;
        BasicInfo.Priority = Thread->Tcb.Priority;
        BasicInfo.BasePriority = KeQueryBasePriorityThread (&Thread->Tcb);

        ObDereferenceObject (Thread);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PTHREAD_BASIC_INFORMATION) ThreadInformation = BasicInfo;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (THREAD_BASIC_INFORMATION);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ThreadTimes:

        if (ThreadInformationLength != (ULONG) sizeof (KERNEL_USER_TIMES)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        SysUserTime.KernelTime.QuadPart = UInt32x32To64(Thread->Tcb.KernelTime,
                                                        KeMaximumIncrement);

        SysUserTime.UserTime.QuadPart = UInt32x32To64(Thread->Tcb.UserTime,
                                                      KeMaximumIncrement);

        SysUserTime.CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME(Thread);
        if (KeReadStateThread(&Thread->Tcb)) {
            SysUserTime.ExitTime = Thread->ExitTime;
        } else {
            SysUserTime.ExitTime.QuadPart = 0;
        }

        ObDereferenceObject (Thread);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PKERNEL_USER_TIMES) ThreadInformation = SysUserTime;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (KERNEL_USER_TIMES);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ThreadDescriptorTableEntry :

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspQueryDescriptorThread (Thread,
                                       ThreadInformation,
                                       ThreadInformationLength,
                                       ReturnLength);

        ObDereferenceObject (Thread);

        return st;

    case ThreadQuerySetWin32StartAddress:
        if (ThreadInformationLength != sizeof (ULONG_PTR)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Win32StartAddressValue = Thread->Win32StartAddress;
        ObDereferenceObject (Thread);

        try {
            *(PVOID *) ThreadInformation = Win32StartAddressValue;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG_PTR);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

        //
        // Query thread cycle counter.
        //

    case ThreadPerformanceCount:
        if (ThreadInformationLength != sizeof (LARGE_INTEGER)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

#if defined (PERF_DATA)
        PerformanceCount.LowPart = Thread->PerformanceCountLow;
        PerformanceCount.HighPart = Thread->PerformanceCountHigh;
#else
        PerformanceCount.QuadPart = 0;
#endif
        ObDereferenceObject(Thread);

        try {
            *(PLARGE_INTEGER)ThreadInformation = PerformanceCount;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (LARGE_INTEGER);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

    case ThreadAmILastThread:
        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        Process = THREAD_TO_PROCESS (CurrentThread);

        if (Process->ActiveThreads == 1) {
            LastThread = 1;
        } else {
            LastThread = 0;
        }

        try {
            *(PULONG)ThreadInformation = LastThread;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ThreadPriorityBoost:
        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        DisableBoost = Thread->Tcb.DisableBoost ? 1 : 0;

        ObDereferenceObject (Thread);

        try {
            *(PULONG)ThreadInformation = DisableBoost;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

    case ThreadIsIoPending:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Its impossible to synchronize this cross thread.
        // Since the result is worthless the second its fetched
        // this isn't a problem.
        //
        IoPending = !IsListEmpty (&Thread->IrpList);


        ObDereferenceObject (Thread);

        try {
            *(PULONG)ThreadInformation = IoPending ;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        return STATUS_SUCCESS ;

    case ThreadBreakOnTermination:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION) {

            BreakOnTerminationEnabled = 1;

        } else {

            BreakOnTerminationEnabled = 0;

        }

        ObDereferenceObject(Thread);

        try {

            *(PULONG) ThreadInformation = BreakOnTerminationEnabled;

            if (ARGUMENT_PRESENT(ReturnLength) ) {
                *ReturnLength = sizeof(ULONG);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ThreadIsTerminated:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }
    
        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);
    
        if (!NT_SUCCESS (st)) {
            return st;
        }
    
        if (PsIsThreadTerminating (Thread) == TRUE) {
            ThreadTerminated = 1;
        } else {
            ThreadTerminated = 0;
        }
    
        ObDereferenceObject (Thread);
    
        try {
    
            *(PULONG) ThreadInformation = ThreadTerminated;
    
            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }
    
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    
        return STATUS_SUCCESS;
        
    default:
        return STATUS_INVALID_INFO_CLASS;
    }

}

NTSTATUS
NtSetInformationThread(
    __in HANDLE ThreadHandle,
    __in THREADINFOCLASS ThreadInformationClass,
    __in_bcount(ThreadInformationLength) PVOID ThreadInformation,
    __in ULONG ThreadInformationLength
    )

/*++

Routine Description:

    This function sets the state of a thread object.

Arguments:

    ThreadHandle - Supplies a handle to a thread object.

    ThreadInformationClass - Supplies the class of information being
        set.

    ThreadInformation - Supplies a pointer to a record that contains the
        information to set.

    ThreadInformationLength - Supplies the length of the record that contains
        the information to set.

--*/

{
    PETHREAD Thread;
    PETHREAD CurrentThread;
    PEPROCESS Process;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    KAFFINITY Affinity, AffinityWithMasks;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG TlsIndex;
    PVOID TlsArrayAddress;
    PVOID Win32StartAddressValue;
    ULONG ProbeAlignment;
    BOOLEAN EnableAlignmentFaultFixup;
    ULONG EnableBreakOnTermination;
    ULONG IdealProcessor;
    ULONG DisableBoost;
    PVOID *ExpansionSlots;
    HANDLE ImpersonationTokenHandle;
    BOOLEAN HasPrivilege;
    PEJOB Job;
    PTEB Teb;
        
    PAGED_CODE();

    //
    // Get previous processor mode and probe input argument if necessary.
    //

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {
        try {

            switch (ThreadInformationClass) {

            case ThreadPriority :
                ProbeAlignment = sizeof(KPRIORITY);
                break;
            case ThreadAffinityMask :
            case ThreadQuerySetWin32StartAddress :
                ProbeAlignment = sizeof (ULONG_PTR);
                break;
            case ThreadEnableAlignmentFaultFixup :
                ProbeAlignment = sizeof (BOOLEAN);
                break;
            default :
                ProbeAlignment = sizeof(ULONG);
            }

            ProbeForRead(
                ThreadInformation,
                ThreadInformationLength,
                ProbeAlignment);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    //
    // Check argument validity.
    //

    switch (ThreadInformationClass) {

    case ThreadPriority:

        if (ThreadInformationLength != sizeof (KPRIORITY)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            Priority = *(KPRIORITY *)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (Priority > HIGH_PRIORITY ||
            Priority <= LOW_PRIORITY) {

            return STATUS_INVALID_PARAMETER;
        }

        if (Priority >= LOW_REALTIME_PRIORITY) {

            //
            // Increasing the priority of a thread beyond
            // LOW_REALTIME_PRIORITY is a privileged operation.
            //

            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                    ThreadHandle,
                                                    THREAD_SET_INFORMATION,
                                                    PreviousMode);

            if (!HasPrivilege) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        KeSetPriorityThread (&Thread->Tcb, Priority);

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

    case ThreadBasePriority:

        if (ThreadInformationLength != sizeof (LONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            BasePriority = *(PLONG)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }
        Process = THREAD_TO_PROCESS (Thread);


        if (BasePriority > THREAD_BASE_PRIORITY_MAX ||
            BasePriority < THREAD_BASE_PRIORITY_MIN) {
            if (BasePriority == THREAD_BASE_PRIORITY_LOWRT+1 ||
                BasePriority == THREAD_BASE_PRIORITY_IDLE-1) {
                ;
            } else {

                //
                // Allow csrss, or realtime processes to select any
                // priority
                //

                if (PsGetCurrentProcessByThread (CurrentThread) == ExpDefaultErrorPortProcess ||
                    Process->PriorityClass == PROCESS_PRIORITY_CLASS_REALTIME) {
                    ;
                } else {
                    ObDereferenceObject (Thread);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }

        //
        // If the thread is running within a job object, and the job
        // object has a priority class limit, do not allow
        // priority adjustments that raise the thread's priority, unless
        // the priority class is realtime
        //

        Job = Process->Job;
        if (Job != NULL && (Job->LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS)) {
            if (Process->PriorityClass != PROCESS_PRIORITY_CLASS_REALTIME){
                if (BasePriority > 0) {
                    ObDereferenceObject (Thread);
                    return STATUS_SUCCESS;
                }
            }
        }

        KeSetBasePriorityThread (&Thread->Tcb, BasePriority);

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

    case ThreadEnableAlignmentFaultFixup:

        if (ThreadInformationLength != sizeof (BOOLEAN) ) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            EnableAlignmentFaultFixup = *(PBOOLEAN)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        KeSetAutoAlignmentThread (&Thread->Tcb, EnableAlignmentFaultFixup);

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

    case ThreadAffinityMask:

        if (ThreadInformationLength != sizeof (KAFFINITY)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            Affinity = *(PKAFFINITY)ThreadInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (!Affinity) {
            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Process = THREAD_TO_PROCESS (Thread);

        if (ExAcquireRundownProtection (&Process->RundownProtect)) {

            PspLockProcessShared (Process, CurrentThread);

            AffinityWithMasks = Affinity & Process->Pcb.Affinity;
            if (AffinityWithMasks != Affinity) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                KeSetAffinityThread (&Thread->Tcb,
                                     AffinityWithMasks);
                st = STATUS_SUCCESS;
            }

            PspUnlockProcessShared (Process, CurrentThread);

            ExReleaseRundownProtection (&Process->RundownProtect);
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject (Thread);

        return st;

    case ThreadImpersonationToken:


        if (ThreadInformationLength != sizeof (HANDLE)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }


        try {
            ImpersonationTokenHandle = *(PHANDLE) ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }


        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_THREAD_TOKEN,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Check for proper access to (and type of) the token, and assign
        // it as the thread's impersonation token.
        //

        st = PsAssignImpersonationToken (Thread, ImpersonationTokenHandle);


        ObDereferenceObject (Thread);

        return st;

    case ThreadQuerySetWin32StartAddress:
        if (ThreadInformationLength != sizeof (ULONG_PTR)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }


        try {
            Win32StartAddressValue = *(PVOID *) ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }


        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Thread->Win32StartAddress = (PVOID)Win32StartAddressValue;

        ObDereferenceObject (Thread);

        return st;


    case ThreadIdealProcessor:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }


        try {
            IdealProcessor = *(PULONG)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (IdealProcessor > MAXIMUM_PROCESSORS) {
            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // return info from this set only api
        //

        st = (NTSTATUS)KeSetIdealProcessorThread (&Thread->Tcb, (CCHAR)IdealProcessor);

        //
        // We could be making cross process and/or cross thread references here.
        // Acquire rundown protection to make sure the teb can't go away.
        //
        Teb = Thread->Tcb.Teb;
        if (Teb != NULL && ExAcquireRundownProtection (&Thread->RundownProtect)) {
            PEPROCESS TargetProcess;
            BOOLEAN Attached;
            KAPC_STATE ApcState;

            Attached = FALSE;
            //
            // See if we are crossing process boundaries and if so attach to the target
            //
            TargetProcess = THREAD_TO_PROCESS (Thread);
            if (TargetProcess != PsGetCurrentProcessByThread (CurrentThread)) {
                KeStackAttachProcess (&TargetProcess->Pcb, &ApcState);
                Attached = TRUE;
            }

            try {

                Teb->IdealProcessor = Thread->Tcb.IdealProcessor;
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }

            if (Attached) {
                KeUnstackDetachProcess (&ApcState);
            }

            ExReleaseRundownProtection (&Thread->RundownProtect);


        }


        ObDereferenceObject (Thread);

        return st;


    case ThreadPriorityBoost:
        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            DisableBoost = *(PULONG)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        KeSetDisableBoostThread (&Thread->Tcb,DisableBoost ? TRUE : FALSE);

        ObDereferenceObject (Thread);

        return st;

    case ThreadZeroTlsCell:
        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            TlsIndex = *(PULONG) ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        ObDereferenceObject (Thread);

        if (Thread != CurrentThread) {
            return STATUS_INVALID_PARAMETER;
        }

        Process = THREAD_TO_PROCESS (Thread);


        // The 32bit TEB needs to be set if this is a WOW64 process on a 64BIT system.
        // This code isn't 100% correct since threads have a conversion state where they
        // are changing from 64 to 32 and they don't have a TEB32 yet.  Fortunately, the slots
        // will be zero when the thread is created so no damage is done by not clearing it here.

        // Note that the test for the process type is inside the inner loop. This
        // is bad programming, but this function is hardly time constrained and
        // fixing this with complex macros would not be worth it due to the loss of clarity.

        for (Thread = PsGetNextProcessThread (Process, NULL);
             Thread != NULL;
             Thread = PsGetNextProcessThread (Process, Thread)) {

            //
            // We are doing cross thread TEB references and need to prevent TEB deletion.
            //
            if (ExAcquireRundownProtection (&Thread->RundownProtect)) {
                Teb = Thread->Tcb.Teb;
                if (Teb != NULL) {
                    try {
#if defined(_WIN64)
                        PTEB32 Teb32 = NULL;
                        PLONG ExpansionSlots32;

                        if (Process->Wow64Process) { //wow64 process
                            Teb32 = WOW64_GET_TEB32(Teb);  //No probing needed on regular TEB.
                        }
#endif
                        if (TlsIndex > TLS_MINIMUM_AVAILABLE-1) {
                            if ( TlsIndex < (TLS_MINIMUM_AVAILABLE+TLS_EXPANSION_SLOTS) - 1 ) {
                                //
                                // This is an expansion slot, so see if the thread
                                // has an expansion cell
                                //
#if defined(_WIN64)
                                if (Process->Wow64Process) { //Wow64 process.
                                    if (Teb32) {
                                        ExpansionSlots32 = ULongToPtr(ProbeAndReadUlong(&(Teb32->TlsExpansionSlots)));
                                        if (ExpansionSlots32) {
                                            ProbeAndWriteLong(ExpansionSlots32 + TlsIndex - TLS_MINIMUM_AVAILABLE, 0);
                                        }
                                    }
                                } else {
#endif
                                    ExpansionSlots = Teb->TlsExpansionSlots;
                                    ProbeForReadSmallStructure (ExpansionSlots, TLS_EXPANSION_SLOTS*4, 8);
                                    if ( ExpansionSlots ) {
                                        ExpansionSlots[TlsIndex-TLS_MINIMUM_AVAILABLE] = 0;
                                    }

#if defined(_WIN64)
                                }
#endif
                            }
                        } else {
#if defined(_WIN64)
                            if (Process->Wow64Process) { //wow64 process
                               if(Teb32) {
                                  ProbeAndWriteUlong(Teb32->TlsSlots + TlsIndex, 0);
                               }
                            } else {
#endif
                               Teb->TlsSlots[TlsIndex] = NULL;
#if defined(_WIN64)
                            }
#endif
                        }
                    } except (EXCEPTION_EXECUTE_HANDLER) {
                        st = GetExceptionCode ();
                    }

                }
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }
        }

        return st;
        break;

    case ThreadSetTlsArrayAddress:
        if (ThreadInformationLength != sizeof (PVOID)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }


        try {
            TlsArrayAddress = *(PVOID *)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Thread->Tcb.TlsArray = TlsArrayAddress;

        ObDereferenceObject (Thread);

        return st;
        break;

    case ThreadHideFromDebugger:
        if (ThreadInformationLength != 0) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HIDEFROMDBG);

        ObDereferenceObject (Thread);

        return st;
        break;

    case ThreadBreakOnTermination:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {

            EnableBreakOnTermination = *(PULONG)ThreadInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        if (!SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (EnableBreakOnTermination) {

            PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION);

        } else {

            PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION);

        }

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

    case ThreadSwitchLegacyState:

#if defined(_AMD64_)

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Thread->Tcb.NpxState = LEGACY_STATE_SWITCH;

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

#else

        return STATUS_NOT_IMPLEMENTED;

#endif

    default:
        return STATUS_INVALID_INFO_CLASS;
    }
}

ULONG
NtGetCurrentProcessorNumber(
    VOID
    )
{
    return KeGetCurrentProcessorNumber();
}

VOID
PsWatchWorkingSet(
    IN NTSTATUS Status,
    IN PVOID PcValue,
    IN PVOID Va
    )

/*++

Routine Description:

    This function collects data about page faults and stores information
    about the page fault in the current process's data structure.

Arguments:

    Status - Supplies the success completion status.

    PcValue - Supplies the instruction address that caused the page fault.

    Va - Supplies the virtual address that caused the page fault.

--*/

{

    PEPROCESS Process;
    PPAGEFAULT_HISTORY WorkingSetCatcher;
    KIRQL OldIrql;
    BOOLEAN TransitionFault = FALSE;

    //
    // Both transition and demand zero faults count as soft faults. Only disk
    // reads count as hard faults.
    //

    if ( Status <= STATUS_PAGE_FAULT_DEMAND_ZERO ) {
        TransitionFault = TRUE;
    }

    Process = PsGetCurrentProcess();
    WorkingSetCatcher = Process->WorkingSetWatch;
    if (WorkingSetCatcher == NULL) {
        return;
    }

    ExAcquireSpinLock(&WorkingSetCatcher->SpinLock,&OldIrql);
    if (WorkingSetCatcher->CurrentIndex >= WorkingSetCatcher->MaxIndex) {
        ExReleaseSpinLock(&WorkingSetCatcher->SpinLock,OldIrql);
        return;
    }

    //
    // Store the Pc and Va values in the buffer. Use the least sig. bit
    // of the Va to store whether it was a soft or hard fault
    //

    WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingPc = PcValue;
    WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingVa = TransitionFault ? (PVOID)((ULONG_PTR)Va | 1) : (PVOID)((ULONG_PTR)Va & 0xfffffffe) ;
    WorkingSetCatcher->CurrentIndex++;
    ExReleaseSpinLock(&WorkingSetCatcher->SpinLock,OldIrql);
    return;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

PKWIN32_PROCESS_CALLOUT PspW32ProcessCallout = NULL;
PKWIN32_THREAD_CALLOUT PspW32ThreadCallout = NULL;
PKWIN32_JOB_CALLOUT PspW32JobCallout = NULL;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
extern PKWIN32_POWEREVENT_CALLOUT PopEventCallout;
extern PKWIN32_POWERSTATE_CALLOUT PopStateCallout;

NTKERNELAPI
VOID
PsEstablishWin32Callouts(
    __in PKWIN32_CALLOUTS_FPNS pWin32Callouts
    )

/*++

Routine Description:

    This function is used by the Win32 kernel mode component to
    register callout functions for process/thread init/deinit functions
    and to report the sizes of the structures.

Arguments:

    ProcessCallout - Supplies the address of the function to be called when
        a process is either created or deleted.

    ThreadCallout - Supplies the address of the function to be called when
        a thread is either created or deleted.

    GlobalAtomTableCallout - Supplies the address of the function to be called
        to get the correct global atom table for the current process

    PowerEventCallout - Supplies the address of a function to be called when
        a power event occurs.

    PowerStateCallout - Supplies the address of a function to be called when
        the power state changes.

    JobCallout - Supplies the address of a function to be called when
        the job state changes or a process is assigned to a job.

    BatchFlushRoutine - Supplies the address of the function to be called

Return Value:

    None.

--*/

{
    PAGED_CODE();

    PspW32ProcessCallout = pWin32Callouts->ProcessCallout;
    PspW32ThreadCallout = pWin32Callouts->ThreadCallout;
    ExGlobalAtomTableCallout = pWin32Callouts->GlobalAtomTableCallout;
    KeGdiFlushUserBatch = (PGDI_BATCHFLUSH_ROUTINE)pWin32Callouts->BatchFlushRoutine;
    PopEventCallout = pWin32Callouts->PowerEventCallout;
    PopStateCallout = pWin32Callouts->PowerStateCallout;
    PspW32JobCallout = pWin32Callouts->JobCallout;
//    PoSetSystemState(ES_SYSTEM_REQUIRED);


    ExDesktopOpenProcedureCallout = pWin32Callouts->DesktopOpenProcedure;
    ExDesktopOkToCloseProcedureCallout = pWin32Callouts->DesktopOkToCloseProcedure;
    ExDesktopCloseProcedureCallout = pWin32Callouts->DesktopCloseProcedure;
    ExDesktopDeleteProcedureCallout = pWin32Callouts->DesktopDeleteProcedure;
    ExWindowStationOkToCloseProcedureCallout = pWin32Callouts->WindowStationOkToCloseProcedure;
    ExWindowStationCloseProcedureCallout = pWin32Callouts->WindowStationCloseProcedure;
    ExWindowStationDeleteProcedureCallout = pWin32Callouts->WindowStationDeleteProcedure;
    ExWindowStationParseProcedureCallout = pWin32Callouts->WindowStationParseProcedure;
    ExWindowStationOpenProcedureCallout = pWin32Callouts->WindowStationOpenProcedure;
    return;
}

VOID
PsSetProcessPriorityByClass (
    __inout PEPROCESS Process,
    __in PSPROCESSPRIORITYMODE PriorityMode
    )

{

    KPRIORITY BasePriority;
    SCHAR QuantumReset;

    PAGED_CODE();

    BasePriority = PspComputeQuantumAndPriority(Process,
                                                PriorityMode,
                                                &QuantumReset);

    KeSetPriorityAndQuantumProcess(&Process->Pcb, BasePriority, QuantumReset);
    return;
}

KPRIORITY
PspComputeQuantumAndPriority (
    __inout PEPROCESS Process,
    __in PSPROCESSPRIORITYMODE PriorityMode,
    __out PSCHAR QuantumReset
    )

/*++

Routine Description:

    This function computes the base priority and quantum reset values for
    the specified process and sets the memory priority of the process.

Arguments:

    Process - Supplies a pointer to a executive process object.

    PriorityMode - Supplies the priority mode.

    QuantumReset - Supplies a pointer to a variable that receives the computed
        quantum reset value.

Return Value:

    The computed base priority is returned as the function value.

--*/

{

    PEJOB Job;
    UCHAR MemoryPriority;
    ULONG QuantumIndex;
    SCHAR Quantum;

    PAGED_CODE();

    //
    // Compute and set process memory priority if appropriate.
    //

    if (PriorityMode == PsProcessPriorityForeground) {
        QuantumIndex = PsPrioritySeparation;
        MemoryPriority = MEMORY_PRIORITY_FOREGROUND;

    } else {
        QuantumIndex = 0;
        MemoryPriority = MEMORY_PRIORITY_BACKGROUND;
    }

    if (PriorityMode != PsProcessPrioritySpinning) {
        MmSetMemoryPriorityProcess(Process, MemoryPriority);
    }

    //
    // Compute quantum reset value.
    //

    if (Process->PriorityClass != PROCESS_PRIORITY_CLASS_IDLE) {
        Job = Process->Job;
        if ((Job != NULL) && (PspUseJobSchedulingClasses != FALSE)) {
            Quantum = PspJobSchedulingClasses[Job->SchedulingClass];

        } else {
            Quantum = PspForegroundQuantum[QuantumIndex];
        }

    } else {
        Quantum = THREAD_QUANTUM;
    }

    *QuantumReset = Quantum;
    return PspPriorityTable[Process->PriorityClass];
}

#if defined(_X86_)
#pragma optimize ("y",off)
#endif

NTSTATUS
PsConvertToGuiThread(
    VOID
    )

/*++

Routine Description:

    This function converts a thread to a GUI thread. This involves giving the
    thread a larger variable sized stack, and allocating appropriate w32
    thread and process objects.

Arguments:

    None.

Environment:

    On x86 this function needs to build an EBP frame.  The function
    KeSwitchKernelStack depends on this fact.   The '#pragma optimize
    ("y",off)' below disables frame pointer omission for all builds.

--*/

{
    PVOID NewStack;
    PVOID OldStack;
    PETHREAD Thread;
    PEPROCESS Process;
    NTSTATUS Status;
    PKNODE Node;

    PAGED_CODE();

    Thread = PsGetCurrentThread();

    if (KeGetPreviousModeByThread(&Thread->Tcb) == KernelMode) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!PspW32ProcessCallout) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // If the thread is using the shadow service table, then an attempt is
    // being made to convert a thread that has already been converted, or
    // a limit violation has occured on the Win32k system service table.
    //

#if defined(_AMD64_)

    if (Thread->Tcb.Win32kTable != NULL) {

#else

    if (Thread->Tcb.ServiceTable != (PVOID)&KeServiceDescriptorTable[0]) {

#endif

        return STATUS_ALREADY_WIN32;
    }

    Process = PsGetCurrentProcessByThread (Thread);

    //
    // Get a larger kernel stack if we haven't already.
    //

    if (!Thread->Tcb.LargeStack) {

        Node = KiProcessorBlock[Thread->Tcb.IdealProcessor]->ParentNode;
        NewStack = MmCreateKernelStack(TRUE,
                                       Node->NodeNumber);

        if ( !NewStack ) {

            try {
                NtCurrentTeb()->LastErrorValue = (LONG)ERROR_NOT_ENOUGH_MEMORY;
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }

            return STATUS_NO_MEMORY;
        }

        //
        // Switching kernel stacks will copy the base trap frame. This needs
        // to be protected from context changes by disabling kernel APC's.
        //

        KeEnterGuardedRegionThread (&Thread->Tcb);

        OldStack = KeSwitchKernelStack(NewStack,
                                   (UCHAR *)NewStack - KERNEL_LARGE_STACK_COMMIT);

        KeLeaveGuardedRegionThread (&Thread->Tcb);

        MmDeleteKernelStack(OldStack, FALSE);
    }

    PERFINFO_CONVERT_TO_GUI_THREAD(Thread);

    //
    // We are all clean on the stack, now call out and then link the Win32 structures
    // to the base exec structures
    //

    Status = (PspW32ProcessCallout) (Process, TRUE);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Switch the thread to use the shadow system service table which will
    // enable it to execute Win32k services.
    //

#if defined(_AMD64_)

    Thread->Tcb.Win32kTable = KeServiceDescriptorTableShadow[WIN32K_SERVICE_INDEX].Base;
    Thread->Tcb.Win32kLimit = KeServiceDescriptorTableShadow[WIN32K_SERVICE_INDEX].Limit;
    
#else

    Thread->Tcb.ServiceTable = (PVOID)&KeServiceDescriptorTableShadow[0];

#endif

    ASSERT (Thread->Tcb.Win32Thread == 0);


    //
    // Make the thread callout.
    //

    Status = (PspW32ThreadCallout)(Thread,PsW32ThreadCalloutInitialize);
    if (!NT_SUCCESS (Status)) {

#if defined(_AMD64_)

        Thread->Tcb.Win32kTable = NULL;
        Thread->Tcb.Win32kLimit = 0;

#else

        Thread->Tcb.ServiceTable = (PVOID)&KeServiceDescriptorTable[0];

#endif

    }

    return Status;

}

#if defined(_X86_)
#pragma optimize ("y",on)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\security.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    security.c

Abstract:

    This module implements the security related portions of the process
    structure.

Revision History:

    Revamped for fast referencing the primary token and holding the security lock
    only over critical portions.

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
PsOpenTokenOfJobObject(
    IN HANDLE JobObject,
    OUT PACCESS_TOKEN * Token
    );

#pragma alloc_text(PAGE, PsReferencePrimaryToken)
#pragma alloc_text(PAGE, PsReferenceImpersonationToken)
#pragma alloc_text(PAGE, PsReferenceEffectiveToken)
#pragma alloc_text(PAGE, PsOpenTokenOfThread)
#pragma alloc_text(PAGE, PsOpenTokenOfProcess)
#pragma alloc_text(PAGE, PsOpenTokenOfJobObject)
#pragma alloc_text(PAGE, PsImpersonateClient)
#pragma alloc_text(PAGE, PsDisableImpersonation)
#pragma alloc_text(PAGE, PsRestoreImpersonation)
#pragma alloc_text(PAGE, PsRevertToSelf)
#pragma alloc_text(PAGE, PsRevertThreadToSelf)
#pragma alloc_text(PAGE, PspInitializeProcessSecurity)
#pragma alloc_text(PAGE, PspDeleteProcessSecurity)
#pragma alloc_text(PAGE, PspAssignPrimaryToken)
#pragma alloc_text(PAGE, PspInitializeThreadSecurity)
#pragma alloc_text(PAGE, PspDeleteThreadSecurity)
#pragma alloc_text(PAGE, PsAssignImpersonationToken)
#pragma alloc_text(PAGE, PspWriteTebImpersonationInfo)
#pragma alloc_text(PAGE, PspSinglePrivCheck)
#pragma alloc_text(PAGE, PspSinglePrivCheckAudit)

#endif //ALLOC_PRAGMA


PACCESS_TOKEN
PsReferencePrimaryToken(
    __inout PEPROCESS Process
    )

/*++

Routine Description:

    This function returns a pointer to the primary token of a process.
    The reference count of that primary token is incremented to protect
    the pointer returned.

    When the pointer is no longer needed, it should be freed using
    PsDereferencePrimaryToken().


Arguments:

    Process - Supplies the address of the process whose primary token
        is to be referenced.

Return Value:

    A pointer to the specified process's primary token.

--*/

{
    PACCESS_TOKEN Token;
    PETHREAD CurrentThread;

    PAGED_CODE();

    ASSERT( Process->Pcb.Header.Type == ProcessObject );

    Token = ObFastReferenceObject (&Process->Token);
    if (Token == NULL) {
        CurrentThread = PsGetCurrentThread ();
        PspLockProcessSecurityShared (Process, CurrentThread);
        Token = ObFastReferenceObjectLocked (&Process->Token);
        PspUnlockProcessSecurityShared (Process, CurrentThread);
    }

    return Token;

}


PACCESS_TOKEN
PsReferenceImpersonationToken(
    __inout PETHREAD Thread,
    __out PBOOLEAN CopyOnOpen,
    __out PBOOLEAN EffectiveOnly,
    __out PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This function returns a pointer to the impersonation token of a thread.
    The reference count of that impersonation token is incremented to protect
    the pointer returned.

    If the thread is not currently impersonating a client, then a null pointer
    is returned.

    If the thread is impersonating a client, then information about the
    means of impersonation are also returned (ImpersonationLevel).

    If a non-null value is returned, then PsDereferenceImpersonationToken()
    must be called to decrement the token's reference count when the pointer
    is no longer needed.


Arguments:

    Thread - Supplies the address of the thread whose impersonation token
        is to be referenced.

    CopyOnOpen - The current value of the Thread->ImpersonationInfo->CopyOnOpen field.

    EffectiveOnly - The current value of the Thread->ImpersonationInfo->EffectiveOnly field.

    ImpersonationLevel - The current value of the Thread->ImpersonationInfo->ImpersonationLevel
        field.

Return Value:

    A pointer to the specified thread's impersonation token.

    If the thread is not currently impersonating a client, then NULL is
    returned.

--*/

{
    PACCESS_TOKEN Token;
    PETHREAD CurrentThread;
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    //
    // before going through the lock overhead just look to see if it is
    // null. There is no race.  Grabbing the lock is not needed until
    // we decide to use the token at which point we re check to see it
    // it is null.
    // This check saves about 300 instructions.
    //

    if (!PS_IS_THREAD_IMPERSONATING (Thread)) {
        return NULL;
    }

    //
    //  Lock the process security fields.
    //
    CurrentThread = PsGetCurrentThread ();

    PspLockThreadSecurityShared (Thread, CurrentThread);

    //
    // Grab impersonation info block.
    //
    ImpersonationInfo = Thread->ImpersonationInfo;


    if (PS_IS_THREAD_IMPERSONATING (Thread)) {

        //
        //  Return the thread's impersonation level, etc.
        //

        Token = ImpersonationInfo->Token;
        //
        //  Increment the reference count of the token to protect our
        //  pointer.
        //

        ObReferenceObject (Token);

        (*ImpersonationLevel) = ImpersonationInfo->ImpersonationLevel;
        (*CopyOnOpen) = ImpersonationInfo->CopyOnOpen;
        (*EffectiveOnly) = ImpersonationInfo->EffectiveOnly;



    } else {
        Token = NULL;
    }


    //
    //  Release the security fields.
    //

    PspUnlockThreadSecurityShared (Thread, CurrentThread);

    return Token;

}

PACCESS_TOKEN
PsReferenceEffectiveToken(
    IN PETHREAD Thread,
    OUT PTOKEN_TYPE TokenType,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This function returns a pointer to the effective token of a thread.  The
    effective token of a thread is the thread's impersonation token if it has
    one.  Otherwise, it is the primary token of the thread's process.

    The reference count of the effective token is incremented to protect
    the pointer returned.

    If the thread is impersonating a client, then the impersonation level
    is also returned.

    Either PsDereferenceImpersonationToken() (for an impersonation token) or
    PsDereferencePrimaryToken() (for a primary token) must be called to
    decrement the token's reference count when the pointer is no longer
    needed.


Arguments:

    Thread - Supplies the address of the thread whose effective token
        is to be referenced.

    TokenType - Receives the type of the effective token.  If the thread
        is currently impersonating a client, then this will be
        TokenImpersonation.  Otherwise, it will be TokenPrimary.

    EffectiveOnly - If the token type is TokenImpersonation, then this
        receives the value of the client thread's Thread->Client->EffectiveOnly field.
        Otherwise, it is set to FALSE.

    ImpersonationLevel - The current value of the Thread->Client->ImpersonationLevel
        field for an impersonation token and is not set for a primary token.

Return Value:

    A pointer to the specified thread's effective token.

--*/

{
    PACCESS_TOKEN Token;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    Process = THREAD_TO_PROCESS(Thread);

    //
    //  Grab the current impersonation token pointer value
    //

    Token = NULL;

    if (PS_IS_THREAD_IMPERSONATING (Thread)) {


        //
        //  Lock the process security fields.
        //
        CurrentThread = PsGetCurrentThread ();

        PspLockThreadSecurityShared (Thread, CurrentThread);


        if (PS_IS_THREAD_IMPERSONATING (Thread)) {
            //
            // Grab impersonation info block.
            //
            ImpersonationInfo = Thread->ImpersonationInfo;

            Token = ImpersonationInfo->Token;

            //
            //  Return the thread's impersonation level, etc.
            //

            (*TokenType) = TokenImpersonation;
            (*EffectiveOnly) = ImpersonationInfo->EffectiveOnly;
            (*ImpersonationLevel) = ImpersonationInfo->ImpersonationLevel;

            //
            //  Increment the reference count of the token to protect our
            //  pointer.
            //
            ObReferenceObject (Token);

            //
            //  Release the security fields.
            //

            PspUnlockThreadSecurityShared (Thread, CurrentThread);

            return Token;
        }

        //
        //  Release the security fields.
        //

        PspUnlockThreadSecurityShared (Thread, CurrentThread);

    }

    //
    // Get the thread's primary token if it wasn't impersonating a client.
    //

    Token = ObFastReferenceObject (&Process->Token);

    if (Token == NULL) {
        //
        // Fast ref failed. We go the slow way with a lock
        //
        CurrentThread = PsGetCurrentThread ();

        PspLockProcessSecurityShared (Process,CurrentThread);
        Token = ObFastReferenceObjectLocked (&Process->Token);
        PspUnlockProcessSecurityShared (Process,CurrentThread);
    }
    //
    //  Only the TokenType and CopyOnOpen OUT parameters are
    //  returned for a primary token.
    //

    (*TokenType) = TokenPrimary;
    (*EffectiveOnly) = FALSE;

    return Token;

}

NTSTATUS
PsOpenTokenOfThread(
    IN HANDLE ThreadHandle,
    IN BOOLEAN OpenAsSelf,
    OUT PACCESS_TOKEN *Token,
    OUT PBOOLEAN CopyOnOpen,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This function does the thread specific processing of
    an NtOpenThreadToken() service.

    The service validates that the handle has appropriate access
    to reference the thread.  If so, it goes on to increment
    the reference count of the token object to prevent it from
    going away while the rest of the NtOpenThreadToken() request
    is processed.

    NOTE: If this call completes successfully, the caller is responsible
          for decrementing the reference count of the target token.
          This must be done using PsDereferenceImpersonationToken().

Arguments:

    ThreadHandle - Supplies a handle to a thread object.

    OpenAsSelf - Is a boolean value indicating whether the access should
        be made using the calling thread's current security context, which
        may be that of a client (if impersonating), or using the caller's
        process-level security context.  A value of FALSE indicates the
        caller's current context should be used un-modified.  A value of
        TRUE indicates the request should be fulfilled using the process
        level security context.

    Token - If successful, receives a pointer to the thread's token
        object.

    CopyOnOpen - The current value of the Thread->Client->CopyOnOpen field.

    EffectiveOnly - The current value of the Thread->Client->EffectiveOnly field.

    ImpersonationLevel - The current value of the Thread->Client->ImpersonationLevel
        field.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_NO_TOKEN - Indicates the referenced thread is not currently
        impersonating a client.

    STATUS_CANT_OPEN_ANONYMOUS - Indicates the client requested anonymous
        impersonation level.  An anonymous token can not be opened.

    status may also be any value returned by an attempt the reference
    the thread object for THREAD_QUERY_INFORMATION access.

--*/

{

    NTSTATUS
        Status;

    PETHREAD
        Thread;

    KPROCESSOR_MODE
        PreviousMode;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();


    UNREFERENCED_PARAMETER (OpenAsSelf);

    //
    //  Make sure the handle grants the appropriate access to the specified
    //  thread.
    //

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);



    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    //  Reference the impersonation token, if there is one
    //

    (*Token) = PsReferenceImpersonationToken (Thread,
                                              CopyOnOpen,
                                              EffectiveOnly,
                                              ImpersonationLevel);


    //
    //  dereference the target thread.
    //

    ObDereferenceObject (Thread);

    //
    // Make sure there is a token
    //

    if (*Token == NULL) {
        return STATUS_NO_TOKEN;
    }

    //
    //  Make sure the ImpersonationLevel is high enough to allow
    //  the token to be opened.
    //

    if ((*ImpersonationLevel) <= SecurityAnonymous) {
        PsDereferenceImpersonationToken (*Token);
        (*Token) = NULL;
        return STATUS_CANT_OPEN_ANONYMOUS;
    }


    return STATUS_SUCCESS;

}


NTSTATUS
PsOpenTokenOfProcess(
    IN HANDLE ProcessHandle,
    OUT PACCESS_TOKEN *Token
    )

/*++

Routine Description:

    This function does the process specific processing of
    an NtOpenProcessToken() service.

    The service validates that the handle has appropriate access
    to referenced process.  If so, it goes on to reference the
    primary token object to prevent it from going away while the
    rest of the NtOpenProcessToken() request is processed.

    NOTE: If this call completes successfully, the caller is responsible
          for decrementing the reference count of the target token.
          This must be done using the PsDereferencePrimaryToken() API.

Arguments:

    ProcessHandle - Supplies a handle to a process object whose primary
        token is to be opened.

    Token - If successful, receives a pointer to the process's token
        object.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    status may also be any value returned by an attempt the reference
    the process object for PROCESS_QUERY_INFORMATION access.

--*/

{

    NTSTATUS
        Status;

    PEPROCESS
        Process;

    KPROCESSOR_MODE
        PreviousMode;


    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    //
    //  Make sure the handle grants the appropriate access to the specified
    //  process.
    //

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

    if (!NT_SUCCESS (Status)) {

        return Status;
    }

    //
    //  Reference the primary token
    //  (This takes care of gaining exclusive access to the process
    //   security fields for us)
    //

    (*Token) = PsReferencePrimaryToken (Process);



    //
    // Done with the process object
    //
    ObDereferenceObject (Process);

    return STATUS_SUCCESS;


}

NTSTATUS
PsOpenTokenOfJobObject(
    IN HANDLE JobObject,
    OUT PACCESS_TOKEN * Token
    )

/*++

Routine Description:

    This function does the ps/job specific work for NtOpenJobObjectToken.


Arguments:

    JobObject - Supplies a handle to a job object whose limit token
        token is to be opened.

    Token - If successful, receives a pointer to the process's token
        object.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_NO_TOKEN - indicates the job object does  not have a token


--*/
{
    NTSTATUS Status;
    PEJOB Job;
    KPROCESSOR_MODE PreviousMode;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (JobObject,
                                        JOB_OBJECT_QUERY,
                                        PsJobType,
                                        PreviousMode,
                                        &Job,
                                        NULL);

    if (NT_SUCCESS (Status)) {
        if (Job->Token != NULL) {
            ObReferenceObject (Job->Token);

            *Token = Job->Token;

        } else {
            Status = STATUS_NO_TOKEN;
        }
    }

    return Status;
}

NTSTATUS
PsImpersonateClient(
    __inout PETHREAD Thread,
    __in PACCESS_TOKEN Token,
    __in BOOLEAN CopyOnOpen,
    __in BOOLEAN EffectiveOnly,
    __in SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This routine sets up the specified thread so that it is impersonating
    the specified client.  This will result in the reference count of the
    token representing the client being incremented to reflect the new
    reference.

    If the thread is currently impersonating a client, that token will be
    dereferenced.



Arguments:

    Thread - points to the thread which is going to impersonate a client.

    Token - Points to the token to be assigned as the impersonation token.
        This does NOT have to be a TokenImpersonation type token.  This
        allows direct reference of client process's primary tokens.

    CopyOnOpen - If TRUE, indicates the token is considered to be private
        by the assigner and should be copied if opened.  For example, a
        session layer may be using a token to represent a client's context.
        If the session is trying to synchronize the context of the client,
        then user mode code should not be given direct access to the session
        layer's token.

        Basically, session layers should always specify TRUE for this, while
        tokens assigned by the server itself (handle based) should specify
        FALSE.


    EffectiveOnly - Is a boolean value to be assigned as the
        Thread->ImpersonationInfo->EffectiveOnly field value for the
        impersonation.  A value of FALSE indicates the server is allowed
        to enable currently disabled groups and privileges.

    ImpersonationLevel - Is the impersonation level that the server is allowed
        to access the token with.


Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.


--*/

{

    PPS_IMPERSONATION_INFORMATION NewClient, FreeClient;
    PACCESS_TOKEN OldToken;
    PACCESS_TOKEN NewerToken=NULL;
    PACCESS_TOKEN ProcessToken ;
    NTSTATUS Status;
    PPS_JOB_TOKEN_FILTER Filter;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PEJOB Job;
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;
    BOOLEAN DontReference = FALSE ;
    BOOLEAN NewTokenCreated = FALSE ;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    Process = THREAD_TO_PROCESS (Thread);

    if (!ARGUMENT_PRESENT(Token)) {

        OldToken = NULL;
        if (PS_IS_THREAD_IMPERSONATING (Thread)) {

            //
            //  Lock the process security fields
            //

            CurrentThread = PsGetCurrentThread ();

            PspLockThreadSecurityExclusive (Thread, CurrentThread);

            if (PS_IS_THREAD_IMPERSONATING (Thread)) {
                //
                // Grab impersonation info block.
                //
                ImpersonationInfo = Thread->ImpersonationInfo;

                //
                // This is a request to revert to self.
                // Clean up any client information.
                //
                OldToken = ImpersonationInfo->Token;
                PS_CLEAR_BITS (&Thread->CrossThreadFlags,
                               PS_CROSS_THREAD_FLAGS_IMPERSONATING);
            }
            //
            //  Release the security fields
            //
            PspUnlockThreadSecurityExclusive (Thread, CurrentThread);

            PspWriteTebImpersonationInfo (Thread, CurrentThread);
        }

    } else {

        //
        // Allocate and set up the Client block. We do this without holding the Process
        // security lock so we reduce contention. Only one thread will manage to assign this.
        // The client block once created never goes away until the last dereference of
        // the process. We can touch this without locks
        //
        NewClient = Thread->ImpersonationInfo;
        if (NewClient == NULL) {
            NewClient = ExAllocatePoolWithTag (PagedPool,
                                               sizeof (PS_IMPERSONATION_INFORMATION),
                                               'mIsP'|PROTECTED_POOL);

            if (NewClient == NULL) {
                return STATUS_NO_MEMORY;
            }
            FreeClient = InterlockedCompareExchangePointer (&Thread->ImpersonationInfo,
                                                            NewClient,
                                                            NULL);
            //
            // We got beaten by another thread. Free our context and use the new one
            //
            if (FreeClient != NULL) {
                ExFreePoolWithTag (NewClient, 'mIsP'|PROTECTED_POOL);
                NewClient = FreeClient;
            }

        }

        //
        // Check process token for rules on impersonation
        //

        ProcessToken = PsReferencePrimaryToken( Process );

        if ( ProcessToken ) {

            Status = SeTokenCanImpersonate( 
                        ProcessToken, 
                        Token,
                        ImpersonationLevel );

            PsDereferencePrimaryTokenEx( Process, ProcessToken );

            if ( !NT_SUCCESS( Status ) ) {

                Status = SeCopyClientToken(
                                Token,
                                SecurityIdentification,
                                KernelMode,
                                &NewerToken );

                if ( !NT_SUCCESS(Status)) {

                    return Status ;
                    
                }

                //
                // We have a substitute token.  Change Token to be this new
                // one, but do not add a reference later.  Right now, there 
                // is exactly one reference, so it will go away when the 
                // thread stops impersonating.  Note that we still need to 
                // do the job filters below, hence the switch.
                //

                Token = NewerToken ;
                NewerToken = NULL ;
                DontReference = TRUE ;
                NewTokenCreated = TRUE ;
                ImpersonationLevel = SecurityIdentification ;
                
            }
            
        }

        //
        // Check if we're allowed to impersonate based on the job
        // restrictions:
        //


        Job = Process->Job;
        if (Job != NULL) {

            if ((Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_NO_ADMIN) &&
                 (SeTokenIsAdmin (Token))) {

                if ( NewTokenCreated ) {

                    ObDereferenceObject( Token );
                    
                }

                return STATUS_ACCESS_DENIED;

            } else if ((Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_RESTRICTED_TOKEN) &&
                       (!SeTokenIsRestricted (Token))) {

                if ( NewTokenCreated ) {

                    ObDereferenceObject( Token );
                    
                }
                return STATUS_ACCESS_DENIED;

            } else {
                Filter = Job->Filter;
                if (Filter != NULL) {
                    //
                    // Filter installed.  Need to create a restricted token
                    // dynamically.
                    //

                    Status = SeFastFilterToken (Token,
                                                KernelMode,
                                                0,
                                                Filter->CapturedGroupCount,
                                                Filter->CapturedGroups,
                                                Filter->CapturedPrivilegeCount,
                                                Filter->CapturedPrivileges,
                                                Filter->CapturedSidCount,
                                                Filter->CapturedSids,
                                                Filter->CapturedSidsLength,
                                                &NewerToken);

                    if (NT_SUCCESS (Status)) {
                        //
                        // If we created a filtered token then we don't need to add an extra token reference
                        // as this is a new token with a single reference we just created.
                        //

                        if ( NewTokenCreated ) {

                            ObDereferenceObject( Token );

                        }
                        Token = NewerToken;

                    } else {

                        if ( NewTokenCreated ) {

                            ObDereferenceObject( Token );

                        }
                        return Status;
                    }

                } else {

                    if ( !DontReference) {

                        ObReferenceObject (Token);
                    }
                }
            }
        } else {

            if ( !DontReference) {
                
                ObReferenceObject (Token);
            }
        }

        //
        //  Lock the process security fields
        //

        CurrentThread = PsGetCurrentThread ();

        PspLockThreadSecurityExclusive (Thread, CurrentThread);
        //
        // If we are already impersonating someone,
        // use the already allocated block.  This avoids
        // an alloc and a free.
        //

        if (PS_IS_THREAD_IMPERSONATING (Thread)) {

            //
            // capture the old token pointer.
            // We'll dereference it after unlocking the security fields.
            //

            OldToken = NewClient->Token;

        } else {

            OldToken = NULL;

            PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
        }

        NewClient->ImpersonationLevel = ImpersonationLevel;
        NewClient->EffectiveOnly = EffectiveOnly;
        NewClient->CopyOnOpen = CopyOnOpen;
        NewClient->Token = Token;
        //
        //  Release the security fields
        //
        PspUnlockThreadSecurityExclusive (Thread, CurrentThread);

        PspWriteTebImpersonationInfo (Thread, CurrentThread);
    }

    //
    // Free the old client token, if necessary.
    //

    if (OldToken != NULL) {
        PsDereferenceImpersonationToken (OldToken);
    }


    return STATUS_SUCCESS;

}

BOOLEAN
PsDisableImpersonation(
    __inout PETHREAD Thread,
    __inout PSE_IMPERSONATION_STATE ImpersonationState
    )

/*++

Routine Description:

    This routine temporarily disables the impersonation of a thread.
    The impersonation state is saved for quick replacement later.  The
    impersonation token is left referenced and a pointer to it is held
    in the IMPERSONATION_STATE data structure.

    PsRestoreImpersonation() must be used after this routine is called.

Arguments:

    Thread - points to the thread whose impersonation (if any) is to
        be temporarily disabled.

    ImpersonationState - receives the current impersonation information,
        including a pointer to the impersonation token.


Return Value:

    TRUE - Indicates the impersonation state has been saved and the
        impersonation has been temporarily disabled.

    FALSE - Indicates the specified thread was not impersonating a client.
       No action has been taken.

--*/

{

    PPS_IMPERSONATION_INFORMATION OldClient;
    PETHREAD CurrentThread;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    //
    // Capture the impersonation information (if there is any).
    // The vast majority of cases this function is called we are not impersonating. Skip acquiring
    // the lock in this case.
    //

    OldClient = NULL;
    if (PS_IS_THREAD_IMPERSONATING (Thread)) {

        //
        //  Lock the process security fields
        //

        CurrentThread = PsGetCurrentThread ();
        PspLockThreadSecurityExclusive (Thread, CurrentThread);

        //
        // Test and clear the impersonation bit. If we are still impersonating then capture the info.
        //
        if (PS_TEST_CLEAR_BITS (&Thread->CrossThreadFlags,
                                PS_CROSS_THREAD_FLAGS_IMPERSONATING)&
                PS_CROSS_THREAD_FLAGS_IMPERSONATING) {

            OldClient = Thread->ImpersonationInfo;
            ImpersonationState->Level         = OldClient->ImpersonationLevel;
            ImpersonationState->EffectiveOnly = OldClient->EffectiveOnly;
            ImpersonationState->CopyOnOpen    = OldClient->CopyOnOpen;
            ImpersonationState->Token         = OldClient->Token;
        }

        //
        //  Release the security fields
        //

        PspUnlockThreadSecurityExclusive (Thread, CurrentThread);
    }

    if (OldClient != NULL) {
        return TRUE;

    } else {
        //
        // Not impersonating.  Just make up some values.
        // The NULL for the token indicates we aren't impersonating.
        //
        ImpersonationState->Level         = SecurityAnonymous;
        ImpersonationState->EffectiveOnly = FALSE;
        ImpersonationState->CopyOnOpen    = FALSE;
        ImpersonationState->Token         = NULL;
        return FALSE;
    }
}

VOID
PsRestoreImpersonation(
    __inout PETHREAD Thread,
    __in PSE_IMPERSONATION_STATE ImpersonationState
    )

/*++

Routine Description:

    This routine restores an impersonation that has been temporarily disabled
    using PsDisableImpersonation().

    Notice that if this routine finds the thread is already impersonating
    (again), then restoring the temporarily disabled impersonation will cause
    the current impersonation to be abandoned.



Arguments:

    Thread - points to the thread whose impersonation is to be restored.

    ImpersonationState - receives the current impersonation information,
        including a pointer ot the impersonation token.


Return Value:

    TRUE - Indicates the impersonation state has been saved and the
        impersonation has been temporarily disabled.

    FALSE - Indicates the specified thread was not impersonating a client.
       No action has been taken.

--*/

{

    PETHREAD CurrentThread;
    PACCESS_TOKEN OldToken;
    PPS_IMPERSONATION_INFORMATION ImpInfo;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    OldToken = NULL;

    //
    //  Lock the process security fields
    //

    CurrentThread = PsGetCurrentThread ();

    PspLockThreadSecurityExclusive (Thread, CurrentThread);

    ImpInfo = Thread->ImpersonationInfo;

    //
    // If the thread is currently impersonating then we must revert this
    //

    if (PS_IS_THREAD_IMPERSONATING (Thread)) {
        OldToken = ImpInfo->Token;
    }


    //
    // Restore the previous impersonation token if there was one
    //

    if (ImpersonationState->Token) {
        ImpInfo->ImpersonationLevel = ImpersonationState->Level;
        ImpInfo->EffectiveOnly      = ImpersonationState->EffectiveOnly;
        ImpInfo->CopyOnOpen         = ImpersonationState->CopyOnOpen;
        ImpInfo->Token              = ImpersonationState->Token;
        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
    } else {
        PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
    }

    //
    //  Release the security fields
    //

    PspUnlockThreadSecurityExclusive (Thread, CurrentThread);

    if (OldToken != NULL) {
        ObDereferenceObject (OldToken);
    }

    return;

}


VOID
PsRevertToSelf( )

/*++

Routine Description:

    This routine causes the calling thread to discontinue
    impersonating a client.  If the thread is not currently
    impersonating a client, no action is taken.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PETHREAD Thread;
    PEPROCESS Process;
    PACCESS_TOKEN OldToken;

    PAGED_CODE();

    Thread = PsGetCurrentThread ();
    Process = THREAD_TO_PROCESS (Thread);

    //
    //  Lock the process security fields
    //
    PspLockThreadSecurityExclusive (Thread, Thread);

    //
    //  See if the thread is impersonating a client
    //  and dereference that token if so.
    //

    if (PS_IS_THREAD_IMPERSONATING (Thread)) {
        PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
        OldToken = Thread->ImpersonationInfo->Token;
    } else {
        OldToken = NULL;
    }

    //
    //  Release the security fields
    //
    PspUnlockThreadSecurityExclusive (Thread, Thread);


    //
    // Free the old client info...
    //
    if (OldToken != NULL) {
        ObDereferenceObject (OldToken);

        PspWriteTebImpersonationInfo (Thread, Thread);
    }

    return;
}

VOID
PsRevertThreadToSelf (
    __inout PETHREAD Thread
    )

/*++

Routine Description:

    This routine causes the specified thread to discontinue
    impersonating a client. If the thread is not currently
    impersonating a client, no action is taken.

Arguments:

    Thread - Thread to remove impersonation from

Return Value:

    None.

--*/

{

    PETHREAD CurrentThread;
    PACCESS_TOKEN OldToken;
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    if (PS_IS_THREAD_IMPERSONATING (Thread)) {

        CurrentThread = PsGetCurrentThread ();

        //
        //  Lock the process security fields
        //

        PspLockThreadSecurityExclusive (Thread, CurrentThread);

        //
        //  See if the thread is impersonating a client
        //  and dereference that token if so.
        //

        if (PS_IS_THREAD_IMPERSONATING (Thread)) {

            //
            // Grab impersonation info block.
            //

            ImpersonationInfo = Thread->ImpersonationInfo;

            PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
            OldToken = ImpersonationInfo->Token;

        } else {
            OldToken = NULL;
        }

        //
        //  Release the security fields
        //

        PspUnlockThreadSecurityExclusive (Thread, CurrentThread);

        //
        // Free the old client info...
        //

        if (OldToken != NULL) {
            ObDereferenceObject (OldToken);
            PspWriteTebImpersonationInfo (Thread, CurrentThread);
        }
    }

    return;
}


NTSTATUS
PspInitializeProcessSecurity(
    IN PEPROCESS Parent OPTIONAL,
    IN PEPROCESS Child
    )

/*++

Routine Description:

    This function initializes a new process's security fields, including
    the assignment of a new primary token.

    The child process is assumed to not yet have been inserted into
    an object table.

    NOTE: IT IS EXPECTED THAT THIS SERVICE WILL BE CALLED WITH A NULL
          PARENT PROCESS POINTER EXACTLY ONCE - FOR THE INITIAL SYSTEM
          PROCESS.


Arguments:

    Parent - An optional pointer to the process being used as the parent
        of the new process.  If this value is NULL, then the process is
        assumed to be the initial system process, and the boot token is
        assigned rather than a duplicate of the parent process's primary
        token.

    Child - Supplies the address of the process being initialized.  This
        process does not yet require security field contention protection.
        In particular, the security fields may be accessed without first
        acquiring the process security fields lock.



Return Value:


--*/

{
    NTSTATUS Status;
    PACCESS_TOKEN ParentToken, NewToken;

    PAGED_CODE();

    //
    // Assign the primary token
    //

    if (ARGUMENT_PRESENT (Parent)) {

        //
        // create the primary token
        // This is a duplicate of the parent's token.
        //
        ParentToken = PsReferencePrimaryToken (Parent);

        Status = SeSubProcessToken (ParentToken,
                                    &NewToken,
                                    TRUE,
                                    MmGetSessionId (Child));

        PsDereferencePrimaryTokenEx (Parent, ParentToken);

        if (NT_SUCCESS(Status)) {
            ObInitializeFastReference (&Child->Token,
                                       NewToken);
        }

    } else {

        //
        //  Reference and assign the boot token
        //
        //  The use of a single boot access token assumes there is
        //  exactly one parentless process in the system - the initial
        //  process.  If this ever changes, this code will need to change
        //  to match the new condition (so that a token doesn't end up
        //  being shared by multiple processes.
        //

        ObInitializeFastReference (&Child->Token, NULL);
        SeAssignPrimaryToken (Child, PspBootAccessToken);
        Status = STATUS_SUCCESS;


    }

    return Status;

}

VOID
PspDeleteProcessSecurity(
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This function cleans up a process's security fields as part of process
    deletion.  It is assumed no other references to the process can occur
    during or after a call to this routine.  This enables us to reference
    the process security fields without acquiring the lock protecting those
    fields.

    NOTE: It may be desirable to add auditing capability to this routine
          at some point.


Arguments:

    Process - A pointer to the process being deleted.


Return Value:

    None.

--*/

{

    PAGED_CODE();


    //
    // If we are deleting a process that didn't successfully complete
    // process initialization, then there may be no token associated
    // with it yet.
    //

    if (!ExFastRefObjectNull (Process->Token)) {
        SeDeassignPrimaryToken (Process);
    }

    return;
}


NTSTATUS
PspAssignPrimaryToken(
    IN PEPROCESS Process,
    IN HANDLE Token OPTIONAL,
    IN PACCESS_TOKEN TokenPointer OPTIONAL
    )

/*++

Routine Description:

    This function performs the security portions of primary token assignment.
    It is expected that the proper access to the process and thread objects,
    as well as necessary privilege, has already been established.

    A primary token can only be replaced if the process has no threads, or
    has one thread.  This is because the thread objects point to the primary
    token and must have those pointers updated when the primary token is
    changed.  This is only expected to be necessary at logon time, when
    the process is in its infancy and either has zero threads or maybe one
    inactive thread.

    If the assignment is successful, the old token is dereferenced and the
    new one is referenced.



Arguments:

    Process - A pointer to the process whose primary token is being
        replaced.

    Token - The handle value of the token to be assigned as the primary
        token.


Return Value:

    STATUS_SUCCESS - Indicates the primary token has been successfully
        replaced.

    STATUS_BAD_TOKEN_TYPE - Indicates the token is not of type TokenPrimary.

    STATUS_TOKEN_IN_USE - Indicates the token is already in use by
        another process.

    Other status may be returned when attempting to reference the token
    object.

--*/

{
    NTSTATUS Status;
    PACCESS_TOKEN NewToken, OldToken;
    KPROCESSOR_MODE PreviousMode;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    if (TokenPointer == NULL) {
        PreviousMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

        //
        // Reference the specified token, and make sure it can be assigned
        // as a primary token.
        //

        Status = ObReferenceObjectByHandle (Token,
                                            TOKEN_ASSIGN_PRIMARY,
                                            SeTokenObjectType,
                                            PreviousMode,
                                            &NewToken,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    } else {
        NewToken = TokenPointer;
    }


    //
    // This routine makes sure the NewToken is suitable for assignment
    // as a primary token.
    //

    Status = SeExchangePrimaryToken (Process, NewToken, &OldToken);


    //
    // Acquire and release the process security lock to force any slow
    // referencers out of the slow path.
    //

    PspLockProcessSecurityExclusive (Process, CurrentThread);
    PspUnlockProcessSecurityExclusive (Process, CurrentThread);

    //
    // Free the old token (we don't need it).
    // This can't be done while the security fields are locked.
    //

    if (NT_SUCCESS (Status)) {
        ObDereferenceObject (OldToken);
    }

    //
    // Undo the handle reference
    //

    if (TokenPointer == NULL) {
        ObDereferenceObject (NewToken);
    }


    return Status;
}


VOID
PspInitializeThreadSecurity(
    IN PEPROCESS Process,
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This function initializes a new thread's security fields.


Arguments:

    Process - Points to the process the thread belongs to.

    Thread - Points to the thread object being initialized.


Return Value:

    None.

--*/

{

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Process);
    //
    // Initially not impersonating anyone. This is not currently called as we zero out the entire thread at create time anyway
    //

    Thread->ImpersonationInfo = NULL;
    PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);

    return;

}


VOID
PspDeleteThreadSecurity(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This function cleans up a thread's security fields as part of thread
    deletion.  It is assumed no other references to the thread can occur
    during or after a call to this routine, so no locking is necessary
    to access the thread security fields.


Arguments:

    Thread - A pointer to the thread being deleted.


Return Value:

    None.

--*/

{
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    PAGED_CODE();

    ImpersonationInfo = Thread->ImpersonationInfo;
    //
    // clean-up client information, if there is any.
    //
    if (PS_IS_THREAD_IMPERSONATING (Thread)) {
        ObDereferenceObject (ImpersonationInfo->Token);
    }

    if (ImpersonationInfo != NULL) {
        ExFreePoolWithTag (ImpersonationInfo, 'mIsP'|PROTECTED_POOL);
        PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
        Thread->ImpersonationInfo = NULL;
    }

    return;

}

NTSTATUS
PspWriteTebImpersonationInfo (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
/*++

Routine Description:

    This function updates the thread TEB fields to reflect the impersonation status
    of the thread.


Arguments:

    Thread - A pointer to the thread whose impersonation token has been changed

    CurrentThread - The current thread

Return Value:

    NTSTATUS - Status of operation

--*/
{
    PTEB Teb;
    BOOLEAN  AttachedToProcess = FALSE;
    PEPROCESS ThreadProcess;
    BOOLEAN Impersonating;
    KAPC_STATE ApcState;

    PAGED_CODE();

    ASSERT (CurrentThread == PsGetCurrentThread ());

    ThreadProcess = THREAD_TO_PROCESS (Thread);

    Teb = Thread->Tcb.Teb;

    if (Teb != NULL) {
        if (PsGetCurrentProcessByThread (CurrentThread) != ThreadProcess) {
            KeStackAttachProcess (&ThreadProcess->Pcb, &ApcState);
            AttachedToProcess = TRUE;
        }

        //
        // We are doing a cross thread TEB reference here. Protect against the TEB being freed and used by
        // somebody else.
        //
        if (Thread == CurrentThread || ExAcquireRundownProtection (&Thread->RundownProtect)) {

            while (1) {

                Impersonating = (BOOLEAN) PS_IS_THREAD_IMPERSONATING (Thread);

                //
                // The TEB may still raise an exception in low memory conditions so we need try/except here
                //

                try {
                    if (Impersonating) {
                        Teb->ImpersonationLocale = (LCID)-1;
                        Teb->IsImpersonating = 1;
                    } else {
                        Teb->ImpersonationLocale = (LCID) 0;
                        Teb->IsImpersonating = 0;
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                }

                KeMemoryBarrier ();

                if (Impersonating == (BOOLEAN) PS_IS_THREAD_IMPERSONATING (Thread)) {
                    break;
                }

            }

            if (Thread != CurrentThread) {
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }
        }

        if (AttachedToProcess) {
            KeUnstackDetachProcess (&ApcState);
        }
    }
    return STATUS_SUCCESS;
}



NTSTATUS
PsAssignImpersonationToken(
    __in PETHREAD Thread,
    __in HANDLE Token
    )

/*++

Routine Description:

    This function performs the security portions of establishing an
    impersonation token.  This routine is expected to be used only in
    the case where the subject has asked for impersonation explicitly
    providing an impersonation token.  Other services are provided for
    use by communication session layers that need to establish an
    impersonation on a server's behalf.

    It is expected that the proper access to the thread object has already
    been established.

    The following rules apply:

         1) The caller must have TOKEN_IMPERSONATE access to the token
            for any action to be taken.

         2) If the token may NOT be used for impersonation (e.g., not an
            impersonation token) no action is taken.

         3) Otherwise, any existing impersonation token is dereferenced and
            the new token is established as the impersonation token.



Arguments:

    Thread - A pointer to the thread whose impersonation token is being
        set.

    Token - The handle value of the token to be assigned as the impersonation
        token.  If this value is NULL, then current impersonation (if any)
        is terminated and no new impersonation is established.


Return Value:

    STATUS_SUCCESS - Indicates the primary token has been successfully
        replaced.

    STATUS_BAD_TOKEN_TYPE - Indicates the token is not of type
        TokenImpersonation.

    Other status may be returned when attempting to reference the token
    object.

--*/

{
    NTSTATUS Status;
    PACCESS_TOKEN NewToken;
    KPROCESSOR_MODE PreviousMode;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    if (!ARGUMENT_PRESENT (Token)) {

        PsRevertThreadToSelf (Thread);

        Status = STATUS_SUCCESS;
    } else {

        PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

        //
        // Reference the specified token for TOKEN_IMPERSONATE access
        //

        Status = ObReferenceObjectByHandle (Token,
                                            TOKEN_IMPERSONATE,
                                            SeTokenObjectType,
                                            PreviousMode,
                                            &NewToken,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        //
        // Make sure the token is an impersonation token.
        //

        if (SeTokenType (NewToken) != TokenImpersonation) {
            ObDereferenceObject (NewToken);
            return STATUS_BAD_TOKEN_TYPE;
        }

        ImpersonationLevel = SeTokenImpersonationLevel (NewToken);

        //
        // The rest can be done by PsImpersonateClient.
        //
        // PsImpersonateClient will reference the passed token
        // on success.
        //

        Status = PsImpersonateClient (Thread,
                                      NewToken,
                                      FALSE,          // CopyOnOpen
                                      FALSE,          // EffectiveOnly
                                      ImpersonationLevel);


        //
        // Dereference the passed token.
        //
        //

        ObDereferenceObject (NewToken);
    }

    return Status;
}

#undef PsDereferencePrimaryToken

#pragma alloc_text(PAGE, PsDereferencePrimaryToken)

VOID
PsDereferencePrimaryToken(
    __in PACCESS_TOKEN PrimaryToken
    )
/*++

Routine Description:

    Returns the reference obtained via PsReferencePrimaryToken

Arguments:

    Returns the reference

Return Value:

    None.

--*/
{
    PAGED_CODE();

    ObDereferenceObject (PrimaryToken);
}

#undef PsDereferenceImpersonationToken

#pragma alloc_text(PAGE, PsDereferenceImpersonationToken)

VOID
PsDereferenceImpersonationToken(
    __in PACCESS_TOKEN ImpersonationToken
    )
/*++

Routine Description:

    Returns the reference obtained via PsReferenceImpersonationToken

Arguments:

    Returns the reference

Return Value:

    None.


--*/
{
    PAGED_CODE();

    if (ImpersonationToken != NULL) {
        ObDereferenceObject (ImpersonationToken);
    }
}

LOGICAL
PspSinglePrivCheck (
    IN LUID PrivilegeValue,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PPRIV_CHECK_CTX PrivCtx
    )
/*++

Routine Description:

    Releases previous security context if it was captured and audits if the privilege was used.

Arguments:

    PrivilegeValue - The value of the privilege being checked.

    PreviousMode - Previous mode of caller

    PrivCtx - Stored context to enable auditing if needed

Return Value:

    LOGICAL - If access was granted then TRUE otherwise FALSE

--*/
{
    PrivCtx->PreviousMode = PreviousMode;

    if (PreviousMode != KernelMode) {
        PrivCtx->RequiredPrivileges.PrivilegeCount = 1;
        PrivCtx->RequiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
        PrivCtx->RequiredPrivileges.Privilege[0].Luid = PrivilegeValue; 
        PrivCtx->RequiredPrivileges.Privilege[0].Attributes = 0;


        SeCaptureSubjectContext (&PrivCtx->SubjectSecurityContext);

        PrivCtx->AccessGranted = SePrivilegeCheck (&PrivCtx->RequiredPrivileges,
                                                   &PrivCtx->SubjectSecurityContext,
                                                   PreviousMode);
        return PrivCtx->AccessGranted;
    } else {
        return TRUE;
    }
}

VOID
PspSinglePrivCheckAudit (
    IN LOGICAL PrivUsed,
    IN PPRIV_CHECK_CTX PrivCtx
    )
/*++

Routine Description:

    Releases previous security context if it was captured and audits if the privilege was used.

Arguments:

    PrivUsed - TRUE if the caller actualy used the privilege, FALSE otherwise

    PrivCtx - Output from a previous call to PspSinglePrivCheck

Return Value:

    None.

--*/
{
    if (PrivCtx->PreviousMode != KernelMode) {
        if (PrivUsed) {

            SePrivilegedServiceAuditAlarm (NULL,
                                           &PrivCtx->SubjectSecurityContext,
                                           &PrivCtx->RequiredPrivileges,
                                           PrivCtx->AccessGranted);
        }

        SeReleaseSubjectContext (&PrivCtx->SubjectSecurityContext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\amd64\psctxamd64.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psctx.c

Abstract:

    This procedure implements Get/Set Context Thread

--*/

#include "psp.h"

//
// Define context exception flags.
//

#define CONTEXT_EXCEPTION_FLAGS (CONTEXT_EXCEPTION_ACTIVE | CONTEXT_SERVICE_ACTIVE)

//
// Define forward referenced functions.
//

PXMM_SAVE_AREA32
PspGetSetContextInternal (
    IN PKAPC Apc,
    IN PVOID OperationType,
    OUT PKEVENT *Event
    );

#pragma alloc_text(PAGE, PspGetContext)
#pragma alloc_text(PAGE, PspGetSetContextInternal)
#pragma alloc_text(PAGE, PspSetContext)

VOID
PspGetContext (
    IN PKTRAP_FRAME TrapFrame,
    IN PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function selectively moves the contents of the specified trap frame
    and nonvolatile context to the specified context record.

Arguments:

    TrapFrame - Supplies the contents of a trap frame.

    ContextPointers - Supplies the address of context pointers record.

    ContextRecord - Supplies the address of a context record.

Return Value:

    None.

--*/

{

    ULONG ContextFlags;

    PAGED_CODE();

    //
    // Get control information if specified.
    //

    ContextFlags = ContextRecord->ContextFlags;
    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers RIP, CS, RSP, SS, and EFlags.
        //

        ContextRecord->Rip = TrapFrame->Rip;
        ContextRecord->SegCs = TrapFrame->SegCs;
        ContextRecord->SegSs = TrapFrame->SegSs;
        ContextRecord->Rsp = TrapFrame->Rsp;
        ContextRecord->EFlags = TrapFrame->EFlags;
    }

    //
    // Get segment register contents if specified.
    //

    if ((ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

        //
        // Set segment registers GS, FS, ES, DS.
        //

        ContextRecord->SegDs = KGDT64_R3_DATA | RPL_MASK;
        ContextRecord->SegEs = KGDT64_R3_DATA | RPL_MASK;
        ContextRecord->SegFs = KGDT64_R3_CMTEB | RPL_MASK;
        ContextRecord->SegGs = KGDT64_R3_DATA | RPL_MASK;
    }

    //
    //  Get integer register contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
        // RBP, R11, R12, R13, R14, and R15.
        //

        ContextRecord->Rax = TrapFrame->Rax;
        ContextRecord->Rcx = TrapFrame->Rcx;
        ContextRecord->Rdx = TrapFrame->Rdx;
        ContextRecord->R8 = TrapFrame->R8;
        ContextRecord->R9 = TrapFrame->R9;
        ContextRecord->R10 = TrapFrame->R10;
        ContextRecord->R11 = TrapFrame->R11;

        ContextRecord->Rbx = *ContextPointers->Rbx;
        ContextRecord->Rbp = *ContextPointers->Rbp;
        ContextRecord->Rsi = *ContextPointers->Rsi;
        ContextRecord->Rdi = *ContextPointers->Rdi;
        ContextRecord->R12 = *ContextPointers->R12;
        ContextRecord->R13 = *ContextPointers->R13;
        ContextRecord->R14 = *ContextPointers->R14;
        ContextRecord->R15 = *ContextPointers->R15;
    }

    //
    // Get floating point context if specified.
    //

    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
        //
        // N.B. The legacy floating state is handled separately.
        //

        ContextRecord->Xmm0 = TrapFrame->Xmm0;
        ContextRecord->Xmm1 = TrapFrame->Xmm1;
        ContextRecord->Xmm2 = TrapFrame->Xmm2;
        ContextRecord->Xmm3 = TrapFrame->Xmm3;
        ContextRecord->Xmm4 = TrapFrame->Xmm4;
        ContextRecord->Xmm5 = TrapFrame->Xmm5;

        ContextRecord->Xmm6 = *ContextPointers->Xmm6;
        ContextRecord->Xmm7 = *ContextPointers->Xmm7;
        ContextRecord->Xmm8 = *ContextPointers->Xmm8;
        ContextRecord->Xmm9 = *ContextPointers->Xmm9;
        ContextRecord->Xmm10 = *ContextPointers->Xmm10;
        ContextRecord->Xmm11 = *ContextPointers->Xmm11;
        ContextRecord->Xmm12 = *ContextPointers->Xmm12;
        ContextRecord->Xmm13 = *ContextPointers->Xmm13;
        ContextRecord->Xmm14 = *ContextPointers->Xmm14;
        ContextRecord->Xmm15 = *ContextPointers->Xmm15;

        ContextRecord->MxCsr = TrapFrame->MxCsr;
    }

    //
    //
    // Get debug register contents if requested.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        //
        // Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
        //

        if ((TrapFrame->Dr7 & DR7_ACTIVE) != 0) {
            ContextRecord->Dr0 = TrapFrame->Dr0;
            ContextRecord->Dr1 = TrapFrame->Dr1;
            ContextRecord->Dr2 = TrapFrame->Dr2;
            ContextRecord->Dr3 = TrapFrame->Dr3;
            ContextRecord->Dr6 = TrapFrame->Dr6;
            ContextRecord->Dr7 = TrapFrame->Dr7;
            if ((TrapFrame->Dr7 & DR7_LAST_BRANCH) != 0) {
                ContextRecord->LastBranchToRip = TrapFrame->LastBranchToRip;
                ContextRecord->LastBranchFromRip = TrapFrame->LastBranchFromRip;
                ContextRecord->LastExceptionToRip = TrapFrame->LastExceptionToRip;
                ContextRecord->LastExceptionFromRip = TrapFrame->LastExceptionFromRip;

            } else {
                ContextRecord->LastBranchToRip = 0;
                ContextRecord->LastBranchFromRip = 0;
                ContextRecord->LastExceptionToRip = 0;
                ContextRecord->LastExceptionFromRip = 0;
            }

        } else {
            ContextRecord->Dr0 = 0;
            ContextRecord->Dr1 = 0;
            ContextRecord->Dr2 = 0;
            ContextRecord->Dr3 = 0;
            ContextRecord->Dr6 = 0;
            ContextRecord->Dr7 = 0;
            ContextRecord->LastBranchToRip = 0;
            ContextRecord->LastBranchFromRip = 0;
            ContextRecord->LastExceptionToRip = 0;
            ContextRecord->LastExceptionFromRip = 0;
        }
    }

    //
    // Get exception reporting information if requested.
    //

    if ((ContextFlags & CONTEXT_EXCEPTION_REQUEST) != 0) {
        ContextRecord->ContextFlags &= ~CONTEXT_EXCEPTION_FLAGS;
        ContextRecord->ContextFlags |= CONTEXT_EXCEPTION_REPORTING;
        if (TrapFrame->ExceptionActive == 1) {
            ContextRecord->ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;
    
        } else if (TrapFrame->ExceptionActive == 2) {
            ContextRecord->ContextFlags |= CONTEXT_SERVICE_ACTIVE;
        }
    }

    return;
}

VOID
PspSetContext (
    OUT PKTRAP_FRAME TrapFrame,
    OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
    IN PCONTEXT ContextRecord,
    KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This function selectively moves the contents of the specified context
    record to the specified trap frame and nonvolatile context.

Arguments:

    TrapFrame - Supplies the address of a trap frame.

    ContextPointers - Supplies the address of a context pointers record.

    ContextRecord - Supplies the address of a context record.

    ProcessorMode - Supplies the processor mode to use when sanitizing
        the PSR and FSR.

Return Value:

    None.

--*/

{

    ULONG ContextFlags;

    PAGED_CODE();

    //
    // Set control information if specified.
    //

    ContextFlags = ContextRecord->ContextFlags;
    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
        TrapFrame->EFlags = SANITIZE_EFLAGS(ContextRecord->EFlags, PreviousMode);
        TrapFrame->Rip = ContextRecord->Rip;
        TrapFrame->Rsp = ContextRecord->Rsp;
    }

    //
    // The segment registers DS, ES, FS, and GS are never restored from saved
    // data. However, SS and CS are restored from the trap frame. Make sure
    // that these segment registers have the proper values.
    //

    if (PreviousMode == UserMode) {
        TrapFrame->SegSs = KGDT64_R3_DATA | RPL_MASK;
        if (ContextRecord->SegCs != (KGDT64_R3_CODE | RPL_MASK)) {
            TrapFrame->SegCs = KGDT64_R3_CMCODE | RPL_MASK;

        } else {
            TrapFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;
        }

    } else {
        TrapFrame->SegCs = KGDT64_R0_CODE;
        TrapFrame->SegSs = KGDT64_NULL;
    }

    TrapFrame->Rip = SANITIZE_VA(TrapFrame->Rip, TrapFrame->SegCs, PreviousMode);

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
        // RBP, R11, R12, R13, R14, and R15.
        //

        TrapFrame->Rax = ContextRecord->Rax;
        TrapFrame->Rcx = ContextRecord->Rcx;
        TrapFrame->Rdx = ContextRecord->Rdx;
        TrapFrame->R8 = ContextRecord->R8;
        TrapFrame->R9 = ContextRecord->R9;
        TrapFrame->R10 = ContextRecord->R10;
        TrapFrame->R11 = ContextRecord->R11;

        *ContextPointers->Rbx = ContextRecord->Rbx;
        *ContextPointers->Rbp = ContextRecord->Rbp;
        *ContextPointers->Rsi = ContextRecord->Rsi;
        *ContextPointers->Rdi = ContextRecord->Rdi;
        *ContextPointers->R12 = ContextRecord->R12;
        *ContextPointers->R13 = ContextRecord->R13;
        *ContextPointers->R14 = ContextRecord->R14;
        *ContextPointers->R15 = ContextRecord->R15;
    }

    //
    // Set floating register contents if requested.
    //

    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
        //
        // N.B. The legacy floating state is handled separately.
        //

        TrapFrame->Xmm0 = ContextRecord->Xmm0;
        TrapFrame->Xmm1 = ContextRecord->Xmm1;
        TrapFrame->Xmm2 = ContextRecord->Xmm2;
        TrapFrame->Xmm3 = ContextRecord->Xmm3;
        TrapFrame->Xmm4 = ContextRecord->Xmm4;
        TrapFrame->Xmm5 = ContextRecord->Xmm5;

        *ContextPointers->Xmm6 = ContextRecord->Xmm6;
        *ContextPointers->Xmm7 = ContextRecord->Xmm7;
        *ContextPointers->Xmm8 = ContextRecord->Xmm8;
        *ContextPointers->Xmm9 = ContextRecord->Xmm9;
        *ContextPointers->Xmm10 = ContextRecord->Xmm10;
        *ContextPointers->Xmm11 = ContextRecord->Xmm11;
        *ContextPointers->Xmm12 = ContextRecord->Xmm12;
        *ContextPointers->Xmm13 = ContextRecord->Xmm13;
        *ContextPointers->Xmm14 = ContextRecord->Xmm14;
        *ContextPointers->Xmm15 = ContextRecord->Xmm15;

        //
        // Clear all reserved bits in MXCSR.
        //

        TrapFrame->MxCsr = SANITIZE_MXCSR(ContextRecord->MxCsr);

        //
        // Clear all reserved bits in legacy floating state.
        //
        // N.B. The legacy floating state is restored if and only if the
        //      request mode is user.
        //
        // N.B. The current MXCSR value is placed in the legacy floating
        //      state so it will get restored if the legacy state is
        //      restored.
        //

        ContextRecord->FltSave.MxCsr = ReadMxCsr();
        ContextRecord->FltSave.ControlWord =
                            SANITIZE_FCW(ContextRecord->FltSave.ControlWord);
    }

    //
    // Set debug register state if specified.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        //
        // Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
        //

        TrapFrame->Dr0 = SANITIZE_DRADDR(ContextRecord->Dr0, PreviousMode);
        TrapFrame->Dr1 = SANITIZE_DRADDR(ContextRecord->Dr1, PreviousMode);
        TrapFrame->Dr2 = SANITIZE_DRADDR(ContextRecord->Dr2, PreviousMode);
        TrapFrame->Dr3 = SANITIZE_DRADDR(ContextRecord->Dr3, PreviousMode);
        TrapFrame->Dr6 = 0;
        TrapFrame->Dr7 = SANITIZE_DR7(ContextRecord->Dr7, PreviousMode);
        if (PreviousMode != KernelMode) {
            KeGetCurrentThread()->Header.DebugActive =
                                (BOOLEAN)((TrapFrame->Dr7 & DR7_ACTIVE) != 0);
        }
    }

    return;
}

PXMM_SAVE_AREA32
PspGetSetContextInternal (
    IN PKAPC Apc,
    IN PVOID OperationType,
    OUT PKEVENT *Event
    )

/*++

Routine Description:

    This function either captures the state of the current thread, or sets
    the state of the current thread.

Arguments:

    Apc - Supplies a pointer to an APC object.

    OperationType - Supplies the type of context operation to be performed.
        A value of NULL specifies a get context operation and a nonNULL value
        a set context operation.

    Event - Supplies a pointer to a variable that receives the completion
        event address.

Return Value:

    If the context operation is a set context and the legacy floating state is
    switched for the current thread, then the address of the legacy floating
    save area is returned as the function value. Otherwise, NULL is returned.

--*/

{

    PGETSETCONTEXT ContextBlock;
    ULONG ContextFlags;
    PKNONVOLATILE_CONTEXT_POINTERS ContextPointers;
    CONTEXT ContextRecord;
    ULONG64 ControlPc;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 ImageBase;
    PETHREAD Thread;
    ULONG64 TrapFrame;
    PXMM_SAVE_AREA32 XmmSaveArea;

    PAGED_CODE();

    //
    // Get the address of the context block and compute the address of the
    // system entry trap frame.
    //

    ContextBlock = CONTAINING_RECORD(Apc, GETSETCONTEXT, Apc);
    ContextPointers = &ContextBlock->NonVolatileContext;
    EstablisherFrame = 0;
    Thread = PsGetCurrentThread();
    TrapFrame = 0;
    if (ContextBlock->Mode == KernelMode) {
        TrapFrame = (ULONG64)Thread->Tcb.TrapFrame;
    }

    if (TrapFrame == 0) {
        TrapFrame = (ULONG64)PspGetBaseTrapFrame(Thread);
    }

    //
    // Capture the current thread context and set the initial control PC
    // value.
    //

    RtlCaptureContext(&ContextRecord);

    //
    // Initialize context pointers for the nonvolatile integer and floating
    // registers.
    //

#if DBG

    RtlZeroMemory(ContextPointers, sizeof(KNONVOLATILE_CONTEXT_POINTERS));

#endif

    ContextPointers->Rbx = &ContextRecord.Rbx;
    ContextPointers->Rsp = &ContextRecord.Rsp;
    ContextPointers->Rbp = &ContextRecord.Rbp;
    ContextPointers->Rsi = &ContextRecord.Rsi;
    ContextPointers->Rdi = &ContextRecord.Rdi;
    ContextPointers->R12 = &ContextRecord.R12;
    ContextPointers->R13 = &ContextRecord.R13;
    ContextPointers->R14 = &ContextRecord.R14;
    ContextPointers->R15 = &ContextRecord.R15;

    ContextPointers->Xmm6 = &ContextRecord.Xmm6;
    ContextPointers->Xmm7 = &ContextRecord.Xmm7;
    ContextPointers->Xmm8 = &ContextRecord.Xmm8;
    ContextPointers->Xmm9 = &ContextRecord.Xmm9;
    ContextPointers->Xmm10 = &ContextRecord.Xmm10;
    ContextPointers->Xmm11 = &ContextRecord.Xmm11;
    ContextPointers->Xmm12 = &ContextRecord.Xmm12;
    ContextPointers->Xmm13 = &ContextRecord.Xmm13;
    ContextPointers->Xmm14 = &ContextRecord.Xmm14;
    ContextPointers->Xmm15 = &ContextRecord.Xmm15;

    //
    // Start with the frame specified by the context record and virtually
    // unwind call frames until the system entry trap frame is encountered.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the function.
        //

        ControlPc = ContextRecord.Rip;
        FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, NULL);

        //
        // If there is a function table entry for the routine, then virtually
        // unwind to the caller of the current routine to obtain the address
        // where control left the caller. Otherwise, the function is a leaf
        // function and the return address register contains the address of
        // where control left the caller.
        //

        if (FunctionEntry != NULL) {
            RtlVirtualUnwind(UNW_FLAG_EHANDLER,
                             ImageBase,
                             ControlPc,
                             FunctionEntry,
                             &ContextRecord,
                             &HandlerData,
                             &EstablisherFrame,
                             ContextPointers);

        } else {
            ContextRecord.Rip = *(PULONG64)(ContextRecord.Rsp);
            ContextRecord.Rsp += 8;
        }

    } while (EstablisherFrame != TrapFrame);

    //
    // If system argument one is nonzero, then set the context of the current
    // thread. Otherwise, get the context of the current thread.
    //

    XmmSaveArea = NULL;
    if (OperationType != NULL) {

        //
        // Set context.
        //
        // If the context mode is user and floating state is being set, then
        // set the address of the legacy floating information.
        //

        ContextFlags = ContextBlock->Context.ContextFlags;
        if ((ContextBlock->Mode == UserMode) &&
            ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT)) {

            XmmSaveArea = &ContextBlock->Context.FltSave;
        }

        //
        // Set context.
        //

        PspSetContext((PKTRAP_FRAME)TrapFrame,
                      ContextPointers,
                      &ContextBlock->Context,
                      ContextBlock->Mode);

    } else {

        //
        // Get context.
        //
        // If the context mode is user, then save the legacy floating state.
        //
    
        if (ContextBlock->Mode == UserMode) {
            KeSaveLegacyFloatingPointState(&ContextBlock->Context.FltSave);
        }
    
        PspGetContext((PKTRAP_FRAME)TrapFrame,
                       ContextPointers,
                       &ContextBlock->Context);
    }

    *Event = &ContextBlock->OperationComplete;
    return XmmSaveArea;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\amd64\psctxwrap.asm ===
title  "Processor Type and Stepping Detection"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    psctxwrap.asm
;
; Abstract:
;
;    This module implements the code necessary to wrap the get/set thread
;    context functions so register state is correctly saved and restored.
;
;--

include ksamd64.inc

        extern  KeSetEvent:Proc
        extern  PspGetSetContextInternal:proc

;++
;
; VOID
; PspGetSetContextSpecialApc (
;     IN PKAPC Apc,
;     IN OUT PKNORMAL_ROUTINE *NormalRoutine,
;     IN OUT PVOID *NormalContext,
;     IN OUT PVOID *SystemArgument1,
;     IN OUT PVOID *SystemArgument2
;     );
;
; Routine Description:
;
;    This function saves and restore non-volatile state for the get/set
;    thread context functions.
;
; Arguments:
;
;    
;   rcx - Supplies a pointer to an APC object.
;
;   rdx - Supplies a pointer to the normal APC routine (not used).
;
;   r8 - Supplies a pointer to the normal Context (not used).
;
;   r9 - Supplies a pointer to the operation type.
;
;   40[rsp] - Supplies a pointer to the current thread (not used). 
;
; Return Value:
;
;    None.
;
;--

SaFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        SavedXmm6 db 16 dup (?)         ; saved nonvolatile floating registers
        SavedXmm7 db 16 dup (?)         ;
        SavedXmm8 db 16 dup (?)         ;
        SavedXmm9 db 16 dup (?)         ;
        SavedXmm10 db 16 dup (?)        ;
        SavedXmm11 db 16 dup (?)        ;
        SavedXmm12 db 16 dup (?)        ;
        SavedXmm13 db 16 dup (?)        ;
        SavedXmm14 db 16 dup (?)        ;
        SavedXmm15 db 16 dup (?)        ;
        SavedRbx dq ?                   ; saved nonvolatile integer registers
        SavedRbp dq ?                   ;
        SavedRsi dq ?                   ;
        SavedRdi dq ?                   ;
        SavedR12 dq ?                   ;
        SavedR13 dq ?                   ;
        SavedR14 dq ?                   ;
        SavedR15 dq ?                   ;
        Event    dq ?                   ; address of event to set
SaFrame ends

        NESTED_ENTRY PspGetSetContextSpecialApc, _TEXT$00

        alloc_stack (sizeof SaFrame)    ; allocate stack frame
        save_reg rbx, SaFrame.SavedRbx  ; save nonvolatile integer registers
        save_reg rbp, SaFrame.SavedRbp  ;
        save_reg rsi, SaFrame.SavedRsi  ;
        save_reg rdi, SaFrame.SavedRdi  ;
        save_reg r12, SaFrame.SavedR12  ;
        save_reg r13, SaFrame.SavedR13  ;
        save_reg r14, SaFrame.SavedR14  ;
        save_reg r15, SaFrame.SavedR15  ;
        save_xmm128 xmm6, SaFrame.SavedXmm6 ; save nonvolatile floating registers
        save_xmm128 xmm7, SaFrame.SavedXmm7 ;
        save_xmm128 xmm8, SaFrame.SavedXmm8 ;
        save_xmm128 xmm9, SaFrame.SavedXmm9 ;
        save_xmm128 xmm10, SaFrame.SavedXmm10 ;
        save_xmm128 xmm11, SaFrame.SavedXmm11 ;
        save_xmm128 xmm12, SaFrame.SavedXmm12 ;
        save_xmm128 xmm13, SaFrame.SavedXmm13 ;
        save_xmm128 xmm14, SaFrame.SavedXmm14 ;
        save_xmm128 xmm15, SaFrame.SavedXmm15 ;

        END_PROLOGUE

        mov     rdx, [r9]               ; get operation type
        lea     r8, SaFrame.Event[rsp]  ; get address to store event address
        mov     r9, dr7                 ; access debug register
        call    PspGetSetContextInternal ; get/set thread context
        test    rax, rax                ; test for legacy state restore
        jz      short GsCS10            ; if z, do not restore legacy state

;
; N.B. The following legacy restore also restores the nonvolatile floating
;      register xmm6-xmm15 with potentially incorrect values. Fortunately,
;      these registers are restored to their proper values chortly thereafter.
;

        fxrstor [rax]                   ; restore legacy floating state
GsCS10: mov     rcx, SaFrame.Event[rsp] ; set event address
        xor     edx, edx                ; set priority increment
        xor     r8d, r8d                ; set wait next
        call    KeSetEvent              ; set completion event
        mov     rbx, SaFrame.SavedRbx[rsp] ; restore nonvolatile integer registers
        mov     rbp, SaFrame.SavedRbp[rsp] ;
        mov     rsi, SaFrame.SavedRsi[rsp] ;
        mov     rdi, SaFrame.SavedRdi[rsp] ;
        mov     r12, SaFrame.SavedR12[rsp] ;
        mov     r13, SaFrame.SavedR13[rsp] ;
        mov     r14, SaFrame.SavedR14[rsp] ;
        mov     r15, SaFrame.SavedR15[rsp] ;
        movdqa  xmm6, SaFrame.SavedXmm6[rsp] ; restore nonvolatile floating registers
        movdqa  xmm7, SaFrame.SavedXmm7[rsp] ;
        movdqa  xmm8, SaFrame.SavedXmm8[rsp] ;
        movdqa  xmm9, SaFrame.SavedXmm9[rsp] ;
        movdqa  xmm10, SaFrame.SavedXmm10[rsp] ;
        movdqa  xmm11, SaFrame.SavedXmm11[rsp] ;
        movdqa  xmm12, SaFrame.SavedXmm12[rsp] ;
        movdqa  xmm13, SaFrame.SavedXmm13[rsp] ;
        movdqa  xmm14, SaFrame.SavedXmm14[rsp] ;
        movdqa  xmm15, SaFrame.SavedXmm15[rsp] ;
        add     rsp, (sizeof SaFrame)   ; deallocate stack frame
        ret                             ; return

        NESTED_END PspGetSetContextSpecialApc, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\amd64\psldt.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psldt.c

Abstract:

    This module contains AMD64 stubs for the process and thread ldt support.

--*/

#include "psp.h"

NTSTATUS
PspQueryLdtInformation (
    IN PEPROCESS Process,
    OUT PVOID LdtInformation,
    IN ULONG LdtInformationLength,
    OUT PULONG ReturnLength
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Process - Supplies a pointer to a executive process object.

    LdtInformation - Supplies a pointer to the information buffer.

    LdtInformationLength - Supplies the length of the information buffer.

    ReturnLength - Supplies a pointer to a variable that receives the number
        of bytes returned in the information buffer.

Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(LdtInformation);
    UNREFERENCED_PARAMETER(LdtInformationLength);
    UNREFERENCED_PARAMETER(ReturnLength);

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
PspSetLdtSize(
    IN PEPROCESS Process,
    IN PVOID LdtSize,
    IN ULONG LdtSizeLength
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Process -- Supplies a pointer to an executive process object.

    LdtSize -- Supplies a pointer to the LDT size information.

    LdtSizeLength - Supplies the length of the LDT size information.


Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{
    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(LdtSize);
    UNREFERENCED_PARAMETER(LdtSizeLength);

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
PspSetLdtInformation(
    IN PEPROCESS Process,
    IN PVOID LdtInformation,
    IN ULONG LdtInformationLength
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Process -- Supplies a pointer to an executive process object.

    LdtInformation -- Supplies a pointer to the information buffer.

    LdtInformationLength -- Supplies the length of the information buffer.

Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(LdtInformation);
    UNREFERENCED_PARAMETER(LdtInformationLength);

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
PspQueryDescriptorThread (
    PETHREAD Thread,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Thread - Supplies a pointer to an executive thread object.

    ThreadInformation - Supplies a pointer to the thread descriptor
        information.

    ThreadInformationLength - Supplies the length of the thread descriptor
        information.

    ReturnLength - Supplies a pointer to a variable that receives the number
        of bytes returned in the descriptor information buffer.

Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    UNREFERENCED_PARAMETER(Thread);
    UNREFERENCED_PARAMETER(ThreadInformation);
    UNREFERENCED_PARAMETER(ThreadInformationLength);
    UNREFERENCED_PARAMETER(ReturnLength);

    return STATUS_NOT_IMPLEMENTED;
}

VOID
PspDeleteLdt(
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Process -- Supplies a pointer to an executive process object.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Process);

    return;
}

NTSTATUS
NtSetLdtEntries(
    __in ULONG Selector0,
    __in ULONG Entry0Low,
    __in ULONG Entry0Hi,
    __in ULONG Selector1,
    __in ULONG Entry1Low,
    __in ULONG Entry1Hi
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Selector0 - Supplies the number of the first descriptor to set.

    Entry0Low - Supplies the low 32 bits of the descriptor.

    Entry0Hi - Supplies the high 32 bits of the descriptor.

    Selector1 - Supplies the number of the last descriptor to set.

    Entry1Low - Supplies the low 32 bits of the descriptor.

    Entry1Hi - Supplies the high 32 bits of the descriptor.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(Selector0);
    UNREFERENCED_PARAMETER(Entry0Low);
    UNREFERENCED_PARAMETER(Entry0Hi);
    UNREFERENCED_PARAMETER(Selector1);
    UNREFERENCED_PARAMETER(Entry1Low);
    UNREFERENCED_PARAMETER(Entry1Hi);

    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\amd64\psvdm.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psvdm.c

Abstract:

    This module contains mips stubs for the Io port handler support

--*/

#include "psp.h"


NTSTATUS
PspSetProcessIoHandlers(
    IN PEPROCESS Process,
    IN PVOID IoHandlerInformation,
    IN ULONG IoHandlerLength
    )
/*++

Routine Description:

    This routine returns STATUS_NOT_IMPLEMENTED

Arguments:

    Process -- Supplies a pointer to the process for which Io port handlers
        are to be installed
    IoHandlerInformation -- Supplies a pointer to the information about the
        io port handlers
    IoHandlerLength -- Supplies the length of the IoHandlerInformation
        structure.

Return Value:

    Returns STATUS_NOT_IMPLEMENTED

--*/
{
    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(IoHandlerInformation);
    UNREFERENCED_PARAMETER(IoHandlerLength);
    return STATUS_NOT_IMPLEMENTED;
}

VOID
PspDeleteVdmObjects(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This is a stub for the Vdm Objects delete routine

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

    None
--*/
{
    UNREFERENCED_PARAMETER(Process);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\i386\psvdm.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psvdm.c

Abstract:

    This module contains code for the io port handler support

--*/

#include "psp.h"


#if DBG
#define ASSERTEQUAL(value1, value2, string)     \
        if ((ULONG)value1 != (ULONG)value2) {   \
            DbgPrint string ;                   \
        }

#define ASSERTEQUALBREAK(value1, value2, string)\
        if ((ULONG)value1 != (ULONG)value2) {   \
            DbgPrint string ;                   \
            DbgBreakPoint();                    \
        }
#else

#define ASSERTEQUAL(value1, value2, string)
#define ASSERTEQUALBREAK(value1, value2, string)

#endif


//
// Internal functions
//

NTSTATUS
Psp386InstallIoHandler(
    IN PEPROCESS Process,
    IN PEMULATOR_ACCESS_ENTRY EmulatorAccessEntry,
    IN ULONG PortNumber,
    IN ULONG Context
    );

NTSTATUS
Psp386RemoveIoHandler(
    IN PEPROCESS Process,
    IN PEMULATOR_ACCESS_ENTRY EmulatorAccessEntry,
    IN ULONG PortNumber
    );

NTSTATUS
Psp386InsertVdmIoHandlerBlock(
    IN PEPROCESS Process,
    IN PVDM_IO_HANDLER VdmIoHandler
    );

PVDM_IO_HANDLER
Psp386GetVdmIoHandler(
    IN PEPROCESS Process,
    IN ULONG PortNumber
    );

NTSTATUS
Psp386CreateVdmIoListHead(
    IN PEPROCESS Process
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,PspVdmInitialize)
#pragma alloc_text(PAGE,PspSetProcessIoHandlers)
#pragma alloc_text(PAGE,Ps386GetVdmIoHandler)
#pragma alloc_text(PAGE,Psp386RemoveIoHandler)
#pragma alloc_text(PAGE,Psp386InstallIoHandler)
#pragma alloc_text(PAGE,Psp386CreateVdmIoListHead)
#pragma alloc_text(PAGE,Psp386InsertVdmIoHandlerBlock)
#pragma alloc_text(PAGE,Psp386GetVdmIoHandler)
#pragma alloc_text(PAGE,PspDeleteVdmObjects)
#endif


//
//  Resource to synchronize access to IoHandler list
//
ERESOURCE VdmIoListCreationResource;




NTSTATUS
PspSetProcessIoHandlers(
    IN PEPROCESS Process,
    IN PVOID IoHandlerInformation,
    IN ULONG IoHandlerLength
    )
/*++

Routine Description:

    This routine installs a device driver IO handling routine for the
    specified process.  If an io operation is detected in a vdm on a port
    that has a device driver IO handling routine, that routine will be called.

Arguments:

    Process -- Supplies a pointer to the process for which Io port handlers
        are to be installed
    IoHandlerInformation -- Supplies a pointer to the information about the
        io port handlers
    IoHandlerLength -- Supplies the length of the IoHandlerInformation
        structure.

Return Value:



--*/
{
    PPROCESS_IO_PORT_HANDLER_INFORMATION IoHandlerInfo;
    NTSTATUS Status;
    PEMULATOR_ACCESS_ENTRY EmulatorAccess;
    ULONG EmulatorEntryNumber, NumberPorts;
    ULONG PortSize;
    PAGED_CODE();

    //
    // Ensure that this call was made from KernelMode
    //
    if (KeGetPreviousMode () != KernelMode) {
        return STATUS_INVALID_PARAMETER;    // this info type invalid in usermode
    }
    //
    // Ensure that the data passed is long enough
    //
    if (IoHandlerLength < (ULONG)sizeof (PROCESS_IO_PORT_HANDLER_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }
    IoHandlerInfo = IoHandlerInformation;

    //
    // For each of the entries in the array that describes the handlers,
    // determine what size of port the specified handler is being installed
    // for, and then iterate over each individual port.
    //
    for (EmulatorEntryNumber = 0, EmulatorAccess =
            IoHandlerInfo->EmulatorAccessEntries;
        EmulatorEntryNumber < IoHandlerInfo->NumEntries;
        EmulatorEntryNumber++, EmulatorAccess++) {

            switch (EmulatorAccess->AccessType) {
            case Uchar:
                PortSize = 1;
                break;
            case Ushort:
                PortSize = 2;
                break;
            case Ulong:
            default:
                PortSize = 4;
            }

            for (NumberPorts = 0;
                NumberPorts < EmulatorAccess->NumConsecutivePorts;
                NumberPorts++) {
                    if (IoHandlerInfo->Install) {
                        Status = Psp386InstallIoHandler(
                            Process,
                            EmulatorAccess,
                            EmulatorAccess->BasePort + NumberPorts * PortSize,
                            IoHandlerInfo->Context
                            );
                        if (NT_SUCCESS(Status)) {
                        }
                    } else {
                        Status = Psp386RemoveIoHandler(
                            Process,
                            EmulatorAccess,
                            EmulatorAccess->BasePort + NumberPorts * PortSize
                            );
                    }
                    if (!NT_SUCCESS(Status)) {
                        goto exitloop;
                    }
            }
    }
    Status = STATUS_SUCCESS;
exitloop:
    return Status;

}


VOID
PspDeleteVdmObjects(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    Frees the VdmObjects structure and the Frees the IoHandler list

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

    None
--*/
{
    SIZE_T PoolQuota;
    PVDM_PROCESS_OBJECTS pVdmObjects;
    PVDM_IO_HANDLER p1, p2;
    PVDM_IO_LISTHEAD p3;
    PLIST_ENTRY  Next;
    PDELAYINTIRQ pDelayIntIrq;

    pVdmObjects = Process->VdmObjects;

    if (pVdmObjects == NULL)  {
        return;
    }

    //
    // First Free any port handler entries for this process,
    //
    p1 = NULL;
    p3 = pVdmObjects->VdmIoListHead;

    if (p3) {
        p2 = p3->VdmIoHandlerList;

        while (p2) {
            p1 = p2;
            p2 = p1->Next;
            ExFreePool( p1 );
        }

        ExDeleteResourceLite(&p3->VdmIoResource);

        ExFreePool( p3 );
        pVdmObjects->VdmIoListHead = NULL;
    }

    if (pVdmObjects->pIcaUserData) {
        PsReturnProcessPagedPoolQuota (Process,
                                       sizeof(VDMICAUSERDATA));

        ExFreePool(pVdmObjects->pIcaUserData);
    }

    //
    // Free up the DelayedIntList, spinlock protection is not needed because
    // object referencing on the process is being used instead.  Meaning there
    // can be no outstanding timers because the process object reference
    // count would have to be nonzero.
    //

    PoolQuota = 0;

    Next = pVdmObjects->DelayIntListHead.Flink;

    while (Next != &pVdmObjects->DelayIntListHead) {
        pDelayIntIrq = CONTAINING_RECORD(Next, DELAYINTIRQ, DelayIntListEntry);
        Next = Next->Flink;
        RemoveEntryList (&pDelayIntIrq->DelayIntListEntry);
        ExFreePool (pDelayIntIrq);
        PoolQuota += sizeof(DELAYINTIRQ);
    }

    if (PoolQuota != 0) {
        PsReturnProcessNonPagedPoolQuota(Process, PoolQuota);
    }

    PsReturnProcessNonPagedPoolQuota (Process, sizeof(VDM_PROCESS_OBJECTS));

    ExFreePool (pVdmObjects);

    Process->VdmObjects = NULL;
}



NTSTATUS
Psp386RemoveIoHandler(
    IN PEPROCESS Process,
    IN PEMULATOR_ACCESS_ENTRY EmulatorAccessEntry,
    IN ULONG PortNumber
    )
/*++

Routine Description:

    This routine remove a handler for a port.  On debug version, it will
    print a message if there is no handler.

Arguments:

    Process -- Supplies a pointer to the process
    EmulatorAccess -- Supplies a pointer to the information about the
        io port handler
    PortNumber -- Supplies the port number to remove the handler from.

Return Value:

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER VdmIoHandler;
    KIRQL OldIrql;
    PAGED_CODE();

    //
    // Ensure we have a vdm process which is initialized
    // correctly for VdmIoHandlers
    //
    if (!pVdmObjects) {
#if DBG
        DbgPrint("Psp386RemoveIoHandler: uninitialized VdmObjects\n");
#endif
        return STATUS_UNSUCCESSFUL;
    }


    //
    // If the list does not have a head, then there are no handlers to
    // remove.
    //
    if (!pVdmObjects->VdmIoListHead) {
#if DBG
        DbgPrint("Psp386RemoveIoHandler : attempt to remove non-existent hdlr\n");
#endif
        return STATUS_SUCCESS;
    }

    //
    // Lock the list, so we can ensure a correct update.
    //
    KeRaiseIrql(APC_LEVEL, &OldIrql);
    ExAcquireResourceExclusiveLite(&pVdmObjects->VdmIoListHead->VdmIoResource,TRUE);

    VdmIoHandler = Psp386GetVdmIoHandler(
        Process,
        PortNumber & ~0x3
        );

    if (!VdmIoHandler) {
#if DBG
        DbgPrint("Psp386RemoveIoHandler : attempt to remove non-existent hdlr\n");
#endif
        ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
        KeLowerIrql(OldIrql);
        return STATUS_SUCCESS;
    }

    ASSERTEQUALBREAK(
        VdmIoHandler->PortNumber,
        (PortNumber & ~0x3),
        ("Psp386RemoveIoHandler : Bad pointer returned from GetVdmIoHandler\n")
        );

    if (EmulatorAccessEntry->AccessMode & EMULATOR_READ_ACCESS) {
        switch (EmulatorAccessEntry->AccessType) {
        case Uchar:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UcharStringIo[PortNumber % 4],
                    ("Psp386RemoveIoHandler : UcharString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UcharStringIo[PortNumber % 4] = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UcharIo[PortNumber % 4],
                    ("Psp386RemoveIoHandler : Uchar fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UcharIo[PortNumber % 4] = NULL;
            }
            break;
        case Ushort:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UshortStringIo[(PortNumber & 2) >> 1],
                    ("Psp386RemoveIoHandler : UshortString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UshortStringIo[(PortNumber & 2) >> 1] = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UshortIo[(PortNumber & 2) >> 1],
                    ("Psp386RemoveIoHandler : Ushort fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UshortIo[(PortNumber & 2) >> 1] = NULL;
            }
            break;
        case Ulong:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UlongStringIo,
                    ("Psp386RemoveIoHandler : UlongString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UlongStringIo = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UlongIo,
                    ("Psp386RemoveIoHandler : Ulong fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UlongIo = NULL;
            }
            break;
        }
    }

    if (EmulatorAccessEntry->AccessMode & EMULATOR_WRITE_ACCESS) {
        switch (EmulatorAccessEntry->AccessType) {
        case Uchar:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UcharStringIo[PortNumber % 4],
                    ("Psp386RemoveIoHandler : UcharString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UcharStringIo[PortNumber % 4] = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UcharIo[PortNumber % 4],
                    ("Psp386RemoveIoHandler : Uchar fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UcharIo[PortNumber % 4] = NULL;
            }
            break;
        case Ushort:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UshortStringIo[(PortNumber & 2) >> 1],
                    ("Psp386RemoveIoHandler : UshortString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UshortStringIo[(PortNumber & 2) >> 1] = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UshortIo[(PortNumber & 2) >> 1],
                    ("Psp386RemoveIoHandler : Ushort fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UshortIo[(PortNumber & 2) >> 1] = NULL;
            }
            break;
        case Ulong:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UlongStringIo,
                    ("Psp386RemoveIoHandler : UlongString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UlongStringIo = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UlongIo,
                    ("Psp386RemoveIoHandler : Ulong fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UlongIo = NULL;
            }
            break;
        }
    }

    ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
    KeLowerIrql(OldIrql);

    return STATUS_SUCCESS;

}

NTSTATUS
Psp386InstallIoHandler(
    IN PEPROCESS Process,
    IN PEMULATOR_ACCESS_ENTRY EmulatorAccessEntry,
    IN ULONG PortNumber,
    IN ULONG Context
    )
/*++

Routine Description:

    This routine install a handler for a port.  On debug version, it will
    print a message if there is already a handler.

Arguments:

    Process -- Supplies a pointer to the process
    EmulatorAccess -- Supplies a pointer to the information about the
        io port handler
    PortNumber -- Supplies the port number to install the handler for.

Return Value:

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER VdmIoHandler;
    NTSTATUS Status;
    KIRQL    OldIrql;
    PAGED_CODE();


    //
    // Ensure we have a vdm process which is initialized
    // correctly for VdmIoHandlers
    //
    if (!pVdmObjects) {
#if DBG
        DbgPrint("Psp386InstallIoHandler: uninitialized VdmObjects\n");
#endif
        return STATUS_UNSUCCESSFUL;
    }


    Status = STATUS_SUCCESS;

    //
    // If this is the first handler to be installed, create the list head,
    // and initialize the resource lock.
    //
    if (!pVdmObjects->VdmIoListHead) {
        Status = Psp386CreateVdmIoListHead(
            Process
            );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Lock the list to ensure correct update.
    //
    KeRaiseIrql(APC_LEVEL, &OldIrql);
    ExAcquireResourceExclusiveLite(&pVdmObjects->VdmIoListHead->VdmIoResource,TRUE);

    //
    // Update Context
    //

    pVdmObjects->VdmIoListHead->Context = Context;

    VdmIoHandler = Psp386GetVdmIoHandler(
        Process,
        PortNumber & ~0x3
        );

    // If there isn't already a node for this block of ports,
    // attempt to allocate a new one.
    //
    if (!VdmIoHandler) {
        try {

            VdmIoHandler = ExAllocatePoolWithQuotaTag (PagedPool,
                                                       sizeof(VDM_IO_HANDLER),
                                                       'HVsP');

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            if (VdmIoHandler) {
                ExFreePool(VdmIoHandler);
            }
        }

        if (!NT_SUCCESS(Status)) {
            ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
            KeLowerIrql(OldIrql);
            return Status;
        }

        RtlZeroMemory(VdmIoHandler, sizeof(VDM_IO_HANDLER));
        VdmIoHandler->PortNumber = PortNumber & ~0x3;

        Status = Psp386InsertVdmIoHandlerBlock(
            Process,
            VdmIoHandler
            );

        if (!NT_SUCCESS(Status)) {
            ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
            KeLowerIrql(OldIrql);
            return Status;
        }
    }

    ASSERTEQUALBREAK(
        VdmIoHandler->PortNumber,
        (PortNumber & ~0x3),
        ("Psp386InstallIoHandler : Bad pointer returned from GetVdmIoHandler\n")
        );

    if (EmulatorAccessEntry->AccessMode & EMULATOR_READ_ACCESS) {
        switch (EmulatorAccessEntry->AccessType) {
        case Uchar:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UcharStringIo[PortNumber % 4],
                    ("Psp386InstallIoHandler : UcharString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UcharStringIo[PortNumber % 4] =
                    (PDRIVER_IO_PORT_UCHAR_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UcharIo[PortNumber % 4],
                    ("Psp386InstallIoHandler : Uchar fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UcharIo[PortNumber % 4] =
                    (PDRIVER_IO_PORT_UCHAR)EmulatorAccessEntry->Routine;
            }
            break;
        case Ushort:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UshortStringIo[(PortNumber & 2) >> 1],
                    ("Psp386InstallIoHandler : UshortString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UshortStringIo[(PortNumber & 2) >> 1] =
                    (PDRIVER_IO_PORT_USHORT_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UshortIo[(PortNumber & 2) >> 1],
                    ("Psp386InstallIoHandler : Ushort fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UshortIo[(PortNumber & 2) >> 1] =
                    (PDRIVER_IO_PORT_USHORT)EmulatorAccessEntry->Routine;
            }
            break;
        case Ulong:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UlongStringIo,
                    ("Psp386InstallIoHandler : UlongString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UlongStringIo =
                    (PDRIVER_IO_PORT_ULONG_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UlongIo,
                    ("Psp386InstallIoHandler : Ulong fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UlongIo =
                    (PDRIVER_IO_PORT_ULONG)EmulatorAccessEntry->Routine;
            }
            break;
        }
    }

    if (EmulatorAccessEntry->AccessMode & EMULATOR_WRITE_ACCESS) {
        switch (EmulatorAccessEntry->AccessType) {
        case Uchar:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UcharStringIo[PortNumber % 4],
                    ("Psp386InstallIoHandler : UcharString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UcharStringIo[PortNumber % 4] =
                    (PDRIVER_IO_PORT_UCHAR_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UcharIo[PortNumber % 4],
                    ("Psp386InstallIoHandler : Uchar fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UcharIo[PortNumber % 4] =
                    (PDRIVER_IO_PORT_UCHAR)EmulatorAccessEntry->Routine;
            }
            break;
        case Ushort:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UshortStringIo[(PortNumber & 2) >> 1],
                    ("Psp386InstallIoHandler : UshortString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UshortStringIo[(PortNumber & 2) >> 1] =
                    (PDRIVER_IO_PORT_USHORT_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UshortIo[(PortNumber & 2) >> 1],
                    ("Psp386InstallIoHandler : Ushort fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UshortIo[(PortNumber & 2) >> 1] =
                    (PDRIVER_IO_PORT_USHORT)EmulatorAccessEntry->Routine;
            }
            break;
        case Ulong:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UlongStringIo,
                    ("Psp386InstallIoHandler : UlongString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UlongStringIo =
                    (PDRIVER_IO_PORT_ULONG_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UlongIo,
                    ("Psp386InstallIoHandler : Ulong fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UlongIo =
                    (PDRIVER_IO_PORT_ULONG)EmulatorAccessEntry->Routine;
            }
        }
    }

    ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
    KeLowerIrql(OldIrql);
    return STATUS_SUCCESS;

}



NTSTATUS
Psp386CreateVdmIoListHead(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This routine creates the head node of the Io handler list.  This node
    contains the spin lock that protects the list.  This routine also
    initializes the spin lock.

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

Notes:

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    NTSTATUS Status;
    PVDM_IO_LISTHEAD HandlerListHead=NULL;
    KIRQL    OldIrql;
    PAGED_CODE();

    Status = STATUS_SUCCESS;

    // if there isn't yet a head, grab the resource lock and create one
    if (pVdmObjects->VdmIoListHead == NULL) {
        KeRaiseIrql(APC_LEVEL, &OldIrql);
        ExAcquireResourceExclusiveLite(&VdmIoListCreationResource, TRUE);

        // if no head was created while we grabbed the spin lock
        if (pVdmObjects->VdmIoListHead == NULL) {

            try {
                // allocate space for the list head
                // and charge the quota for it

                HandlerListHead = ExAllocatePoolWithQuotaTag (NonPagedPool,
                                                              sizeof(VDM_IO_LISTHEAD),
                                                              'LVsP');

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
                if (HandlerListHead) {
                    ExFreePool(HandlerListHead);
                }
            }

            if ((!NT_SUCCESS(Status) || !HandlerListHead)) {
                ExReleaseResourceLite(&VdmIoListCreationResource);
                KeLowerIrql(OldIrql);

                return (Status == STATUS_SUCCESS ?
                    STATUS_INSUFFICIENT_RESOURCES :
                    Status);

            }

            ExInitializeResourceLite(&HandlerListHead->VdmIoResource);

            HandlerListHead->VdmIoHandlerList = NULL;

            //
            // Attach the list head to the process
            // and attach the handler to the list.
            // Since this was a new list

            pVdmObjects->VdmIoListHead = HandlerListHead;

            ExReleaseResourceLite(&VdmIoListCreationResource);
            KeLowerIrql(OldIrql);


        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
Psp386InsertVdmIoHandlerBlock(
    IN PEPROCESS Process,
    IN PVDM_IO_HANDLER VdmIoHandler
    )
/*++

Routine Description:

    This routine inserts a new VdmIoHandler block into the process's io
    handler list.

Arguments:

    Process -- Supplies a pointer to the process
    VdmIoHandler -- Supplies a pointer to the block to insert.

Return Value:

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER HandlerList, p;
    PVDM_IO_LISTHEAD HandlerListHead;
    PAGED_CODE();


    HandlerListHead = pVdmObjects->VdmIoListHead;
    HandlerList = HandlerListHead->VdmIoHandlerList;
    p = NULL;
    while ((HandlerList != NULL) &&
        (HandlerList->PortNumber < VdmIoHandler->PortNumber)) {
#if DBG
            if (HandlerList->PortNumber == VdmIoHandler->PortNumber) {
                DbgPrint("Ps386InsertVdmIoHandlerBlock : handler list corrupt\n");
            }
#endif
            p = HandlerList;
            HandlerList = HandlerList->Next;
    }

    if (p == NULL) { // Beginning of list
        VdmIoHandler->Next = HandlerListHead->VdmIoHandlerList;
        HandlerListHead->VdmIoHandlerList = VdmIoHandler;
    } else if (HandlerList == NULL) { // End of list
        p->Next = VdmIoHandler;
        VdmIoHandler->Next = NULL;
    } else { // Middle of list
        VdmIoHandler->Next = HandlerList;
        p->Next = VdmIoHandler;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
Ps386GetVdmIoHandler(
    IN PEPROCESS Process,
    IN ULONG PortNumber,
    OUT PVDM_IO_HANDLER VdmIoHandler,
    OUT PULONG Context
    )
/*++

Routine Description:

    This routine finds the VdmIoHandler block for the specified port.

Arguments:

    Process -- Supplies a pointer to the process
    PortNumber -- Supplies the port number
    VdmIoHandler -- Supplies a pointer to the destination for the lookup

Returns:

    True -- A handler structure was found and copied
    False -- A handler structure was not found


--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER p;
    BOOLEAN Success;
    KIRQL   OldIrql;
    PAGED_CODE();

    if (pVdmObjects == NULL) {
        return FALSE;
    }

    if (PortNumber % 4) {
#if DBG
        DbgPrint(
            "Ps386GetVdmIoHandler : Invalid Port Number %lx\n",
            PortNumber
            );
#endif
        return FALSE;
    }

    if (!pVdmObjects->VdmIoListHead) {
        return FALSE;
    }


    KeRaiseIrql(APC_LEVEL, &OldIrql);
    ExAcquireResourceExclusiveLite(&pVdmObjects->VdmIoListHead->VdmIoResource,TRUE);

    p = Psp386GetVdmIoHandler(
        Process,
        PortNumber
        );

    if (p) {
        *VdmIoHandler = *p;
        *Context = pVdmObjects->VdmIoListHead->Context;
        Success = TRUE;
    } else {
        Success = FALSE;
    }
    ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
    KeLowerIrql(OldIrql);

    return Success;
}


PVDM_IO_HANDLER
Psp386GetVdmIoHandler(
    IN PEPROCESS Process,
    IN ULONG PortNumber
    )
/*++

Routine Description:

    This routine finds the VdmIoHandler block for the specified port.

Arguments:

    Process -- Supplies a pointer to the process
    PortNumber -- Supplies the port number

Returns:

    NULL  if no handler found
    non-NULL if handler found

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER p;
    PAGED_CODE();

    if (PortNumber % 4) {
#if DBG
        DbgPrint(
            "Ps386GetVdmIoHandler : Invalid Port Number %lx\n",
            PortNumber
            );
#endif
        return NULL;
    }

    p = pVdmObjects->VdmIoListHead->VdmIoHandlerList;
    while ((p) && (p->PortNumber != PortNumber)) {
        p = p->Next;
    }

    return p;

}

NTSTATUS
PspVdmInitialize(
    )

/*++

Routine Description:

    This routine initializes the process based Vdm support for x86.

Arguments:

    None

--*/
{
    return ExInitializeResourceLite (&VdmIoListCreationResource);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\i386\psldt.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psldt.c

Abstract:

    This module contains code for the process and thread ldt support.

Notes:

    The nonpaged pool consumed by the LDT is returned to the system at process
    deletion time.  The process deletion handler calls PspDeleteLdt.  We
    do not keep a reference to the process once the ldt is created.

    Note that the LDT must be kept in nonpaged memory because the EXIT_ALL
    macros that return from traps and interrupts pop ds (which may be an LDT
    selector) and then other registers.  With interrupts disabled.

--*/

#include "psp.h"

//
// Internal constants
//

#define DESCRIPTOR_GRAN     0x00800000
#define DESCRIPTOR_NP       0x00008000
#define DESCRIPTOR_SYSTEM   0x00001000
#define DESCRIPTOR_CONFORM  0x00001C00
#define DESCRIPTOR_DPL      0x00006000
#define DESCRIPTOR_TYPEDPL  0x00007F00


KMUTEX LdtMutex;

//
// Internal subroutines
//

PLDT_ENTRY
PspCreateLdt (
    IN PLDT_ENTRY Ldt,
    IN ULONG Offset,
    IN ULONG Size,
    IN ULONG AllocationSize
    );

LOGICAL
PspIsDescriptorValid (
    IN PLDT_ENTRY Descriptor
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PspLdtInitialize)
#pragma alloc_text(PAGE, PsSetLdtEntries)
#pragma alloc_text(PAGE, NtSetLdtEntries)
#pragma alloc_text(PAGE, PspDeleteLdt)
#pragma alloc_text(PAGE, PspQueryLdtInformation)
#pragma alloc_text(PAGE, PspSetLdtSize)
#pragma alloc_text(PAGE, PspSetLdtInformation)
#pragma alloc_text(PAGE, PspCreateLdt)
#pragma alloc_text(PAGE, PspIsDescriptorValid)
#pragma alloc_text(PAGE, PspQueryDescriptorThread)
#pragma alloc_text(PAGE, PsSetProcessLdtInfo)
#endif

NTSTATUS
PspLdtInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the LDT support for the x86

Arguments:

    None

Return Value:

    NTSTATUS.

--*/
{
    KeInitializeMutex  (&LdtMutex, 0);
    return STATUS_SUCCESS;
}


NTSTATUS
PspQueryLdtInformation (
    IN PEPROCESS Process,
    OUT PPROCESS_LDT_INFORMATION LdtInformation,
    IN ULONG LdtInformationLength,
    OUT PULONG ReturnLength
    )
/*++

Routine Description:

    This function performs the work for the LDT portion of the query
    process information function.  It copies the contents of the LDT
    for the specified process into the user's buffer, up to the length
    of the buffer.

Arguments:

    Process -- Supplies a pointer to the process to return LDT info for
    LdtInformation -- Supplies a pointer to the buffer
    ReturnLength -- Returns the number of bytes put into the buffer

Return Value:

    NTSTATUS.

--*/
{
    ULONG CopyLength, CopyEnd;
    NTSTATUS Status;
    ULONG HeaderLength;
    ULONG Length=0, Start=0;
    LONG MutexStatus;
    PLDTINFORMATION ProcessLdtInfo;

    PAGED_CODE();

    //
    // Verify the parameters
    //

    if (LdtInformationLength < sizeof (PROCESS_LDT_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // This portion of the parameters may be in user space
    //
    try {
        //
        // Capture parameters
        //
        Length = LdtInformation->Length;
        Start = LdtInformation->Start;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    //
    // The buffer containing the LDT entries must be in the information
    // structure.  We subtract one LDT entry, because the structure is
    // declared to contain one.
    //
    if (LdtInformationLength - sizeof(PROCESS_LDT_INFORMATION) + sizeof(LDT_ENTRY) < Length) {

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    // An LDT entry is a processor structure, and must be 8 bytes long
    ASSERT((sizeof(LDT_ENTRY) == 8));

    //
    // The length of the structure must be an even number of LDT entries
    //
    if (Length % sizeof (LDT_ENTRY)) {
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // The information to get from the LDT must start on an LDT entry
    // boundary.
    //
    if (Start % sizeof (LDT_ENTRY)) {
        return STATUS_INVALID_LDT_OFFSET;
    }

    //
    // Acquire the LDT mutex
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ProcessLdtInfo = Process->LdtInformation;

    //
    // If the process has an LDT
    //

    if ((ProcessLdtInfo) && (ProcessLdtInfo->Size)) {

        ASSERT ((ProcessLdtInfo->Ldt));

        //
        // Set the end of the copy to be the smaller of:
        //  the end of the information the user requested or
        //  the end of the information that is actually there
        //

        if (ProcessLdtInfo->Size < Start) {
           CopyEnd = Start;
        } else if (ProcessLdtInfo->Size - Start  > Length) {
            CopyEnd = Length + Start;
        } else {
            CopyEnd = ProcessLdtInfo->Size;
        }

        CopyLength = CopyEnd - Start;

        try {

            //
            // Set the length field to the actual length of the LDT
            //

            LdtInformation->Length = ProcessLdtInfo->Size;

            //
            // Copy the contents of the LDT into the user's buffer
            //

            if (CopyLength) {

                RtlCopyMemory (&(LdtInformation->LdtEntries),
                               (PCHAR)ProcessLdtInfo->Ldt + Start,
                               CopyLength);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            MutexStatus = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT ((MutexStatus == 0));
            return GetExceptionCode ();
        }

    } else {

        //
        // There is no LDT
        //

        CopyLength = 0;
        try {
            LdtInformation->Length = 0;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            MutexStatus = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT ((MutexStatus == 0));
            return GetExceptionCode ();
        }
    }

    //
    // Set the length of the information returned
    //

    if (ARGUMENT_PRESENT (ReturnLength)) {

        try {
            HeaderLength = (PCHAR)(&(LdtInformation->LdtEntries)) -
                (PCHAR)(&(LdtInformation->Start));
            *ReturnLength = CopyLength + HeaderLength;
        } except (EXCEPTION_EXECUTE_HANDLER){
            MutexStatus = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT ((MutexStatus == 0));
            return GetExceptionCode ();
        }
    }

    MutexStatus = KeReleaseMutex (&LdtMutex, FALSE);
    ASSERT ((MutexStatus == 0));
    return STATUS_SUCCESS;
}


NTSTATUS
PspSetLdtSize (
    IN PEPROCESS Process,
    IN PPROCESS_LDT_SIZE LdtSize,
    IN ULONG LdtSizeLength
    )

/*++

Routine Description:

    This routine changes the LDT size.  It will shrink the LDT, but not
    grow it.  If the LDT shrinks by 1 or more pages from its current allocation,
    the LDT will be reallocated for the new smaller size.  If the allocated
    size of the LDT changes, the quota charge for the LDT will be reduced.

Arguments:

    Process -- Supplies a pointer to the process whose LDT is to be sized
    LdtSize -- Supplies a pointer to the size information

Return Value:

    NTSTATUS.

--*/
{
    ULONG OldSize = 0, NewSize;
    LONG MutexState;
    ULONG Length=0;
    PLDT_ENTRY OldLdt = NULL;
    NTSTATUS Status;
    PLDTINFORMATION ProcessLdtInfo;
    PLDT_ENTRY Ldt;

    PAGED_CODE();

    //
    // Verify the parameters
    //
    if (LdtSizeLength != sizeof (PROCESS_LDT_SIZE)){
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // The following parameters may be in user space
    //
    try {
        //
        // Capture the new LDT length
        //
        Length = LdtSize->Length;

    } except(EXCEPTION_EXECUTE_HANDLER){
        return GetExceptionCode ();
    }


    ASSERT((sizeof(LDT_ENTRY) == 8));

    //
    // The LDT must always be an integral number of LDT_ENTRIES
    //
    if (Length % sizeof(LDT_ENTRY)) {
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // Acquire the LDT Mutex
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // If there isn't an LDT we can't set the size of the LDT
    //
    ProcessLdtInfo = Process->LdtInformation;
    if ((ProcessLdtInfo == NULL) || (ProcessLdtInfo->Size == 0)) {
        MutexState = KeReleaseMutex( &LdtMutex, FALSE );
        ASSERT((MutexState == 0));
        return STATUS_NO_LDT;
    }

    //
    // This function cannot be used to grow the LDT
    //
    if (Length > ProcessLdtInfo->Size) {
        MutexState = KeReleaseMutex( &LdtMutex, FALSE );
        ASSERT((MutexState == 0));
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // Later, we will set ProcessLdtInfo->LDT = LDT.  We may set the value
    // of LDT in the if statement below, but there is one case where we
    // don't
    //
    Ldt = ProcessLdtInfo->Ldt;

    //
    // Adjust the size of the LDT
    //

    ProcessLdtInfo->Size = Length;

    //
    // Free some of the LDT memory if conditions allow
    //

    if ( Length == 0 ) {

        OldSize = ProcessLdtInfo->AllocatedSize;
        OldLdt = ProcessLdtInfo->Ldt;

        ProcessLdtInfo->AllocatedSize = 0;
        Ldt = NULL;

    } else if ((ProcessLdtInfo->AllocatedSize - ProcessLdtInfo->Size) >= PAGE_SIZE) {

        OldSize = ProcessLdtInfo->AllocatedSize;
        OldLdt = ProcessLdtInfo->Ldt;

        //
        // Calculate new LDT size (lowest integer number of pages
        // large enough)
        //

        ProcessLdtInfo->AllocatedSize = ROUND_TO_PAGES (ProcessLdtInfo->Size);

        //
        // Reallocate and copy the LDT
        //

        Ldt = PspCreateLdt (ProcessLdtInfo->Ldt,
                            0,
                            ProcessLdtInfo->Size,
                            ProcessLdtInfo->AllocatedSize);

        if ( Ldt == NULL ) {

            //
            // We cannot reduce the allocation, but we can reduce the
            // LDT selector limit (done using Ke386SetLdtProcess)
            //

            Ldt = OldLdt;
            ProcessLdtInfo->AllocatedSize = OldSize;
            OldLdt = NULL;
        }
    }

    ProcessLdtInfo->Ldt = Ldt;

    //
    // Change the limit on the Process LDT
    //

    Ke386SetLdtProcess (&(Process->Pcb),
                        ProcessLdtInfo->Ldt,
                        ProcessLdtInfo->Size);

    NewSize = ProcessLdtInfo->AllocatedSize;

    MutexState = KeReleaseMutex (&LdtMutex, FALSE);

    ASSERT((MutexState == 0));

    //
    // If we resized the LDT, free the old one and reduce the quota charge
    //

    if (OldLdt) {
        ExFreePool (OldLdt);

        PsReturnProcessNonPagedPoolQuota (Process,
                                          OldSize - NewSize);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PspSetLdtInformation(
    IN PEPROCESS Process,
    IN PPROCESS_LDT_INFORMATION LdtInformation,
    IN ULONG LdtInformationLength
    )

/*++

Routine Description:

    This function alters the ldt for a specified process.  It can alter
    portions of the LDT, or the whole LDT.  If an LDT is created or
    grown, the specified process will be charged the quota for the LDT.
    Each descriptor that is set will be verified.

Arguments:

    Process -- Supplies a pointer to the process whose LDT is to be modified
    LdtInformation -- Supplies a pointer to the information about the LDT
        modifications
    LdtInformationLength -- Supplies the length of the LdtInformation
        structure.

--*/
{
    NTSTATUS Status;
    PLDT_ENTRY OldLdt = NULL;
    ULONG OldSize = 0;
    ULONG AllocatedSize;
    ULONG Size;
    ULONG MutexState;
    ULONG LdtOffset;
    PLDT_ENTRY CurrentDescriptor;
    PPROCESS_LDT_INFORMATION LdtInfo=NULL;
    PLDTINFORMATION ProcessLdtInfo;
    PLDT_ENTRY Ldt;

    PAGED_CODE();

    if (LdtInformationLength < sizeof (PROCESS_LDT_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Status = STATUS_SUCCESS;
    LdtInfo = ExAllocatePoolWithQuotaTag (NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                          LdtInformationLength,
                                          'dLsP');

    if (LdtInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // allocate a local buffer to capture the ldt information to
    //
    try {
        //
        // Copy the information the user is supplying
        //
        RtlCopyMemory (LdtInfo,
                       LdtInformation,
                       LdtInformationLength);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ExFreePool (LdtInfo);
        Status = GetExceptionCode ();
        return Status;
    }

    //
    // Verify that the Start and Length are plausible
    //
    if (LdtInfo->Start & 0xFFFF0000) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_OFFSET;
    }

    if (LdtInfo->Length & 0xFFFF0000) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // Ensure that the buffer it large enough to contain the specified number
    // of selectors.
    //
    if (LdtInformationLength - sizeof (PROCESS_LDT_INFORMATION) + sizeof (LDT_ENTRY) < LdtInfo->Length) {
        ExFreePool (LdtInfo);
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // The info to set must be an integral number of selectors
    //
    if (LdtInfo->Length % sizeof (LDT_ENTRY)) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // The beginning of the info must be on a selector boundary
    //
    if (LdtInfo->Start % sizeof (LDT_ENTRY)) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_OFFSET;
    }

    //
    // Verify all of the descriptors.
    //

    for (CurrentDescriptor = LdtInfo->LdtEntries;
         (PCHAR)CurrentDescriptor < (PCHAR)LdtInfo->LdtEntries + LdtInfo->Length;
          CurrentDescriptor++) {
        if (!PspIsDescriptorValid (CurrentDescriptor)) {
            ExFreePool (LdtInfo);
            return STATUS_INVALID_LDT_DESCRIPTOR;
        }
    }

    //
    // Acquire the LDT Mutex
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);
    if (!NT_SUCCESS (Status)) {
        ExFreePool (LdtInfo);
        return Status;
    }

    ProcessLdtInfo = Process->LdtInformation;

    //
    // If the process doen't have an LDT information structure, allocate
    //  one and attach it to the process
    //
    if (ProcessLdtInfo == NULL) {
        ProcessLdtInfo = ExAllocatePoolWithTag (NonPagedPool,
                                                sizeof(LDTINFORMATION),
                                                'dLsP');
        if (ProcessLdtInfo == NULL) {
            goto SetInfoCleanup;
        }
        Process->LdtInformation = ProcessLdtInfo;
        RtlZeroMemory (ProcessLdtInfo, sizeof (LDTINFORMATION));
    }

    //
    // If we are supposed to remove the LDT
    //
    if (LdtInfo->Length == 0)  {

        //
        // Remove the process' LDT
        //

        if (ProcessLdtInfo->Ldt) {
            OldSize = ProcessLdtInfo->AllocatedSize;
            OldLdt = ProcessLdtInfo->Ldt;

            ProcessLdtInfo->AllocatedSize = 0;
            ProcessLdtInfo->Size = 0;
            ProcessLdtInfo->Ldt = NULL;

            Ke386SetLdtProcess (&Process->Pcb,
                                NULL,
                                0);

            PsReturnProcessNonPagedPoolQuota (Process, OldSize);
        }


    } else if (ProcessLdtInfo->Ldt == NULL) {

        //
        // Create a new LDT for the process
        //

        //
        // Allocate an integral number of pages for the LDT.
        //

        ASSERT(((PAGE_SIZE % 2) == 0));

        AllocatedSize = ROUND_TO_PAGES (LdtInfo->Start + LdtInfo->Length);

        Size = LdtInfo->Start + LdtInfo->Length;

        Ldt = PspCreateLdt (LdtInfo->LdtEntries,
                            LdtInfo->Start,
                            Size,
                            AllocatedSize);

        if (Ldt == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetInfoCleanup;
        }

        Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                   AllocatedSize);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Ldt);
            Ldt = NULL;
            goto SetInfoCleanup;
        }

        ProcessLdtInfo->Ldt = Ldt;
        ProcessLdtInfo->Size = Size;
        ProcessLdtInfo->AllocatedSize = AllocatedSize;
        Ke386SetLdtProcess (&Process->Pcb,
                            ProcessLdtInfo->Ldt,
                            ProcessLdtInfo->Size);


    } else if (LdtInfo->Length + LdtInfo->Start > ProcessLdtInfo->Size) {

        //
        // Grow the process' LDT
        //

        if (LdtInfo->Length + LdtInfo->Start > ProcessLdtInfo->AllocatedSize) {

            //
            // Current LDT allocation is not large enough, so create a
            // new larger LDT
            //

            OldSize = ProcessLdtInfo->AllocatedSize;

            Size = LdtInfo->Start + LdtInfo->Length;
            AllocatedSize = ROUND_TO_PAGES (Size);

            Ldt = PspCreateLdt (ProcessLdtInfo->Ldt,
                                0,
                                OldSize,
                                AllocatedSize);

            if (Ldt == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetInfoCleanup;
            }


            Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                       AllocatedSize);

            if (!NT_SUCCESS (Status)) {
                ExFreePool (Ldt);
                Ldt = NULL;
                goto SetInfoCleanup;
            }
            PsReturnProcessNonPagedPoolQuota (Process,
                                              OldSize);

            //
            // Swap LDT information
            //
            OldLdt = ProcessLdtInfo->Ldt;
            ProcessLdtInfo->Ldt = Ldt;
            ProcessLdtInfo->Size = Size;
            ProcessLdtInfo->AllocatedSize = AllocatedSize;

            //
            // Put new selectors into the new ldt
            //
            RtlCopyMemory ((PCHAR)(ProcessLdtInfo->Ldt) + LdtInfo->Start,
                           LdtInfo->LdtEntries,
                           LdtInfo->Length);

            Ke386SetLdtProcess (&Process->Pcb,
                                ProcessLdtInfo->Ldt,
                                ProcessLdtInfo->Size);


        } else {

            //
            // Current LDT allocation is large enough
            //

            ProcessLdtInfo->Size = LdtInfo->Length + LdtInfo->Start;

            Ke386SetLdtProcess (&Process->Pcb,
                                ProcessLdtInfo->Ldt,
                                ProcessLdtInfo->Size);

            //
            // Change the selectors in the table
            //
            for (LdtOffset = LdtInfo->Start, CurrentDescriptor = LdtInfo->LdtEntries;
                 LdtOffset < LdtInfo->Start + LdtInfo->Length;
                 LdtOffset += sizeof(LDT_ENTRY), CurrentDescriptor++) {

                Ke386SetDescriptorProcess (&Process->Pcb,
                                           LdtOffset,
                                           *CurrentDescriptor);
            }
        }
    } else {

        //
        // Simply changing some selectors
        //

        for (LdtOffset = LdtInfo->Start, CurrentDescriptor = LdtInfo->LdtEntries;
             LdtOffset < LdtInfo->Start +  LdtInfo->Length;
             LdtOffset += sizeof(LDT_ENTRY), CurrentDescriptor++) {

            Ke386SetDescriptorProcess (&Process->Pcb,
                                       LdtOffset,
                                       *CurrentDescriptor);
        }
        Status = STATUS_SUCCESS;
    }


SetInfoCleanup:

    MutexState = KeReleaseMutex (&LdtMutex, FALSE);
    ASSERT ((MutexState == 0));

    if (OldLdt != NULL) {
        ExFreePool (OldLdt);
    }

    if (LdtInfo != NULL) {
        ExFreePool (LdtInfo);
    }

    return Status;
}

PLDT_ENTRY
PspCreateLdt (
    IN PLDT_ENTRY Ldt,
    IN ULONG Offset,
    IN ULONG Size,
    IN ULONG AllocationSize
    )

/*++

Routine Description:

    This routine allocates space in nonpaged pool for an LDT, and copies the
    specified selectors into it.  IT DOES NOT VALIDATE THE SELECTORS.
    Selector validation must be done before calling this routine.  IT
    DOES NOT CHARGE THE QUOTA FOR THE LDT.

Arguments:

    Ldt -- Supplies a pointer to the descriptors to be put into the LDT.
    Offset -- Supplies the offset in the LDT to copy the descriptors to.
    Size -- Supplies the actualsize of the new LDT
    AllocationSize -- Supplies the size to allocate

Return Value:

    Pointer to the new LDT
--*/
{
    PLDT_ENTRY NewLdt;

    PAGED_CODE();

    ASSERT ((AllocationSize >= Size));
    ASSERT (((Size % sizeof(LDT_ENTRY)) == 0));

    NewLdt = ExAllocatePoolWithTag (NonPagedPool, AllocationSize, 'dLsP');

    if (NewLdt != NULL) {
        RtlZeroMemory (NewLdt, AllocationSize);
        RtlCopyMemory ((PCHAR)NewLdt + Offset, Ldt, Size - Offset);
    }

    return NewLdt;
}



LOGICAL
PspIsDescriptorValid (
    IN PLDT_ENTRY Descriptor
    )

/*++

Routine Description:

    This function determines if the supplied descriptor is valid to put
    into a process LDT.  For the descriptor to be valid it must have the
    following characteristics:

    Base < MM_HIGHEST_USER_ADDRESS
    Base + Limit < MM_HIGHEST_USER_ADDRESS
    Type must be
        ReadWrite, ReadOnly, ExecuteRead, ExecuteOnly, or Invalid
        big or small
        normal or grow down
        Not a system descriptor (system bit is 1 == application)
            This rules out all gates, etc
        Not conforming
    DPL must be 3

Arguments:

    Descriptor -- Supplies a pointer to the descriptor to check

Return Value:

    True if the descriptor is valid (note: valid to put into an LDT.  This
        includes Invalid descriptors)
    False if not
--*/

{
    ULONG Base;
    ULONG Limit;

    PAGED_CODE();

    //
    // if descriptor is an invalid descriptor
    //

    if ((Descriptor->HighWord.Bits.Type == 0) &&
        (Descriptor->HighWord.Bits.Dpl == 0)) {

        return TRUE;
    }

    Base = Descriptor->BaseLow | (Descriptor->HighWord.Bytes.BaseMid << 16) |
           (Descriptor->HighWord.Bytes.BaseHi << 24);

    Limit = Descriptor->LimitLow | (Descriptor->HighWord.Bits.LimitHi << 16);

    //
    // Only have to check for present selectors
    //
    if (Descriptor->HighWord.Bits.Pres) {
        ULONG ActualLimit;

        if ((Descriptor->HighWord.Bits.Type&0x14) == 0x14) {
            if (Descriptor->HighWord.Bits.Default_Big == 1) {
                ActualLimit = 0xFFFFFFFF;
            } else {
                ActualLimit = 0xFFFF;
            }
        } else if (Descriptor->HighWord.Bits.Granularity == 0) {
            ActualLimit = Limit;
        } else {
            ActualLimit = (Limit<<12) + 0xFFF;
        }

        //
        // See if the segment extends into the kernel address space.
        //
        if (Base > Base + ActualLimit ||
            ((PVOID)(Base + ActualLimit) > MM_HIGHEST_USER_ADDRESS)) {
            return FALSE;
        }

        //
        // Don't let the reserved field be set.
        //
        if (Descriptor->HighWord.Bits.Reserved_0 != 0) {
            return FALSE;
        }
    }


    //
    // if Dpl is not 3
    //

    if (Descriptor->HighWord.Bits.Dpl != 3) {
        return FALSE;
    }

    //
    // if descriptor is a system descriptor (which includes gates)
    // if bit 4 of the Type field is 0, then it's a system descriptor,
    // and we don't like it.
    //

    if (!(Descriptor->HighWord.Bits.Type & 0x10)) {
        return FALSE;
    }

    //
    // if descriptor is conforming code
    //

    if (((Descriptor->HighWord.Bits.Type & 0x18) == 0x18) &&
        (Descriptor->HighWord.Bits.Type & 0x4)) {

        return FALSE;
    }

    return TRUE;
}

NTSTATUS
PspQueryDescriptorThread (
    PETHREAD Thread,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
    )
/*++

Routine Description:

    This function retrieves a descriptor table entry for the specified thread.
    This entry may be in either the Gdt or the LDT, as specfied by the
    supplied selector

Arguments:

    Thread -- Supplies a pointer to the thread.
    ThreadInformation -- Supplies information on the descriptor.
    ThreadInformationLength -- Supplies the length of the information.
    ReturnLength -- Returns the number of bytes returned.

--*/
{
    DESCRIPTOR_TABLE_ENTRY DescriptorEntry={0};
    PEPROCESS Process;
    LONG MutexState;
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT( sizeof(KGDTENTRY) == sizeof(LDT_ENTRY) );

    //
    // Verify parameters
    //

    if ( ThreadInformationLength != sizeof(DESCRIPTOR_TABLE_ENTRY) ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    try {
        DescriptorEntry = *(PDESCRIPTOR_TABLE_ENTRY)ThreadInformation;
    } except(EXCEPTION_EXECUTE_HANDLER){
        return GetExceptionCode ();
    }


    Status = STATUS_SUCCESS;

    //
    // If its a Gdt entry, let the kernel find it for us
    //

    if ( !(DescriptorEntry.Selector & SELECTOR_TABLE_INDEX) ) {

        if ( (DescriptorEntry.Selector & 0xFFFFFFF8) >= KGDT_NUMBER * sizeof(KGDTENTRY) ) {

            return STATUS_ACCESS_VIOLATION;
        }

        try {
            Ke386GetGdtEntryThread (&Thread->Tcb,
                                    DescriptorEntry.Selector & 0xFFFFFFF8,
                                    (PKGDTENTRY) &(((PDESCRIPTOR_TABLE_ENTRY)ThreadInformation)->Descriptor));
            if (ARGUMENT_PRESENT(ReturnLength) ) {
                *ReturnLength = sizeof(LDT_ENTRY);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    } else {

        //
        // it's an LDT entry, so copy it from the LDT
        //

        Process = THREAD_TO_PROCESS (Thread);

        //
        // Acquire the LDT Mutex
        //

        Status = KeWaitForSingleObject (&LdtMutex,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        if ( Process->LdtInformation == NULL ) {

            // If there is no LDT
            Status = STATUS_NO_LDT;

        } else if ( (DescriptorEntry.Selector & 0xFFFFFFF8) >=
            ((PLDTINFORMATION)(Process->LdtInformation))->Size ) {

            // Else If the selector is outside the table
            Status = STATUS_ACCESS_VIOLATION;

        } else try {

            // Else return the contents of the descriptor
            RtlCopyMemory (&(((PDESCRIPTOR_TABLE_ENTRY)ThreadInformation)->Descriptor),
                           (PCHAR)(((PLDTINFORMATION)(Process->LdtInformation))->Ldt) +
                               (DescriptorEntry.Selector & 0xFFFFFFF8),
                           sizeof(LDT_ENTRY));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(LDT_ENTRY);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode ();
        }

        MutexState = KeReleaseMutex (&LdtMutex, FALSE);
        ASSERT ((MutexState == 0));
    }

    return Status;
}

VOID
PspDeleteLdt(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This routine frees the nonpaged pool associated with a process' LDT, if
    it has one.

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

    None
--*/
{
    PLDTINFORMATION LdtInformation;

    PAGED_CODE();

    LdtInformation = Process->LdtInformation;
    if (LdtInformation != NULL) {
        if (LdtInformation->Ldt != NULL) {
            PsReturnProcessNonPagedPoolQuota (Process, LdtInformation->AllocatedSize);
            ExFreePool (LdtInformation->Ldt);
        }
        ExFreePool( LdtInformation );
    }
}

NTSTATUS
PsSetLdtEntries (
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1Hi
    )
/*++

Routine Description:

    This routine sets up to two selectors in the current process's LDT.
    The LDT will be grown as necessary.  A selector value of 0 indicates
    that the specified selector was not passed (allowing the setting of
    a single selector).

Arguments:

    Selector0 -- Supplies the number of the first descriptor to set
    Entry0Low -- Supplies the low 32 bits of the descriptor
    Entry0Hi -- Supplies the high 32 bits of the descriptor
    Selector1 -- Supplies the number of the first descriptor to set
    Entry1Low -- Supplies the low 32 bits of the descriptor
    Entry1Hi -- Supplies the high 32 bits of the descriptor

Return Value:

    NTSTATUS.

--*/

{
    ULONG LdtSize, AllocatedSize;
    NTSTATUS Status;
    PEPROCESS Process;
    LDT_ENTRY Descriptor[2];
    PLDT_ENTRY Ldt, OldLdt;
    PLDTINFORMATION ProcessLdtInformation;
    LONG MutexState;
    ULONG Selector1Index;

    PAGED_CODE();

    //
    // Verify the selectors.  We do not allow selectors that point into
    // Kernel space, system selectors, or conforming code selectors
    //

    //
    // Verify the selectors
    //
    if ((Selector0 & 0xFFFF0000) || (Selector1 & 0xFFFF0000)) {
        return STATUS_INVALID_LDT_DESCRIPTOR;
    }

    // Change the selector values to indexes into the LDT

    Selector0 = Selector0 & ~(RPL_MASK | SELECTOR_TABLE_INDEX);
    Selector1 = Selector1 & ~(RPL_MASK | SELECTOR_TABLE_INDEX);


    //
    // Verify descriptor 0
    //

    Selector1Index = 0;
    if (Selector0) {

        Selector1Index = 1;

        *((PULONG)(&Descriptor[0]))       = Entry0Low;
        *(((PULONG)(&Descriptor[0])) + 1) = Entry0Hi;

        //
        // Validate the descriptor
        //
        if (!PspIsDescriptorValid (&Descriptor[0])) {
            return STATUS_INVALID_LDT_DESCRIPTOR;
        }
    }

    //
    // Verify descriptor 1
    //

    if (Selector1) {
        *((PULONG)(&Descriptor[Selector1Index]))       = Entry1Low;
        *(((PULONG)(&Descriptor[Selector1Index])) + 1) = Entry1Hi;

        //
        // Validate the descriptor
        //
        if (!PspIsDescriptorValid (&Descriptor[Selector1Index])) {
            return STATUS_INVALID_LDT_DESCRIPTOR;
        }
    }

    //
    // Figure out how large the LDT needs to be
    //

    if (Selector0 > Selector1) {
        LdtSize = Selector0 + sizeof(LDT_ENTRY);
    } else {
        LdtSize = Selector1 + sizeof(LDT_ENTRY);
    }

    Process = PsGetCurrentProcess();

    //
    // Acquire the LDT mutex.
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ProcessLdtInformation = Process->LdtInformation;

    //
    // Most of the time, the process will already have an LDT, and it
    // will be large enough.  for this, we just set the descriptors and
    // return
    //

    if (ProcessLdtInformation) {

        //
        // If the LDT descriptor does not have to be modified.
        //

        if (ProcessLdtInformation->Size >= LdtSize) {

            if (Selector0) {

                Ke386SetDescriptorProcess (&(Process->Pcb),
                                           Selector0,
                                           Descriptor[0]);
            }

            if (Selector1) {

                Ke386SetDescriptorProcess (&(Process->Pcb),
                                           Selector1,
                                           Descriptor[Selector1Index]);
            }

            MutexState = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT (MutexState == 0);
            return STATUS_SUCCESS;
        }

        //
        // Else if the LDT will fit in the memory currently allocated.
        //

        if (ProcessLdtInformation->AllocatedSize >= LdtSize) {

            //
            // First remove the LDT.  This will allow us to edit the memory.
            // We will then put the LDT back.  Since we have to change the
            // limit anyway, it would take two calls to the kernel ldt
            // management minimum to set the descriptors.  Each of those calls
            // would stall all of the processors in an MP system.  If we
            // didn't remove the ldt first, and we were setting two descriptors,
            // we would have to call the LDT management 3 times (once per
            // descriptor, and once to change the limit of the LDT).
            //

            Ke386SetLdtProcess (&(Process->Pcb), NULL, 0L);

            //
            // Set the Descriptors in the LDT.
            //

            if (Selector0) {
                *((PLDT_ENTRY) &ProcessLdtInformation->Ldt[Selector0/sizeof(LDT_ENTRY)]) = Descriptor[0];
            }

            if (Selector1) {
                *((PLDT_ENTRY) &ProcessLdtInformation->Ldt[Selector1/sizeof(LDT_ENTRY)]) = Descriptor[Selector1Index];
            }

            //
            // Set the LDT for the process
            //

            ProcessLdtInformation->Size = LdtSize;

            Ke386SetLdtProcess (&(Process->Pcb),
                                ProcessLdtInformation->Ldt,
                                ProcessLdtInformation->Size);

            MutexState = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT (MutexState == 0);
            return STATUS_SUCCESS;
        }

        //
        // Otherwise we have to grow the LDT allocation.
        //
    }

    //
    // If the process does not yet have an LDT information structure,
    // allocate and attach one.
    //

    OldLdt = NULL;

    if (!Process->LdtInformation) {
        ProcessLdtInformation = ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(LDTINFORMATION),
                                                       'dLsP');
        if (ProcessLdtInformation == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetLdtEntriesCleanup;
        }
        Process->LdtInformation = ProcessLdtInformation;
        ProcessLdtInformation->Size = 0L;
        ProcessLdtInformation->AllocatedSize = 0L;
        ProcessLdtInformation->Ldt = NULL;
    }

    //
    // Now, we either need to create or grow an LDT, so allocate some
    // memory, and copy as necessary
    //

    AllocatedSize = ROUND_TO_PAGES (LdtSize);

    Ldt = ExAllocatePoolWithTag (NonPagedPool, AllocatedSize, 'dLsP');

    if (Ldt == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SetLdtEntriesCleanup;
    }

    Status = PsChargeProcessNonPagedPoolQuota (Process, AllocatedSize);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Ldt);
        Ldt = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SetLdtEntriesCleanup;
    }

    RtlZeroMemory (Ldt, AllocatedSize);

    OldLdt = ProcessLdtInformation->Ldt;

    if (OldLdt != NULL) {

        //
        // copy the contents of the old LDT
        //

        RtlCopyMemory (Ldt, OldLdt, ProcessLdtInformation->Size);

        PsReturnProcessNonPagedPoolQuota (Process,
                                          ProcessLdtInformation->AllocatedSize);
    }

    ProcessLdtInformation->Size = LdtSize;
    ProcessLdtInformation->AllocatedSize = AllocatedSize;
    ProcessLdtInformation->Ldt = Ldt;

    //
    // Set the descriptors in the LDT
    //

    if (Selector0) {
        *((PLDT_ENTRY) &ProcessLdtInformation->Ldt[Selector0/sizeof(LDT_ENTRY)]) = Descriptor[0];
    }

    if (Selector1) {
        *((PLDT_ENTRY) &ProcessLdtInformation->Ldt[Selector1/sizeof(LDT_ENTRY)]) = Descriptor[Selector1Index];
    }

    //
    // Set the LDT for the process
    //

    Ke386SetLdtProcess (&Process->Pcb,
                        ProcessLdtInformation->Ldt,
                        ProcessLdtInformation->Size);

    //
    // Cleanup and exit
    //

    Status = STATUS_SUCCESS;

SetLdtEntriesCleanup:

    MutexState = KeReleaseMutex (&LdtMutex, FALSE);
    ASSERT (MutexState == 0);

    if (OldLdt != NULL) {
        ExFreePool (OldLdt);
    }

    return Status;
}

NTSTATUS
NtSetLdtEntries(
    __in ULONG Selector0,
    __in ULONG Entry0Low,
    __in ULONG Entry0Hi,
    __in ULONG Selector1,
    __in ULONG Entry1Low,
    __in ULONG Entry1Hi
    )
/*++

Routine Description:

    This routine sets up to two selectors in the current process's LDT.
    The LDT will be grown as necessary.  A selector value of 0 indicates
    that the specified selector was not passed (allowing the setting of
    a single selector).

Arguments:

    Selector0 -- Supplies the number of the first descriptor to set
    Entry0Low -- Supplies the low 32 bits of the descriptor
    Entry0Hi -- Supplies the high 32 bits of the descriptor
    Selector1 -- Supplies the number of the first descriptor to set
    Entry1Low -- Supplies the low 32 bits of the descriptor
    Entry1Hi -- Supplies the high 32 bits of the descriptor

Return Value:

    NTSTATUS.

--*/

{
    return PsSetLdtEntries (Selector0,
                            Entry0Low,
                            Entry0Hi,
                            Selector1,
                            Entry1Low,
                            Entry1Hi
                            );
}

NTSTATUS
PsSetProcessLdtInfo (
    IN PPROCESS_LDT_INFORMATION LdtInformation,
    IN ULONG LdtInformationLength
    )

/*++

Routine Description:

    This function alters the ldt for a specified process.  It can alter
    portions of the LDT, or the whole LDT.  If an Ldt is created or
    grown, the specified process will be charged the quota for the LDT.
    Each descriptor that is set will be verified.

Arguments:

    LdtInformation - Supplies a pointer to a record that contains the
        information to set.  This pointer has already been probed, but since
        it is a usermode pointer, accesses must be guarded by try-except.

    LdtInformationLength - Supplies the length of the record that contains
        the information to set.

Return Value:

    NTSTATUS.

--*/

{
    PEPROCESS Process = PsGetCurrentProcess();
    NTSTATUS Status;
    PLDT_ENTRY OldLdt = NULL;
    ULONG OldSize = 0;
    ULONG AllocatedSize;
    ULONG Size;
    ULONG MutexState;
    ULONG LdtOffset;
    PLDT_ENTRY CurrentDescriptor;
    PPROCESS_LDT_INFORMATION LdtInfo;
    PLDTINFORMATION ProcessLdtInfo;
    PLDT_ENTRY Ldt;

    PAGED_CODE();

    if (LdtInformationLength < (ULONG)sizeof( PROCESS_LDT_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Allocate a local buffer to capture the ldt information to
    //

    LdtInfo = ExAllocatePoolWithQuotaTag (NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                          LdtInformationLength,
                                          'ldmV');
    if (LdtInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = STATUS_SUCCESS;

    try {

        //
        // Copy the information the user is supplying
        //

        RtlCopyMemory (LdtInfo,
                       LdtInformation,
                       LdtInformationLength);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode ();
        ExFreePool (LdtInfo);
    }

    //
    // If the capture didn't succeed
    //

    if (!NT_SUCCESS (Status)) {

        if (Status == STATUS_ACCESS_VIOLATION) {
            return STATUS_SUCCESS;
        }

        return Status;
    }

    //
    // Verify that the Start and Length are plausible
    //
    if (LdtInfo->Start & 0xFFFF0000) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_OFFSET;
    }

    if (LdtInfo->Length & 0xFFFF0000) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // Ensure that the buffer is large enough to contain the specified number
    // of selectors.
    //
    if (LdtInformationLength - sizeof (PROCESS_LDT_INFORMATION) + sizeof (LDT_ENTRY) < LdtInfo->Length) {
        ExFreePool (LdtInfo);
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // The info to set must be an integral number of selectors
    //
    if (LdtInfo->Length % sizeof (LDT_ENTRY)) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // The beginning of the info must be on a selector boundary
    //
    if (LdtInfo->Start % sizeof (LDT_ENTRY)) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_OFFSET;
    }

    //
    // Verify all of the descriptors.
    //

    for (CurrentDescriptor = LdtInfo->LdtEntries;
         (PCHAR)CurrentDescriptor < (PCHAR)LdtInfo->LdtEntries + LdtInfo->Length;
          CurrentDescriptor += 1) {

        if (!PspIsDescriptorValid (CurrentDescriptor)) {
            ExFreePool (LdtInfo);
            return STATUS_INVALID_LDT_DESCRIPTOR;
        }
    }

    //
    // Acquire the Ldt Mutex
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);
    if (!NT_SUCCESS (Status)) {
        ExFreePool (LdtInfo);
        return Status;
    }

    ProcessLdtInfo = Process->LdtInformation;

    //
    // If the process doesn't have an Ldt information structure, allocate
    // one and attach it to the process
    //

    if (ProcessLdtInfo == NULL) {
        ProcessLdtInfo = ExAllocatePoolWithTag (NonPagedPool,
                                                sizeof(LDTINFORMATION),
                                                'dLsP');
        if (ProcessLdtInfo == NULL) {
            goto SetInfoCleanup;
        }
        RtlZeroMemory (ProcessLdtInfo, sizeof (LDTINFORMATION));
        Process->LdtInformation = ProcessLdtInfo;
    }

    //
    // If we are supposed to remove the LDT
    //
    if (LdtInfo->Length == 0)  {

        //
        // Remove the process' Ldt
        //

        if (ProcessLdtInfo->Ldt) {
            OldSize = ProcessLdtInfo->AllocatedSize;
            OldLdt = ProcessLdtInfo->Ldt;

            ProcessLdtInfo->AllocatedSize = 0;
            ProcessLdtInfo->Size = 0;
            ProcessLdtInfo->Ldt = NULL;

            Ke386SetLdtProcess (&Process->Pcb,
                                NULL,
                                0);

            PsReturnProcessNonPagedPoolQuota (Process, OldSize);
        }

    } else if (ProcessLdtInfo->Ldt == NULL) {

        //
        // Create a new Ldt for the process
        //
        // Allocate an integral number of pages for the LDT.
        //

        ASSERT(((PAGE_SIZE % 2) == 0));

        AllocatedSize = ROUND_TO_PAGES (LdtInfo->Start + LdtInfo->Length);

        Size = LdtInfo->Start + LdtInfo->Length;

        Ldt = PspCreateLdt (LdtInfo->LdtEntries,
                            LdtInfo->Start,
                            Size,
                            AllocatedSize);

        if (Ldt == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetInfoCleanup;
        }

        Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                   AllocatedSize);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Ldt);
            Ldt = NULL;
            goto SetInfoCleanup;
        }

        ProcessLdtInfo->Ldt = Ldt;
        ProcessLdtInfo->Size = Size;
        ProcessLdtInfo->AllocatedSize = AllocatedSize;
        Ke386SetLdtProcess (&Process->Pcb,
                            ProcessLdtInfo->Ldt,
                            ProcessLdtInfo->Size);


    } else if (LdtInfo->Length + LdtInfo->Start > ProcessLdtInfo->Size) {

        //
        // Grow the process' Ldt
        //

        if (LdtInfo->Length + LdtInfo->Start > ProcessLdtInfo->AllocatedSize) {

            //
            // Current Ldt allocation is not large enough, so create a
            // new larger Ldt
            //

            OldSize = ProcessLdtInfo->AllocatedSize;

            Size = LdtInfo->Start + LdtInfo->Length;
            AllocatedSize = ROUND_TO_PAGES (Size);

            Ldt = PspCreateLdt (ProcessLdtInfo->Ldt,
                                0,
                                OldSize,
                                AllocatedSize);

            if (Ldt == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetInfoCleanup;
            }

            Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                       AllocatedSize);

            if (!NT_SUCCESS (Status)) {
                ExFreePool (Ldt);
                Ldt = NULL;
                goto SetInfoCleanup;
            }
            PsReturnProcessNonPagedPoolQuota (Process,
                                              OldSize);

            //
            // Swap Ldt information
            //
            OldLdt = ProcessLdtInfo->Ldt;
            ProcessLdtInfo->Ldt = Ldt;
            ProcessLdtInfo->Size = Size;
            ProcessLdtInfo->AllocatedSize = AllocatedSize;

            //
            // Put new selectors into the new ldt
            //
            RtlCopyMemory ((PCHAR)(ProcessLdtInfo->Ldt) + LdtInfo->Start,
                           LdtInfo->LdtEntries,
                           LdtInfo->Length);

            Ke386SetLdtProcess (&Process->Pcb,
                                ProcessLdtInfo->Ldt,
                                ProcessLdtInfo->Size);


        } else {

            //
            // Current Ldt allocation is large enough
            //

            ProcessLdtInfo->Size = LdtInfo->Length + LdtInfo->Start;

            Ke386SetLdtProcess (&Process->Pcb,
                                ProcessLdtInfo->Ldt,
                                ProcessLdtInfo->Size);

            //
            // Change the selectors in the table
            //
            for (LdtOffset = LdtInfo->Start, CurrentDescriptor = LdtInfo->LdtEntries;
                 LdtOffset < LdtInfo->Start + LdtInfo->Length;
                 LdtOffset += sizeof(LDT_ENTRY), CurrentDescriptor++) {

                Ke386SetDescriptorProcess (&Process->Pcb,
                                           LdtOffset,
                                           *CurrentDescriptor);
            }
        }
    } else {

        //
        // Simply changing some selectors
        //

        for (LdtOffset = LdtInfo->Start, CurrentDescriptor = LdtInfo->LdtEntries;
             LdtOffset < LdtInfo->Start +  LdtInfo->Length;
             LdtOffset += sizeof(LDT_ENTRY), CurrentDescriptor++) {

            Ke386SetDescriptorProcess (&Process->Pcb,
                                       LdtOffset,
                                       *CurrentDescriptor);
        }
        Status = STATUS_SUCCESS;
    }


SetInfoCleanup:

    MutexState = KeReleaseMutex (&LdtMutex, FALSE);
    ASSERT ((MutexState == 0));

    if (OldLdt != NULL) {
        ExFreePool (OldLdt);
    }

    if (LdtInfo != NULL) {
        ExFreePool (LdtInfo);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\cleanup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Raw called by the
    dispatch driver.

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawCleanup)
#endif


NTSTATUS
RawCleanup (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine for cleaning up a handle.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the read

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  This is a Cleanup operation.  All we have to do is deal with
    //  share access.
    //

    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    IoRemoveShareAccess( IrpSp->FileObject, &Vcb->ShareAccess );

    //
    //  If the volume has been dismounted then the close count should be one.
    //  we will let the volume dismount complete at this point if so.
    //

    if (FlagOn( Vcb->VcbState,  VCB_STATE_FLAG_DISMOUNTED )) {

        ASSERT( Vcb->OpenCount == 1 );

        //
        //  Float this Vcb and Vpb while we wait for the close.  
        //  We know the Vcb won't go away in this call because our
        //  reference keeps the OpenCount above zero.
        //

        RawCheckForDismount( Vcb, FALSE );
    }

    (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );

    RawCompleteRequest( Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\close.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Raw called by the
    dispatch driver.

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawClose)
#endif

NTSTATUS
RawClose (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine for closing a volume.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the read

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN DeleteVolume = FALSE;

    PAGED_CODE();

    //
    //  This is a close operation.  If it is the last one, dismount.
    //

    //
    // Skip stream files as they are unopened fileobjects.
    // This might be a close from IopInvalidateVolumesForDevice
    // 
    if (IrpSp->FileObject->Flags & FO_STREAM_FILE) {
        RawCompleteRequest( Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    Vcb->OpenCount -= 1;

    if (Vcb->OpenCount == 0) {

        DeleteVolume = RawCheckForDismount( Vcb, FALSE );
    }

    if (!DeleteVolume) {
        (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );
    }

    RawCompleteRequest( Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ps\i386\psctx386.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    psctx.c

Abstract:

    This procedure implements Get/Set Context Thread

Note