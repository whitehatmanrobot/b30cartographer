ULL;
CRITICAL_SECTION ShareDelContextMutex;

GENERIC_MAPPING SrvShareFileGenericMapping = GENERIC_SHARE_FILE_ACCESS_MAPPING;

//
// Forward declarations.
//

PVOID
CaptureShareInfo (
    IN DWORD Level,
    IN PSHARE_INFO_2 Shi2,
    IN DWORD ShareType,
    IN LPWSTR Path,
    IN LPWSTR Remark,
    IN PSECURITY_DESCRIPTOR ConnectSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR FileSecurityDescriptor OPTIONAL,
    OUT PULONG CapturedBufferLength
    );

NET_API_STATUS
DisallowSharedLanmanNetDrives(
    IN PUNICODE_STRING NtSharePath
    );

NET_API_STATUS
ShareAssignSecurityDescriptor(
            IN PSECURITY_DESCRIPTOR PassedSecurityDescriptor,
            OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor
            );

NET_API_STATUS
ShareEnumCommon (
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL,
    IN LPWSTR NetName OPTIONAL
    );

NET_API_STATUS
ShareEnumSticky (
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

ULONG
SizeShares (
    IN ULONG Level,
    IN PSHARE_INFO_502 Shi502
    );

BOOLEAN
ValidSharePath(
    IN LPWSTR SharePath,
    IN BOOL   IsNtPath
    );


NET_API_STATUS NET_API_FUNCTION
NetrShareAdd (
    IN LPWSTR ServerName,
    IN DWORD Level,
    IN LPSHARE_INFO Buffer,
    OUT LPDWORD ErrorParameter
    )
{
    return I_NetrShareAdd( ServerName, Level, Buffer, ErrorParameter, FALSE );
}

NET_API_STATUS NET_API_FUNCTION
I_NetrShareAdd (
    IN LPWSTR ServerName,
    IN DWORD Level,
    IN LPSHARE_INFO Buffer,
    OUT LPDWORD ErrorParameter,
    IN BOOLEAN BypassSecurity
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetShareAdd function.  Only levels 2 and 502 are valid.

Arguments:

    ServerName - name of the server.
    Level - Request level.
    Buffer - Contains the information about the share.  If this is a level
        502 request, will also contain a valid security descriptor in
        self-relative form.
    ErrorParameter - status of the FsControl call.
    BypassSecurity - skip security checks

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    NTSTATUS status;
    PSERVER_REQUEST_PACKET srp;
    PVOID capturedBuffer;
    LPWSTR path;
    LPWSTR netName;
    LPWSTR remark;
    ULONG bufferLength;
    UNICODE_STRING dosSharePath;
    UNICODE_STRING ntSharePath;

    PSRVSVC_SECURITY_OBJECT securityObject;
    PSECURITY_DESCRIPTOR connectSecurityDescriptor;
    PSECURITY_DESCRIPTOR fileSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR newFileSecurityDescriptor = NULL;

    UINT driveType = DRIVE_FIXED;
    DWORD shareType;

    BOOL isIpc;
    BOOL isAdmin;
    BOOL isDiskAdmin;
    BOOL isPrintShare;
    BOOL isSpecial;
    BOOL isNtPath;
    BOOL isTemporary;
    BOOL FreeFileSecurityDescriptor;

    PSHARE_INFO_2 shi2;
    PSHARE_INFO_502 shi502;

    ServerName;

    //
    // Check that user input buffer is not NULL
    //
    if ( !ARGUMENT_PRESENT( Buffer ) || Buffer->ShareInfo2 == NULL) {
        SET_ERROR_PARAMETER(PARM_ERROR_UNKNOWN);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set up for error cleanup.
    //

    srp = NULL;
    dosSharePath.Buffer = NULL;
    ntSharePath.Buffer = NULL;
    capturedBuffer = NULL;
    FreeFileSecurityDescriptor = FALSE;

    //
    // Extract Internal buffer information.
    //

    shi2 = Buffer->ShareInfo2;

    //
    // 502 may contain a security descriptor.
    //

    if ( Level == 502 ) {

        shi502 = (LPSHARE_INFO_502) Buffer->ShareInfo502;
        fileSecurityDescriptor = shi502->shi502_security_descriptor;

        //
        // check the reserved field.  If it is zero, this was called from
        // inside the srvsvc. If not, it was through rpc.
        //

        if ( fileSecurityDescriptor != NULL ) {

            if ( !RtlValidSecurityDescriptor( fileSecurityDescriptor ) ) {
                SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
                error = ERROR_INVALID_PARAMETER;
                goto exit;
            }

            if ( shi502->shi502_reserved != 0 ) {

                error = ShareAssignSecurityDescriptor(
                                        fileSecurityDescriptor,
                                        &newFileSecurityDescriptor
                                        );

                if ( error != NO_ERROR ) {

                    SS_PRINT(( "NetrShareAdd: ShareAssignSecurityDescriptor "
                                "error: %d\n", error ));

                    SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
                    error = ERROR_INVALID_PARAMETER;
                    goto exit;
                }

                FreeFileSecurityDescriptor = TRUE;

            } else {
                newFileSecurityDescriptor = fileSecurityDescriptor;
            }
        } else {
            fileSecurityDescriptor = SsDefaultShareSecurityObject.SecurityDescriptor;
            newFileSecurityDescriptor = fileSecurityDescriptor;
        }

    } else if ( Level != 2 ) {

        //
        // The only valid levels are 2 and 502. 2 is a subset of 502.
        //

        error = ERROR_INVALID_LEVEL;
        goto exit;
    }
    else
    {
        // For level 2, default to the default security descriptor
        fileSecurityDescriptor = SsDefaultShareSecurityObject.SecurityDescriptor;
        newFileSecurityDescriptor = fileSecurityDescriptor;
    }

    //
    // A share name must be specified.
    //

    netName = shi2->shi2_netname;

    if ( (netName == NULL) || (*netName == '\0') ) {
        SET_ERROR_PARAMETER( SHARE_NETNAME_PARMNUM );
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Limit it to NNLEN
    //

    if ( wcslen(netName) > NNLEN ) {
        SET_ERROR_PARAMETER( SHARE_NETNAME_PARMNUM );
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // If this is the IPC$ share, or the ADMIN$ share, no path
    // may be specified.  No path is needed for the IPC$ share, while a path
    // is supplied internally for the ADMIN$ share.
    //

    path = shi2->shi2_path;
    remark = shi2->shi2_remark;
    shareType = (shi2->shi2_type & ~(STYPE_TEMPORARY));


    //
    // Figure out which kind of share this is.
    //

    isIpc = (BOOL)(STRICMP( netName, IPC_SHARE_NAME ) == 0);
    isAdmin = (BOOL)(STRICMP( netName, ADMIN_SHARE_NAME ) == 0);
    isTemporary = (BOOL)(shi2->shi2_type & STYPE_TEMPORARY);
    isNtPath = IS_NTPATH_NAME( path );

    // For NTPaths, we only allow disk-style shares
    if( isNtPath && (shareType != STYPE_DISKTREE) )
    {
        SET_ERROR_PARAMETER( SHARE_TYPE_PARMNUM );
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // We have an administrative disk share if the share name is a drive letter
    // followed by $, and if the path name is the root of that same drive.
    //
    if( wcslen( netName ) == 2 && netName[1] == L'$' &&
        TOUPPER( netName[0] ) >= L'A' && TOUPPER( netName[0]) <= L'Z' &&
        path != NULL && wcslen( path ) == 3 &&
        TOUPPER( path[0] ) == TOUPPER( netName[0] ) &&
        path[1] == L':' && path[2] == L'\\' ) {
        //
        // The share name and path look to be an administrative disk share.
        // If the path refers to a fixed drive, then it really is one.
        //
        isDiskAdmin = ((SsGetDriveType( path ) == DRIVE_FIXED) ||
                       (SsGetDriveType( path ) == DRIVE_CDROM) ||
                       (SsGetDriveType( path ) == DRIVE_REMOVABLE));
    } else {
        isDiskAdmin = FALSE;
    }

    isPrintShare = (BOOL)(shareType == STYPE_PRINTQ);

    isSpecial = isIpc || isAdmin || isDiskAdmin;

    if ( isIpc ) {

        if ( path != NULL ) {
            SET_ERROR_PARAMETER( SHARE_PATH_PARMNUM );
            error = ERROR_INVALID_PARAMETER;
            goto exit;
        }
        path = NULL;

        //
        // Let the caller specify a remark if they want.  If they don't,
        // supply a default remark.
        //

        if ( remark == NULL ) {
            remark = SsIPCShareRemark;
        }

        shareType = STYPE_IPC;

    } else if ( isAdmin ) {

        if ( path != NULL ) {
            SET_ERROR_PARAMETER( SHARE_PATH_PARMNUM );
            error = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        //
        // Let the caller specify a remark if they want.  If they don't,
        // supply a default remark.
        //

        if ( remark == NULL ) {
            remark = SsAdminShareRemark;
        }

        shareType = STYPE_DISKTREE;

        //
        // For the ADMIN$ share, we set the path to the system root
        // directory.  We get this from from the kernel via the
        // read-only shared page (USER_SHARED_DATA)
        //

        path = USER_SHARED_DATA->NtSystemRoot;

    } else {

        //
        // For all shares other than IPC$ and ADMIN$, a path must be
        // specified and must not have .. and . as directory names.
        //

        if ( (path == NULL) || (*path == '\0') || !ValidSharePath( path, isNtPath ) ) {
            SET_ERROR_PARAMETER( SHARE_PATH_PARMNUM );
            error = ERROR_INVALID_NAME;
            goto exit;
        }

        //
        // If we've got a disk admin share and they didn't supply a
        //  comment, use the built in one
        //
        if( isDiskAdmin && remark == NULL ) {
            remark = SsDiskAdminShareRemark;
        }
    }

    //
    // The remark must be no longer than MAXCOMMENTSZ.
    //

    if ( (remark != NULL) && (STRLEN(remark) > MAXCOMMENTSZ) ) {
        SET_ERROR_PARAMETER( SHARE_REMARK_PARMNUM );
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // If the server service is fully started, make sure that the caller
    // is allowed to set share information in the server.  We only do
    // this if the service is started--the default share and configured
    // share creations done during initialization do not need any
    // special access.
    //

    if ( SsData.SsInitialized && BypassSecurity == FALSE ) {

        if ( isSpecial ) {
            securityObject = &SsShareAdminSecurityObject;
        } else if ( isPrintShare ) {
            securityObject = &SsSharePrintSecurityObject;
        } else {
            securityObject = &SsShareFileSecurityObject;
        }

        error = SsCheckAccess( securityObject, SRVSVC_SHARE_INFO_SET );

        if ( error != NO_ERROR ) {
            SET_ERROR_PARAMETER( 0 );
            goto exit;
        }

    }

    //
    // If this is a disk share, make sure that the drive is a type that
    // can be shared.
    //

    if ( (shareType == STYPE_DISKTREE) && !isAdmin ) {

        DWORD pathType;

        //
        // Check the path type.  It should be an absolute directory path.
        // We do not check the path type for Nt Paths
        //

        if( !isNtPath )
        {
            error = NetpPathType(
                               NULL,
                               path,
                               &pathType,
                               0
                               );

            if ( (error != NO_ERROR) || (pathType != ITYPE_PATH_ABSD) ) {
                error = ERROR_INVALID_NAME;
                SET_ERROR_PARAMETER( SHARE_PATH_PARMNUM );
                goto exit;
            }
        }

        driveType = SsGetDriveType( path );

        if ( driveType == DRIVE_REMOVABLE ) {

            shareType = STYPE_REMOVABLE;

        } else if ( driveType == DRIVE_CDROM ) {

            shareType = STYPE_CDROM;

        } else if ( !(driveType == DRIVE_REMOTE &&
                     SsData.ServerInfo599.sv599_enablesharednetdrives) &&
                    driveType != DRIVE_FIXED &&
                    driveType != DRIVE_RAMDISK ) {

            if ( driveType == DRIVE_REMOTE ) {
                error = NERR_RedirectedPath;
            } else {
                error = NERR_UnknownDevDir;
            }
            SET_ERROR_PARAMETER( SHARE_PATH_PARMNUM );
            goto exit;
        }
    }

    //
    // Set up the request packet.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    srp->Level = Level;

    //
    // Get the path name in NT format and put it in the SRP.
    //

    if ( path != NULL ) {

        RtlInitUnicodeString( &dosSharePath, path );

        if ( !RtlDosPathNameToNtPathName_U(
                  dosSharePath.Buffer,
                  &ntSharePath,
                  NULL,
                  NULL ) ) {
            SET_ERROR_PARAMETER( SHARE_PATH_PARMNUM );
            error = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        //
        // If this is a redirected drive, make sure the redir is not
        // LanMan.
        //

        if ( driveType == DRIVE_REMOTE ) {

            error = DisallowSharedLanmanNetDrives( &ntSharePath );

            if ( error != NERR_Success ) {
                SET_ERROR_PARAMETER( SHARE_PATH_PARMNUM );
                goto exit;
            }

        } // if remote drive

        srp->Name1 = ntSharePath;
    }

    //
    // Determine whether this is an admin share and use the appropriate
    // security descriptor.
    //

    if ( isAdmin || isDiskAdmin ) {
        connectSecurityDescriptor = SsShareAdmConnectSecurityObject.SecurityDescriptor;
    } else {
        connectSecurityDescriptor = SsShareConnectSecurityObject.SecurityDescriptor;
    }

    //
    // If this is a disk share, verify that the directory to be shared
    // exists and that the caller has access.  (Don't do the access
    // check during server startup.) Don't check the admin$ share -- we
    // know it exists.  Skip removable type disks.
    //

    if ( !isAdmin &&
         (shareType == STYPE_DISKTREE) &&
         (shi2->shi2_path != NULL) ) {

        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK iosb;
        HANDLE handle = INVALID_HANDLE_VALUE;
        NTSTATUS status;

        if ( SsData.SsInitialized && BypassSecurity == FALSE &&
           (error = RpcImpersonateClient(NULL)) != NO_ERROR ) {
                goto exit;
        }

        InitializeObjectAttributes(
            &objectAttributes,
            &ntSharePath,
            OBJ_CASE_INSENSITIVE,
            0,
            NULL
            );

        status = NtOpenFile(
                    &handle,
                    FILE_LIST_DIRECTORY,
                    &objectAttributes,
                    &iosb,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT
                    );

        if( status == STATUS_INVALID_PARAMETER ) {
            status = NtOpenFile(
                    &handle,
                    FILE_LIST_DIRECTORY,
                    &objectAttributes,
                    &iosb,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );
        }

        if ( SsData.SsInitialized && BypassSecurity == FALSE ) {
            (VOID)RpcRevertToSelf( );
        }

        if ( !NT_SUCCESS(status) ) {

            if ( SsData.SsInitialized || (status != STATUS_ACCESS_DENIED) ) {

                //
                // During startup, if the directory does not
                // exist (renamed/deleted), log an event.
                //

                if ( !SsData.SsInitialized &&
                     ((status == STATUS_OBJECT_NAME_NOT_FOUND) ||
                      (status == STATUS_OBJECT_PATH_NOT_FOUND)) ) {

                    LPWSTR subStrings[2];
                    subStrings[0] = netName;
                    subStrings[1] = shi2->shi2_path;

                    SsLogEvent(
                        EVENT_SRV_CANT_RECREATE_SHARE,
                        2,
                        subStrings,
                        NO_ERROR
                        );

                }

                SET_ERROR_PARAMETER( 0 );
                error = RtlNtStatusToDosError( status );
                goto exit;
            }

        } else if( !IS_SLASH_SLASH_NAME( path ) ) {

            if ( SsData.SsInitialized ) {

                FILE_FS_ATTRIBUTE_INFORMATION fileFsAttributeInformation;

                RtlZeroMemory( &fileFsAttributeInformation, sizeof( fileFsAttributeInformation ));

                status = NtQueryVolumeInformationFile( handle,
                                                       &iosb,
                                                       &fileFsAttributeInformation,
                                                       sizeof( fileFsAttributeInformation ),
                                                       FileFsAttributeInformation
                                                     );

                if( (status == STATUS_SUCCESS || status == STATUS_BUFFER_OVERFLOW) &&
                    !(fileFsAttributeInformation.FileSystemAttributes &
                      FILE_SUPPORTS_REPARSE_POINTS) ) {

                    //
                    // Query the name from the file system.  This is because some
                    // fs like fat uses only upper case oem names.  This can cause
                    // a problem because some oem characters do not have upper case
                    // equivalents and thus get mapped to something funny.
                    //
                    // We do not do this if the filesystem supports reparse points, since
                    //  we will come up with the wrong name!
                    //

                    PFILE_NAME_INFORMATION fileNameInformation;
                    ULONG fileInfoSize;
                    ULONG fileNameLength;

                    fileInfoSize =  sizeof(FILE_NAME_INFORMATION) + SIZE_WSTR( path );

                    fileNameInformation = MIDL_user_allocate( fileInfoSize );

                    if ( fileNameInformation == NULL ) {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        NtClose( handle );
                        goto exit;
                    }


                    status = NtQueryInformationFile(
                                                handle,
                                                &iosb,
                                                fileNameInformation,
                                                fileInfoSize,
                                                FileNameInformation
                                                );


                    if ( status == STATUS_SUCCESS ) {

                        //
                        // The file name returned is expected to be
                        // 3 characters shorter than the share path length.
                        // These 3 characters are "X", ":", "\0".
                        //
                        // If the lengths do not match, than this could be a mounted
                        // FAT volume on an NTFS drive, so we only copy the necessary data
                        //

                        fileNameLength = fileNameInformation->FileNameLength;

                        if ((fileNameLength+3*sizeof(WCHAR)) <= SIZE_WSTR(path)) {

                            //
                            // Copy the path name
                            //

                            RtlCopyMemory(
                                    (LPBYTE) path + 2*sizeof(WCHAR) + (SIZE_WSTR(path) - (fileNameLength+3*sizeof(WCHAR))),
                                    fileNameInformation->FileName,
                                    fileNameLength
                                    );

                            path[fileNameLength/sizeof(WCHAR)+2+(SIZE_WSTR(path) - (fileNameLength+3*sizeof(WCHAR)))/sizeof(WCHAR)] = L'\0';
                        }
                    }

                    MIDL_user_free( fileNameInformation );
                }
            }

            NtClose( handle );

        } else {

            NtClose( handle );
        }
    }

    //
    // Capture the share data structure passed in.
    //

    if ( isSpecial ) {
        shareType |= STYPE_SPECIAL;
    }
    if ( isTemporary ) {
        shareType |= STYPE_TEMPORARY;
    }

    capturedBuffer = CaptureShareInfo(
                        Level,
                        shi2,
                        shareType,
                        path,
                        remark,
                        connectSecurityDescriptor,
                        newFileSecurityDescriptor,
                        &bufferLength
                        );

    if ( capturedBuffer == NULL ) {
        SET_ERROR_PARAMETER( 0 );
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Send the request on to the server.
    //

    error = SsServerFsControl(
                FSCTL_SRV_NET_SHARE_ADD,
                srp,
                capturedBuffer,
                bufferLength
                );

    SET_ERROR_PARAMETER( srp->Parameters.Set.ErrorParameter );

    //
    // If the request succeeded, add a value to the Shares key, thus
    // effecting a sticky share.  We only do this if the server is fully
    // started -- the default share and configured share creations done
    // during initialization should not be added to the registry.
    //
    // Don't do this if this is an admin share being [re]created.
    //

    if ( SsData.SsInitialized &&
         (error == NO_ERROR) &&
         !isSpecial &&
         !isTemporary ) {
        SsAddShareToRegistry( shi2, newFileSecurityDescriptor, 0 );
    }

    //
    // If a print share was successfully added, increment the number
    // of print shares and update the exported (announced) server type.
    //

    if ( isPrintShare ) {
        InterlockedIncrement( &SsData.NumberOfPrintShares );
        SsSetExportedServerType( NULL, FALSE, TRUE );
    }

exit:

    //
    // Clean up.  Free the share data structure that was allocated by
    // CaptureShareInfo2.  Free the server request packet.  If there was
    // an NT path name allocated by RtlDosPathNameToNtPathName, free it.
    // If we created ADMIN$, free the system path string and the system
    // path information buffer.
    //

    if (FreeFileSecurityDescriptor) {

        (VOID) RtlDeleteSecurityObject ( &newFileSecurityDescriptor );
    }

    if ( capturedBuffer != NULL ) {
        MIDL_user_free( capturedBuffer );
    }

    if ( srp != NULL ) {
        SsFreeSrp( srp );
    }

    if ( ntSharePath.Buffer != NULL ) {
        RtlFreeUnicodeString( &ntSharePath );
    }
    return error;

} // NetrShareAdd


NET_API_STATUS
NetrShareCheck (
    IN LPWSTR ServerName,
    IN LPWSTR Device,
    OUT LPDWORD Type
    )

/*++

Routine Description:

    This routine implements NetShareCheck by calling NetrShareEnum.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    DWORD totalEntries;
    DWORD entriesRead;
    ULONG i;
    PSHARE_INFO_2 shi2;
    NET_API_STATUS error;
    LPBYTE buffer = NULL;

    ServerName;

    //
    // Call ShareEnumCommon to actually get the information about what
    // the shares are on the server.  We use this routine rather than
    // calling NetrShareEnum because NetShareCheck requires no privilege
    // to execute, and we don't want the security checks in
    // NetrShareEnum.
    //

    error = ShareEnumCommon(
                2,
                &buffer,
                (DWORD)-1,
                &entriesRead,
                &totalEntries,
                NULL,
                NULL
                );

    if ( error != NO_ERROR ) {
        if( buffer ) {
            MIDL_user_free( buffer );
        }
        return error;
    }

    SS_ASSERT( totalEntries == entriesRead );

    //
    // Attempt to find the drive letter in a share's path name.
    //

    for ( shi2 = (PSHARE_INFO_2)buffer, i = 0; i < totalEntries; shi2++, i++ ) {

        if ( shi2->shi2_path != NULL && Device && *Device == *shi2->shi2_path ) {

            //
            // Something on the specified disk is shared--free the buffer
            // and return the type of share.
            //

            *Type = shi2->shi2_type & ~STYPE_SPECIAL;
            MIDL_user_free( buffer );

            return NO_ERROR;
        }
    }

    //
    // Nothing on the specified disk is shared.  Return an error.
    //

    MIDL_user_free( buffer );
    return NERR_DeviceNotShared;

} // NetrShareCheck

NET_API_STATUS NET_API_FUNCTION
NetrShareDel (
    IN LPWSTR ServerName,
    IN LPWSTR NetName,
    IN DWORD Reserved
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetShareDel function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    SHARE_DEL_HANDLE handle;

    error = I_NetrShareDelStart( ServerName, NetName, Reserved, &handle, TRUE );

    if ( error == NO_ERROR ) {
        error = NetrShareDelCommit( &handle );
    }

    return error;

} // NetrShareDel

NET_API_STATUS NET_API_FUNCTION
NetrShareDelStart (
    IN LPWSTR ServerName,
    IN LPWSTR NetName,
    IN DWORD Reserved,
    IN PSHARE_DEL_HANDLE ContextHandle
    )
{
    return I_NetrShareDelStart( ServerName, NetName, Reserved, ContextHandle, TRUE );
}


NET_API_STATUS NET_API_FUNCTION
I_NetrShareDelStart (
    IN LPWSTR ServerName,
    IN LPWSTR NetName,
    IN DWORD Reserved,
    IN PSHARE_DEL_HANDLE ContextHandle,
    IN BOOLEAN CheckAccess
    )

/*++

Routine Description:

    This routine implements the first phase of the share deletion
    function, which simply remembers that the specified share is to be
    deleted.  The NetrShareDelCommit function actually deletes the
    share.  This two-phase deletion is used to delete IPC$, which is
    the share used for named pipes, so that RPC can be used to delete
    the IPC$ share without receiving RPC errors.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSHARE_INFO_2 shareInfo = NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD shareType;
    BOOL isPrintShare;
    BOOL isSpecial;
    PSRVSVC_SECURITY_OBJECT securityObject;
    PSHARE_DEL_CONTEXT context;

    ServerName, Reserved;

    //
    // A share name must be specified.
    //

    if ( (NetName == NULL) || (*NetName == '\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First determine what kind of share is being deleted.
    //

    error = ShareEnumCommon(
                2,
                (LPBYTE *)&shareInfo,
                (DWORD)-1,
                &entriesRead,
                &totalEntries,
                NULL,
                NetName
                );

    if ( error != NO_ERROR ) {
        if( shareInfo ) {
            MIDL_user_free( shareInfo );
        }
        return error;
    }

    if ( entriesRead == 0 ) {
        if( shareInfo ) {
            MIDL_user_free( shareInfo );
        }
        return NERR_NetNameNotFound;
    }

    shareType = shareInfo->shi2_type & ~STYPE_SPECIAL;
    isSpecial = (BOOL)((shareInfo->shi2_type & STYPE_SPECIAL) != 0);

    isPrintShare = (BOOL)(shareType == STYPE_PRINTQ);

    MIDL_user_free( shareInfo );

    //
    // Make sure that the caller is allowed to delete this share.
    //

    if( CheckAccess ) {
        if ( isSpecial ) {
            securityObject = &SsShareAdminSecurityObject;
        } else if ( isPrintShare ) {
            securityObject = &SsSharePrintSecurityObject;
        } else {
            securityObject = &SsShareFileSecurityObject;
        }

        error = SsCheckAccess( securityObject, SRVSVC_SHARE_INFO_SET );

        if ( error != NO_ERROR ) {
            return error;
        }
    }

    //
    // Set up context for the commit phase.
    //

    context = MIDL_user_allocate(
                sizeof(SHARE_DEL_CONTEXT) +
                    wcslen(NetName)*sizeof(WCHAR) + sizeof(WCHAR)
                );

    if ( context == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory(
        context,
        sizeof(SHARE_DEL_CONTEXT) +
            wcslen(NetName)*sizeof(WCHAR) + sizeof(WCHAR)
        );

    context->IsPrintShare = isPrintShare;
    context->IsSpecial = isSpecial;

    wcscpy( (LPWSTR)(context + 1), NetName );

    RtlInitUnicodeString( &context->Srp.Name1, (LPWSTR)(context + 1) );

    // Insert it into the context list
    EnterCriticalSection( &ShareDelContextMutex );

    context->Next = SrvShareDelContextHead;
    SrvShareDelContextHead = context;

    LeaveCriticalSection( &ShareDelContextMutex );

    //
    // Return the context pointer as an RPC context handle.
    //

    *ContextHandle = context;

    return NO_ERROR;

} // I_NetrShareDelStart


NET_API_STATUS NET_API_FUNCTION
NetrShareDelCommit (
    IN PSHARE_DEL_HANDLE ContextHandle
    )

/*++

Routine Description:

    This routine implements the second phase of the share deletion
    function, which actually deletes the share.  The first phase,
    NetrShareDelStart simply remembers that the share is to be deleted.
    This two-phase deletion is used to delete IPC$, which is the share
    used for named pipes, so that RPC can be used to delete the IPC$
    share without receiving RPC errors.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSHARE_DEL_CONTEXT context;
    PSHARE_DEL_CONTEXT pSearch;

    //
    // The context handle is a pointer to allocated storage containing
    // the name of the share being deleted and other useful information.
    // Copy the pointer, then clear the context handle.
    //

    if( (ContextHandle == NULL) || (*ContextHandle == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    context = *ContextHandle;
    *ContextHandle = NULL;

    //
    // Look for this context to validate that its on the list
    //
    EnterCriticalSection( &ShareDelContextMutex );

    pSearch = SrvShareDelContextHead;
    if( pSearch == context )
    {
        SrvShareDelContextHead = pSearch->Next;
        context->Next = NULL;
    }
    else
    {
        while( (pSearch != NULL) && (pSearch->Next != context) )
        {
            pSearch = pSearch->Next;
        }

        if( (pSearch != NULL) && (pSearch->Next == context) )
        {
            pSearch->Next = pSearch->Next->Next;
            context->Next = NULL;
        }
        else
        {
            pSearch = NULL;
        }
    }

    LeaveCriticalSection( &ShareDelContextMutex );

    if( pSearch == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Send the request on to the server.
    //

    error =  SsServerFsControl(
                FSCTL_SRV_NET_SHARE_DEL,
                &context->Srp,
                NULL,
                0
                );

    //
    // If the request succeeded, remove the value corresponding to the
    // share from the Shares key, thus effecting a sticky share
    // deletion.
    //
    // We don't do this if this is an admin share being deleted.  No
    // registry information is kept for these shares.
    //

    if ( (error == NO_ERROR) && !context->IsSpecial ) {
        SsRemoveShareFromRegistry( (LPWSTR)(context + 1) );
    }

    //
    // If a print share was successfully deleted, decrement the number
    // of print shares and update the exported (announced) server type.
    //

    if ( context->IsPrintShare ) {
        InterlockedDecrement( &SsData.NumberOfPrintShares );
        SsSetExportedServerType( NULL, FALSE, TRUE );
    }

    //
    // Free the context.
    //

    MIDL_user_free( context );

    return error;

} // NetrShareDelCommit


NET_API_STATUS NET_API_FUNCTION
NetrShareDelSticky (
    IN LPWSTR ServerName,
    IN LPWSTR NetName,
    IN DWORD Reserved
    )

/*++

Routine Description:

    This routine implements the NetShareDelSticky function.  It removes
    the named share from the sticky share list in the registry.  The
    primary use of this function is to delete a sticky share whose
    root directory has been deleted, thus preventing actual recreation
    of the share, but whose entry still exists in the registry.  It can
    also be used to remove the persistence of a share without deleting
    the current incarnation of the share.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSHARE_INFO_2 shareInfo, shi2;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD shareType;
    ULONG i;
    BOOL isPrintShare;
    PSRVSVC_SECURITY_OBJECT securityObject;

    ServerName, Reserved;


    //
    // A share name must be specified.
    //

    if ( (NetName == NULL) || (*NetName == '\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First determine what kind of share is being deleted.
    //

    error = ShareEnumSticky(
                2,
                (LPBYTE *)&shareInfo,
                (DWORD)-1,
                &entriesRead,
                &totalEntries,
                NULL
                );

    if ( error != NO_ERROR ) {

        return error;

    } else if ( entriesRead == 0 ) {

        return NERR_NetNameNotFound;
    }

    for ( shi2 = shareInfo, i = 0 ; i < entriesRead; i++, shi2++ ) {

        if ( _wcsicmp( shi2->shi2_netname, NetName ) == 0 ) {
            break;
        }
    }

    //
    // Does it exist?
    //

    if ( i == entriesRead ) {
        MIDL_user_free( shareInfo );
        return NERR_NetNameNotFound;
    }

    //
    // Use appropriate security object based on whether it is a print
    // share or not.  Admin shares are not sticky.
    //

    shareType = shi2->shi2_type & ~STYPE_SPECIAL;
    isPrintShare = (BOOL)(shareType == STYPE_PRINTQ);

    MIDL_user_free( shareInfo );

    //
    // Make sure that the caller is allowed to delete this share.
    //

    if ( isPrintShare ) {
        securityObject = &SsSharePrintSecurityObject;
    } else {
        securityObject = &SsShareFileSecurityObject;
    }

    error = SsCheckAccess(
                securityObject,
                SRVSVC_SHARE_INFO_SET
                );

    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Remove the value corresponding to the share from the Shares key,
    // thus effecting a sticky share deletion.
    //

    error = SsRemoveShareFromRegistry( NetName );

    if ( error == ERROR_FILE_NOT_FOUND ) {
        error = NERR_NetNameNotFound;
    }

    return error;

} // NetrShareDelSticky


NET_API_STATUS NET_API_FUNCTION
NetrShareEnum (
    SRVSVC_HANDLE ServerName,
    LPSHARE_ENUM_STRUCT InfoStruct,
    DWORD PreferredMaximumLength,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetShareEnum function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    ACCESS_MASK desiredAccess;

    ServerName;

    if( !ARGUMENT_PRESENT( InfoStruct ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Determine the desired access.
    //

    switch ( InfoStruct->Level ) {

    case 0:
    case 1:
    case 501:
        desiredAccess = SRVSVC_SHARE_USER_INFO_GET;
        break;

    case 2:
    case 502:
        desiredAccess = SRVSVC_SHARE_ADMIN_INFO_GET;
        break;

    default:

        return ERROR_INVALID_LEVEL;
    }

    //
    // Make sure that the caller has the access necessary for this
    // operation.
    //

    error = SsCheckAccess(
                &SsSharePrintSecurityObject,
                desiredAccess
                );

    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Use the common routine to get the information.
    //

    if( InfoStruct->ShareInfo.Level2 == NULL ||
        InfoStruct->ShareInfo.Level2->Buffer != NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    return ShareEnumCommon(
               InfoStruct->Level,
               (LPBYTE *)&InfoStruct->ShareInfo.Level2->Buffer,
               PreferredMaximumLength,
               &InfoStruct->ShareInfo.Level2->EntriesRead,
               TotalEntries,
               ResumeHandle,
               NULL
               );

} // NetrShareEnum


NET_API_STATUS NET_API_FUNCTION
NetrShareEnumSticky (
    SRVSVC_HANDLE ServerName,
    LPSHARE_ENUM_STRUCT InfoStruct,
    DWORD PreferredMaximumLength,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetShareEnumSticky function.

Arguments:

    ServerName - the name of the server whose shares we want to enumerate.
    InfoStruct - pointer to a PSHARE_ENUM_STRUCT that will contain the
        output buffer upon completion.
    PreferredMaximumLength - an advisory value that specifies the maximum
        number of bytes the client is expecting to be returned. If -1, the
        client expects the whole list to be returned.
    TotalEntries - Upon return, will contain the number of entries that
        were available.
    ResumeHandle - is not NULL, will contain the resume handle that can be
        used to continue a search.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    ACCESS_MASK desiredAccess;

    ServerName;

    if( !ARGUMENT_PRESENT( InfoStruct ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( InfoStruct->ShareInfo.Level2 == NULL ||
        InfoStruct->ShareInfo.Level2->Buffer != NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Determine the desired access.
    //

    switch ( InfoStruct->Level ) {

    case 0:
    case 1:
        desiredAccess = SRVSVC_SHARE_USER_INFO_GET;
        break;

    case 2:
    case 502:
        desiredAccess = SRVSVC_SHARE_ADMIN_INFO_GET;
        break;

    default:

        return ERROR_INVALID_LEVEL;
    }

    //
    // Make sure that the caller has the access necessary for this
    // operation.
    //

    error = SsCheckAccess(
                &SsSharePrintSecurityObject,
                desiredAccess
                );

    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Use the common routine to get the information.
    //

    return ShareEnumSticky(
               InfoStruct->Level,
               (LPBYTE *)&InfoStruct->ShareInfo.Level2->Buffer,
               PreferredMaximumLength,
               &InfoStruct->ShareInfo.Level2->EntriesRead,
               TotalEntries,
               ResumeHandle
               );

} // NetrShareEnumSticky


NET_API_STATUS NET_API_FUNCTION
NetrShareGetInfo (
    IN LPWSTR ServerName,
    IN LPWSTR NetName,
    IN  DWORD Level,
    OUT LPSHARE_INFO Buffer
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetShareGetInfo function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSHARE_INFO_2 shareInfo = NULL;
    ULONG entriesRead;
    ULONG totalEntries;
    ACCESS_MASK desiredAccess;

    ServerName;

    //
    // A share name must be specified.
    //

    if ( (NetName == NULL) || (*NetName == '\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Determine the desired access.
    //

    switch ( Level ) {

    case 0:
    case 1:
    case 501:
    case 1005:
        desiredAccess = SRVSVC_SHARE_USER_INFO_GET;
        break;

    case 2:
    case 502:
        desiredAccess = SRVSVC_SHARE_ADMIN_INFO_GET;
        break;

    default:

        return ERROR_INVALID_LEVEL;
    }

    //
    // Make sure that the caller has the access necessary for this
    // operation.
    //

    error = SsCheckAccess(
                &SsSharePrintSecurityObject,
                desiredAccess
                );

    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Use the common routine to get the information.
    //

    error = ShareEnumCommon(
                Level,
                (LPBYTE *)&shareInfo,
                (DWORD)-1,
                &entriesRead,
                &totalEntries,
                NULL,
                NetName
                );

    if ( error != NO_ERROR ) {
        if( shareInfo ) {
            MIDL_user_free( shareInfo );
        }
        return error;
    }
    if ( entriesRead == 0 ) {
        if( shareInfo ) {
            MIDL_user_free( shareInfo );
        }
        return NERR_NetNameNotFound;
    }
    SS_ASSERT( entriesRead == 1 );

    //
    // Make sure that the caller is allowed to get share information on
    // this share.
    //

    if ( Level == 502 ) {
        Buffer->ShareInfo502 = (LPSHARE_INFO_502_I)shareInfo;
    } else {
        Buffer->ShareInfo2 = (LPSHARE_INFO_2)shareInfo;
    }
    return NO_ERROR;

} // NetrShareGetInfo


NET_API_STATUS NET_API_FUNCTION
NetrShareSetInfo (
    IN LPWSTR ServerName,
    IN LPWSTR NetName,
    IN DWORD Level,
    IN LPSHARE_INFO Buffer,
    OUT LPDWORD ErrorParameter OPTIONAL
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetShareSetInfo function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD shareType;
    BOOL isPrintShare;
    BOOL isSpecial;
    PSRVSVC_SECURITY_OBJECT securityObject;
    PVOID capturedBuffer = NULL;
    ULONG bufferLength;

    LPWSTR remark = NULL;
    ULONG maxUses = 0;
    PSECURITY_DESCRIPTOR fileSd = NULL;
    PSECURITY_DESCRIPTOR newFileSd = NULL;

    BOOL setRemark;
    BOOL setFileSd;

    PSHARE_INFO_2 shi2 = NULL;
    SHARE_INFO_2 localShi2;

    ServerName;

    //
    // Check that user input buffer is not NULL
    //
    if (Buffer->ShareInfo2 == NULL) {
        SET_ERROR_PARAMETER(PARM_ERROR_UNKNOWN);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Determine what the caller is trying to set.
    //

    switch ( Level ) {

    case 502:

        fileSd = Buffer->ShareInfo502->shi502_security_descriptor;

        // *** lack of break is intentional!

    case 2:

        maxUses = Buffer->ShareInfo2->shi2_max_uses;

        // *** lack of break is intentional!

    case 1:

        remark = Buffer->ShareInfo2->shi2_remark;

        break;

    case SHARE_REMARK_INFOLEVEL:

        remark = Buffer->ShareInfo1004->shi1004_remark;

        break;

    case SHARE_MAX_USES_INFOLEVEL:

        maxUses = Buffer->ShareInfo1006->shi1006_max_uses;

        break;

    case SHARE_FILE_SD_INFOLEVEL:

        fileSd = Buffer->ShareInfo1501->shi1501_security_descriptor;

        break;

    case 1005:
        Buffer->ShareInfo1005->shi1005_flags &= SHI1005_VALID_FLAGS_SET;
        break;

    default:

        SS_PRINT(( "NetrShareSetInfo: invalid level: %ld\n", Level ));
        SET_ERROR_PARAMETER( 0 );
        return ERROR_INVALID_LEVEL;
    }

    setRemark = (BOOLEAN)( remark != NULL );
    setFileSd = (BOOLEAN)( fileSd != NULL );

    //
    // A share name must be specified.
    //

    if ( (NetName == NULL) || (*NetName == '\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Determine what kind of share is being modified.
    //

    error = ShareEnumCommon(
                2,
                (LPBYTE *)&shi2,
                (DWORD)-1,
                &entriesRead,
                &totalEntries,
                NULL,
                NetName
                );
    if ( error != NO_ERROR ) {
        if( shi2 ) {
            MIDL_user_free( shi2 );
        }
        return error;
    }
    if ( entriesRead == 0 ) {
        if( shi2 ) {
            MIDL_user_free( shi2 );
        }
        return NERR_NetNameNotFound;
    }

    shareType = shi2->shi2_type & ~STYPE_SPECIAL;
    isSpecial = (BOOL)((shi2->shi2_type & STYPE_SPECIAL) != 0);

    MIDL_user_free( shi2 );

    //
    // The share ACL cannot be changed on admin shares.
    //
    if ( isSpecial && setFileSd ) {
        SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
        error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Figure out which kind of share this is.
    //

    isPrintShare = (BOOL)(shareType == STYPE_PRINTQ);

    //
    // Only disk shares can be affected by 1005
    //
    if( Level == 1005 && shareType != STYPE_DISKTREE ) {
        error = ERROR_BAD_DEV_TYPE;
        goto exit;
    }

    if( SsData.SsInitialized ) {

        //
        // Make sure that the caller is allowed to set share information on
        // this share.
        //

        if ( isSpecial ) {
            securityObject = &SsShareAdminSecurityObject;
        } else if ( isPrintShare ) {
            securityObject = &SsSharePrintSecurityObject;
        } else {
            securityObject = &SsShareFileSecurityObject;
        }

        error = SsCheckAccess( securityObject, SRVSVC_SHARE_INFO_SET );

        if ( error != NO_ERROR ) {
            return error;
        }
    }

    //
    // Just return success if not trying to set anything.
    //

    if ( !setRemark && (maxUses == 0) && !setFileSd && Level != 1005 ) {
        return NO_ERROR;
    }

    //
    // The remark must be no longer than MAXCOMMENTSZ.
    //

    if ( setRemark ) {
        if ( STRLEN(remark) > MAXCOMMENTSZ ) {
            SET_ERROR_PARAMETER( SHARE_REMARK_PARMNUM );
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Mapped the security descriptor to remove the generic permissions
    //

    if ( setFileSd ) {

        if ( !RtlValidSecurityDescriptor( fileSd ) ) {
            SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
            return ERROR_INVALID_PARAMETER;
        }

        error = ShareAssignSecurityDescriptor(
                                fileSd,
                                &newFileSd
                                );

        if ( error != NO_ERROR ) {
            SS_PRINT(( "NetrShareSetInfo: ShareAssignSecurityDescriptor "
                        "error: %d\n", error ));
            SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Allocate a request packet.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    srp->Level = Level;

    //
    // Set up the share name.
    //

    RtlInitUnicodeString( &srp->Name1, NetName );

    //
    // Set up the MaxUses field.  If equal to 0, then it won't be changed
    // by the server.
    //

    srp->Parameters.Set.Api.ShareInfo.MaxUses = maxUses;

    //
    // Capture the share data structure passed in.
    //

    localShi2.shi2_netname = NetName;

    switch( Level ) {
    case 1005:
        bufferLength = sizeof(SHARE_INFO_1005);

        capturedBuffer = MIDL_user_allocate( bufferLength );
        if( capturedBuffer == NULL ) {
            SET_ERROR_PARAMETER( 0 );
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        RtlZeroMemory( capturedBuffer, bufferLength );

        *((PSHARE_INFO_1005) capturedBuffer) = *Buffer->ShareInfo1005;
        break;

    default:
        capturedBuffer = CaptureShareInfo(
                            Level,
                            &localShi2,
                            0,      // ShareType, unused for SHARE_SET_INFO
                            NULL,
                            remark,
                            NULL,
                            newFileSd,
                            &bufferLength
                            );

        if ( capturedBuffer == NULL ) {
            SET_ERROR_PARAMETER( 0 );
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        break;
    }

    //
    // Send the request to the server.
    //

    error = SsServerFsControl(
                FSCTL_SRV_NET_SHARE_SET_INFO,
                srp,
                capturedBuffer,
                bufferLength
                );

    //
    // If the request succeeded, modify the share's value in the Shares
    // key, thus effecting a sticky change.
    //
    // We don't do this if this is an admin share being modified.  No
    // registry information is kept for these shares.
    //

    if ( (error == NO_ERROR) && !isSpecial ) {

        DWORD entriesRead;
        DWORD totalEntries;
        NET_API_STATUS error2;

        shi2 = NULL;

        error2 = ShareEnumCommon(
                    2,
                    (LPBYTE *)&shi2,
                    (DWORD)-1,
                    &entriesRead,
                    &totalEntries,
                    NULL,
                    NetName
                    );

        if ( error2 == NO_ERROR ) {

            DWORD CSCFlags = 0;

            if( Level != 1005 ) {
                PSHARE_INFO_501 shi501 = NULL;

                if( ShareEnumCommon(
                            501,
                            (LPBYTE *)&shi501,
                            (DWORD)-1,
                            &entriesRead,
                            &totalEntries,
                            NULL,
                            NetName
                            ) == NO_ERROR && shi501 != NULL ) {

                    CSCFlags = shi501->shi501_flags & CSC_MASK;
                }

                if( shi501 ) {
                    MIDL_user_free( shi501 );
                }

            } else {

                CSCFlags = Buffer->ShareInfo1005->shi1005_flags & CSC_MASK;
            }

            SsAddShareToRegistry( shi2,
                                  newFileSd,
                                  CSCFlags
                                );

        }

        if( shi2 ) {
            MIDL_user_free( shi2 );
        }

    }

    //
    // Set up the error parameter if requested and return.
    //

    SET_ERROR_PARAMETER( srp->Parameters.Set.ErrorParameter );


exit:

    if (srp != NULL) {
        SsFreeSrp( srp );
    }

    if ( newFileSd != NULL ) {
        (VOID)RtlDeleteSecurityObject( &newFileSd );
    }

    if( capturedBuffer != NULL ) {
        MIDL_user_free( capturedBuffer );
    }

    return error;

} // NetrShareSetInfo


PVOID
CaptureShareInfo (
    IN DWORD Level,
    IN PSHARE_INFO_2 Shi2,
    IN DWORD ShareType OPTIONAL,
    IN LPWSTR Path OPTIONAL,
    IN LPWSTR Remark OPTIONAL,
    IN PSECURITY_DESCRIPTOR ConnectSecurityDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR FileSecurityDescriptor OPTIONAL,
    OUT PULONG CapturedBufferLength
    )

{
    PSHARE_INFO_502 capturedShi502;
    ULONG capturedBufferLength;
    PCHAR variableData;
    ULONG pathNameLength;
    ULONG shareNameLength;
    ULONG remarkLength;
    ULONG connectSDLength = 0;
    ULONG fileSdLength = 0;

    //
    // Determine the lengths of the strings in the buffer and the total
    // length of the buffer.
    //

    if ( Shi2->shi2_netname == NULL ) {
        shareNameLength = 0;
    } else {
        shareNameLength = SIZE_WSTR( Shi2->shi2_netname );
    }

    if ( Path == NULL ) {
        pathNameLength = 0;
    } else {
        pathNameLength = SIZE_WSTR( Path );
    }

    if ( Remark == NULL ) {
        remarkLength = 0;
    } else {
        remarkLength = SIZE_WSTR( Remark );
    }

    if ( ARGUMENT_PRESENT( ConnectSecurityDescriptor ) ) {

        //
        // Allocate extra space for the security descriptor since it needs
        // to be longword-aligned and there may be padding in front of it.
        //

        connectSDLength =
            RtlLengthSecurityDescriptor( ConnectSecurityDescriptor ) +
            sizeof(ULONG);
    }

    if ( ARGUMENT_PRESENT( FileSecurityDescriptor ) ) {
        //
        //  ULONG added for alignment.
        //

        fileSdLength = RtlLengthSecurityDescriptor( FileSecurityDescriptor ) +
                       sizeof(ULONG);
    }

    //
    // Allocate a buffer in which to capture the share information.
    //

    capturedBufferLength = sizeof(SHARE_INFO_502) +
                               shareNameLength +
                               remarkLength +
                               pathNameLength +
                               connectSDLength +
                               fileSdLength;

    //
    // Allocate a buffer to hold the input information.
    //

    capturedShi502 = MIDL_user_allocate( capturedBufferLength );

    if ( capturedShi502 == NULL ) {
        *CapturedBufferLength = 0;
        return NULL;
    }

    //
    // Copy over the share info structure.
    //

    *((PSHARE_INFO_2) capturedShi502) = *Shi2;

    //
    // Optionally override the share type.
    //

    if ( ShareType != 0 ) {
        capturedShi502->shi502_type = ShareType;
    }

    //
    // Capture the share name.
    //

    variableData = (PCHAR)( capturedShi502 + 1 );

    if ( shareNameLength != 0 ) {
        capturedShi502->shi502_netname = (LPWSTR)variableData;
        RtlCopyMemory( variableData, Shi2->shi2_netname, shareNameLength );
        variableData += shareNameLength;
    } else {
        capturedShi502->shi502_netname = NULL;
    }

    //
    // Capture the remark.
    //

    if ( remarkLength != 0 ) {
        capturedShi502->shi502_remark = (LPWSTR)variableData;
        RtlCopyMemory( variableData, Remark, remarkLength );
        variableData += remarkLength;
    } else {
        capturedShi502->shi502_remark = NULL;
    }

    //
    // Capture the path.
    //

    if ( pathNameLength > 0 ) {
        capturedShi502->shi502_path = (LPWSTR)variableData;
        RtlCopyMemory( variableData, Path, pathNameLength );
        variableData += pathNameLength;
    } else {
        capturedShi502->shi502_path = NULL;
    }

    //
    // Capture the security descriptor.  Use the shi502_permissions field
    // to contain the offset to the security descriptor in the buffer.
    //

    if ( ARGUMENT_PRESENT( ConnectSecurityDescriptor ) ) {

        variableData = (PCHAR)( ((ULONG_PTR)variableData + 3) & ~3 );

        //
        // Store the offset directly into shi502_permissions now.  The
        // reason is that shi502_permissions is a 32-bit field, insufficient
        // to contain a pointer under Sundown.
        //

        capturedShi502->shi502_permissions = (ULONG)((ULONG_PTR)variableData -
                                                     (ULONG_PTR)capturedShi502);

        RtlCopyMemory(
            variableData,
            ConnectSecurityDescriptor,
            connectSDLength - sizeof(ULONG)
            );

        variableData += (connectSDLength - sizeof(ULONG));

    } else {
        capturedShi502->shi502_permissions = 0;
    }

    //
    // Capture the self relative form of the file security descriptor.
    //

    if ( ARGUMENT_PRESENT( FileSecurityDescriptor ) ) {

        variableData = (PCHAR)( ((ULONG_PTR)variableData + 3) & ~3 );
        capturedShi502->shi502_security_descriptor = (LPBYTE) variableData;
        variableData += ( fileSdLength - sizeof(ULONG)) ;

        RtlCopyMemory(
            (PVOID)capturedShi502->shi502_security_descriptor,
            FileSecurityDescriptor,
            fileSdLength - sizeof(ULONG)
            );

    } else {
        capturedShi502->shi502_security_descriptor = (LPBYTE) NULL;
    }


    //
    // Convert all the pointers in the structure to offsets from the
    // beginning of the structure.
    //

    POINTER_TO_OFFSET( capturedShi502->shi502_netname, capturedShi502 );
    POINTER_TO_OFFSET( capturedShi502->shi502_remark, capturedShi502 );
    POINTER_TO_OFFSET( capturedShi502->shi502_path, capturedShi502 );
    POINTER_TO_OFFSET( (PCHAR)capturedShi502->shi502_security_descriptor, capturedShi502 );

    //
    // Set up the length of the captured buffer to return to the caller
    // and return the captures structure.
    //

    *CapturedBufferLength = capturedBufferLength;

    return capturedShi502;

} // CaptureShareInfo

NET_API_STATUS
DisallowSharedLanmanNetDrives(
    IN PUNICODE_STRING NtSharePath
    )
{
    NET_API_STATUS error = NERR_Success;
    NTSTATUS status;
    HANDLE linkHandle;
    OBJECT_ATTRIBUTES objAttr;
    UNICODE_STRING linkTarget;
    ULONG returnedLength = 0;
    UNICODE_STRING tempNtPath;

    linkTarget.Buffer = NULL;
    linkTarget.MaximumLength = 0;
    linkTarget.Length = 0;
    tempNtPath = *NtSharePath;

    //
    // Remove the trailing '\\'
    //

    tempNtPath.Length -= 2;

    InitializeObjectAttributes(
        &objAttr,
        &tempNtPath,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    status = NtOpenSymbolicLinkObject(
                                &linkHandle,
                                SYMBOLIC_LINK_QUERY,
                                &objAttr
                                );

    if ( !NT_SUCCESS(status) ) {
        return NERR_Success;
    }

    //
    // Get the size of the buffer needed.
    //

    status = NtQuerySymbolicLinkObject(
                                linkHandle,
                                &linkTarget,
                                &returnedLength
                                );

    if ( !NT_SUCCESS(status) && status != STATUS_BUFFER_TOO_SMALL ) {
        NtClose( linkHandle );
        return NERR_Success;
    }

    //
    // Allocate our buffer
    //

    linkTarget.Length = (USHORT)returnedLength;
    linkTarget.MaximumLength = (USHORT)(returnedLength + sizeof(WCHAR));
    linkTarget.Buffer = MIDL_user_allocate( linkTarget.MaximumLength );

    if ( linkTarget.Buffer == NULL ) {
        NtClose( linkHandle );
        return NERR_Success;
    }

    status = NtQuerySymbolicLinkObject(
                                linkHandle,
                                &linkTarget,
                                &returnedLength
                                );

    NtClose( linkHandle );

    if ( NT_SUCCESS(status) ) {

        //
        // See if this is a lanman drive
        //

        if (_wcsnicmp(
                linkTarget.Buffer,
                DD_NFS_DEVICE_NAME_U,
                wcslen(DD_NFS_DEVICE_NAME_U)) == 0) {

            error = NERR_RedirectedPath;
        }
    }

    MIDL_user_free( linkTarget.Buffer );

    return(error);

} // DisallowSharedLanmanNetDrives

NET_API_STATUS
FillStickyShareInfo(
        IN PSRVSVC_SHARE_ENUM_INFO ShareEnumInfo,
        IN PSHARE_INFO_502 Shi502
        )

/*++

Routine Description:

    This routine fills in the output buffer with data from the shi502
    structure.

Arguments:

    ShareEnumInfo - contains the parameters passed in through the
        NetShareEnumSticky api.
    Shi502 - pointer to a shi502 structure

Return Value:

    status of operation.

--*/

{

    PSHARE_INFO_502 newShi502;
    PCHAR endOfVariableData;

    ShareEnumInfo->TotalBytesNeeded += SizeShares(
                                            ShareEnumInfo->Level,
                                            Shi502
                                            );


    //
    // If we have more data but ran out of space, return ERROR_MORE_DATA
    //

    if ( ShareEnumInfo->TotalBytesNeeded >
            ShareEnumInfo->OutputBufferLength ) {
        return(ERROR_MORE_DATA);
    }

    //
    // Transfer data from the share info 502 structure to the output
    // buffer.
    //

    newShi502 = (PSHARE_INFO_502)ShareEnumInfo->StartOfFixedData;
    ShareEnumInfo->StartOfFixedData += FIXED_SIZE_OF_SHARE(ShareEnumInfo->Level);

    endOfVariableData = ShareEnumInfo->EndOfVariableData;

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** This routine assumes that the fixed structure will fit in the
    //     buffer!
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different share structures are
    //     identical.
    //

    switch( ShareEnumInfo->Level ) {

    case 502:

        if ( Shi502->shi502_security_descriptor != NULL ) {

            ULONG fileSDLength;
            fileSDLength = RtlLengthSecurityDescriptor(
                                Shi502->shi502_security_descriptor
                                );

            //
            // DWord Align
            //

            endOfVariableData = (PCHAR) ( (ULONG_PTR) ( endOfVariableData -
                            fileSDLength ) & ~3 );

            newShi502->shi502_security_descriptor = endOfVariableData;
            newShi502->shi502_reserved  = fileSDLength;

            RtlMoveMemory(
                    newShi502->shi502_security_descriptor,
                    Shi502->shi502_security_descriptor,
                    fileSDLength
                    );

        } else {
            newShi502->shi502_security_descriptor = NULL;
            newShi502->shi502_reserved = 0;
        }

    case 2:

        //
        // Set level 2 specific fields in the buffer.  Since this server
        // can only have user-level security, share permissions are
        // meaningless.
        //

        newShi502->shi502_permissions = 0;
        newShi502->shi502_max_uses = Shi502->shi502_max_uses;

        //
        // To get the current uses, we need to query the server for this
        //

        {
            PSHARE_INFO_2 shareInfo = NULL;
            NET_API_STATUS error;
            DWORD entriesRead;
            DWORD totalEntries;

            error = ShareEnumCommon(
                        2,
                        (LPBYTE *)&shareInfo,
                        (DWORD)-1,
                        &entriesRead,
                        &totalEntries,
                        NULL,
                        Shi502->shi502_netname
                        );

            if ( error != NO_ERROR || entriesRead == 0 ) {
                newShi502->shi502_current_uses = 0;
            } else {
                newShi502->shi502_current_uses = shareInfo->shi2_current_uses;
            }

            if( shareInfo ) {
                MIDL_user_free( shareInfo );
            }
        }

        //
        // Copy the DOS path name to the buffer.
        //

        if ( Shi502->shi502_path != NULL ) {
            endOfVariableData -= SIZE_WSTR( Shi502->shi502_path );
            newShi502->shi502_path = (LPTSTR) endOfVariableData;
            wcscpy( newShi502->shi502_path, Shi502->shi502_path );
        } else {
            newShi502->shi502_path = NULL;
        }

        //
        // We don't have per-share passwords (share-level security)
        // so set the password pointer to NULL.
        //

        newShi502->shi502_passwd = NULL;

        // *** Lack of break is intentional!

    case 1:

        newShi502->shi502_type = Shi502->shi502_type;

        //
        // Copy the remark to the buffer.  The routine will handle the
        // case where there is no remark on the share and put a pointer
        // to a zero terminator in the buffer.
        //

        if ( Shi502->shi502_remark != NULL ) {
            endOfVariableData -= SIZE_WSTR( Shi502->shi502_remark );
            newShi502->shi502_remark = (LPTSTR) endOfVariableData;
            wcscpy( newShi502->shi502_remark, Shi502->shi502_remark );
        } else {
            newShi502->shi502_remark = NULL;
        }

        // *** Lack of break is intentional!

    case 0:

        //
        // Copy the share name to the buffer.
        //

        if ( Shi502->shi502_netname != NULL ) {
            endOfVariableData -= SIZE_WSTR( Shi502->shi502_netname );
            newShi502->shi502_netname = (LPTSTR) endOfVariableData;
            wcscpy( newShi502->shi502_netname, Shi502->shi502_netname );
        } else {
            newShi502->shi502_remark = NULL;
        }
        break;
    }

    ShareEnumInfo->EndOfVariableData = endOfVariableData;

    return NO_ERROR;

} // FillStickyShareInfo


NET_API_STATUS
ShareAssignSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR PassedSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor
    )

/*++

Routine Description:

    This routine converts a the generic mappings in an sd to
    standards and specifics.

Arguments:

    PassedSecurityDescriptor - Security descriptor passed from the client.
    NewSecurityDescriptor - Pointer to a buffer to receive the new sd.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{

    NTSTATUS status;
    HANDLE token;
    PISECURITY_DESCRIPTOR_RELATIVE trustedSecurityDescriptor = NULL;
    NET_API_STATUS error;
    ULONG secLen;

    //
    // We don't necessarily trust the security descriptor passed in from the client.
    //  And, since we are going to write to it, we better make sure it is in some
    //  memory that we understand.
    //
    try {
        // We only work with Self-Relative SD's, reject any others
        if( !RtlpAreControlBitsSet((PISECURITY_DESCRIPTOR)PassedSecurityDescriptor, SE_SELF_RELATIVE) )
        {
            return ERROR_INVALID_PARAMETER;
        }

        secLen = RtlLengthSecurityDescriptor( PassedSecurityDescriptor );

        if( secLen < sizeof( *trustedSecurityDescriptor ) ) {
            RaiseException( STATUS_INVALID_PARAMETER, 0, 0, NULL );
        }

        trustedSecurityDescriptor = (PISECURITY_DESCRIPTOR_RELATIVE)MIDL_user_allocate( secLen );
        if( trustedSecurityDescriptor == NULL ) {
            RaiseException( STATUS_INSUFFICIENT_RESOURCES, 0, 0, NULL );
        }

        RtlCopyMemory( trustedSecurityDescriptor, PassedSecurityDescriptor, secLen );

        trustedSecurityDescriptor->Owner = 0;
        trustedSecurityDescriptor->Group = 0;
        trustedSecurityDescriptor->Sacl = 0;
        trustedSecurityDescriptor->Control &=
                (SE_DACL_DEFAULTED | SE_DACL_PRESENT | SE_SELF_RELATIVE | SE_DACL_PROTECTED);

        //
        // Impersonate client
        //

        status = RpcImpersonateClient( NULL );

        if( !NT_SUCCESS( status ) ) {
            RaiseException( status, 0, 0, NULL );
        }

        status = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_QUERY,
                        TRUE,
                        &token
                        );

        (VOID)RpcRevertToSelf( );

        if( !NT_SUCCESS( status ) ) {
            RaiseException( status, 0, 0, NULL );
        }

        //
        // Get a new sd which has the generics mapped to specifics.
        // the returned sd is in self-relative form.
        //

        status = RtlNewSecurityObject(
                                    NULL,
                                    trustedSecurityDescriptor,
                                    NewSecurityDescriptor,
                                    FALSE,
                                    token,
                                    &SrvShareFileGenericMapping
                                    );

        ASSERT( RtlValidSecurityDescriptor( *NewSecurityDescriptor ) );

        NtClose( token );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();
    }

    if( trustedSecurityDescriptor != NULL ) {
        MIDL_user_free( trustedSecurityDescriptor );
    }

    return RtlNtStatusToDosError( status );

} // ShareAssignSecurityDescriptor


void
SHARE_DEL_HANDLE_rundown (
    SHARE_DEL_HANDLE ContextHandle
    )
{
    (VOID)NetrShareDelCommit( &ContextHandle );

    return;

} // SHARE_DEL_HANDLE_rundown


NET_API_STATUS
ShareEnumCommon (
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL,
    IN LPWSTR NetName OPTIONAL
    )

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;

    if( !ARGUMENT_PRESENT( EntriesRead ) || !ARGUMENT_PRESENT( TotalEntries ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure that the level is valid.  Since it is an unsigned
    // value, it can never be less than 0.
    //

    if ( (Level > 2) && (Level != 501 ) && (Level != 502) && (Level != 1005) ) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // Set up the input parameters in the request buffer.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    srp->Level = Level;
    if ( ARGUMENT_PRESENT( NetName ) ) {
        srp->Flags = SRP_RETURN_SINGLE_ENTRY;
    }

    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        srp->Parameters.Get.ResumeHandle = *ResumeHandle;
    } else {
        srp->Parameters.Get.ResumeHandle = 0;
    }

    RtlInitUnicodeString( &srp->Name1, NetName );

    //
    // Get the data from the server.  This routine will allocate the
    // return buffer and handle the case where PreferredMaximumLength ==
    // -1.
    //

    error = SsServerFsControlGetInfo(
                FSCTL_SRV_NET_SHARE_ENUM,
                srp,
                (PVOID *)Buffer,
                PreferredMaximumLength
                );

    //
    // Set up return information.
    //

    *EntriesRead = srp->Parameters.Get.EntriesRead;
    *TotalEntries = srp->Parameters.Get.TotalEntries;
    if ( *EntriesRead > 0 && ARGUMENT_PRESENT( ResumeHandle ) ) {
        *ResumeHandle = srp->Parameters.Get.ResumeHandle;
    }

    SsFreeSrp( srp );

    //
    // We need to null out the owner, group, and sacl.
    //

    if ( Level == 502 && *Buffer != NULL ) {

        PSHARE_INFO_502 shi502 = (PSHARE_INFO_502) *Buffer;
        PSECURITY_DESCRIPTOR fileSD;
        ULONG i;

        for ( i = 0 ; i < *EntriesRead; i++, shi502++ ) {

            fileSD = shi502->shi502_security_descriptor;
            if ( fileSD != NULL ) {

                PISECURITY_DESCRIPTOR SD = fileSD;

                if (SD->Control & SE_SELF_RELATIVE) {
                    PISECURITY_DESCRIPTOR_RELATIVE SDR = fileSD;

                    SDR->Owner = 0;
                    SDR->Group = 0;
                    SDR->Sacl = 0;

                } else {

                    SD->Owner = NULL;
                    SD->Group = NULL;
                    SD->Sacl  = NULL;

                }

                SD->Control &=
                    (SE_DACL_DEFAULTED | SE_DACL_PROTECTED | SE_DACL_PRESENT | SE_SELF_RELATIVE);

                ASSERT( RtlValidSecurityDescriptor( fileSD ) );
            }

        } // for
    }

    return error;

} // ShareEnumCommon


NET_API_STATUS
ShareEnumSticky (
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    This routine enumerates all the shares kept in the registry.

Arguments:

    Same as NetShareEnumSticky api.

Return Value:

    status of request.

--*/

{
    NET_API_STATUS error;
    BOOLEAN getEverything;
    ULONG oldResumeHandle;
    SRVSVC_SHARE_ENUM_INFO enumInfo;

    //
    // Set up the input parameters in the request buffer.
    //

    enumInfo.Level = Level;
    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        enumInfo.ResumeHandle = *ResumeHandle;
    } else {
        enumInfo.ResumeHandle = 0;
    }

    oldResumeHandle = enumInfo.ResumeHandle;

    //
    // If the length of the second buffer is specified as -1, then we
    // are supposed to get all the information, regardless of size.
    // Allocate space for the output buffer and try to use it.  If this
    // fails, the SsEnumerateStickyShares will tell us just how much we
    // really need to allocate.
    //

    if ( PreferredMaximumLength == 0xFFFFFFFF ) {

        enumInfo.OutputBufferLength = INITIAL_BUFFER_SIZE;
        getEverything = TRUE;

    } else {

        enumInfo.OutputBufferLength = PreferredMaximumLength;
        getEverything = FALSE;
    }

    enumInfo.OutputBuffer = MIDL_user_allocate( enumInfo.OutputBufferLength );

    if ( enumInfo.OutputBuffer == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Make the request
    //

    error = SsEnumerateStickyShares( &enumInfo );

    //
    // If the call was successful, or there was an error other than
    // ERROR_MORE_DATA (which indicates that the buffer wasn't large
    // enough), or the passed in buffer size was all we're allowed to
    // allocate, return to the caller.
    //

    if ( (error != ERROR_MORE_DATA && error != NERR_BufTooSmall) ||
             !getEverything ) {

        //
        // If no entries were found, free the buffer and set the pointer
        // to NULL.
        //

        if ( enumInfo.EntriesRead == 0 ) {
            MIDL_user_free( enumInfo.OutputBuffer );
            enumInfo.OutputBuffer = NULL;
        }

        goto exit;
    }

    //
    // The initial buffer wasn't large enough, and we're allowed to
    // allocate more.  Free the first buffer.
    //

    MIDL_user_free( enumInfo.OutputBuffer );

    //
    // Allocate a buffer large enough to hold all the information, plus
    // a fudge factor in case the amount of information has increased.
    // If the amount of information increased more than the fudge factor,
    // then we give up.  This should almost never happen.
    //

    enumInfo.OutputBufferLength = enumInfo.TotalBytesNeeded + EXTRA_ALLOCATION;

    enumInfo.OutputBuffer = MIDL_user_allocate( enumInfo.OutputBufferLength );

    if ( enumInfo.OutputBuffer == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Reset the resume handle in the SRP.  It was altered by the first
    // Enum attempt.
    //

    enumInfo.ResumeHandle = oldResumeHandle;

    //
    // Try again to get the information from the server, this time with the
    // larger buffer.
    //

    error = SsEnumerateStickyShares( &enumInfo );

exit:
    //
    // Set up return information.
    //

    *Buffer = enumInfo.OutputBuffer;
    *EntriesRead = enumInfo.EntriesRead;
    *TotalEntries = enumInfo.TotalEntries;
    if ( *EntriesRead > 0 && ARGUMENT_PRESENT( ResumeHandle ) ) {
        *ResumeHandle = enumInfo.ResumeHandle;
    }

    return error;

} // ShareEnumSticky


ULONG
SizeShares (
    IN ULONG Level,
    IN PSHARE_INFO_502 Shi502
    )

/*++

Routine Description:

    This routine returns the size the passed-in share would take up in
    an API output buffer.

Arguments:

    Level - level of request
    Shi502 - pointer to a shi502 structure

Return Value:

    ULONG - The number of bytes the share would take up in the
        output buffer.

--*/

{
    ULONG shareSize = 0;

    switch ( Level ) {
    case 502:
        if ( Shi502->shi502_security_descriptor != NULL ) {

            //
            // add 4 bytes for possible padding
            //

            shareSize = sizeof( ULONG ) +
                RtlLengthSecurityDescriptor( Shi502->shi502_security_descriptor );
        }

    case 2:
        shareSize += SIZE_WSTR( Shi502->shi502_path );

    case 501:
    case 1:
        shareSize += SIZE_WSTR( Shi502->shi502_remark );

    case 0:
        shareSize += SIZE_WSTR( Shi502->shi502_netname );

    }

    return ( shareSize + FIXED_SIZE_OF_SHARE( Level ) );

} // SizeShares


BOOLEAN
ValidSharePath(
    IN LPWSTR SharePath,
    IN BOOL   IsNtPath
    )
/*++

Routine Description:

    This routine checks to see if .. and . exists on the path.  If they do,
    then we reject this path name.

Arguments:

    SharePath - The share path to be checked.

Return Value:

    TRUE, if path is ok.

--*/

{

    LPWCH source = SharePath;

    if( IsNtPath )
    {
        // The NT Path is validated by the OPEN call
        return TRUE;
    }

    //
    // Walk through the pathname until we reach the zero terminator.  At
    // the start of this loop, source points to the first charaecter
    // after a directory separator or the first character of the
    // pathname.
    //

    //
    // Allow the NT naming convention of slash slash . slash through here
    //
    if( IS_SLASH_SLASH_NAME( source ) ) {

        //
        // We have a path which starts with slash slash
        //  Set the buffer ptr so we start checking the pathname after
        //  the slash slash dot

        source += 3;
    }

    while ( *source != L'\0' ) {

        if ( *source == L'.') {
            source++;
            if ( ( IS_PATH_SEPARATOR(*source) ) ||
                 ( (*source++ == L'.') &&
                    IS_PATH_SEPARATOR(*source) ) ) {

                //
                // '.' and '..' appear as a directory names. Reject.
                //

                return(FALSE);
            }
        }

        //
        // source does not point to a dot, so continue until we see
        // another directory separator
        //

        while ( *source != L'\0' ) {
            if ( *source++ == L'\\' ) {
                break;
            }
        }
    }

    return TRUE;

} // ValidSharePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\srvconfg.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    SrvConfg.h

Abstract:

    This file contains default server settings for startup.

Author:

    David Treadwell (davidtr)    1-Mar-1991

Revision History:

--*/

#ifndef _SRVCONFG_
#define _SRVCONFG_

//
// The platform ID for NT servers.  This indicates the info level that
// should be called for platform-specific information.
//

#define DEF_PLATFORM_ID SV_PLATFORM_ID_NT
#define MIN_PLATFORM_ID SV_PLATFORM_ID_NT
#define MAX_PLATFORM_ID SV_PLATFORM_ID_NT

//
// The default name is used for the server set and get info APIs as well
// as the transport name if no overriding transport name is specified.
//

#define DEF_NAME L"NTSERVER"

//
// Version definitions--these indicate LM 3.0.
//

#define DEF_VERSION_MAJOR 3
#define MIN_VERSION_MAJOR 3
#define MAX_VERSION_MAJOR 3

#define DEF_VERSION_MINOR 10
#define MIN_VERSION_MINOR 10
#define MAX_VERSION_MINOR 10

//
// The server type.
//

#define DEF_TYPE 0
#define MIN_TYPE 0
#define MAX_TYPE 0xFFFFFFFF

//
// The server comment is used only for the server get and set info APIs.
//

#define DEF_COMMENT L""

//
// The maximum number of users that may be logged on to the server
// simultaneously.
//

#define DEF_USERS 0xFFFFFFFF
#define MIN_USERS 1
#define MAX_USERS 0xFFFFFFFF

//
// The autodisconnect time: when a client is idle for this many minutes,
// the server closes the connection, but only if the client has no open
// files/pipes.
//

#define DEF_DISC 15
#define MIN_DISC 0          // zero minutes -- disconnect ASAP
#define MAX_DISC 0xFFFFFFFF

//
// The IPX autodisconnect time: when a client doesn't send any SMBs
// for this many minutes, the server closes the 'connection', even if
// the client has open files/pipes.
//

#define DEF_CONNECTIONLESSAUTODISC 15
#define MIN_CONNECTIONLESSAUTODISC 15
#define MAX_CONNECTIONLESSAUTODISC 0xFFFFFFFF

//
// The number of minutes to wait between the time a client establishes a virtual
//  circuit to the server and the time it gets around to doing a session setup.  This
//  time is reset if the client keeps sending messages
//
#define DEF_CONNECTIONNOSESSIONSTIMEOUT 2
#define MIN_CONNECTIONNOSESSIONSTIMEOUT 1
#define MAX_CONNECTIONNOSESSIONSTIMEOUT 0xFFFFFFFF

//
// The minimum allowed negotiate buffer size from the client
//
#define DEF_MINCLIENTBUFFERSIZE 500
#define MIN_MINCLIENTBUFFERSIZE 64
#define MAX_MINCLIENTBUFFERSIZE (64*1024)

//
// Parameters dealing with server announcements: whether the server is
// hidden (no announcements), the announce interval, the randomization
// factor for the accounce interval, and whether the server announces
// itself as a time source.
//

#define DEF_HIDDEN FALSE

#define DEF_ANNOUNCE 4 * 60
#define MIN_ANNOUNCE 1
#define MAX_ANNOUNCE 65535

#define DEF_ANNDELTA 3000
#define MIN_ANNDELTA 0
#define MAX_ANNDELTA 65535

#define DEF_TIMESOURCE FALSE
#define DEF_ACCEPTDOWNLEVELAPIS TRUE
#define DEF_LMANNOUNCE FALSE

//
// A fully qualified path to the user directories.
//

#define DEF_USERPATH L"c:\\"

//
// The domain name to which to send server announcements.
//

#define DEF_DOMAIN L"DOMAIN"

//
// Server "heuristics", enabling various capabilities.
//

#define DEF_ENABLEOPLOCKS TRUE
#define DEF_ENABLEFCBOPENS TRUE
#define DEF_ENABLESOFTCOMPAT TRUE
#define DEF_ENABLERAW TRUE
#define DEF_ENABLESHAREDNETDRIVES FALSE
#define DEF_ENABLEFORCEDLOGOFF TRUE
#define DEF_ENABLEOPLOCKFORCECLOSE FALSE
#define DEF_REMOVEDUPLICATESEARCHES TRUE
#define DEF_RESTRICTNULLSESSACCESS TRUE
#define DEF_ENABLEWFW311DIRECTIPX TRUE

//
// Receive buffer size, receive work item count, and receive IRP stack
// size.
//

#define DEF_SIZREQBUF 4356
#define MIN_SIZREQBUF 1024
#define MAX_SIZREQBUF 65535

//
// If we have a large memory system, we use DEF_LARGE_SIZREQBUF instead of DEF_SIZREQBUF
//
#define DEF_LARGE_SIZREQBUF 16644

#define DEF_INITWORKITEMS 4
#define MIN_INITWORKITEMS 1
#define MAX_INITWORKITEMS 512

#define DEF_MAXWORKITEMS 128
#define MIN_MAXWORKITEMS 1
#define MAX_MAXWORKITEMS 65535                       // arbitrary

#define DEF_RAWWORKITEMS 4
#define MIN_RAWWORKITEMS 1
#define MAX_RAWWORKITEMS 512

#define DEF_MAXRAWWORKITEMS 16
#define MIN_MAXRAWWORKITEMS 1
#define MAX_MAXRAWWORKITEMS 512

#define DEF_IRPSTACKSIZE 15
#define MIN_IRPSTACKSIZE 11
#define MAX_IRPSTACKSIZE 50

//
// Maximum raw mode buffer size.  (This isn't actually configurable --
// the server must always be prepared to receive raw requests for up to
// 65535 bytes.)
//

#define DEF_MAXRAWBUFLEN 65535
#define MIN_MAXRAWBUFLEN 65535
#define MAX_MAXRAWBUFLEN 65535

//
// Cache-related parameters.
//

#define DEF_MAXCOPYREADLEN 8192
#define MIN_MAXCOPYREADLEN 0
#define MAX_MAXCOPYREADLEN 0xFFFFFFFF

#define DEF_MAXCOPYWRITELEN 0
#define MIN_MAXCOPYWRITELEN 0
#define MAX_MAXCOPYWRITELEN 0xFFFFFFFF

//
// Free connection count.
//

#define DEF_MAXFREECONNECTIONS 2
#define MIN_MAXFREECONNECTIONS 2
#define MAX_MAXFREECONNECTIONS 100                  // arbitrary

#define DEF_MINFREECONNECTIONS 2
#define MIN_MINFREECONNECTIONS 2
#define MAX_MINFREECONNECTIONS 32                   // arbitrary

//   Small free connection limits (machine < 1 GB memory)
#define SRV_MIN_CONNECTIONS_SMALL 4
#define SRV_MAX_CONNECTIONS_SMALL 8
//   Medium free connection limits (machine 1-16 GB memory)
#define SRV_MIN_CONNECTIONS_MEDIUM 8
#define SRV_MAX_CONNECTIONS_MEDIUM 16
//   Large free connection limits (machine > 16 GB memory)
#define SRV_MIN_CONNECTIONS_LARGE 12
#define SRV_MAX_CONNECTIONS_LARGE 24

//
// Initial and maximum table sizes.
//

#define DEF_INITSESSTABLE 4
#define MIN_INITSESSTABLE 1
#define MAX_INITSESSTABLE 64

#define DEF_SESSUSERS 2048
#define MIN_SESSUSERS 1
#define MAX_SESSUSERS 2048
#define ABSOLUTE_MAX_SESSION_TABLE_SIZE 2048        // Limited by index bits

#define DEF_INITCONNTABLE 8
#define MIN_INITCONNTABLE 1
#define MAX_INITCONNTABLE 128

#define DEF_SESSCONNS 2048
#define MIN_SESSCONNS 1
#define MAX_SESSCONNS 2048
#define ABSOLUTE_MAX_TREE_TABLE_SIZE 2048           // Limited by index bits

#define DEF_INITFILETABLE 16
#define MIN_INITFILETABLE 1
#define MAX_INITFILETABLE 256

#define DEF_SESSOPENS 16384
#define MIN_SESSOPENS 1
#define MAX_SESSOPENS 16384
// #define ABSOLUTE_MAX_FILE_TABLE_SIZE 16384           // Limited by index bits

#define DEF_INITSEARCHTABLE 8
#define MIN_INITSEARCHTABLE 1
#define MAX_INITSEARCHTABLE 2048

#define DEF_OPENSEARCH 2048
#define MIN_OPENSEARCH 1
#define MAX_OPENSEARCH 2048
#define ABSOLUTE_MAX_SEARCH_TABLE_SIZE 2048         // Limited by index bits

#define DEF_MAXGLOBALOPENSEARCH 4096
#define MIN_MAXGLOBALOPENSEARCH 1
#define MAX_MAXGLOBALOPENSEARCH 0xFFFFFFFF

#define DEF_INITCOMMTABLE 4
#define MIN_INITCOMMTABLE 1
#define MAX_INITCOMMTABLE 32

#define DEF_CHDEVS 32
#define MIN_CHDEVS 1
#define MAX_CHDEVS 32
#define ABSOLUTE_MAX_COMM_DEVICE_TABLE_SIZE 32

//
// Core search timeouts.  The first is for active core searches, the second
// is for core searches where we have returned STATUS_NO_MORE_FILES.  The
// second should be shorter, as these are presumably complete.  All values
// are specified in seconds.
//

#define DEF_MAXKEEPSEARCH (60 * 60)
#define MIN_MAXKEEPSEARCH 10
#define MAX_MAXKEEPSEARCH 10000

//
// *** These 3 parameters are no longer used.
//

#define DEF_MINKEEPSEARCH (60 * 8)
#define MIN_MINKEEPSEARCH 5
#define MAX_MINKEEPSEARCH 5000

#define DEF_MAXKEEPCOMPLSEARCH (60 * 10)
#define MIN_MAXKEEPCOMPLSEARCH 2
#define MAX_MAXKEEPCOMPLSEARCH 10000

#define DEF_MINKEEPCOMPLSEARCH (60 * 4)
#define MIN_MINKEEPCOMPLSEARCH 1
#define MAX_MINKEEPCOMPLSEARCH 1000

//
// SrvWorkerThreadCountAdd is added to the system CPU count to determine
// how many worker threads the server will have.
//
// *** THIS PARAMETER IS NO LONGER USED!
//

#define DEF_THREADCOUNTADD 2
#define MIN_THREADCOUNTADD 0
#define MAX_THREADCOUNTADD 10

//
// SrvBlockingThreadCount is the number of blocking threads that get
// started at server initialization.
//
// *** THIS PARAMETER IS NO LONGER USED!
//

#define DEF_NUMBLOCKTHREADS 2
#define MIN_NUMBLOCKTHREADS 1
#define MAX_NUMBLOCKTHREADS 10

//
// This is the maximum number of threads for each server queue per processor
//
#define DEF_MAXTHREADSPERQUEUE  10
#define MIN_MAXTHREADSPERQUEUE  1
#define MAX_MAXTHREADSPERQUEUE  65535

//
// If a server worker thread remains idle for this many seconds, it will terminate
//
#define DEF_IDLETHREADTIMEOUT   30
#define MIN_IDLETHREADTIMEOUT   1
#define MAX_IDLETHREADTIMEOUT   65535

//
// Scavenger thread idle wait time.
//

#define DEF_SCAVTIMEOUT 30
#define MIN_SCAVTIMEOUT 1
#define MAX_SCAVTIMEOUT 300

//
// The server periodically recomputes the average work queue depth.
//  This is how often the recomputation is done (in secs)
//
#define DEF_QUEUESAMPLESECS 5
#define MIN_QUEUESAMPLESECS 1
#define MAX_QUEUESAMPLESECS 65535

//
// For multiprocessor systems, the server tries to dynamically
//  balance the workload over the processors in the system.  The
//  processor handling the client's dpc's is known as the preferred
//  processor for this client. The server looks at the average work
//  queue depth for each of the processors in the system.  If the
//  client is currently on the preferred processor, but some other
//  processor's average work queue length + current queue length is
//  OTHERQUEUEAFFINITY shorter, then the client is reassigned to
//  that processor
//
#define DEF_OTHERQUEUEAFFINITY  3
#define MIN_OTHERQUEUEAFFINITY  1
#define MAX_OTHERQUEUEAFFINITY  65535

//
// If the client is not currently its preferred processor, but the
//  preferred processor's average work queue length + current queue
//  length is no more than PREFERREDAFFINITY items longer, then this
//  client is reassigned to its preferred processor
//
#define DEF_PREFERREDAFFINITY  1
#define MIN_PREFERREDAFFINITY  0
#define MAX_PREFERREDAFFINITY  65535

//
// Each client looks at the other processor queues every BALANCECOUNT
//  operations to see if it would be better served by a different
//  processor
//
#define DEF_BALANCECOUNT  1500
#define MIN_BALANCECOUNT  10
#define MAX_BALANCECOUNT  65535

//
// If a client is not currently assigned to its preferred processor, we've
//  found that cpu utilization can drop if server responses are sent from the
//  client's preferred processor (most certainly because transport data is not
//  sloshed between cpus).  Unfortunately this can adversely affect throughput
//  by a couple of percentage points on some platforms.  This setting affects
//  whether these responses are requeued to the preferred processor.
//
// OBSOLETE!
//
#define DEF_SENDSFROMPREFERREDPROCESSOR TRUE

//
// Does the server support compressed data transfers?
//
#define DEF_ENABLECOMPRESSION FALSE

//
// If an NTAS, should the server automatically create the drive$ shares?
//
#define DEF_AUTOSHARESERVER TRUE

//
// If a workstation, should the server automaticaly create the drive$ shares?
//
#define DEF_AUTOSHAREWKS    TRUE

//
// Should security signatures be enabled?
//
#define DEF_ENABLESECURITYSIGNATURE FALSE

//
// Should security signatures be required?
//
#define DEF_REQUIRESECURITYSIGNATURE FALSE

//
// Should security signatures be enabled for W9x clients?
//  This is here because there is a bug in W95 and some W98 vredir.vxd
//  versions that cause them to improperly sign.
//
#define DEF_ENABLEW9XSECURITYSIGNATURE TRUE

//
// Should we enforce reauthentication on kerberos tickets (perhaps causing Win2K clients to be
// disconnected since they don't do dynamic reauth)
//
#define DEF_ENFORCEKERBEROSREAUTHENTICATION FALSE

//
// Should we disable the Denial-of-Service checking
//
#define DEF_DISABLEDOS FALSE

//
// What is the minimum amount of disk space necessary to generate a "low disk space" warning event
//
#define DEF_LOWDISKSPACEMINIMUM 400
#define MIN_LOWDISKSPACEMINIMUM 0
#define MAX_LOWDISKSPACEMINIMUM 0xFFFFFFFF

//
// Should we do strict name checking
//
#define DEF_DISABLESTRICTNAMECHECKING FALSE

//
// Various information variables for the server.
//

#define DEF_MAXMPXCT 50
#define MIN_MAXMPXCT 1
#define MAX_MAXMPXCT 65535                           // We will only send 125 to W9X clients


//
// Time server waits for an an oplock to break before failing an open
// request
//

#define DEF_OPLOCKBREAKWAIT 35
#define MIN_OPLOCKBREAKWAIT 10
#define MAX_OPLOCKBREAKWAIT 180

//
// Time server waits for an oplock break response.
//

#define DEF_OPLOCKBREAKRESPONSEWAIT 35
#define MIN_OPLOCKBREAKRESPONSEWAIT 10
#define MAX_OPLOCKBREAKRESPONSEWAIT 180

//
// This is supposed to indicate how many virtual connections are allowed
// between this server and client machines.  It should always be set to
// one, though more VCs can be established.  This duplicates the LM 2.0
// server's behavior.
//

#define DEF_SESSVCS 1
#define MIN_SESSVCS 1
#define MAX_SESSVCS 1

//
// Receive work item thresholds
//

//
// The minimum desirable number of free receive workitems
//

#define DEF_MINRCVQUEUE 2
#define MIN_MINRCVQUEUE 0
#define MAX_MINRCVQUEUE 10

//
// The minimum number of free receive work items available before
// the server will start processing a potentially blocking SMB.
//

#define DEF_MINFREEWORKITEMS 2
#define MIN_MINFREEWORKITEMS 0
#define MAX_MINFREEWORKITEMS 10

//
// The maximum amount of time an "extra" work item can be idle before it
// is freed back to the system.
//

#define DEF_MAXWORKITEMIDLETIME 30         // seconds
#define MIN_MAXWORKITEMIDLETIME 10
#define MAX_MAXWORKITEMIDLETIME 1800

//
// Size of the shared memory section used for communication between the
// server and XACTSRV.
//

#define DEF_XACTMEMSIZE 0x100000    // 1 MB
#define MIN_XACTMEMSIZE 0x10000     // 64k
#define MAX_XACTMEMSIZE 0x1000000   // 16 MB

//
// Priority of server FSP threads.  Specified relative to the base
// priority of the process.  Valid values are between -2 and 2, or 15.
//

#define DEF_THREADPRIORITY 1
#define MIN_THREADPRIORITY 0
#define MAX_THREADPRIORITY THREAD_BASE_PRIORITY_LOWRT

//
// Limits on server memory usage.
//

#define DEF_MAXPAGEDMEMORYUSAGE 0xFFFFFFFF
#define MIN_MAXPAGEDMEMORYUSAGE 0x100000   // 1MB
#define MAX_MAXPAGEDMEMORYUSAGE 0xFFFFFFFF

#define DEF_MAXNONPAGEDMEMORYUSAGE 0xFFFFFFFF
#define MIN_MAXNONPAGEDMEMORYUSAGE 0x100000   // 1MB
#define MAX_MAXNONPAGEDMEMORYUSAGE 0xFFFFFFFF

//
// The server keeps a small list of free RFCB structures to avoid hitting
//  the heap.  This is the number in that list, per processor
//
#define DEF_MAXFREERFCBS    20
#define MIN_MAXFREERFCBS    0
#define MAX_MAXFREERFCBS    65535

//
// The server keeps a small list of free MFCB structures to avoid hitting
//  the heap.  This is the number in that list, per processor
//
#define DEF_MAXFREEMFCBS    20
#define MIN_MAXFREEMFCBS    0
#define MAX_MAXFREEMFCBS    65535

//
// The server keeps a small list of free LFCB structures to avoid hitting
//  the heap.  This is the number in that list, per processor
//
#define DEF_MAXFREELFCBS    20
#define MIN_MAXFREELFCBS    0
#define MAX_MAXFREELFCBS    65535

//
// The server keeps a small list of freed pool memory chunks to avoid hitting
//  the heap.  This is the number in that list, per processor
//
#define DEF_MAXFREEPAGEDPOOLCHUNKS  50
#define MIN_MAXFREEPAGEDPOOLCHUNKS  0
#define MAX_MAXFREEPAGEDPOOLCHUNKS  65535

//
// The chunks that are kept in the free pool list must be at least this size:
//
#define DEF_MINPAGEDPOOLCHUNKSIZE   128
#define MIN_MINPAGEDPOOLCHUNKSIZE   0
#define MAX_MINPAGEDPOOLCHUNKSIZE   65535

//
// The chunks must be no larger than this
//
#define DEF_MAXPAGEDPOOLCHUNKSIZE    512
#define MIN_MAXPAGEDPOOLCHUNKSIZE    0
#define MAX_MAXPAGEDPOOLCHUNKSIZE    65535

//
// Alert information
//

#define DEF_ALERTSCHEDULE 5 // 5 minutes
#define MIN_ALERTSCHEDULE 1
#define MAX_ALERTSCHEDULE 65535

#define DEF_ERRORTHRESHOLD 10  // 10 errors
#define MIN_ERRORTHRESHOLD 1
#define MAX_ERRORTHRESHOLD 65535

#define DEF_NETWORKERRORTHRESHOLD 5 // 5% errors
#define MIN_NETWORKERRORTHRESHOLD 1
#define MAX_NETWORKERRORTHRESHOLD 100

#define DEF_DISKSPACETHRESHOLD 10 // 10% free disk space
#define MIN_DISKSPACETHRESHOLD 0
#define MAX_DISKSPACETHRESHOLD 99

//
// Link speed parameters
//

#define DEF_MAXLINKDELAY 60                 // seconds
#define MIN_MAXLINKDELAY 0
#define MAX_MAXLINKDELAY 0x100000

#define DEF_MINLINKTHROUGHPUT 0             // bytes per second
#define MIN_MINLINKTHROUGHPUT 0
#define MAX_MINLINKTHROUGHPUT 0xFFFFFFFF

#define DEF_LINKINFOVALIDTIME 60            // seconds
#define MIN_LINKINFOVALIDTIME 0
#define MAX_LINKINFOVALIDTIME 0x100000

#define DEF_SCAVQOSINFOUPDATETIME 300       // seconds
#define MIN_SCAVQOSINFOUPDATETIME 0
#define MAX_SCAVQOSINFOUPDATETIME 0x100000

//
// Sharing violation retry delays/count
//

#define DEF_SHARINGVIOLATIONRETRIES 5       // number of retries
#define MIN_SHARINGVIOLATIONRETRIES 0
#define MAX_SHARINGVIOLATIONRETRIES 1000

#define DEF_SHARINGVIOLATIONDELAY 200       // milliseconds
#define MIN_SHARINGVIOLATIONDELAY 0
#define MAX_SHARINGVIOLATIONDELAY 1000

//
// Lock violation delay
//

#define DEF_LOCKVIOLATIONDELAY 250          // milliseconds
#define MIN_LOCKVIOLATIONDELAY 0
#define MAX_LOCKVIOLATIONDELAY 1000

#define DEF_LOCKVIOLATIONOFFSET 0xEF000000
#define MIN_LOCKVIOLATIONOFFSET 0
#define MAX_LOCKVIOLATIONOFFSET 0xFFFFFFFF

//
// length to switchover to mdl reads
//

#define DEF_MDLREADSWITCHOVER 1024
#define MIN_MDLREADSWITCHOVER 512
#define MAX_MDLREADSWITCHOVER 65535

//
// Number of closed RFCBs that can be cached
//

#define DEF_CACHEDOPENLIMIT 10
#define MIN_CACHEDOPENLIMIT 0
#define MAX_CACHEDOPENLIMIT 65535

//
// Number of directory names to cache for quick checkpath calls
//

#define DEF_CACHEDDIRECTORYLIMIT    5
#define MIN_CACHEDDIRECTORYLIMIT    0
#define MAX_CACHEDDIRECTORYLIMIT    65535


//
// Max length for a copy buffer operation, as opposed to taking the
// NDIS buffer in total.
//

#define DEF_MAXCOPYLENGTH   512
#define MIN_MAXCOPYLENGTH   40
#define MAX_MAXCOPYLENGTH   65535

//
// *** Change the following defines to limit WinNT (vs. NTAS) parameters.
//
// *** If you make a change here, you need to make the same change in
//     srv\srvconfg.h!

#define MAX_USERS_WKSTA                 10
#define MAX_USERS_PERSONAL               5
#define MAX_USERS_WEB_BLADE             10

#define MAX_USERS_EMBEDDED              10
#define MAX_MAXWORKITEMS_EMBEDDED       256
#define MAX_THREADS_EMBEDDED            5
#define DEF_MAXMPXCT_EMBEDDED           16

#define MAX_MAXWORKITEMS_WKSTA          64
#define MAX_THREADS_WKSTA                5
#define DEF_MAXMPXCT_WKSTA              10             // since there are fewer workitems on a wksta

#endif // ifndef _SRVCONFG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\srvsvc_s_stub.c ===
#include "srvsvc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\srvinfo.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    SrvInfo.c

Abstract:

    This module contains support for the server get and set info APIs
    in the server service.

Author:

    David Treadwell (davidtr)    7-Mar-1991

Revision History:

--*/

#include "srvsvcp.h"
#include "ssreg.h"

#include <netlibnt.h>

#include <tstr.h>
#include <lmerr.h>


NET_API_STATUS NET_API_FUNCTION
NetrServerGetInfo (
    IN  LPWSTR ServerName,
    IN  DWORD Level,
    OUT LPSERVER_INFO InfoStruct
    )

/*++

Routine Description:

    This routine uses the server parameters stored in the server service
    to return the server information.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    ULONG outputBufferLength;
    NET_API_STATUS error;
    ACCESS_MASK desiredAccess;
    LPWSTR DomainName;
    PNAME_LIST_ENTRY service;
    PTRANSPORT_LIST_ENTRY transport;
    UCHAR serverNameBuf[ MAX_PATH ];
    UNICODE_STRING ServerNameUnicode;
    NTSTATUS status;
    ULONG namelen;

    //
    // Determine the access required for the requested level of
    // information.
    //

    switch ( Level ) {

    case 100:
    case 101:

        desiredAccess = SRVSVC_CONFIG_USER_INFO_GET;
        break;

    case 102:
    case 502:

        desiredAccess = SRVSVC_CONFIG_POWER_INFO_GET;
        break;

    case 503:

        desiredAccess = SRVSVC_CONFIG_ADMIN_INFO_GET;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // Make sure that the caller has that level of access.
    //

    error = SsCheckAccess(
                &SsConfigInfoSecurityObject,
                desiredAccess
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Acquire the resource that protects server information.  Since
    // we'll only read the information, get shared access to the
    // resource.
    //

    (VOID)RtlAcquireResourceShared( &SsData.SsServerInfoResource, TRUE );

    if( ServerName == NULL ) {
        ServerName = SsData.ServerNameBuffer;
    }

    //
    // Convert the server name
    //

    if( ServerName[0] == L'\\' && ServerName[1] == L'\\' ) {
        ServerName += 2;
    }

    RtlInitUnicodeString( &ServerNameUnicode, ServerName );
    error = ConvertStringToTransportAddress( &ServerNameUnicode, serverNameBuf, &namelen );
    if( error != NERR_Success ) {
        RtlReleaseResource( &SsData.SsServerInfoResource );
        return error;
    }

    //
    // Look for the NAME_LIST_ENTRY entry that represents the name of the server
    //  the client referred to.
    //

    DomainName = SsData.DomainNameBuffer;

    for( service = SsData.SsServerNameList; service != NULL; service = service->Next ) {

        if( service->TransportAddressLength != namelen ) {
            continue;
        }


        if( RtlEqualMemory( serverNameBuf, service->TransportAddress, namelen ) ) {
            DomainName = service->DomainName;
            break;
        }
    }

    //
    // If we didn't find an entry, find and use the primary entry
    //
    if( service == NULL ) {
        for( service = SsData.SsServerNameList; service != NULL; service = service->Next ) {
            if( service->PrimaryName ) {
                DomainName = service->DomainName;
                break;
            }
        }
    }

    //
    // Use the level parameter to determine how much space to allocate
    // and how to fill it in.
    //

    switch ( Level ) {

    case 100: {

        PSERVER_INFO_100 sv100;

        //
        // All we copy is the server name.
        //

        outputBufferLength = sizeof(SERVER_INFO_100) +
                                 STRSIZE( ServerName);

        sv100 = MIDL_user_allocate( outputBufferLength );
        if ( sv100 == NULL ) {
            RtlReleaseResource( &SsData.SsServerInfoResource );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Copy over the fixed portion of the buffer.
        //

        RtlCopyMemory( sv100, &SsData.ServerInfo102, sizeof(SERVER_INFO_100) );

        //
        // Set up the name string.
        //

        sv100->sv100_name = (LPWSTR)( sv100 + 1 );
        STRCPY( sv100->sv100_name, ServerName );

        //
        // Set up the output buffer pointer.
        //

        InfoStruct->ServerInfo100 = sv100;

        break;
    }

    case 101: {

        PSERVER_INFO_101 sv101;

        //
        // All we copy is the server name.
        //

        outputBufferLength = sizeof(SERVER_INFO_101) +
                                 STRSIZE( ServerName ) +
                                 STRSIZE( SsData.ServerCommentBuffer ) ;

        sv101 = MIDL_user_allocate( outputBufferLength );
        if ( sv101 == NULL ) {
            RtlReleaseResource( &SsData.SsServerInfoResource );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Copy over the fixed portion of the buffer.
        //

        RtlCopyMemory( sv101, &SsData.ServerInfo102, sizeof(SERVER_INFO_101) );

        if( service != NULL ) {
            sv101->sv101_type = service->ServiceBits;
            for( transport = service->Transports; transport; transport = transport->Next ) {
                sv101->sv101_type |= transport->ServiceBits;
            }
        } else {
            //
            // If there are no transports,
            //  return the global information.
            //

            sv101->sv101_type = SsGetServerType();
        }


        //
        // Set up the variable portion of the buffer.
        //

        sv101->sv101_name = (LPWSTR)( sv101 + 1 );
        STRCPY( sv101->sv101_name, ServerName );

        sv101->sv101_comment = (LPWSTR)( (PCHAR)sv101->sv101_name +
                                        STRSIZE( ServerName ));
        STRCPY( sv101->sv101_comment, SsData.ServerCommentBuffer );

        //
        // Set up the output buffer pointer.
        //

        InfoStruct->ServerInfo101 = sv101;

        break;
    }

    case 102: {

        PSERVER_INFO_102 sv102;

        //
        // We copy the server name, server comment, and user path
        // buffer.
        //

        outputBufferLength = sizeof(SERVER_INFO_102) +
                         STRSIZE( ServerName ) +
                         STRSIZE( SsData.ServerCommentBuffer )  +
                         STRSIZE( SsData.UserPathBuffer ) ;

        sv102 = MIDL_user_allocate( outputBufferLength );
        if ( sv102 == NULL ) {
            RtlReleaseResource( &SsData.SsServerInfoResource );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Copy over the fixed portion of the buffer.
        //

        RtlCopyMemory( sv102, &SsData.ServerInfo102, sizeof(SERVER_INFO_102) );

        if( service != NULL ) {
            sv102->sv102_type = service->ServiceBits;
            for( transport = service->Transports; transport; transport = transport->Next ) {
                sv102->sv102_type |= transport->ServiceBits;
            }
        } else {
            //
            // If there are no transports,
            //  return the global information.
            //

            sv102->sv102_type = SsGetServerType();
        }

        //
        // Set up the server name.
        //

        sv102->sv102_name = (LPWSTR)( sv102 + 1 );
        STRCPY( sv102->sv102_name, ServerName );

        //
        // Set up the server comment.
        //

        sv102->sv102_comment = (LPWSTR)( (PCHAR)sv102->sv102_name + STRSIZE( ServerName ));
        STRCPY( sv102->sv102_comment, SsData.ServerCommentBuffer );

        //
        // Set up the user path.
        //

        sv102->sv102_userpath = (LPWSTR)( (PCHAR)sv102->sv102_comment +
                                        STRSIZE( sv102->sv102_comment ) );
        STRCPY( sv102->sv102_userpath, SsData.UserPathBuffer );

        //
        // Set up the output buffer pointer.
        //

        InfoStruct->ServerInfo102 = sv102;

        break;
    }

    case 502:

        //
        // Allocate enough space to hold the fixed structure.  This level has
        // no variable structure.
        //

        InfoStruct->ServerInfo502 = MIDL_user_allocate( sizeof(SERVER_INFO_502) );
        if ( InfoStruct->ServerInfo502 == NULL ) {
            RtlReleaseResource( &SsData.SsServerInfoResource );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Copy the data from the server service buffer to the user buffer.
        //

        RtlCopyMemory(
            InfoStruct->ServerInfo502,
            &SsData.ServerInfo599,
            sizeof(SERVER_INFO_502)
            );

        break;

    case 503: {

        PSERVER_INFO_503 sv503;

        outputBufferLength = sizeof( *sv503 ) + STRSIZE( DomainName );

        sv503 = MIDL_user_allocate( outputBufferLength );

        if ( sv503 == NULL ) {
            RtlReleaseResource( &SsData.SsServerInfoResource );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Copy the data from the server service buffer to the user buffer.
        //

        RtlCopyMemory( sv503, &SsData.ServerInfo599, sizeof( *sv503 ) );

        //
        // Copy the domain name
        //
        sv503->sv503_domain = (LPWSTR)( sv503 + 1 );
        STRCPY( sv503->sv503_domain, DomainName );

        InfoStruct->ServerInfo503 = sv503;

        break;
    }

    default:

        RtlReleaseResource( &SsData.SsServerInfoResource );
        return ERROR_INVALID_LEVEL;
    }

    RtlReleaseResource( &SsData.SsServerInfoResource );

    return NO_ERROR;

} // NetrServerGetInfo


NET_API_STATUS NET_API_FUNCTION
NetrServerSetInfo (
    IN LPWSTR ServerName,
    IN DWORD Level,
    IN LPSERVER_INFO InfoStruct,
    OUT LPDWORD ErrorParameter OPTIONAL
    )

/*++

Routine Description:

    This routine sets information in the server service and server.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    ULONG i;
    LONG parmnum;
    BOOLEAN validLevel = FALSE;
    PSERVER_REQUEST_PACKET srp;
    LPBYTE buffer = (LPBYTE)InfoStruct->ServerInfo100;
    BOOLEAN announcementInformationChanged = FALSE;

    ServerName;

    //
    // Check that user input buffer is not NULL
    //
    if (buffer == NULL) {
        if ( ARGUMENT_PRESENT( ErrorParameter ) ) {
            *ErrorParameter = PARM_ERROR_UNKNOWN;
        }
        return ERROR_INVALID_PARAMETER;
    }

    parmnum = (LONG)(Level - PARMNUM_BASE_INFOLEVEL);

    if ( ARGUMENT_PRESENT( ErrorParameter ) ) {
        *ErrorParameter = parmnum;
    }

    //
    // Make sure that the caller is allowed to set information in the
    // server.
    //

    error = SsCheckAccess(
                &SsConfigInfoSecurityObject,
                SRVSVC_CONFIG_INFO_SET
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Acquire the resource that protects server information.  Since
    // we're going to be writing to the information, we need exclusive
    // access to the reqource.
    //


    //
    // If a parameter number was specified, set that one field.
    //

    if ( parmnum >= 0 ) {

        //
        // Walk through the field descriptors looking for an
        // equivalent parameter number.
        //

        for ( i = 0; SsServerInfoFields[i].FieldName != NULL; i++ ) {

            if ( (ULONG)parmnum == SsServerInfoFields[i].ParameterNumber ) {

                //
                // Verify that the field is settable.
                //
                // !!! We should also reject levels above 502?
                //

                if ( SsServerInfoFields[i].Settable != ALWAYS_SETTABLE ) {
                    return ERROR_INVALID_LEVEL;
                }

                (VOID)RtlAcquireResourceExclusive( &SsData.SsServerInfoResource, TRUE );

                //
                // Set the field.
                //

                error = SsSetField(
                            &SsServerInfoFields[i],
                            buffer,
                            TRUE,
                            &announcementInformationChanged
                            );

                RtlReleaseResource( &SsData.SsServerInfoResource );

                //
                // If a relevant parameter changed, call
                // SsSetExportedServerType.  This will cause an
                // announcement to be sent.
                //

                if ( announcementInformationChanged ) {
                    SsSetExportedServerType( NULL, TRUE, TRUE );
                }

                return error;
            }
        }

        //
        // If a match had been found we would have returned by now.
        // Indicate that the parameter number was illegal.
        //

        return ERROR_INVALID_LEVEL;
    }

    //
    // A full input structure was specified.  Walk through all the
    // server data field descriptors, looking for fields that should be
    // set.
    //

    for ( i = 0; SsServerInfoFields[i].FieldName != NULL; i++ ) {

        ULONG fieldLevel;

        //
        // We need to set this field if:
        //
        //     o the level specified on input is the same order as the
        //       level of the field.  They have the same order if
        //       they are in the same century (e.g.  101 and 102 are
        //       in the same order); AND
        //
        //     o the specified level is greater than or equal to the
        //       level of the field.  For example, if the input
        //       level is 101 and the field level is 102, don't set
        //       the field.  If the input level is 102 and the field
        //       level is 101, set it; AND
        //
        //     o the field is settable.  If the field is not settable
        //       by NetServerSetInfo, just ignore the value in the
        //       input structure.
        //
        // Note that level 598 doesn't follow the first rule above.  It
        // is NOT a superset of 50x, and it is NOT a subset of 599.
        //

        fieldLevel = SsServerInfoFields[i].Level;

        if ( Level / 100 == fieldLevel / 100 &&
             ((fieldLevel != 598) && (Level >= fieldLevel) ||
              (fieldLevel == 598) && (Level == 598)) &&
             SsServerInfoFields[i].Settable == ALWAYS_SETTABLE ) {

            //
            // We found a match, so the specified level number must have
            // been valid.
            //
            // !!! Reject levels above 502?

            validLevel = TRUE;

            //
            // Set this field.
            //

           (VOID)RtlAcquireResourceExclusive( &SsData.SsServerInfoResource, TRUE );

            error = SsSetField(
                         &SsServerInfoFields[i],
                         buffer + SsServerInfoFields[i].FieldOffset,
                         TRUE,
                         &announcementInformationChanged
                         );

            RtlReleaseResource( &SsData.SsServerInfoResource );

            if ( error != NO_ERROR ) {

                //
                // Set the parameter in error if we need to.
                //

                if ( ARGUMENT_PRESENT(ErrorParameter) ) {
                    *ErrorParameter = SsServerInfoFields[i].ParameterNumber;
                }

                return error;
            }

        }

    }

    //
    // If no match was ever found, then an invalid level was passed in.
    //

    if ( !validLevel ) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // Get an SRP and set it up with the appropriate level.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    srp->Level = 0xFFFFFFFF;

    (VOID)RtlAcquireResourceShared( &SsData.SsServerInfoResource, TRUE );

    //
    // Send the request on to the server.
    //

    error = SsServerFsControl(
                FSCTL_SRV_NET_SERVER_SET_INFO,
                srp,
                &SsData.ServerInfo102,
                sizeof(SERVER_INFO_102) + sizeof(SERVER_INFO_599) +
                                                sizeof(SERVER_INFO_598)
                );

    //
    // Release the resource and free the SRP.
    //

    RtlReleaseResource( &SsData.SsServerInfoResource );

    SsFreeSrp( srp );

    //
    // If a relevant parameter changed, call SsSetExportedServerType.
    // This will cause an announcement to be sent.
    //

    if ( announcementInformationChanged ) {
        SsSetExportedServerType( NULL, TRUE, TRUE );
    }

    return error;

} // NetrServerSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\srvmain.c ===
/*++

Copyright (c) 1990-91  Microsoft Corporation

Module Name:

    srvmain.c

Abstract:

    This is the main routine for the NT LAN Manager Server Service.

    !!! Does service controller guarantee no controls will be issued
        while we are initializing?  Also, does it serialize controls?
        If not, we need some synchronization in here.

Author:

    David Treadwell (davidtr) 05-10-1991

Revision History:

    19-Jan-1993 Danl
        Removed the old long endpoint name "LanmanServer".

    07-Jan-1993 Danl
        Added an RPC endpoint name using "srvsvc", since "LanmanServer" is
        too long for DOS machines to _access.
        For a short time we will support both names.

    18-Feb-1992 ritaw
        Convert to Win32 service control APIs.

--*/

#include "srvsvcp.h"

#include <windows.h>
#include <lmerr.h>
#include <lmsname.h>
#include <tstr.h>
#include <wincon.h>
#include <winsvc.h>

#include <netlib.h>
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include <netdebug.h>   // NetpKdPrint
#include <rpcutil.h>
#include <srvann.h>
#include <srvnames.h>   // SERVER_INTERFACE_NAME
#include <dbt.h>

#include <mountmgr.h>

SERVICE_STATUS SsServiceStatus;
SERVICE_STATUS_HANDLE SsServiceStatusHandle;

DWORD
WINAPI
ControlResponse(
    DWORD   fdwControl,
    DWORD   fdwEventType,
    LPVOID  lpEventData,
    LPVOID  lpContext
    );

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    SsData.SsLmsvcsGlobalData = pGlobals;
}


VOID
ServiceMain(
    IN DWORD argc,
    IN LPWSTR argv[]
    )

/*++

Routine Description:

    This is the "main" routine for the server service.  The containing
    process will call this routine when we're supposed to start up.

Arguments:

Return Value:

    None.

--*/
{
    RPC_STATUS rpcStatus;
    NET_API_STATUS error;
    NET_API_STATUS terminationError;
    BOOLEAN rpcServerStarted = FALSE;

    NTSTATUS Status;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventNameString;
    LARGE_INTEGER LocalTimeout;

    PSVCHOST_GLOBAL_DATA pTempGlobals = SsData.SsLmsvcsGlobalData;

    RtlZeroMemory( &SsData, sizeof( SsData ) );
    RtlZeroMemory( &SsServiceStatus, sizeof( SsServiceStatus ) );

    SsData.SsLmsvcsGlobalData = pTempGlobals;

    SsServiceStatusHandle = 0;

    SsInitializeServerInfoFields();

    //
    // Make sure svchost.exe gave us the global data
    //
    ASSERT(SsData.SsLmsvcsGlobalData != NULL);

    //
    // Skip the Service Name in the argument list.
    //
    if (argc > 0) {
        argc--;
        if (argc > 0) {
            argv = &(argv[1]);
        }
    }


#if DBG
    //
    // Set up for debugging--the first command line argument may be
    // "/debug:X" where SsDebug gets set to X.
    //

    if ( argc > 0 && STRNICMP( TEXT("/debug:"), (LPWSTR)argv[0], 7 ) == 0 ) {
#ifdef UNICODE
        UNICODE_STRING ustr;
        RtlInitUnicodeString( &ustr, (PWSTR)argv[0] + 7 );
        RtlUnicodeStringToInteger( &ustr, 16, &SsDebug );
#else
        SsDebug = 0;
        RtlCharToInteger( argv[0] + 7, 16, &SsDebug );
#endif
    }


#ifndef USE_DEBUGGER
  //SsDebug = 0xffff;
    if ( SsDebug != 0 ) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        COORD coord;
        (VOID)AllocConsole( );
        (VOID)GetConsoleScreenBufferInfo(
                GetStdHandle(STD_OUTPUT_HANDLE),
                &csbi
                );
        coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
        coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
        (VOID)SetConsoleScreenBufferSize(
                GetStdHandle(STD_OUTPUT_HANDLE),
                coord
                );
    }
#endif
#endif

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SRVSVC_main: server service starting.\n" ));
    }

    IF_DEBUG(INITIALIZATION_BREAKPOINT) {
        DbgUserBreakPoint( );
    }


    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //

    SsServiceStatus.dwServiceType = SERVICE_WIN32;
    SsServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    SsServiceStatus.dwControlsAccepted = 0;
    SsServiceStatus.dwCheckPoint = 1;
    SsServiceStatus.dwWaitHint = 30000;  // 30 seconds

    SET_SERVICE_EXITCODE(
        NO_ERROR,
        SsServiceStatus.dwWin32ExitCode,
        SsServiceStatus.dwServiceSpecificExitCode
        );

    //
    // Initialize server to receive service requests by registering the
    // control handler.
    //

    SsServiceStatusHandle = RegisterServiceCtrlHandlerEx(
                                SERVICE_SERVER,
                                ControlResponse,
                                NULL
                                );

    if ( SsServiceStatusHandle == 0 ) {

        error = GetLastError();

        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SRVSVC_main: RegisterServiceCtrlHandler failed: "
                          "%ld\n", error ));
        }
        goto exit;

    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SRVSVC_main: Control handler registered.\n" ));
    }


    //
    // Wait for the Sam service to start.
    //
    // Later, when we initialize the server driver, it is going to create a
    // "NULL Session" token by calling LsaLogonUser.  That call waits until
    // SAM is initialized.  However, we don't have an opportunity to give
    // wait hints to the service controller, so we'll wait here.
    //
    // Create the event to wait on.
    //

    RtlInitUnicodeString( &EventNameString, L"\\SAM_SERVICE_STARTED" );
    InitializeObjectAttributes( &EventAttributes, &EventNameString, 0, 0, NULL);

    Status = NtCreateEvent(
                   &EventHandle,
                   SYNCHRONIZE,
                   &EventAttributes,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, SAM beat us to creating it.
        // Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &EventHandle,
                                  SYNCHRONIZE,
                                  &EventAttributes );

        }
        if ( !NT_SUCCESS(Status)) {
            error = NetpNtStatusToApiStatus(Status);

            IF_DEBUG(INITIALIZATION_ERRORS) {
                SS_PRINT(( "SRVSVC_main: Can't open SAM_SERVICE_STARTED event: %lx\n",
                            Status ));
            }

            goto exit;
        }
    }

    //
    // Wait for SAM to finish initializing.
    //

    LocalTimeout = RtlEnlargedIntegerMultiply( SsServiceStatus.dwWaitHint/2, -10000 );

    do {

        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "SRVSVC_main: Wait for SAM to init.\n" ));
        }
        AnnounceServiceStatus( 1 );
        Status = NtWaitForSingleObject( EventHandle,
                                        (BOOLEAN)FALSE,
                                        &LocalTimeout);
    } while ( Status == STATUS_TIMEOUT  );

    (VOID) NtClose( EventHandle );

    if ( !NT_SUCCESS(Status) ) {
        error = NetpNtStatusToApiStatus(Status);

        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SRVSVC_main: Wait for SAM_SERVICE_STARTED event failed: %lx\n",
                        Status ));
        }

        goto exit;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SRVSVC_main: Done waiting for SAM to init.\n" ));
    }

    AnnounceServiceStatus( 1 );

    //
    // Initialize server service data and the Lanman server FSP in kernel
    // mode.
    //

    error = SsInitialize( argc, argv );

    if ( error != NO_ERROR ) {
        goto exit;
    }

    //
    // Set the variable that indicates that the server is fully
    // initialized.
    //

    SS_ASSERT( !SsData.SsInitialized );
    SsData.SsInitialized = TRUE;

    //
    // Start the RPC server.  Because other services may reside in this
    // process, the actual RPC server may already have been started;
    // this routine will track this for us.
    //
    rpcStatus = SsData.SsLmsvcsGlobalData->StartRpcServer(
                    SERVER_INTERFACE_NAME,
                    srvsvc_ServerIfHandle
                    );

    if ( rpcStatus != 0 ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SRVSVC_main: NetpStartRpcServer failed: %X\n",
                        rpcStatus ));
        }
        error = rpcStatus;
        goto exit;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SRVSVC_main: RPC server started.\n" ));
    }

    rpcServerStarted = TRUE;

    //
    // Start getting PNP transport notifications from the server
    //
    error = StartPnpNotifications();
    if( error != NO_ERROR ) {
        goto exit;
    }

    //
    // Announce that we have successfully started.
    //

    SsServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SsServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                         SERVICE_ACCEPT_PAUSE_CONTINUE |
                                         SERVICE_ACCEPT_SHUTDOWN;

    SsServiceStatus.dwCheckPoint = 0;
    SsServiceStatus.dwWaitHint = 0;

    AnnounceServiceStatus( 0 );

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SRVSVC_main: initialization successfully completed.\n" ));
    }

    if (!I_ScSetServiceBits(SsServiceStatusHandle, SV_TYPE_SERVER, TRUE, TRUE, FALSE)) {
        error = GetLastError();

        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SRVSVC_main: I_ScSetServiceBits failed: %ld\n",
                        error ));
        }
        goto exit;

    }

    //
    // Use this thread as the scavenger thread to send server
    // announcements and watch the registry for configuration changes.
    //

    SS_ASSERT( SsData.SsInitialized );
    (VOID)SsScavengerThread( NULL );
    SS_ASSERT( SsData.SsInitialized );

exit:

    IF_DEBUG(TERMINATION) {
        SS_PRINT(( "SRVSVC_main: terminating.\n" ));
    }

    IF_DEBUG(TERMINATION_BREAKPOINT) {
        DbgUserBreakPoint( );
    }

    //
    // Set the initialization variable to indicate that the server
    // service is not started.
    //

    SsData.SsInitialized = FALSE;

    //
    // Shut down our connection to the RPC server, if the RPC server
    // was started successfully.
    //

    if ( rpcServerStarted ) {
        rpcStatus = SsData.SsLmsvcsGlobalData->StopRpcServer (
                        srvsvc_ServerIfHandle
                        );
        if ( rpcStatus != NO_ERROR ) {
            IF_DEBUG(TERMINATION_ERRORS) {
                SS_PRINT(( "SRVSVC_main: unable to terminate RPC server: %X\n",
                            rpcStatus ));
            }
        } else {
            IF_DEBUG(TERMINATION) {
                SS_PRINT(( "SRVSVC_main: RPC server successfully shut down.\n" ));
            }
        }
    }

    //
    // Announce that we're going down.
    //

    terminationError = error;

    SsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    SsServiceStatus.dwCheckPoint = 1;
    SsServiceStatus.dwWaitHint = 20000;   // 20 seconds

    SET_SERVICE_EXITCODE(
        terminationError,
        SsServiceStatus.dwWin32ExitCode,
        SsServiceStatus.dwServiceSpecificExitCode
        );

    AnnounceServiceStatus( 0 );

    //
    // Clean up previously initialized state.
    //

    IF_DEBUG(TERMINATION) {
        SS_PRINT(( "SRVSVC_main: cleaning up.\n" ));
    }

    error = SsTerminate( );
    if ( terminationError == NO_ERROR ) {
        terminationError = error;
    }

    //
    // Announce that we're down.
    //

    SsServiceStatus.dwCurrentState = SERVICE_STOPPED;
    SsServiceStatus.dwControlsAccepted = 0;
    SsServiceStatus.dwCheckPoint = 0;
    SsServiceStatus.dwWaitHint = 0;

    SET_SERVICE_EXITCODE(
        terminationError,
        SsServiceStatus.dwWin32ExitCode,
        SsServiceStatus.dwServiceSpecificExitCode
        );

    AnnounceServiceStatus( 0 );

    IF_DEBUG(TERMINATION) {
        SS_PRINT(( "SRVSVC_main: the server service is terminated.\n" ));
    }

    return;

} // SVCS_ENTRY_POINT (SRVSVC_main)


VOID
AnnounceServiceStatus (
    DWORD increment
    )

/*++

Routine Description:

    Announces the service's status to the service controller.
    Add 'increment' to the checkpoint value.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Service status handle is NULL if RegisterServiceCtrlHandler failed.
    //

    if ( SsServiceStatusHandle == 0 ) {
        SS_PRINT(( "AnnounceServiceStatus: Cannot call SetServiceStatus, "
                    "no status handle.\n" ));

        return;
    }

    if( SsServiceStatus.dwCurrentState == SERVICE_RUNNING && increment ) {
        //
        // No need to tell the service controller about another checkpoint
        //   since it already knows we're running
        //
        return;
    }

    SsServiceStatus.dwCheckPoint += increment;

    IF_DEBUG(ANNOUNCE) {
        SS_PRINT(( "AnnounceServiceStatus: CurrentState %lx\n"
                   "                       ControlsAccepted %lx\n"
                   "                       Win32ExitCode %lu\n"
                   "                       ServiceSpecificExitCode %lu\n"
                   "                       CheckPoint %lu\n"
                   "                       WaitHint %lu\n",
                 SsServiceStatus.dwCurrentState,
                 SsServiceStatus.dwControlsAccepted,
                 SsServiceStatus.dwWin32ExitCode,
                 SsServiceStatus.dwServiceSpecificExitCode,
                 SsServiceStatus.dwCheckPoint,
                 SsServiceStatus.dwWaitHint ));
    }

    //
    // Call SetServiceStatus, ignoring any errors.
    //

    SetServiceStatus(SsServiceStatusHandle, &SsServiceStatus);

} // AnnounceServiceStatus

DWORD
WINAPI
ControlResponse(
    DWORD   opCode,
    DWORD   fdwEventType,
    LPVOID  lpEventData,
    LPVOID  lpContext
    )
{
    NET_API_STATUS error;
    USHORT i;
    BOOL announce = TRUE;

    //
    // Determine the type of service control message and modify the
    // service status, if necessary.
    //

    switch( opCode ) {

        case SERVICE_CONTROL_SHUTDOWN:
        case SERVICE_CONTROL_STOP:

            IF_DEBUG(CONTROL_MESSAGES) {
                SS_PRINT(( "ControlResponse: STOP control received.\n" ));
            }

            //
            // Announce that we are in the process of stopping.
            //

            SsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            AnnounceServiceStatus( 0 );

            //
            // Set the event that will wake up the scavenger thread.
            // That thread will wake up and kill the server.
            //

            if ( !SetEvent( SsData.SsTerminationEvent ) ) {
                IF_DEBUG(TERMINATION_ERRORS) {
                    SS_PRINT(( "ControlResponse: SetEvent failed: %ld\n",
                                  GetLastError( ) ));
                }
            }

            //
            // Let the main thread announce when the stop is done.
            //

            announce = FALSE;

            break;

        case SERVICE_CONTROL_PAUSE:

            IF_DEBUG(CONTROL_MESSAGES) {
                SS_PRINT(( "ControlResponse: PAUSE control received.\n" ));
            }

            //
            // Announce that we are in the process of pausing.
            //

            SsServiceStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
            AnnounceServiceStatus( 0 );

            //
            // Send the request on to the server.
            //

            error = SsServerFsControl( FSCTL_SRV_PAUSE, NULL, NULL, 0L );
            SS_ASSERT( error == NO_ERROR );

            //
            // Announce that we're now paused.
            //

            SsServiceStatus.dwCurrentState = SERVICE_PAUSED;

            break;

        case SERVICE_CONTROL_CONTINUE:

            IF_DEBUG(CONTROL_MESSAGES) {
                SS_PRINT(( "ControlResponse: CONTINUE control received.\n" ));
            }

            //
            // Announce that continue is pending.
            //

            SsServiceStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
            AnnounceServiceStatus( 0 );

            //
            // Send the request on to the server.
            //

            error = SsServerFsControl( FSCTL_SRV_CONTINUE, NULL, NULL, 0L );
            SS_ASSERT( error == NO_ERROR );

            //
            // Announce that we're active now.
            //

            SsServiceStatus.dwCurrentState = SERVICE_RUNNING;

            break;

        case SERVICE_CONTROL_INTERROGATE:

            IF_DEBUG(CONTROL_MESSAGES) {
                SS_PRINT(( "ControlResponse: INTERROGATE control received.\n" ));
            }


            break;

        default:

            IF_DEBUG(CONTROL_MESSAGES) {
                SS_PRINT(( "ControlResponse: unknown code received.\n" ));
            }
            return ERROR_CALL_NOT_IMPLEMENTED;

            break;
    }

    if ( announce ) {
        AnnounceServiceStatus( 0 );
    }

    return NO_ERROR;

} // ControlResponse
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\ssdata.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    SsData.c

Abstract:

    This module contains declarations for global data used by the server
    service.

Author:

    David Treadwell (davidtr)    7-Mar-1991

Revision History:

--*/

#include "srvsvcp.h"
#include "srvconfg.h"

//
// Global server service data.
//

SERVER_SERVICE_DATA SsData;

//
// Macros for simplifying field generation.
//

#define MAKE_BOOL_FIELD(_name_,_lower_,_upper_,_level_,_set_) \
    L#_name_, BOOLEAN_FIELD, FIELD_OFFSET( SERVER_INFO_ ## _level_, \
    sv ## _level_ ## _ ## _lower_ ), _level_, SV_ ## _upper_ ## _PARMNUM, \
    _set_, DEF_ ## _upper_, FALSE, TRUE
#define MAKE_DWORD_FIELD(_name_,_lower_,_upper_,_level_,_set_) \
    L#_name_, DWORD_FIELD, FIELD_OFFSET( SERVER_INFO_ ## _level_, \
    sv ## _level_ ## _ ## _lower_ ), _level_, SV_ ## _upper_ ## _PARMNUM, \
    _set_, DEF_ ## _upper_, MIN_ ## _upper_, MAX_ ## _upper_
#define MAKE_LPSTR_FIELD(_name_,_lower_,_upper_,_level_,_set_) \
    L#_name_, LPSTR_FIELD, FIELD_OFFSET( SERVER_INFO_ ## _level_, \
    sv ## _level_ ## _ ## _lower_ ), _level_, SV_ ## _upper_ ## _PARMNUM, \
    _set_, (DWORD_PTR)DEF_ ## _upper_, 0, 0

//
// Data for all server info fields.
//

//
// These are the default values for the fields.
//
FIELD_DESCRIPTOR SsServerInfoFields_Default[] = {
     MAKE_DWORD_FIELD( platform_id, platform_id, PLATFORM_ID, 100, NOT_SETTABLE ),
     MAKE_LPSTR_FIELD( name, name, NAME, 100, NOT_SETTABLE ),
     MAKE_DWORD_FIELD( version_major, version_major, VERSION_MAJOR, 101, NOT_SETTABLE ),
     MAKE_DWORD_FIELD( version_minor, version_minor, VERSION_MINOR, 101, NOT_SETTABLE ),
     MAKE_DWORD_FIELD( type, type, TYPE, 101, NOT_SETTABLE ),
     MAKE_LPSTR_FIELD( srvcomment, comment, COMMENT, 101, ALWAYS_SETTABLE ),
     MAKE_LPSTR_FIELD( comment, comment, COMMENT, 101, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( users, users, USERS, 102, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( disc, disc, DISC, 102, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( autodisconnect, disc, DISC, 102, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( hidden, hidden, HIDDEN, 102, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( announce, announce, ANNOUNCE, 102, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( anndelta, anndelta, ANNDELTA, 102, ALWAYS_SETTABLE ),
     MAKE_LPSTR_FIELD( userpath, userpath, USERPATH, 102, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( sessopens, sessopens, SESSOPENS, 502, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( sessvcs, sessvcs, SESSVCS, 502, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( opensearch, opensearch, OPENSEARCH, 502, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( sizreqbuf, sizreqbuf, SIZREQBUF, 502, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( initworkitems, initworkitems, INITWORKITEMS, 502, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxworkitems, maxworkitems, MAXWORKITEMS, 502, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( rawworkitems, rawworkitems, RAWWORKITEMS, 502, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( irpstacksize, irpstacksize, IRPSTACKSIZE, 502, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxrawbuflen, maxrawbuflen, MAXRAWBUFLEN, 502, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( sessusers, sessusers, SESSUSERS, 502, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( sessconns, sessconns, SESSCONNS, 502, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxpagedmemoryusage, maxpagedmemoryusage, MAXPAGEDMEMORYUSAGE, 502, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxnonpagedmemoryusage, maxnonpagedmemoryusage, MAXNONPAGEDMEMORYUSAGE, 502, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( enablesoftcompat, enablesoftcompat, ENABLESOFTCOMPAT, 502, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( enableforcedlogoff, enableforcedlogoff, ENABLEFORCEDLOGOFF, 502, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( timesource, timesource, TIMESOURCE, 502, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( acceptdownlevelapis, acceptdownlevelapis, ACCEPTDOWNLEVELAPIS, 502, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( lmannounce, lmannounce, LMANNOUNCE, 502, ALWAYS_SETTABLE ),
     MAKE_LPSTR_FIELD( domain, domain, DOMAIN, 503, NOT_SETTABLE ),
     MAKE_DWORD_FIELD( maxcopyreadlen, maxcopyreadlen, MAXCOPYREADLEN, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxcopywritelen, maxcopywritelen, MAXCOPYWRITELEN, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( minkeepsearch, minkeepsearch, MINKEEPSEARCH, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxkeepsearch, maxkeepsearch, MAXKEEPSEARCH, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( minkeepcomplsearch, minkeepcomplsearch, MINKEEPCOMPLSEARCH, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxkeepcomplsearch, maxkeepcomplsearch, MAXKEEPCOMPLSEARCH, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( threadcountadd, threadcountadd, THREADCOUNTADD, 503, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( numblockthreads, numblockthreads, NUMBLOCKTHREADS, 503, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( scavtimeout, scavtimeout, SCAVTIMEOUT, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( minrcvqueue, minrcvqueue, MINRCVQUEUE, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( minfreeworkitems, minfreeworkitems, MINFREEWORKITEMS, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( xactmemsize, xactmemsize, XACTMEMSIZE, 503, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( threadpriority, threadpriority, THREADPRIORITY, 503, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxmpxct, maxmpxct, MAXMPXCT, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( oplockbreakwait, oplockbreakwait, OPLOCKBREAKWAIT, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( oplockbreakresponsewait, oplockbreakresponsewait, OPLOCKBREAKRESPONSEWAIT, 503, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( enableoplocks, enableoplocks, ENABLEOPLOCKS, 503, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( enableoplockforceclose, enableoplockforceclose, ENABLEOPLOCKFORCECLOSE, 503, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( enablefcbopens, enablefcbopens, ENABLEFCBOPENS, 503, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( enableraw, enableraw, ENABLERAW, 503, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( enablesharednetdrives, enablesharednetdrives, ENABLESHAREDNETDRIVES, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( minfreeconnections, minfreeconnections, MINFREECONNECTIONS, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxfreeconnections, maxfreeconnections, MAXFREECONNECTIONS, 503, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( initsesstable, initsesstable, INITSESSTABLE, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( initconntable, initconntable, INITCONNTABLE, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( initfiletable, initfiletable, INITFILETABLE, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( initsearchtable, initsearchtable, INITSEARCHTABLE, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( alertschedule, alertschedule, ALERTSCHEDULE, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( errorthreshold, errorthreshold, ERRORTHRESHOLD, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( networkerrorthreshold, networkerrorthreshold, NETWORKERRORTHRESHOLD, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( diskspacethreshold, diskspacethreshold, DISKSPACETHRESHOLD, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxlinkdelay, maxlinkdelay, MAXLINKDELAY, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( minlinkthroughput, minlinkthroughput, MINLINKTHROUGHPUT, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( linkinfovalidtime, linkinfovalidtime, LINKINFOVALIDTIME, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( scavqosinfoupdatetime, scavqosinfoupdatetime, SCAVQOSINFOUPDATETIME, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxworkitemidletime, maxworkitemidletime, MAXWORKITEMIDLETIME, 599, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxrawworkitems, maxrawworkitems, MAXRAWWORKITEMS, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxthreadsperqueue, maxthreadsperqueue, MAXTHREADSPERQUEUE, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( connectionlessautodisc, connectionlessautodisc, CONNECTIONLESSAUTODISC, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( sharingviolationretries, sharingviolationretries, SHARINGVIOLATIONRETRIES, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( sharingviolationdelay, sharingviolationdelay, SHARINGVIOLATIONDELAY, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( maxglobalopensearch, maxglobalopensearch, MAXGLOBALOPENSEARCH, 598, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( removeduplicatesearches, removeduplicatesearches, REMOVEDUPLICATESEARCHES, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( lockviolationoffset, lockviolationoffset, LOCKVIOLATIONOFFSET, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( lockviolationdelay, lockviolationdelay, LOCKVIOLATIONDELAY, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( mdlreadswitchover, mdlreadswitchover, MDLREADSWITCHOVER, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( cachedopenlimit, cachedopenlimit, CACHEDOPENLIMIT, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( cacheddirectorylimit, cacheddirectorylimit, CACHEDDIRECTORYLIMIT, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxcopylength, maxcopylength, MAXCOPYLENGTH, 598, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( restrictnullsessaccess, restrictnullsessaccess, RESTRICTNULLSESSACCESS, 598, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( enablewfw311directipx, enablewfw311directipx, ENABLEWFW311DIRECTIPX, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( otherqueueaffinity, otherqueueaffinity, OTHERQUEUEAFFINITY, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( queuesamplesecs, queuesamplesecs, QUEUESAMPLESECS, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( balancecount, balancecount, BALANCECOUNT, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( preferredaffinity, preferredaffinity, PREFERREDAFFINITY, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxfreerfcbs, maxfreerfcbs, MAXFREERFCBS, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxfreemfcbs, maxfreemfcbs, MAXFREEMFCBS, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxfreelfcbs, maxfreelfcbs, MAXFREELFCBS, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxfreepagedpoolchunks, maxfreepagedpoolchunks, MAXFREEPAGEDPOOLCHUNKS, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( minpagedpoolchunksize, minpagedpoolchunksize, MINPAGEDPOOLCHUNKSIZE, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( maxpagedpoolchunksize, maxpagedpoolchunksize, MAXPAGEDPOOLCHUNKSIZE, 598, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( sendsfrompreferredprocessor, sendsfrompreferredprocessor, SENDSFROMPREFERREDPROCESSOR, 598, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( enablecompression, enablecompression, ENABLECOMPRESSION, 598, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( autosharewks, autosharewks, AUTOSHAREWKS, 598, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( autoshareserver, autoshareserver, AUTOSHARESERVER, 598, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( enablesecuritysignature, enablesecuritysignature, ENABLESECURITYSIGNATURE, 598, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( requiresecuritysignature, requiresecuritysignature, REQUIRESECURITYSIGNATURE, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( minclientbuffersize, minclientbuffersize, MINCLIENTBUFFERSIZE, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( ConnectionNoSessionsTimeout, ConnectionNoSessionsTimeout, CONNECTIONNOSESSIONSTIMEOUT, 598, SET_ON_STARTUP ),
     MAKE_DWORD_FIELD( IdleThreadTimeOut, IdleThreadTimeOut, IDLETHREADTIMEOUT, 598, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( enableW9xsecuritysignature, enableW9xsecuritysignature, ENABLEW9XSECURITYSIGNATURE, 598, SET_ON_STARTUP ),
     MAKE_BOOL_FIELD( enforcekerberosreauthentication, enforcekerberosreauthentication, ENFORCEKERBEROSREAUTHENTICATION, 598, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( disabledos, disabledos, DISABLEDOS, 598, ALWAYS_SETTABLE ),
     MAKE_DWORD_FIELD( lowdiskspaceminimum, lowdiskspaceminimum, LOWDISKSPACEMINIMUM, 598, ALWAYS_SETTABLE ),
     MAKE_BOOL_FIELD( disablestrictnamechecking, disablestrictnamechecking, DISABLESTRICTNAMECHECKING, 598, ALWAYS_SETTABLE ),

     NULL, 0, 0, 0, 0, 0, 0, 0, 0
};

//
// These are the real FIELD_DESCRIPTORs used during runtime
//
FIELD_DESCRIPTOR SsServerInfoFields[ sizeof( SsServerInfoFields_Default ) / sizeof( SsServerInfoFields_Default[0] ) ];


//
// This function loads the default values into SsServerInfoFields
//
VOID
SsInitializeServerInfoFields( VOID )
{
    RtlCopyMemory( &SsServerInfoFields,
                    &SsServerInfoFields_Default,
                    sizeof( SsServerInfoFields )
                );
}

//
// Variable to control DbgPrints for debugging.
//
#if DBG
DWORD SsDebug = SSDEBUG_DEFAULT;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\srvsvcp.h ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    SrvSvcP.h

Abstract:

    This is the header file for the NT server service.

Author:

    David Treadwell (davidtr)    10-Jan-1991

Revision History:

--*/

#ifndef _SRVSVCP_
#define _SRVSVCP_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <lmcons.h>
#include <secobj.h>
#include <ntlsapi.h>
#include <srvfsctl.h>
#include <srvsvc.h>
#include <svcs.h>
#include <winreg.h>

#include "ssdebug.h"
#include "sssec.h"

//
// String constants.
//

#define IPC_SHARE_NAME TEXT("IPC$")
#define ADMIN_SHARE_NAME TEXT("ADMIN$")

#define  SRVSVC_MAX_NUMBER_OF_DISKS 26

//
// Internationalizable strings
//
extern LPWSTR SsAdminShareRemark ;
extern LPWSTR SsIPCShareRemark ;
extern LPWSTR SsDiskAdminShareRemark ;

//
// Bits of server type (in announcement messages) that can only be set
// by the server itself -- not by services via the internal API
// I_NetServerSetServiceBits.
//
// SV_TYPE_TIME_SOURCE is a pseudo internal bit.  It can be set internally or
//  it can be set by the w32time service.
//

#define SERVER_TYPE_INTERNAL_BITS (SV_TYPE_SERVER |         \
                                   SV_TYPE_PRINTQ_SERVER |  \
                                   SV_TYPE_NT |             \
                                   SV_TYPE_DFS)

//
// INITIAL_BUFFER_SIZE is the buffer size that GetInfo and Enum requests
// first try to fill.  If this buffer isn't large enough, they allocate
// a buffer large enough to hold all the information plus a fudge factor,
// EXTRA_ALLOCATION.
//

#define INITIAL_BUFFER_SIZE (ULONG)8192
#define EXTRA_ALLOCATION    1024

//
// ServerProductName in SERVER_SERVICE_DATA is the name passed to the
//  Licensing DLL as the name of this service.  MAXPRODNAME is the max
//  number of characters in the service name.

#define    SERVER_PRODUCT_NAME    L"SMBServer"

//  szVersionNumber in SERVER_SERVICE_DATA is the version string passed
//    to the Licensing DLL as the vesion of this service.  MAXVERSIONSZ
//    is the max number of characters for the version string

#define MAXVERSIONSZ    10

//
// Structures used to hold transport specific server type bits
//
typedef struct _TRANSPORT_LIST_ENTRY {
    struct _TRANSPORT_LIST_ENTRY    *Next;
    LPWSTR                          TransportName;                     // device name for xport
    DWORD                           ServiceBits;                       // SV... announce bits
} TRANSPORT_LIST_ENTRY, *PTRANSPORT_LIST_ENTRY;

typedef struct _NAME_LIST_ENTRY {
    struct _NAME_LIST_ENTRY         *Next;
    CHAR                            TransportAddress[ MAX_PATH ];       // address of this server
    ULONG                           TransportAddressLength;
    LPWSTR                          DomainName;                         // name of the domain
    DWORD                           ServiceBits;                        // SV... announce bits
    struct {
        ULONG                       PrimaryName: 1;   // Is this the server's primary name?
    };
    PTRANSPORT_LIST_ENTRY           Transports;
} NAME_LIST_ENTRY, *PNAME_LIST_ENTRY;

//
// Structure for server service global data.
//
typedef struct _SERVER_SERVICE_DATA {
    SERVER_INFO_102 ServerInfo102;
    SERVER_INFO_599 ServerInfo599;
    SERVER_INFO_598 ServerInfo598;

    //
    // Handle for accessing the server.
    //
    HANDLE SsServerDeviceHandle;

    //
    // Pointer to global data made available by SVCS main image.
    //
    PSVCHOST_GLOBAL_DATA SsLmsvcsGlobalData;

    //
    // Resource for synchronizing access to server info.
    //
    RTL_RESOURCE SsServerInfoResource;
    BOOL SsServerInfoResourceInitialized;

    //
    // Boolean indicating whether the server service is initialized.
    //
    BOOL SsInitialized;

    //
    // Boolean indicating whether the kernel-mode server FSP has been
    // started.
    //
    BOOL SsServerFspStarted;

    //
    // Event used for synchronizing server service termination.
    //
    HANDLE SsTerminationEvent;

    //
    // Event used for forcing the server to announce itself on the network from
    // remote clients.
    //
    HANDLE SsAnnouncementEvent;

    //
    // Event used for forcing the server to announce itself on the network from
    // inside the server service.
    //
    HANDLE SsStatusChangedEvent;

    //
    // Event used to detect domain name changes
    //
    HANDLE SsDomainNameChangeEvent;

    //
    // Name of this computer in OEM format.
    //
    CHAR SsServerTransportAddress[ MAX_PATH ];
    ULONG SsServerTransportAddressLength;

    //
    // List containing transport specific service names and bits
    //
    PNAME_LIST_ENTRY SsServerNameList;

    //
    // If we are asked to set some service bits before we've bound to
    //  any transports, we need to save those bits here and use them later
    //  when we finally do bind to transports.
    //
    DWORD   ServiceBits;

    BOOLEAN IsDfsRoot;                  // TRUE if we are the root of a DFS tree
    UNICODE_STRING ServerAnnounceName;
    LONG  NumberOfPrintShares;
    WCHAR ServerNameBuffer[MAX_PATH];
    WCHAR AnnounceNameBuffer[MAX_PATH];
    WCHAR ServerCommentBuffer[MAXCOMMENTSZ+1];
    WCHAR UserPathBuffer[MAX_PATH+1];
    WCHAR DomainNameBuffer[MAX_PATH];
    WCHAR ServerProductName[ sizeof( SERVER_PRODUCT_NAME ) ];
    WCHAR szVersionNumber[ MAXVERSIONSZ+1 ];

    //
    // Number of XACTSRV worker threads.
    //
    LONG XsThreads;

    //
    // This is the number of Xs threads blocked waiting for an LPC request.
    //  When it drops to zero, all threads are active and another thread is
    //  created.
    //
    LONG XsWaitingApiThreads;

    //
    // Event signalled when the last XACTSRV worker thread terminates.
    //
    HANDLE XsAllThreadsTerminatedEvent;

    //
    // Boolean indicating whether XACTSRV is active or terminating.
    //
    BOOL XsTerminating;

    //
    // Handle for the LPC port used for communication between the file server
    // and XACTSRV.
    //
    HANDLE XsConnectionPortHandle;
    HANDLE XsCommunicationPortHandle;

    //
    // Handle to the NTLSAPI.DLL library
    //
    HMODULE XsLicenseLibrary;

    //
    // Entry point for obtaining a client license
    //
    PNT_LICENSE_REQUEST_W SsLicenseRequest;

    //
    // Entry point for freeing a client license
    //
    PNT_LS_FREE_HANDLE SsFreeLicense;

    //
    // Handle to the XACT library
    //
    HMODULE XsXactsrvLibrary;

    BOOL ApiThreadsStarted;

    //
    // This resource is used to ensure that more than one thread aren't trying
    //  to load the xactsrv library at the same time.
    //
    BOOL LibraryResourceInitialized;
    RTL_RESOURCE LibraryResource;

} SERVER_SERVICE_DATA, *PSERVER_SERVICE_DATA;

extern SERVER_SERVICE_DATA SsData;

//
// Structure type used for generalized switch matching.
//

typedef struct _FIELD_DESCRIPTOR {
    LPWCH     FieldName;
    ULONG     FieldType;
    ULONG     FieldOffset;
    ULONG     Level;
    DWORD     ParameterNumber;
    ULONG     Settable;
    DWORD_PTR DefaultValue;
    DWORD     MinimumValue;
    DWORD     MaximumValue;
} FIELD_DESCRIPTOR, *PFIELD_DESCRIPTOR;

//
// Used by NetrShareEnumSticky to get share information from the registry.
//

typedef struct _SRVSVC_SHARE_ENUM_INFO  {
    ULONG Level;
    ULONG ResumeHandle;
    ULONG EntriesRead;
    ULONG TotalEntries;
    ULONG TotalBytesNeeded;
    PVOID OutputBuffer;
    ULONG OutputBufferLength;

    //
    // Scratch fields used by SsEnumerateStickyShares
    //

    ULONG ShareEnumIndex;
    PCHAR StartOfFixedData;
    PCHAR EndOfVariableData;
} SRVSVC_SHARE_ENUM_INFO, *PSRVSVC_SHARE_ENUM_INFO;

//
// Internal structure used for two-step delete of share's
//
typedef struct _SHARE_DEL_CONTEXT {
    struct _SHARE_DEL_CONTEXT* Next;
    SERVER_REQUEST_PACKET Srp;
    BOOL IsPrintShare;
    BOOL IsSpecial;
    //WCHAR NetName[];
} SHARE_DEL_CONTEXT, *PSHARE_DEL_CONTEXT;


//
// Manifests that determine field type.
//

#define BOOLEAN_FIELD 0
#define DWORD_FIELD 1
#define LPSTR_FIELD 2

//
// Manifests that determine when a field may be set.
//

#define NOT_SETTABLE 0
#define SET_ON_STARTUP 1
#define ALWAYS_SETTABLE 2

//
// Data for all server info fields.
//
extern FIELD_DESCRIPTOR SsServerInfoFields[];
extern VOID SsInitializeServerInfoFields( VOID );

//
// Macros.
//

#define POINTER_TO_OFFSET(val,start)               \
    (val) = (val) == NULL ? NULL : (PVOID)( (PCHAR)(val) - (ULONG_PTR)(start) )

#define OFFSET_TO_POINTER(val,start)               \
    (val) = (val) == NULL ? NULL : (PVOID)( (PCHAR)(val) + (ULONG_PTR)(start) )

#define FIXED_SIZE_OF_SHARE(level)                  \
    ( (level) == 0 ? sizeof(SHARE_INFO_0) :         \
      (level) == 1 ? sizeof(SHARE_INFO_1) :         \
      (level) == 2 ? sizeof(SHARE_INFO_2) :         \
                     sizeof(SHARE_INFO_502) )

#define SIZE_WSTR( Str )  \
    ( ( Str ) == NULL ? 0 : ((wcslen( Str ) + 1) * sizeof(WCHAR)) )

//
// Internal routine prototypes.
//

PSERVER_REQUEST_PACKET
SsAllocateSrp (
    VOID
    );

NET_API_STATUS
SsCheckAccess (
    IN PSRVSVC_SECURITY_OBJECT SecurityObject,
    IN ACCESS_MASK DesiredAccess
    );

VOID
SsCloseServer (
    VOID
    );

VOID
SsControlCHandler (
    IN ULONG CtrlType
    );

NET_API_STATUS
SsCreateSecurityObjects (
    VOID
    );

VOID
SsDeleteSecurityObjects (
    VOID
    );

VOID
SsFreeSrp (
    IN PSERVER_REQUEST_PACKET Srp
    );

NET_API_STATUS
SsInitialize (
    IN DWORD argc,
    IN LPTSTR argv[]
    );

VOID
SsLogEvent(
    IN DWORD MessageId,
    IN DWORD NumberOfSubStrings,
    IN LPWSTR *SubStrings,
    IN DWORD ErrorCode
    );

NET_API_STATUS
SsOpenServer ( void );

NET_API_STATUS
SsParseCommandLine (
    IN DWORD argc,
    IN LPTSTR argv[],
    IN BOOLEAN Starting
    );

DWORD
SsScavengerThread (
    IN LPVOID lpThreadParameter
    );

NET_API_STATUS
SsServerFsControlGetInfo (
    IN ULONG ServerControlCode,
    IN PSERVER_REQUEST_PACKET Srp,
    IN OUT PVOID *OutputBuffer,
    IN OUT ULONG OutputBufferLength
    );

NET_API_STATUS
SsServerFsControl (
    IN ULONG ServerControlCode,
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer OPTIONAL,
    IN ULONG BufferLength
    );

DWORD
SsGetServerType (
    VOID
    );

VOID
SsSetExportedServerType (
    IN PNAME_LIST_ENTRY Service  OPTIONAL,
    IN BOOL ExternalBitsAlreadyChanged,
    IN BOOL UpdateImmediately
    );

NET_API_STATUS
SsSetField (
    IN PFIELD_DESCRIPTOR Field,
    IN PVOID Value,
    IN BOOLEAN WriteToRegistry,
    OUT BOOLEAN *AnnouncementInformationChanged OPTIONAL
    );

UINT
SsGetDriveType (
    IN LPWSTR path
    );

NET_API_STATUS
SsTerminate (
    VOID
    );

DWORD
SsAtol (
    IN LPTSTR Input
    );

VOID
SsNotifyRdrOfGuid(
    LPGUID Guid
    );

VOID
AnnounceServiceStatus (
    DWORD increment
    );

VOID
BindToTransport (
    IN PVOID TransportName
    );

VOID
BindOptionalNames (
    IN PWSTR TransportName
    );

NET_API_STATUS NET_API_FUNCTION
I_NetrServerTransportAddEx (
    IN DWORD Level,
    IN LPTRANSPORT_INFO Buffer
    );

VOID
I_NetServerTransportDel(
    IN PUNICODE_STRING TransportName
    );

NET_API_STATUS
StartPnpNotifications (
    VOID
    );

NET_API_STATUS NET_API_FUNCTION
I_NetrShareDelStart (
    IN LPWSTR ServerName,
    IN LPWSTR NetName,
    IN DWORD Reserved,
    IN PSHARE_DEL_HANDLE ContextHandle,
    IN BOOLEAN CheckAccess
    );

NET_API_STATUS NET_API_FUNCTION
I_NetrShareAdd (
    IN LPWSTR ServerName,
    IN DWORD Level,
    IN LPSHARE_INFO Buffer,
    OUT LPDWORD ErrorParameter,
    IN BOOLEAN BypassSecurity
    );

//
// XACTSRV functions.
//

DWORD
XsStartXactsrv (
    VOID
    );

VOID
XsStopXactsrv (
    VOID
    );

NET_API_STATUS
ShareEnumCommon (
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL,
    IN LPWSTR NetName OPTIONAL
    );

NET_API_STATUS
ConvertStringToTransportAddress (
    IN PUNICODE_STRING InputName,
    OUT CHAR TransportAddress[MAX_PATH],
    OUT PULONG TransportAddressLength
    );

VOID
SsSetDfsRoot();


VOID
SsSetDomainName (
    VOID
    );


#endif // ndef _SRVSVCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\ssdebug.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    SsDebug.h

Abstract:

    Header file for various server service debugging aids.

Author:

    David Treadwell (davidtr)    10-Jan-1991

Revision History:

--*/

#ifndef _SSDEBUG_
#define _SSDEBUG_

#if DBG

#ifndef SSDEBUG_DEFAULT
#define SSDEBUG_DEFAULT 0
#endif

#define DEBUG_INITIALIZATION            0x00000001
#define DEBUG_INITIALIZATION_ERRORS     0x00000002
#define DEBUG_TERMINATION               0x00000004
#define DEBUG_TERMINATION_ERRORS        0x00000008

#define DEBUG_API_ERRORS                0x00000010
#define DEBUG_FS_CONTROL                0x00000020
#define DEBUG_REGISTRY                  0x00000040
#define DEBUG_8                         0x00000080

#define DEBUG_ANNOUNCE                  0x00000100
#define DEBUG_CONTROL_MESSAGES          0x00000200
#define DEBUG_11                        0x00000400
#define DEBUG_12                        0x00000800

#define DEBUG_SECURITY                  0x00001000
#define DEBUG_ACCESS_DENIED             0x00002000
#define DEBUG_INITIALIZATION_BREAKPOINT 0x00004000
#define DEBUG_TERMINATION_BREAKPOINT    0x00008000

extern ULONG SsDebug;

#define DEBUG if ( TRUE )
#define IF_DEBUG(flag) if (SsDebug & (DEBUG_ ## flag))

VOID
SsPrintf (
    char *Format,
    ...
    );

#ifdef USE_DEBUGGER
#define SS_PRINT(args) DbgPrint args
#else
#define SS_PRINT(args)
//#define SS_PRINT(args) SsPrintf args
#endif

#ifdef USE_DEBUGGER
#define SS_ASSERT(exp) ASSERT(exp)
#else
VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );
#define SS_ASSERT(exp) if (!(exp)) SsAssert( #exp, __FILE__, __LINE__ )
#endif

#else

#define DEBUG if ( FALSE )
#define IF_DEBUG(flag) if (FALSE)

#define SS_PRINT(args)

#define SS_ASSERT(exp)

#endif

#endif // ndef _SSDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\ssinit.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    SsInit.c

Abstract:

    This module contains initialization routines for the NT server
    service.

Author:

    David Treadwell (davidtr)    6-Mar-1991

Revision History:

    ChuckC   20-May-93   Load share remarks from messagefile so it
                         can be internationalized.

--*/

#include "srvsvcp.h"
#include "srvconfg.h"
#include "ssreg.h"

#include <netevent.h>

#include <lmapibuf.h>           // NetApiBufferFree().
#include <lmconfig.h>
#include <netlib.h>
#include <apperr2.h>

#include <debugfmt.h>
#include <tstr.h>

#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
#define SERVER_DRIVER_NAME L"Srv"

#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
#define MAX(a,b) ( ((a) < (b)) ? (b) : (a) )
#define MINIMIZE(_param,_max) _param = MIN( _param, _max );

//
// Internationalizable share remarks.
//

#define NETMSG_DLL               TEXT("NETMSG.DLL")
LPWSTR SsDefaultRemark         = TEXT("") ;             // if all else fails

LPWSTR SsAdminShareRemark      = NULL ;
LPWSTR SsIPCShareRemark        = NULL ;
LPWSTR SsDiskAdminShareRemark  = NULL ;

//
// Lock to protect the ShareDeleteCommit list
//
extern CRITICAL_SECTION ShareDelContextMutex;
extern PSHARE_DEL_CONTEXT SrvShareDelContextHead;

//
// Forward declarations.
//

NET_API_STATUS
CreateDefaultShares (
    VOID
    );

VOID
InitializeDefaultData(
    VOID
    );

VOID
InitializeStrings(
    VOID
    );

VOID
FreeStrings(
    VOID
    );

NET_API_STATUS
InitializeServer (
    VOID
    );

NET_API_STATUS
LoadServer (
    VOID
    );

VOID
SetServerName (
    VOID
    );

DWORD
DiscoverDrives (
    VOID
    );

NET_API_STATUS
TerminateServer (
    VOID
    );

VOID
UnloadServer (
    VOID
    );

#define IsEmbedded() IsSuiteVersion(VER_SUITE_EMBEDDEDNT)
BOOL IsSuiteVersion(USHORT SuiteMask);


VOID
SAMWaitAnnounce (
    LPVOID event
    )
{
    ULONG i;

    //
    // Announce ourselves and then wait for awhile.
    // If the event gets signaled, terminate the loop and this thread.
    // But don't do this forever, since SAM may actually get stuck
    //

    //
    // Do it for 30 minutes
    //
    for( i=0; i < 120; i++ ) {

        AnnounceServiceStatus( 1 );

        if( WaitForSingleObject( (HANDLE)event, 15*1000 ) != WAIT_TIMEOUT ) {
            break;
        }
    }

    if( i == 120 ) {
        DbgPrint( "SRVSVC: SAM has hung on startup.  \"Srv\" will be reported as failed to start.\n" );
    }
}

NET_API_STATUS
SsInitialize (
    IN DWORD argc,
    IN LPWSTR argv[]
    )

/*++

Routine Description:

    This routine controls initialization of the server service and
    server driver.  It sets up server data stored in the server
    service, parses the command line parameters in case any data needs
    to be changed, and then starts the file server.

Arguments:

    argc - the count of command-line arguments.

    argv - an array of pointers to the command line arguments.

Return Value:

    NET_API_STATUS - results of operation.

--*/

{
    NET_API_STATUS error;
    HANDLE threadHandle = NULL;
    HANDLE event = NULL;

    //
    // Initialize the resource that protects access to global server
    // information.
    //

    SS_ASSERT( !SsData.SsServerInfoResourceInitialized );
    try {
        RtlInitializeResource( &SsData.SsServerInfoResource );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return RtlNtStatusToDosError( GetExceptionCode() );
    }

    // Initialize the lock that protects the ShareDelCommit list
    InitializeCriticalSection( &ShareDelContextMutex );
    SrvShareDelContextHead = NULL;

    //
    // We hold this resource while we are doing announcements, and when
    // we communicate with the FSD.  These ought to be quick operations,
    // but it's really unpredictable under load.  Indicate to the RTL
    // that we really don't know how long it'll take.
    //
    SsData.SsServerInfoResource.Flags |= RTL_RESOURCE_FLAG_LONG_TERM;

    SsData.SsServerInfoResourceInitialized = TRUE;

    //
    // Get the internationalizable special share remarks
    //
    InitializeStrings( );

    //
    // Initialize the server name list bits list.
    //

    SsData.SsServerNameList = NULL;

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: resource initialized.\n" ));
    }

    //
    // Create the event used for termination synchronization.
    //

    SS_ASSERT( SsData.SsTerminationEvent == NULL );
    SsData.SsTerminationEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( SsData.SsTerminationEvent == NULL ) {
        error = GetLastError( );
        SS_PRINT(( "SsInitialize: CreateEvent failed: %ld\n", error ));
        return error;
    }

    //
    // Initialize the server data to its default values stored in
    // srvconfg.h.
    //

    InitializeDefaultData( );

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: default data initialized.\n" ));
    }

    //
    // Sometimes the LSA misbehaves and doesn't process the computer name and
    //  domain name fetching calls.  So we need to defeat the service controller
    //  hang detection mechanism.  Sigh.
    //
    event = CreateEvent( NULL, TRUE, FALSE, NULL );

    if( event != NULL ) {
        DWORD threadId;

        threadHandle = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)SAMWaitAnnounce,
                        (LPVOID)event,
                        0,
                        &threadId
                        );
        if( threadHandle == NULL ) {
            CloseHandle( event );
            event = NULL;
        }
    }

    //
    // Get the computer name.
    //
    SetServerName( );

    //
    // Get the primary domain for this computer into the startup parameters.
    //
    SsSetDomainName( );

    if( event != NULL ) {
        //
        // We created an announcement thread, set the event telling it to terminate
        //
        SetEvent( event );

        //
        // Wait for the thread to terminate
        //
        (VOID)WaitForSingleObject( threadHandle, INFINITE );

        //
        // Close the handles
        //
        CloseHandle( event );
        CloseHandle( threadHandle );
    }

    //
    // See if we are the top of a DFS tree
    //
    SsSetDfsRoot();

    //
    // Verify that the various registry keys under the main server
    // service key exist.
    //

    error = SsCheckRegistry( );
    if ( error != NO_ERROR ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SsInitialize: SsCheckRegistry failed: %ld\n", error ));
        }
        return error;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: registry keys verified.\n" ));
    }

    //
    // Load server configuration data from the registry.
    //

    error = SsLoadConfigurationParameters( );
    if ( error != NO_ERROR ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SsInitialize: SsLoadConfigurationParameters failed: "
                        "%ld\n", error ));
        }
        return error;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: configuration parameters loaded.\n" ));
    }

    //
    // Parse the command line.  This will change server data values as
    // specified.
    //

    error = SsParseCommandLine( argc, argv, TRUE );
    if ( error != NO_ERROR ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SsInitialize: SsParseCommandLine failed: %ld\n",
                        error ));
        }
        return error;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: command line parsed.\n" ));
    }

    //
    // Set up the security objects that will be used to validate access
    // for APIs.
    //

    error = SsCreateSecurityObjects( );
    if ( error != NO_ERROR ) {
        return error;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: security initialized.\n" ));
    }

    //
    // Start the file server driver.
    //

    error = InitializeServer( );
    if ( error != NO_ERROR ) {
        return error;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: server FSP initialized.\n" ));
    }

    //
    // Watch for Domain Name changes, and automatically pick them up
    //
    error = NetRegisterDomainNameChangeNotification( &SsData.SsDomainNameChangeEvent );
    IF_DEBUG(INITIALIZATION_ERRORS) {
        if( error != NO_ERROR ) {
            SS_PRINT(( "SsInitialize: NetRegisterDomainNameChangeNotification failed: "
                    "%ld\n", error ));
        }
    }

    //
    // Start XACTSRV, if requested.
    //
    // *** This must be done AFTER the server driver is started, but
    //     BEFORE sticky shares are recreated, otherwise downlevel print
    //     shares are lost.
    //

    if ( SsData.ServerInfo599.sv599_acceptdownlevelapis ) {
        error = XsStartXactsrv( );
        if ( error != NO_ERROR ) {
            return error;
        }
    }

    //
    // Re-register the server's domain so we pick up the DNS name
    //
    SsSetDomainName();

    //
    // Create the default shares needed by the server.
    //

    error = CreateDefaultShares( );
    if ( error != NO_ERROR ) {
        return error;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: default shares created.\n" ));
    }

    //
    // Complete loading the configuration--sticky shares and transports.
    // These must be done after the server FSP has started.
    //

    error = SsRecreateStickyShares( );
    if ( error != NO_ERROR ) {
        return error;
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsInitialize: sticky shares reloaded.\n" ));
    }

    //
    // Set information used in server announcements.
    //

    SsSetExportedServerType( NULL, FALSE, FALSE );


    //
    // Server initialization was successful.
    //

    return NO_ERROR;

} // SsInitialize


NET_API_STATUS
SsTerminate (
    VOID
    )

/*++

Routine Description:

    This routine sends the FSCTL_SRV_SHUTDOWN control code to the server
    FSD to tell it to terminate its FSP.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NET_API_STATUS error;
    PNAME_LIST_ENTRY Service;
    PTRANSPORT_LIST_ENTRY Transport;

    //
    // Shut the server FSD/FSP down.
    //

    error = TerminateServer( );

    //
    // Shut down XACTSRV.
    //

    XsStopXactsrv( );

    //
    // Stop waiting for domain name changes
    //
    if( SsData.SsDomainNameChangeEvent ) {
        NetUnregisterDomainNameChangeNotification( SsData.SsDomainNameChangeEvent );
        SsData.SsDomainNameChangeEvent = NULL;
    }

    //
    // Delete security objects.
    //

    SsDeleteSecurityObjects( );

    //
    //  Close the network announcement event.
    //

    if (SsData.SsAnnouncementEvent != NULL) {
        CloseHandle( SsData.SsAnnouncementEvent );
        SsData.SsAnnouncementEvent = NULL;
    }

    //
    //  Close the local announcement event.
    //

    if (SsData.SsStatusChangedEvent != NULL) {
        CloseHandle( SsData.SsStatusChangedEvent );
        SsData.SsStatusChangedEvent = NULL;
    }

    //
    // Close the termination event.
    //

    if ( SsData.SsTerminationEvent != NULL ) {
        CloseHandle( SsData.SsTerminationEvent );
        SsData.SsTerminationEvent = NULL;
    }

    //
    // Free up the transport service list.
    //

    while( SsData.SsServerNameList != NULL ) {

        PNAME_LIST_ENTRY Service = SsData.SsServerNameList;

        while( Service->Transports != NULL ) {
            PTRANSPORT_LIST_ENTRY Next = Service->Transports->Next;
            MIDL_user_free( Service->Transports );
            Service->Transports = Next;
        }

        SsData.SsServerNameList = Service->Next;

        MIDL_user_free( Service );
    }

    //
    // Delete the server info resource.
    //

    if ( SsData.SsServerInfoResourceInitialized ) {
        RtlDeleteResource( &SsData.SsServerInfoResource );
        SsData.SsServerInfoResourceInitialized = FALSE;

        // Free any orphaned delete context's (caused by penetration style attacks)
        while( SrvShareDelContextHead != NULL )
        {
            PSHARE_DEL_CONTEXT pDelete = SrvShareDelContextHead;
            SrvShareDelContextHead = pDelete->Next;

            MIDL_user_free( pDelete );
        }

        DeleteCriticalSection( &ShareDelContextMutex );
    }

    //
    // Free up any string relate memory
    //
    FreeStrings() ;

    return error;

} // SsTerminate


NET_API_STATUS
CreateDefaultShares (
    VOID
    )

/*++

Routine Description:

    This routine sends the NetShareAdd API to the server to add the
    default server shares using the data above.

Arguments:

    None.

Return Value:

    NET_API_STATUS - results of operation.

--*/

{
    NET_API_STATUS error;
    SHARE_INFO_2 shareInfo;
    SHARE_INFO shInfo;
    WCHAR diskShareName[3];
    WCHAR diskSharePath[4];
    ULONG i;
    DWORD diskMask;
    DWORD diskconfiguration;

    //
    // Create IPC$.
    //
    // !!! Need to verify the remarks for these default shares.
    //

    shareInfo.shi2_netname = IPC_SHARE_NAME;
    shareInfo.shi2_type = STYPE_IPC;
    shareInfo.shi2_remark = NULL;
    shareInfo.shi2_permissions = 0;
    shareInfo.shi2_max_uses = SHI_USES_UNLIMITED;
    shareInfo.shi2_current_uses = 0;
    shareInfo.shi2_path = NULL;
    shareInfo.shi2_passwd = NULL;

    shInfo.ShareInfo2 = &shareInfo;
    error = NetrShareAdd( NULL, 2, &shInfo, NULL );
    if ( error != NO_ERROR ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "CreateDefaultShares: failed to add " FORMAT_LPWSTR
                        ": %X\n", shareInfo.shi2_netname, error ));
        }
    } else {
        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "CreateDefaultShares: added default share "
                        FORMAT_LPWSTR "\n", shareInfo.shi2_netname, error ));
        }
    }

    //
    // If this is a workstation, and the AutoShareWks key is set to TRUE then
    //   automatically create the admin$ and drive$ shares.
    //
    //
    // If this is a server, and the AutoShareServer key is set to TRUE then
    //    automatically create the admin$ and drive$ shares.
    //

    if( (SsData.ServerInfo598.sv598_producttype == NtProductWinNt &&
         SsData.ServerInfo598.sv598_autosharewks) ||

        (SsData.ServerInfo598.sv598_producttype != NtProductWinNt &&
         SsData.ServerInfo598.sv598_autoshareserver ) ) {

        //
        // Create ADMIN$.
        //

        shareInfo.shi2_netname = ADMIN_SHARE_NAME;
        shareInfo.shi2_type = STYPE_DISKTREE;
        shareInfo.shi2_remark = NULL;
        shareInfo.shi2_permissions = 1;
        shareInfo.shi2_max_uses = SHI_USES_UNLIMITED;
        shareInfo.shi2_current_uses = 0;
        shareInfo.shi2_path = NULL;
        shareInfo.shi2_passwd = NULL;

        error = NetrShareAdd( NULL, 2, &shInfo, NULL );
        if ( error != NO_ERROR ) {
            IF_DEBUG(INITIALIZATION_ERRORS) {
                SS_PRINT(( "CreateDefaultShares: failed to add " FORMAT_LPWSTR
                            ": %X\n", shareInfo.shi2_netname, error ));
            }
        } else {
            IF_DEBUG(INITIALIZATION) {
                SS_PRINT(( "CreateDefaultShares: added default share "
                            FORMAT_LPWSTR "\n", shareInfo.shi2_netname, error ));
            }
        }

        //
        // Loop through available drives, creating an admin share for each
        // one.  Note that we allow "holes" in the drive letter space.
        //

        diskShareName[0] = 'A';
        diskShareName[1] = '$';
        diskShareName[2] = '\0';

        diskSharePath[0] = diskShareName[0];
        diskSharePath[1] = ':';
        diskSharePath[2] = '\\';
        diskSharePath[3] = '\0';

        shareInfo.shi2_netname = diskShareName;
        shareInfo.shi2_type = STYPE_DISKTREE;
        shareInfo.shi2_remark = SsDiskAdminShareRemark;
        shareInfo.shi2_permissions = 1;
        shareInfo.shi2_max_uses = SHI_USES_UNLIMITED;
        shareInfo.shi2_current_uses = 0;
        shareInfo.shi2_path = diskSharePath;
        shareInfo.shi2_passwd = NULL;

        diskconfiguration = DiscoverDrives();

        for ( i = 0, diskMask = 0x80000000;
              (i < SRVSVC_MAX_NUMBER_OF_DISKS) && (diskShareName[0] <= 'Z');
              i++, diskShareName[0]++, diskSharePath[0]++, diskMask >>= 1 ) {


            if ( (diskconfiguration & diskMask) != 0) {

                error = NetrShareAdd( NULL, 2, &shInfo, NULL );

                if ( error != NO_ERROR ) {
                    IF_DEBUG(INITIALIZATION_ERRORS) {
                        SS_PRINT(( "CreateDefaultShares: failed to add "
                                    FORMAT_LPWSTR ": %X\n",
                                    shareInfo.shi2_netname, error ));
                    }
                } else {
                    IF_DEBUG(INITIALIZATION) {
                        SS_PRINT(( "CreateDefaultShares: added default share "
                                    FORMAT_LPWSTR "\n",
                                    shareInfo.shi2_netname, error ));
                    }
                }
            }
        }
    }

    return NO_ERROR;

} // CreateDefaultShares


DWORD
DiscoverDrives (
    VOID
    )

/*++

Routine Description:

    This routine returns a bit mask representing the local drives present
    on the system.

Arguments:

    None.

Return Value:

    DrivesAvailable - A 32 bit field representing the available drives on
        the system.  The MSB represents drive A, the next represents drive
        B, etc.  The extra 6 bits are currently unsed.

--*/

{
    WCHAR rootDirPath[4];
    WCHAR driveLetter;
    DWORD drivesAvailable = 0;
    DWORD driveMask = 0x80000000;
    UINT driveType;


    rootDirPath[1] = ':';
    rootDirPath[2] = '\\';
    rootDirPath[3] = '\0';

    for ( driveLetter = 'A';
          driveLetter <= 'Z';
          driveLetter++ ) {

        rootDirPath[0] = driveLetter;

        driveType = SsGetDriveType( rootDirPath );

        //
        // We only put fixed disk drives into the mask.  We used to put
        // removables, CD-ROMs, and RAM disks into the list.  But this
        // list is used for two purposes:  creation of X$ shares (for
        // backup purposes), and free disk space checking (for admin
        // purposes).  Neither of these uses applies very well to these
        // devices.
        //

        if ( driveType == DRIVE_FIXED
             //|| driveType == DRIVE_REMOVABLE
             //|| driveType == DRIVE_CDROM
             //|| driveType == DRIVE_RAMDISK
             ) {

            //
            // This is a valid drive letter
            //

            drivesAvailable |= driveMask;
        }

        //
        // Update drive mask for the next drive
        //

        driveMask /= 2;

    }

    return drivesAvailable;
}


VOID
InitializeDefaultData(
    VOID
    )

/*++

Routine Description:

    This routine sets up the default data in the server service by using
    the values in srvconfg.h.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NET_API_STATUS error;
    USHORT i;
    OSVERSIONINFOEX VersionInformation;
    NT_PRODUCT_TYPE ProductType;
    WCHAR szNumber[ sizeof( SsData.szVersionNumber ) / sizeof( WCHAR ) ], *p;

    //
    // Loop through all the defined fields, setting them as we go.
    //

    for ( i = 0; SsServerInfoFields[i].FieldName != NULL; i++ ) {

        error = SsSetField(
                    &SsServerInfoFields[i],
                    &SsServerInfoFields[i].DefaultValue,
                    FALSE,
                    NULL
                    );
        SS_ASSERT( error == NO_ERROR );
    }

    SsData.NumberOfPrintShares = 0;

    //
    // Get the system version and product name
    //
    VersionInformation.dwOSVersionInfoSize = sizeof( VersionInformation );
    i = (USHORT)GetVersionEx( (LPOSVERSIONINFO)&VersionInformation );

    SS_ASSERT( i == TRUE );

    SsData.ServerInfo102.sv102_version_major = VersionInformation.dwMajorVersion;
    SsData.ServerInfo102.sv102_version_minor = VersionInformation.dwMinorVersion;

    wcscpy( SsData.ServerProductName, SERVER_PRODUCT_NAME );

    //
    // Convert the version number to a version number string...
    //
    szNumber[ sizeof( szNumber ) / sizeof( szNumber[0] ) - 1 ] = L'\0';
    for( p = &szNumber[ sizeof( szNumber ) / sizeof( szNumber[0] ) - 2 ]; p > &szNumber[0]; p-- ) {
        *p = L"0123456789"[ VersionInformation.dwMinorVersion % 10 ];
        VersionInformation.dwMinorVersion /= 10;
        if( VersionInformation.dwMinorVersion == 0 )
            break;
    }

    *(--p) = L'.';

    do {
        *(--p) = L"0123456789"[ VersionInformation.dwMajorVersion % 10 ];
        VersionInformation.dwMajorVersion /= 10;
    } while( VersionInformation.dwMajorVersion && p > &szNumber[0] );

    if( VersionInformation.wSuiteMask & VER_SUITE_PERSONAL )
    {
        // Turn off auto-shares by default on Personal
        SsData.ServerInfo598.sv598_autoshareserver = FALSE;
        SsData.ServerInfo598.sv598_autosharewks = FALSE;
    }

    //
    // ... and store it in SsData
    //
    wcscpy( SsData.szVersionNumber, p );

    //
    // Change certain defaults for Workstations
    if( RtlGetNtProductType( &ProductType ) )
    {
        if( ProductType == NtProductWinNt )
        {
            SsData.ServerInfo599.sv599_diskspacethreshold = 0;
            SsData.ServerInfo598.sv598_disabledos = TRUE;
        }
    }

    // Change defaults for Embedded
    if( IsEmbedded() )
    {
        MINIMIZE( SsData.ServerInfo102.sv102_users, MAX_USERS_EMBEDDED );
    }

} // InitializeDefaultData


NET_API_STATUS
InitializeServer (
    VOID
    )

/*++

Routine Description:

    This routine sends the FSCTL_SRV_STARTUP control code to the server
    FSD to tell it to start and initialize its FSP.

Arguments:

    None.

Return Value:

    NET_API_STATUS - results of operation.

--*/

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;

    SS_ASSERT( !SsData.SsServerFspStarted );

    //
    // Load the server driver.
    //

    error = LoadServer( );

    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Get an SRP and set it up with the appropriate level.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        UnloadServer();
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    srp->Level = (ULONG)SS_STARTUP_LEVEL;

    //
    // Pass domain name to the server.
    //

    RtlInitUnicodeString( &srp->Name1, SsData.DomainNameBuffer );

    //
    // Pass server name to the server.
    //

    RtlInitUnicodeString( &srp->Name2, SsData.ServerNameBuffer );

    //
    // Send the request on to the server.
    //

    error = SsServerFsControl(
                FSCTL_SRV_STARTUP,
                srp,
                &SsData.ServerInfo102,
                sizeof(SERVER_INFO_102) + sizeof(SERVER_INFO_599) +
                                                sizeof(SERVER_INFO_598)
                );

    if ( error == NO_ERROR ) {
        SsData.SsServerFspStarted = TRUE;
    } else {
        UnloadServer();
    }

    //
    // Free the SRP and return.
    //

    SsFreeSrp( srp );

    return error;

} // InitializeServer

NET_API_STATUS
StartPnpNotifications (
    VOID
    )

/*++

Routine Description:

    This routine sends the FSCTL_SRV_BEGIN_PNP_NOTIFICATIONS control code to the server
    FSD to tell it to start monitoring transport PNP notifications

Arguments:

    None.

Return Value:

    NET_API_STATUS - results of operation.

--*/

{
    NET_API_STATUS error;

    //
    // Send the request on to the server.
    //

    error = SsServerFsControl(
                FSCTL_SRV_BEGIN_PNP_NOTIFICATIONS,
                NULL,
                NULL,
                0
                );

    IF_DEBUG(INITIALIZATION) {
        if( error != NO_ERROR ) {
            SS_PRINT(( "StartPnpNotifications: error %X\n", error ));
        }
    }

    return error;

} // StartPnpNotifications


NET_API_STATUS
LoadServer (
    VOID
    )
{
    NTSTATUS status;
    NET_API_STATUS error;
    LPWSTR registryPathBuffer;
    UNICODE_STRING registryPath;
    ULONG privileges[1];
    LPWSTR subString[1];

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "LoadServer: entered\n" ));
    }
    registryPathBuffer = (LPWSTR)MIDL_user_allocate(
                                    sizeof(SERVICE_REGISTRY_KEY) +
                                    sizeof(SERVER_DRIVER_NAME) +
                                    sizeof(WCHAR)       // for null
                                    );
    if ( registryPathBuffer == NULL ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "LoadServer: Unable to allocate memory\n" ));
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    error = NetpGetPrivilege( 1, privileges );
    if ( error != NO_ERROR ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "LoadServer: Unable to enable privilege: %ld\n",
                        error ));
        }
        MIDL_user_free( registryPathBuffer );
        return error;
    }

    wcscpy( registryPathBuffer, SERVICE_REGISTRY_KEY );
    wcscat( registryPathBuffer, SERVER_DRIVER_NAME );

    RtlInitUnicodeString( &registryPath, registryPathBuffer );

    status = NtLoadDriver( &registryPath );

    MIDL_user_free( registryPathBuffer );

    if ( status == STATUS_IMAGE_ALREADY_LOADED ) {
        status = STATUS_SUCCESS;
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "LoadServer: Unable to load driver: %lx\n",
                        status ));
        }

        subString[0] = SERVER_DRIVER_NAME;
        SsLogEvent(
            EVENT_SRV_CANT_LOAD_DRIVER,
            1,
            subString,
            status
            );

        error = RtlNtStatusToDosError(status);

    } else {

        //
        // Get a handle to the server.
        //
        error = SsOpenServer();
        if ( error != NO_ERROR ) {
            UnloadServer();
        }

    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "LoadServer: returning\n" ));
    }

    NetpReleasePrivilege( );

    return error;

} // LoadServer


NET_API_STATUS
ConvertStringToTransportAddress (
    IN PUNICODE_STRING InputName,
    OUT CHAR TransportAddress[ MAX_PATH ],
    OUT PULONG TransportAddressLength
    )
{
    OEM_STRING computerName;

    if( InputName == NULL || InputName->Length == 0 ) {
        RtlCopyMemory( TransportAddress,
                       SsData.SsServerTransportAddress,
                       SsData.SsServerTransportAddressLength );

        *TransportAddressLength = SsData.SsServerTransportAddressLength;
        return NO_ERROR;
    }

    if( InputName->Length > (MAX_PATH - 1 ) * sizeof( WCHAR ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Write directly to the output buffer
    //

    computerName.Buffer = TransportAddress;
    computerName.MaximumLength = MAX_PATH;

    //
    // Convert To Oem Name
    //

    (VOID) RtlUpcaseUnicodeStringToOemString(
                                    &computerName,
                                    InputName,
                                    FALSE
                                    );

    //
    // Make sure it is exactly NETBIOS_NAME_LEN characters
    //
    if( computerName.Length < NETBIOS_NAME_LEN ) {

        RtlCopyMemory( TransportAddress + computerName.Length,
                       "               ",
                       NETBIOS_NAME_LEN - computerName.Length
                     );

        *TransportAddressLength = NETBIOS_NAME_LEN;

    } else {

        *TransportAddressLength = NETBIOS_NAME_LEN;

    }

    return NO_ERROR;

} // ConvertStringToTransportAddress


VOID
SsSetDomainName (
    VOID
    )

/*++

Routine Description:

    Calls NetpGetDomainName to determine the domain name the server
    should use.  Ensure this domain name is reflected throughout the server service and
    srv.sys

Arguments:

    None.

Return Value:

    None.

--*/

{
    NET_API_STATUS error;
    LPWSTR domainName = NULL;
    LPWSTR dnsDomainName = NULL;
    LPWSTR fullDnsDomainName = NULL;
    PNAME_LIST_ENTRY service;
    BOOLEAN IsWorkgroup;
    DWORD dwError;

    dwError = NetpGetDomainNameExEx( &domainName, &fullDnsDomainName, &IsWorkgroup );
    if( dwError != NO_ERROR )
    {
        LPWSTR subString[2];
        subString[0] = SsData.DomainNameBuffer;
        subString[1] = L"????";

        SsLogEvent(
            EVENT_SRV_CANT_CHANGE_DOMAIN_NAME,
            2,
            subString,
            dwError
            );

        return;
    }

    if( fullDnsDomainName )
    {
        // Strip the name domain.foo.com down do just "domain"
        dnsDomainName = wcstok( fullDnsDomainName, L"." );
    }

    RtlAcquireResourceExclusive( &SsData.SsServerInfoResource, TRUE );

    if( SsData.SsServerFspStarted && SsData.DomainNameBuffer[0] ) {

        SERVER_REQUEST_PACKET srp;
        NTSTATUS status;

        //
        // If we used to have a domain name, change the service list to the
        //  new domain name
        //
        for( service = SsData.SsServerNameList; service != NULL; service = service->Next ) {
            if( !STRCMPI( service->DomainName, SsData.DomainNameBuffer ) ) {
                STRCPY( service->DomainName, domainName );
            }
        }

        srp.Name1.Length = wcslen( SsData.DomainNameBuffer ) * sizeof( WCHAR );
        srp.Name1.MaximumLength = srp.Name1.Length;
        srp.Name1.Buffer = SsData.DomainNameBuffer;

        srp.Name2.Length = wcslen( domainName ) * sizeof( WCHAR );
        srp.Name2.MaximumLength = srp.Name2.Length;
        srp.Name2.Buffer = domainName;

        //
        // Tell the SMB server about this change
        //
        status = SsServerFsControl( FSCTL_SRV_CHANGE_DOMAIN_NAME, &srp, NULL, 0 );

        //
        // If we are unable to change the domain name, log an error
        //
        if( !NT_SUCCESS( status ) ) {

            LPWSTR subString[2];
            subString[0] = SsData.DomainNameBuffer;
            subString[1] = domainName;

            SsLogEvent(
                EVENT_SRV_CANT_CHANGE_DOMAIN_NAME,
                2,
                subString,
                status
                );
        }

        if( fullDnsDomainName && !IsWorkgroup )
        {
            //
            // Tell the SMB server about the DNS Domain Name change too
            //
            srp.Name2.Length = wcslen( dnsDomainName ) * sizeof( WCHAR );
            srp.Name2.MaximumLength = srp.Name2.Length;
            srp.Name2.Buffer = dnsDomainName;

            srp.Name1.Length = wcslen( domainName ) * sizeof( WCHAR );
            srp.Name1.MaximumLength = srp.Name2.Length;
            srp.Name1.Buffer = domainName;

            //
            // Tell the SMB server about this change
            //
            status = SsServerFsControl( FSCTL_SRV_CHANGE_DNS_DOMAIN_NAME, &srp, NULL, 0 );

            //
            // If we are unable to change the domain name, log an error
            //
            if( !NT_SUCCESS( status ) ) {

                LPWSTR subString[2];
                subString[0] = SsData.DomainNameBuffer;
                subString[1] = domainName;

                SsLogEvent(
                    EVENT_SRV_CANT_CHANGE_DOMAIN_NAME,
                    2,
                    subString,
                    status
                    );
            }
        }
    }

    //
    // Copy the name into our name buffer.
    //
    STRNCPY( SsData.DomainNameBuffer, domainName, MAX_PATH);

    RtlReleaseResource( &SsData.SsServerInfoResource );

    //
    // Free the storage allocated by NetpGetComputerName.
    //

    (VOID)NetApiBufferFree( domainName );
    if( fullDnsDomainName )
    {
        (VOID)NetApiBufferFree( fullDnsDomainName );
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SsSetDomainName: domain name set to " FORMAT_LPWSTR
                    "(could be overridden later!)\n",
                    SsData.DomainNameBuffer ));
    }

} // SsSetDomainName


VOID
SetServerName (
    VOID
    )

/*++

Routine Description:

    Calls NetpGetComputerName to determine the name the server should use
    to register itself on the network.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NET_API_STATUS error;
    LPWSTR computerName;

    //
    // Get the computer name.
    //

    error = NetpGetComputerName( &computerName );
    SS_ASSERT( error == NO_ERROR );

    //
    // Copy the name into our name buffer.  This name is returned to
    // our apis.
    //

    STRCPY( SsData.ServerNameBuffer, computerName );

    //
    // Free the storage allocated by NetpGetComputerName.
    //

    (void) NetApiBufferFree( computerName );

    //
    // Uppercase the server name.  This name is used for announcements.
    //

    {
        UNICODE_STRING serverName;

        SsData.ServerAnnounceName.Length =
        serverName.Length =
                (USHORT) (STRLEN( SsData.ServerNameBuffer ) * sizeof(WCHAR));

        SsData.ServerAnnounceName.MaximumLength =
        serverName.MaximumLength =
                (USHORT) (serverName.Length + sizeof(WCHAR));

        serverName.Buffer = SsData.ServerNameBuffer;
        SsData.ServerAnnounceName.Buffer = SsData.AnnounceNameBuffer;

        (VOID)RtlUpcaseUnicodeString(
                        &SsData.ServerAnnounceName,
                        &serverName,
                        FALSE
                        );

        //
        // Make the server name in Netbios format.
        //

        error = ConvertStringToTransportAddress(
                        &serverName,
                        SsData.SsServerTransportAddress,
                        &SsData.SsServerTransportAddressLength
                        );

        SS_ASSERT( error == NO_ERROR );
    }


    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "SetServerName: server name set to " FORMAT_LPWSTR
                    " (could be overridden later!)\n",
                    SsData.ServerNameBuffer ));
    }

    return;

} // SetServerName


NET_API_STATUS
TerminateServer (
    VOID
    )

/*++

Routine Description:

    This routine sends the FSCTL_SRV_SHUTDOWN control code to the server
    FSD to tell it to shutdown operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NET_API_STATUS error = NO_ERROR;

    if ( SsData.SsServerFspStarted ) {

        SsData.SsServerFspStarted = FALSE;

        //
        // Send the request on to the server.
        //

        error = SsServerFsControl(
                    FSCTL_SRV_SHUTDOWN,
                    NULL,
                    NULL,
                    0
                    );
        if ( (error != NO_ERROR) &&
             (error != ERROR_SERVER_HAS_OPEN_HANDLES) ) {
            IF_DEBUG(TERMINATION_ERRORS) {
                SS_PRINT(( "TerminateServer: FSCTL_SRV_SHUTDOWN failed: %ld\n",
                            error ));
            }
        }

        //
        // Unload the server driver, unless there are other open handles
        // to the server.  We don't unload the driver in this case
        // because the driver won't actually go away until the
        // additional handles are closed, so the driver will not be
        // fully unloaded.  This would cause a subsequent server startup
        // to fail.
        //

        if ( error != ERROR_SERVER_HAS_OPEN_HANDLES ) {
            IF_DEBUG(TERMINATION) {
                SS_PRINT(( "TerminateServer: Unloading server\n" ));
            }
            UnloadServer( );
        }

    }

    //
    // Close the handle to the server.
    //

    SsCloseServer( );

    return error;

} // TerminateServer


VOID
UnloadServer (
    VOID
    )
{
    NTSTATUS status;
    NET_API_STATUS error;
    LPWSTR registryPathBuffer;
    UNICODE_STRING registryPath;
    ULONG privileges[1];
    LPWSTR subString[1];

    registryPathBuffer = (LPWSTR)MIDL_user_allocate(
                                    sizeof(SERVICE_REGISTRY_KEY) +
                                    sizeof(SERVER_DRIVER_NAME) +
                                    sizeof(WCHAR)       // for null
                                    );
    if ( registryPathBuffer == NULL ) {
        IF_DEBUG(TERMINATION_ERRORS) {
            SS_PRINT(( "UnloadServer: Unable to allocate memory\n" ));
        }
        return;
    }

    privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    error = NetpGetPrivilege( 1, privileges );
    if ( error != NO_ERROR ) {
        IF_DEBUG(TERMINATION_ERRORS) {
            SS_PRINT(( "UnloadServer: Unable to enable privilege: %ld\n",
                        error ));
        }
        MIDL_user_free( registryPathBuffer );
        return;
    }

    wcscpy( registryPathBuffer, SERVICE_REGISTRY_KEY );
    wcscat( registryPathBuffer, SERVER_DRIVER_NAME );

    RtlInitUnicodeString( &registryPath, registryPathBuffer );

    status = NtUnloadDriver( &registryPath );

    MIDL_user_free( registryPathBuffer );

    NetpReleasePrivilege( );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(TERMINATION_ERRORS) {
            SS_PRINT(( "UnloadServer: Unable to unload driver: %lx\n",
                        status ));
        }

        subString[0] = SERVER_DRIVER_NAME;
        SsLogEvent(
            EVENT_SRV_CANT_UNLOAD_DRIVER,
            1,
            subString,
            status
            );

    }

    return;

} // UnloadServer



VOID
InitializeStrings(
    VOID
    )

/*++

Routine Description:

    Retrieve internationalizable strings from NETMSG.DLL. They
    are used for share comments for IPC$, ADMIN$, C$, etc.
    Routine does not report any errors. If there are problems,
    the strings will be empty ones.

    FreeStrings should be called to free the memory allocated
    by format message and the

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD  dwRet, dwFlags ;
    HMODULE hModule ;

    //
    // init the strings to the default empty remark.
    //
    SsAdminShareRemark      = SsDefaultRemark ;
    SsIPCShareRemark        = SsDefaultRemark ;
    SsDiskAdminShareRemark  = SsDefaultRemark ;

    //
    // load NETMSG.DLL - if we cannot, just return.
    //
    hModule = LoadLibrary(NETMSG_DLL) ;
    if(!hModule)
        return ;

    //
    // hit FormatMessage 3 times for the real thing...
    //
    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE ;

    dwRet = FormatMessage(dwFlags,
                          hModule,
                          APE2_SERVER_IPC_SHARE_REMARK,
                          0,
                          (LPWSTR) &SsIPCShareRemark,
                          1,
                          NULL) ;
    if (dwRet == 0)
        SsIPCShareRemark = SsDefaultRemark ;

    dwRet = FormatMessage(dwFlags,
                          hModule,
                          APE2_SERVER_ADMIN_SHARE_REMARK,
                          0,
                          (LPWSTR) &SsAdminShareRemark,
                          1,
                          NULL) ;
    if (dwRet == 0)
        SsAdminShareRemark = SsDefaultRemark ;

    dwRet = FormatMessage(dwFlags,
                          hModule,
                          APE2_SERVER_DISK_ADMIN_SHARE_REMARK,
                          0,
                          (LPWSTR) &SsDiskAdminShareRemark,
                          1,
                          NULL) ;
    if (dwRet == 0)
        SsDiskAdminShareRemark = SsDefaultRemark ;

    FreeLibrary(hModule) ;
}


VOID
FreeStrings(
    VOID
    )

/*++

Routine Description:

    Free the memory used by server comment strings (allocated by
    FormatMessage).

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // as long as the strings do not point to the default (static data),
    // free them.
    //

    if (SsAdminShareRemark && SsAdminShareRemark != SsDefaultRemark)
       LocalFree(SsAdminShareRemark) ;
    SsAdminShareRemark = SsDefaultRemark ;

    if (SsIPCShareRemark && SsIPCShareRemark != SsDefaultRemark)
        LocalFree(SsIPCShareRemark) ;
    SsIPCShareRemark = SsDefaultRemark ;

    if (SsDiskAdminShareRemark && SsDiskAdminShareRemark != SsDefaultRemark)
        LocalFree(SsDiskAdminShareRemark) ;
    SsDiskAdminShareRemark = SsDefaultRemark ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\ssdata.h ===
#if 0
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    SsData.h

Abstract:

    This module contains declarations for global data used by the server
    service.

Author:

    David Treadwell (davidtr)    7-Mar-1991

Revision History:

--*/

#ifndef _SSDATA_
#define _SSDATA_

#include <nturtl.h>
#include <winbase.h>
#include <winreg.h>

//
// Global server service data.
//
extern SERVER_SERVICE_DATA SsData;

//
// Manifests that determine field type.
//

#define BOOLEAN_FIELD 0
#define DWORD_FIELD 1
#define LPSTR_FIELD 2

//
// Manifests that determine when a field may be set.
//

#define NOT_SETTABLE 0
#define SET_ON_STARTUP 1
#define ALWAYS_SETTABLE 2

//
// Data for all server info fields.
//

extern FIELD_DESCRIPTOR SsServerInfoFields[];

//
// Resource for synchronizing access to server info.
//

extern RTL_RESOURCE SsServerInfoResource;

extern BOOL SsServerInfoResourceInitialized;

//
// Boolean indicating whether the server service is initialized.
//

extern BOOL SsInitialized;

//
// Boolean indicating whether the kernel-mode server FSP has been
// started.
//

extern BOOL SsServerFspStarted;

//
// Event used for synchronizing server service termination.
//

extern HANDLE SsTerminationEvent;

//
// Event used for forcing the server to announce itself on the network from
// remote clients.
//

extern HANDLE SsAnnouncementEvent;

//
// Event used for forcing the server to announce itself on the network from
// inside the server service.
//

extern HANDLE SsStatusChangedEvent;

//
// Event used to detect domain name changes
//
extern HANDLE SsDomainNameChangeEvent;

//
// Name of this computer in OEM format.
//

extern CHAR SsServerTransportAddress[ MAX_PATH ];
extern ULONG SsServerTransportAddressLength;

//
// List containing transport specific service names and bits
//

extern PNAME_LIST_ENTRY SsServerNameList;

#endif // ndef _SSDATA_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\ssreg.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    ssreg.h

Abstract:

    Manifests for Registry usage in the server service.

Author:

    Chuck Lenzmeier (chuckl) 21-Mar-1992

Revision History:

--*/

#ifndef _SSREG_
#define _SSREG_

//
// Names of server service keys.
//

#define SERVER_REGISTRY_PATH L"LanmanServer"

#define PARAMETERS_REGISTRY_PATH L"LanmanServer\\Parameters"
#define AUTOTUNED_REGISTRY_PATH L"LanmanServer\\AutotunedParameters"
#define SHARES_REGISTRY_PATH L"LanmanServer\\Shares"
#define SHARES_SECURITY_REGISTRY_PATH L"LanmanServer\\Shares\\Security"
#define LINKAGE_REGISTRY_PATH L"LanmanServer\\Linkage"
#define SHARES_DEFAULT_SECURITY_REGISTRY_PATH L"LanmanServer\\DefaultSecurity"

#define BIND_VALUE_NAME L"Bind"
#define SIZE_VALUE_NAME L"Size"
#define DISC_VALUE_NAME L"Disc"
#define COMMENT_VALUE_NAME L"Comment"
#define NULL_SESSION_PIPES_VALUE_NAME L"NullSessionPipes"
#define NULL_SESSION_SHARES_VALUE_NAME L"NullSessionShares"
#define PIPES_NEED_LICENSE_VALUE_NAME L"PipesNeedLicense"
#define ERROR_LOG_IGNORE_VALUE_NAME L"ErrorLogIgnore"
#define OPTIONAL_NAMES_VALUE_NAME L"OptionalNames"
#define SERVICE_DLL_VALUE_NAME L"ServiceDll"
#define NO_REMAP_PIPES_VALUE_NAME L"NoRemapPipes"
#define DISABLE_DOS_CHECKING L"DisableDoS"

#define FULL_PARAMETERS_REGISTRY_PATH L"SYSTEM\\CurrentControlSet\\Services\\" PARAMETERS_REGISTRY_PATH


//
// Names of share "environment variables".
//

#define MAXUSES_VARIABLE_NAME L"MaxUses"
#define PATH_VARIABLE_NAME L"Path"
#define PERMISSIONS_VARIABLE_NAME L"Permissions"
#define REMARK_VARIABLE_NAME L"Remark"
#define TYPE_VARIABLE_NAME L"Type"
#define CSC_VARIABLE_NAME L"CSCFlags"
#define GUID_VARIABLE_NAME L"Guid"

//
// Used to check for Security Descriptor "Upgrade" from NT4 "World" to Win2K "World+Anonymous"
//
#define ANONYMOUS_UPGRADE_NAME L"AnonymousDescriptorsUpgraded"
#define SAVED_ANONYMOUS_RESTRICTION_NAME L"PreviousAnonymousRestriction"
#define FULL_SECURITY_REGISTRY_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\lanmanserver\\DefaultSecurity"
#define ABBREVIATED_SECURITY_REGISTRY_PATH L"LanmanServer\\DefaultSecurity"

//
// Functions exported by registry.c.
//

VOID
SsAddParameterToRegistry (
    PFIELD_DESCRIPTOR Field,
    PVOID Value
    );

VOID
SsAddShareToRegistry (
    IN PSHARE_INFO_2 ShareInfo2,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN DWORD CSCState
    );

NET_API_STATUS
SsBindToTransports (
    VOID
    );

NET_API_STATUS
SsCheckRegistry (
    VOID
    );

NET_API_STATUS
SsEnumerateStickyShares (
    IN OUT PSRVSVC_SHARE_ENUM_INFO ShareEnumInfo
    );

BOOLEAN
SsGetDefaultSdFromRegistry ( 
    IN PWCH ValueName,
    OUT PSECURITY_DESCRIPTOR *FileSD
);

VOID
SsWriteDefaultSdToRegistry ( 
    IN PWCH ValueName,
    IN PSECURITY_DESCRIPTOR FileSD
);


NET_API_STATUS
SsLoadConfigurationParameters (
    VOID
    );

NET_API_STATUS
SsRecreateStickyShares (
    VOID
    );

NET_API_STATUS
SsRemoveShareFromRegistry (
    LPTSTR NetName
    );

//
// Functions used by registry.c that are elsewhere but there is no convenient
// place to put the prototype
//

DWORD
ComputeTransportAddressClippedLength(
    IN PCHAR TransportAddress,
    IN ULONG TransportAddressLength
    );

#endif // ndef _SSREG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\stats.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    stats.c

Abstract:

    This module contains support for the NetStatisticsGet API for the NT
    OS/2 server service.

Author:

    David Treadwell (davidtr)    12-Apr-1991

Revision History:

--*/

#include "srvsvcp.h"


NET_API_STATUS NET_API_FUNCTION
NetrServerStatisticsGet (
    IN LPTSTR ServerName,
    IN LPTSTR Service,
    IN DWORD Level,
    IN DWORD Options,
    OUT LPSTAT_SERVER_0 *InfoStruct
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    server half of the NetStatisticsGet function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;

    ServerName, Service;

    //
    // The only valid level is 0.
    //

    if ( Level != 0 ) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // No options supported.
    //

    if ( Options != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure that the caller has the access necessary for this
    // operation.
    //

    error = SsCheckAccess(
                &SsStatisticsSecurityObject,
                SRVSVC_STATISTICS_GET
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Set up the request packet.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Send the request to the server.
    //

    error = SsServerFsControlGetInfo(
                FSCTL_SRV_NET_STATISTICS_GET,
                srp,
                (PVOID *)InfoStruct,
                (ULONG)-1
                );

    SsFreeSrp( srp );

    return error;

} // NetrServerStatisticsGet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\sssec.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    SsSec.h

Abstract:

    Manifests for API security in the server service.

Author:

    David Treadwell (davidtr)   28-Aug-1991

Revision History:

--*/

#ifndef _SSSEC_
#define _SSSEC_

//
// Structure that holds all security information for a single server
// service security object.
//

typedef struct _SRVSVC_SECURITY_OBJECT {
    LPTSTR ObjectName;
    PGENERIC_MAPPING Mapping;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SRVSVC_SECURITY_OBJECT, *PSRVSVC_SECURITY_OBJECT;

//
// Security objects used by the server service.
//

extern SRVSVC_SECURITY_OBJECT SsConfigInfoSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsTransportEnumSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsConnectionSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsDiskSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsFileSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsSessionSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsShareFileSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsSharePrintSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsShareAdminSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsShareConnectSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsShareAdmConnectSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsStatisticsSecurityObject;
extern SRVSVC_SECURITY_OBJECT SsDefaultShareSecurityObject;

//
// Object type names for audit alarm tracking.
//

#define SRVSVC_CONFIG_INFO_OBJECT       TEXT( "SrvsvcConfigInfo" )
#define SRVSVC_TRANSPORT_INFO_OBJECT    TEXT( "SrvsvcTransportEnum" )
#define SRVSVC_CONNECTION_OBJECT        TEXT( "SrvsvcConnection" )
#define SRVSVC_DISK_OBJECT              TEXT( "SrvsvcServerDiskEnum" )
#define SRVSVC_FILE_OBJECT              TEXT( "SrvsvcFile" )
#define SRVSVC_SESSION_OBJECT           TEXT( "SrvsvcSessionInfo" )
#define SRVSVC_SHARE_FILE_OBJECT        TEXT( "SrvsvcShareFileInfo" )
#define SRVSVC_SHARE_PRINT_OBJECT       TEXT( "SrvsvcSharePrintInfo" )
#define SRVSVC_SHARE_ADMIN_OBJECT       TEXT( "SrvsvcShareAdminInfo" )
#define SRVSVC_SHARE_CONNECT_OBJECT     TEXT( "SrvsvcShareConnect" )
#define SRVSVC_SHARE_ADM_CONNECT_OBJECT TEXT( "SrvsvcShareAdminConnect" )
#define SRVSVC_STATISTICS_OBJECT        TEXT( "SrvsvcStatisticsInfo" )
#define SRVSVC_DEFAULT_SHARE_OBJECT     TEXT( "SrvsvcDefaultShareInfo" )

//
// Access masks for configuration information (NetServer{Get,Set}Info).
//

#define SRVSVC_CONFIG_USER_INFO_GET     0x0001
#define SRVSVC_CONFIG_POWER_INFO_GET    0x0002
#define SRVSVC_CONFIG_ADMIN_INFO_GET    0x0004
#define SRVSVC_CONFIG_INFO_SET          0x0010

#define SRVSVC_CONFIG_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED     | \
                                   SRVSVC_CONFIG_USER_INFO_GET  | \
                                   SRVSVC_CONFIG_POWER_INFO_GET | \
                                   SRVSVC_CONFIG_ADMIN_INFO_GET | \
                                   SRVSVC_CONFIG_INFO_SET )

//
// Access masks for connection information (NetConnectionEnum).
//

#define SRVSVC_CONNECTION_INFO_GET      0x0001

#define SRVSVC_CONNECTION_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED     | \
                                       SRVSVC_CONNECTION_INFO_GET )

//
// Access masks for disk information (NetServerDiskEnum).
//

#define SRVSVC_DISK_ENUM    0x0001

#define SRVSVC_DISK_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED | \
                                 SRVSVC_DISK_ENUM )

//
// Access masks for file information (NetFileEnum, NetFileGetInfo,
// NetFileClose).
//

#define SRVSVC_FILE_INFO_GET    0x0001
#define SRVSVC_FILE_CLOSE       0x0010

#define SRVSVC_FILE_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED | \
                                 SRVSVC_FILE_INFO_GET     | \
                                 SRVSVC_FILE_CLOSE )

//
// Access masks for session information (NetSessionEnum,
// NetSessionGetInfo, NetSessionDel).
//

#define SRVSVC_SESSION_USER_INFO_GET    0x0001
#define SRVSVC_SESSION_ADMIN_INFO_GET   0x0002
#define SRVSVC_SESSION_DELETE           0x0010

#define SRVSVC_SESSION_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED        | \
                                    SRVSVC_SESSION_USER_INFO_GET    | \
                                    SRVSVC_SESSION_ADMIN_INFO_GET   | \
                                    SRVSVC_SESSION_DELETE )

//
// Access masks for share information (NetShareAdd, NetShareDel,
// NetShareEnum, NetShareGetInfo, NetShareCheck, NetShareSetInfo).
//
// Access masks for connecting to shares are defined in srvfsctl.h,
// since they must be shared between the server and server service.
//

#define SRVSVC_SHARE_USER_INFO_GET     0x0001
#define SRVSVC_SHARE_ADMIN_INFO_GET    0x0002
#define SRVSVC_SHARE_INFO_SET          0x0010

#define SRVSVC_SHARE_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED    | \
                                  SRVSVC_SHARE_USER_INFO_GET  | \
                                  SRVSVC_SHARE_ADMIN_INFO_GET | \
                                  SRVSVC_SHARE_INFO_SET )

//
// Access masks for statistics information (NetStatisticsGet,
// NetStatisticsClear).
//

#define SRVSVC_STATISTICS_GET       0x0001

#define SRVSVC_STATISTICS_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED  | \
                                       SRVSVC_STATISTICS_GET )

#endif // _SSSEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\tod.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    tod.c

Abstract:

    This module contains the server end of the NetRemoteTOD API.


Author:

    Rajen Shah        (rajens)    02-Apr-1991

[Environment:]

    User Mode - Mixed NT and Win32

Revision History:

    02-Apr-1991     RajenS
        Created
    02-Mar-1992     JohnRo
        Disable DbgPrints for normal APIs (caused loss of elapsed time!)
    08-Apr-1992     ChuckL
        Moved into server service
    10-Jun-1993 JohnRo
        RAID 13081: NetRemoteTOD should return timezone info.
    16-Jun-1993 JohnRo
        RAID 13080: Fix GP fault if MIDL_user_allocate returns NULL ptr or
        caller passes us NULL ptr.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <lmcons.h>
#include <netlibnt.h>
#include <lmremutl.h>
#include <rpcutil.h>
#include <ssdebug.h>    // SS_PRINT() macro.
#include <timelib.h>

#define     TOD_DEFAULT_INTERVAL    310            // 310-milisecond interval


NTSTATUS
timesvc_RemoteTimeOfDay(
    OUT LPTIME_OF_DAY_INFO  *lpTimeOfDayInfo
    )

/*++

Routine Description:

    This routine calls the Win32 and NT base timer APIs to get the
    relevant time/date information. It also calls the Rtl routine to
    convert the time elapsed since 1-1-1970.

    The routine allocates a buffer to contain the time of day information
    and returns a pointer to that buffer to the caller.

Arguments:

    lpTimeOfDayInfo        - Location of where to place pointer to buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SYSTEMTIME SystemTime;
    LARGE_INTEGER Time;
    DWORD TickCount;
    LPTIME_OF_DAY_INFO        lpTimeOfDay;
    LONG LocalTimeZoneOffsetSecs;  // offset (+ for West of GMT, etc).

    if (lpTimeOfDayInfo == NULL) {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Call the appropriate routines to collect the time information
    //

    GetSystemTime(&SystemTime);

    //
    // Get number of seconds from UTC.  Positive values for west of Greenwich,
    // negative values for east of Greenwich.
    //
    LocalTimeZoneOffsetSecs = NetpLocalTimeZoneOffset();

    //
    // Allocate a TimeOfDay_INFO structure that is to be returned to the
    // caller and fill it with the relevant data.
    //

    *lpTimeOfDayInfo = (TIME_OF_DAY_INFO *) MIDL_user_allocate(
                            sizeof (struct _TIME_OF_DAY_INFO)
                            );

    if (*lpTimeOfDayInfo == NULL) {
        SS_PRINT((
                "SRVSVC: timesvc_RemoteTimeOfDay"
                "got NULL from MIDL_user_allocate!\n" ));
        return(STATUS_NO_MEMORY);
    }

    lpTimeOfDay = (LPTIME_OF_DAY_INFO)(*lpTimeOfDayInfo);

    lpTimeOfDay->tod_hours         = SystemTime.wHour;
    lpTimeOfDay->tod_mins         = SystemTime.wMinute;
    lpTimeOfDay->tod_secs         = SystemTime.wSecond;
    lpTimeOfDay->tod_hunds         = SystemTime.wMilliseconds/10;
    lpTimeOfDay->tod_tinterval = TOD_DEFAULT_INTERVAL;
    lpTimeOfDay->tod_day         = SystemTime.wDay;
    lpTimeOfDay->tod_month         = SystemTime.wMonth;
    lpTimeOfDay->tod_year         = SystemTime.wYear;
    lpTimeOfDay->tod_weekday         = SystemTime.wDayOfWeek;

    // tod_timezone is + for west of GMT, - for east of it.
    // tod_timezone is in minutes.
    lpTimeOfDay->tod_timezone    = LocalTimeZoneOffsetSecs / 60;

    // Get the 64-bit system time.
    // Convert the system time to the number of miliseconds
    // since 1-1-1970.
    //

    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time,
                              &(lpTimeOfDay->tod_elapsedt)
                             );

    // Get the free running counter value
    //
    TickCount = GetTickCount();
    lpTimeOfDay->tod_msecs = TickCount;

    return(STATUS_SUCCESS);

} // timesvc_RemoteTimeOfDay


NET_API_STATUS
NetrRemoteTOD (
    IN        LPSTR                    ServerName,
    OUT LPTIME_OF_DAY_INFO  *lpTimeOfDayInfo
    )

/*++

Routine Description:

  This is the RPC server entry point for the NetRemoteTOD API.

Arguments:

    ServerName            - Name of server on which this API is to be executed.
                      It should match this server's name - no checking is
                      done since it is assumed that RPC did the right thing.

    lpTimeOfDayInfo - On return takes a pointer to a TIME_OF_DAY_INFO
                      structure - the memory is allocated here.


Return Value:

    Returns a NET_API_STATUS code.
    Also returns a pointer to the TIME_OF_DAY_INFO data buffer that was
    allocated, if there is no error.


--*/
{
    NTSTATUS status;

    //
    // Call the worker routine to collect all the time/date information
    //
    status = timesvc_RemoteTimeOfDay(lpTimeOfDayInfo);

    //
    // Translate the NTSTATUS to a NET_API_STATUS error, and return it.
    //

    return(NetpNtStatusToApiStatus(status));

    UNREFERENCED_PARAMETER( ServerName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\sssubs.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    SsSubs.c

Abstract:

    This module contains support routines for the NT server service.

Author:

    David Treadwell (davidtr)    10-Jan-1991

Revision History:

--*/

#include "srvsvcp.h"
#include "ssreg.h"

#include <lmerr.h>
#include <lmsname.h>
#include <netlibnt.h>
#include <tstr.h>

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>

#include <ntddnfs.h>

#define MRXSMB_DEVICE_NAME TEXT("\\Device\\LanmanRedirector")


PSERVER_REQUEST_PACKET
SsAllocateSrp (
    VOID
    )

/*++

Routine Description:

    This routine allocates a serer request packet so that an API can
    communicate with the kernel-mode server.  Any general initialization
    in performed here.

Arguments:

    None.

Return Value:

    PSERVER_REQUEST_PACKET - a pointer to the allocated SRP.

--*/

{
    PSERVER_REQUEST_PACKET srp;

    srp = MIDL_user_allocate( sizeof(SERVER_REQUEST_PACKET) );
    if ( srp != NULL ) {
        RtlZeroMemory( srp, sizeof(SERVER_REQUEST_PACKET) );
    }

    return srp;

}  // SsAllocateSrp

#if DBG

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    BOOL ok;
    CHAR choice[16];
    DWORD bytes;
    DWORD error;

    SsPrintf( "\nAssertion failed: %s\n  at line %ld of %s\n",
                FailedAssertion, LineNumber, FileName );
    do {
        HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);

        SsPrintf( "Break or Ignore [bi]? " );

        if (hStdIn && (hStdIn != INVALID_HANDLE_VALUE))
        {
            bytes = sizeof(choice);
            ok = ReadFile(
                    hStdIn,
                    &choice,
                    bytes,
                    &bytes,
                    NULL
                    );
        }
        else
        {
            // default to "break"
            ok = TRUE;
            choice[0] = TEXT('B');
        }

        if ( ok ) {
            if ( toupper(choice[0]) == 'I' ) {
                break;
            }
            if ( toupper(choice[0]) == 'B' ) {
                DbgUserBreakPoint( );
            }
        } else {
            error = GetLastError( );
        }
    } while ( TRUE );

    return;

} // SsAssert
#endif


VOID
SsCloseServer (
    VOID
    )

/*++

Routine Description:

    This routine closes the server file system device, if it has been
    opened.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Close the server device, if it has been opened.
    //

    if ( SsData.SsServerDeviceHandle != NULL ) {
        NtClose( SsData.SsServerDeviceHandle );
        SsData.SsServerDeviceHandle = NULL;
    }

} // SsCloseServer


VOID
SsControlCHandler (
    IN ULONG CtrlType
    )

/*++

Routine Description:

    Captures and ignores a kill signal.  Without this, any ^C pressed in
    the window that started the server service will result in this
    process being killed, and then the server can't function properly.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CtrlType;

    return;

} // SsControlCHandler


VOID
SsFreeSrp (
    IN PSERVER_REQUEST_PACKET Srp
    )

/*++

Routine Description:

    Frees an SRP allocated by SsAllocateSrp.

Arguments:

    Srp - a pointer to the SRP to free.

Return Value:

    None.

--*/

{
    MIDL_user_free( Srp );

}  // SsFreeSrp


VOID
SsLogEvent(
    IN DWORD MessageId,
    IN DWORD NumberOfSubStrings,
    IN LPWSTR *SubStrings,
    IN DWORD ErrorCode
    )
{
    HANDLE logHandle;
    DWORD dataSize = 0;
    LPVOID rawData = NULL;
    USHORT eventType = EVENTLOG_ERROR_TYPE;

    logHandle = RegisterEventSource(
                    NULL,
                    SERVER_DISPLAY_NAME
                    );

    if ( logHandle == NULL ) {
        SS_PRINT(( "SRVSVC: RegisterEventSource failed: %lu\n",
                    GetLastError() ));
        return;
    }

    if ( ErrorCode != NERR_Success ) {

        //
        // An error code was specified.
        //

        dataSize = sizeof(ErrorCode);
        rawData = (LPVOID)&ErrorCode;

    }

    //
    //  If the message is is only a warning, then set the event type as such.
    //  This is doc'd in netevent.h.
    //

    if ((ULONG)(MessageId & 0xC0000000) == (ULONG) 0x80000000 ) {

        eventType = EVENTLOG_WARNING_TYPE;
    }

    //
    // Log the error.
    //

    if ( !ReportEventW(
            logHandle,
            eventType,
            0,                  // event category
            MessageId,
            NULL,               // user SID
            (WORD)NumberOfSubStrings,
            dataSize,
            SubStrings,
            rawData
            ) ) {
        SS_PRINT(( "SRVSVC: ReportEvent failed: %lu\n",
                    GetLastError() ));
    }

    if ( !DeregisterEventSource( logHandle ) ) {
        SS_PRINT(( "SRVSVC: DeregisterEventSource failed: %lu\n",
                    GetLastError() ));
    }

    return;

} // SsLogEvent


NET_API_STATUS
SsOpenServer ()

/*++

Routine Description:

    This routine opens the server file system device, allowing the
    server service to send FS controls to it.

Arguments:

    None.

Return Value:

    NET_API_STATUS - results of operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeServerName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Open the server device.
    //

    RtlInitUnicodeString( &unicodeServerName, SERVER_DEVICE_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Opening the server with desired access = SYNCHRONIZE and open
    // options = FILE_SYNCHRONOUS_IO_NONALERT means that we don't have
    // to worry about waiting for the NtFsControlFile to complete--this
    // makes all IO system calls that use this handle synchronous.
    //

    status = NtOpenFile(
                 &SsData.SsServerDeviceHandle,
                 FILE_ALL_ACCESS & ~SYNCHRONIZE,
                 &objectAttributes,
                 &ioStatusBlock,
                 0,
                 0
                 );

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SsOpenServer: NtOpenFile (server device object) "
                          "failed: %X\n", status ));
        }
        return NetpNtStatusToApiStatus( status );
    }

    //
    // We're now ready to talk to the server.
    //

    return NO_ERROR;

} // SsOpenServer

#if DBG

VOID
SsPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;
    HANDLE hStdOut;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    
    if (hStdOut && (hStdOut != INVALID_HANDLE_VALUE))
    {
        WriteFile(hStdOut, (LPVOID )OutputBuffer, length, &length, NULL );
    }

} // SsPrintf
#endif


NET_API_STATUS
SsServerFsControlGetInfo (
    IN ULONG ServerControlCode,
    IN PSERVER_REQUEST_PACKET Srp,
    IN OUT PVOID *OutputBuffer,
    IN ULONG PreferredMaximumLength
    )

/*++

Routine Description:

    This routine sends an SRP to the server for an API that retrieves
    information from the server and takes a PreferredMaximumLength
    parameter.

Arguments:

    ServerControlCode - the FSCTL code for the operation.

    Srp - a pointer to the SRP for the operation.

    OutputBuffer - a pointer to receive a pointer to the buffer
        allocated by this routine to hold the output information.

    PreferredMaximumLength - the PreferredMaximumLength parameter.

Return Value:

    NET_API_STATUS - results of operation.

--*/

{
    NET_API_STATUS status = STATUS_SUCCESS;
    ULONG resumeHandle = Srp->Parameters.Get.ResumeHandle;
    ULONG BufLen = min( INITIAL_BUFFER_SIZE, PreferredMaximumLength );
    ULONG i;

    *OutputBuffer = NULL;

    //
    // Normally, we should only go through this loop at most 2 times.  But
    //   if the amount of data the server needs to return is growing, then
    //   we might be forced to run through it a couple of more times.  '5'
    //   is an arbitrary number just to ensure we don't get stuck.
    //

    for( i=0; i < 5; i++ ) {

        if( *OutputBuffer ) {
            MIDL_user_free( *OutputBuffer );
        }

        *OutputBuffer = MIDL_user_allocate( BufLen );

        if( *OutputBuffer == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Make the request of the server.
        //

        Srp->Parameters.Get.ResumeHandle = resumeHandle;

        status = SsServerFsControl(
                    ServerControlCode,
                    Srp,
                    *OutputBuffer,
                    BufLen
                    );

        //
        // If we were successful, or we got an error other than our buffer
        //   being too small, break out.
        //
        if ( status != ERROR_MORE_DATA && status != NERR_BufTooSmall ) {
            break;
        }

        //
        // We've been told that our buffer isn't big enough.  But if we've hit
        //  the caller's PreferredMaximumLength, break out.
        //
        if( BufLen >= PreferredMaximumLength ) {
            break;
        }

        //
        // Let's try again.  EXTRA_ALLOCATION is here to cover the case where the
        //   amount of space required grows between the previous FsControl call and
        //   the next one.
        //
        BufLen = min( Srp->Parameters.Get.TotalBytesNeeded + EXTRA_ALLOCATION,
                    PreferredMaximumLength );

    }

    if ( *OutputBuffer && Srp->Parameters.Get.EntriesRead == 0 ) {
        MIDL_user_free( *OutputBuffer );
        *OutputBuffer = NULL;
    }

    return status;

} // SsServerFsControlGetInfo


NET_API_STATUS
SsServerFsControl (
    IN ULONG ServerControlCode,
    IN PSERVER_REQUEST_PACKET Srp OPTIONAL,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine sends an FSCTL to the server using the previously opened
    server handle

Arguments:

    ServerControlCode - the FSCTL code to send to the server.

    Srp - a pointer to the SRP for the operation.

    Buffer - a pointer to the buffer to pass to the server as the
        "OutputBuffer" parameter of NtFsControlFile.

    BufferLength - the size of this buffer.

Return Value:

    NET_API_STATUS - results of the operation.

--*/

{
    NTSTATUS status;
    NET_API_STATUS error;
    IO_STATUS_BLOCK ioStatusBlock;
    PSERVER_REQUEST_PACKET sendSrp;
    ULONG sendSrpLength;
    PWCH name1Buffer, name2Buffer;
    HANDLE eventHandle;

    if( SsData.SsServerDeviceHandle == NULL ) {
        DbgPrint( "SRVSVC: SsData.SsServerDeviceHandle == NULL\n" );
        return ERROR_BAD_NET_RESP;
    }

    //
    // If a name was specified, we must capture the SRP along with the
    // name in order to avoid sending embedded input pointers.
    //

    if ( Srp != NULL ) {

        name1Buffer = Srp->Name1.Buffer;
        name2Buffer = Srp->Name2.Buffer;

        if ( Srp->Name1.Buffer != NULL || Srp->Name2.Buffer != NULL ) {

            PCHAR nextStringLocation;

            //
            // Allocate enough space to hold the SRP + name.
            //

            sendSrpLength = sizeof(SERVER_REQUEST_PACKET);

            if ( Srp->Name1.Buffer != NULL ) {
                sendSrpLength += Srp->Name1.MaximumLength;
            }

            if ( Srp->Name2.Buffer != NULL ) {
                sendSrpLength += Srp->Name2.MaximumLength;
            }

            sendSrp =  MIDL_user_allocate( sendSrpLength );

            if ( sendSrp == NULL ) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Copy over the SRP.
            //

            RtlCopyMemory( sendSrp, Srp, sizeof(SERVER_REQUEST_PACKET) );

            //
            // Set up the names in the new SRP.
            //

            nextStringLocation = (PCHAR)( sendSrp + 1 );

            if ( Srp->Name1.Buffer != NULL ) {

                sendSrp->Name1.Length = Srp->Name1.Length;
                sendSrp->Name1.MaximumLength = Srp->Name1.MaximumLength;
                sendSrp->Name1.Buffer = (PWCH)nextStringLocation;

                RtlCopyMemory(
                    sendSrp->Name1.Buffer,
                    Srp->Name1.Buffer,
                    Srp->Name1.MaximumLength
                    );

                nextStringLocation += Srp->Name1.MaximumLength;

                POINTER_TO_OFFSET( sendSrp->Name1.Buffer, sendSrp );
            }

            if ( Srp->Name2.Buffer != NULL ) {

                sendSrp->Name2.Length = Srp->Name2.Length;
                sendSrp->Name2.MaximumLength = Srp->Name2.MaximumLength;
                sendSrp->Name2.Buffer = (PWCH)nextStringLocation;

                RtlCopyMemory(
                    sendSrp->Name2.Buffer,
                    Srp->Name2.Buffer,
                    Srp->Name2.MaximumLength
                    );

                POINTER_TO_OFFSET( sendSrp->Name2.Buffer, sendSrp );
            }

        } else {

            //
            // There was no name in the SRP, so just send the SRP that was
            // passed in.
            //

            sendSrp = Srp;
            sendSrpLength = sizeof(SERVER_REQUEST_PACKET);
        }

    } else {

        //
        // This request has no SRP.
        //

        sendSrp = NULL;
        sendSrpLength = 0;

    }

    //
    // Create an event to synchronize with the driver
    //
    status = NtCreateEvent(
                &eventHandle,
                FILE_ALL_ACCESS,
                NULL,
                NotificationEvent,
                FALSE
                );

    //
    // Send the request to the server FSD.
    //
    if( NT_SUCCESS( status ) ) {

        status = NtFsControlFile(
                 SsData.SsServerDeviceHandle,
                 eventHandle,
                 NULL,
                 NULL,
                 &ioStatusBlock,
                 ServerControlCode,
                 sendSrp,
                 sendSrpLength,
                 Buffer,
                 BufferLength
                 );

        if( status == STATUS_PENDING ) {
            NtWaitForSingleObject( eventHandle, FALSE, NULL );
        }

        NtClose( eventHandle );
    }

    //
    // If an error code was set in the SRP, use it.  Otherwise, if
    // an error was returned or set in the IO status block, use that.
    //

    if ( (sendSrp != NULL) && (sendSrp->ErrorCode != NO_ERROR) ) {
        error = sendSrp->ErrorCode;
        IF_DEBUG(API_ERRORS) {
            SS_PRINT(( "SsServerFsControl: (1) API call %lx to srv failed, "
                        "err = %ld\n", ServerControlCode, error ));
        }
    } else {
        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }
        if ( status == STATUS_SERVER_HAS_OPEN_HANDLES ) {
            error = ERROR_SERVER_HAS_OPEN_HANDLES;
        } else {
            error = NetpNtStatusToApiStatus( status );
        }
        if ( error != NO_ERROR ) {
            IF_DEBUG(API_ERRORS) {
                SS_PRINT(( "SsServerFsControl: (2) API call %lx to srv "
                            "failed, err = %ld, status = %X\n",
                            ServerControlCode, error, status ));
            }
        }
    }

    //
    // If a separate buffer was allocated to capture the name, copy
    // over the new SRP and free it.
    //

    if ( sendSrp != Srp ) {
        RtlCopyMemory( Srp, sendSrp, sizeof(SERVER_REQUEST_PACKET) );
        Srp->Name1.Buffer = name1Buffer;
        Srp->Name2.Buffer = name2Buffer;
        MIDL_user_free( sendSrp );
    }

    return error;

} // SsServerFsControl


DWORD
SsGetServerType (
    VOID
    )
/*++

Routine Description:

    Return the ServiceBits of all the services implemented by this service.

    Enter with SsData.SsServerInfoResource locked.

Arguments:

    None

Return Value:

    SV_TYPE service bits.

--*/
{
    DWORD serviceBits;

    serviceBits = SV_TYPE_SERVER | SV_TYPE_NT | SsData.ServiceBits;

    if( SsData.IsDfsRoot ) {
        serviceBits |= SV_TYPE_DFS;
    }

    if ( SsData.ServerInfo599.sv599_timesource ) {
        serviceBits |= SV_TYPE_TIME_SOURCE;
    }

    if ( SsData.ServerInfo598.sv598_producttype == NtProductServer ) {
        serviceBits |= SV_TYPE_SERVER_NT;
    }

    if ( SsData.NumberOfPrintShares != 0 ) {
        serviceBits |= SV_TYPE_PRINTQ_SERVER;
    }

    return serviceBits;

}


VOID
SsSetExportedServerType (
    IN PNAME_LIST_ENTRY service        OPTIONAL,
    IN BOOL ExternalBitsAlreadyChanged,
    IN BOOL UpdateImmediately
    )
{
    DWORD serviceBits;
    DWORD newServiceBits;
    BOOL changed = ExternalBitsAlreadyChanged;

    //
    // The value returned in the sv102_type field is an amalgam of the
    // following:
    //
    // 1) The internal server type bits SV_TYPE_SERVER (always set),
    //    SV_TYPE_NT (always set), SV_TYPE_TIME_SOURCE (set if the
    //    parameter TimeSource is TRUE), and SV_TYPE_PRINTQ_SERVER (set
    //    if there are any print shares).
    //
    // 2) SV_TYPE_DFS if this machine is the root of a DFS tree
    //
    // 3) The bits set by the service controller calling I_NetServerSetServiceBits.
    //      SV_TYPE_TIME_SOURCE is a pseudo internal bit.  It can be set
    //      internally or it can be set by the w32time service.
    //
    // 4) The logical OR of all per-transport server type bits set by
    //    the Browser calling I_NetServerSetServiceBits.
    //

    (VOID)RtlAcquireResourceExclusive( &SsData.SsServerInfoResource, TRUE );

    serviceBits = SsGetServerType();

    if( ARGUMENT_PRESENT( service ) ) {
        //
        // Change the bits for the passed-in NAME_LIST_ENTRY only
        //

        newServiceBits = service->ServiceBits;
        newServiceBits &= ~(SV_TYPE_SERVER_NT | SV_TYPE_PRINTQ_SERVER | SV_TYPE_DFS);
        newServiceBits |= serviceBits;

        if( service->ServiceBits != newServiceBits ) {
            service->ServiceBits |= newServiceBits;
            changed = TRUE;
        }

    } else {
        //
        // Change the bits for each NAME_LIST_ENTRY
        //
        for ( service = SsData.SsServerNameList; service != NULL; service = service->Next ) {

            newServiceBits = service->ServiceBits;
            newServiceBits &= ~(SV_TYPE_SERVER_NT | SV_TYPE_PRINTQ_SERVER | SV_TYPE_DFS );
            newServiceBits |= serviceBits;

            if( service->ServiceBits != newServiceBits ) {
                service->ServiceBits |= newServiceBits;
                changed = TRUE;
            }
        }
    }

    RtlReleaseResource( &SsData.SsServerInfoResource );

    if ( changed && UpdateImmediately ) {
        if( SsData.SsStatusChangedEvent )
        {
            if ( !SetEvent( SsData.SsStatusChangedEvent ) ) {
                SS_PRINT(( "SsSetExportedServerType: SetEvent failed: %ld\n",
                        GetLastError( ) ));
            }
        }
    }

    return;

} // SsSetExportedServerType


NET_API_STATUS
SsSetField (
    IN PFIELD_DESCRIPTOR Field,
    IN PVOID Value,
    IN BOOLEAN WriteToRegistry,
    OUT BOOLEAN *AnnouncementInformationChanged OPTIONAL
    )
{
    PCHAR structure;

    //
    // *** We do not initialize *AnnouncementInformationChanged to
    //     FALSE!  We leave it alone, unless interesting information is
    //     changed, in which case we set it to TRUE.  This is to allow a
    //     caller to initialize it itself, then call this function
    //     multiple times, with the resulting value in the parameter
    //     being TRUE if at least one of the calls changed an
    //     interesting parameter.
    //

    //
    // Determine the structure that will be set.
    //

    if ( Field->Level / 100 == 5 ) {
        if ( Field->Level != 598 ) {
            structure = (PCHAR)&SsData.ServerInfo599;
        } else {
            structure = (PCHAR)&SsData.ServerInfo598;
        }
    } else {
        structure = (PCHAR)&SsData.ServerInfo102;
    }

    //
    // Set the value in the field based on the field type.
    //

    switch ( Field->FieldType ) {

    case BOOLEAN_FIELD: {

        BOOLEAN value = *(PBOOLEAN)Value;
        PBOOLEAN valueLocation;

        //
        // BOOLEANs may only be TRUE (1) or FALSE (0).
        //

        if ( value != TRUE && value != FALSE ) {
            return ERROR_INVALID_PARAMETER;
        }

        valueLocation = (PBOOLEAN)( structure + Field->FieldOffset );

        //
        // If we're turning off Hidden (i.e., making the server public),
        // indicate that an announcment-related parameter has changed.
        // This will cause an announcement to be sent immediately.
        //

        if ( (Field->FieldOffset ==
                        FIELD_OFFSET( SERVER_INFO_102, sv102_hidden )) &&
             (value && !(*valueLocation)) &&
             (ARGUMENT_PRESENT(AnnouncementInformationChanged)) ) {
                *AnnouncementInformationChanged = TRUE;
        }

        *valueLocation = value;

        break;
    }

    case DWORD_FIELD: {

        DWORD value = *(PDWORD)Value;
        PDWORD valueLocation;

        //
        // Make sure that the specified value is in the range of
        // legal values for the Field.
        //

        if ( value > Field->MaximumValue || value < Field->MinimumValue ) {
            return ERROR_INVALID_PARAMETER;
        }

        valueLocation = (PDWORD)( structure + Field->FieldOffset );
        *valueLocation = value;

        break;
    }

    case LPSTR_FIELD: {

        LPWCH value = *(LPWCH *)Value;
        LPWSTR valueLocation;
        ULONG maxLength;

        //
        // We are setting the name, comment, or userpath for the server.
        // Use the field offset to determine which.
        //

        if ( Field->FieldOffset ==
                 FIELD_OFFSET( SERVER_INFO_102, sv102_name ) ) {
            valueLocation = SsData.ServerNameBuffer;
            maxLength = sizeof( SsData.SsServerTransportAddress );
        } else if ( Field->FieldOffset ==
                        FIELD_OFFSET( SERVER_INFO_102, sv102_comment ) ) {
            valueLocation = SsData.ServerCommentBuffer;
            maxLength = MAXCOMMENTSZ;
        } else if ( Field->FieldOffset ==
                        FIELD_OFFSET( SERVER_INFO_102, sv102_userpath ) ) {
            valueLocation = SsData.UserPathBuffer;
            maxLength = MAX_PATH;
        } else if ( Field->FieldOffset ==
                        FIELD_OFFSET( SERVER_INFO_599, sv599_domain ) ) {
            valueLocation = SsData.DomainNameBuffer;
            maxLength = DNLEN;
        } else {
            SS_ASSERT( FALSE );
            return ERROR_INVALID_PARAMETER;
        }

        //
        // If the string is too long, return an error.
        //

        if ( (value != NULL) && (STRLEN(value) > maxLength) ) {
            return ERROR_INVALID_PARAMETER;
        }

        //
        // If we're changing the server comment, indicate that an
        // announcment-related parameter has changed.  This will cause
        // an announcement to be sent immediately.
        //

        if ( (Field->FieldOffset ==
                        FIELD_OFFSET( SERVER_INFO_102, sv102_comment )) &&
             ( ((value == NULL) && (*valueLocation != '\0')) ||
               ((value != NULL) && (wcscmp(value,valueLocation) != 0)) ) &&
             (ARGUMENT_PRESENT(AnnouncementInformationChanged)) ) {
                *AnnouncementInformationChanged = TRUE;
        }

        //
        // If the input is NULL, make the string zero length.
        //

        if ( value == NULL ) {

            *valueLocation = '\0';
            *(valueLocation+1) = '\0';

        } else {

            wcscpy( valueLocation, value );

        }

        break;
    }

    } // end switch

    //
    // The change worked.  If requested, add the parameter to the
    // registry, thus effecting a sticky change.  Don't write it
    // to the registry if this is xxx_comment or xxx_disc since
    // we already write out their more well known aliases
    // srvcomment and autodisconnect.  Changes here should also be
    // made to SetStickyParameters().
    //

    if ( WriteToRegistry &&
         (_wcsicmp( Field->FieldName, DISC_VALUE_NAME ) != 0) &&
         (_wcsicmp( Field->FieldName, COMMENT_VALUE_NAME ) != 0) ) {

        SsAddParameterToRegistry( Field, Value );
    }

    return NO_ERROR;

} // SsSetField

UINT
SsGetDriveType (
    IN LPWSTR path
)
/*++

Routine Description:

    This routine calls GetDriveType, attempting to eliminate
    the DRIVE_NO_ROOT_DIR type

Arguments:

    A path

Return Value:

    The drive type

--*/
{
    UINT driveType = GetDriveType( path );

    if( driveType == DRIVE_NO_ROOT_DIR ) {

        if( path[0] != UNICODE_NULL && path[1] == L':' ) {

            WCHAR shortPath[ 4 ];

            shortPath[0] = path[0];
            shortPath[1] = L':';
            shortPath[2] = L'\\';
            shortPath[3] = L'\0';

            driveType = GetDriveType( shortPath );

        } else {

            ULONG len = wcslen( path );
            LPWSTR pathWithSlash = MIDL_user_allocate( (len + 2) * sizeof( *path ) );

            if( pathWithSlash != NULL ) {
                RtlCopyMemory( pathWithSlash, path, len * sizeof( *path ) );
                pathWithSlash[ len ] = L'\\';
                pathWithSlash[ len+1 ] = L'\0';
                driveType = GetDriveType( pathWithSlash );
                MIDL_user_free( pathWithSlash );
            }
        }
    }

    return driveType;
}

VOID
SsNotifyRdrOfGuid(
    LPGUID Guid
    )
{
    NTSTATUS status;
    HANDLE hMrxSmbHandle;
    UNICODE_STRING unicodeServerName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Open the server device.
    //

    RtlInitUnicodeString( &unicodeServerName, MRXSMB_DEVICE_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Opening the server with desired access = SYNCHRONIZE and open
    // options = FILE_SYNCHRONOUS_IO_NONALERT means that we don't have
    // to worry about waiting for the NtFsControlFile to complete--this
    // makes all IO system calls that use this handle synchronous.
    //

    status = NtOpenFile(
                 &hMrxSmbHandle,
                 FILE_ALL_ACCESS & ~SYNCHRONIZE,
                 &objectAttributes,
                 &ioStatusBlock,
                 0,
                 0
                 );

    if ( NT_SUCCESS(status) ) {
        status = NtFsControlFile( hMrxSmbHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &ioStatusBlock,
                                  FSCTL_LMR_SET_SERVER_GUID,
                                  Guid,
                                  sizeof(GUID),
                                  NULL,
                                  0 );

        NtClose( hMrxSmbHandle );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\xport.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    Xport.c

Abstract:

    This module contains support for the ServerTransport catagory of
    APIs for the NT server service.

Author:

    David Treadwell (davidtr)    10-Mar-1991

Revision History:

--*/

#include "srvsvcp.h"
#include "ssreg.h"

#include <tstr.h>

//
// Forward declarations.
//

LPSERVER_TRANSPORT_INFO_3
CaptureSvti3 (
    IN DWORD Level,
    IN LPTRANSPORT_INFO Svti,
    OUT PULONG CapturedSvtiLength
    );



NET_API_STATUS NET_API_FUNCTION
I_NetrServerTransportAddEx (
    IN DWORD Level,
    IN LPTRANSPORT_INFO Buffer
    )
{
    NET_API_STATUS error;
    LPSERVER_TRANSPORT_INFO_3 capturedSvti3;
    LPSTR TransportAddress;  // Pointer to transport address within capturedSvti1
    ULONG capturedSvtiLength;
    PSERVER_REQUEST_PACKET srp;
    PNAME_LIST_ENTRY service;
    PTRANSPORT_LIST_ENTRY transport;
    BOOLEAN serviceAllocated = FALSE;
    LPTSTR DomainName = NULL;
    ULONG Flags = 0;
    DWORD len;

    if( Level >= 1 && Buffer->Transport1.svti1_domain != NULL ) {
        DomainName = Buffer->Transport1.svti1_domain;

        if( STRLEN( DomainName ) > DNLEN ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if( Level >= 2 && Buffer->Transport2.svti2_flags != 0 ) {
        Flags = Buffer->Transport2.svti2_flags;

        //
        // Make sure valid flags are passed in
        //
        if( Flags & (~SVTI2_REMAP_PIPE_NAMES) ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Capture the transport request buffer and form the full transport
    // address.
    //

    capturedSvti3 = CaptureSvti3( Level, Buffer, &capturedSvtiLength );

    if ( capturedSvti3 == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    TransportAddress = capturedSvti3->svti3_transportaddress;
    OFFSET_TO_POINTER( TransportAddress, capturedSvti3 );

    //
    // Make sure this name isn't already bound for the transport
    //
    (VOID)RtlAcquireResourceExclusive( &SsData.SsServerInfoResource, TRUE );

    if( DomainName == NULL ) {
        DomainName = SsData.DomainNameBuffer;
    }

    for( service = SsData.SsServerNameList; service != NULL; service = service->Next ) {

        if( service->TransportAddressLength != capturedSvti3->svti3_transportaddresslength ) {
            continue;
        }

        if( !RtlEqualMemory( service->TransportAddress,
                             TransportAddress,
                             capturedSvti3->svti3_transportaddresslength
                            ) ) {
            continue;
        }

        for( transport=service->Transports; transport != NULL; transport=transport->Next ) {

            if( !STRCMPI( transport->TransportName, Buffer->Transport0.svti0_transportname ) ) {
                //
                // Error... this transport is already bound to the address
                //
                RtlReleaseResource( &SsData.SsServerInfoResource );
                MIDL_user_free( capturedSvti3 );
                return ERROR_DUP_NAME;
            }
        }

        break;
    }

    //
    // Counting on success, ensure we can allocate space for the new entry
    //
    if( service == NULL ) {

        len = sizeof( *service ) + sizeof( SsData.DomainNameBuffer );

        service = MIDL_user_allocate( len );

        if( service == NULL ) {
            RtlReleaseResource( &SsData.SsServerInfoResource );
            MIDL_user_free( capturedSvti3 );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RtlZeroMemory( service, len );

        service->DomainName = (LPTSTR)( service + 1 );

        serviceAllocated = TRUE;
    }

    len = sizeof( *transport ) +
          (STRLEN( Buffer->Transport0.svti0_transportname ) + sizeof(CHAR)) * sizeof( TCHAR );

    transport = MIDL_user_allocate( len );

    if( transport == NULL ) {

        RtlReleaseResource( &SsData.SsServerInfoResource );
        if( serviceAllocated ) {
            MIDL_user_free( service );
        }
        MIDL_user_free( capturedSvti3 );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( transport, len );

    //
    // Get a SRP in which to send the request.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        RtlReleaseResource( &SsData.SsServerInfoResource );
        if( serviceAllocated ) {
            MIDL_user_free( service );
        }
        MIDL_user_free( transport );
        MIDL_user_free( capturedSvti3 );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Add any user-supplied flags
    //

    if (Flags & SVTI2_REMAP_PIPE_NAMES) {

        srp->Flags |= SRP_XADD_REMAP_PIPE_NAMES;
    }

    //
    // Check if this is the primary machine name
    //

    if((capturedSvti3->svti3_transportaddresslength ==
                      SsData.SsServerTransportAddressLength)
                &&
        RtlEqualMemory(SsData.SsServerTransportAddress,
                       TransportAddress,
                       SsData.SsServerTransportAddressLength)  )
    {
        srp->Flags |= SRP_XADD_PRIMARY_MACHINE;
    }

    //
    // Send the request on to the server.
    //
    error = SsServerFsControl(
                FSCTL_SRV_NET_SERVER_XPORT_ADD,
                srp,
                capturedSvti3,
                capturedSvtiLength
                );

    //
    // Free the SRP
    //

    SsFreeSrp( srp );

    if( error != NO_ERROR ) {
        RtlReleaseResource( &SsData.SsServerInfoResource );
        if( serviceAllocated ) {
            MIDL_user_free( service );
        }
        MIDL_user_free( transport );
        MIDL_user_free( capturedSvti3 );
        return error;
    }

    //
    // Everything worked.  Add it to the NAME_LIST
    //
    transport->TransportName = (LPTSTR)(transport + 1 );
    STRCPY( transport->TransportName, Buffer->Transport0.svti0_transportname );
    transport->Next = service->Transports;
    service->Transports = transport;

    if( serviceAllocated ) {

        RtlCopyMemory( service->TransportAddress,
                       TransportAddress,
                       capturedSvti3->svti3_transportaddresslength );

        service->TransportAddress[ capturedSvti3->svti3_transportaddresslength ] = '\0';
        service->TransportAddressLength = capturedSvti3->svti3_transportaddresslength;

        STRCPY( service->DomainName, DomainName );

        service->Next = SsData.SsServerNameList;

        //
        // If this is the first transport and name added to the server, it must be the primary
        //  name
        //
        if( SsData.SsServerNameList == NULL ) {
            service->PrimaryName = 1;
        }

        SsData.SsServerNameList = service;
    }

    RtlReleaseResource( &SsData.SsServerInfoResource );
    MIDL_user_free( capturedSvti3 );
    SsSetExportedServerType( service, FALSE, FALSE );

    return NO_ERROR;
}

NET_API_STATUS NET_API_FUNCTION
NetrServerTransportAddEx (
    IN LPTSTR ServerName,
    IN DWORD Level,
    IN LPTRANSPORT_INFO Buffer
    )
{
    NET_API_STATUS error;
    PNAME_LIST_ENTRY service;
    ULONG Flags;

    ServerName;

    //
    // Make sure that the level is valid.
    //

    if ( Level != 0 && Level != 1 && Level != 2 && Level != 3 ) {
        return ERROR_INVALID_LEVEL;
    }

    if( Buffer->Transport0.svti0_transportname == NULL  ||
        Buffer->Transport0.svti0_transportaddress == NULL ||
        Buffer->Transport0.svti0_transportaddresslength == 0 ||
        Buffer->Transport0.svti0_transportaddresslength >= sizeof(service->TransportAddress) ) {

        return ERROR_INVALID_PARAMETER;
    }

    if( Level >= 2 && Buffer->Transport2.svti2_flags != 0 ) {

        Flags = Buffer->Transport2.svti2_flags;

        if (Flags & ~(SVTI2_REMAP_PIPE_NAMES)) {

            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Make sure that the caller is allowed to set information in the
    // server.
    //

    if( SsData.SsInitialized ) {
        error = SsCheckAccess(
                    &SsConfigInfoSecurityObject,
                    SRVSVC_CONFIG_INFO_SET
                    );

        if ( error != NO_ERROR ) {
            return ERROR_ACCESS_DENIED;
        }
    }

    return I_NetrServerTransportAddEx ( Level, Buffer );

} // NetrServerTransportAddEx

NET_API_STATUS NET_API_FUNCTION
NetrServerTransportAdd (
    IN LPTSTR ServerName,
    IN DWORD Level,
    IN LPSERVER_TRANSPORT_INFO_0 Buffer
)
{
    if( Level != 0 ) {
        return ERROR_INVALID_LEVEL;
    }

    return NetrServerTransportAddEx( ServerName, 0, (LPTRANSPORT_INFO)Buffer );
}

//
// This routine is called from xsproc when the server delivers us a PNP unbind
//  notification.  This routine unbinds all server names from the named transport
//
VOID
I_NetServerTransportDel(
    IN PUNICODE_STRING TransportName
)
{
    PSERVER_TRANSPORT_INFO_3 capturedSvti3;
    ULONG capturedSvtiLength;
    PSERVER_REQUEST_PACKET srp;
    PNAME_LIST_ENTRY service;
    PNAME_LIST_ENTRY sbackp = NULL;
    PTRANSPORT_LIST_ENTRY transport;
    PTRANSPORT_LIST_ENTRY tbackp = NULL;
    NET_API_STATUS error;

    //
    // Allocate the SERVER_TRANSPORT_INFO_3 structure and initialize it with
    //  the name of the transport we wish to delete
    //
    capturedSvtiLength = sizeof( SERVER_TRANSPORT_INFO_3 ) +
            TransportName->Length + sizeof(WCHAR);

    capturedSvti3 = MIDL_user_allocate( capturedSvtiLength );
    if( capturedSvti3 == NULL ) {
        return;
    }

    RtlZeroMemory( capturedSvti3, capturedSvtiLength );

    capturedSvti3->svti3_transportname = (LPTSTR)(capturedSvti3+1);
    RtlCopyMemory(  capturedSvti3->svti3_transportname,
                    TransportName->Buffer,
                    TransportName->Length
                 );

    POINTER_TO_OFFSET( capturedSvti3->svti3_transportname, capturedSvti3 );

    //
    // Get a SRP in which to send the request.
    //
    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        MIDL_user_free( capturedSvti3 );
        return;
    }

    //
    // Send the request on to the server.
    //
    error = SsServerFsControl(
                FSCTL_SRV_NET_SERVER_XPORT_DEL,
                srp,
                capturedSvti3,
                capturedSvtiLength
                );

    //
    // Free the SRP and svti
    //

    SsFreeSrp( srp );

    if( error != NO_ERROR ) {
        MIDL_user_free( capturedSvti3 );
        return;
    }

    OFFSET_TO_POINTER( capturedSvti3->svti3_transportname, capturedSvti3 );

    //
    // Now that we've deleted the transport from the server, delete it from
    //  our own internal structures
    //
    (VOID)RtlAcquireResourceExclusive( &SsData.SsServerInfoResource, TRUE );

    //
    // Remove the entry from the SsData.SsServerNameList.  If it's the last transport for
    //  the NAME_LIST_ENTRY, delete the NAME_LIST_ENTRY as well.  These lists are
    //  expected to be quite short, and this operation is infrequent,
    //   so the inefficiency of rescans should be of no consequence.
    //
outer_scan:
    for( service = SsData.SsServerNameList, sbackp = NULL;
         service != NULL;
         sbackp = service, service = service->Next ) {

inner_scan:
        for( transport=service->Transports, tbackp = NULL;
             transport != NULL;
             tbackp=transport, transport=transport->Next ) {

            if( STRCMPI( transport->TransportName, capturedSvti3->svti3_transportname ) ) {
                continue;
            }

            //
            // This is the one...remove it from the list
            //

            if( tbackp == NULL ) {
                service->Transports = transport->Next;
            } else {
                tbackp->Next = transport->Next;
            }

            MIDL_user_free( transport );

            goto inner_scan;
        }

        //
        // If this NAME_LIST_ENTRY no longer has any transports, delete it
        //
        if( service->Transports == NULL ) {
            if( sbackp == NULL ) {
                SsData.SsServerNameList = service->Next;
            } else {
                sbackp->Next = service->Next;
            }

            //
            // If this was the last NAME_LIST_ENTRY, save the ServiceBits
            //  in case another transport comes back later
            //
            if( SsData.SsServerNameList == NULL && SsData.ServiceBits == 0 ) {
                SsData.ServiceBits = service->ServiceBits;
            }

            MIDL_user_free( service );

            goto outer_scan;
        }
    }

    RtlReleaseResource( &SsData.SsServerInfoResource );
    MIDL_user_free( capturedSvti3 );
}


NET_API_STATUS NET_API_FUNCTION
NetrServerTransportDelEx (
    IN LPTSTR ServerName,
    IN DWORD Level,
    IN LPTRANSPORT_INFO Buffer
    )

{
    NET_API_STATUS error;
    LPSERVER_TRANSPORT_INFO_3 capturedSvti3;
    LPSTR TransportAddress;  // Pointer to transport address within capturedSvti1
    ULONG capturedSvtiLength;
    PSERVER_REQUEST_PACKET srp;
    PNAME_LIST_ENTRY service;
    PNAME_LIST_ENTRY sbackp = NULL;
    PTRANSPORT_LIST_ENTRY transport;
    PTRANSPORT_LIST_ENTRY tbackp = NULL;

    ServerName;

    //
    // Make sure that the level is valid.
    //

    if ( Level != 0 && Level != 1 ) {
        return ERROR_INVALID_LEVEL;
    }

    if( Buffer->Transport0.svti0_transportname == NULL ||
        Buffer->Transport0.svti0_transportaddress == NULL ||
        Buffer->Transport0.svti0_transportaddresslength == 0 ||
        Buffer->Transport0.svti0_transportaddresslength >= sizeof(service->TransportAddress) ) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure that the caller is allowed to set information in the
    // server.
    //

    if( SsData.SsInitialized ) {
        error = SsCheckAccess(
                    &SsConfigInfoSecurityObject,
                    SRVSVC_CONFIG_INFO_SET
                    );

        if ( error != NO_ERROR ) {
            return ERROR_ACCESS_DENIED;
        }
    }

    //
    // Capture the transport request buffer and form the full transport
    // address.
    //

    capturedSvti3 = CaptureSvti3( Level, Buffer, &capturedSvtiLength );

    if ( capturedSvti3 == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    TransportAddress = capturedSvti3->svti3_transportaddress;
    OFFSET_TO_POINTER( TransportAddress, capturedSvti3 );

    //
    // Get an SRP in which to send the request.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        MIDL_user_free( capturedSvti3 );
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Send the request on to the server.
    //
    error = SsServerFsControl(
                FSCTL_SRV_NET_SERVER_XPORT_DEL,
                srp,
                capturedSvti3,
                capturedSvtiLength
                );

    //
    // Free the SRP and svti
    //

    SsFreeSrp( srp );

    if( error != NO_ERROR ) {
        MIDL_user_free( capturedSvti3 );
        return error;
    }

    (VOID)RtlAcquireResourceExclusive( &SsData.SsServerInfoResource, TRUE );


    //
    // Remove the entry from the SsData.SsServerNameList.  If it's the last transport for
    //  the NAME_LIST_ENTRY, delete the NAME_LIST_ENTRY as well.
    //
    for( service = SsData.SsServerNameList; service != NULL; sbackp = service, service = service->Next ) {

        //
        // Walk the list until we find the NAME_LIST_ENTRY having the transportaddress
        //   of interest
        //
        if( service->TransportAddressLength != capturedSvti3->svti3_transportaddresslength ) {
            continue;
        }

        if( !RtlEqualMemory( service->TransportAddress,
                             TransportAddress,
                             capturedSvti3->svti3_transportaddresslength ) ) {
            continue;
        }

        //
        // This is the correct NAME_LIST_ENTRY, now find the TRANSPORT_LIST_ENTRY of interest
        //
        for( transport=service->Transports; transport != NULL; tbackp=transport, transport=transport->Next ) {

            if( STRCMPI( transport->TransportName, Buffer->Transport0.svti0_transportname ) ) {
                continue;
            }

            //
            // This is the one...remove it from the list
            //

            if( tbackp == NULL ) {
                service->Transports = transport->Next;
            } else {
                tbackp->Next = transport->Next;
            }

            MIDL_user_free( transport );

            break;
        }

        //
        // If this NAME_LIST_ENTRY no longer has any transports, delete it
        //
        if( service->Transports == NULL ) {
            if( sbackp == NULL ) {
                SsData.SsServerNameList = service->Next;
            } else {
                sbackp->Next = service->Next;
            }

            //
            // If this was the last NAME_LIST_ENTRY, save the ServiceBits
            //  in case another transport comes back later
            //
            if( SsData.SsServerNameList == NULL && SsData.ServiceBits == 0 ) {
                SsData.ServiceBits = service->ServiceBits;
            }

            MIDL_user_free( service );
        }

        break;
    }

    RtlReleaseResource( &SsData.SsServerInfoResource );
    MIDL_user_free( capturedSvti3 );

    return NO_ERROR;

} // NetrServerTransportDelEx

NET_API_STATUS NET_API_FUNCTION
NetrServerTransportDel (
    IN LPTSTR ServerName,
    IN DWORD Level,
    IN LPSERVER_TRANSPORT_INFO_0 Buffer
)
{
    // To protect us from penetration bugs, all calls that come in over
    // this interface are marshalled and treated as InfoLevel 0.  To truly
    // use Info Level 1, you need to use the new RPC interface, which is done
    // automatically for Whistler+ (NT 5.1)
    return NetrServerTransportDelEx( ServerName, 0, (LPTRANSPORT_INFO)Buffer );
}


NET_API_STATUS NET_API_FUNCTION
NetrServerTransportEnum (
    IN LPTSTR ServerName,
    IN LPSERVER_XPORT_ENUM_STRUCT InfoStruct,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )
{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;

    ServerName;

    if (InfoStruct == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure that the level is valid.
    //

    if ( InfoStruct->Level != 0  && InfoStruct->Level != 1 ) {
        return ERROR_INVALID_LEVEL;
    }

    if (InfoStruct->XportInfo.Level0 == NULL) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Make sure that the caller is allowed to get information from the
    // server.
    //

    if( SsData.SsInitialized ) {
        error = SsCheckAccess(
                    &SsTransportEnumSecurityObject,
                    SRVSVC_CONFIG_USER_INFO_GET
                    );

        if ( error != NO_ERROR ) {
            return ERROR_ACCESS_DENIED;
        }
    }

    //
    // Set up the input parameters in the request buffer.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    srp->Level = InfoStruct->Level;

    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        srp->Parameters.Get.ResumeHandle = *ResumeHandle;
    } else {
        srp->Parameters.Get.ResumeHandle = 0;
    }

    if (InfoStruct->XportInfo.Level0->Buffer != NULL) {
        // The InfoStruct is defined as a parameter. However the Buffer
        // parameter is only used as out. In these cases we need to free
        // the buffer allocated by RPC if the client had specified a non
        // NULL value for it.
        MIDL_user_free(InfoStruct->XportInfo.Level0->Buffer);
        InfoStruct->XportInfo.Level0->Buffer = NULL;
    }

    //
    // Get the data from the server.  This routine will allocate the
    // return buffer and handle the case where PreferredMaximumLength ==
    // -1.
    //

    error = SsServerFsControlGetInfo(
                FSCTL_SRV_NET_SERVER_XPORT_ENUM,
                srp,
                (PVOID *)&InfoStruct->XportInfo.Level0->Buffer,
                PreferredMaximumLength
                );

    //
    // Set up return information.
    //

    InfoStruct->XportInfo.Level0->EntriesRead = srp->Parameters.Get.EntriesRead;
    *TotalEntries = srp->Parameters.Get.TotalEntries;
    if ( srp->Parameters.Get.EntriesRead > 0 && ARGUMENT_PRESENT( ResumeHandle ) ) {
        *ResumeHandle = srp->Parameters.Get.ResumeHandle;
    }

    SsFreeSrp( srp );

    return error;

} // NetrServerTransportEnum


LPSERVER_TRANSPORT_INFO_3
CaptureSvti3 (
    IN DWORD Level,
    IN LPTRANSPORT_INFO Svti,
    OUT PULONG CapturedSvtiLength
    )
{
    LPSERVER_TRANSPORT_INFO_3 capturedSvti;
    PCHAR variableData;
    ULONG transportNameLength;
    CHAR TransportAddressBuffer[MAX_PATH];
    LPBYTE TransportAddress;
    DWORD TransportAddressLength;
    LPTSTR DomainName;
    DWORD domainLength;

    //
    // If a server transport name is specified, use it, otherwise
    // use the default server name on the transport.
    //
    // Either way, the return transport address is normalized into a netbios address
    //

    if ( Svti->Transport0.svti0_transportaddress == NULL ) {
        TransportAddress = SsData.SsServerTransportAddress;
        TransportAddressLength = SsData.SsServerTransportAddressLength;
        Svti->Transport0.svti0_transportaddresslength = TransportAddressLength;
    } else {


        //
        // Normalize the transport address.
        //

        TransportAddress = TransportAddressBuffer;
        TransportAddressLength = min( Svti->Transport0.svti0_transportaddresslength,
                                      sizeof( TransportAddressBuffer ));

        RtlCopyMemory( TransportAddress,
                       Svti->Transport0.svti0_transportaddress,
                       TransportAddressLength );

        if ( TransportAddressLength < NETBIOS_NAME_LEN ) {

            RtlCopyMemory( TransportAddress + TransportAddressLength,
                           "               ",
                           NETBIOS_NAME_LEN - TransportAddressLength );

            TransportAddressLength = NETBIOS_NAME_LEN;

        } else {

            TransportAddressLength = NETBIOS_NAME_LEN;

        }

    }

    transportNameLength = SIZE_WSTR( Svti->Transport0.svti0_transportname );

    if( Level == 0 || Svti->Transport1.svti1_domain == NULL ) {
        DomainName = SsData.DomainNameBuffer;
    } else {
        DomainName = Svti->Transport1.svti1_domain;
    }

    domainLength = SIZE_WSTR( DomainName );

    //
    // Allocate enough space to hold the captured buffer, including the
    // full transport name/address and domain name
    //

    *CapturedSvtiLength = sizeof(*capturedSvti) +
                            transportNameLength + TransportAddressLength + domainLength;

    capturedSvti = MIDL_user_allocate( *CapturedSvtiLength );

    if ( capturedSvti == NULL ) {
        return NULL;
    }

    RtlZeroMemory( capturedSvti, *CapturedSvtiLength );

    //
    // Copy in the domain name
    //
    variableData = (PCHAR)( capturedSvti + 1 );
    capturedSvti->svti3_domain = (PWCH)variableData;
    RtlCopyMemory( variableData,
                   DomainName,
                   domainLength
                 );
    variableData += domainLength;
    POINTER_TO_OFFSET( capturedSvti->svti3_domain, capturedSvti );

    //
    // Copy the transport name
    //
    capturedSvti->svti3_transportname = (PWCH)variableData;
    RtlCopyMemory(
        variableData,
        Svti->Transport3.svti3_transportname,
        transportNameLength
        );
    variableData += transportNameLength;
    POINTER_TO_OFFSET( capturedSvti->svti3_transportname, capturedSvti );

    //
    // Copy the transport address
    //
    capturedSvti->svti3_transportaddress = variableData;
    capturedSvti->svti3_transportaddresslength = TransportAddressLength;
    RtlCopyMemory(
        variableData,
        TransportAddress,
        TransportAddressLength
        );
    variableData += TransportAddressLength;
    POINTER_TO_OFFSET( capturedSvti->svti3_transportaddress, capturedSvti );

    if( Level >= 3 ) {
        capturedSvti->svti3_passwordlength = Svti->Transport3.svti3_passwordlength;
        RtlCopyMemory( capturedSvti->svti3_password,
                       Svti->Transport3.svti3_password,
                       sizeof( capturedSvti->svti3_password )
                     );
    }

    return capturedSvti;

} // CaptureSvti3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\xsdata.c ===
/*+

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    xsdata.c

Abstract:

    Global data declarations for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

    Chuck Lenzmeier (chuckl) 17-Jun-1992
        Moved from xssvc to srvsvc\server

--*/

//
// Includes.
//

#include "srvsvcp.h"
#include "xsdata.h"

#include <remdef.h>         // from net\inc

#include <xsconst.h>        // from xactsrv

#undef DEBUG
#undef DEBUG_API_ERRORS
#include <xsdebug.h>

#if DBG
DWORD XsDebug = 0;
#endif

VOID
(*XsSetParameters)(
    IN LPTRANSACTION Transaction,
    IN LPXS_PARAMETER_HEADER Header,
    IN LPVOID Parameters
    ) = NULL;

LPVOID
(*XsCaptureParameters) (
    IN LPTRANSACTION Transaction,
    OUT LPDESC *AuxDescriptor
    ) = NULL;

BOOL
(*XsCheckSmbDescriptor)(
    IN LPDESC SmbDescriptor,
    IN LPDESC ActualDescriptor
    ) = NULL;

//
// Table of information necessary for dispatching API requests.
//
// ImpersonateClient specifies whether XACTSRV should impersonate the caller
//     before invoking the API handler.
//
// Handler specifies the function XACTSRV should call to handle the API.
//

XS_API_TABLE_ENTRY XsApiTable[XS_SIZE_OF_API_TABLE] = {
    TRUE,  "XsNetShareEnum",                NULL, REMSmb_NetShareEnum_P,       // 0
    TRUE,  "XsNetShareGetInfo",             NULL, REMSmb_NetShareGetInfo_P,
    TRUE,  "XsNetShareSetInfo",             NULL, REMSmb_NetShareSetInfo_P,
    TRUE,  "XsNetShareAdd",                 NULL, REMSmb_NetShareAdd_P,
    TRUE,  "XsNetShareDel",                 NULL, REMSmb_NetShareDel_P,
    TRUE,  "XsNetShareCheck",               NULL, REMSmb_NetShareCheck_P,
    TRUE,  "XsNetSessionEnum",              NULL, REMSmb_NetSessionEnum_P,
    TRUE,  "XsNetSessionGetInfo",           NULL, REMSmb_NetSessionGetInfo_P,
    TRUE,  "XsNetSessionDel",               NULL, REMSmb_NetSessionDel_P,
    TRUE,  "XsNetConnectionEnum",           NULL, REMSmb_NetConnectionEnum_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 10
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetServerGetInfo",            NULL, REMSmb_NetServerGetInfo_P,
    TRUE,  "XsNetServerSetInfo",            NULL, REMSmb_NetServerSetInfo_P,
    TRUE,  "XsNetServerDiskEnum",           NULL, REMSmb_NetServerDiskEnum_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 20
    TRUE,  "XsNetCharDevEnum",              NULL, REMSmb_NetCharDevEnum_P,
    TRUE,  "XsNetCharDevGetInfo",           NULL, REMSmb_NetCharDevGetInfo_P,
    TRUE,  "XsNetCharDevControl",           NULL, REMSmb_NetCharDevControl_P,
    TRUE,  "XsNetCharDevQEnum",             NULL, REMSmb_NetCharDevQEnum_P,
    TRUE,  "XsNetCharDevQGetInfo",          NULL, REMSmb_NetCharDevQGetInfo_P,
    TRUE,  "XsNetCharDevQSetInfo",          NULL, REMSmb_NetCharDevQSetInfo_P,
    TRUE,  "XsNetCharDevQPurge",            NULL, REMSmb_NetCharDevQPurge_P,
    TRUE,  "XsNetCharDevQPurgeSelf",        NULL, REMSmb_NetCharDevQPurgeSelf_P,
    TRUE,  "XsNetMessageNameEnum",          NULL, REMSmb_NetMessageNameEnum_P,
    TRUE,  "XsNetMessageNameGetInfo",       NULL, REMSmb_NetMessageNameGetInfo_P, // 30
    TRUE,  "XsNetMessageNameAdd",           NULL, REMSmb_NetMessageNameAdd_P,
    TRUE,  "XsNetMessageNameDel",           NULL, REMSmb_NetMessageNameDel_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetMessageBufferSend",        NULL, REMSmb_NetMessageBufferSend_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetServiceEnum",              NULL, REMSmb_NetServiceEnum_P,
    TRUE,  "XsNetServiceInstall",           NULL, REMSmb_NetServiceInstall_P,  // 40
    TRUE,  "XsNetServiceControl",           NULL, REMSmb_NetServiceControl_P,
    TRUE,  "XsNetAccessEnum",               NULL, REMSmb_NetAccessEnum_P,
    TRUE,  "XsNetAccessGetInfo",            NULL, REMSmb_NetAccessGetInfo_P,
    TRUE,  "XsNetAccessSetInfo",            NULL, REMSmb_NetAccessSetInfo_P,
    TRUE,  "XsNetAccessAdd",                NULL, REMSmb_NetAccessAdd_P,
    TRUE,  "XsNetAccessDel",                NULL, REMSmb_NetAccessDel_P,
    TRUE,  "XsNetGroupEnum",                NULL, REMSmb_NetGroupEnum_P,
    TRUE,  "XsNetGroupAdd",                 NULL, REMSmb_NetGroupAdd_P,
    TRUE,  "XsNetGroupDel",                 NULL, REMSmb_NetGroupDel_P,
    TRUE,  "XsNetGroupAddUser",             NULL, REMSmb_NetGroupAddUser_P,   // 50
    TRUE,  "XsNetGroupDelUser",             NULL, REMSmb_NetGroupDelUser_P,
    TRUE,  "XsNetGroupGetUsers",            NULL, REMSmb_NetGroupGetUsers_P,
    TRUE,  "XsNetUserEnum",                 NULL, REMSmb_NetUserEnum_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUserDel",                  NULL, REMSmb_NetUserDel_P,
    TRUE,  "XsNetUserGetInfo",              NULL, REMSmb_NetUserGetInfo_P,
    TRUE,  "XsNetUserSetInfo",              NULL, REMSmb_NetUserSetInfo_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUserGetGroups",            NULL, REMSmb_NetUserGetGroups_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 60
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetWkstaGetInfo",             NULL, REMSmb_NetWkstaGetInfo_P,
    TRUE,  "XsNetWkstaSetInfo",             NULL, REMSmb_NetWkstaSetInfo_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
   FALSE,  "XsNetPrintQEnum",               NULL, REMSmb_DosPrintQEnum_P,
   FALSE,  "XsNetPrintQGetInfo",            NULL, REMSmb_DosPrintQGetInfo_P,  // 70
    TRUE,  "XsNetPrintQSetInfo",            NULL, REMSmb_DosPrintQSetInfo_P,
    TRUE,  "XsNetPrintQAdd",                NULL, REMSmb_DosPrintQAdd_P,
    TRUE,  "XsNetPrintQDel",                NULL, REMSmb_DosPrintQDel_P,
    TRUE,  "XsNetPrintQPause",              NULL, REMSmb_DosPrintQPause_P,
    TRUE,  "XsNetPrintQContinue",           NULL, REMSmb_DosPrintQContinue_P,
   FALSE,  "XsNetPrintJobEnum",             NULL, REMSmb_DosPrintJobEnum_P,
   FALSE,  "XsNetPrintJobGetInfo",          NULL, REMSmb_DosPrintJobGetInfo_P,
    TRUE,  "XsNetPrintJobSetInfo",          NULL, REMSmb_DosPrintJobSetInfo_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 80
    TRUE,  "XsNetPrintJobDel",              NULL, REMSmb_DosPrintJobDel_P,
    TRUE,  "XsNetPrintJobPause",            NULL, REMSmb_DosPrintJobPause_P,
    TRUE,  "XsNetPrintJobContinue",         NULL, REMSmb_DosPrintJobContinue_P,
    TRUE,  "XsNetPrintDestEnum",            NULL, REMSmb_DosPrintDestEnum_P,
    TRUE,  "XsNetPrintDestGetInfo",         NULL, REMSmb_DosPrintDestGetInfo_P,
    TRUE,  "XsNetPrintDestControl",         NULL, REMSmb_DosPrintDestControl_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 90
    TRUE,  "XsNetRemoteTOD",                NULL, REMSmb_NetRemoteTOD_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetServiceGetInfo",           NULL, REMSmb_NetServiceGetInfo_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 100
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetPrintQPurge",              NULL, REMSmb_DosPrintQPurge_P,
    FALSE, "XsNetServerEnum2",              NULL, REMSmb_NetServerEnum2_P,
    TRUE,  "XsNetAccessGetUserPerms",       NULL, REMSmb_NetAccessGetUserPerms_P,
    TRUE,  "XsNetGroupGetInfo",             NULL, REMSmb_NetGroupGetInfo_P,
    TRUE,  "XsNetGroupSetInfo",             NULL, REMSmb_NetGroupSetInfo_P,
    TRUE,  "XsNetGroupSetUsers",            NULL, REMSmb_NetGroupSetUsers_P,
    TRUE,  "XsNetUserSetGroups",            NULL, REMSmb_NetUserSetGroups_P,
    TRUE,  "XsNetUserModalsGet",            NULL, REMSmb_NetUserModalsGet_P,  // 110
    TRUE,  "XsNetUserModalsSet",            NULL, REMSmb_NetUserModalsSet_P,
    TRUE,  "XsNetFileEnum2",                NULL, REMSmb_NetFileEnum2_P,
    TRUE,  "XsNetUserAdd2",                 NULL, REMSmb_NetUserAdd2_P,
    TRUE,  "XsNetUserSetInfo2",             NULL, REMSmb_NetUserSetInfo2_P,
    TRUE,  "XsNetUserPasswordSet2",         NULL, REMSmb_NetUserPasswordSet2_P,
    FALSE, "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetGetDCName",                NULL, REMSmb_NetGetDCName_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 120
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetStatisticsGet2",           NULL, REMSmb_NetStatisticsGet2_P,
    TRUE,  "XsNetBuildGetInfo",             NULL, REMSmb_NetBuildGetInfo_P,
    TRUE,  "XsNetFileGetInfo2",             NULL, REMSmb_NetFileGetInfo2_P,
    TRUE,  "XsNetFileClose2",               NULL, REMSmb_NetFileClose2_P,
    FALSE, "XsNetServerReqChallenge",       NULL, REMSmb_NetServerReqChalleng_P,
    FALSE, "XsNetServerAuthenticate",       NULL, REMSmb_NetServerAuthenticat_P,
    FALSE, "XsNetServerPasswordSet",        NULL, REMSmb_NetServerPasswordSet_P,
    FALSE, "XsNetAccountDeltas",            NULL, REMSmb_NetAccountDeltas_P,
    FALSE, "XsNetAccountSync",              NULL, REMSmb_NetAccountSync_P, // 130
    TRUE,  "XsNetUserEnum2",                NULL, REMSmb_NetUserEnum2_P,
    TRUE,  "XsNetWkstaUserLogon",           NULL, REMSmb_NetWkstaUserLogon_P,
    TRUE,  "XsNetWkstaUserLogoff",          NULL, REMSmb_NetWkstaUserLogoff_P,
    TRUE,  "XsNetLogonEnum",                NULL, REMSmb_NetLogonEnum_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsI_NetPathType",               NULL, REMSmb_I_NetPathType_P,
    TRUE,  "XsI_NetPathCanonicalize",       NULL, REMSmb_I_NetPathCanonicalize_P,
    TRUE,  "XsI_NetPathCompare",            NULL, REMSmb_I_NetPathCompare_P,
    TRUE,  "XsI_NetNameValidate",           NULL, REMSmb_I_NetNameValidate_P,
    TRUE,  "XsI_NetNameCanonicalize",       NULL, REMSmb_I_NetNameCanonicalize_P, //140
    TRUE,  "XsI_NetNameCompare",            NULL, REMSmb_I_NetNameCompare_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetPrintDestAdd",             NULL, REMSmb_DosPrintDestAdd_P,
    TRUE,  "XsNetPrintDestSetInfo",         NULL, REMSmb_DosPrintDestSetInfo_P,
    TRUE,  "XsNetPrintDestDel",             NULL, REMSmb_DosPrintDestDel_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetPrintJobSetInfo",          NULL, REMSmb_DosPrintJobSetInfo_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 150
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 160
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 170
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 180
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 190
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 200
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,  // 210
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsNetUnsupportedApi",           NULL, REMSmb_NetUnsupportedApi_P,
    TRUE,  "XsSamOEMChangePasswordUser2_P", NULL, REM32_SamOEMChgPasswordUser2_P,
    FALSE, "XsNetServerEnum3",              NULL, REMSmb_NetServerEnum3_P
};

// Spooler dynamic-load functions
PSPOOLER_OPEN_PRINTER pSpoolerOpenPrinterFunction = NULL;
PSPOOLER_RESET_PRINTER pSpoolerResetPrinterFunction = NULL;
PSPOOLER_ADD_JOB pSpoolerAddJobFunction = NULL;
PSPOOLER_SCHEDULE_JOB pSpoolerScheduleJobFunction = NULL;
PSPOOLER_CLOSE_PRINTER pSpoolerClosePrinterFunction = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\xsdata.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xsdata.h

Abstract:

    Header file for XACTSRV global data.

Author:

    David Treadwell (davidtr) 05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#ifndef _XSDATA_
#define _XSDATA_

#include <nturtl.h>

#include <winbase.h>

#include <rap.h>
#include <xstypes.h>
#include <ntmsv1_0.h>

//
// Routine used to load and initialize for xactsrv processing
//
extern BOOLEAN XsLoadXactLibrary( WORD FunctionNumber );

extern VOID
XsProcessApisWrapper (
    LPVOID ThreadNum
    );

//
// Table of information necessary for dispatching API requests.
//
// ImpersonateClient specifies whether XACTSRV should impersonate the caller
//     before invoking the API handler.
//
// Handler specifies the function XACTSRV should call to handle the API.  The
//   function is dynamically loaded from xactsrv.dll the first time that the client
//   requests the service.
//

typedef struct _XS_API_TABLE_ENTRY {
    BOOL ImpersonateClient;
    LPSTR HandlerName;
    PXACTSRV_API_HANDLER Handler;
    LPDESC Params;
} XS_API_TABLE_ENTRY, *PXS_API_TABLE_ENTRY;

//
// Table of information necessary for dispatching API requests.
// XsProcessApis uses the API number in the request transaction find
// the appropriate entry.
//

#define XS_SIZE_OF_API_TABLE 216

extern XS_API_TABLE_ENTRY XsApiTable[XS_SIZE_OF_API_TABLE];

//
// These entry points are dynamically loaded from xactsrv.dll the first time a
//  client requests the service
//
typedef
VOID
(*XS_SET_PARAMETERS_FUNCTION) (
    IN LPTRANSACTION Transaction,
    IN LPXS_PARAMETER_HEADER Header,
    IN LPVOID Parameters
    );

extern XS_SET_PARAMETERS_FUNCTION XsSetParameters;

typedef
LPVOID
(*XS_CAPTURE_PARAMETERS_FUNCTION ) (
    IN LPTRANSACTION Transaction,
    OUT LPDESC *AuxDescriptor
    );

extern XS_CAPTURE_PARAMETERS_FUNCTION XsCaptureParameters;

typedef
BOOL
(*XS_CHECK_SMB_DESCRIPTOR_FUNCTION)(
    IN LPDESC SmbDescriptor,
    IN LPDESC ActualDescriptor
    );

extern XS_CHECK_SMB_DESCRIPTOR_FUNCTION XsCheckSmbDescriptor;

//
// The license functions are dynamically loaded, as they are not used on workstations
//
extern BOOLEAN SsLoadLicenseLibrary();

//
// Print Spooler dynamic loading info
//
typedef 
BOOL
(*PSPOOLER_OPEN_PRINTER)(
   IN LPWSTR    pPrinterName,
   OUT LPHANDLE phPrinter,
   IN PVOID pDefault
   );

typedef
BOOL
(*PSPOOLER_RESET_PRINTER)(
   IN HANDLE   hPrinter,
   IN PVOID pDefault
   );

typedef
BOOL
(*PSPOOLER_ADD_JOB)(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    OUT LPBYTE  pData,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
    );

typedef
BOOL
(*PSPOOLER_SCHEDULE_JOB)(
    IN HANDLE  hPrinter,
    IN DWORD   JobId
    );

typedef
BOOL
(*PSPOOLER_CLOSE_PRINTER)(
    IN HANDLE hPrinter
    );

extern PSPOOLER_OPEN_PRINTER pSpoolerOpenPrinterFunction;
extern PSPOOLER_RESET_PRINTER pSpoolerResetPrinterFunction;
extern PSPOOLER_ADD_JOB pSpoolerAddJobFunction;
extern PSPOOLER_SCHEDULE_JOB pSpoolerScheduleJobFunction;
extern PSPOOLER_CLOSE_PRINTER pSpoolerClosePrinterFunction;


#endif // ndef _XSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\xsinit.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    xsinit.c

Abstract:

    This module contains the initialization and termination code for
    the XACTSRV component of the server service.

Author:

    David Treadwell (davidtr)    05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

    Chuck Lenzmeier (chuckl) 17-Jun-1992
        Merged xactsrv.c into xsinit.c and moved from xssvc to
        srvsvc\server

--*/

//
// Includes.
//

#include "srvsvcp.h"
#include "xsdata.h"
                     
#include <windows.h>        // from sdk\inc
#include <xactsrv2.h>       // from private\inc
#include <srvfsctl.h>

#include <xsconst.h>        // from xactsrv

#undef DEBUG
#undef DEBUG_API_ERRORS
#include <xsdebug.h>

extern CRITICAL_SECTION SpoolerMutex;

BOOLEAN
XsUnloadPrintSpoolerFunctions(
    );


DWORD
XsStartXactsrv (
    VOID
    )
{
    NTSTATUS status;
    DWORD error;
    DWORD i;
    HANDLE threadHandle;
    DWORD threadId;
    HANDLE eventHandle;
    HANDLE serverHandle;
    ANSI_STRING ansiName;
    UNICODE_STRING unicodeName;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    PORT_MESSAGE connectionRequest;
    REMOTE_PORT_VIEW clientView;
    BOOL waitForEvent;

    //
    // Set up variables so that we'll know how to shut down in case of
    // an error.
    //

    serverHandle = NULL;
    eventHandle = NULL;
    waitForEvent = FALSE;

    try {
        RtlInitializeResource( &SsData.LibraryResource );
        InitializeCriticalSection( &SpoolerMutex );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return RtlNtStatusToDosError( GetExceptionCode() );
    }
    SsData.LibraryResourceInitialized = TRUE;

    //
    // Create a event that will be set by the last thread to exit.
    //

    IF_DEBUG(INIT) {
        SS_PRINT(( "XsStartXactsrv: Creating termination event.\n" ));
    }
    SS_ASSERT( SsData.XsAllThreadsTerminatedEvent == NULL );

    status = NtCreateEvent(
                 &SsData.XsAllThreadsTerminatedEvent,
                 EVENT_ALL_ACCESS,
                 NULL,
                 NotificationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SS_PRINT(( "XsStartXactsrv: NtCreateEvent failed: %X\n",
                          status ));
        }

        SsData.XsAllThreadsTerminatedEvent = NULL;
        goto exit;
    }

    //
    // Open the server device.  Note that we need this handle because
    // the handle used by the main server service is synchronous.  We
    // need to to do the XACTSRV_CONNECT FSCTL asynchronously.
    //

    RtlInitUnicodeString( &unicodeName, XS_SERVER_DEVICE_NAME_W );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile(
                 &serverHandle,
                 FILE_READ_DATA,            // DesiredAccess
                 &objectAttributes,
                 &ioStatusBlock,
                 0L,                        // ShareAccess
                 0L                         // OpenOptions
                 );

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SS_PRINT(( "XsStartXactsrv: NtOpenFile (server device object) "
                          "failed: %X\n", status ));
        }
        goto exit;
    }

    //
    // Create the LPC port.
    //
    // !!! Right now this only tries a single port name.  If, for some
    //     bizarre reason, somebody already has a port by this name,
    //     then this will fail.  It might make sense to try different
    //     names if this fails.
    //
    // !!! We might want to make the port name somewhat random for
    //     slightly enhanced security.

    RtlInitUnicodeString( &unicodeName, XS_PORT_NAME_W );
    RtlInitAnsiString(    &ansiName,    XS_PORT_NAME_A );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeName,
        0,
        NULL,
        NULL
        );

    IF_DEBUG(LPC) {
        SS_PRINT(( "XsInitialize: creating port %Z\n", &ansiName ));
    }

    SS_ASSERT( SsData.XsConnectionPortHandle == NULL );

    status = NtCreatePort(
                 &SsData.XsConnectionPortHandle,
                 &objectAttributes,
                 0,
                 XS_PORT_MAX_MESSAGE_LENGTH,
                 XS_PORT_MAX_MESSAGE_LENGTH * 32
                 );

    if ( ! NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            if ( status == STATUS_OBJECT_NAME_COLLISION ) {
                SS_PRINT(( "XsStartXactsrv: The XACTSRV port already "
                            "exists\n"));

            } else {
                SS_PRINT(( "XsStartXactsrv: Failed to create port %Z: %X\n",
                              &ansiName, status ));
            }
        }

        SsData.XsConnectionPortHandle = NULL;
        goto exit;
    }

    //
    // Set up an event so that we'll know when IO completes, then send
    // the FSCTL to the server indicating that it should now connect to
    // us.  We'll set up the port while the IO is outstanding, then wait
    // on the event when the port setup is complete.
    //

    status = NtCreateEvent(
                 &eventHandle,
                 EVENT_ALL_ACCESS,
                 NULL,                           // ObjectAttributes
                 NotificationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SS_PRINT(( "XsStartXactsrv: NtCreateEvent failed: %X\n",
                        status ));
        }
        goto exit;
    }

    IF_DEBUG(LPC) {
        SS_PRINT(( "XsStartXactsrv: sending FSCTL_SRV_XACTSRV_CONNECT.\n" ));
    }

    status = NtFsControlFile(
                 serverHandle,
                 eventHandle,
                 NULL,                           // ApcRoutine
                 NULL,                           // ApcContext
                 &ioStatusBlock,
                 FSCTL_SRV_XACTSRV_CONNECT,
                 ansiName.Buffer,
                 ansiName.Length,
                 NULL,                           // OutputBuffer
                 0L                              // OutputBufferLength
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SS_PRINT(( "XsStartXactsrv: NtFsControlFile failed: %X\n",
                          status ));
        }
        goto exit;
    }

    waitForEvent = TRUE;

    //
    // Start listening for the server's connection to the port.  Note
    // that it is OK if the server happens to call NtConnectPort
    // first--it will simply block until this call to NtListenPort
    // occurs.
    //

    IF_DEBUG(LPC) {
        SS_PRINT(( "XsStartXactsrv: listening to port.\n" ));
    }

    connectionRequest.u1.s1.TotalLength = sizeof(connectionRequest);
    connectionRequest.u1.s1.DataLength = (CSHORT)0;
    status = NtListenPort(
                 SsData.XsConnectionPortHandle,
                 &connectionRequest
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SS_PRINT(( "XsStartXactsrv: NtListenPort failed: %X\n", status ));
        }
        goto exit;
    }

    //
    // The server has initiated the connection.  Accept the connection.
    //
    // !!! We probably need some security check here.
    //

    clientView.Length = sizeof(clientView);
    clientView.ViewSize = 0;
    clientView.ViewBase = 0;

    IF_DEBUG(LPC) {
        SS_PRINT(( "XsStartXactsrv: Accepting connection to port.\n" ));
    }

    SS_ASSERT( SsData.XsCommunicationPortHandle == NULL );

    status = NtAcceptConnectPort(
                 &SsData.XsCommunicationPortHandle,
                 NULL,                           // PortContext
                 &connectionRequest,
                 TRUE,                           // AcceptConnection
                 NULL,                           // ServerView
                 &clientView
                 );

    if ( !NT_SUCCESS(status) ) {
       IF_DEBUG(ERRORS) {
           SS_PRINT(( "XsStartXactsrv: NtAcceptConnectPort failed: %X\n",
                         status ));
       }

       SsData.XsCommunicationPortHandle = NULL;
       goto exit;
    }

    IF_DEBUG(LPC) {
        SS_PRINT(( "XsStartXactsrv: client view size: %ld, base: %lx\n",
                      clientView.ViewSize, clientView.ViewBase ));
    }

    //
    // Complete the connection to the port, thereby releasing the server
    // thread waiting in NtConnectPort.
    //

    IF_DEBUG(LPC) {
        SS_PRINT(( "XsStartXactsrv: Completing connection to port.\n" ));
    }

    status = NtCompleteConnectPort( SsData.XsCommunicationPortHandle );

    if ( !NT_SUCCESS(status) ) {
       IF_DEBUG(ERRORS) {
           SS_PRINT(( "XsStartXactsrv: NtCompleteConnectPort failed: %X\n",
                         status ));
       }
       goto exit;
    }


    status = STATUS_SUCCESS;

exit:

    //
    // Wait for the IO to complete, then close the event handle.
    //

    if ( waitForEvent ) {

        NTSTATUS waitStatus;

        SS_ASSERT( eventHandle != NULL );

        waitStatus = NtWaitForSingleObject( eventHandle, FALSE, NULL );

        if ( !NT_SUCCESS(waitStatus) ) {

            IF_DEBUG(ERRORS) {
                SS_PRINT(( "XsStartXactsrv: NtWaitForSingleObject failed: "
                              "%X\n", waitStatus ));
            }

            //
            // If another error has already occurred, don't report this
            // one.
            //

            if ( NT_SUCCESS(status) ) {
                status = waitStatus;
            }
        }

        //
        // Check the status in the IO status block.  If it is bad, then
        // there was some problem on the server side of the port setup.
        //

        if ( !NT_SUCCESS(ioStatusBlock.Status) ) {
            IF_DEBUG(ERRORS) {
                SS_PRINT(( "XsStartXactsrv: bad status in IO status block: "
                              "%X\n", ioStatusBlock.Status ));
            }

            //
            // If another error has already occurred, don't report this
            // one.
            //

            if ( NT_SUCCESS(status) ) {
                status = ioStatusBlock.Status;
            }

        }

        CloseHandle( eventHandle );

    }

    //
    // Close the handle to the server.
    //

    if ( serverHandle != NULL ) {
       CloseHandle( serverHandle );
    }

    //
    // If the above failed, return to caller now.
    //

    if ( !NT_SUCCESS(status) ) {
        return RtlNtStatusToDosError( status );
    }

    //
    // Start one API processing thread.  It will spawn others if needed
    //
    threadHandle = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)XsProcessApisWrapper,
                        0,
                        0,
                        &threadId
                        );

    if ( threadHandle != 0 ) {

        IF_DEBUG(THREADS) {
            SS_PRINT(( "XsStartXactsrv: Created thread %ld for "
                          "processing APIs\n", SsData.XsThreads ));
        }

        CloseHandle( threadHandle );
        SsData.ApiThreadsStarted = TRUE;

    } else {

        //
        // Thread creation failed.  Return an error to the caller.
        // It is the responsibility of the caller to call
        // XsStopXactsrv to clean up.
        //

        error = GetLastError( );
        return error;

    }


    //
    // Initialization succeeded.
    //

    return NO_ERROR;

} // XsStartXactsrv


/*
 * This routine is called to stop the transaction processor once the
 * server driver has terminated.
 */
VOID
XsStopXactsrv (
    VOID
    )
{
    NTSTATUS status;
    static XACTSRV_REQUEST_MESSAGE requestMessage;
    LONG i;
    BOOL ok;

    //
    // Stop all the xs worker threads, and release resources
    //

    if ( SsData.XsConnectionPortHandle != NULL ) {

        //
        // Indicate that XACTSRV is terminating.
        //
        SsData.XsTerminating = TRUE;

        IF_DEBUG(TERMINATION) {
           SS_PRINT(("XsStopXactsrv:  queueing termination messages\n"));
        }

        if( SsData.ApiThreadsStarted == TRUE ) {

            //
            // Queue a message to kill off the worker thereads
            //
            RtlZeroMemory( &requestMessage, sizeof( requestMessage ));
            requestMessage.PortMessage.u1.s1.DataLength =
                (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
            requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
            requestMessage.MessageType = XACTSRV_MESSAGE_WAKEUP;
            
            status = NtRequestPort(
                        SsData.XsConnectionPortHandle,
                        (PPORT_MESSAGE)&requestMessage
                        );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    SS_PRINT(( "SrvXsDisconnect: NtRequestPort failed: %X\n",
                                status ));
                }
            }

            //
            // The above will cause all worker threads to wake up then die.
            //

            ok = WaitForSingleObject( SsData.XsAllThreadsTerminatedEvent, (DWORD)-1 );

            IF_DEBUG(ERRORS) {
                if ( !ok ) {
                    SS_PRINT(( "XsStopXactsrv: WaitForSingleObject failed: "
                                "%ld\n", GetLastError() ));
                }
            }

            SsData.ApiThreadsStarted = FALSE;
        }

        CloseHandle( SsData.XsConnectionPortHandle );
    }

    if( SsData.XsCommunicationPortHandle != NULL ) {
        CloseHandle( SsData.XsCommunicationPortHandle );
        SsData.XsCommunicationPortHandle = NULL;
    }

    //
    // Unload the xactsrv libaray
    //
    if( SsData.XsXactsrvLibrary != NULL ) {
        PXS_API_TABLE_ENTRY entry = XsApiTable;

        //
        // Null out all of the entry points
        //
        for( entry = XsApiTable;
             entry < &XsApiTable[ XS_SIZE_OF_API_TABLE ];
             entry++ ) {

            entry->Handler = NULL;
        }

        XsSetParameters = NULL;
        XsCaptureParameters = NULL;
        XsCheckSmbDescriptor = NULL;

        FreeLibrary( SsData.XsXactsrvLibrary );
        SsData.XsXactsrvLibrary = NULL;
    }

    //
    // Unload the license library
    //
    if( SsData.XsLicenseLibrary != NULL ) {
        SsData.SsLicenseRequest = NULL;
        SsData.SsFreeLicense = NULL;
        FreeLibrary( SsData.XsLicenseLibrary );
        SsData.XsLicenseLibrary = NULL;
    }

    if( SsData.LibraryResourceInitialized == TRUE ) {
        // Unload the spooler library if necessary
        XsUnloadPrintSpoolerFunctions();
        DeleteCriticalSection( &SpoolerMutex );

        // Delete the library resource
        RtlDeleteResource( &SsData.LibraryResource );
        SsData.LibraryResourceInitialized = FALSE;
    }

    //
    // Close the termination event.
    //

    if ( SsData.XsAllThreadsTerminatedEvent != NULL ) {
        CloseHandle( SsData.XsAllThreadsTerminatedEvent );
        SsData.XsAllThreadsTerminatedEvent = NULL;
    }

    return;

} // XsStopXactsrv

/*
 * This routine is called to dynamically load the transaction library for
 * downlevel clients.  It fills in the entry points for the library
 */
BOOLEAN
XsLoadXactLibrary( WORD FunctionNumber )
{
    PXS_API_TABLE_ENTRY entry = &XsApiTable[ FunctionNumber ];

    if( SsData.XsXactsrvLibrary == NULL ) {

        RtlAcquireResourceExclusive( &SsData.LibraryResource, TRUE );

        if( SsData.XsXactsrvLibrary == NULL ) {
            SsData.XsXactsrvLibrary = LoadLibrary( L"xactsrv.dll" );
        }

        RtlReleaseResource( &SsData.LibraryResource );

        if( SsData.XsXactsrvLibrary == NULL ) {

            DbgPrint( "SRVSVC: Unable to load xactsrv.dll, error %u\n",
                GetLastError() );

            return FALSE;
        }
    }

    if( XsSetParameters == NULL &&
        (XsSetParameters = (XS_SET_PARAMETERS_FUNCTION)GetProcAddress(
                            SsData.XsXactsrvLibrary, "XsSetParameters" )) == NULL ) {

        DbgPrint( "SRVSVC: XsSetParameters entry missing from xactsrv.dll, err %u\n",
                GetLastError() );

        return FALSE;
    }

    if( XsCaptureParameters == NULL &&
        (XsCaptureParameters = (XS_CAPTURE_PARAMETERS_FUNCTION)GetProcAddress(
                                SsData.XsXactsrvLibrary, "XsCaptureParameters" )) == NULL ) {

        DbgPrint( "SRVSVC: XsCaptureParameters entry missing from xactsrv.dll, err %u\n",
                GetLastError() );

        return FALSE;
    }

    if( XsCheckSmbDescriptor == NULL &&
        (XsCheckSmbDescriptor = (XS_CHECK_SMB_DESCRIPTOR_FUNCTION)GetProcAddress(
                                SsData.XsXactsrvLibrary, "XsCheckSmbDescriptor" )) == NULL ) {

        DbgPrint( "SRVSVC: XsCheckSmbDescriptor entry missing from xactsrv.dll, err %u\n",
                GetLastError() );

        return FALSE;
    }

    //
    // Fetch the requested entry point
    //
    entry->Handler =
            (PXACTSRV_API_HANDLER)GetProcAddress( SsData.XsXactsrvLibrary, entry->HandlerName );

    if( entry->Handler == NULL ) {

        DbgPrint( "SRVSVC: %s entry missing from xactsrv.dll, err %u\n",
            entry->HandlerName, GetLastError() );

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SsLoadLicenseLibrary()
{
    if( SsData.XsLicenseLibrary == NULL ) {

        RtlAcquireResourceExclusive( &SsData.LibraryResource, TRUE );

        if( SsData.XsLicenseLibrary == NULL ) {
            SsData.XsLicenseLibrary = LoadLibrary( L"ntlsapi.dll" );
        }

        RtlReleaseResource( &SsData.LibraryResource );

        if( SsData.XsLicenseLibrary == NULL ) {
            return FALSE;
        }
    }

    SsData.SsLicenseRequest = (PNT_LICENSE_REQUEST_W)GetProcAddress( SsData.XsLicenseLibrary, "NtLicenseRequestW" );
    SsData.SsFreeLicense = (PNT_LS_FREE_HANDLE)GetProcAddress( SsData.XsLicenseLibrary, "NtLSFreeHandle" );

    return( SsData.SsLicenseRequest != NULL && SsData.SsFreeLicense != NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apc.h ===
/*
 *
 * REVISIONS:
 *  pcy24Nov92: Added !C_WINDOWS to #ifndef HFILE stuff
 *  RCT25Nov92    Added some stuff
 *  pcy02Dec92: No need for BOOL if C_WINDOWS
 *  pcy07Dec92: Changed BOOL to INT rather than enum so OS2 doesn't choke
 *  ane11Dec92: Changed defn of PFILE and HFILE on OS2
 *  rct11Dec92: Added FLOAT
 *  pcy14Dec92: Semicolon needed in typedef of BOOL
 *  pcy14Dec92: PFILE needed on C_WINDOWS in all cases
 *  pcy14Dec92: Extra #endif needed in PFILE syntax
 *  jod15Dec92: Removed the #if (C_OS & C_OS2) for HFILE and PFILE
 *  pcy17Dec92: Removed VALID, INVALID
 *  rct27Jan93: Added UCHAR, PUCHAR
 *  pcy02Feb93: Added UINT
 *  rct21Apr93: defined VOID as void for NLMs
 *  pcy28Apr93: #ifdef _cplusplus added around extern "C"
 *  pcy16May93: Added typedef for WORD
 *  cad27May93: typedef USHORT even for OS2
 *  cad18Sep93: Added memory debugging stuff
 *  cad07Oct93: added SmartHeap malloc
 *  cad18Nov93: not setting up smartheap strdup if it isn't there
 *  cad08Dec93: added extended set/get types
 *  cad27Dec93: include file madness
 *  ram21Mar94: added some windows specific stuff
 *  cad07Apr94: added DEBUG_PRT macro
 *  mwh12Apr94: port for SCO
 *  mwh01Jun94: port for INTERACTIVE
 *  ajr07Jul94: Lets undef UINT on Unix platforms first
 *  ajr30Jan95: Send DEBUG_PRT stuff to stderr
 *  daf17May95: port for ALPHA/OSF
 *  jps13Jul94: added VOID and DWORD for os2 1.x
 *  ajr07Nov95: cannot have c++ comments on preprosser lines for sinix
 *  cgm08Dec95: added SLONG, change LONG for NLM and Watcom 10.5
 *  djs22Feb96: added CHANGESET
 *  tjd24Feb97: added RESOURCE_STR_SIZE to define maximum resource string length
 *  tjd28Feb97: added the resource dll instance handle
 */

#ifndef __APC_H
#define __APC_H

#ifdef USE_SMARTHEAP
#ifdef __cplusplus
extern "C" {
#include <stdlib.h>
}
#include <smrtheap.hpp>
#else
#include <smrtheap.h>
#endif
// prevent malloc.h from being included
#define __malloc_h  
#define _INC_MALLOC
#include <shmalloc.h>  

#ifdef MEM_strdup
// override default strdup
#undef strdup
#include <string.h>
#define strdup(p) MEM_strdup(p)
#endif
#endif  /* USE_SMARTHEAP */

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#if (C_OS & C_UNIX)
#undef UINT
#endif

#ifndef PVOID
typedef void * PVOID;
#endif

#ifndef VOID
#if (C_OS & C_NLM | C_ALPHAOSF) || ((C_OS & C_OS2) && (C_VERSION & C_OS2_13))
#define VOID void
#else
typedef void VOID;
#endif
#endif

#ifndef INT

#if (C_OS & C_DOS)
typedef int INT;
#else
typedef int INT;
#endif

#endif

#ifndef UINT
#   if C_OS & (C_WIN311 | C_WINDOWS) 
#       ifndef _INC_WINDOWS
typedef unsigned int UINT;
#       endif
#   else
typedef unsigned int UINT ;
#   endif
#endif

#ifndef CHAR
#if (C_OS & C_IRIX)
// pcy - compiler bug on IRIX.  SGI is looking into this one.
#define CHAR char
#else
typedef char CHAR;
#endif
#endif

#if C_OS & (C_WIN311 | C_WINDOWS)
#ifndef _INC_WINDOWS
typedef INT BOOL;         
#endif
#else
#if (!(C_OS & C_OS2))     /* not on OS2 */
#ifndef __WINDOWS_H       /* not if windows.h has already been included */
#ifndef BOOL
typedef INT BOOL;
#endif
#endif
#endif
#endif

typedef unsigned char UCHAR;
typedef unsigned char * PUCHAR;

#ifndef PCHAR
typedef char * PCHAR;
#endif

#if (C_OS & C_DOS)
#ifndef DWORD
typedef unsigned long DWORD;
#endif
#endif

#if (C_OS & C_OS2)
#ifndef DWORD
typedef unsigned long DWORD;
#endif
#endif

#ifndef WORD
typedef unsigned short WORD;
#endif

#if (!(C_OS & C_OS2))
#if (C_OS & (C_WIN311 | C_WINDOWS))
#ifndef PFILE
#define PFILE FILE*
#endif
#ifndef __WINDOWS_H       /* not if windows.h has already been included */
#ifndef HFILE
#define HFILE FILE*
#endif
#endif
#endif
#endif

#if ( !( C_OS & (C_WIN311 | C_WINDOWS ) ))
#define PFILE FILE*
#endif

#if ( C_OS & (C_WIN311 | C_WINDOWS ))       /* Need this for Novell FE */
#define DWORD unsigned long 
#define BYTE unsigned char
#endif

#if (!(C_OS & C_OS2))
#ifndef BYTE
typedef unsigned char  BYTE;
#endif
#endif

#ifndef UNSIGNED
typedef unsigned UNSIGNED;
#endif

/* #if (!(C_OS & C_OS2)) */
#ifndef USHORT
typedef unsigned short USHORT;
#endif
/* #endif */

#ifndef ULONG
typedef unsigned long ULONG;
#endif

#ifndef SLONG
typedef signed long SLONG;
#endif

#ifndef LONG
#if C_OS & C_NLM
#define LONG unsigned long
#else
typedef long LONG;
#endif
#endif

#if (C_OS & C_UNIX)
#undef USHORT
#define USHORT int

#if (C_OS & (C_SCO | C_INTERACTIVE))
typedef unsigned int ssize_t; /* SCO uses size_t, so type it ourselves */
#endif 

#endif


enum Type {GET, SET, GETRESPONSE, ALERT, DATASET, DECREMENTSET, PAUSESET,
        SIMPLE_SET, EXTENDED_GET, EXTENDED_SET, INCREMENTSET, 
        CHANGESET};

/* typedef Type MessageType;

typedef int AttributeCode;
typedef int EventCode;
typedef int EventID;
typedef int State;
typedef int Signal;

*/

#ifndef SEMAPHORE
#if (C_OS & C_OS2)
typedef ULONG SEMAPHORE;
#elif (!(C_OS & (C_WIN311 | C_WINDOWS | C_DOS)))
typedef LONG SEMAPHORE;
#endif
#endif

#if (!(C_OS & C_OS2))
#ifndef TID
typedef unsigned int TID;
#endif
#endif

#define OK       1


typedef INT    COUNTTYPE;
typedef INT    HASHTYPE;
typedef HASHTYPE * PHASHTYPE;
typedef float FLOAT;

#ifdef APCDEBUG

#if (C_OS & C_WIN311)

#define DEBUG_PRT(a)        wpf_debug_prt(a)       /* defined in winprtf.cxx */
#define DEBUG_PRT1(a)       DEBUG_PRT(a)           /* defined in winprtf.cxx */
#define DEBUG_PRT2(a, b)    wpf_debug_prt2(a,b)    /* defined in winprtf.cxx */
#define DEBUG_PRT3(a, b, c) wpf_debug_prt3(a,b,c)  /* defined in winprtf.cxx */
#define DEBUG_PRT_S_D(a,b)  wpf_debug_prt_s_d(a,b) /* defined in winprtf.cxx */

#else
#define DEBUG_PRT(_a) \
{if(theDebugFlag) { \
    fprintf (stderr,_a); \
    fflush(stdout); \
}\
}


#define DEBUG_PRT1(a)  \
{if(theDebugFlag)  { \
    fprintf(stderr,a); \
    printf("\n");\
}\
}


#define DEBUG_PRT2(a, b)  \
{if(theDebugFlag)  { \
    fprintf(stderr,a); \
    fprintf(stderr,": ");\
    fprintf(stderr,b);\
    fprintf(stderr,"\n");\
}\
}

#define DEBUG_PRT3(a, b, c)  \
{if(theDebugFlag)  { \
    fprintf(stderr,a); \
    fprintf(stderr,": ");\
    fprintf(stderr,b);\
    fprintf(stderr,c);\
    fprintf(stderr,"\n");\
}\
}
#endif

#define DEBUG_COUT(a)        if(theDebugFlag)  { \
                               (cout << a);\
                            }
#else
#define DEBUG_PRT(a)
#define DEBUG_PRT1(a)
#define DEBUG_PRT2(a, b)
#define DEBUG_PRT3(a, b, c)
#define DEBUG_PRT_S_D(a,b)
#define DEBUG_COUT(a)
#endif

// @@@
#define INTERNATIONAL 

#define RESOURCE_STR_SIZE  256
#if (C_OS & C_NT)
  #include <windows.h>
#endif
// @@@

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apcdrvr.cxx ===
/* Copyright 1999 American Power Conversion, All Rights Reserverd
* 
* Description:
*   The ApcMiniDriver class provides an interface that is
*   compatible with the MiniDriver interface for the Windows2000
*   UPS service.  
*   The ApcMiniDriver makes use of a modified 
*   PowerChute plus UPS service.  This modified service has had
*   all of the networking, data logging, and flex manager code
*   removed.  All that is left is the modeling and monitoring of
*   the connected UPS system.  It is assumed that a "smart" 
*   signalling UPS is connected.
*   The ApcMiniDriver class is also responsible for filling in
*   the advanced registry settings, battery replacement condition,
*   serial #, firmware rev, etc...
*
* Revision History:
*   mholly  14Apr1999  Created
*   mholly  16Apr1999  Convert data from UPS into wide characters
*                       if UNICODE is defined
*   mholly  19Apr1999  remove registry updates of utility line state
*   mholly  20Apr1999  no longer updating model/vendor in registry
*   mholly  26Apr1999  convert RUN_TIME_REMAINING to minutes before
*                       updating the registry - also only update the
*                       runtime in the onRuntimeTimer method
*   mholly  12May1999  no longer taking aCommPort parameter in UPSInit
*
*/

#include "cdefine.h"

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include "apcdrvr.h"
#include "apcups.h"
#include "ntsrvap.h"
#include "event.h"
#include "timerman.h"
#include "codes.h"
#include "tokenstr.h"

extern "C"{
#include "upsreg.h"
}

// Separator used for the shutdown delay allowed values
#define SHUTDOWN_DELAY_SEPARATOR				","
#define LOW_BATT_DURATION_SEPARATOR     ","
#define SECONDS_TO_MINUTES              60

/**
* ApcMiniDriver
*
* Description:
*   Constructor - initializes all data members
*
* Parameters:   
*   None
*
* Returns:
*   N/A
*
*/
ApcMiniDriver::ApcMiniDriver()
: theState(UPS_ONLINE),
  theStateChangedEvent(NULL),
  theReplaceBatteryState(UPS_BATTERYSTATUS_UNKNOWN),
  theUpsApp(NULL),
  theRunTimeTimer(0),
  theOnBatteryRuntime(-1),
  theBatteryCapacity(-1)
{
}


/**
* ~ApcMiniDriver
*
* Description:
*   Destructor - does nothing, must call
*   UPSStop prior to destructor
*
* Parameters:   
*   None
*
* Returns:
*   N/A
*
*/
ApcMiniDriver::~ApcMiniDriver()
{
}


/**
* UPSInit
*
* Description:
*   Must be the first method called on the object
*   Failing to call UPSInit will result in an object
*   in an unstable state
*
* Parameters:   
*   aCommPort: not used
*
* Returns:
*   UPS_INITOK: initalized successfully
*   UPS_INITUNKNOWNERROR: initialization failed
*
*/
DWORD ApcMiniDriver::UPSInit()
{
    DWORD init_err = UPS_INITOK;
	
    theStateChangedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	
    if (!theStateChangedEvent) {
        init_err = UPS_INITUNKNOWNERROR;
	}
	
    if ((UPS_INITOK == init_err) && 
        (ErrNO_ERROR != initalizeUpsApplication())) {
        init_err = UPS_INITUNKNOWNERROR;
    }

    if (UPS_INITOK != init_err) {
        UPSStop();
    }

    return init_err;
}


/**
* UPSStop
*
* Description:
*   must be called to cleanup the object, after
*   this call completes the only valid method
*   call is UPSInit() or the destructor
*
* Parameters:   
*   None
*
* Returns:
*   None
*
*/
void ApcMiniDriver::UPSStop()
{
    UPSCancelWait();	
    cleanupUpsApplication();
	
    if (theStateChangedEvent) {
        CloseHandle(theStateChangedEvent);
        theStateChangedEvent = NULL;
    }
}


/**
* UPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*
*/
void ApcMiniDriver::UPSWaitForStateChange(DWORD aLastState, DWORD anInterval)
{	
    if (aLastState == theState) {
        //
        // wait for a state change from the UPS
        //
        if (theStateChangedEvent) {
            WaitForSingleObject(theStateChangedEvent, anInterval);
        }
    }	
}


/**
* UPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD ApcMiniDriver::UPSGetState()
{
    return theState;
}


/**
* UPSCancelWait
*
* Description:
*   interrupts pending calls to UPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void ApcMiniDriver::UPSCancelWait()
{
    if (theStateChangedEvent) {
        SetEvent(theStateChangedEvent);
    }
}


/**
* UPSTurnOff
*
* Description:
*   Attempts to turn off the outlets on the UPS
*   after the specified delay.  This method querries the 
*   UPS for the allowed shutdown delays and sets the
*   delay to one of the following:
*     1. aTurnOffDelay if it exactly matches one of the allowed values
*     2. the next highest value after aTurnOffDelay, if one exists
*     3. the highest allowed value, if aTurnOffDelay is larger than all of
*        the allowed values.
*   If no allowed values are returned, the Shutdown Delay will not be set.
*   Next the UPS is instructed to sleep until power is restored.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void ApcMiniDriver::UPSTurnOff(DWORD aTurnOffDelay)
{
    if (theUpsApp) {
        char allowed_values[512];

        // Retrieve the allowed shutdown delays from the UPS
        theUpsApp->Get(ALLOWED_SHUTDOWN_DELAYS, allowed_values);

				TokenString token_str(allowed_values, SHUTDOWN_DELAY_SEPARATOR);
				PCHAR tok = token_str.GetCurrentToken();

        // Set the shutdown delay if there are allowed values
        if (tok) {
          
          // Initialize counters
          long requested_value = (long) aTurnOffDelay;
          long max = atol(tok);
          long last_closest = 0;
          
       
          // Cycle through the allowed values looking for a suitable value
				  while (tok) {
            long value = atol(tok);

            // Check to see if this value is closest to the requested
            if ( ((value >= requested_value) && (value < last_closest)) 
              || (last_closest < requested_value)) {
              last_closest = value;
            }

            // Check to see if this value is the max value
            if (value > max) {
              max = value;
            }

            // Get the next value
            tok = token_str.GetCurrentToken();
          }

          long shutdown_delay = last_closest;

          if (last_closest < requested_value) {
            // The requested value is larger than all of the values, use the max
            shutdown_delay = max;
          }

          // Set the shutdown delay
          char shutdown_delay_str[4];
          sprintf(shutdown_delay_str, "%3.3u", shutdown_delay);
          theUpsApp->Set(SHUTDOWN_DELAY, shutdown_delay_str);
        }

        // Signal the UPS to sleep
        theUpsApp->UPSTurnOff();
    }
}


/**
* Update
*
* Description:
*   Update is called when theUpsApp has
*   generated an Event for which this object
*   has registered.
*   Events are defined by a set of integer
*   'codes' defined in the file 'codes.h'
*
* Parameters:
*   anEvent: a pointer to an Event object that
*           defines the generated event
*
* Returns:
*   ErrNO_ERROR   
*   
*/
INT ApcMiniDriver::Update(PEvent anEvent)
{
    INT err = ErrNO_ERROR;
	
    if (!anEvent) {
        return err;
    }
	
    switch (anEvent->GetCode()) {
    case UTILITY_LINE_CONDITION:
        {
            err = onUtilityLineCondition(anEvent);
        }
        break;
		
    case BATTERY_REPLACEMENT_CONDITION:
        {
            err = onBatteryReplacementCondition(anEvent);
        }
        break;
        
    case BATTERY_CONDITION:
        {
            err = onBatteryCondition(anEvent);
        }
        break;
		
    case COMMUNICATION_STATE:
        {
            err = onCommunicationState(anEvent);
        }
        break;

	case TIMER_PULSE:
        {
            err = onTimerPulse(anEvent);
        }
        break;

    default:
        {
            err = UpdateObj::Update(anEvent);
        }
        break;
    }
    return err;
}


/**
* onUtilityLineCondition
*
* Description:
*   Determines the current state of the power
*   and reports any changes to the registry and
*   to any threads pending on UPSWaitForStateChange
*
* Parameters:
*   anEvent: pointer to an Event object that
*           relates to a UTILITY_LINE_CONDITION event
*
* Returns:
*   ErrNO_ERROR
*   
*/
INT ApcMiniDriver::onUtilityLineCondition(PEvent anEvent) 
{
    DWORD state = atoi(anEvent->GetValue());
    DWORD old_state = theState;
	
    if (LINE_BAD == state) {
        theState = UPS_ONBATTERY;
    }
    else {
        theState = UPS_ONLINE;
    }
	
    if (old_state != theState) {
        UPSCancelWait(); 
    }
    return ErrNO_ERROR;
}


/**
* onBatteryReplacementCondition
*
* Description:
*   Determines the current replacement state of the
*   battery and reports any changes to the registry
*
* Parameters:
*   anEvent: pointer to an Event object that
*           relates to a BATTERY_REPLACEMENT_CONDITION event
*
* Returns:
*   ErrNO_ERROR
*   
*/
INT ApcMiniDriver::onBatteryReplacementCondition(PEvent anEvent)
{
    DWORD state = atoi(anEvent->GetValue());
    DWORD old_state = theReplaceBatteryState;
	
    if (BATTERY_NEEDS_REPLACING == state) {
        theReplaceBatteryState = UPS_BATTERYSTATUS_REPLACE;
    }
    else {
        theReplaceBatteryState = UPS_BATTERYSTATUS_GOOD;
    }
	
    if (old_state != theReplaceBatteryState) {
        InitUPSStatusBlock();
        SetUPSStatusBatteryStatus(theReplaceBatteryState);
        SaveUPSStatusBlock(FALSE);
    }
    return ErrNO_ERROR;
}


/**
* onBatteryCondition
*
* Description:
*   Determines the current charge-state of the battery
*   and reports any changes to the registry and
*   to any threads pending on UPSWaitForStateChange
*
* Parameters:
*   anEvent: pointer to an Event object that
*           relates to a BATTERY_CONDITION event
*
* Returns:
*   ErrNO_ERROR
*   
*/
INT ApcMiniDriver::onBatteryCondition(PEvent anEvent)
{
    DWORD old_state = theState;
    DWORD state = atoi(anEvent->GetValue());

    //
    // get the current line condition
    // we only goto low battery if we
    // are also on battery
    //
    char value[256];
    theUpsApp->Get(UTILITY_LINE_CONDITION, value);
    DWORD line_state = atoi(value);
	
    if ((BATTERY_BAD == state) || (LOW_BATTERY == state)) {

        if (LINE_BAD == line_state) {
            theState = UPS_LOWBATTERY;
        }
        else {
            theState = UPS_ONLINE;
        }
    }
    else {
		
        if (LINE_BAD == line_state) {
            theState = UPS_ONBATTERY;
        }
        else {
            theState = UPS_ONLINE;
        }
    }

    if (old_state != theState) {
        UPSCancelWait();
    }
    return ErrNO_ERROR;
}


/**
* onCommunicationState
*
* Description:
*   Determines the communication state to the UPS
*   If theState goes to UPS_NOCOMM we report the change
*   to threads pending on UPSWaitForStateChange
*   If the state is leaving UPS_NOCOMM, we 
*   reinitialize the registry with advanced data
*   and then 'fake' power and battery condition
*   events
*
* Parameters:
*   anEvent: pointer to an Event object that
*           relates to a COMMUNICATION_STATE event
*
* Returns:
*   ErrNO_ERROR
*   
*/
INT ApcMiniDriver::onCommunicationState(PEvent anEvent)
{
    DWORD state = atoi(anEvent->GetValue());
	
    if ((COMMUNICATION_LOST == state) || 
        (COMMUNICATION_LOST_ON_BATTERY == state)) {

        if (UPS_NOCOMM != theState) {
            theState = UPS_NOCOMM;
            UPSCancelWait();
        }
    }
    else {
		
        if (UPS_NOCOMM == theState) {
            //
            // need to re-initialize the UPS data, since
            // when you lose comm, the user might plug in
            // a new UPS system
            //
            initalizeAdvancedUpsData();

            // Set the low battery warning threshold
            setLowBatteryDuration();

            //
            // here we just ask the service what it thinks
            // the current line/battery conditions are, and
            // 'fake' an event to ourselves.  This allows
            // all line/battery state changes to be handled
            // consistently in the same methods
            //
            char value[256];
            theUpsApp->Get(UTILITY_LINE_CONDITION, value);
            Event ulc_evt(UTILITY_LINE_CONDITION, value);
            onUtilityLineCondition(&ulc_evt);
            
            theUpsApp->Get(BATTERY_CONDITION, value);
            Event batt_evt(BATTERY_CONDITION, value);
            onBatteryCondition(&batt_evt);
        }
    }
    return ErrNO_ERROR;
}


/**
* onTimerPulse
*
* Description:
*   Retrieves the on-battery runtime and battery
*   capacity from the UPS and updates the registry
*   with the values if they differ from the last
*   time this method was called
*
* Parameters:
*   anEvent: pointer to an Event object that
*           relates to a TIMER_PULSE event
*
* Returns:
*   ErrNO_ERROR
*   
*/
INT ApcMiniDriver::onTimerPulse(PEvent anEvent)
{
    DWORD old_run_time = theOnBatteryRuntime;
    DWORD old_batt_cap = theBatteryCapacity;

    //
    // get the current on-battery runtime
    //
    CHAR data[100];
    if (theUpsApp->Get(RUN_TIME_REMAINING,data) == ErrNO_ERROR) {
      //
      // we get the RUN_TIME_REMAINING back in seconds
      // the UPS applet expects the value to be in 
      // minutes - 
      theOnBatteryRuntime = atol(data) / 60;
    }

    //
    // get the current battery capacity
    //
    if (theUpsApp->Get(BATTERY_CAPACITY,data) == ErrNO_ERROR) {
      // we get the battery capacity back as a percentage
      // the UPS applet expects only a whole number.
      theBatteryCapacity = (long) atof(data);
    }


    if ((old_run_time != theOnBatteryRuntime) || (old_batt_cap != theBatteryCapacity)){
      // One or more values changed, update the registry
      InitUPSStatusBlock();

      if (old_run_time != theOnBatteryRuntime) {
        // Update run time remaining
        SetUPSStatusRuntime(theOnBatteryRuntime);
      }

      if (old_batt_cap != theBatteryCapacity) {
        SetUPSStatusBatteryCapacity(theBatteryCapacity);
      }

      SaveUPSStatusBlock(FALSE);
    }
    
    //
    // must create another timer to update the
    // value again
    //
    theRunTimeTimer = 
        _theTimerManager->SetTheTimer((ULONG)5, 
        anEvent, 
        this);

    return ErrNO_ERROR;
}


/**
* initalizeAdvancedUpsData
*
* Description:
*   Retrieves the advanced data from theUpsApp
*   and forces an update to the registry with
*   the fresh data
*
* Parameters:
*   None
*
* Returns:
*   ErrNO_ERROR
*   
*/
INT ApcMiniDriver::initalizeAdvancedUpsData()
{
    // Initialize all static registry data
    InitUPSStatusBlock();
    CHAR data[100];
    TCHAR w_data[200];


    theUpsApp->Get(CURRENT_FIRMWARE_REV,data);
#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, data, -1,
        w_data, (sizeof(w_data)/sizeof(TCHAR)));
#else
    strcpy(w_data, data);
#endif
    SetUPSStatusFirmRev(w_data);
    

    theUpsApp->Get(UPS_SERIAL_NUMBER,data);
#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, data, -1,
        w_data, (sizeof(w_data)/sizeof(TCHAR)));
#else
    strcpy(w_data, data);
#endif
    SetUPSStatusSerialNum(w_data);

    // Default utility power and battery status to GOOD
    SetUPSStatusBatteryStatus(UPS_BATTERYSTATUS_GOOD);
    
    SetUPSStatusBatteryCapacity(0);

    SaveUPSStatusBlock(TRUE);
    
    //
    // dummy up a BATTERY_REPLACEMENT_CONDITION event,
    // just to make sure we initialize the registry with
    // valid data, since this is an event we will not
    // be notified unless the state changes
    //
    theUpsApp->Get(BATTERY_REPLACEMENT_CONDITION, data);
    Event replace_batt(BATTERY_REPLACEMENT_CONDITION, data);
    onBatteryReplacementCondition(&replace_batt);

    return ErrNO_ERROR;
}


/**
* initalizeUpsApplication
*
* Description:
*   inits theUpsApp member with a new NTServerApplication
*   object.  
*   Registers for the events that can be received
*   in the Update method
*   Initalizes the advanced UPS data in the registry,
*   and starts the repeating event that triggers updates
*   to get on-battery runtime data
*
* Parameters:
*   None
*
* Returns:
*   ErrNO_ERROR: init succeeded
*   ErrMEMORY: theUpsApp could not be created
*   
*/
INT ApcMiniDriver::initalizeUpsApplication()
{
    INT err = ErrNO_ERROR;

    //
    // assume that the UPS is not on battery
    // this matches the assumption made by
    // the NTServerApplication class
    //
    theState = UPS_ONLINE;
    theUpsApp = new NTServerApplication();
    
    if (!theUpsApp) {
        err = ErrMEMORY;
    }
    else {
        theUpsApp->RegisterEvent(UTILITY_LINE_CONDITION, this);
        theUpsApp->RegisterEvent(BATTERY_CONDITION, this);
        theUpsApp->RegisterEvent(BATTERY_REPLACEMENT_CONDITION, this);
        theUpsApp->RegisterEvent(COMMUNICATION_STATE, this);	
        
        err = theUpsApp->Start();
    }
    
    if (ErrNO_ERROR == err) {
        initalizeAdvancedUpsData();
        
        // Start the polling of UPS run time
        if (!theRunTimeTimer) {
            Event retry_event(TIMER_PULSE, TIMER_PULSE);
            onTimerPulse(&retry_event);
        }
    }
    return err;
}


/**
* cleanupUpsApplication
*
* Description:
*   cleans up and destructs theUpsApp object.  Sets
*   member variables to the default values
*
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void ApcMiniDriver::cleanupUpsApplication()
{
    theState = UPS_ONLINE;

    if (theUpsApp) {
        theUpsApp->Quit();
        delete theUpsApp;
        theUpsApp = NULL;
    }	
    theRunTimeTimer = 0;
    theOnBatteryRuntime = -1;
}

/**
* setLowBatteryDuration
*
* Description:
*   Sets the low battery duration to a value compatable with the 
*   UPSTurnOffWait registry key. This method querries the 
*   UPS for the allowed low battery durations and sets the
*   duration to one of the following:
*     1. The value of UPSTurnOffWait if it exactly matches one of
*        the allowed values
*     2. the next highest value after UPSTurnOffWait, if one exists
*     3. the highest allowed value, if UPSTurnOffWait is larger than
*        all of the allowed values.
*   If the UPSTurnOffWait is not set or no allowed values are returned,
*   the low battery duration will not be set.
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void ApcMiniDriver::setLowBatteryDuration() {
  DWORD turn_off_wait;

  InitUPSConfigBlock();

  if ((GetUPSConfigTurnOffWait(&turn_off_wait) == ERROR_SUCCESS) && (theUpsApp)) {
    char allowed_values[512];
    
    // Retrieve the allowed low battery durations from the UPS
    theUpsApp->Get(ALLOWED_LOW_BATTERY_DURATIONS, allowed_values);
    
		TokenString token_str(allowed_values, LOW_BATT_DURATION_SEPARATOR);
    PCHAR tok = token_str.GetCurrentToken();
    
    // Set the low battery duration if there are allowed values
    if (tok) {
      
      // Initialize counters
      long max = atol(tok);
      long last_closest = 0;
      long requested_value = 0;
      if (turn_off_wait > 0) {
        // Convert the value from seconds to minutes (rounded up)
        requested_value = turn_off_wait / SECONDS_TO_MINUTES;
        if ((turn_off_wait % SECONDS_TO_MINUTES) > 0) {
          ++requested_value;
        }
      }
      
      
      // Cycle through the allowed values looking for a suitable value
      while (tok) {
        long value = atol(tok);
        
        // Check to see if this value is closest to the requested
        if ( ((value >= requested_value) && (value < last_closest)) 
          || (last_closest < requested_value)) {
          last_closest = value;
        }
        
        // Check to see if this value is the max value
        if (value > max) {
          max = value;
        }
        
        // Get the next value
        tok = token_str.GetCurrentToken();
      }
      
      long low_batt_duration = last_closest;
      
      if (last_closest < requested_value) {
        // The requested value is larger than all of the values, use the max
        low_batt_duration = max;
      }
      
      // Set the shutdown delay
      char low_batt_duration_str[4];
      sprintf(low_batt_duration_str, "%2.2u", low_batt_duration);
      theUpsApp->Set(LOW_BATTERY_DURATION, low_batt_duration_str);
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apcdrvr.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserverd
* 
* Description:
*   The ApcMiniDriver class provides an interface that is
*   compatible with the MiniDriver interface for the Windows2000
*   UPS service.  
*   The ApcMiniDriver makes use of a modified 
*   PowerChute plus UPS service.  This modified service has had
*   all of the networking, data logging, and flex manager code
*   removed.  All that is left is the modeling and monitoring of
*   the connected UPS system.  It is assumed that a "smart" 
*   signalling UPS is connected.
*   The ApcMiniDriver class is also responsible for filling in
*   the advanced registry settings, battery replacement condition,
*   serial #, firmware rev, etc...
*
* Revision History:
*   mholly  14Apr1999  Created
*   mholly  12May1999  no longer taking aCommPort in UPSInit
*
*/

#ifndef _INC_APCMINIDRVR_H_
#define _INC_APCMINIDRVR_H_

#include "update.h"

class NTServerApplication;

class ApcMiniDriver : public UpdateObj
{
public:
    ApcMiniDriver();
    ~ApcMiniDriver();

    INT Update(PEvent anEvent) ;
    
    DWORD   UPSInit();
    void    UPSStop();
    void    UPSWaitForStateChange(DWORD aState, DWORD anInterval);
    DWORD   UPSGetState();
    void    UPSCancelWait();
    void    UPSTurnOff(DWORD aTurnOffDelay);

protected:
    INT initalizeAdvancedUpsData();
    INT initalizeUpsApplication();
    void cleanupUpsApplication();
    void setLowBatteryDuration();

    INT onUtilityLineCondition(PEvent anEvent);
    INT onBatteryReplacementCondition(PEvent anEvent);
    INT onBatteryCondition(PEvent anEvent);
    INT onCommunicationState(PEvent anEvent);
    INT onTimerPulse(PEvent anEvent);

private:
    NTServerApplication * theUpsApp;

    DWORD theState;
    HANDLE theStateChangedEvent;
    DWORD theReplaceBatteryState;
    ULONG theRunTimeTimer;
    DWORD theOnBatteryRuntime;
    DWORD theBatteryCapacity;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\xsproc.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    xsproc.c

Abstract:

    This module contains the main processing loop for XACTSRV.

Author:

    David Treadwell (davidtr)    05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

    02-Jun-1992 JohnRo
        RAID 9829: Avoid SERVICE_ equate conflicts.

    Chuck Lenzmeier (chuckl) 17-Jun-1992
        Moved from xssvc to srvsvc\server

--*/

//
// Includes.
//

#include "srvsvcp.h"
#include "xsdata.h"

#include <netevent.h>

#include <windows.h>        // from sdk\inc
#include <winspool.h>       // Dynamically loaded as needed for perf
#include <winsprlp.h>       // addjob_info_2w, private spooler defs

#include <apinums.h>        // from net\inc
#include <netlib.h>         // from net\inc (NetpGetComputerName)

#include <xactsrv2.h>       // from private\inc
#include <smbgtpt.h>

#include <xsconst.h>        // from xactsrv

#include <lmsname.h>        // from \sdk\inc
#include <lmerr.h>          // from \sdk\inc
#include <lmapibuf.h>       // from \sdk\inc (NetApiBufferFree)
#include <lmmsg.h>          // from \sdk\inc (NetMessageBufferSend)
#include <winsvc.h>         // from \sdk\inc

#if DBG
#include <stdio.h>
#include <lmbrowsr.h>
#endif

#undef DEBUG
#undef DEBUG_API_ERRORS
#include <xsdebug.h>

HMODULE hSpoolerLibrary = NULL;
CRITICAL_SECTION SpoolerMutex;

VOID
ConvertApiStatusToDosStatus(
    LPXS_PARAMETER_HEADER header
    );

BOOLEAN
XsProcessApis (
    DWORD ThreadNum
    );

BOOLEAN
XsLoadPrintSpoolerFunctions(
    );

BOOLEAN
XsUnloadPrintSpoolerFunctions(
    );


VOID
XsProcessApisWrapper (
    LPVOID ThreadNumber
    )

/*++

Routine Description:

    This routine provides multithreaded capability for main processing
    routine, XsProcessApis.

Arguments:

    ThreadNum - thread number for debugging purposes.


--*/

{
    XACTSRV_REQUEST_MESSAGE requestMessage;
    BOOLEAN LastThread;
    DWORD ThreadNum = PtrToInt( ThreadNumber );

    //
    //  Increase the priority of this thread to just above foreground (the
    //  same as the rest of the server).
    //

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );

    //
    // Do the APIs
    //
    LastThread = XsProcessApis( ThreadNum );

    IF_DEBUG(THREADS) {
        SS_PRINT(( "Thread %ld exiting, active count %ld\n", ThreadNum,
                    SsData.XsThreads ));
    }

    //
    // If the last thread has terminated, set the All Threads Terminated event.
    //

    if( LastThread ) {

        SetEvent( SsData.XsAllThreadsTerminatedEvent );

    } else if( SsData.XsTerminating ) {

        //
        // There are still threads left, and we are trying to terminate.  Queue
        //  another message to the queue so the next thread will get it and
        //  notice that we're trying to quit.
        //
        RtlZeroMemory( &requestMessage, sizeof( requestMessage ));
        requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
        requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
        requestMessage.MessageType = XACTSRV_MESSAGE_WAKEUP;

        NtRequestPort(
            SsData.XsConnectionPortHandle,
            (PPORT_MESSAGE)&requestMessage
            );
    }

    ExitThread( NO_ERROR );

} // XsProcessApisWrapper


BOOLEAN
XsProcessApis (
    DWORD ThreadNum
    )

/*++

Routine Description:

    This routine waits for messages to come through the LPC port to
    the server.  When one does, it calls the appropriate routine to
    handle the API, then replies to the server indicating that the
    API has completed.

Arguments:

    ThreadNum - thread number for debugging purposes.

Return Value:

    TRUE if we are the last thread

--*/

{
    NTSTATUS status;
    NET_API_STATUS error;
    XACTSRV_REQUEST_MESSAGE request;
    XACTSRV_REPLY_MESSAGE reply;
    BOOL sendReply = FALSE;
    BOOL ValidationSuccessful = FALSE;
    LPTRANSACTION transaction;
    WORD apiNumber;
    LPXS_PARAMETER_HEADER header;
    LPVOID parameters;
    LPDESC structureDesc;
    LPDESC auxStructureDesc;
    LPDESC paramStructureDesc;
    LARGE_INTEGER timeout;
#if 0
    LARGE_INTEGER XactSrvStartTime;
    LARGE_INTEGER XactSrvEndTime;
    LARGE_INTEGER PerformanceFrequency;
#endif
    LONG availableThreads;
    LONG i;

    i = InterlockedIncrement( &SsData.XsThreads );

    //
    // Loop dispatching API requests.
    //
    while ( SsData.XsTerminating == FALSE ) {

        //
        // We're waiting to handle another API...
        //
        InterlockedIncrement( &SsData.XsWaitingApiThreads );

        //
        // Send the reply to the last message and wait for the next message.
        //
        // Wait for 30 seconds if there are many servicing threads.  If there
        //  is only one thread, we can wait without a timeout.
        //
        timeout.QuadPart = -1*10*1000*1000*30;

        status = NtReplyWaitReceivePortEx(
                     SsData.XsCommunicationPortHandle,
                     NULL,                       // PortContext
                     sendReply ? (PPORT_MESSAGE)&reply : NULL,
                     (PPORT_MESSAGE)&request,
                     SsData.XsThreads > 1 ? &timeout : NULL
                     );

        sendReply = TRUE;

        //
        // Set 'availableThreads' to the number of threads currently available to service
        //  API requests
        //
        availableThreads = InterlockedDecrement( &SsData.XsWaitingApiThreads );

        IF_DEBUG(THREADS) {
            SS_PRINT(( "XsProcessApis: Thread %d:  NtReplyWaitReceivePort %X, msg %X\n",
                       ThreadNum, status, &request ));
        }

        if( status == STATUS_TIMEOUT ) {
            //
            // If this is the last thread, or we seem busy, then don't terminate.
            //
            if( InterlockedDecrement( &SsData.XsThreads ) == 0 ||
                availableThreads == 0 ) {

                    //
                    // Do not terminate.
                    //
                    InterlockedIncrement( &SsData.XsThreads );
                    sendReply = FALSE;
                    continue;
            }

            //
            // This thread can terminate, there isn't enough work to support it.
            //
            return FALSE;

        }

        if( !NT_SUCCESS( status ) ||
            SsData.XsTerminating ||
            request.PortMessage.u2.s2.Type == LPC_PORT_CLOSED ) {

            //
            // The port is no longer valid, or XACTSRV is terminating.
            //

            IF_DEBUG(THREADS) {
                SS_PRINT(( "XsProcessApis: %X\n", status ));
                SS_PRINT(( "XsProcessApis: %s.  Thread %ld quitting\n",
                            SsData.XsTerminating ?
                                "XACTSRV terminating" : "Port invalid",
                            ThreadNum ));
            }

            break;
        }

        //
        // If we have received anything other than a message, then something
        //  strange is happening.  Ignore it.
        //
        if( (request.PortMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST ) {
            //
            // Reject this connection attempt
            //

            IF_DEBUG(LPC) {
                SS_PRINT(( "XsProcessApis: unexpected LPC_CONNECTION_REQUEST rejected\n" ));
            }

            NtAcceptConnectPort(    SsData.XsCommunicationPortHandle,
                                    NULL,
                                    (PPORT_MESSAGE)&request,
                                    FALSE,
                                    NULL,
                                    NULL
                                );
            sendReply = FALSE;
            continue;

        } else if( !(request.PortMessage.u2.s2.Type & LPC_REQUEST) ) {
            //
            // This is not a request message.  Reject it.
            //

            IF_DEBUG(LPC) {
                SS_PRINT(( "XsProcessApis: unexpected LPC type %X rejected\n",
                        request.PortMessage.u2.s2.Type ));
            }

            sendReply = FALSE;
            continue;
        }

        IF_DEBUG(THREADS) {
            SS_PRINT(( "XsProcessApis: Thread %ld responding to request, "
                       "  MessageType %d, SsData.XsTerminating %d",
                        ThreadNum, request.MessageType, SsData.XsTerminating ));
        }

        if( availableThreads == 0 ) {

            HANDLE threadHandle;
            DWORD  threadId;
            
            //
            // Are there other threads ready to handle new requests?  If not, then
            // we should spawn a new thread.  Since the server synchronously sends
            // requests to xactsrv, we will never end up with more than
            // the maximum number of server worker threads + 1.
            //

            threadHandle = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)XsProcessApisWrapper,
                                IntToPtr(SsData.XsThreads),
                                0,
                                &threadId
                                );

            if ( threadHandle != 0 ) {

                IF_DEBUG(THREADS) {
                    SS_PRINT(( "XsStartXactsrv: Created thread %ld for "
                                  "processing APIs\n", SsData.XsThreads ));
                }

                CloseHandle( threadHandle );

            } else {

                IF_DEBUG(THREADS) {
                    SS_PRINT(( "XsStartXactsrv: Unable to create thread %ld for "
                                  "processing APIs\n", SsData.XsThreads ));
                }

            }
        }

        //
        // Set up the response message to be sent on the next call to
        // NtReplyWaitReceivePort.
        //
        reply.PortMessage.u1.s1.DataLength =
            sizeof(reply) - sizeof(PORT_MESSAGE);
        reply.PortMessage.u1.s1.TotalLength = sizeof(reply);
        reply.PortMessage.u2.ZeroInit = 0;
        reply.PortMessage.ClientId = request.PortMessage.ClientId;
        reply.PortMessage.MessageId = request.PortMessage.MessageId;

        switch ( request.MessageType ) {
        case XACTSRV_MESSAGE_DOWN_LEVEL_API:

            //
            // Get a pointer to the transaction block from the message.
            // It is the file server's responsibility to set up this
            // pointer correctly, and since he is a trusted entity, we
            // do no checking on the pointer value.
            //

            transaction = request.Message.DownLevelApi.Transaction;
            ASSERT( transaction != NULL );

#if 0
            NtQueryPerformanceCounter(&XactSrvStartTime, &PerformanceFrequency);

            //
            //  Convert frequency from ticks/second to ticks/millisecond
            //

            PerformanceFrequency = LiXDiv(PerformanceFrequency, 1000);

            if (LiGeq(XactSrvStartTime, transaction->XactSrvTime)) {
                CHAR Buffer[200];
                LARGE_INTEGER LpcTime = LiSub(XactSrvStartTime, transaction->XactSrvTime);

                LpcTime = LiDiv(LpcTime, PerformanceFrequency);

                sprintf(Buffer, "XactSrv: LPC Time: %ld milliseconds (%ld)\n", LpcTime.LowPart, LpcTime.HighPart);

                I_BrowserDebugTrace(NULL, Buffer);
            }
#endif
            //
            // The API number is the first word in the parameters
            // section, and it is followed by the parameter descriptor
            // string.  After that comes the data descriptor.
            //

            apiNumber = SmbGetUshort( (LPWORD)transaction->InParameters );
            paramStructureDesc = (LPDESC)( transaction->InParameters + 2 );

            try {

                structureDesc = paramStructureDesc
                                + strlen( paramStructureDesc ) + 1;

            } except( EXCEPTION_EXECUTE_HANDLER ) {
                reply.Message.DownLevelApi.Status = GetExceptionCode();
                break;
            }

            //
            // Make sure the API number is in range.
            //

            if ( apiNumber >=
                    (sizeof(XsApiTable) / sizeof(XS_API_TABLE_ENTRY)) ) {

                reply.Message.DownLevelApi.Status =
                                            STATUS_INVALID_SYSTEM_SERVICE;
                break;
            }

            //
            // Make sure xactsrv.dll is loaded, and a handler is available for this
            //  request.
            //
            if( XsApiTable[ apiNumber ].Handler == NULL &&
                XsLoadXactLibrary( apiNumber ) == FALSE ) {

                reply.Message.DownLevelApi.Status = STATUS_INVALID_SYSTEM_SERVICE;
                break;
            }

            //
            // Check if the parameter descriptor is valid.  If not,
            // there is obviously something very wrong about this
            // request.
            //

            ValidationSuccessful = FALSE;

            try {
                if (XsApiTable[apiNumber].Params == NULL &&
                    *paramStructureDesc != '\0') {
                    reply.Message.DownLevelApi.Status = STATUS_INVALID_PARAMETER;
                    goto ValidationFailed;
                } else if ( !XsCheckSmbDescriptor(
                                 paramStructureDesc,
                                 XsApiTable[apiNumber].Params )) {
                    reply.Message.DownLevelApi.Status = STATUS_INVALID_PARAMETER;
                    goto ValidationFailed;
                }

                //
                // Capture the input parameters into a buffer.  The API
                // handler will treat this data as passed-in parameters.
                //

                header = XsCaptureParameters( transaction, &auxStructureDesc );

                if ( header == NULL ) {
                    reply.Message.DownLevelApi.Status = STATUS_NO_MEMORY;
                    goto ValidationFailed;
                }

                ValidationSuccessful = TRUE;

            ValidationFailed:
                ;
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                reply.Message.DownLevelApi.Status = GetExceptionCode();
                break;
            }

            if (!ValidationSuccessful) {
                break;
            }

            //
            // Initialize header to default values.
            //

            header->Converter = 0;
            header->Status = NO_ERROR;
            header->ClientMachineName =
                request.Message.DownLevelApi.ClientMachineName;

            header->ClientTransportName = request.Message.DownLevelApi.TransportName;

            header->EncryptionKey = request.Message.DownLevelApi.LanmanSessionKey;

            header->Flags = request.Message.DownLevelApi.Flags;

            header->ServerName = request.Message.DownLevelApi.ServerName;

            parameters = header + 1;

            IF_DEBUG(LPC) {

                SS_PRINT(( "XsProcessApis: received message from %ws at %lx, "
                              "transaction %lx, API %ld on transport %ws\n",
                              header->ClientMachineName, &request,
                              transaction, apiNumber,
                              header->ClientTransportName ));
            }

            IF_DEBUG(DESC_STRINGS) {

                SS_PRINT(( "XsProcessApis: API %ld, parameters %s, data %s\n",
                              apiNumber, paramStructureDesc, structureDesc ));
            }

            //
            // Impersonate the client before calling the API.
            //

            if ( XsApiTable[apiNumber].ImpersonateClient ) {

                // NULL-session requests to impersonating API's are blocked by SRV.SYS (in xssupp.c),
                // otherwise NULL sessions could execute API's as privileged users.

                status = NtImpersonateClientOfPort(
                             SsData.XsCommunicationPortHandle,
                             (PPORT_MESSAGE)&request
                             );

                if ( !NT_SUCCESS(status) ) {

                    IF_DEBUG(ERRORS) {
                        SS_PRINT(( "XsProcessApis: NtImpersonateClientOfPort "
                                      "failed: %X\n", status ));
                    }

                    reply.Message.DownLevelApi.Status = ERROR_ACCESS_DENIED;
                    break;
                }
            }

            try {
                //
                // Call the API processing routine to perform the actual API call.
                // The called routine should set up parameters, make the actual API
                // call, and return the status to us.
                //

                reply.Message.DownLevelApi.Status =
                    XsApiTable[apiNumber].Handler(
                         header,
                         parameters,
                         structureDesc,
                         auxStructureDesc
                         );
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                reply.Message.DownLevelApi.Status = GetExceptionCode();
            }

            //
            // Discontinue client impersonation.
            //

            if ( XsApiTable[apiNumber].ImpersonateClient ) {

                PVOID dummy = NULL;

                status = NtSetInformationThread(
                             NtCurrentThread( ),
                             ThreadImpersonationToken,
                             &dummy,  // discontinue impersonation
                             sizeof(PVOID)
                             );

                if ( !NT_SUCCESS(status)) {
                    IF_DEBUG(ERRORS) {
                        SS_PRINT(( "XsProcessApis: NtSetInformationThread "
                                      "(revert) failed: %X\n", status ));
                    }
                    // *** Ignore the error.
                }
            }

            //
            // Make sure we return the right error codes
            //

            if ( header->Status != NERR_Success ) {
                ConvertApiStatusToDosStatus( header );
            }

            //
            // Put the parameters in the transaction and free the parameter
            // buffer.
            //

            XsSetParameters( transaction, header, parameters );

            break;

        case XACTSRV_MESSAGE_OPEN_PRINTER: {

            UNICODE_STRING printerName;

            if( !pSpoolerOpenPrinterFunction )
            {
                if( !XsLoadPrintSpoolerFunctions() )
                {
                    reply.Message.OpenPrinter.Error = GetLastError();
                    break;
                }
            }

            RtlInitUnicodeString(
                &printerName,
                (PWCH)request.Message.OpenPrinter.PrinterName
                );

            if (!(*pSpoolerOpenPrinterFunction)( printerName.Buffer,
                              &reply.Message.OpenPrinter.hPrinter, NULL)) {

                reply.Message.OpenPrinter.Error = GetLastError();
                SS_PRINT(( "XsProcessApis: OpenPrinter failed: %ld\n",
                                  reply.Message.OpenPrinter.Error ));
                break;
            }


            reply.Message.OpenPrinter.Error = NO_ERROR;
            break;
        }

        case XACTSRV_MESSAGE_ADD_JOB_PRINTER:
        {
            LPADDJOB_INFO_2W addJob;
            PRINTER_DEFAULTS prtDefault;
            DWORD bufferLength;
            UNICODE_STRING dosName;
            UNICODE_STRING ntName;
            BOOL ok;
            PVOID dummy = NULL;

            if( !(pSpoolerResetPrinterFunction || pSpoolerAddJobFunction) )
            {
                if( !XsLoadPrintSpoolerFunctions() )
                {
                    reply.Message.OpenPrinter.Error = GetLastError();
                    break;
                }
            }

            //
            // Allocate space for the add job structure.  This buffer
            // will get the JobId and the spool file path name.
            //

            bufferLength = sizeof(ADDJOB_INFO_2W) +
                                (MAXIMUM_FILENAME_LENGTH * sizeof(TCHAR));

            addJob = (LPADDJOB_INFO_2W) LocalAlloc( LPTR, bufferLength );
            if ( addJob == NULL ) {
                reply.Message.AddPrintJob.Error = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            //
            // Impersonate the client before calling the API.
            //

            status = NtImpersonateClientOfPort(
                         SsData.XsCommunicationPortHandle,
                         (PPORT_MESSAGE)&request
                         );

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    SS_PRINT(( "XsProcessApis: NtImpersonateClientOfPort "
                                  "failed: %X\n", status ));
                }

                LocalFree( addJob );
                reply.Message.DownLevelApi.Status = ERROR_ACCESS_DENIED;
                break;
            }

            //
            // call ResetJob so that we will pick up the new printer defaults
            //

            prtDefault.pDatatype = (LPWSTR)-1;
            prtDefault.pDevMode = (LPDEVMODEW)-1;
            prtDefault.DesiredAccess = 0;

            ok = (*pSpoolerResetPrinterFunction)(
                        request.Message.AddPrintJob.hPrinter,
                        &prtDefault
                        );

            if ( !ok ) {

                //
                // *** Ignore the error.  AddJob will use the old defaults
                // in this case.
                //

                IF_DEBUG(ERRORS) {
                    DWORD error;
                    error = GetLastError( );
                    SS_PRINT(( "XsProcessApis: ResetPrinter "
                        "failed: %ld\n", error ));
                }
            }

            // Setup IN arguments to AddJob buffer

            addJob->pData = request.Message.AddPrintJob.ClientMachineName;

            //
            // Call AddJob to set up the print job and get a job ID
            // and spool file name.
            //

            ok = (*pSpoolerAddJobFunction)(
                      request.Message.AddPrintJob.hPrinter,
                      3,
                      (LPBYTE)addJob,
                      bufferLength,
                      &bufferLength
                      );

            if ( !ok ) {
                reply.Message.AddPrintJob.Error = GetLastError( );
            }

            //
            // Discontinue client impersonation.
            //

            status = NtSetInformationThread(
                         NtCurrentThread( ),
                         ThreadImpersonationToken,
                         &dummy,  // discontinue impersonation
                         sizeof(PVOID)
                         );

            if ( !NT_SUCCESS(status)) {
                IF_DEBUG(ERRORS) {
                    SS_PRINT(( "XsProcessApis: NtSetInformationThread "
                                  "(revert) failed: %X\n", status ));
                }
                // *** Ignore the error.
            }

            if ( !ok ) {
                SS_PRINT(( "XsProcessApis: AddJob failed, %ld\n",
                                  reply.Message.AddPrintJob.Error ));
                LocalFree( addJob );
                break;
            }

            //
            // Set up the information in the return buffer.
            //

            reply.Message.AddPrintJob.JobId = addJob->JobId;

            RtlInitUnicodeString( &dosName, addJob->pData );

            status = RtlDosPathNameToNtPathName_U(
                         dosName.Buffer,
                         &ntName,
                         NULL,
                         NULL
                         );
            if ( !NT_SUCCESS(status) ) {
                IF_DEBUG(ERRORS) {
                    SS_PRINT(( "XsProcessApis: Dos-to-NT path failed: %X\n",
                                status ));
                }
                ntName.Buffer = NULL;
                ntName.Length = 0;
            }

            //
            // Set up return data.
            //

            reply.Message.AddPrintJob.BufferLength = ntName.Length;
            reply.Message.AddPrintJob.Error = NO_ERROR;
            RtlCopyMemory(
                request.Message.AddPrintJob.Buffer,
                ntName.Buffer,
                ntName.Length
                );

            //
            // Free allocated resources.
            //

            LocalFree( addJob );
            if ( ntName.Buffer != NULL ) {
                RtlFreeHeap( RtlProcessHeap( ), 0, ntName.Buffer );
            }

            break;
        }

        case XACTSRV_MESSAGE_SCHD_JOB_PRINTER:

            if( !pSpoolerScheduleJobFunction )
            {
                if( !XsLoadPrintSpoolerFunctions() )
                {
                    reply.Message.OpenPrinter.Error = GetLastError();
                    break;
                }
            }

            //
            // Call ScheduleJob( ) to indicate that we're done writing to
            // the spool file.
            //

            if ( !(*pSpoolerScheduleJobFunction)(
                      request.Message.SchedulePrintJob.hPrinter,
                      request.Message.SchedulePrintJob.JobId ) ) {

                reply.Message.SchedulePrintJob.Error = GetLastError( );
                SS_PRINT(( "XsProcessApis: ScheduleJob failed, %ld\n",
                                  reply.Message.SchedulePrintJob.Error ));
                break;
            }

            reply.Message.SchedulePrintJob.Error = NO_ERROR;
            break;

        case XACTSRV_MESSAGE_CLOSE_PRINTER:

            if( !pSpoolerClosePrinterFunction )
            {
                if( !XsLoadPrintSpoolerFunctions() )
                {
                    reply.Message.OpenPrinter.Error = GetLastError();
                    break;
                }
            }

            if ( !(*pSpoolerClosePrinterFunction)( request.Message.ClosePrinter.hPrinter ) ) {
                reply.Message.ClosePrinter.Error = GetLastError( );
                SS_PRINT(( "XsProcessApis: ClosePrinter failed: %ld\n",
                                  reply.Message.ClosePrinter.Error ));
                break;
            }

            reply.Message.ClosePrinter.Error = NO_ERROR;
            break;

        case XACTSRV_MESSAGE_MESSAGE_SEND:
        {
            LPTSTR sender;

            error = NetpGetComputerName( &sender );

            if ( error != NO_ERROR ) {
                SS_PRINT(( "XsProcessApis: NetpGetComputerName failed: %ld\n",
                            error ));
                reply.Message.MessageBufferSend.Error = error;
                break;
            }

            error = NetMessageBufferSend(
                        NULL,

                        //
                        // the following LPTSTR typecast is not wrong, because the
                        // ServerService will always be built for UNICODE.  If you
                        // want to rebuild it for ASCII, then 
                        // it must be fixed in ntos\srv\scavengr.c which
                        // should pass in a LPWSTR if built for unicode or
                        // convert the UNICODE_STRING to an OEM_STRING and
                        // pass a pointer to the buffer field, as it does
                        // now
                        //

                        (LPTSTR)request.Message.MessageBufferSend.Receipient,
                        sender,
                        request.Message.MessageBufferSend.Buffer,
                        request.Message.MessageBufferSend.BufferLength
                        );

            if ( error != NO_ERROR ) {
                SS_PRINT(( "XsProcessApis: NetMessageBufferSend failed: %ld\n",
                            error ));
            }

            (void) NetApiBufferFree( sender );

            reply.Message.MessageBufferSend.Error = error;
            break;
        }

        case XACTSRV_MESSAGE_LSREQUEST:
            SS_PRINT(( "LSREQUEST User: %ws\n", request.Message.LSRequest.UserName ));
        {
            NT_LS_DATA NtLSData;

            //
            // Ensure we have loaded the license library.  Or at least tried to!
            //
            if( SsData.SsLicenseRequest == NULL && !SsLoadLicenseLibrary() ) {
                //
                // Now what do we do?  Let's be a kind and gentle server and let
                //  the client in.
                //
                reply.Message.LSRequest.Status = STATUS_SUCCESS;
                reply.Message.LSRequest.hLicense = &SsData.SsFreeLicense;
                break;
            }

            NtLSData.DataType = NT_LS_USER_NAME;
            NtLSData.Data = request.Message.LSRequest.UserName;
            NtLSData.IsAdmin = request.Message.LSRequest.IsAdmin;

            reply.Message.LSRequest.Status = SsData.SsLicenseRequest (
                SsData.ServerProductName,
                SsData.szVersionNumber,
                (LS_HANDLE *)&reply.Message.LSRequest.hLicense,
                &NtLSData
               );

            if( !NT_SUCCESS( reply.Message.LSRequest.Status ) ) {
                //
                // We need to return the 'same old' error code that clients are used to
                //  getting for when the server is full
                //
                SS_PRINT(("LSREQUEST returns status %X, mapping to %X\n",
                          reply.Message.LSRequest.Status, STATUS_REQUEST_NOT_ACCEPTED ));
                reply.Message.LSRequest.Status = STATUS_REQUEST_NOT_ACCEPTED;
            }

            break;
        }

        case XACTSRV_MESSAGE_LSRELEASE:

            SS_PRINT(( "LSRELEASE Handle: %X\n", request.Message.LSRelease.hLicense ));

            if( SsData.SsFreeLicense != NULL &&
                request.Message.LSRelease.hLicense != &SsData.SsFreeLicense ) {

                SsData.SsFreeLicense( (LS_HANDLE)request.Message.LSRelease.hLicense );
            }

            break;

        case XACTSRV_MESSAGE_PNP:
        {
            PUNICODE_STRING transportName;
            BOOLEAN bind = request.Message.Pnp.Bind;

            //
            // Capture the parameters, release the server, and issue the bind or unbind
            //
            transportName = (PUNICODE_STRING)LocalAlloc(
                                        LPTR,
                                        sizeof( UNICODE_STRING ) +
                                        request.Message.Pnp.TransportName.MaximumLength
                                        );

            if( transportName == NULL ) {
                SS_PRINT(( "XACTSRV_MESSAGE_PNP: LocalAlloc failed!\n" ));
                break;
            }

            transportName->Buffer = (PUSHORT)(transportName+1);
            transportName->MaximumLength = request.Message.Pnp.TransportName.MaximumLength;
            RtlCopyUnicodeString(transportName, &request.Message.Pnp.TransportName );

            //
            // Now process the PNP command
            //
            if( bind == TRUE ) {
                //
                // If it is a bind, send the response now, and continue with the operation
                //
                sendReply = FALSE;
                status = NtReplyPort( SsData.XsCommunicationPortHandle, (PPORT_MESSAGE)&reply );

                //
                // Bind to the transport.  First bind the primary server name, then bind all
                //   of the secondary names.  These calls will log errors as necessary.
                //
                BindToTransport( transportName->Buffer );

                BindOptionalNames( transportName->Buffer );

            } else {
                //
                // Unbind from the transport
                //
                I_NetServerTransportDel( transportName );
            }

            LocalFree( transportName );

            break;
        }

        default:

            SS_ASSERT( FALSE );

        }
   }

    return (InterlockedDecrement( &SsData.XsThreads ) == 0) ? TRUE : FALSE;

} // XsProcessApis



VOID
ConvertApiStatusToDosStatus(
    LPXS_PARAMETER_HEADER Header
    )
/*++

Routine Description:

    This routine converts an api return status to status expected by
    downlevel.

Arguments:

    Header - structure containing the status.

Return Value:

--*/
{
    WORD dosStatus;

    switch ( Header->Status ) {
    case ERROR_SPECIAL_ACCOUNT:
    case ERROR_SPECIAL_GROUP:
    case ERROR_SPECIAL_USER:
    case ERROR_INVALID_LOGON_TYPE:
        dosStatus = ERROR_INVALID_PARAMETER;
        break;

    case ERROR_DEPENDENT_SERVICES_RUNNING:
        dosStatus = NERR_ServiceCtlNotValid;
        break;

    case ERROR_INVALID_DOMAINNAME:
        dosStatus = NERR_NotLocalDomain;
        break;

    case ERROR_NO_SUCH_USER:
        dosStatus = NERR_UserNotFound;
        break;

    case ERROR_ALIAS_EXISTS:
        dosStatus = NERR_GroupExists;
        break;

    case NERR_BadServiceName:
        dosStatus = NERR_ServiceNotInstalled;
        break;

    case ERROR_ILL_FORMED_PASSWORD:
    case NERR_PasswordTooRecent:
        dosStatus = ERROR_INVALID_PASSWORD;
        break;

    case ERROR_PASSWORD_RESTRICTION:
        dosStatus = NERR_PasswordHistConflict;
        break;

    case ERROR_ACCOUNT_RESTRICTION:
        dosStatus = NERR_PasswordTooRecent;
        break;

    case ERROR_PASSWORD_EXPIRED:
    case ERROR_PASSWORD_MUST_CHANGE:
        dosStatus = NERR_PasswordExpired;
        break;

    case ERROR_INVALID_PRINTER_NAME:
        dosStatus = NERR_QNotFound;
        break;

    case ERROR_UNKNOWN_PRINTER_DRIVER:
        dosStatus = NERR_DriverNotFound;
        break;

    case ERROR_NO_BROWSER_SERVERS_FOUND:

        //
        //  Down level clients don't understand how to deal with
        //  the "No browser server" error, so we turn it into success.
        //
        //  This seems wrong to me, but it is what WfW does in the
        //  same circumstance.
        //

        if ( !(Header->Flags & XS_FLAGS_NT_CLIENT) ) {
            dosStatus = NERR_Success;
        } else {
            dosStatus = Header->Status;
        }
        break;

    default:

        //
        // make sure it's a valid lm error code
        //

        if ( (Header->Status > ERROR_VC_DISCONNECTED) &&
                    ((Header->Status < NERR_BASE) ||
                     (Header->Status > MAX_NERR)) ) {

            NTSTATUS status;
            LPWSTR substring[1];
            WCHAR errorString[10];
            UNICODE_STRING unicodeString;

            substring[0] = errorString;
            unicodeString.MaximumLength = 10 * sizeof(WCHAR);
            unicodeString.Buffer = errorString;

            status = RtlIntegerToUnicodeString(
                            (ULONG) Header->Status,
                            10,
                            &unicodeString
                            );

            if ( NT_SUCCESS( status ) ) {
                SsLogEvent(
                    EVENT_SRV_CANT_MAP_ERROR,
                    1,
                    substring,
                    NO_ERROR
                    );
            }

            dosStatus = ERROR_UNEXP_NET_ERR;
            SS_PRINT(( "srvsvc: unmapped error %d from xactsrv.\n",
                        Header->Status )) ;

        } else {

            //
            // No change
            //

            return;
        }
    }

    Header->Status = dosStatus;
    return;

} // ConvertApiStatusToDosStatus


BOOLEAN
XsLoadPrintSpoolerFunctions(
    )
{
    BOOLEAN bReturn = TRUE;

    EnterCriticalSection( &SpoolerMutex );

    if( !hSpoolerLibrary )
    {
        hSpoolerLibrary = LoadLibrary( L"winspool.drv" );
        if( !hSpoolerLibrary )
        {
            bReturn = FALSE;
            goto finish;
        }

        pSpoolerOpenPrinterFunction = (PSPOOLER_OPEN_PRINTER)GetProcAddress( hSpoolerLibrary, "OpenPrinterW" );
        if( !pSpoolerOpenPrinterFunction )
        {
            bReturn = FALSE;
            goto finish;
        }
        pSpoolerResetPrinterFunction = (PSPOOLER_RESET_PRINTER)GetProcAddress( hSpoolerLibrary, "ResetPrinterW" );
        if( !pSpoolerResetPrinterFunction )
        {
            bReturn = FALSE;
            goto finish;
        }
        pSpoolerAddJobFunction = (PSPOOLER_ADD_JOB)GetProcAddress( hSpoolerLibrary, "AddJobW" );
        if( !pSpoolerAddJobFunction )
        {
            bReturn = FALSE;
            goto finish;
        }
        pSpoolerScheduleJobFunction = (PSPOOLER_SCHEDULE_JOB)GetProcAddress( hSpoolerLibrary, "ScheduleJob" );
        if( !pSpoolerScheduleJobFunction )
        {
            bReturn = FALSE;
            goto finish;
        }
        pSpoolerClosePrinterFunction = (PSPOOLER_CLOSE_PRINTER)GetProcAddress( hSpoolerLibrary, "ClosePrinter" );
        if( !pSpoolerClosePrinterFunction )
        {
            bReturn = FALSE;
            goto finish;
        }
    }

finish:
    if( !bReturn )
    {
        pSpoolerOpenPrinterFunction = NULL;
        pSpoolerResetPrinterFunction = NULL;
        pSpoolerAddJobFunction = NULL;
        pSpoolerScheduleJobFunction = NULL;
        pSpoolerClosePrinterFunction = NULL;

        if( hSpoolerLibrary )
        {
            FreeLibrary( hSpoolerLibrary );
            hSpoolerLibrary = NULL;
        }
    }

    LeaveCriticalSection( &SpoolerMutex );

    return bReturn;
}

BOOLEAN
XsUnloadPrintSpoolerFunctions(
    )
{
    EnterCriticalSection( &SpoolerMutex );

    pSpoolerOpenPrinterFunction = NULL;
    pSpoolerResetPrinterFunction = NULL;
    pSpoolerAddJobFunction = NULL;
    pSpoolerScheduleJobFunction = NULL;
    pSpoolerClosePrinterFunction = NULL;

    if( hSpoolerLibrary )
    {
        FreeLibrary( hSpoolerLibrary );
        hSpoolerLibrary = NULL;
    }

    LeaveCriticalSection( &SpoolerMutex );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apcobj.cxx ===
/*
*
* NOTES:
*
* REVISIONS:
*  ane23Dec92:  Added #define of DECLARE_ISA_TEXT
*  pcy13Jan93: Removed == and != member functions.  They're already in the header.
*  pcy18Sep93: Moved implementation of equals to .cxx
*  rct05Nov93: Added memory check stuff
*  pcy04Apr94: Removed do nothing constructors for space
*  cad07Apr94: initing debug flag
*  mwh01Jun94: port for INTERACTIVE
*  ash08Aug96: Added new handler
*  poc17Sep96: New handler code should not be compiled on Unix
*  poc17Sep96: Missed a M. Windows specific file - should not be included.
*  srt30Sep96:  Fixed initializer of memhdlr
*/
//                                                                        
// Implementation of a generic object...derived from Borland's container
// class libraries.
//
//                                                                        

#include "cdefine.h"

extern "C" {
#include <stdlib.h>
#include <stdio.h>
   
#include <windows.h>
  
}

#define DECLARE_ISA_TEXT
#include "apcobj.h"
#include "isa.h"


//------------------------------------------------------------------------

Obj::Obj() : theObjectStatus(ErrNO_ERROR)
{
#ifdef APCDEBUG
   theDebugFlag = 0;
#endif
}



//------------------------------------------------------------------------

Obj::~Obj()
{
#ifdef MCHK
   strncpy(memCheck, "                              ", 30);
#endif
}

//------------------------------------------------------------------------

INT Obj::IsA() const
{
   return OBJ;
}

//------------------------------------------------------------------------

INT Obj::Equal( RObj anObj) const 
{
   if(this == &anObj)
   {
      return TRUE;
   }
   else
   {
      return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apcsemnt.h ===
/*
 *
 * REVISIONS:
 *  jwa 09FEB93 created
 *  pcy06Mar93: Added TimedRequest member function
 *  pcy21Apr93: OS2 FE merge
 *  srt21Jun96: Added named shared event type semaphores
 *
 */


#ifndef __APCSEMAPHOR_H
#define __APCSEMAPHOR_H

#include "semaphor.h"

#define INCL_DOSSEMAPHORES
#define INCL_NOPMAPI
#include <windows.h>
#include <tchar.h>

_CLASSDEF( ApcSemaphore )

class ApcSemaphore : public Semaphore {

private:
   HANDLE SemHand;          // This is the handle returned by the Nt create Mutex function

public:
   ApcSemaphore();
   ApcSemaphore( TCHAR * anEventName);
   virtual ~ApcSemaphore();

   virtual INT	 Post();
   virtual INT   Clear();
   virtual INT   IsPosted();
   virtual INT   TimedWait( LONG aTimeOut );	// 0, <0 (block), n>0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apcsemnt.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 * jwa 09FEB92 creation
 *  pcy21Apr93: OS2 FE merge
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  srt21Jun96: Added named shared event type semaphores
 *  mwh27Jan97: add this pointer to semaphore name in default ctor, needed
 *              to help with semaphores being used in a DLL and a client
 *              to a DLL.  The DLL and the client each get their own copy
 *              of SemKey, but the memory addresses will be unique
 */
#include "cdefine.h"

#if (C_OS & C_NT)
#include <windows.h>
#include <stdio.h>
#endif

#include "err.h"
#include "apcsemnt.h"

INT SemKey = 0;


//-------------------------------------------------------------------------
// The semaphore is created as unnamed and shared
//
ApcSemaphore::ApcSemaphore(VOID) : 
   Semaphore()
{
    SetObjectStatus(ErrNO_ERROR);
    
    // unnamed semaphore, shared and 

    TCHAR cBuffer[128];

    // add use of this pointer in the name - the memory address will be
    // unique throughout this process, including any DLL's that are mapped
    // in.  This ocurred because if a DLL uses ApcSemaphore, and a client
    // of the DLL also uses ApcSemaphore they each have their own copy of
    // SemKey, meaning it is possible, and likely that when the DLL makes
    // use of this CTOR, and the client makes use of this CTOR that they
    // will map to the same name, therefore you will get two ApcSemaphore
    // objects that both reference the same event.  By adding the this
    // pointer each event should be unique
    _stprintf(cBuffer,_TEXT("%ld%ld_%d_%ld"),GetCurrentProcessId(),GetCurrentThreadId(),
            SemKey,this);
    SemKey++;
    SemHand=CreateEvent((LPSECURITY_ATTRIBUTES)NULL,
                        TRUE,  // Manual Reset
                        FALSE,  // Initial State
                        cBuffer);
	if(!SemHand){
		SetObjectStatus(ErrSEM_CREATE_FAILED);
	}
}

//-------------------------------------------------------------------------
//
ApcSemaphore::ApcSemaphore(TCHAR * cBuffer)	   //named shared event
{
    SemHand=CreateEvent((LPSECURITY_ATTRIBUTES)NULL,
                        FALSE,  // Manual Reset
                        FALSE,  // Initial State
                        cBuffer);
	if(!SemHand){
		SetObjectStatus(ErrSEM_CREATE_FAILED);
	}
}

//-------------------------------------------------------------------------
//
ApcSemaphore::~ApcSemaphore()
{
   CloseHandle(SemHand);
}


//-------------------------------------------------------------------------
//
INT ApcSemaphore::Post(VOID)
{
    INT err = ErrNO_ERROR;
	if(!SetEvent(SemHand))
      err= ErrSEM_GENERAL_ERROR;

    return err;
}

//-------------------------------------------------------------------------
//
INT ApcSemaphore::Clear(VOID)
{
    INT err = ErrNO_ERROR;
    if(!ResetEvent(SemHand))
      err = ErrSEM_GENERAL_ERROR;
    
    return err;
}




//-------------------------------------------------------------------------
//
INT ApcSemaphore::IsPosted(VOID)
{
    // Could also call TimedWait(0)
    //
    INT ret = ErrSEM_BLOCK_NG;
    DWORD waitresult = WaitForSingleObject(SemHand,(DWORD)0);
    if(waitresult == WAIT_TIMEOUT)
      ret = ErrNO_ERROR;
    return ret;
}


//-------------------------------------------------------------------------
// Wait for sem to be posted
//
// ulTimeout: 0 - Don't wait at all
//	     <0 - Wait forever (same as Wait())
//	     >0 - Wait for ulTimeout milliseconds
//
INT ApcSemaphore::TimedWait(LONG ulTimeout) 
{
    INT err;
    DWORD time_out = (ulTimeout < 0) ? INFINITE : ulTimeout;

    DWORD waitresult=WaitForSingleObject(SemHand,time_out);
    if(waitresult ==  0){
        err = ErrNO_ERROR;
    }
    else if (waitresult == WAIT_TIMEOUT)  {
        err = ErrSEM_TIMED_OUT;
    }
    else  {
        err = ErrSEM_GENERAL_ERROR;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apcobj.h ===
/*
*
* NOTES:
*
* REVISIONS:
*  pcy13Jan93: Implemented an object status member to return constructor errors.
*  pcy27Jan93: HashValue is no longer const
*  cad09Jul93: Added memory leak probes
*  pcy14Sep93: Removed HashValue, and got rid of pure virtuals to help size
*  pcy18Sep93: Implemented Equals
*  ash08Aug96: Added new handler
*  poc17Sep96: Modified so that the new handler code will not be included on Unix.
*
*/

#ifndef __APCOBJ_H
#define __APCOBJ_H

#include "_defs.h"

#include "apc.h"

#include "isa.h"
#include "err.h"

extern "C" {
#include <string.h>
}


_CLASSDEF(Obj)

#ifdef MCHK
#define MCHKINIT strcpy(memCheck, "APCID"); strncat(memCheck, IsA(), 25)
#else
#define MCHKINIT
#endif


class Obj {
   
protected:
   
#ifdef MCHK
   CHAR memCheck[38];
#endif
   
   Obj();
   INT theObjectStatus;
   
public:
#ifdef APCDEBUG 
   INT theDebugFlag;
#endif
   
   virtual ~Obj();
   
   virtual INT    IsA() const;
   virtual INT    Equal( RObj anObj) const;
   
   INT   operator == ( RObj cmp) const { return Equal(cmp); };
   INT   operator != ( RObj cmp) const { return !Equal(cmp); };
   INT   GetObjectStatus() { return theObjectStatus; };
   VOID  SetObjectStatus(INT aStatus) { theObjectStatus = aStatus; };
   
   
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apcups.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserverd
*
* Description:
*   DLL entry points for the APC UpsMiniDriver interface
*
*
* Revision History:
*   mholly  14Apr1999  Created
*
*/

#ifndef _INC_APCUPS_H_
#define _INC_APCUPS_H_


// The following ifdef block is the standard way of creating macros which
// make exporting from a DLL simpler. All files within this DLL are compiled
// with the APCUPS_EXPORTS symbol defined on the command line. this symbol
// should not be defined on any project that uses this DLL. This way any
// other project whose source files include this file see APCUPS_API
// functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.

#ifdef __cplusplus
extern "C" {
#endif

#ifdef APCUPS_EXPORTS
#define APCUPS_API
#else
#define APCUPS_API __declspec(dllimport)
#endif

//
// UPS MiniDriver Interface
//
APCUPS_API DWORD WINAPI UPSInit();
APCUPS_API void  WINAPI UPSStop(void);
APCUPS_API void  WINAPI UPSWaitForStateChange(DWORD, DWORD);
APCUPS_API DWORD WINAPI UPSGetState(void);
APCUPS_API void  WINAPI UPSCancelWait(void);
APCUPS_API void  WINAPI UPSTurnOff(DWORD);

//
// values returned from UPSGetState
//
#define UPS_ONLINE 1
#define UPS_ONBATTERY 2
#define UPS_LOWBATTERY 4
#define UPS_NOCOMM 8


//
// error values returned from UPSInit
//
#define UPS_INITUNKNOWNERROR    0
#define UPS_INITOK              1
#define UPS_INITNOSUCHDRIVER    2
#define UPS_INITBADINTERFACE    3
#define UPS_INITREGISTRYERROR   4
#define UPS_INITCOMMOPENERROR   5
#define UPS_INITCOMMSETUPERROR  6

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\backups.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  rct08Dec92 fixed up some things ... finished implementation
 *  pcy28Dec92: Parent is now an UpdateObj.  Not a DeviceController
 *  ane11Jan93: Added theTimerId
 *  pcy15Jan93: Added upsstate.h
 *  pcy28Jan94: Handle run time timer different (now in Shutdowner)
 *  ajr02Aug94: moved BACKUPS_FIRMWARE_REV definition to backups.h
 *  djs16Mar95: changed upsstate.h to sysstate.h
 */

#ifndef __BACKUPS_H
#define __BACKUPS_H

//
// Defines
//

_CLASSDEF(BackUps)
_CLASSDEF(Sensor)

extern "C"  {
#include <time.h>
}

#include "ups.h"
#include "sysstate.h"


class BackUps : public Ups {

protected:

   INT      theLastTransferCause;

   time_t   theRunTimeExpiration;
   time_t   theOnBatteryTimer;

   PSensor  theBatteryConditionSensor;
   PSensor  theUtilityLineConditionSensor;
   PSensor  theTurnOffUpsOnBatterySensor;

   virtual VOID HandleLineConditionEvent(PEvent aEvent);
   virtual VOID HandleBatteryConditionEvent(PEvent aEvent);

   INT   isOnLine()           { return !IS_STATE(UPS_STATE_ON_BATTERY); };
   INT   isOnBattery()        { return IS_STATE(UPS_STATE_ON_BATTERY); };
   INT   isBatteryBad()       { return IS_STATE(UPS_STATE_BATTERY_BAD); };
   INT   isLowBattery()       { return IS_STATE(UPS_STATE_BATTERY_NEEDED); };
   INT   isInSmartBoost()     { return IS_STATE(UPS_STATE_ON_BOOST); };
   INT   isInDeepDischarge()  { return IS_STATE(UPS_STATE_IN_CALIBRATION); };
   INT   isInLightsTest()     { return IS_STATE(UPS_STATE_IN_LIGHTS_TEST); };
   INT   isLineFailPending()  { return IS_STATE(UPS_STATE_LINE_FAIL_PENDING); };
   VOID  setLineGood();
   VOID  setLineBad();
   VOID  setBatteryGood();
   VOID  setBatteryBad(PEvent aEvent);
   VOID  setLineFailPending();

   virtual VOID registerForEvents();

public:

   BackUps(PUpdateObj aDeviceController, PCommController aCommController);
   virtual ~BackUps();

   virtual INT  IsA() const { return BACKUPS; };
   virtual INT    Get(INT code, PCHAR value);
   virtual INT    Set(INT code, const PCHAR value);
   virtual INT    Update(PEvent event);
};

#define BACKUPS_FIRMWARE_REV    "Q"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\backups.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  rct11Dec92	compiled w/o the TurnOffUpsOnBatterySensor
 *  SjA15Dec92  Fixed macro problems and now registers for events.
 *  jod16Dec92: Moved cdefine.h to top of file.
 *  pcy27Dec92: Parent is now an UpdateObj, not a DeviceController
 *  pcy27Dec92: Sensors no longer initialized explicitly.  Done during construct
 *  ane11Jan93: Added generation of a RUN_TIME_EXPIRED event
 *  pcy02Feb93: Scoped declaration of run_time_remaining so compilers dont error
 *  ane03Feb93: Added destructors, commented out one of the timers being set
 *  pcy1&Feb93: Set value to RUN_TIME_EXPIRED for RUN_TIME_EXPIRED event
 *  ajr22Feb93: moved process.h into C_OS2 cond
 *  cad04Aug93: Changed shutdown handling for status
 *  cad14Sep93: looking at shutdown_status to set shutdown flag
 *  pcy20Sep93: Reset theRunTimeRemaining when setting line good
 *  cad27Sep93: Added enabling battery run time
 *  cad02Nov93: name fix
 *  cad15Nov93: Changed how comm lost handled
 *  cad10Dec93: firmware rev get added
 *  pcy28Jan94: Handle run time timer different (now in Shutdowner)
 *  ajr08Feb94: Fixed TIMED_RUN_TIME_REMAINING case
 *  cad08Jan94: removed run time enabled stuff (assumed by flex shutdown)
 *  pcy04Mar94: Make sure ups gets shutdown events
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  rct03Jun94: Added functionality for tracking xfer cause and time on battery
 *  jps20jul94: itoa -> ltoa (theUpsState); added some (time_t *)s
 *  ajr02Aug94: Lets set the line to bad if we are in bad bat state
 *  ajr02Aug94: moved BACKUPS_FIRMWARE_REV definition to backups.h
 *  ajr14Feb96: SINIX Merge
 *  djs16Jul96: Added IS_BACKUPS
 *  mds29Dec97: Enabled the TurnOffUpsOnBatterySensor to correctly shutdown
 *				UPS when using a Share-Ups in confirmed mode.
 *  tjg12Jan98: Undid the changes to TurnOffUpsOnBatterySensor
 *  clk09Sep98: Reworked LineBad condition in HandleBadBatteryCond to always
 *              setBatteryBad (fixes SIR 6019).
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"
#include "_defs.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#include <netcons.h>
#include <process.h>
#endif
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdio.h>
#include <ctype.h>
}

#include "err.h"
#include "backups.h"
#include "simpsens.h"
#include "event.h"
#include "codes.h"
#include "dispatch.h"
#include "cfgcodes.h"
#include "cfgmgr.h"
#include "timerman.h"
#include "utils.h"        /* ajr 02/22/93 */

_CLASSDEF(DeviceController)
_CLASSDEF(UnsupportedSensor)


//-------------------------------------------------------------------

BackUps :: BackUps(PUpdateObj aDeviceController,
      PCommController aCommController)
   :  Ups(aDeviceController, aCommController), 
      theRunTimeExpiration(0),
      theOnBatteryTimer(0L),
      theLastTransferCause(NO_TRANSFERS)
{
	theUtilityLineConditionSensor = 
	    new UtilityLineConditionSensor(this, aCommController);
	theBatteryConditionSensor = 
	    new BatteryConditionSensor(this, aCommController);
	theTurnOffUpsOnBatterySensor = 
	    new TurnOffUpsOnBatterySensor(this, aCommController);
}

BackUps :: ~BackUps()
{
   delete theUtilityLineConditionSensor;
   theUtilityLineConditionSensor = NULL;
   delete theBatteryConditionSensor;
   theBatteryConditionSensor = NULL;
   delete theTurnOffUpsOnBatterySensor;
   theTurnOffUpsOnBatterySensor = NULL;
}


//-------------------------------------------------------------------

INT BackUps :: Update(PEvent anEvent) 
{
    INT err = ErrNO_ERROR;
    
    switch(anEvent->GetCode()) {
        
      case UTILITY_LINE_CONDITION:
        HandleLineConditionEvent(anEvent);
        break;
        
      case BATTERY_CONDITION:
        HandleBatteryConditionEvent(anEvent);
        break;

      case ADMIN_SHUTDOWN:
        SET_BIT(theUpsState, SHUTDOWN_IN_PROGRESS_BIT);
        break;

      case CANCEL_SHUTDOWN:
        CLEAR_BIT(theUpsState, SHUTDOWN_IN_PROGRESS_BIT);
        break;
        
      default:
        UpdateObj::Update(anEvent);
        break;
    }
    return err;
}

//-------------------------------------------------------------------

INT BackUps :: Get(INT code, PCHAR aValue)
{
    INT err = ErrNO_ERROR;

    // This is a quick and dirty implementation.  We should probably
    // look for the code in Device::theSensorList and then send the
    // get to the sensor that matches the code.  For now this will do.
    // We may have to worry about get codes that dont have sensors if
    // we use the above approach.  Maybe everything should have a sensor.
    
    CHAR state[10];
    
    switch(code) {
      case FIRMWARE_REV:
        strcpy(aValue, BACKUPS_FIRMWARE_REV);
        break;
        
      case BATTERY_CONDITION:
        err = theBatteryConditionSensor->Get(code, aValue);
        break;
        
      case UTILITY_LINE_CONDITION:
        err = theUtilityLineConditionSensor->Get(code, aValue);
        break;
        
      case UPS_STATE:
        strcpy(aValue, _ltoa(theUpsState,state,10));
        break;
        
      case UPS_MODEL :
        strcpy(aValue, "Back-UPS");
        break;
        
      case TIMED_RUN_TIME_REMAINING:
	      err=ErrUNSUPPORTED;
         break;
        
      case MAX_BATTERY_RUN_TIME:
        _theConfigManager->Get(CFG_UPS_MAX_BATTERY_RUN_TIME, aValue);
        break;
        
      case TIME_ON_BATTERY:
         if (theOnBatteryTimer == 0)
            {
            strcpy(aValue, "0");
            }
         else
            {
            _ltoa((LONG)((time((time_t *)NULL) - theOnBatteryTimer)), aValue, 10);
            }
         break;

      case IS_BACKUPS:
         strcpy(aValue,"Yes");
         break;

      default:
        err = ErrINVALID_CODE;
        break;
    }
    
    return err;
}

//-------------------------------------------------------------------

INT BackUps :: Set(INT code, PCHAR value) 
{
    INT err = ErrNO_ERROR;
	
	switch(code)
        {
          case TURN_OFF_UPS_ON_BATTERY:
             theTurnOffUpsOnBatterySensor->Set(code, value);
             break;
          case MAX_BATTERY_RUN_TIME:
            //_theConfigManager->Set(CFG_UPS_MAX_BATTERY_RUN_TIME, value);
            break;
          default:
            err = ErrUNSUPPORTED;
            break;
        }
    return err;
}

//-------------------------------------------------------------------

VOID BackUps :: HandleLineConditionEvent(PEvent anEvent) 
{
   switch(atoi(anEvent->GetValue()))
      {
      case LINE_GOOD:
         theLastTransferCause = NO_TRANSFERS;
         theOnBatteryTimer = 0;
         theRunTimeExpiration = 0;
         setLineGood();
         break;
            
      case LINE_BAD:
         theLastTransferCause = BLACKOUT;
         theOnBatteryTimer = time((time_t *)NULL);
         theRunTimeExpiration = 1;
         setLineBad();
         break;
      }
    UpdateObj::Update(anEvent);
}


//-------------------------------------------------------------------

VOID BackUps :: HandleBatteryConditionEvent(PEvent anEvent) 
{
   INT send_update = TRUE;
    
   switch(atoi(anEvent->GetValue()))
      {
      case BATTERY_GOOD:
         if(!(IS_STATE(UPS_STATE_BATTERY_BAD)))
            {
            send_update = FALSE;
            }
         setBatteryGood();
         break;
            
      case BATTERY_BAD:
          // When we get a bad battery, we always want to call setBadBattery
          // because it performs the test for on-line/on-battery.  There's
          // no need to perform the test here.
          setBatteryBad(anEvent);
         break;
      }

   if(send_update)
      {
      UpdateObj::Update(anEvent);
      }
}

//-------------------------------------------------------------------

VOID BackUps :: setLineGood()
{
    CLEAR_BIT(theUpsState, LINE_STATUS_BIT);
    CLEAR_BIT(theUpsState, LINE_FAIL_PENDING_BIT);   
    
    theRunTimeExpiration = FALSE;
}

//-------------------------------------------------------------------

VOID BackUps :: setLineBad()
{
   CLEAR_BIT(theUpsState, LINE_FAIL_PENDING_BIT);
   SET_BIT(theUpsState, LINE_STATUS_BIT);

   theRunTimeExpiration = TRUE;
   
   if (isBatteryBad())
      {
      Event batteryEvent(BATTERY_CONDITION, LOW_BATTERY);
      UpdateObj::Update(&batteryEvent);
      }
}

//-------------------------------------------------------------------

VOID BackUps :: setBatteryGood()
{
    CLEAR_BIT(theUpsState, BATTERY_STATUS_BIT);
}

//-------------------------------------------------------------------

VOID BackUps :: setBatteryBad(PEvent anEvent)
{
    SET_BIT(theUpsState, BATTERY_STATUS_BIT);
    
    if (isOnBattery()) {
        anEvent->SetValue(LOW_BATTERY);
    } else {
        anEvent->SetValue(BATTERY_DISCHARGED);
    }
    
}

//-------------------------------------------------------------------

VOID BackUps :: setLineFailPending()
{
    SET_BIT(theUpsState, LINE_FAIL_PENDING_BIT);
}

//-------------------------------------------------------------------

VOID BackUps :: registerForEvents()
{
    theUtilityLineConditionSensor->RegisterEvent(UTILITY_LINE_CONDITION, this);
    theBatteryConditionSensor->RegisterEvent(BATTERY_CONDITION, this); 
    theDeviceController->RegisterEvent(ADMIN_SHUTDOWN, this);
    theDeviceController->RegisterEvent(CANCEL_SHUTDOWN, this);
    theDeviceController->RegisterEvent(SHUTDOWN, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\apcups.cxx ===
/* Copyright 1999 American Power Conversion, All Rights Reserverd
* 
* Description:
*   DLL entry points for the APC UpsMiniDriver interface
*   Creates a single instance of an ApcMiniDriver class
*   and forwards all requests to this object
*
* Revision History:
*   mholly  14Apr1999  Created
*
*/


#include "cdefine.h"

#include <windows.h>



#include "apcups.h"
#include "apcdrvr.h"

//
// _theDriver
//
//  Each process that attaches to this DLL will
//  get its own copy of _theDriver.  _theDriver
//  is an instance of the class ApcMiniDriver.
//  The ApcMiniDriver class provides support for
//  APC "smart" signalling UPS systems
//
ApcMiniDriver _theDriver;



/**
* DllMain
*
* Description:
*   This method is called when the DLL is loaded
*   We do not make use of this method
*
* Parameters:   
*   not used
* Returns:
*   TRUE
*
*/
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


/**
* UPSInit
*
* Description:
*   Must be the first method called in the interface -
*   forwards call to ApcMiniDriver::UPSInit
*
* Parameters:
*   aCommPort:  comm port that the UPS is connected
*
* Returns:
*   UPS_INITOK: successful initialization
*   UPS_INITUNKNOWNERROR: failed initialization
*   
*/
DWORD UPSInit()
{
    return _theDriver.UPSInit();
}


/**
* UPSStop
*
* Description:
*   stops monitoring of the UPS - the only valid
*   interface after a call to UPSStop is UPSInit
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSStop(void)
{
    _theDriver.UPSStop();
}


/**
* UPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*   
*/
void UPSWaitForStateChange(DWORD aState, DWORD anInterval)
{
    _theDriver.UPSWaitForStateChange(aState, anInterval);
}


/**
* UPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD UPSGetState(void)
{
    return _theDriver.UPSGetState();
}


/**
* UPSCancelWait
*
* Description:
*   interrupts pending calls to UPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSCancelWait(void)
{
    _theDriver.UPSCancelWait();
}


/**
* UPSTurnOff
*
* Description:
*   Attempts to turn off the outlets on the UPS
*   after the specified delay.  This method querries the 
*   UPS for the allowed shutdown delays and sets the
*   delay to one of the following:
*     1. aTurnOffDelay if it exactly matches one of the allowed values
*     2. the next highest value after aTurnOffDelay, if one exists
*     3. the highest allowed value, if aTurnOffDelay is larger than all of
*        the allowed values.
*   If no allowed values are returned, the Shutdown Delay will not be set.
*   Next the UPS is instructed to sleep until power is restored.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void UPSTurnOff(DWORD aTurnOffDelay)
{
    _theDriver.UPSTurnOff(aTurnOffDelay);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\attrib.h ===
/*
*
* REFERENCES:
*
* NOTES:
*
* REVISIONS:
*  sja05Nov92: Added a new constructor which allows the use of #defines's 
*              for the value parameter
*  ane11Nov92: Removed !=, == members.  They're in object now.
*
*  ker20Nov92: Added SetValue function
*  pcy26Nov92: object.h changed to apcobj.h
*  pcy27Jan93: HashValue is no longer const
*  ane08Feb93: Added copy constructor
*  cad28Sep93: Made sure destructor(s) virtual
*  ntf03Jan96: added printMeOut and operator<< functions for Attribute class
*/
#ifndef __ATTRIB_H
#define __ATTRIB_H

#if !defined( __APCOBJ_H )
#include "apcobj.h"
#endif

_CLASSDEF(Attribute)

#ifdef APCDEBUG
class ostream;
#endif

class Attribute : public Obj {
   
private:
   PCHAR theValue;
   INT   theAttributeCode;
   
protected:
#ifdef APCDEBUG
   virtual ostream& printMeOut(ostream& os);
#endif
   
public:
   
#ifdef APCDEBUG
   friend ostream& operator<< (ostream& os, Attribute &);
#endif
   
   Attribute(INT, PCHAR);
   Attribute(INT, LONG);
   Attribute(const Attribute &anAttr);
   virtual ~Attribute();
   INT                  GetCode() const { return theAttributeCode; };
   const PCHAR          GetValue();
   VOID SetCode(INT aCode);
   INT                  SetValue(const PCHAR);
   INT                  SetValue(LONG);        
   virtual INT          Equal( RObj ) const;
   virtual INT        IsA() const { return ATTRIBUTE; };
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\badbatts.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy27Aug93: Get rid of Update()
 *  cad28Sep93: Made sure destructor(s) virtual
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  cgm12Apr96: Add destructor with unregister
 *  djs02Jun97: Changed from sensor to a statesensor
 */
#ifndef BADBATTS_H
#define BADBATTS_H

#include "stsensor.h"

_CLASSDEF(NumberBadBatteriesSensor)
 
class NumberBadBatteriesSensor : public StateSensor {
   
public:
   NumberBadBatteriesSensor(PDevice aParent, PCommController aCommController = NULL);
   virtual ~NumberBadBatteriesSensor();
   virtual INT IsA() const { return NUMBERBADBATTERIESSENSOR; };
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\badbatts.cxx ===
/*
 *
 * REVISIONS:
 *  cgm12Apr96: Add destructor with unregister
 *  djs02Jun97: Changed from sensor to a statesensor
 *
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
}
#include "badbatts.h"
#include "comctrl.h"

NumberBadBatteriesSensor :: NumberBadBatteriesSensor(PDevice aParent, PCommController aCommController)
			: StateSensor(aParent, aCommController, BAD_BATTERY_PACKS)
{
   DeepGet();
   theCommController->RegisterEvent(theSensorCode, this);
}

NumberBadBatteriesSensor :: ~NumberBadBatteriesSensor()
{
   theCommController->UnregisterEvent(theSensorCode, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\attrib.cxx ===
/*
*
* REFERENCES:
*
* NOTES:
*
* REVISIONS:
*  sja11Nov92: Added a new constructor which allows the use of #defines's 
*              for the value parameter
*  ker20Nov92: Added extern "C" to string.h, removed redefinitions, added
*              SetValue function.
*  pcy02Dec92: Added #include err.h.  We need it.
*  ane16Dec92: Added cdefine.h
*  ane08Feb93: Added copy constructor
*  cad07Oct93: Plugging Memory Leaks
*  cad27Dec93: include file madness
*  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
*  mwh01Jun94: port for INTERACTIVE
*  mwh07Jun94: port for NCR
*  daf17May95: port for ALPHA/OS
*  djs02Oct95: port for AIX 4.1
*  ntf03Jan96: added printMeOut and operator<< functions for Attribute class
*
*  v-stebe  29Jul2000   changed mem. alloc from new to on the heap (bug #46327)
*/

#ifdef APCDEBUG
#include <iostream.h>
#endif

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#include <string.h>
#if  (C_OS & (C_INTERACTIVE | C_ALPHAOSF)) || ((C_OS & C_AIX) && (C_AIX_VERSION & C_AIX4))
#  include <stdlib.h>
#else
#  include <malloc.h>
#endif
#include <stdio.h>
}
#include "attrib.h"
#include "isa.h"
#include "err.h"

#if (C_OS & C_NCR)
#  include "incfix.h"
#endif


//-------------------------------------------------------------------

Attribute::Attribute(INT aCode, PCHAR aValue)
: theAttributeCode(aCode), theValue((CHAR*)NULL)
{
   if (aValue)
      theValue = _strdup(aValue);
}

Attribute::Attribute(INT aCode, LONG aValue)
: theAttributeCode(aCode)//, theValue(_strdup(aValue))
{
   CHAR strvalue[32];
   sprintf(strvalue, "%ld", aValue);
   theValue = _strdup(strvalue);
}

Attribute::Attribute(const Attribute &anAttr)
: theAttributeCode (anAttr.theAttributeCode)
{
   if (anAttr.theValue)
      theValue = _strdup (anAttr.theValue);
   else
      theValue = (PCHAR)NULL;
}

INT Attribute::SetValue(LONG aValue)
{
   CHAR the_temp_string[32];
   sprintf(the_temp_string, "%ld", aValue);
   return SetValue(the_temp_string);
}

INT Attribute::SetValue(const PCHAR aValue)
{
   if (!aValue)
      return ErrNO_VALUE;
   if (theValue)
   {
      free(theValue);   
      theValue = (CHAR*)NULL;
   }
   theValue=_strdup(aValue);
   return ErrNO_ERROR;
}

const PCHAR Attribute::GetValue()
{                               
   return theValue;
} 

VOID Attribute::SetCode(INT aCode) {
   theAttributeCode = aCode;
}



//-------------------------------------------------------------------

Attribute::~Attribute()
{
   if (theValue) {
      free(theValue);
   }
}

//-------------------------------------------------------------------

INT Attribute::Equal(RObj anObject) const
{
   if (anObject.IsA() != IsA())
      return FALSE;
   
   if ( ((RAttribute) anObject).GetCode() == theAttributeCode )
      //   &&         ( !strcmp(theValue, ((RAttribute) anObject).GetValue()) ))
      return TRUE;
   
   return FALSE;
}


#ifdef APCDEBUG
ostream & operator<< (ostream& os, Attribute & obj) {
   return(obj.printMeOut(os));
}

ostream& Attribute::printMeOut(ostream& os)
{
   os << theValue << "(" << theAttributeCode << ")" << endl;
   return os;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\batcalt.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker03DEC92   Initial OS/2 Revision
 *  jod05Apr93: Added changes for Deep Discharge
 *  cad07Oct93: Plugging Memory Leaks
 *  cgm12Apr96: Destructor with unregister
 *  clk24Jun98: Added thePendingEventTimerID & thePendingEvent
 */
 
#ifndef __BATCALT_H
#define __BATCALT_H

#include "stsensor.h"
#include "event.h"

_CLASSDEF(BatteryCalibrationTestSensor)

// enum TestResult { TEST_CANCELLED, TEST_COMPLETED};
#define CANCELLED_LINEFAIL  2

			  
class BatteryCalibrationTestSensor : public StateSensor {

protected:
    INT   theCalibrationCondition;
    LONG           thePendingEventTimerId;
    PEvent         thePendingEvent;
        
public:
	BatteryCalibrationTestSensor( PDevice aParent, PCommController aCommController);
	virtual ~BatteryCalibrationTestSensor();
//overidden interfaces

	virtual INT IsA() const { return BATTERYCALIBRATIONTESTSENSOR; };
        virtual INT Validate(INT, const PCHAR);
        virtual INT Update(PEvent);
        virtual INT Set(const PCHAR);
        INT         GetCalibrationCondition() {return theCalibrationCondition;};
        VOID        SetCalibrationCondition(INT cond) {theCalibrationCondition = cond;};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\batpacks.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *
 *  cad28Sep93: Made sure destructor(s) virtual
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  djs29May97: Added update method for Symmetra events
 */

#ifndef BATPACKS_H
#define BATPACKS_H

#include "eeprom.h"
#include "firmrevs.h"
#include "sensor.h"

_CLASSDEF(NumberBatteryPacksSensor)

class NumberBatteryPacksSensor : public EepromSensor {
protected:
   PFirmwareRevSensor theFirmwareRev;
   virtual INT storeValue(const PCHAR aValue);

public:
   NumberBatteryPacksSensor(PDevice aParent, PCommController aCommController=NULL, PFirmwareRevSensor aFirmwareRev=NULL);
   virtual ~NumberBatteryPacksSensor();
   virtual INT IsA() const { return NUMBERBATTERYPACKSSENSOR; };
   virtual INT Set(INT aCode, const PCHAR aValue);
   virtual INT Set(const PCHAR aValue);
   virtual INT Get(INT aCode, PCHAR aValue);
   virtual INT Update(PEvent anEvent);



private:
   INT theNumber_Of_Internal_Packs;
   INT theSensorIsInitialized;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\battcond.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */
#ifndef BATTCOND_H
#define BATTCOND_H

#include "stsensor.h"

_CLASSDEF(BatteryConditionSensor)

class BatteryConditionSensor : public StateSensor {

public:
   BatteryConditionSensor(PDevice aParent, PCommController aCommController=NULL);
   virtual ~BatteryConditionSensor();
   virtual INT IsA() const { return BATTERYCONDITIONSENSOR; };
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\batcalt.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker03DEC92  Initial OS/2 Revision 
 *  pcy14Dec92: Changed READ_ONLY to AREAD_ONLY
 *  jod05Apr93: Added changes for Deep Discharge
 *  cad19Jul93: Battery Calibration fixed up
 *  pcy10Sep93: Fixed to cancel on line fail and other rework
 *  cad28Sep93: Not generating cancels on double sets
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  clk24Jun98: Added Pending Event to Update/Set
 *  clk29Jul98: Initialized thePendingEvent to NULL (it was causing
 *              the server to crash when shutting down server)
 *
 *  v-stebe  29Jul2000   Fixed PREfix errors (bugs #46370, #46371)
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "batcalt.h"
#include "cfgmgr.h"
#include "utils.h"
#include "dispatch.h"
#include "comctrl.h"
#include "timerman.h"
//Constructor

BatteryCalibrationTestSensor :: BatteryCalibrationTestSensor(PDevice aParent, 
      		         PCommController 	aCommController)
:	StateSensor(aParent,aCommController, BATTERY_CALIBRATION_TEST,AREAD_WRITE),
    theCalibrationCondition(0), thePendingEventTimerId(0), thePendingEvent(NULL)
{
    storeState(NO_BATTERY_CALIBRATION_IN_PROGRESS);

    theCommController->RegisterEvent(BATTERY_CALIBRATION_CONDITION, this);
}

BatteryCalibrationTestSensor :: ~BatteryCalibrationTestSensor()
{

    theCommController->UnregisterEvent(BATTERY_CALIBRATION_CONDITION, this);

        // if there's a pending event, then we want to cancel it
    if (thePendingEventTimerId) {
        _theTimerManager->CancelTimer(thePendingEventTimerId);
        thePendingEventTimerId = 0;
    }
    
    if (thePendingEvent)
    {
        delete thePendingEvent;
        thePendingEvent = NULL;
    }
}

INT BatteryCalibrationTestSensor::Validate(INT aCode, const PCHAR aValue)
{
    INT retVal = ErrINVALID_VALUE;	// easy default
    INT the_new_value=atoi(aValue);
    INT the_curr_value = atoi(theValue);

    if (aCode == theSensorCode) {
	if ((the_curr_value == NO_BATTERY_CALIBRATION_IN_PROGRESS) &&
            (the_new_value == BATTERY_CALIBRATION_IN_PROGRESS))  {
		retVal = ErrNO_ERROR;
	}
	else {
            if((the_curr_value == BATTERY_CALIBRATION_IN_PROGRESS) &&
		(the_new_value == NO_BATTERY_CALIBRATION_IN_PROGRESS)) {
		retVal = ErrNO_ERROR;
	    }
	}
    }
    else if (aCode == BATTERY_CALIBRATION_CONDITION) {
        retVal = StateSensor::Validate(aCode, aValue);
    }
    else {
	retVal = ErrINVALID_CODE;         
    }
    return retVal;
}


INT BatteryCalibrationTestSensor::Set(const PCHAR aValue)
{
   INT action = atoi(aValue);
   INT the_current_value = atoi(theValue);
   CHAR tmpstring[11];
   PEvent cal_event = (PEvent)NULL;
   CHAR new_val[16];
   INT err = ErrNO_ERROR;

   if (action == PERFORM_BATTERY_CALIBRATION) {
       sprintf(new_val, "%d", BATTERY_CALIBRATION_IN_PROGRESS);
   }
   else if (action == CANCEL_BATTERY_CALIBRATION) {
       sprintf(new_val, "%d", NO_BATTERY_CALIBRATION_IN_PROGRESS);
   }

   err = Sensor::Set(new_val);

   switch(action)  {
     case PERFORM_BATTERY_CALIBRATION:
       if(err == ErrNO_ERROR)  {
          cal_event = new Event(BATTERY_CALIBRATION_CONDITION, 
                                BATTERY_CALIBRATION_IN_PROGRESS);
       }
       else if ((err != ErrNO_STATE_CHANGE) && (err != ErrINVALID_VALUE)) {
          cal_event = new Event(BATTERY_CALIBRATION_CONDITION, 
                                BATTERY_CALIBRATION_CANCELLED);
          if (cal_event != NULL) {
            cal_event->AppendAttribute(FAILURE_CAUSE, (float) err);
          }
          else {
            err = ErrMEMORY;
          }
       }          
       break;

     case CANCEL_BATTERY_CALIBRATION:
          if (!err)
          {
              // Create a pending event
              Event pendingEvent(PENDING_EVENT, 0L);
              thePendingEventTimerId = _theTimerManager->SetTheTimer((ULONG)5,
                  &pendingEvent, this);

             cal_event = new Event(BATTERY_CALIBRATION_CONDITION, 
                                   BATTERY_CALIBRATION_CANCELLED);
             if (cal_event != NULL) {
               if (theCalibrationCondition == CANCELLED_LINEFAIL)
                   cal_event->AppendAttribute(FAILURE_CAUSE, 
                                              _itoa(LINE_BAD,tmpstring,10));
               theCalibrationCondition = FALSE;
             }
             else {
               err = ErrMEMORY;
             }
          }
          break;
   }

   if (cal_event)
   {
      UpdateObj::Update(cal_event);
      delete cal_event;
      cal_event = NULL;
   }

   return err;
}


INT BatteryCalibrationTestSensor::Update(PEvent anEvent)
{
    INT err = ErrNO_ERROR;
    INT the_temp_code=anEvent->GetCode();
    PCHAR the_temp_value=anEvent->GetValue();

    // Do Sets sent by time delay (scheduled)
    //
    if (the_temp_code == BATTERY_CALIBRATION_TEST) {
	err = Set(the_temp_value);
    }
    
    // We want to check to see if the event is the 
    // pending event set up in the Set.  
    // This fix was put in to stop multiple events.
    if (thePendingEventTimerId) {

        if (anEvent->GetCode() == PENDING_EVENT) {
            thePendingEventTimerId = 0;
        }
    }
    else {
        StateSensor::Update(anEvent);
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\battcond.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  ker04DEC92: Initial fill in of Member Functions
 *  SjA10Dec92: Registers with ComController for BATTERY_CONDITION events in constructor.
 *  SjA10Dec92: Now has an Update Method. Useful for debugging
 *  SjA11Dec92: Validate correctly returns Err_NOERROR rather than VALID;
 *  pcy16Feb93: Made to work more like a state sensor
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "err.h"
#include "battcond.h"
#include "comctrl.h"

BatteryConditionSensor :: BatteryConditionSensor(PDevice aParent, PCommController aCommController)
			  : StateSensor(aParent, aCommController, BATTERY_CONDITION)
{
    storeState(BATTERY_GOOD);
    theCommController->RegisterEvent(BATTERY_CONDITION, this);
//	theState = BATTERY_GOOD;
}



BatteryConditionSensor :: ~BatteryConditionSensor()
{
    if (theCommController)
       theCommController->UnregisterEvent(BATTERY_CONDITION, this);
                                                 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\battcaps.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  cgm12Apr96: Destructor with unregister
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "battcaps.h"
#include "comctrl.h"

BatteryCapacitySensor :: BatteryCapacitySensor(PDevice aParent, PCommController aCommController)
			: ThresholdSensor(aParent, aCommController, BATTERY_CAPACITY)
{
    DeepGet();
    theCommController->RegisterEvent(BATTERY_CAPACITY, this);
}

BatteryCapacitySensor :: ~BatteryCapacitySensor()
{
    theCommController->UnregisterEvent(BATTERY_CAPACITY, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\batpacks.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
 *  djs22Feb96: Added internal, external, and total packs
 *  cgm12Apr96: Add destructor with unregister
 *  poc28Sep96: Fixed SIR 4363.
 *  djs29May97: Added update method for Symmetra events
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
}
#include "batpacks.h"
#include "comctrl.h"
#include "sensor.h"
#include "event.h"
#include "dispatch.h"
#include "utils.h"



NumberBatteryPacksSensor :: NumberBatteryPacksSensor(PDevice aParent, 
       PCommController aCommController, PFirmwareRevSensor aFirmwareRev)
     :EepromSensor(aParent, aCommController, EXTERNAL_BATTERY_PACKS)
{

      theFirmwareRev = aFirmwareRev;
      CHAR external_packs[32];
      
      // theValue of this sensor is the number of external battery packs.  
      // Internal battery packs will be stored locally by this sensor.
      
      theFirmwareRev->Get(EXTERNAL_BATTERY_PACKS,external_packs);
      if (_strcmpi(external_packs,"YES") == 0)
      {
	theCommController->RegisterEvent(theSensorCode, this);
      }

      CHAR External_Battery_Packs_Changeable[32];
      theFirmwareRev->Get(EXTERNAL_PACKS_CHANGEABLE,External_Battery_Packs_Changeable);
      if (_strcmpi(External_Battery_Packs_Changeable, "Yes") ==0) {
        readOnly = AREAD_WRITE;
        setInitialValue();
      }

     CHAR Internal_Packs[32];
     theFirmwareRev->Get(INTERNAL_BATTERY_PACKS,Internal_Packs);
     theNumber_Of_Internal_Packs = atoi(Internal_Packs);

     // Disable validation checking until the sensor value
     // is initialized

      theSensorIsInitialized = 0;

      if (!theFirmwareRev->IsBackUpsPro()) {
          DeepGet();
      }
}


INT NumberBatteryPacksSensor::Get(INT aCode, PCHAR aValue)
{
      INT err = ErrNO_ERROR;
 
      switch(aCode)
       {
         case EXTERNAL_BATTERY_PACKS:
           err = Sensor::Get(aValue);
	   if (strlen(aValue) > 2) {
	     aValue[0] = aValue[1]; 
	     aValue[1] = aValue[2]; 
	     aValue[2] = aValue[3];    // copy null terminator
	   }
	   break;
 
         case INTERNAL_BATTERY_PACKS:
           _itoa(theNumber_Of_Internal_Packs,aValue,10);
  	   break;
 
         case TOTAL_BATTERY_PACKS:
         {
           CHAR External_Packs[32];
           err = Sensor::Get(External_Packs);
           INT Total_Batteries;
           Total_Batteries = theNumber_Of_Internal_Packs + 
               atoi(External_Packs);
           _itoa(Total_Batteries,aValue,10);
          }
	  break;
         default:
           err = Sensor::Set(aCode, aValue);
           break;
 
       }
      return err;
}


INT NumberBatteryPacksSensor::Set(INT aCode, const PCHAR aValue)
{
      INT err = ErrNO_ERROR;
 
      switch(aCode)
       {
         case EXTERNAL_BATTERY_PACKS:
	   {
 
            // Left pad number of battery packs with zeros

            // Default:  set number of external battery packs to zero
 
            if (strlen(aValue) == 0) {
              aValue[3] = NULL;
              aValue[2] = '0';
              aValue[1] = '0';
             }
            if (strlen(aValue) == 1) {
              aValue[3] = aValue[1];    // copy null terminator
              aValue[2] = aValue[0];
              aValue[1] = '0';
             }
            if (strlen(aValue) == 2) {
              aValue[3] = aValue[2];    // copy null terminator
              aValue[2] = aValue[1];
              aValue[1] = aValue[0];
             }
             aValue[0] = '0';
             err = Sensor::Set(aValue);
           }
	   break;

         default:
           err = Sensor::Set(aCode, aValue);
           break;
       }
      return err;
}

INT NumberBatteryPacksSensor::Set(const PCHAR aValue)
{
  return (Set(EXTERNAL_BATTERY_PACKS, aValue));
}

INT NumberBatteryPacksSensor::Update(PEvent anEvent)
{
	INT err = ErrNO_ERROR;

   switch (anEvent->GetCode()) {
   case EXTERNAL_BATTERY_PACKS:
	   err = storeValue(anEvent->GetValue());
	   break;
   default:
	   err = EepromSensor::Update(anEvent);
	   break;
   }
   return err;
}


INT NumberBatteryPacksSensor::storeValue(const PCHAR aValue)
{
   CHAR Ups_Is_A_Matrix[32];
   theFirmwareRev ->Get(IS_MATRIX,Ups_Is_A_Matrix);
   if (_strcmpi(Ups_Is_A_Matrix,"Yes") ==0) {

    //
     // Initialize curr_num so if theValue is not set (should only be first
     // time thru) we will generate a CHECK_CABLE event
     //
     INT curr_num = -1;
     if(theValue)  {
        curr_num = atoi(theValue);
     }
     INT new_count = atoi(aValue);

     if(new_count == 0 && curr_num != 0)  {
       // create Check signal cable Event
       Event tmp(SMART_CELL_SIGNAL_CABLE_STATE, CHECK_CABLE);
       UpdateObj::Update(&tmp);
     }
     if(new_count != 0 && curr_num == 0)  {
       // create Ignore battery good event.  The UPS sends a battery good
       // when plugging back in the cable.  Another UPSLink-ism.
       Event tmp(SMART_CELL_SIGNAL_CABLE_STATE, IGNORE_BATTERY_GOOD);
       UpdateObj::Update(&tmp);
     }
   }
 
   // Check for an new battery and generate an event
   if (theSensorIsInitialized) 
   {
     if (strcmp(aValue, theValue) > 0) 
     {
       PEvent added_event = new Event(BATTERY_ADDED, "");
       UpdateObj::Update(added_event);
       delete added_event;
       added_event = NULL;
     }

     // Check for a battery removal and generate an event
     if (strcmp(aValue, theValue) < 0) 
     {
       PEvent removed_event = new Event(BATTERY_REMOVED, "");
       UpdateObj::Update(removed_event);
       delete removed_event;
       removed_event = NULL;
     }
   }
   else
   {
     theSensorIsInitialized = 1;
   }


   Sensor::storeValue(aValue);

   return ErrNO_ERROR;
}

NumberBatteryPacksSensor :: ~NumberBatteryPacksSensor()
{

  theCommController->UnregisterEvent(theSensorCode, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\battcaps.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 */
#ifndef BATTCAPS_H
#define BATTCAPS_H

#include "thsensor.h"

_CLASSDEF(BatteryCapacitySensor)


class BatteryCapacitySensor : public ThresholdSensor {
   
public:
   BatteryCapacitySensor(PDevice aParent,PCommController aCommController=NULL);
   virtual ~BatteryCapacitySensor(); 
   virtual INT IsA() const {return BATTERYCAPACITYSENSOR ; } ;
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\battrep.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  pcy14Dec92: Changed READ_WRITE to AREAD_WRITE
 *  pcy26Jan93: I'm a EepromSensor now
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "battrep.h"

BatteryReplacementDateSensor :: BatteryReplacementDateSensor(PDevice aParent, PCommController aCommController)
			: EepromSensor(aParent, aCommController, BATTERY_REPLACEMENT_DATE, AREAD_WRITE)
{
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\battmgr.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker07DEC92: Initial OS/2 Revision
 *  ker14DEC92: fleshed out the methods
 *  pcy17Dec92: Set should not use const PCHAR
 *  pcy26Jan93: Added SetEepromAccess()
 *  pcy10Sep93: Removed theCommController member.  Its in Device.
 *  cad28Sep93: Made sure destructor(s) virtual
 *  cad11Nov93: Making sure all timers are cancelled on destruction
 */

#ifndef __BATTMGR_H__
#define __BATTMGR_H__

#include "update.h"
#include "device.h"
#include "comctrl.h"
#include "sensor.h"
#include "firmrevs.h"

_CLASSDEF(BatteryReplacementManager)

class BatteryReplacementManager : public Device {

   protected:
      PCHAR theReplaceDate;
      PCHAR theAgeLimit;
      ULONG theTimerId;

      PUpdateObj theParent;
      PSensor theBatteryReplacementDateSensor;
      PSensor theReplaceBatterySensor;

   public:
      BatteryReplacementManager(PUpdateObj aParent, PCommController aCommController, PFirmwareRevSensor aFirmwareRevSensor);
      virtual ~BatteryReplacementManager();
      virtual INT Get(INT, PCHAR);
//      virtual INT DeepGet(INT, PCHAR);
      virtual INT Set(INT, const PCHAR);
      virtual INT Update(PEvent);
      virtual INT SetReplacementTimer(void);
   	  VOID SetEepromAccess(INT anAccessCode);
      virtual VOID  GetAllowedValue(INT code, CHAR *aValue);
   virtual VOID   Reinitialize();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\battmgr.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker07DEC92: Initial OS/2 revision
 *  ker14DEC92: fleshed out the methods
 *  pcy17Dec92: Set should not use const PCHAR
 *  pcy26Jan93: Added SetEepromAccess()
 *  pcy02Feb93: Made Set() return value for all cases
 *  cad03Sep93: Fixed problem where date not being cached, but cache used
 *  cad07Oct93: Plugging Memory Leaks
 *  cad11Nov93: Making sure all timers are cancelled on destruction
 *  cad04Mar94: fixes for access code problem
 *  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
 *  djs22Feb96: changed to new firmware rev interface
 *  cgm16Apr96: Add unregister to destructor
 *  ntf30Jul97: Added code after strncpy to cater for situation where
 *              no '\0' added.
 *  ntf30Jul97: Added 1 to the size of theReplaceDate and theAgeLimit as, well,
 *              theReplaceDate anyway, was being copied to by a strncpy which
 *              said its length excluding room for NULL char was
 *              REPLACE_DATE_MAX which was actuall its size including NULL.
 *  tjg02Mar98: Added theReplaceBatterySensor->DeepGet() in Reinitialize()
 */

#include "cdefine.h"

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "_defs.h"
#include "apc.h"
#include "battmgr.h"
#include "battrep.h"
#include "replbatt.h"
#include "cfgmgr.h"
#include "unssens.h"
#include "timerman.h"
#include "eeprom.h"
#include "smartups.h"

#if (C_OS & C_UNIX)
#include "utils.h"
#endif

#define REPLACE_DATE_MAX    32


BatteryReplacementManager::BatteryReplacementManager(PUpdateObj aParent,
                             PCommController aCommController,
                             PFirmwareRevSensor aFirmwareRevSensor)
    :Device(aParent, aCommController), theTimerId(0)
{
    theReplaceDate=new CHAR[REPLACE_DATE_MAX+1];
    theAgeLimit=new CHAR[REPLACE_DATE_MAX+1];

    theParent=aParent;
    theCommController=aCommController;


    CHAR Battery_Replacement_Date_Capable[32];
    aFirmwareRevSensor->Get(IS_BATTERY_DATE,Battery_Replacement_Date_Capable);

    if (_strcmpi(Battery_Replacement_Date_Capable,"No") == 0)
    {
    theBatteryReplacementDateSensor = &_theUnsupportedSensor;
    _theConfigManager->Get(CFG_BATTERY_REPLACEMENT_DATE, theReplaceDate);
    }
    else  {
    theBatteryReplacementDateSensor=new BatteryReplacementDateSensor(this, theCommController);
    theBatteryReplacementDateSensor->Get(BATTERY_REPLACEMENT_DATE, theReplaceDate);
    }
    _theConfigManager->Get(CFG_BATTERY_AGE_LIMIT, theAgeLimit);

    theReplaceBatterySensor = new ReplaceBatterySensor(this, theCommController);
    theReplaceBatterySensor->RegisterEvent(BATTERY_REPLACEMENT_CONDITION, this);
}


BatteryReplacementManager::~BatteryReplacementManager()
{
   if (theTimerId) {
      _theTimerManager->CancelTimer(theTimerId);
      theTimerId = 0;
   }

   if(theBatteryReplacementDateSensor &&
    (theBatteryReplacementDateSensor != &_theUnsupportedSensor)) {
       delete theBatteryReplacementDateSensor;
       theBatteryReplacementDateSensor = NULL;
   }

   if (theReplaceBatterySensor){
      theReplaceBatterySensor->UnregisterEvent(BATTERY_REPLACEMENT_CONDITION, this);
      delete theReplaceBatterySensor;
      theReplaceBatterySensor = NULL;
   }

   if (theReplaceDate) {
       delete[] theReplaceDate;
       theReplaceDate = NULL;
   }
   if (theAgeLimit) {
       delete[] theAgeLimit;
       theAgeLimit = NULL;
   }
}

INT BatteryReplacementManager::Get(INT aCode, PCHAR aValue)
{
    INT err = ErrNO_ERROR;

    switch(aCode)
    {
      case BATTERY_REPLACEMENT_DATE:
         strcpy(aValue, theReplaceDate);
         break;

      case BATTERY_AGE_LIMIT:
         strcpy(aValue, theAgeLimit);
         break;

      case LIGHTS_TEST:
         err = theParent->Get(aCode, aValue);
         break;

      default:
         err =ErrINVALID_CODE;
         break;
    }
    return err;
}

INT BatteryReplacementManager::Set(INT aCode, const PCHAR aValue)
{
    INT err = ErrNO_ERROR;

    switch(aCode) {

      case BATTERY_REPLACEMENT_DATE:
          strncpy(theReplaceDate, aValue, REPLACE_DATE_MAX);
          //ntf30Jul97: Added next line in case theReplaceDate was full.
          *(theReplaceDate + REPLACE_DATE_MAX) = '\0';
          theBatteryReplacementDateSensor->Set(aCode, theReplaceDate);
          //err = _theConfigManager->Set(CFG_BATTERY_REPLACEMENT_DATE,
            //  theReplaceDate);
          break;

      case BATTERY_AGE_LIMIT:
          //err = _theConfigManager->Set(aCode, aValue);
          break;

      default:
          err = ErrINVALID_CODE;
          break;
    }
    return err;
}

INT BatteryReplacementManager::Update(PEvent ev)
{
    if ((ev->GetCode() == BATTERY_REPLACEMENT_CONDITION) &&
        (atoi(ev->GetValue()) == BATTERY_NEEDS_REPLACING)) {

        theTimerId = 0;
    }
    return Device::Update(ev);
}

INT BatteryReplacementManager::SetReplacementTimer(void)
{

   //Get Date Battery Was Replaced/Installed

   CHAR the_temp_string[REPLACE_DATE_MAX];
   strcpy(the_temp_string, theReplaceDate);
   the_temp_string[2]='\0';
   the_temp_string[5]='\0';

   INT the_birth_month=atoi(the_temp_string);
   PCHAR the_day_pointer=&(the_temp_string[3]);
   INT the_birth_day=atoi(the_day_pointer);
   PCHAR the_year_pointer=&(the_temp_string[6]);
   INT the_birth_year=atoi(the_year_pointer);

   //Get Lifespan of Battery

   INT the_battery_lifespan=atoi(theAgeLimit);

   //Calculate the month of death

   INT the_month=the_birth_month+=(the_battery_lifespan%12);

   INT the_year=the_birth_year+=(the_battery_lifespan/12);
   if(the_year>=100)
      the_year-=100;

   //Create a DateTimeObj with that date

   DateTimeObj my_date_time_obj(the_year, the_month, the_birth_day, 0L,
                                0L, 0L);

   //Create the Event

   Event the_timer_event(BATTERY_REPLACEMENT_CONDITION,
                         BATTERY_NEEDS_REPLACING);

   //Send it to the Timer manager and forget it

   theTimerId = _theTimerManager->SetTheTimer(&my_date_time_obj,
                                              &the_timer_event, this);

   return TRUE;
}


VOID
BatteryReplacementManager :: SetEepromAccess(INT anAccessCode)
{
    ((PEepromChoiceSensor)theBatteryReplacementDateSensor)->SetEepromAccess(anAccessCode);
}

VOID BatteryReplacementManager :: GetAllowedValue(INT code, CHAR *aValue)
{
    ((PSmartUps)theParent)->GetAllowedValue(code, aValue);
}


VOID BatteryReplacementManager::Reinitialize()
{
    theBatteryReplacementDateSensor->DeepGet();
    theReplaceBatterySensor->DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\battrep.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *  pcy26Jan93: I'm a EepromSensor now
 */
#ifndef BATTREP_H
#define BATTREP_H

#include "eeprom.h"

_CLASSDEF(BatteryReplacementDateSensor)

class BatteryReplacementDateSensor : public EepromSensor {
   
public:
   BatteryReplacementDateSensor(PDevice aParent, PCommController aCommController=NULL);
   virtual INT IsA() const { return BATTERYREPLACEMENTDATESENSOR; };
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\bypmodes.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *
 *  cad08Sep93: Trapping set to handle wierd cases
 *  cad10Sep93: Simplified, seems to work
 *  pcy20Sep93: Wait for possible top fan event to occur
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  mwh30Jun94: if BYPASS_SOFTWARE sleep 3 secs to see if TOPFANFAILURE (1x)
 *  mwh30Jun94: had to add unistd.h for sleep on unix
 *  cgm12Apr96: Add destructor with unregister
 *  clk24Jun98: In Set, changed Sensor::Set to theCommControllerSet
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#if (C_OS & C_UNIX)
#include <unistd.h>
#endif
}

#include "bypmodes.h"
#include "comctrl.h"
#include "event.h"
#include "pollparm.h"
#include "timerman.h"

BypassModeSensor :: BypassModeSensor(PDevice aParent, PCommController aCommController)
			  : StateSensor(aParent, aCommController, BYPASS_MODE, AREAD_WRITE),
                            theBypassCause(0)
{
#ifdef SINGLETHREADED
    theAlreadyOnBypassFlag = 0;
#endif
    storeState(UPS_NOT_ON_BYPASS);
    theCommController->RegisterEvent(theSensorCode, this);

    // We force registering for this cause protocol doesn't handle it
    //
    theCommController->RegisterEvent(STATE_REGISTER, this);
}

BypassModeSensor :: ~BypassModeSensor()
{
    theCommController->UnregisterEvent(theSensorCode, this);
    theCommController->UnregisterEvent(STATE_REGISTER, this);
}
#if 0
***  Removed for size concerns.  This is really a redundant feature since
***  protocol generates these events

INT BypassModeSensor::Validate(INT aCode, const PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    if(aCode!=theSensorCode)  {
      	err = ErrINVALID_CODE;
    }
    else  {
	err = StateSensor::Validate(aCode, aValue);
    }
    return err; 
}

#endif

INT BypassModeSensor::Update(PEvent anEvent)
{
    INT val = atoi(anEvent->GetValue());

    switch(val)  {
       case UPS_ON_BYPASS:
          theBypassCause = atoi(anEvent->GetAttributeValue(BYPASS_CAUSE));
	  //
	  // Another UPSLinkism. If on bypass by top fan failure, the UPS
	  // also tells us on bypass by computer select which is what we
	  // use to indicate a software bypass
	  //
          if(theBypassCause == BYPASS_BY_SOFTWARE)  {
	      CHAR value[32];
#ifdef SINGLETHREADED
              if (!theAlreadyOnBypassFlag) {
                  theAlreadyOnBypassFlag = 1;

#if (C_OS & C_WIN311)
		_theTimerManager->Wait(3000L);	// changed wait to 3 seconds 3/15/94 jod
#else
		sleep(3);	// three seconds
#endif
              }
#else
              _theTimerManager->Wait(3000L);	// changed wait to 3 seconds 3/15/94 jod
#endif
	      theCommController->Get(TRIP1_REGISTER, value);
	      if(atoi(value) & TOPFANFAILUREMASK)  {
		  anEvent->SetAttributeValue(BYPASS_CAUSE, 
					     BYPASS_BY_TOP_FAN_FAILURE);
                  theBypassCause = BYPASS_BY_TOP_FAN_FAILURE;
	      }
	  }
          break;

       case UPS_NOT_ON_BYPASS:
#ifdef SINGLETHREADED
          theAlreadyOnBypassFlag = 0;
#endif
          theBypassCause = 0;
   }
   return Sensor::Update(anEvent);
}


BypassModeSensor::Get(INT aCode, PCHAR aValue)
{
   CHAR state_value[32];
   CHAR trip_value[32];
   CHAR trip1_value[32];
   theCommController->Get(STATE_REGISTER, state_value);
   theCommController->Get(TRIP_REGISTER, trip_value);
   theCommController->Get(TRIP1_REGISTER, trip1_value);

   INT state = 0;
   if((atoi(state_value) & (SWITCHEDBYPASSMASK | COMPSELECTBYPASSMASK)) ||
      (atoi(trip_value) & (OVERTEMPMASK | BATTERYCHARGERMASK)) ||
      (atoi(trip1_value) & (BYPASSDCIMBALANCEMASK | BYPASSOUTPUTLIMITSMASK | TOPFANFAILUREMASK)))  {
      state = UPS_ON_BYPASS;
   }
   else  {
      state = UPS_NOT_ON_BYPASS;
   }
   sprintf(aValue, "%d", state);
   return ErrNO_ERROR;
}


INT BypassModeSensor::Set(const PCHAR aValue)
{
    INT err = ErrNO_ERROR;

    switch (atoi(aValue)) {
      case INITIATE_BYPASS:
//	sprintf(buf,"%d",UPS_ON_BYPASS);
//	err = StateSensor::Set(buf);
//       aValue[0]=0;
	err = theCommController->Set(theSensorCode, aValue);
	break;

      case CANCEL_BYPASS:
	// Let real value get set when state change in UPS is detected
	// Will cause double events, but should be OK
	//
//       aValue[0]=0;
	err = theCommController->Set(theSensorCode, aValue);
	break;

      default:
	err =  ErrINVALID_VALUE;
	break;
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\cdefine.h ===
/*
 *
 * REFERENCES:
 *
 * NOTES:
 *    To use
 *       Example: C_PLATFORM 
 *          #if (C_PLATFORM & (C_SUN | C_IBM))
 *
 * REVISIONS:
 *  pcy23Nov92 Added some meat
 *  pcy24Nov92 Added C_OS:C_WINDOWS
 *  rct25Nov92 Amendments for NetWare
 *  pcy14Dec92 Removed MULTI_THREADED define from here
 *  rct27Jan93 Added stuff for INTEK compiler
 *  pcy02Feb93: Added NT stuff
 *  ajr17Feb93: Added ifdef's for AIX RS6000
 *  ajr24Feb93: Added POSIX conditions for UNIX I/O
 *  ajr25Feb93: Added UNIX C_OS group
 *  ajr12Mar93: #included <errno.h> for debugging purposes (temp)
 *  ajr24Mar93: Added TIME_SCALE_FACTOR def's
 *  ajr24Mar93: Added header include ifndef.. for handling of const typing...
 *              instead of #defining....
 *  pcy28Apr93: Dont use // commenting in this module. It's used in C source.
 *  cad27Sep93: Added include of limits to fix conflicts downstream
 *  ajr16Nov93: Removed TIME_SCALE_FACTOR
 *  cad27Dec93: include file madness
 *  mwh28Feb94: make HPUX legit
 *  mwh13Mar94: port for SUNOS4
 *  ram21Mar94: Included windows.h for novell FE work
 *  mwh04Apr94: port for UWARE - unixware
 *  mwh12Apr94: port for SCO
 *  pcy19Apr94: port for SGI
 *  ajr25Apr94: Handle SIGFUNC_HAS_VARARGS here
 *  mwh23May94: port for NCR
 *  mwh01Jun94: port for INTERACTIVE
 *  jps20jul94: added #undef SYSTEM for os2
 *  djs31Mar95: port for UNISYS
 *  daf17May95: port for ALPHA/OSF
 *  dml24Aug95: removed conditional code for OS2 ver 1.3
 *  djs09Sep95: port for HPUX 10.0
 *  djs02Oct95: port for AIX 4.1
 *  djs06Oct95: port for UnixWare 2.01
 *  ajr07Nov95: port for Sinix RM. Must have c style comments with preprocessor
 *  dml15Dec95: put C_WIN311 def back in (was overwritten by C_OLIV) in INTERACTIVE slot
 *  rsd28Dec95: Change #ifdef DOS to #ifdef NWDOS, add C_NETWORK C_IPX
 *  ntf29Dec95: Added C_NT to ORd OS's for including <windows.h>, also put in
 *              #undef VOID and #undef BOOLEAN in this block because of
 *              conflicts using Visual C++ 4.0 for NT.
 *  pcy28jun96: Added C_API stuff
 *  cgm27may97: Added smartheap header file.
 */

#ifndef _CDEFINE_H
#define _CDEFINE_H

#ifdef USE_SMARTHEAP
#include "smrtheap.hpp"
#endif
#include <limits.h>


/*
 * C_OS codes
 */
#define C_DOS               1 /* 0000 0000 0000 0000 0000 0001 */
#define C_OS2               2 /* 0000 0000 0000 0000 0000 0010 */
#define C_NLM               4 /* 0000 0000 0000 0000 0000 0100 */
#define C_AIX               8 /* 0000 0000 0000 0000 0000 1000 */
#define C_IRIX             16 /* 0000 0000 0000 0000 0001 0000 */
#define C_HPUX             32 /* 0000 0000 0000 0000 0010 0000 */
#define C_SUNOS4           64 /* 0000 0000 0000 0000 0100 0000 */
#define C_WINDOWS         128 /* 0000 0000 0000 0000 1000 0000 */
#define C_VAP             256 /* 0000 0000 0000 0001 0000 0000 */
#define C_NT              512 /* 0000 0000 0000 0010 0000 0000 */
#define C_SOLARIS2       1024 /* 0000 0000 0000 0100 0000 0000 */
#define C_UWARE          2048 /* 0000 0000 0000 1000 0000 0000 */
#define C_SCO            4096 /* 0000 0000 0001 0000 0000 0000 */
#define C_NCR            8192 /* 0000 0000 0010 0000 0000 0000 */
#define C_WIN311        16384 /* 0000 0000 0100 0000 0000 0000 */
#define C_OLIV          32768 /* 0000 0000 1000 0000 0000 0000 */
#define C_USYS          65536 /* 0000 0001 0000 0000 0000 0000 */
#define C_ALPHAOSF     131072 /* 0000 0010 0000 0000 0000 0000 */
#define C_SINIX        262144 /* 0000 0100 0000 0000 0000 0000 */
#define C_INTERACTIVE  524288 /* 0000 1000 0000 0000 0000 0000 */
#define C_WIN95       1048576 /* 0001 0000 0000 0000 0000 0000  */

/* 
* C_VERSION codes
*/
#define C_OS2_13        1
#define C_OS2_2X        2



/* --------------------
/  C_OSVER
/ -------------------- */
#define C_AIX3_2    1


/* --------------------
/  C_IOSTD
/ -------------------- */
#define C_POSIX       1



/*
 * C_VENDOR codes
 */
/*
#define C_SUN        1
#define C_IBM        2
#define C_SGI        4
#define C_HP         8
#define C_DEC        16
*/

/*
 * C_PLATFORM codes
 */
#define C_INTEL286  0
#define C_INTEL386  1
#define C_MIPS      2
#define C_SPARC     4
#define C_SGI       8
#define C_HP        16
#define C_DEC       32
#define C_X86       64

/*
 * C_MACHINE codes
 */
#define C_PS2         1

/*
 * C_NETWORK codes
 */
#define C_DDE         1
#define C_IPX         2

/* empty by default */
#define SYSTEM

/*
 * C_APPFRAMEWORK codes
 */
#define C_OWL         1
#define C_COMPILER   0


/* C_API codes */
#define C_WIN32   1
#define C_WIN16   2


#ifdef OS2
   #define C_OS  C_OS2
   
   #ifdef OS22X
      #define C_VERSION C_OS2_2X
      #undef SYSTEM
      #define SYSTEM    _System
   #else
      #define C_VERSION C_OS2_13
      #define SYSTEM 
   #endif
#endif

#ifdef VAP
#define C_OS  C_VAP
#endif

#ifdef NLM
#define C_OS  C_NLM
#endif

#ifdef NWDOS
#define C_OS  C_DOS
#define C_NETWORK C_IPX
#endif

#ifdef X86
#define C_PLATFORM C_X86
#endif

#ifdef IBM
#define C_PLATFORM  C_IBM
#endif

#ifdef SPARC
#define C_PLATFORM  C_SPARC
#endif

#ifdef SGI
#define C_PLATFORM  C_SGI
#endif

#ifdef AIXPS2
#define C_OS  C_AIXPS2
#endif

#ifdef AIX
#define C_OS  C_AIX
#endif

#ifdef HPUX
#define C_OS  C_HPUX
#endif

#ifdef UWARE
#define C_OS C_UWARE
#endif

#ifdef SCO
#define C_OS C_SCO
#endif

#ifdef INTERACTIVE
#define C_OS C_INTERACTIVE
#endif
  
#ifdef NCR
#define C_OS C_NCR
#endif

#ifdef SGI
#define C_OS  C_IRIX
#endif

#ifdef WIN311
#define C_OS C_WIN311
#define C_NETWORK        C_DDE
#define C_API    C_WIN16
#endif

#ifdef NWWIN
#define C_OS C_WINDOWS
#define C_NETWORK C_IPX
#define C_APPFRAMEWORK   C_OWL
#define C_API    C_WIN16
#endif

#ifdef NT
#define C_OS C_NT
#define SYSTEM
#define C_API    C_WIN32
#endif

#ifdef WIN95
#define C_OS (C_NT | C_WIN95)
#define SYSTEM
#define C_API    C_WIN32
#endif

#ifdef __INTEK__
#define __cplusplus
#endif

#ifdef AIX3_2
#define C_OSVER C_AIX3_2
#endif

#ifdef SOLARIS2
#define C_OS C_SOLARIS2
#endif

#ifdef USYS
#define C_OS C_USYS
#endif

#ifdef ALPHAOSF
#define C_OS C_ALPHAOSF
#endif

#ifdef APC_OLIVETTI
#define C_OS C_OLIV
#endif

#ifdef SUNOS4
#define C_OS C_SUNOS4
#endif

#ifdef SINIX
#define C_OS C_SINIX
#endif

/* --------------------
/  Some Unix Stuff....
/ -------------------- */
#define C_UNIX      (C_AIX | C_HPUX | C_SUNOS4 | C_SOLARIS2 |\
		     C_UWARE | C_SCO | C_OLIV | C_IRIX | C_NCR |\
                     C_INTERACTIVE | C_USYS | C_ALPHAOSF | C_SINIX) 

#define SIGFUNC_HAS_VARARGS        C_IRIX

#if (C_OS & C_UNIX)
#define C_IOSTD  C_POSIX
#endif

#define C_HPUX9  1
#define C_HPUX10 2
 
#ifdef HPUX10
#define C_HP_VERSION C_HPUX10
#else
#define C_HP_VERSION C_HPUX9
#endif

#define C_AIX3  1
#define C_AIX4 2
 
#ifdef AIX4
#define C_AIX_VERSION C_AIX4
#else
#define C_AIX_VERSION C_AIX3
#endif


#define C_UWARE1  1
#define C_UWARE2 2
 
#ifdef UWARE2
#define C_UWARE_VERSION C_UWARE2
#else
#define C_UWARE_VERSION C_UWARE1
#endif
/* ---------------
 ...THREADED Macros
   --------------- */
#if (C_OS & (C_WINDOWS | C_WIN311 | C_UNIX | C_DOS))
#define SINGLETHREADED
#else
#define MULTITHREADED
#endif	 

/* 
 * Used for error logging.  @(#)cdefine.h   1.35 expands to filename and rev in SCCS
 */
#ifndef __APCFILE__
#define __APCFILE__ "@(#)cdefine.h  1.35"
#endif
/*
* Most of files required this for Windows Novell Fe.
*/
#if (C_OS & (C_WINDOWS | C_WIN311 | C_NT))
/* Need to do this otherwise <winnt.h> will not define SHORT */
  #undef VOID 
  #undef BOOLEAN
#include <windows.h>
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\bypmodes.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *
 *  cad08Sep93: Added Set
 *  cad28Sep93: Made sure destructor(s) virtual
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  mwh30Jun94: add data member for SINGLETHREADED
 *  cgm12Apr96: Add destructor with unregister
 */

#ifndef BYPMODES_H
#define BYPMODES_H

#include "stsensor.h"
 
_CLASSDEF(BypassModeSensor)
 
class BypassModeSensor : public StateSensor {
protected:
   INT theBypassCause;

#ifdef SINGLETHREADED
   INT theAlreadyOnBypassFlag;
#endif

public:
   BypassModeSensor(PDevice aParent, PCommController aCommController = NULL);
   virtual ~BypassModeSensor();
   virtual INT IsA() const { return BYPASSMODESENSOR; };
   virtual INT Update(PEvent aEvent);
   virtual INT Get(INT aCode, PCHAR aValue);
   virtual INT Set(const PCHAR);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\cdevice.h ===
/*
* REVISIONS:
*  xxxddMMMyy
*  sja09Dec92 - Poll method made public for Windows 3.1
*  pcy14Dec92 - ZERO changed to APCZERO
*  ajr08Mar93: added C_UNIX to single SINGLETHREADED
*  pcy21Apr93: OS2 FE merge
*  pcy14May93: Added Set(PTransactionGroup)
*  tje01Jun93: Moved SINGLETHREADED to cdefine.h
*  cad09Jul93: using new semaphores
*  cad03Sep93: made more methods virtual
*  cad08Sep93: Protected the event list
*  cad14Sep93: Cleaning up theState
*  cad17Nov93: publicized haslostcomm method
*  mwh18Nov93: changed EventID to INT
*  cad11Jan94: moved const/dest to .cxx
*  ajr16Feb94: Added default id to SubmitList.
*  ajr16Feb94: Added writeUpsOffFile() protected member function.
*  mwh05May94: #include file madness , part 2
*  srt24Oct96: Added an abort semaphore
*  tjg26Jan98: Added Stop method
*  tjg02Mar98: Removed Stop method (dead code)
*/
#ifndef _INC__CDEVICE_H
#define _INC__CDEVICE_H

_CLASSDEF(CommDevice)
_CLASSDEF(PollLoop)

#include "apc.h"
#include "update.h"
#include "thrdable.h"
#include "apcsemnt.h"

extern "C"  {
#include <time.h>
}

_CLASSDEF(Message)
_CLASSDEF(ProtectedList)
_CLASSDEF(ListIterator)
_CLASSDEF(TransactionGroup)
_CLASSDEF(Controller)
_CLASSDEF(Protocol)
_CLASSDEF(Stream)
_CLASSDEF(MutexLock)
_CLASSDEF(Thread)
_CLASSDEF(List)
_CLASSDEF(CommDevice)


// Values for theState
//
#define NORMAL_STATE    0
#define RETRYING        2
#define COMM_STOPPED    3
#define PAUSE_POLLING   4

#define FOURSECONDS    4000

class CommDevice : public UpdateObj
{

public:
    CommDevice(PController control);
    virtual ~CommDevice();

    PController    GetController(VOID) {return theController;};
    PProtocol      GetProtocol(VOID) {return theProtocol;};
    PStream        GetPort(VOID) {return thePort;};
    INT            HasLostComm(VOID)  {return theLostCommFlag;};

    virtual  INT   Equal(RObj item) const;
    virtual  INT   RegisterEvent(INT event, PUpdateObj object);
    virtual  INT   UnregisterEvent(INT event, PUpdateObj object);
    virtual  INT   Initialize(VOID);
    virtual  INT   Set(INT pid, const PCHAR value);
    virtual  INT   Set(PTransactionGroup agroup);
    virtual  INT   Get(INT pid, PCHAR value);
    virtual  INT   Get(PTransactionGroup agroup);
    virtual  INT   Update(PEvent anEvent);
    virtual  INT   IsA() const {return COMMDEVICE;};
    virtual  VOID  OkToPoll(VOID);
    virtual  INT   Poll(VOID);

protected:
    PApcSemaphore      theAbortSem;
    PProtectedList     thePollList;
    PListIterator      thePollIterator;
    PTransactionGroup  theCurrentTransaction;
    time_t             pollStartTime;
    INT                theSleepingFlag;
    INT                thePollIsDone;
    PProtectedList     theEventList;
    PListIterator      theEventIterator;
    INT                theState;
    PController        theController;
    PProtocol          theProtocol;
    PStream            thePort;
    PMutexLock         theAskLock;
    LONG               thePollInterval;
    INT                theLostCommFlag;

    PThread            thePollThread;
    virtual INT        CreatePort() = 0;
    virtual INT        CreateProtocol() = 0;
    INT                SubmitList(PList msglist,INT id=-1);
    INT                HandleEvents();
    INT                Retry();
    virtual INT        AskUps(PMessage msg) = 0;
    virtual VOID       StartPollThread();
    VOID               Access();
    VOID               Release();


    friend class PollLoop;
};

class PollLoop : public Threadable
{
public:
    PollLoop (PCommDevice aDevice);
    virtual ~PollLoop ();

    virtual VOID ThreadMain(VOID);

protected:
    PCommDevice theDevice;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\cdevice.cxx ===
/*
*
* NOTES:
*
* REVISIONS:
*  ane09DEC92: fixed thread rundown problems
*  ane16DEC92: added semaphore to protect multi-threaded access to 
*              current transaction group on protocol
*  jod29Dec92: Made SubmitList return an INT -> changed Get and Set
*  ane30Dec92: optimized polling
*  jod13Jan93: Added eventList to InterpretMessage() call and moved all
*              HandleEvent calls to the Poll loop 
*  ane25Jan93: Added call to error logger when initialization of port
*              fails
*  ane03Feb93: Added checks to avoid crashes during rundown of polling
*              thread, also updated destructor
*  ane09Feb93: Use ExitWait when telling the poll thread to go away
*  pcy16Feb93: Explicitly check for COMM LOST on returning msgs
*  pcy18Feb93: Fixed typo Err_RETRYING_COMM to ErrRETRYING_COM
*  pcy21Apr93: OS2 FE merge
*  pcy14May93: Added Set(PTransactionGroup)
*  cad09Jul93: using exitwait, new semaphores
*  cad15Jul93: sleeping during no-comm to allow cpu to detect reconnect better
*  pcy16Jul93: Added NT semaphores
*  jod24Aug93: Added Unregister
*  cad08Sep93: Added handling of events during gets
*  pcy10Sep93: Set theCurrentTransaction to the top of the list on Unregister
*  cad14Sep93: Support for pausing polling
*  cad07Oct93: Plugging Memory Leaks
*  cad12Oct93: Not sending garbage down for gets
*  ajr18Oct93: Made changes to work with Process manager for SINGLETHREADED
*  cad17Nov93: more lost comm fixups
*  mwh19Nov93: changed EventID to INT
*  ajr28Dec93: Added types.h on unix platforms to resolve typing problems.
*  cad11Jan94: Changes for new process manager
*  cad13Jan94: fixed up/simplified interval time measurement
*  cad14Jan94: fixing polling time for single-threaded
*  mwh14Jan94: fix singlethreaded client skipping every other poll
*  cad18Jan94: cleaned up single-threaded poll
*  pcy28Jan94: Create poll events on stack
*  ajr16Feb94: Added default id to SubmitList.
*  ajr16Feb94: Added writeUpsOffFile() protected member function.
*  ram21Mar94: Included header files for Novell FE to work
*  ajr23Mar94: Made sure to close upsoff.cmd
*  pcy08Apr94: Trim size, use static iterators, dead code removal
*  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
*  mwh05May94: #include file madness , part 2
*  mwh09May94: lose the auto. aggregate init. e.g CHAR foo[2] = "";
*  ajr20May94: SCO stuff
*  mwh23May94: port for NCR
*  ajr24May94: Uware includes....
*  ajr31May94: Saw to it that upsoff.cmd is erased after execution...
*  ajr31May94: Added stat.h for IRIX too....
*  mwh01Jun94: port for INTERACTIVE
*  cad01Jul94: fix for unix sleep problem and unregister crash
*  ajr29Aug94: reworked writeUpsOffFile to take Message *
*  ajr02May95: Need to stop carrying time in milliseconds
*  dml21Jun95: modify for general utility to get default pwrchute directory; req'd for Windows
*  dml24Aug95: removed conditional code for OS2 ver 1.3
*  ajr07Nov95: SINIX Port
*  poc28Sep96: Fixed SIR 4392.
*  jps17Oct96: Moved and added Access() and Release() calls, attempting to eliminate
*              application errors on exit
*  srt21Oct96: Replaced a timerManager wait with a timed semaphore wait
*  jps23Oct96: Added Access()/Release() to ~CommDevice(); commented out test for
*              TURN_ON_SMART_MODE in Set() so it always calls Access()/Release()
*  srt24Oct96: Added an abort semaphore
*  inf14Apr97: Loaded error string from resource file.
*  tjg09Jul97: Changed NT code to call getPwrchuteDirectory instead of getenv
*  awm21Oct97: Added initialization for performance monitor shared memory blocks
*  awm14Jan98: Removed initialization for performance monitor shared memory blocks
*  tjg26Jan98: Added Stop method
*  tjg02Mar98: Removed Stop method (dead code)
*
*  v-stebe  29Jul2000   Fixed PREfix errors (bugs #46363-46365, #46367, #46368)
*  v-stebe  11Sep2000   Fixed additional PREfix errors
*/

#include "cdefine.h"

#include "stream.h"

extern "C" {
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <time.h>
}

#include "_defs.h"
#include "apcobj.h"
#include "list.h"
#include "dispatch.h"
#include "event.h"
#include "message.h"
#include "proto.h"
#include "trans.h"
#include "cdevice.h"
#include "err.h"
#include "timerman.h"
#include "thread.h"
#include "contrlr.h"
#include "errlogr.h"
#include "utils.h"
#include "protlist.h"
#include "codes.h"


#include "apcsemnt.h"
#include "mutexnt.h"

#define RETRY_FAILED  1
#define RETRY_SUCCESS 0

#define ASKUPS_FAILED 1
#define ASKUPS_OK     0


/*--------------------------------------------------------------------
*
*       Function...:   CommDevice
*
*       Description:   Constructor.
*
*-------------------------------------------------------------------*/
CommDevice::CommDevice(Controller* control)
:  theController(control),
thePollList((ProtectedList *)NULL),
theCurrentTransaction((PTransactionGroup)NULL),
pollStartTime(0),
theSleepingFlag(0),
thePollIsDone(0),
theState(NORMAL_STATE),
thePort((PStream)NULL),
theProtocol((Protocol*)NULL),
thePollIterator((PListIterator)NULL),
thePollThread((PThread)NULL),
thePollInterval(4L),
theLostCommFlag(0)
{
    theEventList     = new ProtectedList();
    theEventIterator = (PListIterator) &(theEventList->InitIterator());
    theAskLock = new ApcMutexLock();
    theAbortSem = new ApcSemaphore();
}

/*--------------------------------------------------------------------
*
*       Function...:   CommDevice
*
*       Description:   Destructor.
*
*-------------------------------------------------------------------*/
CommDevice::~CommDevice()
{
    Access();
    
    theController->UnregisterEvent(EXIT_THREAD_NOW, this);
    
    theAbortSem->Post();
    
    if (theEventList)
    {
        theEventList->FlushAll();
        delete theEventList;
        theEventList = (PProtectedList)NULL;
        if (theEventIterator) {
            delete theEventIterator;
            theEventIterator = (PListIterator)NULL;
        }
        
    }
    
    if (thePollList)
    {
        thePollList->FlushAll();
        delete thePollList;
        thePollList = (ProtectedList *)NULL;
    }
    
    if (thePollIterator)
    {
        delete thePollIterator;
        thePollIterator = (PListIterator)NULL;
    }
    
    if (thePort)
    {
        delete thePort;
        thePort = (PStream)NULL;
    }
    
    if (theProtocol)
    {
        delete theProtocol;
        theProtocol = (PProtocol)NULL;
    }
    
    
    if (thePollThread)
    {
        // Use ExitWait to make sure that the poll thread is exited before
        // deleting the poll list, etc.
        
        //
        // NT workaround
        //
        thePollThread->TerminateThreadNow();
        
        delete thePollThread;
        thePollThread = (PThread)NULL;
    }
    
    Release();
    
    delete theAskLock;
    // theAskLock is a mutex lock.  Everyone should have one.  Dont us Semaphore
    // or NullMutexLock.
    theAskLock = (PMutexLock) NULL;
    
    delete theAbortSem;
    theAbortSem = NULL;
}

/*--------------------------------------------------------------------
*
*       Function...:   Initialize
*
*       Description:   .
*                                                    
*-------------------------------------------------------------------*/
INT CommDevice::Initialize()
{
    INT err = ErrNO_ERROR;
    
    if (thePort) 
    {
        err = thePort->Initialize();
    }
    
    theObjectStatus = err;
    
    // Can't call this in the constructor since theController vtbl isn't set
    // up at that point...It'll crash
    
    theController->RegisterEvent(EXIT_THREAD_NOW, this);
    return err;
}

INT CommDevice::Update(PEvent anEvent)
{
    switch (anEvent->GetCode())
    {
    case EXIT_THREAD_NOW:
        if(thePollThread)
        {
            thePollThread->ExitWait();
            delete thePollThread;
            thePollThread = (PThread)NULL;
        }
        break;
        
    default:
        break;
    }
    return ErrNO_ERROR;
}

/*--------------------------------------------------------------------
*
*       Function...:   Get
*
*       Description:   
*
*-------------------------------------------------------------------*/
INT CommDevice::Get(INT id, CHAR* value)
{
    INT err = ErrNO_ERROR;
    
    if (theLostCommFlag) {
        err = ErrCOMMUNICATION_LOST;
    }
    else {
        // Build the get transaction
        PTransactionGroup transaction_group = new TransactionGroup(GET);
        PTransactionItem transaction_item = new TransactionItem(GET, id, "");
        
        if ((transaction_group != NULL) && (transaction_item != NULL)) {
          transaction_group->AddTransactionItem(transaction_item);
        
          // Let the Protocol build the message.  The messages to send will be
          // placed in msglist.  There may be more than one message.
          if (theProtocol)
              err = theProtocol->BuildTransactionGroupMessages(transaction_group);
          else
              err = ErrRETRYING_COMM;
        
          if (!err && theProtocol)
          {
              Access();
            
              theProtocol->SetCurrentTransactionGroup(transaction_group);
              err = SubmitList(transaction_group->GetProtocolMessageList());
            
              Release();
            
              if (!(err))
              {
                  err = transaction_group->GetErrorCode();
              }
            
              if (err == ErrNO_ERROR || err == ErrCONTINUE)
              {
                  PList tiList = transaction_group->GetTransactionItemList();
                  PTransactionItem tmpti = new TransactionItem(GET,id);
                  PTransactionItem transitem = (PTransactionItem)tiList->Find(tmpti);
                  strcpy(value, transitem->GetValue());
                  delete tmpti;
                  tmpti = NULL;
              }
          }
          delete transaction_group;
          transaction_group = NULL;
        }
        else {
          err = ErrMEMORY;

          // Cleanup allocations so that we don't leak
          delete transaction_item;
          transaction_item = NULL;

          delete transaction_group;
          transaction_group = NULL;
        }
    }
    return err;
}


/*--------------------------------------------------------------------
*
*       Function...:   Get with a Transaction Group
*
*       Description:   
*
*-------------------------------------------------------------------*/
INT CommDevice::Get(PTransactionGroup transaction_group)
{
    INT err = ErrNO_ERROR;
    if(theLostCommFlag)  {
        err = ErrCOMMUNICATION_LOST;
    }
    else  {
        // Let the Protocol build the message.  The messages to send will be
        // placed in msglist.  There may be more than one message.
        if (theProtocol)
            err = theProtocol->BuildTransactionGroupMessages(transaction_group);
        else
            err = ErrRETRYING_COMM;
        
        if (!err && theProtocol)
        {
            Access();
            
            theProtocol->SetCurrentTransactionGroup(transaction_group);
            INT getErr = SubmitList(transaction_group->GetProtocolMessageList());
            
            Release();
            
            if (!(getErr))
            {
                getErr = transaction_group->GetErrorCode();
            }
            return getErr;
        }
    }
    return err;
}

/*--------------------------------------------------------------------
*
*       Function...:   Set
*
*       Description:   .
*
*-------------------------------------------------------------------*/

INT CommDevice::Set(INT id, CHAR* value)
{
    INT err = ErrNO_ERROR;
    
    if ((id != TURN_ON_SMART_MODE) && theLostCommFlag) {
        err = ErrCOMMUNICATION_LOST;
    }
    else {
        // Build the set transaction
        //
        PTransactionGroup transaction_group = new TransactionGroup(SET);
        PTransactionItem transaction_item = new TransactionItem(SET, id, value);
        
        if ((transaction_group != NULL) && (transaction_item != NULL)) {
          transaction_group->AddTransactionItem(transaction_item);
        
          // Let the Protocol build the message.  The messages to send will be
          // placed in msglist.  There may be more than one message.
          if (theProtocol)
              err = theProtocol->BuildTransactionGroupMessages(transaction_group);
          else
              err = ErrRETRYING_COMM;
        
          if (!err && theProtocol)
          {
              //       if(id != TURN_ON_SMART_MODE)  {
              Access();
              //       }
              theProtocol->SetCurrentTransactionGroup(transaction_group);
              err = SubmitList(transaction_group->GetProtocolMessageList(),id);
              //       if(id != TURN_ON_SMART_MODE)  {
              Release();
              //       }
            
              if (!err) {
                  err = transaction_group->GetErrorCode();
              }
          }
        
          if (!err) {
              err = transaction_item->GetErrorCode();
          }
          delete transaction_group;
          transaction_group = NULL;
        }
        else {
          err = ErrMEMORY;

          // Cleanup allocations so that we don't leak
          delete transaction_item;
          transaction_item = NULL;

          delete transaction_group;
          transaction_group = NULL;
        }
    }
    return err;
}


INT CommDevice::Set(PTransactionGroup transaction_group)
{
    INT err = ErrNO_ERROR;
    
    if(theLostCommFlag)  {
        err = ErrCOMMUNICATION_LOST;
    }
    else {
        // Let the Protocol build the message.  The messages to send will be
        // placed in msglist.  There may be more than one message.
        if (theProtocol)
            err = theProtocol->BuildTransactionGroupMessages(transaction_group);
        else
            err = ErrRETRYING_COMM;
        
        if (!err && theProtocol)
        {
            Access();
            
            theProtocol->SetCurrentTransactionGroup(transaction_group);
            INT setErr = SubmitList(transaction_group->GetProtocolMessageList());
            
            Release();
            
            if (!(setErr))
            {
                setErr = transaction_group->GetErrorCode();
            }
            return setErr;
        }
    }
    return err;
}


/*--------------------------------------------------------------------
*
*       Function...:   SubmitList
*
*       Description:   .
*
*-------------------------------------------------------------------*/
INT CommDevice::SubmitList(List* msglist, INT id)   // ***, ObjList* eventlist)
{
    ListIterator iterator(*msglist);
    PMessage msg  = (PMessage)&(iterator.Current());
    PMessage answer = (Message *)NULL;
    INT submitErr = 0;
    // #if !C_OS & C_WIN311
    // in windows we need to get to the ASKUP during the initialize retries
    if (theState==COMM_STOPPED)  {
        submitErr = theState;   // exit out of this routine - ex NO_COMM
    }
    // #endif
    
    
    while (msg && (submitErr == 0))  {
        // Send the message
        AskUps(msg);
        
        //check the message for an error
        if (msg->getErrcode()) {
            submitErr = msg->getErrcode();
        }
        else {
            List* newmsglist = new List();
            if (newmsglist != NULL) {
              if (theProtocol)  {
                  theProtocol->InterpretMessage(msg,theEventList, newmsglist);
              }
              else  {
                  submitErr = ErrRETRYING_COMM;
              }
            
            
              if (msg->getErrcode())  {
                  submitErr = msg->getErrcode();
              }
              else if (submitErr == 0) {
                  // If the Protocol has decided additional messages are 
                  // required to be sent as the result of the response, 
                  // send these before continuing.
                  //
                  if (newmsglist->GetItemsInContainer()) {
                      submitErr = SubmitList(newmsglist);
                  }
                  msg = (PMessage)iterator.Next();
              }
              newmsglist->FlushAll();
              delete newmsglist;
              newmsglist = NULL;
            }
            else {
              submitErr = ErrMEMORY;
            }
        }
    }
    return submitErr;
}

/*--------------------------------------------------------------------
*                                                  
*       Function...:   RegisterEvent
*
*       Description:   
*
*-------------------------------------------------------------------*/
INT CommDevice::RegisterEvent(INT id, UpdateObj* object)
{
  INT err = ErrNO_ERROR;
    UpdateObj::RegisterEvent(id, object);
    
    // Add the event to the poll list
    PTransactionGroup transaction_group = new TransactionGroup(GET);
    PTransactionItem transaction_item = new TransactionItem(GET, id, "");
    
    if ((transaction_group != NULL) && (transaction_item != NULL)) {
      transaction_group->AddTransactionItem(transaction_item);
    
      if (theProtocol)
          err = theProtocol->BuildPollTransactionGroupMessages(transaction_group);
      else
          err = ErrRETRYING_COMM;
    
      if (!err)
      {
          int listAllocated = FALSE;
        
          if (thePollList == (PList) NULL)
              thePollList = new ProtectedList;
          thePollList->Append(transaction_group);
          if (theCurrentTransaction == (PTransactionGroup)NULL)
              theCurrentTransaction = (PTransactionGroup) thePollList->GetHead();
          if (thePollIterator == (PListIterator)NULL)
              thePollIterator = new ListIterator (*thePollList);
      }
      else
      {
          delete transaction_group;
          transaction_group = NULL;
      }
    }
    else {
      err = ErrMEMORY;

      // Cleanup allocations so that we don't leak
      delete transaction_item;
      transaction_item = NULL;

      delete transaction_group;
      transaction_group = NULL;
    }
    
    // Ignore errors that come back from BuildPollTransactionGroupMessages
    // since the worst that will happen is the parameter won't be polled for
    if (err == ErrRETRYING_COMM)
	{
        return err;
	}
    else
	{
        return ErrNO_ERROR;
	}
}

/*--------------------------------------------------------------------
*
*       Function...:   UnregisterEvent
*
*       Description:   .
*
*-------------------------------------------------------------------*/
INT CommDevice::UnregisterEvent(INT id, UpdateObj* object)
{
    UpdateObj::UnregisterEvent(id, object);
    if ( !(theDispatcher->GetRegisteredCount(id)) &&  // If Empty List
        thePollIterator && thePollList )              // just in case
    {
        PTransactionGroup tmp = (PTransactionGroup)NULL;
        thePollIterator->Reset();
        PTransactionGroup group = (PTransactionGroup) &(thePollIterator->Current());
        
        Access();
        
        while (group != (PTransactionGroup)NULL)
        {
            tmp = (PTransactionGroup)thePollIterator->Next();
            if (group->GetFirstTransactionItem()->GetCode() == id)
            {
                thePollList->Detach((RObj)*group);
                delete group;
                group = NULL;
                //
                // We have to do this because if we remove the
                // transaction we're currently pointing to we
                // die
                //
                thePollIterator->Reset();
                theCurrentTransaction = (PTransactionGroup) thePollList->GetHead();
                break;
            }
            group = tmp;
        }
        Release();
        
    }
    return ErrNO_ERROR;
}


/*--------------------------------------------------------------------
*
*       Function...:   Equal
*
*       Description:   .
*
*-------------------------------------------------------------------*/
INT CommDevice::Equal(RObj item) const
{
    RCommDevice comp = (RCommDevice)item;
    if ( theController == comp.GetController() )
    {
        if ( theProtocol == comp.GetProtocol() )
        {
            if ( thePort == comp.GetPort() )
			{
                return TRUE;
			}
        }
    }
    return FALSE;
}

/*--------------------------------------------------------------------
*
*       Function...:   HandleEvents
*
*       Description:   .
*
*-------------------------------------------------------------------*/
INT CommDevice::HandleEvents()
{
    INT err = ErrNO_ERROR;
    PEvent event = (PEvent)NULL;
    
    if (theEventIterator)
    {
        theEventIterator->Reset();
        event = (PEvent) &(theEventIterator->Current());
    }
    else
    {
        err = ErrRETRYING_COMM;
    }
    
    while (event && (err == ErrNO_ERROR))
    {
        PEvent tmp = (PEvent)NULL;
        
        if (theEventList && theEventIterator &&
            (theEventList->GetItemsInContainer() > 0))
        {
            // Remove the event before dispatching it to prevent
            // unwanted loops
            
            tmp = (PEvent) theEventIterator->Next();
            theEventList->Detach((RObj)*event);
            UpdateObj::Update(event);
            delete event;
            event = tmp;
        }
        else
        {
            err = ErrRETRYING_COMM;
        }
    }
    return err;
}
/*--------------------------------------------------------------------
*
*       Function...:   Poll
*
*       Description:   .
*
*-------------------------------------------------------------------*/
INT  CommDevice::Poll() 
{
    time_t ElapsedTime = time((time_t*)NULL);
    List *newmsglist = (List*)NULL;
    INT err = ErrNO_ERROR;
    
    
    if ( (theSleepingFlag == FALSE) && (theCurrentTransaction) && (err == ErrNO_ERROR))
    {
        if(pollStartTime ==0)
        {
            pollStartTime = time((time_t*)NULL);
        }
        
        Access();
        PTransactionGroup transactionGroup = theCurrentTransaction;
        
        PMessage msg = (PMessage) transactionGroup->GetProtocolMessageList()->GetHead();
        
        if ((theState == COMM_STOPPED) || (theState == PAUSE_POLLING))
        {
            // sleep and let the CPU get a break, maybe things will be ;
            // better when we wake up.;
            theSleepingFlag = TRUE;
        }
        else
        {
            // If there are no comm problems;
            AskUps(msg); // Should this be there ???;
            theAbortSem->TimedWait(500);
            
            if (msg->getErrcode() == ErrCOMMUNICATION_LOST)
            {
                theCurrentTransaction = (PTransactionGroup)NULL;
            }
            else
            {
                List* msglist = (List*)NULL;
                
                
                if (msg->getResponse())
                {
                    theProtocol->SetCurrentTransactionGroup(theCurrentTransaction);
                    theProtocol->InterpretMessage(msg, theEventList, msglist);
                    
                    if (msglist)
                    {
                        SubmitList(msglist);
                    }
                    
                    PList a_list = transactionGroup->GetTransactionItemList();
                    ListIterator itemIter(*a_list);
                    
                    for (INT i = 0; i < a_list->GetItemsInContainer(); i++)
                    {
                        RTransactionItem transItem = (RTransactionItem)itemIter.Current();
                        // Check transItem for NULL.  We have to check the address because
                        // the previous call returns a reference instead of a pointer.
                        // Fixes bug #227550
                        if ((&transItem!=NULL) && (!(transItem.GetErrorCode())))
                        {
                            Event event(transItem.GetCode(), transItem.GetValue());
                            UpdateObj::Update(&event);
                        }
                        itemIter++;
                    }
                }
                
                // Clean out old errors and responses;
                
                msg->setErrcode(ErrNO_ERROR);
                
                PTransactionGroup tmp = (PTransactionGroup)thePollIterator->Next();
                
                if (tmp == (PTransactionGroup)NULL)
                {
                    thePollIterator->Reset();
                    theCurrentTransaction = (PTransactionGroup)thePollList->GetHead();
                    theSleepingFlag = TRUE;
                    thePollIsDone   = TRUE;
                }
                else
                {
                    theCurrentTransaction = tmp;
                }
            }
        }
        
        msg->ReleaseResponse();
        Release();
        
        if ((err == ErrNO_ERROR) && theEventList && theEventList->GetItemsInContainer())
        {
            err = HandleEvents();
            theAbortSem->TimedWait(250);
        }
    }
    else if (theCurrentTransaction == NULL)
    {
        //      puts("No transactions to process");
    }
    
    // Give up CPU
    _theTimerManager->Wait(0L);
    
    theAbortSem->TimedWait(250);
    if (theSleepingFlag == TRUE)
    {
        ULONG elapsed = (ULONG)(time((time_t*)NULL) - pollStartTime);
        
        if (elapsed > (ULONG)thePollInterval)
        {
            theSleepingFlag = FALSE;
        }
        else
        {
            theAbortSem->TimedWait(1000 * ((thePollInterval - elapsed)+ 1));
        }
        // for single-threaded apps, this is used outside here,
        // and set externally
        
        pollStartTime = 0;
    }
    return err;
}

//-------------------------------------------------------------------

VOID CommDevice::StartPollThread ()
{
    // Create a thread which will poll the server at a regular interval
    // for updated information on events in the poll list
    PollLoop *pollLoop = new PollLoop (this);
    thePollThread = new Thread (pollLoop);

    if (thePollThread != NULL) {
      thePollThread->Start();
    }
}

VOID CommDevice::OkToPoll ()
{
    if (!thePollThread) {
        StartPollThread();
    }
    
    //
    // We must give up the CPU here to allow the poll thread to start running.
    // Otherwise we release the poll thread before we call wait, leaving the
    // wait to hang
    //
    _theTimerManager->Wait(500L);
    
    if (thePollThread) {
        thePollThread->Release();
    }
}

VOID CommDevice::Access()
{
    theAskLock->Request();
}

VOID CommDevice::Release()
{
    theAskLock->Release();
}

/*****************************************************************************
*
* PollLoop::ThreadMain is run within a seperate thread.  It's purpose is to
* periodically look at the events on the poll list and ask the server for
* updated information on each event.
*
****************************************************************************/
PollLoop::PollLoop (PCommDevice aDevice)
: theDevice (aDevice)
{
    SetThreadName("APC UPS Polling");
}


PollLoop::~PollLoop ()
{
}


VOID PollLoop::ThreadMain () {
    // Wait for the thread to be released to start polling
    
    Wait();
    
    while (ExitNow() == FALSE) {
        
        if(theDevice->HasLostComm())  {
            TimedWait(5000);
        }
        else {
            theDevice->Poll();
        }
    }
    DoneExiting();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\chgsensr.h ===
/*
 * REVISIONS:
 *  djs08May96   Created
 */
 
#ifndef __CHGSENSOR_H
#define __CHGSENSOR_H

#include "stsensor.h"
#include "isa.h"

_CLASSDEF(ChangeSensor)

			  
class ChangeSensor : public StateSensor {

protected:

public:
	ChangeSensor(PDevice aParent, 
                PCommController aCommController, 
                INT aSensorCode = NO_SENSOR_CODE, 
                INT anUpperEventCode = NO_CODE,
                INT aLowerEventCode = NO_CODE,
                ACCESSTYPE anACCESSTYPE = AREAD_ONLY);

//overidden interfaces

	virtual INT Validate(INT, const PCHAR);

 private:

   INT theUpperEventCode;
   INT theLowerEventCode;
   INT theValidationCheckingEnabled;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\cfgmgr.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy11Dec92: Added extern _theConfigManager so others can use me.
 *  hw12Dec92:  Added structure _ConfigItemList_T.
 *  rct19Jan93: Overloaded some methods...took out itemCodeList
 *  rct26Jan93: Added remove methods
 *  tje15Mar93: Made ConfigManager an abstract base class to support multiple types of cfgmgr's
 *  pcy09Sep93: cfgmgr should be an obj to allow object status returns
 *  cad04Mar94: added remove and rename for components 
 *  pav02Jul96: Added Item to handle lists (i.e. - SmartScheduling)
 *  mholly06Oct98   : Discontinue use of a cache
 */

#ifndef _INC__CFGMGR_H
#define _INC__CFGMGR_H

#include "_defs.h"
#include "list.h"
#include "cfgcodes.h"
#include "icodes.h"

//
// Defines
//

_CLASSDEF(ConfigManager)
_CLASSDEF(IniConfigManager)

//
// Uses
//

_CLASSDEF(TAttribute)
_CLASSDEF(List)

extern PConfigManager _theConfigManager;

//
// _ConfigItemList_T is struct used as the entries in
// the ConfigItemList defined in stdcfg.cxx
// ConfigItemList contains the default values for
// items that can come from the ConfigManager
//
#define LAST_ENTRY   -1

struct _ConfigItemList_T {
   INT      code;
   PCHAR    componentName;
   PCHAR    itemName;
   PCHAR    defaultValue;
};


class ConfigManager : public Obj {

public:
	ConfigManager();

	virtual INT Get( INT, PCHAR ) = 0;
//++srb
  //virtual INT   Set( INT, PCHAR ) = 0;

    virtual INT	GetListValue( PCHAR, PCHAR, PCHAR ) = 0;
protected:
    virtual _ConfigItemList_T * getItemCode( INT aCode ) = 0;
    virtual _ConfigItemList_T * getItemCode( PCHAR aComponent, PCHAR anItem ) = 0;
};

class IniConfigManager : public ConfigManager {

public:
    IniConfigManager();
    virtual ~IniConfigManager();
    
    INT Get( INT, PCHAR );
//++srb
    //INT   Set( INT, PCHAR );

    INT	GetListValue( PCHAR, PCHAR, PCHAR );

private:
    _ConfigItemList_T * getItemCode( INT aCode );
    _ConfigItemList_T * getItemCode( PCHAR aComponent, PCHAR anItem );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\cfgcodes.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy16Dec92: Initial implementation
 *  ane29Dec92: Added CFG_HOST_NAME
 *  pcy15Jan92: CFG_HOST_NAME already existed and fixed numbering on scripts
 *  rct07Feb93: Added pager cfgcodes
 *  rct21Apr93: Fixed a sequencing problem
 *  jod05Apr93: Added changes for Deep Discharge
 *  pcy21May93: Added Battery date stuff
 *  cad10Jun93: Added MEasureUPS threshold codes
 *  rct29Jun93: Added code for PF msg w/ Batt RT disabled
 *  cad12Oct93: Added codes for front end colors
 *  cad24Jan94: added flex event stuff
 *  pcy28Jan94: added more flex event stuff
 *  cad08Jan94: removed run time enabled stuff, ups model support
 *  rct28Feb94: added mailing codes
 *  cad04Mar94: added allowed port names
 *  cad16Mar94: added modem stuff
 *  ajr10Jun94: Added LowBatShutdownType code
 *  ajr22Aug94: added mups enabled flag
 *  dml25Apr95: Added SMS Mif file codes
 *  djs20May95: Added DarkStar codes
 *  ntf11Jun96: Added codes CFG_LEFT_BARGRAPH, ... CFG_RIGHT_BARGRAPH
 *  pam03Jul96: Added codes CFG_COMM_RPC, CFG_COMM_TCPIP, CFG_COMM_IPXSPX
 *  das01Aug96: Added codes CFG_IGNORE_APPS_LIST, CFG_CABLE_TYPE,
 *              CFG_NOTIFY_DELAY, CFG_NOTIFY_INTERVAL, CFG_NOTIFY_ACTIONS,
 *              CFG_NOTIFY_SHUTDOWN_DELAY 
 *  tjg21Oct96: Added Help File codes (CFG_HELP_VIEWER and CFG_HELP_VIEWER
 *  mwh29Aug97: add finder interval codes
 *  mds29Dec97: Added CFG_SHARE_UPS_CONFIRMED_MODE_ENABLED 
 *  daharoni05Feb99: Added CFG_COMMAND_FILE_SHOW_WINDOW
 */

#ifndef __CFGCODES_H
#define __CFGCODES_H

#define CFG_ITEMS                               0
#define CFG_GROUPS                              10000

//
// Items
//
#define CFG_UPS_SIGNALLING_TYPE                 (CFG_ITEMS + 1)
#define CFG_UPS_PORT_NAME                       (CFG_ITEMS + 2)
#define CFG_UPS_PORT_TYPE                       (CFG_ITEMS + 3)
#define CFG_UPS_PROTOCOL                        (CFG_ITEMS + 4)
#define CFG_UPS_MAX_BATTERY_RUN_TIME            (CFG_ITEMS + 5)

#ifdef MULTI_SERVER_SUPPORT    
#define CFG_UPS_SLAVE_ENABLED                   (CFG_ITEMS + 6)
#define CFG_UPS_MASTER_NAME                     (CFG_ITEMS + 7)
#endif

#define CFG_EVENT_LOG_ENABLED                   (CFG_ITEMS + 8)
#define CFG_EVENT_LOG_NAME                      (CFG_ITEMS + 9)
#define CFG_EVENT_LOG_MAX_SIZE                  (CFG_ITEMS + 10)
#define CFG_EVENT_LOG_ROLL_PCT                  (CFG_ITEMS + 11)

#define CFG_DATA_LOG_ENABLED                    (CFG_ITEMS + 12)
#define CFG_DATA_LOG_NAME                       (CFG_ITEMS + 13)
#define CFG_DATA_LOG_MAX_SIZE                   (CFG_ITEMS + 14)
#define CFG_DATA_LOG_INTERVAL                   (CFG_ITEMS + 15)
#define CFG_DATA_LOG_ROLL_PCT                   (CFG_ITEMS + 16)

#define CFG_MESSAGE_DELAY                       (CFG_ITEMS + 17)
#define CFG_MESSAGE_INTERVAL                    (CFG_ITEMS + 18)
#define CFG_POWER_FAIL_MSG                      (CFG_ITEMS + 19)
#define CFG_POWER_RETURN_MSG                    (CFG_ITEMS + 20)
#define CFG_LOW_BATTERY_MSG                     (CFG_ITEMS + 21)
#define CFG_RUN_TIME_EXPIRED_MSG                (CFG_ITEMS + 22)
#define CFG_SHUTDOWN_MSG                        (CFG_ITEMS + 23)


#define CFG_ENABLE_SELF_TESTS                   (CFG_ITEMS + 24)
#define CFG_SELF_TEST_SCHEDULE                  (CFG_ITEMS + 25)
#define CFG_SELF_TEST_DAY                       (CFG_ITEMS + 26)
#define CFG_SELF_TEST_TIME                      (CFG_ITEMS + 27)
#define CFG_SELF_TEST_RESULT                    (CFG_ITEMS + 28)
#define CFG_LAST_SELF_TEST_RESULT               (CFG_ITEMS + 29)
#define CFG_LAST_SELF_TEST_DAY                  (CFG_ITEMS + 30)

#define CFG_LOW_BATTERY_SHUTDOWN_DELAY          (CFG_ITEMS + 31)
#define CFG_ADMIN_SHUTDOWN_DELAY                (CFG_ITEMS + 32)
#define CFG_DAILY_SHUTDOWN_ENABLED              (CFG_ITEMS + 33)
#define CFG_DAILY_SHUTDOWN_TIME                 (CFG_ITEMS + 34)
#define CFG_DAILY_WAKE_UP_TIME                  (CFG_ITEMS + 35)
#define CFG_WEEKLY_SHUTDOWN_ENABLED             (CFG_ITEMS + 36)
#define CFG_WEEKLY_SHUTDOWN_DAY                 (CFG_ITEMS + 37)
#define CFG_WEEKLY_SHUTDOWN_TIME                (CFG_ITEMS + 38)
#define CFG_WEEKLY_WAKEUP_DAY                   (CFG_ITEMS + 39)
#define CFG_WEEKLY_WAKEUP_TIME                  (CFG_ITEMS + 40)


#define CFG_SERVER_BINDERY_ADDRESS              (CFG_ITEMS + 41)
#define CFG_BINDERY_RESPONSE_ADDRESS            (CFG_ITEMS + 42)
#define CFG_CLIENT_ADDRESS                      (CFG_ITEMS + 43)
#define CFG_ALERT_ADDRESS                       (CFG_ITEMS + 44)
#define CFG_LOCAL_BINDERY_ADDRESS               (CFG_ITEMS + 45)
#define CFG_HOST_NAME                           (CFG_ITEMS + 46)


#define CFG_HUMIDITY_ENABLED_LOW_THRESHOLD      (CFG_ITEMS + 47)
#define CFG_HUMIDITY_ENABLED_HIGH_THRESHOLD     (CFG_ITEMS + 48)
#define CFG_HUMIDITY_VALUE_LOW_THRESHOLD        (CFG_ITEMS + 49)
#define CFG_HUMIDITY_VALUE_HIGH_THRESHOLD       (CFG_ITEMS + 50)


#define CFG_TEMPERATURE_UNITS                   (CFG_ITEMS + 51)
#define CFG_SOUND_EFFECTS                       (CFG_ITEMS + 52)

#define CFG_FREQUENCY_VALUE_HIGH_THRESHOLD      (CFG_ITEMS + 53)
#define CFG_FREQUENCY_VALUE_LOW_THRESHOLD       (CFG_ITEMS + 54)
#define CFG_FREQUENCY_ENABLED_HIGH_THRESHOLD    (CFG_ITEMS + 55)
#define CFG_FREQUENCY_ENABLED_LOW_THRESHOLD     (CFG_ITEMS + 56)

#define CFG_LINE_VOLTAGE_VALUE_HIGH_THRESHOLD   (CFG_ITEMS + 57)
#define CFG_LINE_VOLTAGE_VALUE_LOW_THRESHOLD    (CFG_ITEMS + 58)
#define CFG_LINE_VOLTAGE_ENABLED_HIGH_THRESHOLD (CFG_ITEMS + 59)
#define CFG_LINE_VOLTAGE_ENABLED_LOW_THRESHOLD  (CFG_ITEMS + 60)

#define CFG_MAX_LINEV_VALUE_HIGH_THRESHOLD      (CFG_ITEMS + 61)
#define CFG_MAX_LINEV_VALUE_LOW_THRESHOLD       (CFG_ITEMS + 62)
#define CFG_MAX_LINEV_ENABLED_HIGH_THRESHOLD    (CFG_ITEMS + 63)
#define CFG_MAX_LINEV_ENABLED_LOW_THRESHOLD     (CFG_ITEMS + 64)

#define CFG_MIN_LINEV_VALUE_HIGH_THRESHOLD      (CFG_ITEMS + 65)
#define CFG_MIN_LINEV_VALUE_LOW_THRESHOLD       (CFG_ITEMS + 66)
#define CFG_MIN_LINEV_ENABLED_HIGH_THRESHOLD    (CFG_ITEMS + 67)
#define CFG_MIN_LINEV_ENABLED_LOW_THRESHOLD     (CFG_ITEMS + 68)

#define CFG_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD    (CFG_ITEMS + 69)
#define CFG_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD     (CFG_ITEMS + 70)
#define CFG_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD  (CFG_ITEMS + 71)
#define CFG_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD   (CFG_ITEMS + 72)

#define CFG_UPS_LOAD_VALUE_HIGH_THRESHOLD       (CFG_ITEMS + 73)
#define CFG_UPS_LOAD_VALUE_LOW_THRESHOLD        (CFG_ITEMS + 74)
#define CFG_UPS_LOAD_ENABLED_HIGH_THRESHOLD     (CFG_ITEMS + 75)
#define CFG_UPS_LOAD_ENABLED_LOW_THRESHOLD      (CFG_ITEMS + 76)

#define CFG_UPS_TEMP_VALUE_HIGH_THRESHOLD       (CFG_ITEMS + 77)
#define CFG_UPS_TEMP_VALUE_LOW_THRESHOLD        (CFG_ITEMS + 78)
#define CFG_UPS_TEMP_ENABLED_HIGH_THRESHOLD     (CFG_ITEMS + 79)
#define CFG_UPS_TEMP_ENABLED_LOW_THRESHOLD      (CFG_ITEMS + 80)

#define CFG_ALLOWED_ALARM_DELAYS                (CFG_ITEMS + 81)
#define CFG_ALLOWED_HIGH_TRANSFER_VOLTAGES      (CFG_ITEMS + 82)
#define CFG_ALLOWED_LOW_TRANSFER_VOLTAGES       (CFG_ITEMS + 83)
#define CFG_ALLOWED_LOW_BATTERY_DURATIONS       (CFG_ITEMS + 84)
#define CFG_ALLOWED_MIN_RETURN_CAPACITIES       (CFG_ITEMS + 85)
#define CFG_ALLOWED_RATED_OUTPUT_VOLTAGES       (CFG_ITEMS + 86)
#define CFG_ALLOWED_SELF_TEST_SCHEDULES         (CFG_ITEMS + 87)
#define CFG_ALLOWED_SHUTDOWN_DELAYS             (CFG_ITEMS + 88)
#define CFG_ALLOWED_TURN_OFF_DELAYS             (CFG_ITEMS + 89)
#define CFG_ALLOWED_TURN_ON_DELAYS              (CFG_ITEMS + 90)
#define CFG_ALLOWED_SENSITIVITIES               (CFG_ITEMS + 91)

#define CFG_LAST_BATTERY_CALIBRATION_DATE       (CFG_ITEMS + 92)
#define CFG_LAST_BATTERY_CALIBRATION_RESULT     (CFG_ITEMS + 93)
#define CFG_BATTERY_CALIBRATION_DAY             (CFG_ITEMS + 94)
#define CFG_BATTERY_CALIBRATION_ENABLED         (CFG_ITEMS + 95)
#define CFG_FAIL_SCRIPT                         (CFG_ITEMS + 96)
#define CFG_RETURN_SCRIPT                       (CFG_ITEMS + 97)
#define CFG_LOWBATT_SCRIPT                      (CFG_ITEMS + 98)
#define CFG_BATTGOOD_SCRIPT                     (CFG_ITEMS + 99)
#define CFG_RTE_SCRIPT                          (CFG_ITEMS + 100)
#define CFG_SHUTDOWN_SCRIPT                     (CFG_ITEMS + 101)
#define CFG_LOSTCOM_SCRIPT                      (CFG_ITEMS + 102)
#define CFG_BTESTFAIL_SCRIPT                    (CFG_ITEMS + 103)
#define CFG_POWERRETURN_SCRIPT                  (CFG_ITEMS + 104)

#define CFG_BATTERY_RUN_TIME_ENABLED            (CFG_ITEMS + 105)

#define CFG_ERROR_LOG_ENABLED                   (CFG_ITEMS + 106)
#define CFG_ERROR_LOG_NAME                      (CFG_ITEMS + 107)
#define CFG_ERROR_LOG_MAX_SIZE                  (CFG_ITEMS + 108)
#define CFG_ERROR_LOG_ROLL_PCT                  (CFG_ITEMS + 109)

#define CFG_LINECOND_ENABLED                    (CFG_ITEMS + 110)
#define CFG_LINECOND_MESSAGE                    (CFG_ITEMS + 111)
#define CFG_LINECOND_DELAY                      (CFG_ITEMS + 112)

#define CFG_BATTCOND_ENABLED                    (CFG_ITEMS + 113)
#define CFG_BATTCOND_MESSAGE                    (CFG_ITEMS + 114)
#define CFG_BATTCOND_DELAY                      (CFG_ITEMS + 115)

#define CFG_COMMCOND_ENABLED                    (CFG_ITEMS + 116)
#define CFG_COMMCOND_MESSAGE                    (CFG_ITEMS + 117)
#define CFG_COMMCOND_DELAY                      (CFG_ITEMS + 118)

#define CFG_HOSTCOND_ENABLED                    (CFG_ITEMS + 119)
#define CFG_HOSTCOND_MESSAGE                    (CFG_ITEMS + 120)
#define CFG_HOSTCOND_DELAY                      (CFG_ITEMS + 121)

#define CFG_DEVICE_BOARD                        (CFG_ITEMS + 122)
#define CFG_DEVICE_PORT                         (CFG_ITEMS + 123)
#define CFG_DEVICE_HARDWARE_TYPE                (CFG_ITEMS + 124)

#define CFG_PAGER_ENABLED                       (CFG_ITEMS + 125)
#define CFG_PAGER_DELAY                         (CFG_ITEMS + 126)
#define CFG_PAGER_RETRIES                       (CFG_ITEMS + 127)
#define CFG_PAGER_SERVICE_LIST                  (CFG_ITEMS + 128)
#define CFG_MODEM_DRIVER_TYPE                   (CFG_ITEMS + 129)
#define CFG_MODEM_PORT_NUMBER                   (CFG_ITEMS + 130)
#define CFG_MODEM_BOARD_NUMBER                  (CFG_ITEMS + 131)
#define CFG_MODEM_INIT_STRING                   (CFG_ITEMS + 132)
#define CFG_MODEM_BAUD_RATE                     (CFG_ITEMS + 133)
#define CFG_MODEM_ALLOWED_BAUD_RATES            (CFG_ITEMS + 134)
#define CFG_MODEM_PORT_NAME                     (CFG_ITEMS + 135)
#define CFG_MODEM_DIAL_TYPE                     (CFG_ITEMS + 136)

#define CFG_MAIL_DELAY                         (CFG_ITEMS + 137)

#define CFG_POPUPS_ENABLED                      (CFG_ITEMS + 138)
#define CFG_AUTO_UPS_REBOOT_ENABLED		         (CFG_ITEMS + 139)

#define CFG_MUPS_CONTACT1_DEFAULT               (CFG_ITEMS + 140)
#define CFG_MUPS_CONTACT2_DEFAULT               (CFG_ITEMS + 141)
#define CFG_MUPS_CONTACT3_DEFAULT               (CFG_ITEMS + 142)
#define CFG_MUPS_CONTACT4_DEFAULT               (CFG_ITEMS + 143)
#define CFG_MUPS_CONTACT1_DESCRIPTION           (CFG_ITEMS + 144)
#define CFG_MUPS_CONTACT2_DESCRIPTION           (CFG_ITEMS + 145)
#define CFG_MUPS_CONTACT3_DESCRIPTION           (CFG_ITEMS + 146)
#define CFG_MUPS_CONTACT4_DESCRIPTION           (CFG_ITEMS + 147)
#define CFG_MUPS_CONTACT1_ENABLED               (CFG_ITEMS + 148)
#define CFG_MUPS_CONTACT2_ENABLED               (CFG_ITEMS + 149)
#define CFG_MUPS_CONTACT3_ENABLED               (CFG_ITEMS + 150)
#define CFG_MUPS_CONTACT4_ENABLED               (CFG_ITEMS + 151)


//#define CFG_FIRST_BARGRAPH                      (CFG_ITEMS + 152)

#define CFG_BATTERY_RUN_TIME_VALUE_LOW_THRESHOLD      (CFG_ITEMS + 153)
#define CFG_BATTERY_RUN_TIME_VALUE_HIGH_THRESHOLD     (CFG_ITEMS + 154)

#define CFG_BATTERY_CALIBRATION_TIME             (CFG_ITEMS + 155)    
#define CFG_BATTERY_REPLACEMENT_DATE             (CFG_ITEMS + 156)    
#define CFG_BATTERY_AGE_LIMIT                    (CFG_ITEMS + 157)    

#define CFG_BATTVOLT_VALUE_HIGH_THRESHOLD      (CFG_ITEMS + 158)
#define CFG_BATTVOLT_VALUE_LOW_THRESHOLD       (CFG_ITEMS + 159)
#define CFG_BATTVOLT_ENABLED_HIGH_THRESHOLD    (CFG_ITEMS + 160)
#define CFG_BATTVOLT_ENABLED_LOW_THRESHOLD     (CFG_ITEMS + 161)

#define CFG_AMB_TEMP_VALUE_HIGH_THRESHOLD       (CFG_ITEMS + 162)
#define CFG_AMB_TEMP_VALUE_LOW_THRESHOLD        (CFG_ITEMS + 163)
#define CFG_AMB_TEMP_ENABLED_HIGH_THRESHOLD     (CFG_ITEMS + 164)
#define CFG_AMB_TEMP_ENABLED_LOW_THRESHOLD      (CFG_ITEMS + 165)

#define CFG_UNLIMITED_POWER_FAIL_MSG            (CFG_ITEMS + 166)
#define CFG_BRDCAST_ENABLED                     (CFG_ITEMS + 167)   
#define CFG_PREPARE_SHUTDOWN_MSG                (CFG_ITEMS + 168)
#define CFG_FINAL_SHUTDOWN_MSG                  (CFG_ITEMS + 169)
#define CFG_CANCEL_SHUTDOWN_MSG                 (CFG_ITEMS + 170)
#define CFG_SERVER_PAUSE_ENABLED                (CFG_ITEMS + 171)
#define CFG_UPS_POLL_INTERVAL                   (CFG_ITEMS + 172)

#define CFG_COMMAND_FILE_DELAY                  (CFG_ITEMS + 173)
#define CFG_SHUTDOWN_DELAY                      (CFG_ITEMS + 174)
#define CFG_NOTIFY_TYPE                         (CFG_ITEMS + 175)
#define CFG_MESSAGE_USER_LIST                   (CFG_ITEMS + 176)

#define CFG_NET_SOCKET_ADDRESS_DATA             (CFG_ITEMS + 177)
#define CFG_NET_SOCKET_ADDRESS_ALERT            (CFG_ITEMS + 178)
#define CFG_NET_SOCKET_ADDRESS_BINDERY          (CFG_ITEMS + 179)
#define CFG_PROCESS_SLEEP_CYCLE                 (CFG_ITEMS + 180)

#define CFG_UPS_TURN_OFF_DELAY                  (CFG_ITEMS + 181)
#define CFG_NOTIFY_USER_LIST                    (CFG_ITEMS + 182)
#define CFG_ADMIN_NOTIFY_USER_LIST              (CFG_ITEMS + 183)
#define CFG_ALLOWED_NOTIFY_TYPES                (CFG_ITEMS + 184)
#define CFG_PAGE_USER_LIST                      (CFG_ITEMS + 185)
#define CFG_EMAIL_USER_LIST                     (CFG_ITEMS + 186)
#define CFG_NOTIFIABLE_USERS                    (CFG_ITEMS + 187)
#define CFG_PAGEABLE_USERS                      (CFG_ITEMS + 188)
#define CFG_EMAILABLE_USERS                     (CFG_ITEMS + 189)
#define CFG_FLEX_USERS                          (CFG_ITEMS + 190)
#define CFG_BKFTOK_ID                           (CFG_ITEMS + 191)
#define CFG_UPSOFF_FILE                         (CFG_ITEMS + 192)
#define CFG_UPSOFF_PATH                         (CFG_ITEMS + 193)

#define CFG_EMAIL_ENABLED                       (CFG_ITEMS + 194)
#define CFG_EMAIL_DELAY                         (CFG_ITEMS + 195)
#define CFG_EMAIL_FILE_PATH                     (CFG_ITEMS + 196)
#define CFG_EMAIL_LOGIN_NAME                    (CFG_ITEMS + 197)

#define CFG_ALLOWED_PORT_NAMES                  (CFG_ITEMS + 198)

#define CFG_MODEM_ENABLED                       (CFG_ITEMS + 199)

#define CFG_NLM_SAP_ENABLED                     (CFG_ITEMS + 200)
#define CFG_NLM_RUN_PRIORITY                    (CFG_ITEMS + 201)
#define CFG_NLM_EXIT_AFTER_DOWN                 (CFG_ITEMS + 202)

#define CFG_EMAIL_PASSWORD                      (CFG_ITEMS + 203)
#define CFG_EMAIL_HEADER                        (CFG_ITEMS + 204)
#define CFG_EMAIL_TYPE                          (CFG_ITEMS + 205)

#define CFG_ALLOWED_RUN_TIMES_AFTER_LOW_BATTERY (CFG_ITEMS + 206)
#define CFG_LOWBAT_SHUTDOWN_TYPE                (CFG_ITEMS + 207)

#define CFG_SERVER_SECURITY                     (CFG_ITEMS + 208)
#define CFG_GENERATE_MIF_FILE                   (CFG_ITEMS + 209)

#define CFG_MUPS_ENABLED                        (CFG_ITEMS + 210)
#define CFG_MIF_DIRECTORY                       (CFG_ITEMS + 211)
#define CFG_MACRO_FILE_NAME                     (CFG_ITEMS + 212)

#define CFG_SERVER_NETVIEW			(CFG_ITEMS + 213)
#define CFG_NLM_SPX_TIMEOUT                     (CFG_ITEMS + 214)
#define CFG_UPS_SERVER_RESP_TIMEOUT             (CFG_ITEMS + 215)

#define CFG_NET_TCP_SOCKET_ADDRESS_POLL         (CFG_ITEMS + 216)
#define CFG_NET_TCP_SOCKET_ADDRESS_ALERT        (CFG_ITEMS + 217)
#define CFG_NET_TCP_SOCKET_ADDRESS_BINDERY      (CFG_ITEMS + 218)
#define CFG_NET_SPX_SOCKET_ADDRESS_POLL         (CFG_ITEMS + 219)
#define CFG_NET_SPX_SOCKET_ADDRESS_ALERT        (CFG_ITEMS + 220)
#define CFG_NET_SPX_SOCKET_ADDRESS_BINDERY      (CFG_ITEMS + 221)

#if (C_OS & C_NLM)
#define CFG_NLM_OVERRIDE_SIGNAL                 (CFG_ITEMS + 222)
#endif

#define CFG_PHASE_A_INPUT_VOLTAGE_VALUE_HIGH_THRESHOLD       (CFG_ITEMS + 223)
#define CFG_PHASE_A_INPUT_VOLTAGE_VALUE_LOW_THRESHOLD        (CFG_ITEMS + 224)
#define CFG_PHASE_A_INPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD     (CFG_ITEMS + 225)
#define CFG_PHASE_A_INPUT_VOLTAGE_ENABLED_LOW_THRESHOLD      (CFG_ITEMS + 226)
#define CFG_PHASE_B_INPUT_VOLTAGE_VALUE_HIGH_THRESHOLD       (CFG_ITEMS + 227)
#define CFG_PHASE_B_INPUT_VOLTAGE_VALUE_LOW_THRESHOLD        (CFG_ITEMS + 228)
#define CFG_PHASE_B_INPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD     (CFG_ITEMS + 229)
#define CFG_PHASE_B_INPUT_VOLTAGE_ENABLED_LOW_THRESHOLD      (CFG_ITEMS + 230)
#define CFG_PHASE_C_INPUT_VOLTAGE_VALUE_HIGH_THRESHOLD       (CFG_ITEMS + 231)
#define CFG_PHASE_C_INPUT_VOLTAGE_VALUE_LOW_THRESHOLD        (CFG_ITEMS + 232)
#define CFG_PHASE_C_INPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD     (CFG_ITEMS + 233)
#define CFG_PHASE_C_INPUT_VOLTAGE_ENABLED_LOW_THRESHOLD      (CFG_ITEMS + 234)
#define CFG_PHASE_A_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD      (CFG_ITEMS + 235)
#define CFG_PHASE_A_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD       (CFG_ITEMS + 236)
#define CFG_PHASE_A_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD    (CFG_ITEMS + 237)
#define CFG_PHASE_A_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD     (CFG_ITEMS + 238)
#define CFG_PHASE_B_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD      (CFG_ITEMS + 239)
#define CFG_PHASE_B_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD       (CFG_ITEMS + 240)
#define CFG_PHASE_B_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD    (CFG_ITEMS + 241)
#define CFG_PHASE_B_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD     (CFG_ITEMS + 242)
#define CFG_PHASE_C_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD      (CFG_ITEMS + 243)
#define CFG_PHASE_C_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD       (CFG_ITEMS + 244)
#define CFG_PHASE_C_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD    (CFG_ITEMS + 245)
#define CFG_PHASE_C_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD     (CFG_ITEMS + 246)

#define CFG_FIRST_BARGRAPH                      (CFG_ITEMS + 250)
#define CFG_SECOND_BARGRAPH                     (CFG_ITEMS + 251)
#define CFG_THIRD_BARGRAPH                      (CFG_ITEMS + 252)

#define CFG_COMM_RPC                            (CFG_ITEMS + 253)
#define CFG_COMM_TCPIP                          (CFG_ITEMS + 254)
#define CFG_COMM_IPXSPX                         (CFG_ITEMS + 255)

#define CFG_PREPARE_FOR_SHUTDOWN_DELAY          (CFG_ITEMS + 256) 
#define CFG_DATASAFE_ENABLED                    (CFG_ITEMS + 257)
#define CFG_SHUTDOWN_SOON_MSG					(CFG_ITEMS + 258)     
#define CFG_APP_SHUTDOWN_TIMER			        (CFG_ITEMS + 259)
#define CFG_CABLE_TYPE                          (CFG_ITEMS + 260)
#define CFG_IGNORE_APPS_LIST                    (CFG_ITEMS + 261)  
#define CFG_NOTIFY_DELAY                        (CFG_ITEMS + 262)
#define CFG_NOTIFY_INTERVAL                     (CFG_ITEMS + 263)
#define CFG_NOTIFY_SHUTDOWN_DELAY               (CFG_ITEMS + 264)
#define CFG_NOTIFY_ACTIONS                      (CFG_ITEMS + 265)

#define CFG_COMM_RPC_FINDER_INTERVAL            (CFG_ITEMS + 266)
#define CFG_COMM_TCP_FINDER_INTERVAL            (CFG_ITEMS + 267)
#define CFG_COMM_IPX_FINDER_INTERVAL            (CFG_ITEMS + 268)
#define CFG_COMM_NP_FINDER_INTERVAL             (CFG_ITEMS + 268)

#define CFG_COMM_NP                             (CFG_ITEMS + 269)
		
#define CFG_COMMAND_FILE_SHOW_WINDOW			(CFG_ITEMS + 270)

#define CFG_COLOR_BASE                          (CFG_ITEMS + 300)

#define CFG_INDICATOR_COLOR                     (CFG_COLOR_BASE + 0)
#define CFG_BORDER_COLOR                        (CFG_COLOR_BASE + 1)
#define CFG_TICK_COLOR                          (CFG_COLOR_BASE + 2)
#define CFG_IN_RANGE_COLOR                      (CFG_COLOR_BASE + 3)
#define CFG_OUT_OF_RANGE_COLOR                  (CFG_COLOR_BASE + 4)
#define CFG_DATA_COLOR                          (CFG_COLOR_BASE + 5)
#define CFG_LABEL_COLOR                         (CFG_COLOR_BASE + 6)
#define CFG_DISABLED_COLOR                      (CFG_COLOR_BASE + 7)
#define CFG_WINDOW_COLOR                        (CFG_COLOR_BASE + 8)
#define CFG_LIGHT_SHADOW_COLOR                  (CFG_COLOR_BASE + 9)
#define CFG_DARK_SHADOW_COLOR                   (CFG_COLOR_BASE + 10)
#define CFG_STATUS_PANE_COLOR                   (CFG_COLOR_BASE + 11)
#define CFG_EVENT_PANE_COLOR                    (CFG_COLOR_BASE + 12)
#define CFG_ERROR_COLOR                         (CFG_COLOR_BASE + 13)
#define CFG_WARNING_COLOR                       (CFG_COLOR_BASE + 14)

#define CFG_UPS_MODEL_BASE                      (CFG_ITEMS + 400)
 
#define CFG_NONETWORK_FLAG                      (CFG_ITEMS + 401)
#define CFG_USE_TCP                             (CFG_ITEMS + 402)

#define CFG_HELP_VIEWER                         (CFG_ITEMS + 403)
#define CFG_HELP_FILENAME                       (CFG_ITEMS + 404)

#define CFG_EMAIL_SMTP_SERVER                   (CFG_ITEMS + 405)
#define CFG_EMAIL_SMTP_ACCOUNT                  (CFG_ITEMS + 406)
#define CFG_EMAIL_SMTP_DOMAIN                   (CFG_ITEMS + 407)

#define CFG_SHARE_UPS_CONFIRMED_MODE_ENABLED    (CFG_ITEMS + 408)


//
// Groups
//

#define CFG_TRANSPORTS                          (CFG_GROUPS + 1)
#define CFG_DEVICES                             (CFG_GROUPS + 2)
#define CFG_USERS                               (CFG_GROUPS + 3)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\cfgmgr.cxx ===
/*
 * REVISIONS:
 *  pcy11Dec92: Added apc.h, string.h, itemcode.h, and _theConfigManager
 *  ane11Dec92: Added os/2 include files
 *  hw12Dec92:  Added ConfigItemList structure and BuildItemCodes routine
 *  pcy17Dec92: Implemented Get's using a Code
 *  pcy17Dec92: Chnaged some defines in ItemCode list
 *  ane22Dec92: Added local bindery address constant
 *  ane23Dec92: Changed defaults for Lan Manager settings
 *  pcy27Dec92: Added some sensor codes
 *  ane05Jan93: Added slave codes
 *  rct01Jan93: Corrected some problems searching, cleaned things up
 *  ane18Jan93: Added roll percentage defaults
 *  rct26Jan93: Added Remove() methods
 *  rct09Feb93: Split out cfg items array (stdcfg.cxx)
 *  pcy18Feb93: Cast NULL's to appropriate types
 *  ajr11Mar93: Set default pwrchute_dir to /usr/lib/powerchute for unix
 *  tje12Mar93: Removed strDEFAULT_PWRCHUTE_DIR references
 *  tje13Mar93: Made ConfigManager abstract and added IniConfigManager class
 *  pcy09Sep93: Set object status to indicate ini file create failure
 *  rct03Mar94: fixed Get() for NoDefault case
 *  cad04Mar94: added remove and rename for components
 *  ajr09Mar94: Fixed logical check for ErrNO_ERORR and ErrDEFAULT_VALUE_USED
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  ajr28Apr94: Now striping trailing white spaces in the Get....
 *  mwh07Jun94: port for NCR
 *  pav02Jul96: Added Add to handle lists (i.e. - SmartScheduling)
 *  ntf22Aug97: Changed Component::GetItemValue to be more robust.
 *	awm02Oct97: Added a check to see whether the global _theConfigManager already existed before
 *				setting it equal to the config manager being created.  This is to support multiple
 *				config managers within the application
 *				Took out a line which set the global "_theConfigManager" to NULL in the destructor
 *				of the IniConfigManager.  This will have to be done manually when the config manager
 *				is destroyed in the main application.
 *  mholly06Oct98   : Discontinue use of a cache
 */

#include "cdefine.h"

extern "C" {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
}

#include "apc.h"
#include "cfgmgr.h"
#include "err.h"
#include "isa.h"


PConfigManager _theConfigManager = (PConfigManager)NULL;

extern struct _ConfigItemList_T ConfigItemList[];


/********************************************************************
 *
 * ConfigManager methods
 *
 ********************************************************************/

//-------------------------------------------------------------------
// Constructor

ConfigManager::ConfigManager()
{
}


/********************************************************************
 *
 * IniConfigManager methods
 *
 ********************************************************************/

//-------------------------------------------------------------------
// Constructor

IniConfigManager::IniConfigManager()
: ConfigManager()
{
    // If there is no configuration manager currently, 
    // then set the global this one.  Any others created 
    // subsequently will not have the global handle
    
    if (!_theConfigManager) {
        _theConfigManager = this;
    }
}

//-------------------------------------------------------------------
// Destructor

IniConfigManager::~IniConfigManager()
{
}


//-------------------------------------------------------------------
// Private member to return an item code given the component/item pair
_ConfigItemList_T * IniConfigManager::getItemCode(INT aCode)
{
    INT index = 0;
    
    while (ConfigItemList[index].code != aCode) {
        
        if (ConfigItemList[index].code == LAST_ENTRY) {
            return NULL;
        }
        index++;
    }    
    return &ConfigItemList[index];
}


_ConfigItemList_T * IniConfigManager::getItemCode(PCHAR aComponent, PCHAR anItem)
{
    INT index = 0;
    
    while ((_strcmpi(ConfigItemList[index].componentName, aComponent) != 0) ||
        (_strcmpi(ConfigItemList[index].itemName, anItem) != 0)) {
        
        if (ConfigItemList[index].code == LAST_ENTRY) {
            return NULL;
        }
        index++;
    }
    return &ConfigItemList[index];
}


//-------------------------------------------------------------------
INT IniConfigManager::Get(INT itemCode, PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    
    _ConfigItemList_T * search = getItemCode(itemCode);
    
    if (!search) {
        strcpy(aValue, "NoDefault");
        err =  ErrINVALID_ITEM_CODE;
    }
    else {
        strcpy(aValue, search->defaultValue);
    }
    return err;
}

//-------------------------------------------------------------------

//-------------------------------------------------------------------

INT IniConfigManager::GetListValue(PCHAR aComponent, PCHAR anItem, PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    _ConfigItemList_T * search = getItemCode(aComponent, anItem);
    
    if (search) {	
        strcpy(aValue, search->defaultValue);
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\codes.h ===
/*
 *  jod15Dec92: Added Keiths codes from kcodes.h
 *  jod16Dec92: Added RATED_LINE_VOLTAGE and HOST_SHUTDOWN
 *  ane16Dec92: Added shutdown and bindery constants
 *  ane11Jan93: Added SHUTDOWN_WAKEUP_TIME
 *  pcy19Jan93: Added MEASURE_UPS group stuff, and HOST_LOW_BATTERY_SHUTDOWN now
 *  jod28Jan93: Added SHUTDOWN_CONDITION   
 *  pcy21Apr93: OS2 FE merge
 *  pcy30Apr93: Added FRONT_END_HEIGHT, FRONT_END_WIDTH
 *  jod05Apr93: Added changes for Deep Discharge
 *  jod14May93: Added Matrix changes.
 *  cad04Aug93: Cleaned up/added host codes
 *  cad12Aug93: Added code to set comm port
 *  cad27Aug93: Added comm port and mups stuff and made one message interval
 *  cad16Sep93: Added timer pulse
 *  cad27Sep93: misc codes added, including FIXED_VALUE for graph thresholds
 *  cad07Oct93: Added cool codes
 *  cad29Oct93: server list change and delete codes
 *  cad08Dec93: Flex event codes
 *  cad19Jan94: more flex event codes
 *  cad24Jan94: added more
 *  pcy28Jan94: added more flex codes
 *  cad02Feb94: uflex event users
 *  cad08Jan94: removed run time enabled stuff
 *  rct28Feb94: email & paging codes
 *  pcy04Mar94: Added shutdowner message codes
 *  cad04Mar94: added user codes
 *  rct09Mar94: fixed some shutdowner stuff
 *  cad14Mar94: added AIO stuff
 *  cad16Mar94: added modem stuff
 *  cad28Mar94: added code to reset ups comm port
 *  cad07Apr94: fixed dupes, added reset to default stuff
 *  cad18Apr94: added modem code for wait for dial tone
 *  ajr10Jun94: Added a LOW_BATTERY shutdown code.
 *  dml13Sep95: added standalone code
 *  djs05Feb96: Added firmware rev codes
 *  djs07May96: Added Dark Star codes
 *  pcy04Jun96: Added Bridge Window Handle
 *  ntf11Jun96: Added LEFT_BAR_TYPE ... RIGHT_BAR_TYPE
 *  djs18Jun96: Moved firmware codes to the UPS obj
 *  ntf23Jun96: Changed LEFT... to FIRST, MIDDLE -> SECOND and RIGHT -> THIRD
 *  pcy28jun96: Added IS_ stuff for menus
 *  pam08Jul96: Added MORE_UPS_ATTRIBUTES, MORE_UPS_STATE_VALUES
 *  djs12Jul96: Added IS_ bar graph codes
 *  pam12Jul96: Added SERVER_PRODUCT_NAME, SERVER_VERSION, SERVER_PLATFORM
 *  srt19Dec96: Added COMPUTER_NAME
 *  srt04Jun97: Added IS_EXT_SLEEP_UPS
 *  tjg11Jul97: Added CURRENT_FIRMWARE_REV
 *  tjg03Sep97: Added Front End Version codes
 *  tjg05Sep97: Added EMAIL codes
 *  awm07Oct97: Added FLEX_EVENT_NAME_LIST
 *  awm14Oct97: Added Testing codes
 *  tjg10Nov97: Added IS_SMTP_EMAIL code
 *  awm22Nov97: Added FLEX_TEST_AVAILABLE
 *  tjg02Dec97: Changed IS_DARKSTAR to IS_SYMMETRA, changed MINIMUM_LOAD_CAPABILITY
 *              to MAX_LOAD... removed RIM_INSTALLATION_STATUS
 *  dma10Dec97: Resolved conflict between SPECIFIC_SMARTSCHEDULING and IS_SYMMETRA codes.
 *              Cleaned up look of the code.
 *  clk24Jun98: Added PENDING_EVENT to Internal
 *  mholly12May1999:  add TURN_OFF_SMART_MODE code 
 */ 

#ifndef __CODES_H
#define __CODES_H

#define NO_CODE                                 0


// ****** UPS STUFF ******
#define UPS                                     0
#define UPS_ATTRIBUTES                          0
#define UPS_STATES                              200
#define UPS_STATE_VALUES                        300
#define UPS_ACTIONS                             400
#define MORE_UPS_ATTRIBUTES                     500
#define MORE_UPS_STATE_VALUES                   700


// Attributes
#define TOTAL_BATTERY_PACKS                     (UPS + UPS_ATTRIBUTES + 1)
#define BAD_BATTERY_PACKS                       (UPS + UPS_ATTRIBUTES + 2)
#define TRANSFER_CAUSE                          (UPS + UPS_ATTRIBUTES + 3)
#define FIRMWARE_REV                            (UPS + UPS_ATTRIBUTES + 4)
#define RATED_BATTERY_VOLTAGE                   (UPS + UPS_ATTRIBUTES + 5)
#define BATTERY_CAPACITY                        (UPS + UPS_ATTRIBUTES + 6)
#define TRIP_REGISTER                           (UPS + UPS_ATTRIBUTES + 7)
#define DIP_SWITCH_POSITION                     (UPS + UPS_ATTRIBUTES + 8)
#define RUN_TIME_REMAINING                      (UPS + UPS_ATTRIBUTES + 9)
#define COPYRIGHT                               (UPS + UPS_ATTRIBUTES + 10)
#define BATTERY_VOLTAGE                         (UPS + UPS_ATTRIBUTES + 11)
#define UPS_TEMPERATURE                         (UPS + UPS_ATTRIBUTES + 12)
#define OUTPUT_FREQUENCY                        (UPS + UPS_ATTRIBUTES + 13)
#define LINE_VOLTAGE                            (UPS + UPS_ATTRIBUTES + 14)
#define MAX_LINE_VOLTAGE                        (UPS + UPS_ATTRIBUTES + 15)
#define MIN_LINE_VOLTAGE                        (UPS + UPS_ATTRIBUTES + 16)
#define OUTPUT_VOLTAGE                          (UPS + UPS_ATTRIBUTES + 17)
#define UPS_LOAD                                (UPS + UPS_ATTRIBUTES + 18)
#define EEPROM_RESET                            (UPS + UPS_ATTRIBUTES + 19)
#define EEPROM_DECREMENT                        (UPS + UPS_ATTRIBUTES + 20)
#define UPS_ID                                  (UPS + UPS_ATTRIBUTES + 21)
#define UPS_SERIAL_NUMBER                       (UPS + UPS_ATTRIBUTES + 22)
#define MANUFACTURE_DATE                        (UPS + UPS_ATTRIBUTES + 23)
#define BATTERY_REPLACEMENT_DATE                (UPS + UPS_ATTRIBUTES + 24)
#define HIGH_TRANSFER_VOLTAGE                   (UPS + UPS_ATTRIBUTES + 25)
#define LOW_TRANSFER_VOLTAGE                    (UPS + UPS_ATTRIBUTES + 26)
#define MIN_RETURN_CAPACITY                     (UPS + UPS_ATTRIBUTES + 27)
#define RATED_OUTPUT_VOLTAGE                    (UPS + UPS_ATTRIBUTES + 28)
#define UPS_SENSITIVITY                         (UPS + UPS_ATTRIBUTES + 29)
#define LOW_BATTERY_DURATION                    (UPS + UPS_ATTRIBUTES + 30)
#define ALARM_DELAY                             (UPS + UPS_ATTRIBUTES + 31)
#define SHUTDOWN_DELAY                          (UPS + UPS_ATTRIBUTES + 32)
#define TURN_ON_DELAY                           (UPS + UPS_ATTRIBUTES + 33)
#define EARLY_TURN_OFF_POINTS                   (UPS + UPS_ATTRIBUTES + 34)
#define UPS_SELF_TEST_SCHEDULE                  (UPS + UPS_ATTRIBUTES + 35)
#define SELF_TEST_DAY                           (UPS + UPS_ATTRIBUTES + 36)
#define SELF_TEST_TIME                          (UPS + UPS_ATTRIBUTES + 37)
#define SELF_TEST_SETTING                       (UPS + UPS_ATTRIBUTES + 38)
#define SELF_TEST_LAST_DATE                     (UPS + UPS_ATTRIBUTES + 39)
#define SELF_TEST_LAST_TIME                     (UPS + UPS_ATTRIBUTES + 40)
#define SELF_TEST_RESULT                        (UPS + UPS_ATTRIBUTES + 41)
#define LOW_BATTERY_VOLTAGE_THRESHOLD           (UPS + UPS_ATTRIBUTES + 42)
#define HIGH_BATTERY_VOLTAGE_THRESHOLD          (UPS + UPS_ATTRIBUTES + 43)
#define LOW_BV_THRESHOLD_ENABLED                (UPS + UPS_ATTRIBUTES + 44)
#define HIGH_BV_THRESHOLD_ENABLED               (UPS + UPS_ATTRIBUTES + 45)
#define LOW_UPS_TEMP_THRESHOLD                  (UPS + UPS_ATTRIBUTES + 46)
#define HIGH_UPS_TEMP_THRESHOLD                 (UPS + UPS_ATTRIBUTES + 47)
#define LOW_UPS_TEMP_THRESHOLD_ENABLED          (UPS + UPS_ATTRIBUTES + 48)
#define HIGH_UPS_TEMP_THRESHOLD_ENABLED         (UPS + UPS_ATTRIBUTES + 49)
#define LOW_FREQUENCY_THRESHOLD                 (UPS + UPS_ATTRIBUTES + 50)
#define HIGH_FREQUENCY_THRESHOLD                (UPS + UPS_ATTRIBUTES + 51)
#define LOW_FREQUENCY_THRESHOLD_ENABLED         (UPS + UPS_ATTRIBUTES + 52)
#define HIGH_FREQUENCY_THRESHOLD_ENABLED        (UPS + UPS_ATTRIBUTES + 53)
#define LOW_LINEV_THRESHOLD                     (UPS + UPS_ATTRIBUTES + 54)
#define HIGH_LINEV_THRESHOLD                    (UPS + UPS_ATTRIBUTES + 55)
#define LOW_LINEV_THRESHOLD_ENABLED             (UPS + UPS_ATTRIBUTES + 56)
#define HIGH_LINEV_THRESHOLD_ENABLED            (UPS + UPS_ATTRIBUTES + 57)
#define LOW_OUTV_THRESHOLD                      (UPS + UPS_ATTRIBUTES + 58)
#define HIGH_OUTV_THRESHOLD                     (UPS + UPS_ATTRIBUTES + 59)
#define LOW_OUTV_THRESHOLD_ENABLED              (UPS + UPS_ATTRIBUTES + 60)
#define HIGH_OUTV_THRESHOLD_ENABLED             (UPS + UPS_ATTRIBUTES + 61)
#define LOW_LOAD_THRESHOLD                      (UPS + UPS_ATTRIBUTES + 62)
#define HIGH_LOAD_THRESHOLD                     (UPS + UPS_ATTRIBUTES + 63)
#define LOW_LOAD_THRESHOLD_ENABLED              (UPS + UPS_ATTRIBUTES + 64)
#define HIGH_LOAD_THRESHOLD_ENABLED             (UPS + UPS_ATTRIBUTES + 65)
#define BATTERY_AGE_LIMIT                       (UPS + UPS_ATTRIBUTES + 66)
#define LOW_MAX_LINEV_THRESHOLD                 (UPS + UPS_ATTRIBUTES + 67)
#define HIGH_MAX_LINEV_THRESHOLD                (UPS + UPS_ATTRIBUTES + 68)
#define LOW_MAX_LINEV_THRESHOLD_ENABLED         (UPS + UPS_ATTRIBUTES + 69)
#define HIGH_MAX_LINEV_THRESHOLD_ENABLED        (UPS + UPS_ATTRIBUTES + 70)
#define LOW_MIN_LINEV_THRESHOLD                 (UPS + UPS_ATTRIBUTES + 71)
#define HIGH_MIN_LINEV_THRESHOLD                (UPS + UPS_ATTRIBUTES + 72)
#define LOW_MIN_LINEV_THRESHOLD_ENABLED         (UPS + UPS_ATTRIBUTES + 73)
#define HIGH_MIN_LINEV_THRESHOLD_ENABLED        (UPS + UPS_ATTRIBUTES + 74)
#define BATTERY_TYPE                            (UPS + UPS_ATTRIBUTES + 75)
#define AVERAGE_VOLTAGE                         (UPS + UPS_ATTRIBUTES + 76)
#define UPS_MODEL                               (UPS + UPS_ATTRIBUTES + 78)
#define FAILURE_CAUSE                           (UPS + UPS_ATTRIBUTES + 79)
#define TIMED_RUN_TIME_REMAINING                (UPS + UPS_ATTRIBUTES + 80)
#define ALLOWED_VALUES                          (UPS + UPS_ATTRIBUTES + 81)
#define ALLOWED_RATED_OUTPUT_VOLTAGES           (UPS + UPS_ATTRIBUTES + 82)
#define ALLOWED_HIGH_TRANSFER_VOLTAGES          (UPS + UPS_ATTRIBUTES + 83)
#define ALLOWED_LOW_TRANSFER_VOLTAGES           (UPS + UPS_ATTRIBUTES + 84)
#define ALLOWED_MIN_RETURN_CAPACITIES           (UPS + UPS_ATTRIBUTES + 85)
#define ALLOWED_UPS_SENSITIVITIES               (UPS + UPS_ATTRIBUTES + 86)
#define ALLOWED_LOW_BATTERY_DURATIONS           (UPS + UPS_ATTRIBUTES + 87)
#define ALLOWED_ALARM_DELAYS                    (UPS + UPS_ATTRIBUTES + 88)
#define ALLOWED_SHUTDOWN_DELAYS                 (UPS + UPS_ATTRIBUTES + 89)
#define ALLOWED_TURN_ON_DELAYS                  (UPS + UPS_ATTRIBUTES + 90)
#define MAX_BATTERY_RUN_TIME                    (UPS + UPS_ATTRIBUTES + 91)
#define BATTERY_CALIBRATION_DAY                 (UPS + UPS_ATTRIBUTES + 99)
#define BATTERY_CALIBRATION_TIME                (UPS + UPS_ATTRIBUTES + 100)
#define STATE_REGISTER                          (UPS + UPS_ATTRIBUTES + 101)
#define BATTERY_CALIBRATION_ENABLED             (UPS + UPS_ATTRIBUTES + 102)
#define DAILY_SELF_TEST_ENABLED                 (UPS + UPS_ATTRIBUTES + 103)
#define WEEKLY_SELF_TEST_ENABLED                (UPS + UPS_ATTRIBUTES + 104)
#define AUTO_REBOOT_ENABLED                     (UPS + UPS_ATTRIBUTES + 105)
#define DATA_DECREMENT                          (UPS + UPS_ATTRIBUTES + 106)
#define UPS_TYPE                                (UPS + UPS_ATTRIBUTES + 107)
#define BYPASS_CAUSE                            (UPS + UPS_ATTRIBUTES + 108)
#define BYPASS_BY_SOFTWARE                      (UPS + UPS_ATTRIBUTES + 109)
#define BYPASS_BY_SWITCH                        (UPS + UPS_ATTRIBUTES + 110)
#define BYPASS_BY_DC_IMBALANCE                  (UPS + UPS_ATTRIBUTES + 111)
#define BYPASS_BY_VOLTAGE_LIMITS                (UPS + UPS_ATTRIBUTES + 112)
#define BYPASS_BY_TOP_FAN_FAILURE               (UPS + UPS_ATTRIBUTES + 113)
#define BYPASS_BY_INTERNAL_TEMP                 (UPS + UPS_ATTRIBUTES + 114)
#define BYPASS_BY_BATT_CHARGER_FAILED           (UPS + UPS_ATTRIBUTES + 115)
#define TRIP1_REGISTER                          (UPS + UPS_ATTRIBUTES + 116)
#define SLAVE_ENABLED                           (UPS + UPS_ATTRIBUTES + 117)
#define IS_EEPROM_PROGRAMMABLE                  (UPS + UPS_ATTRIBUTES + 119)
#define IS_LOAD_SENSING_ON                      (UPS + UPS_ATTRIBUTES + 120)
#define OUTPUT_VOLTAGE_REPORT                   (UPS + UPS_ATTRIBUTES + 121)
#define UPS_LANGUAGE                            (UPS + UPS_ATTRIBUTES + 122)
#define AUTO_SELF_TEST                          (UPS + UPS_ATTRIBUTES + 123)
#define UPS_ALLOWED_VALUES                      (UPS + UPS_ATTRIBUTES + 124)
#define EEPROM_ALLOWED_VALUES                   (UPS + UPS_ATTRIBUTES + 125)
#define BATTERY_CALIBRATION_LAST_DATE           (UPS + UPS_ATTRIBUTES + 126)
#define TIME_ON_BATTERY                         (UPS + UPS_ATTRIBUTES + 127)
#define UPS_RUN_TIME_AFTER_LOW_BATTERY          (UPS + UPS_ATTRIBUTES + 128)
#define UPS_FRONT_PANEL_PASSWORD                (UPS + UPS_ATTRIBUTES + 129)
#define ALLOWED_UPS_RUN_TIME_AFTER_LOW_BATTERY  (UPS + UPS_ATTRIBUTES + 130)
#define UPS_MODEL_NAME                          (UPS + UPS_ATTRIBUTES + 131)
#define EEPROM_INCREMENT                        (UPS + UPS_ATTRIBUTES + 132)
#define INTERNAL_BATTERY_PACKS                  (UPS + UPS_ATTRIBUTES + 133) 
#define EXTERNAL_BATTERY_PACKS                  (UPS + UPS_ATTRIBUTES + 134) 
#define EXTERNAL_PACKS_CHANGEABLE               (UPS + UPS_ATTRIBUTES + 135) 
#define DECIMAL_FIRMWARE_REV                    (UPS + UPS_ATTRIBUTES + 136)
#define IS_ADMIN_SHUTDOWN                       (UPS + UPS_ATTRIBUTES + 137) 
#define IS_SECOND_GEN                           (UPS + UPS_ATTRIBUTES + 138) 
#define MAX_VOLTAGE_RANGE_VALUE                 (UPS + UPS_ATTRIBUTES + 139) 
#define MIN_VOLTAGE_RANGE_VALUE                 (UPS + UPS_ATTRIBUTES + 140) 
#define IS_MATRIX                               (UPS + UPS_ATTRIBUTES + 141) 
#define IS_THIRD_GEN                            (UPS + UPS_ATTRIBUTES + 142) 
#define IS_FIRST_GEN                            (UPS + UPS_ATTRIBUTES + 143) 
#define IS_BACKUPS                              (UPS + UPS_ATTRIBUTES + 144) 
#define IS_SYMMETRA                             (UPS + UPS_ATTRIBUTES + 145) 

// Smart Scheduling
#define DAILY_SMARTSCHEDULING      		        (UPS + UPS_ATTRIBUTES + 146)
#define MONTHLY_SMARTSCHEDULING             	(UPS + UPS_ATTRIBUTES + 147)
#define NO_SMARTSCHEDULING       		        (UPS + UPS_ATTRIBUTES + 148)
#define SELFTEST_LIST       			        (UPS + UPS_ATTRIBUTES + 149)
#define BATTERY_CALIBRATION_LIST       		    (UPS + UPS_ATTRIBUTES + 150)

// Dark Star
#define MODULE_COUNTS_AND_STATUS                (UPS + UPS_ATTRIBUTES + 151)
#define ABNORMAL_CONDITION_REGISTER             (UPS + UPS_ATTRIBUTES + 152)
#define INPUT_VOLTAGE_FREQUENCY                 (UPS + UPS_ATTRIBUTES + 153)
#define OUTPUT_VOLTAGE_CURRENTS                 (UPS + UPS_ATTRIBUTES + 154)
#define TOTAL_INVERTERS                         (UPS + UPS_ATTRIBUTES + 155)
#define NUMBER_BAD_INVERTERS                    (UPS + UPS_ATTRIBUTES + 156)
#define CURRENT_REDUNDANCY                      (UPS + UPS_ATTRIBUTES + 157)
#define MINIMUM_REDUNDANCY                      (UPS + UPS_ATTRIBUTES + 158)
#define CURRENT_LOAD_CAPABILITY                 (UPS + UPS_ATTRIBUTES + 159)
#define INPUT_VOLTAGE_PHASE_A        	        (UPS + UPS_ATTRIBUTES + 161)
#define INPUT_VOLTAGE_PHASE_B                   (UPS + UPS_ATTRIBUTES + 162)
#define INPUT_VOLTAGE_PHASE_C                   (UPS + UPS_ATTRIBUTES + 163)
#define INPUT_FREQUENCY                         (UPS + UPS_ATTRIBUTES + 164)
#define OUTPUT_VOLTAGE_PHASE_A                  (UPS + UPS_ATTRIBUTES + 165)
#define OUTPUT_VOLTAGE_PHASE_B                  (UPS + UPS_ATTRIBUTES + 166)
#define OUTPUT_VOLTAGE_PHASE_C                  (UPS + UPS_ATTRIBUTES + 167)
#define NUMBER_OF_INPUT_PHASES                  (UPS + UPS_ATTRIBUTES + 168)
#define NUMBER_OF_OUTPUT_PHASES                 (UPS + UPS_ATTRIBUTES + 169)

#define FIRMWARE_REV_CHAR                       (UPS + UPS_ATTRIBUTES + 170) 
#define COUNTRY_CODE                            (UPS + UPS_ATTRIBUTES + 171) 
#define UPSMODEL_CHAR                           (UPS + UPS_ATTRIBUTES + 172) 
#define IS_SMARTBOOST                           (UPS + UPS_ATTRIBUTES + 173) 
#define IS_SMARTTRIM                            (UPS + UPS_ATTRIBUTES + 174) 
#define IS_FREQUENCY                            (UPS + UPS_ATTRIBUTES + 175) 
#define IS_BATTERY_CAPACITY                     (UPS + UPS_ATTRIBUTES + 176) 
#define IS_COPYRIGHT                            (UPS + UPS_ATTRIBUTES + 177) 
#define IS_RUNTIME_REMAINING                    (UPS + UPS_ATTRIBUTES + 178) 
#define IS_MIN_RETURN_CAPACITY                  (UPS + UPS_ATTRIBUTES + 179) 
#define IS_SENSITIVITY                          (UPS + UPS_ATTRIBUTES + 180) 
#define IS_LOW_BATTERY_DURATION                 (UPS + UPS_ATTRIBUTES + 181) 
#define IS_ALARM_DELAY                          (UPS + UPS_ATTRIBUTES + 182) 
#define IS_SHUTDOWN_DELAY                       (UPS + UPS_ATTRIBUTES + 183) 
#define IS_TURN_ON_DELAY                        (UPS + UPS_ATTRIBUTES + 184) 
#define IS_MANUFACTURE_DATE                     (UPS + UPS_ATTRIBUTES + 185) 
#define IS_SERIAL_NUMBER                        (UPS + UPS_ATTRIBUTES + 186) 
#define IS_UPS_ID                               (UPS + UPS_ATTRIBUTES + 187) 
#define IS_TURN_OFF_WITH_DELAY                  (UPS + UPS_ATTRIBUTES + 188) 
#define IS_CTRL_Z                               (UPS + UPS_ATTRIBUTES + 189) 
#define IS_LOAD_SENSING                         (UPS + UPS_ATTRIBUTES + 190) 
#define IS_EEPROM_PROGRAM_CAPABLE               (UPS + UPS_ATTRIBUTES + 191) 
#define IS_BATTERY_DATE                         (UPS + UPS_ATTRIBUTES + 192) 
#define IS_SELF_TEST_SCHEDULE                   (UPS + UPS_ATTRIBUTES + 193) 
#define IS_BATTERY_CALIBRATION                  (UPS + UPS_ATTRIBUTES + 194) 
#define IS_RATED_OUTPUT_VOLTAGE                 (UPS + UPS_ATTRIBUTES + 195) 
#define IS_HIGH_TRANSFER_VOLTAGE                (UPS + UPS_ATTRIBUTES + 196) 
#define IS_LOW_TRANSFER_VOLTAGE                 (UPS + UPS_ATTRIBUTES + 197) 
#define HIGH_TRANSFER_VALUES                    (UPS + UPS_ATTRIBUTES + 198) 
#define LOW_TRANSFER_VALUES                     (UPS + UPS_ATTRIBUTES + 199) 


//
// These cant remain contiguous since we have to work with old back ends
// whose state codes start at 200
//
#define RATED_OUTPUT_VALUES                     (UPS + MORE_UPS_ATTRIBUTES + 0) 
#define SINGLE_HIGH_TRANSFER_VALUE              (UPS + MORE_UPS_ATTRIBUTES + 1) 
#define SINGLE_LOW_TRANSFER_VALUE               (UPS + MORE_UPS_ATTRIBUTES + 2) 
#define UPS_NAME                                (UPS + MORE_UPS_ATTRIBUTES + 3) 
#define IS_XL                                   (UPS + MORE_UPS_ATTRIBUTES + 4) 
#define IS_SELF_TEST                            (UPS + MORE_UPS_ATTRIBUTES + 5)
#define IS_SIMULATE_POWER_FAIL                  (UPS + MORE_UPS_ATTRIBUTES + 6)
#define IS_LIGHTS_TEST                          (UPS + MORE_UPS_ATTRIBUTES + 7)
#define IS_BYPASS                               (UPS + MORE_UPS_ATTRIBUTES + 8) 
#define SUPPORTED_FEATURES                      (UPS + MORE_UPS_ATTRIBUTES + 9) 
#define MAXIMUM_LOAD_CAPABILITY                 (UPS + MORE_UPS_ATTRIBUTES + 10)
#define IS_UPS_LOAD                             (UPS + MORE_UPS_ATTRIBUTES + 11)
#define IS_UTILITY_VOLTAGE                      (UPS + MORE_UPS_ATTRIBUTES + 12)
#define IS_OUTPUT_VOLTAGE                       (UPS + MORE_UPS_ATTRIBUTES + 13)
#define IS_OPERATING_REDUNDANCY                 (UPS + MORE_UPS_ATTRIBUTES + 14)
#define IS_MIN_REDUNDANCY_ALARM                 (UPS + MORE_UPS_ATTRIBUTES + 15)
#define IS_UPS_LOAD_ALARM                       (UPS + MORE_UPS_ATTRIBUTES + 16)
#define IS_INTELLIGENCE_MODULE                  (UPS + MORE_UPS_ATTRIBUTES + 17)
#define IS_REDUNDANT_INTELLIGENCE_MODULE        (UPS + MORE_UPS_ATTRIBUTES + 18)
#define IS_MAXIMUM_CAPACITY                     (UPS + MORE_UPS_ATTRIBUTES + 19)
#define IS_BATTERY_VOLTAGE                      (UPS + MORE_UPS_ATTRIBUTES + 20)
#define IS_UPS_TEMPERATURE                      (UPS + MORE_UPS_ATTRIBUTES + 21)
#define IS_MULTIPLE_UPS_MODULES                 (UPS + MORE_UPS_ATTRIBUTES + 22)
#define IS_EXT_SLEEP_UPS                        (UPS + MORE_UPS_ATTRIBUTES + 23)
#define CURRENT_FIRMWARE_REV                    (UPS + MORE_UPS_ATTRIBUTES + 24)

// moved SPECIFIC_SMARTSCHEDULING code because it had the same code as
// IS_SYMMETRA.  Moved this code because at the current time (building of v5.1.0),
// no backends ask for SPECIFIC_SMARTSCHEDULING so this likely will not break anything.

#define SPECIFIC_SMARTSCHEDULING                (UPS + MORE_UPS_ATTRIBUTES + 25)
#define IS_SINGLEBYTE                           (UPS + MORE_UPS_ATTRIBUTES + 26)
#define IS_MULTIBYTE                            (UPS + MORE_UPS_ATTRIBUTES + 27)

// States
#define BATTERY_CONDITION                       (UPS + UPS_STATES + 1)
#define UTILITY_LINE_CONDITION                  (UPS + UPS_STATES + 2)
#define SMART_BOOST_STATE                       (UPS + UPS_STATES + 3)
#define ABNORMAL_CONDITION_STATE                (UPS + UPS_STATES + 4)
#define OVERLOAD_CONDITION                      (UPS + UPS_STATES + 5)
#define BATTERY_REPLACEMENT_CONDITION           (UPS + UPS_STATES + 6)
#define COMMUNICATION_STATE                     (UPS + UPS_STATES + 7)
#define SELF_TEST_STATE                         (UPS + UPS_STATES + 8)
#define BATTERY_CALIBRATION_CONDITION           (UPS + UPS_STATES + 9)
#define UPS_STATE                               (UPS + UPS_STATES + 10)
#define LINE_CONDITION_TEST                     (UPS + UPS_STATES + 11)
#define RUN_TIME_EXPIRED                        (UPS + UPS_STATES + 12)
#define SHUTDOWN_CONDITION                      (UPS + UPS_STATES + 13)
#define MATRIX_FAN_STATE                        (UPS + UPS_STATES + 14)
#define BATTERY_CHARGER_STATE                   (UPS + UPS_STATES + 15)
#define BYPASS_RELAY_CONDITION                  (UPS + UPS_STATES + 16)
#define BYPASS_POWER_SUPPLY_CONDITION           (UPS + UPS_STATES + 17)
#define MATRIX_STATE_CONDITION                  (UPS + UPS_STATES + 18)
#define MATRIX_TEMPERATURE                      (UPS + UPS_STATES + 19)
#define BYPASS_MODE                             (UPS + UPS_STATES + 20)
#define SMART_CELL_SIGNAL_CABLE_STATE           (UPS + UPS_STATES + 21)
#define CLIENT_DISCONNECT                       (UPS + UPS_STATES + 22)
#define EEPROM_CHANGED                          (UPS + UPS_STATES + 23)
#define SYSTEM_STATE                            (UPS + UPS_STATES + 24)
#define SMART_TRIM_STATE                        (UPS + UPS_STATES + 25)
#define IM_STATUS                               (UPS + UPS_STATES + 27)
#define IM_INSTALLATION_STATE                   (UPS + UPS_STATES + 28)
#define RIM_STATUS                              (UPS + UPS_STATES + 29)
#define RIM_INSTALLATION_STATE                  (UPS + UPS_STATES + 30)
#define REDUNDANCY_STATE                        (UPS + UPS_STATES + 31)
#define SYSTEM_FAN_STATE                        (UPS + UPS_STATES + 32)
#define INPUT_BREAKER_STATE                     (UPS + UPS_STATES + 33)
#define BYPASS_CONTACTOR_STATE                  (UPS + UPS_STATES + 34)
#define LOAD_CAPABILITY_STATE                   (UPS + UPS_STATES + 35)
#define INVERTER_INSTALLATION_STATE             (UPS + UPS_STATES + 36)


// Allowable state values
#define COMMUNICATION_LOST                      (UPS + UPS_STATE_VALUES + 1)
#define COMMUNICATION_ESTABLISHED               (UPS + UPS_STATE_VALUES + 2)
#define UPS_OVERLOAD                            (UPS + UPS_STATE_VALUES + 3)
#define NO_UPS_OVERLOAD                         (UPS + UPS_STATE_VALUES + 4)
#define SMART_BOOST_ON                          (UPS + UPS_STATE_VALUES + 5)
#define SMART_BOOST_OFF                         (UPS + UPS_STATE_VALUES + 6)
#define BATTERY_BAD                             (UPS + UPS_STATE_VALUES + 7)
#define BATTERY_GOOD                            (UPS + UPS_STATE_VALUES + 8)
#define LOW_BATTERY                             (UPS + UPS_STATE_VALUES + 9)
#define BATTERY_DISCHARGED                      (UPS + UPS_STATE_VALUES + 10)
#define LINE_BAD                                (UPS + UPS_STATE_VALUES + 11)
#define LINE_GOOD                               (UPS + UPS_STATE_VALUES + 12)
#define SELF_TEST_PASSED                        (UPS + UPS_STATE_VALUES + 13)
#define SELF_TEST_FAILED                        (UPS + UPS_STATE_VALUES + 14)
#define SELF_TEST_INVALID                       (UPS + UPS_STATE_VALUES + 15)
#define ABNORMAL_CONDITION                      (UPS + UPS_STATE_VALUES + 16)
#define NO_ABNORMAL_CONDITION                   (UPS + UPS_STATE_VALUES + 17)
#define BATTERY_NEEDS_REPLACING                 (UPS + UPS_STATE_VALUES + 18)
#define BATTERY_DOESNT_NEED_REPLACING           (UPS + UPS_STATE_VALUES + 19)
#define COPYRIGHT_VIOLATION                     (UPS + UPS_STATE_VALUES + 20)   
#define BATTERY_CALIBRATED                      (UPS + UPS_STATE_VALUES + 21)
#define BATTERY_CALIBRATION_IN_PROGRESS         (UPS + UPS_STATE_VALUES + 22)
#define BATTERY_CALIBRATION_CANCELLED           (UPS + UPS_STATE_VALUES + 23)
#define BATTERY_CALIBRATION_FAILED              (UPS + UPS_STATE_VALUES + 24)
#define NO_BATTERY_CALIBRATION                  (UPS + UPS_STATE_VALUES + 25)
#define UPS_SHUTDOWN                            (UPS + UPS_STATE_VALUES + 26)
#define UPS_NOT_SHUTDOWN                        (UPS + UPS_STATE_VALUES + 27)
#define UPS_OFF_PENDING                         (UPS + UPS_STATE_VALUES + 28)
#define STATE_UNKNOWN                           (UPS + UPS_STATE_VALUES + 29)
#define HIGH_THRESHOLD_EXCEEDED                 (UPS + UPS_STATE_VALUES + 30)
#define LOW_THRESHOLD_EXCEEDED                  (UPS + UPS_STATE_VALUES + 31)
#define IN_THRESHOLD_RANGE                      (UPS + UPS_STATE_VALUES + 32)
#define LIGHTS_TEST_IN_PROGRESS                 (UPS + UPS_STATE_VALUES + 33)
#define NO_LIGHTS_TEST_IN_PROGRESS              (UPS + UPS_STATE_VALUES + 34)
#define SELF_TEST_IN_PROGRESS                   (UPS + UPS_STATE_VALUES + 35)
#define NO_SELF_TEST_IN_PROGRESS                (UPS + UPS_STATE_VALUES + 36)
#define COMMUNICATION_LOST_ON_BATTERY           (UPS + UPS_STATE_VALUES + 37)

//
// These value come from Keiths Kcodes.h  Im not sure they
// belong here.
//
#define RETURN_FROM_LOW_BATTERY                 (UPS + UPS_STATE_VALUES + 38)
#define LINE_BAD_TRANSFER_CAUSE                 (UPS + UPS_STATE_VALUES + 39)
#define HIGH_LINE_VOLTAGE                       (UPS + UPS_STATE_VALUES + 40)
#define BROWNOUT                                (UPS + UPS_STATE_VALUES + 41)
#define BLACKOUT                                (UPS + UPS_STATE_VALUES + 42)
#define SMALL_SAG                               (UPS + UPS_STATE_VALUES + 43)
#define SMALL_SPIKE                             (UPS + UPS_STATE_VALUES + 44)
#define DEEP_SAG                                (UPS + UPS_STATE_VALUES + 45)
#define SELF_TEST_INITIATOR                     (UPS + UPS_STATE_VALUES + 46)
#define SELF_TEST_INITIATED_BY_USER             (UPS + UPS_STATE_VALUES + 47)
#define SELF_TEST_INITIATED_BY_SCHEDULE         (UPS + UPS_STATE_VALUES + 48)
#define SELF_TEST_INITIATED_BY_UNKNOWN          (UPS + UPS_STATE_VALUES + 49)
#define BATTERY_CALIBRATION_STATE               (UPS + UPS_STATE_VALUES + 50)
#define NO_BATTERY_CALIBRATION_IN_PROGRESS      (UPS + UPS_STATE_VALUES + 51)
#define LARGE_SPIKE                             (UPS + UPS_STATE_VALUES + 52)
#define NO_TRANSFERS                            (UPS + UPS_STATE_VALUES + 53)
#define SELF_TEST_TRANSFER                      (UPS + UPS_STATE_VALUES + 54)
#define NOTCH_SPIKE_TRANSFER                    (UPS + UPS_STATE_VALUES + 55)
#define LOW_LINE_TRANSFER                       (UPS + UPS_STATE_VALUES + 56)
#define HIGH_LINE_TRANSFER                      (UPS + UPS_STATE_VALUES + 57)
#define RATE_TRANSFER                           (UPS + UPS_STATE_VALUES + 58)
#define UNKNOWN_TRANSFER                        (UPS + UPS_STATE_VALUES + 59)
#define FAN_FAILURE_IN_TOP_BOX                  (UPS + UPS_STATE_VALUES + 60)
#define FAN_FAILURE_IN_BOTTOM_BOX               (UPS + UPS_STATE_VALUES + 61)
#define FAN_OK                                  (UPS + UPS_STATE_VALUES + 62)
#define BATTERY_CHARGER_OK                      (UPS + UPS_STATE_VALUES + 63)
#define BATTERY_CHARGER_FAILED                  (UPS + UPS_STATE_VALUES + 64)
#define BYPASS_RELAY_OK                         (UPS + UPS_STATE_VALUES + 65)
#define BYPASS_RELAY_FAILED                     (UPS + UPS_STATE_VALUES + 65)
#define BYPASS_POWER_SUPPLY_OK                  (UPS + UPS_STATE_VALUES + 66)
#define BYPASS_POWER_SUPPLY_FAULT               (UPS + UPS_STATE_VALUES + 67)
#define UPS_NOT_ON_BYPASS                       (UPS + UPS_STATE_VALUES + 68)
#define UPS_ON_BYPASS                           (UPS + UPS_STATE_VALUES + 69)
//
// These value come from the MATRIX state register response
//
#define MATRIX_ARMED_RECP_STANDBY               (UPS + UPS_STATE_VALUES + 70)
#define MATRIX_RECP_STANDBY                     (UPS + UPS_STATE_VALUES + 71)
#define MATRIX_SWITCHED_BYPASS                  (UPS + UPS_STATE_VALUES + 72)
#define MATRIX_RETURN_FROM_BYPASS               (UPS + UPS_STATE_VALUES + 73)
#define MATRIX_COMP_SELECT_BYPASS               (UPS + UPS_STATE_VALUES + 74)
#define MATRIX_ENTERING_COMP_SELECT_BYPASS      (UPS + UPS_STATE_VALUES + 75)
#define MATRIX_WAKEUP                           (UPS + UPS_STATE_VALUES + 76)
#define MATRIX_STATE_CLEAR                      (UPS + UPS_STATE_VALUES + 77)
#define MATRIX_TEMPERATURE_OK                   (UPS + UPS_STATE_VALUES + 78)
#define MATRIX_TEMPERATURE_FAULT                (UPS + UPS_STATE_VALUES + 79)
#define SELF_TEST_NO_RECENT_TEST                (UPS + UPS_STATE_VALUES + 80)

//
// More Comm States
//
#define SERVER_COMM_LOST	                    (UPS + UPS_STATE_VALUES + 81)
#define SERVER_COMM_ESTABLISHED	                (UPS + UPS_STATE_VALUES + 82)
#define UPS_COMM_PORT_CHANGED	                (UPS + UPS_STATE_VALUES + 83)

#define CHECK_CABLE                             (UPS + UPS_STATE_VALUES + 84)
#define CABLE_OK                                (UPS + UPS_STATE_VALUES + 85)
#define IGNORE_BATTERY_GOOD                     (UPS + UPS_STATE_VALUES + 86)
#define RESPOND_TO_BATTERY_GOOD                 (UPS + UPS_STATE_VALUES + 87)
#define INITIATE_BYPASS                         (UPS + UPS_STATE_VALUES + 88)
#define CANCEL_BYPASS                           (UPS + UPS_STATE_VALUES + 89)
#define PRECAUTION_TO_UPS_FAULT                 (UPS + UPS_STATE_VALUES + 90)

#define SMART_TRIM_ON                           (UPS + UPS_STATE_VALUES + 91)
#define SMART_TRIM_OFF                          (UPS + UPS_STATE_VALUES + 92)

#define UPS_MODULE_FAILED                       (UPS + UPS_STATE_VALUES + 93)
#define UPS_MODULE_OK                           (UPS + UPS_STATE_VALUES + 94)
#define IM_FAILED                               (UPS + UPS_STATE_VALUES + 95)
#define IM_OK                                   (UPS + UPS_STATE_VALUES + 96)
#define IM_INSTALLED                            (UPS + UPS_STATE_VALUES + 97)
#define IM_NOT_INSTALLED                        (UPS + UPS_STATE_VALUES + 98)
#define REDUNDANCY_FAILED                       (UPS + UPS_STATE_VALUES + 99)

//
// These cant remain contiguous since we have to work with old back ends
// whose action codes start at 400
//
#define REDUNDANCY_OK                           (UPS + MORE_UPS_STATE_VALUES + 0)
#define BYPASS_CONTACTOR_OK                     (UPS + MORE_UPS_STATE_VALUES + 1)
#define BYPASS_CONTACTOR_FAILED                 (UPS + MORE_UPS_STATE_VALUES + 2)
#define SYSTEM_FAN_FAILED                       (UPS + MORE_UPS_STATE_VALUES + 3)
#define SYSTEM_FAN_OK                           (UPS + MORE_UPS_STATE_VALUES + 4)
#define BREAKER_CLOSED                          (UPS + MORE_UPS_STATE_VALUES + 5)
#define BREAKER_OPEN                            (UPS + MORE_UPS_STATE_VALUES + 6)
#define RIM_FAILED                              (UPS + MORE_UPS_STATE_VALUES + 7)
#define RIM_OK                                  (UPS + MORE_UPS_STATE_VALUES + 8)
#define RIM_INSTALLED                           (UPS + MORE_UPS_STATE_VALUES + 9)
#define RIM_NOT_INSTALLED                       (UPS + MORE_UPS_STATE_VALUES + 10)
#define LOAD_CAPABILITY_FAILED                  (UPS + MORE_UPS_STATE_VALUES + 11)
#define LOAD_CAPABILITY_OK                      (UPS + MORE_UPS_STATE_VALUES + 12)
#define UPS_MODULE_ADDED                        (UPS + MORE_UPS_STATE_VALUES + 13)
#define UPS_MODULE_REMOVED                      (UPS + MORE_UPS_STATE_VALUES + 14)
#define BATTERY_ADDED                           (UPS + MORE_UPS_STATE_VALUES + 15)
#define BATTERY_REMOVED                         (UPS + MORE_UPS_STATE_VALUES + 16)

#define INPUT_BREAKER_TRIPPED_TRANSFER          (UPS + MORE_UPS_STATE_VALUES + 17)


// Actions
#define TURN_ON_SMART_MODE                      (UPS + UPS_ACTIONS + 1)
#define LIGHTS_TEST                             (UPS + UPS_ACTIONS + 2)
#define TURN_OFF_UPS_AFTER_DELAY                (UPS + UPS_ACTIONS + 3)
#define TURN_OFF_UPS_ON_BATTERY                 (UPS + UPS_ACTIONS + 4)
#define SIMULATE_POWER_FAIL                     (UPS + UPS_ACTIONS + 5)
#define TURN_OFF_UPS                            (UPS + UPS_ACTIONS + 6)
#define PUT_UPS_TO_SLEEP                        (UPS + UPS_ACTIONS + 7)
#define BATTERY_CALIBRATION_TEST                (UPS + UPS_ACTIONS + 8)
#define SELF_TEST                               (UPS + UPS_ACTIONS + 9)
#define PERFORM_BATTERY_CALIBRATION             (UPS + UPS_ACTIONS + 10)
#define CANCEL_BATTERY_CALIBRATION              (UPS + UPS_ACTIONS + 11)
#define SIMULATE_POWER_FAIL_OVER                (UPS + UPS_ACTIONS + 12)
#define RESCHEDULE_SELF_TEST                    (UPS + UPS_ACTIONS + 13)
#define RESCHEDULE_DDTEST                       (UPS + UPS_ACTIONS + 14)
#define TURN_OFF_SMART_MODE                     (UPS + UPS_ACTIONS + 15)


// ****** UPS STUFF ******
#define MEASURE_UPS                             1000
#define MEASURE_UPS_ATTRIBUTES                  0
#define MEASURE_UPS_STATES                      100
#define MEASURE_UPS_STATE_VALUES                200
#define MEASURE_UPS_ACTIONS                     300


// Attributes
#define AMBIENT_TEMPERATURE                     (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 1)
#define HUMIDITY                                (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 2)
#define LOW_AMBIENT_TEMP_THRESHOLD              (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 3)
#define HIGH_AMBIENT_TEMP_THRESHOLD             (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 4)
#define LOW_HUMIDITY_THRESHOLD                  (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 5)
#define HIGH_HUMIDITY_THRESHOLD                 (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 6)
#define CONTACT_POSITION                        (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 7)
#define CONTACT_NUMBER                          (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 8)
#define USER_COMMENT                            (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 9)
#define LOW_AMBIENT_TEMP_THRESHOLD_ENABLED      (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 10)
#define HIGH_AMBIENT_TEMP_THRESHOLD_ENABLED     (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 11)
#define LOW_HUMIDITY_THRESHOLD_ENABLED          (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 12)
#define HIGH_HUMIDITY_THRESHOLD_ENABLED         (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 13)

// Note: CONTACT1..4 values must be numerically sequential and adjacent
//
#define CONTACT1_DEFAULT_POSITION               (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 14)
#define CONTACT2_DEFAULT_POSITION               (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 15)
#define CONTACT3_DEFAULT_POSITION               (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 16)
#define CONTACT4_DEFAULT_POSITION               (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 17)
#define CONTACT1_DESCRIPTION                    (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 18)
#define CONTACT2_DESCRIPTION                    (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 19)
#define CONTACT3_DESCRIPTION                    (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 20)
#define CONTACT4_DESCRIPTION                    (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 21)
#define CONTACT1_STATUS_ENABLED                 (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 22)
#define CONTACT2_STATUS_ENABLED                 (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 23)
#define CONTACT3_STATUS_ENABLED                 (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 24)
#define CONTACT4_STATUS_ENABLED                 (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 25)
#define CONTACT_STATUS                          (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 26)
#define NORMAL_POSITION                         (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 27)
#define MUPS_FIRMWARE_REV                       (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 28)
#define CONTACT1_STATE                          (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 29)
#define CONTACT2_STATE                          (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 30)
#define CONTACT3_STATE                          (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 31)
#define CONTACT4_STATE                          (MEASURE_UPS + MEASURE_UPS_ATTRIBUTES + 32)

// States
#define IS_MEASURE_UPS_ATTACHED                 (MEASURE_UPS + MEASURE_UPS_STATES + 1) 
#define CONTACT_STATE                           (MEASURE_UPS + MEASURE_UPS_STATES + 2)
#define CONTACT1_STATUS                         (MEASURE_UPS + MEASURE_UPS_STATES + 3)
#define CONTACT2_STATUS                         (MEASURE_UPS + MEASURE_UPS_STATES + 4)
#define CONTACT3_STATUS                         (MEASURE_UPS + MEASURE_UPS_STATES + 5)
#define CONTACT4_STATUS                         (MEASURE_UPS + MEASURE_UPS_STATES + 6)


// Allowable state values
#define CONTACT_FAULT                           (MEASURE_UPS + MEASURE_UPS_STATE_VALUES + 1)
#define CONTACT_NORMAL                          (MEASURE_UPS + MEASURE_UPS_STATE_VALUES + 2)
#define CONTACT_OPEN                            (MEASURE_UPS + MEASURE_UPS_STATE_VALUES + 3)
#define CONTACT_CLOSED                          (MEASURE_UPS + MEASURE_UPS_STATE_VALUES + 4)

// Actions




// ****** HOST STUFF ******
#define HOST                                    2000
#define HOST_ATTRIBUTES                         0
#define HOST_STATES                             100
#define HOST_STATE_VALUES                       200
#define HOST_ACTIONS                            300
#define HOST_ACTION_VALUES		                400


// Attributes
#define SERVER_NAME                             (HOST + HOST_ATTRIBUTES + 1)
//#define ADMIN_SHUTDOWN_NOW_DELAY              (HOST + HOST_ATTRIBUTES + 3)
//#define LOW_BATTERY_SHUTDOWN_DELAY            (HOST + HOST_ATTRIBUTES + 5)
#define CLIENT_NAME                             (HOST + HOST_ATTRIBUTES + 6)
#define CLIENT_TYPE                             (HOST + HOST_ATTRIBUTES + 7)
#define CLIENT_ALERT_ADDR                       (HOST + HOST_ATTRIBUTES + 8)
#define CLIENT_BINDERY_ADDR                     (HOST + HOST_ATTRIBUTES + 10)
#define SERVER_ADDR                             (HOST + HOST_ATTRIBUTES + 11)
#define ERROR_FILE_NAME                         (HOST + HOST_ATTRIBUTES + 15)
#define ERROR_FILE_MAX_SIZE                     (HOST + HOST_ATTRIBUTES + 16)
#define UPS_PORT_NAME			                (HOST + HOST_ATTRIBUTES + 20)
#define ALLOWED_UPS_PORT_NAMES		            (HOST + HOST_ATTRIBUTES + 21)
#define UPS_SIGNALLING_TYPE		                (HOST + HOST_ATTRIBUTES + 22)
// just in case:
#define ALLOWED_UPS_SIGNALLING_TYPES	        (HOST + HOST_ATTRIBUTES + 23)
#define UPS_PORT_TYPE		  	                (HOST + HOST_ATTRIBUTES + 24)
#define ALLOWED_UPS_PORT_TYPES		            (HOST + HOST_ATTRIBUTES + 25)
#define HOST_TIME			                    (HOST + HOST_ATTRIBUTES + 26)
#define HOST_USES_AIO_COMM		                (HOST + HOST_ATTRIBUTES + 27)
#define HOST_AIO_HARDWARE                       (HOST + HOST_ATTRIBUTES + 28)
#define HOST_ALLOWED_AIO_HARDWARE               (HOST + HOST_ATTRIBUTES + 29)
#define HOST_AIO_BOARD_NUMBER                   (HOST + HOST_ATTRIBUTES + 30)
#define HOST_AIO_PORT_NUMBER                    (HOST + HOST_ATTRIBUTES + 31)
#define HOST_USER_PASSWORD                      (HOST + HOST_ATTRIBUTES + 32)
#define HOST_SERVER_SECURITY                    (HOST + HOST_ATTRIBUTES + 32)
#define SERVER_PRODUCT_NAME                     (HOST + HOST_ATTRIBUTES + 33)
#define SERVER_VERSION                          (HOST + HOST_ATTRIBUTES + 34)
#define SERVER_PLATFORM                         (HOST + HOST_ATTRIBUTES + 35)
#define COMPUTER_NAME                           (HOST + HOST_ATTRIBUTES + 36)

// States
#define MONITORING_STATUS                       (HOST + HOST_STATES + 1)
#define SHUTDOWN_STATUS                         (HOST + HOST_STATES + 2)

// Allowable state values
#define MONITORING_STARTED                      (HOST + HOST_STATE_VALUES + 1)
#define MONITORING_STOPPED                      (HOST + HOST_STATE_VALUES + 2)

// Actions
#define HOST_NAME                               (HOST + HOST_ACTIONS + 11)
#define CLIENT_ACK                              (HOST + HOST_ACTIONS + 12) 
#define CLEAR_ERROR_FILE                        (HOST + HOST_ACTIONS + 16)
#define CLIENT_USE_MASTER                       (HOST + HOST_ACTIONS + 17)

#define RESET_UPS_COMM_PORT                     (HOST + HOST_ACTIONS + 18)


// Values for Action Codes
#define ENABLE                                  (HOST + HOST_ACTION_VALUES + 1)
#define DISABLE                                 (HOST + HOST_ACTION_VALUES + 2)
#define SLAVE_SHUTDOWN                          (HOST + HOST_ACTION_VALUES + 7)

// ****** POPUP STUFF ******
#define POPUP                                   3000
#define POPUP_ATTRIBUTES                        0
#define POPUP_STATES                            100
#define POPUP_STATE_VALUES                      200
#define POPUP_ACTIONS                           300


#define MESSAGE_DELAY                           (POPUP + POPUP_ATTRIBUTES + 1)
#define MESSAGE_INTERVAL                        (POPUP + POPUP_ATTRIBUTES + 2)
#define POWER_FAIL_MSG                          (POPUP + POPUP_ATTRIBUTES + 3)
#define POWER_RETURN_MSG                        (POPUP + POPUP_ATTRIBUTES + 4)
#define LOW_BATTERY_MSG                         (POPUP + POPUP_ATTRIBUTES + 5)
#define SHUTDOWN_MSG                            (POPUP + POPUP_ATTRIBUTES + 6)
#define RUN_TIME_EXPIRED_MSG                    (POPUP + POPUP_ATTRIBUTES + 7)
#define SHUTDOWN_DELAY_VALUE                    (POPUP + POPUP_ATTRIBUTES + 8)

#define DISABLE_POPUPS                          (POPUP + POPUP_ACTIONS + 1)


// ****** DATALOG STUFF ******
#define CDATALOG                                4000
#define DATALOG_ATTRIBUTES                      0
#define DATALOG_STATES                          100
#define DATALOG_STATE_VALUES                    200
#define DATALOG_ACTIONS                         300


#define DATA_FILE_NAME                          (CDATALOG + DATALOG_ATTRIBUTES + 1)
#define DATA_FILE_MAX_SIZE                      (CDATALOG + DATALOG_ATTRIBUTES + 2)
#define DATA_LOGGING_INTERVAL                   (CDATALOG + DATALOG_ATTRIBUTES + 3)
#define DATA_LOGGING_ENABLED                    (CDATALOG + DATALOG_ATTRIBUTES + 4)
#define DATA_LOG_DATA                           (CDATALOG + DATALOG_ATTRIBUTES + 5) 
#define DATA_LOG_DATA_DONE                      (CDATALOG + DATALOG_ATTRIBUTES + 6) 
#define IS_DATA_LOGGING                         (CDATALOG + DATALOG_ATTRIBUTES + 7) 





#define CLEAR_DATA_FILE                         (CDATALOG + DATALOG_ACTIONS + 1)
#define LOG_DATA                                (CDATALOG + DATALOG_ACTIONS + 2)



// ****** EVENTLOG STUFF ******
#define CEVENTLOG                               5000
#define EVENTLOG_ATTRIBUTES                     0
#define EVENTLOG_STATES                         100
#define EVENTLOG_STATE_VALUES                   200
#define EVENTLOG_ACTIONS                        300
    

#define EVENT_FILE_NAME                         (CEVENTLOG + EVENTLOG_ATTRIBUTES + 2)
#define EVENT_FILE_MAX_SIZE                     (CEVENTLOG + EVENTLOG_ATTRIBUTES + 3)
#define EVENT_LOGGING_ENABLED                   (CEVENTLOG + EVENTLOG_ATTRIBUTES + 4)
#define EVENT_LOG_DATA                          (CEVENTLOG + EVENTLOG_ATTRIBUTES + 5)
#define EVENT_LOG_DATA_DONE                     (CEVENTLOG + EVENTLOG_ATTRIBUTES + 6)
#define EVENT_LOG_UPDATE                        (CEVENTLOG + EVENTLOG_ATTRIBUTES + 7)
#define IS_EVENT_LOGGING                        (CEVENTLOG + EVENTLOG_ATTRIBUTES + 8)

#define CLEAR_EVENT_FILE                        (CEVENTLOG + EVENTLOG_ACTIONS + 13)


#define USERS                                   6000
#define USERS_ATTRIBUTES                        0   
#define USERS_ACTIONS                           100

#define USERS_USER_NAME                         (USERS + USERS_ATTRIBUTES + 1)
#define USERS_NOTIFICATION_ENABLED              (USERS + USERS_ATTRIBUTES + 2)
#define USERS_NOTIFY_ADDRESS                    (USERS + USERS_ATTRIBUTES + 3)
#define USERS_PAGING_ENABLED                    (USERS + USERS_ATTRIBUTES + 4)
#define USERS_PAGER_NUMBER                      (USERS + USERS_ATTRIBUTES + 5)
#define USERS_PAGER_ACCESS_CODE                 (USERS + USERS_ATTRIBUTES + 6)
#define USERS_PAGER_SERVICE                     (USERS + USERS_ATTRIBUTES + 7)
#define USERS_EMAIL_ENABLED                     (USERS + USERS_ATTRIBUTES + 8)
#define USERS_EMAIL_ADDRESS                     (USERS + USERS_ATTRIBUTES + 9)
#define USERS_PAGER_SERVICE_LIST                (USERS + USERS_ATTRIBUTES + 10)
#define USERS_OLD_NAME                          (USERS + USERS_ATTRIBUTES + 11)

#define USERS_ATTRIBUTE_VALUES                  (USERS + USERS_ACTIONS + 1)
#define USERS_DELETE_USER                       (USERS + USERS_ACTIONS + 2)
#define USERS_RENAME_USER                       (USERS + USERS_ACTIONS + 3)


// ***** INTERNAL MESSAGES ******
#define INTERNAL                                7000

#define SET_DATA                                (INTERNAL + 1)
#define DECREMENT                               (INTERNAL + 2)
#define NO_MSG                                  (INTERNAL + 3)
#define RUNTIME_ERROR                           (INTERNAL + 4)
#define ERROR_LOCATION                          (INTERNAL + 5)
#define RETRY_CONSTRUCT                         (INTERNAL + 6)
#define RETRY_POPUP                             (INTERNAL + 7)
#define NEW_SERVER                              (INTERNAL + 8)
#define AVAILABLE_SERVERS                       (INTERNAL + 9)
#define NO_THRESHOLD                            (INTERNAL + 10)
#define WEEKDAYS                                (INTERNAL + 11)
#define FRONT_END_WIDTH                         (INTERNAL + 12)
#define FRONT_END_HEIGHT                        (INTERNAL + 13)
#define WILD_CARD                               (INTERNAL + 14)

// the following must be numerically sequential
#define UPS_BACKUPS                             (INTERNAL + 15)
#define UPS_SMARTUPS                            (INTERNAL + 16)
#define UPS_SECOND_GEN                          (INTERNAL + 17)
#define UPS_MATRIX                              (INTERNAL + 18)
// end sequence

#define ISNETWORK_ATTACHED                      (INTERNAL + 19)
#define TEMPERATURE_UNITS                       (INTERNAL + 20)
#define BAR_TYPE                                (INTERNAL + 21)
#define SOUND_EFFECTS                           (INTERNAL + 22)
#define LOW_THRESHOLD                           (INTERNAL + 23)
#define HIGH_THRESHOLD                          (INTERNAL + 24)
#define ADDED_SERVER                            (INTERNAL + 25)
#define REMOVED_SERVER                          (INTERNAL + 26)
#define CHANGED_SERVER                          (INTERNAL + 27)
#define USER_PASSWORD                           (INTERNAL + 28)
#define TIMER_PULSE                             (INTERNAL + 29)
#define FIXED_VALUE                             (INTERNAL + 30)
#define INTERVAL                                (INTERNAL + 31)
#define DISPLAY_POPUP                           (INTERNAL + 32)
#define TIME_REMAINING                          (INTERNAL + 33)
#define RETRY_PORT                              (INTERNAL + 34)
#define TIMER_ID                                (INTERNAL + 35)
#define EXECUTE_COMMAND_FILE                    (INTERNAL + 36)
#define CONNECTING_SERVER                       (INTERNAL + 37)
#define SHUTDOWN_TYPE                           (INTERNAL + 38)
#define LOW_THRESHOLD_ENABLED                   (INTERNAL + 39)
#define HIGH_THRESHOLD_ENABLED                  (INTERNAL + 40)
#define EXIT_THREAD_NOW                         (INTERNAL + 41)
#define IS_SECURITY_ENABLED                     (INTERNAL + 42)
#define EXIT_MAIL			                    (INTERNAL + 43)
#define IS_SYSTEM_STANDALONE                    (INTERNAL + 44)
#define ADD_SERVER_TO_LIST                      (INTERNAL + 45)
#define REMOVE_SERVER_FROM_LIST                 (INTERNAL + 46)
#define CHANGE_SERVER_IN_LIST                   (INTERNAL + 47)
#define SELFTEST_TYPE                           (INTERNAL + 48)
#define BRIDGE_WINDOW_HANDLE                    (INTERNAL + 49)

#define FIRST_BAR_TYPE                          (INTERNAL + 50)
#define SECOND_BAR_TYPE                         (INTERNAL + 51)
#define THIRD_BAR_TYPE                          (INTERNAL + 52)

#define FRONT_END_NAME                          (INTERNAL + 53)
#define FRONT_END_VERSION                       (INTERNAL + 54)
#define FRONT_END_COPYRIGHT                     (INTERNAL + 55)

#define PENDING_EVENT                           (INTERNAL + 56)


//****  Shutdowner stuff
#define SHUTDOWNER                              8000
#define SHUTDOWNER_ATTRIBUTES                   0
#define SHUTDOWNER_STATES                       200
#define SHUTDOWNER_STATE_VALUES                 300
#define SHUTDOWNER_ACTIONS                      400

#define ADMIN_SHUTDOWN_DELAY                    (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 1)
#define ADMIN_SHUTDOWN_NOW_DELAY                (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 3)
#define LOW_BATTERY_SHUTDOWN_DELAY              (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 4)
#define SHUTDOWNER_SHUTDOWN                     (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 5)
#define SHUTDOWN_INITIATOR                      (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 6)
#define SHUTDOWN_WAKEUP_TIME                    (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 7)
#define WEEKLY_SHUTDOWN_DAY                     (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 8)
#define WEEKLY_SHUTDOWN_TIME                    (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 9)
#define WEEKLY_SHUTDOWN                         (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 10)
#define DAILY_SHUTDOWN_TIME                     (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 11)
#define DAILY_SHUTDOWN                          (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 12)
#define WEEKLY_REBOOT_DAY                       (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 13)
#define WEEKLY_REBOOT_TIME                      (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 14)
#define DAILY_REBOOT_DAY                        (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 15)
#define DAILY_REBOOT_TIME                       (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 16)
#define DAILY_SHUTDOWN_ENABLED                  (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 17)
#define WEEKLY_SHUTDOWN_ENABLED                 (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 18)
#define DEFAULT_SHUTDOWN_DELAY                  (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 19)
#define HOST_LOW_BATTERY_DURATION               (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 20)
#define LINE_FAIL_SHUTDOWN_DELAY                (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 21)
#define SHUTDOWN_LIST                           (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 22)
#define PREPARE_FOR_SHUTDOWN_DELAY              (SHUTDOWNER + SHUTDOWNER_ATTRIBUTES + 23)

#define SHUTDOWN                                (SHUTDOWNER + SHUTDOWNER_ACTIONS + 1)
#define ADMIN_SHUTDOWN                          (SHUTDOWNER + SHUTDOWNER_ACTIONS + 2)
#define CANCEL_SHUTDOWN                         (SHUTDOWNER + SHUTDOWNER_ACTIONS + 3)
#define UPS_FAULT_SHUTDOWN                      (SHUTDOWNER + SHUTDOWNER_ACTIONS + 4)
#define FINAL_SHUTDOWN                          (SHUTDOWNER + SHUTDOWNER_ACTIONS + 5)
#define PREPARE_FOR_SHUTDOWN                    (SHUTDOWNER + SHUTDOWNER_ACTIONS + 6)
#define PERFORM_SHUTDOWN                        (SHUTDOWNER + SHUTDOWNER_ACTIONS + 7)
#define LOW_BATTERY_SHUTDOWN                    (SHUTDOWNER + SHUTDOWNER_ACTIONS + 8)
#define RESCHEDULE_SHUTDOWN                     (SHUTDOWNER + SHUTDOWNER_ACTIONS + 9)
#define IS_SMART_SCHEDULING_ENABLED             (SHUTDOWNER + SHUTDOWNER_ACTIONS + 10)
#define IS_SHUTDOWN_IN_PROGRESS                 (SHUTDOWNER + SHUTDOWNER_ACTIONS + 11)
#define IS_DATASAFE_ENABLED                     (SHUTDOWNER + SHUTDOWNER_ACTIONS + 12)

#define NO_SHUTDOWN                             (SHUTDOWNER + SHUTDOWNER_STATE_VALUES + 1)
#define SHUTDOWN_STARTED                        (SHUTDOWNER + SHUTDOWNER_STATE_VALUES + 2)
#define SHUTDOWN_STOPPED                        (SHUTDOWNER + SHUTDOWNER_STATE_VALUES + 3)

//****  Modem stuff

#define MODEM                                   9000
#define MODEM_ATTRIBUTES                        0
#define MODEM_STATES                            200
#define MODEM_STATE_VALUES                      300
#define MODEM_ACTIONS                           400

#define MODEM_INIT_STRING                       (MODEM + MODEM_ATTRIBUTES + 1)
#define MODEM_SET_PAUSE_TIME                    (MODEM + MODEM_ATTRIBUTES + 2)
#define MODEM_DIAL_WITH_TONE                    (MODEM + MODEM_ATTRIBUTES + 3)
#define MODEM_DIAL_WITH_PULSE                   (MODEM + MODEM_ATTRIBUTES + 4)
#define MODEM_DIAL_STRING_TERMINATOR            (MODEM + MODEM_ATTRIBUTES + 5)
#define MODEM_DIAL_WAIT_DIAL_TONE               (MODEM + MODEM_ATTRIBUTES + 6)
#define MODEM_DIAL_WAIT_SILENT                  (MODEM + MODEM_ATTRIBUTES + 7)
#define MODEM_COMMAND_TERMINATOR                (MODEM + MODEM_ATTRIBUTES + 8)
#define MODEM_PAUSE_COMMAND                     (MODEM + MODEM_ATTRIBUTES + 9)
#define MODEM_HANGUP_COMMAND                    (MODEM + MODEM_ATTRIBUTES + 10)
#define MODEM_DRIVER_TYPE                       (MODEM + MODEM_ATTRIBUTES + 11)
#define MODEM_PORT_NUMBER                       (MODEM + MODEM_ATTRIBUTES + 12)
#define MODEM_BOARD_NUMBER                      (MODEM + MODEM_ATTRIBUTES + 13)
#define MODEM_DIAL_TYPE		                    (MODEM + MODEM_ATTRIBUTES + 14)
#define MODEM_ALLOWED_DIAL_TYPES                (MODEM + MODEM_ATTRIBUTES + 15)
#define MODEM_BAUD_RATE		                    (MODEM + MODEM_ATTRIBUTES + 16)
#define MODEM_ALLOWED_BAUD_RATES                (MODEM + MODEM_ATTRIBUTES + 17)
#define MODEM_PORT_NAME                         (MODEM + MODEM_ATTRIBUTES + 18)



// ***** FLEXIBLE EVENT CODES ******
#define FLEX_EVENT                              10000
#define FLEX_EVENT_ATTRIBUTES                   0
#define FLEX_EVENT_ACTIONS                      100
#define FLEX_EVENT_EVENTS                       200
#define FLEX_EVENT_VALUES                       300
#define FLEX_EVENT_TEST_ACTIONS			        400

#define FLEX_EVENT_LIST                         (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 1)
#define FLEX_ACTION_LIST                        (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 2)
#define FLEX_USERS                              (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 3)
#define FLEX_NOTIFIABLE_USERS                   (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 4)
#define FLEX_ADMIN_USER_LIST                    (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 5)
#define FLEX_ADMIN_NOTIFY_MESSAGE               (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 6)
#define FLEX_ADMIN_NOTIFY_DELAY                 (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 7)
#define FLEX_ADMIN_NOTIFY_REPEAT                (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 8)
#define FLEX_ADMIN_NOTIFY_INTERVAL              (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 9)
#define FLEX_ALLOWED_NOTIFY_TYPES               (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 10)
#define FLEX_NOTIFY_TYPE                        (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 11)
#define FLEX_NOTIFY_USER_LIST                   (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 12)
#define FLEX_NOTIFY_MESSAGE                     (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 13)
#define FLEX_NOTIFY_DELAY                       (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 14)
#define FLEX_NOTIFY_REPEAT                      (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 15)
#define FLEX_NOTIFY_INTERVAL                    (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 16)
#define FLEX_SHUTDOWN_DELAY                     (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 17)
#define FLEX_COMMAND_FILE_NAME                  (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 18)
#define FLEX_COMMAND_FILE_DELAY                 (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 19)
#define FLEX_PAGEABLE_USERS                     (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 20)
#define FLEX_PAGE_USER_LIST                     (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 21)
#define FLEX_PAGE_DELAY                         (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 22)
#define FLEX_PAGE_MESSAGE                       (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 23)
#define FLEX_EMAILABLE_USERS                    (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 24)
#define FLEX_EMAIL_USER_LIST                    (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 25)
#define FLEX_EMAIL_MESSAGE                      (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 26)
#define FLEX_EMAIL_DELAY                        (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 27)
#define FLEX_EMAIL_EVENT_DELAY                  (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 28)
#define FLEX_EMAIL_ENABLED                      (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 29)


#define FLEX_PAGER_SERVICE_NAME                 (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 30)
#define FLEX_PAGER_SERVICE_OLD_NAME             (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 31)
#define FLEX_PAGER_SERVICE_ATTR_VALUES          (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 32)
#define FLEX_PAGER_SERVICE_ANSWER_DELAY         (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 33)
#define FLEX_PAGER_SERVICE_EXTENSION_DELAY      (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 34)
#define FLEX_PAGER_SERVICE_EXIT_CODE            (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 35)
#define FLEX_PAGER_EVENT_MESSAGE                (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 36)
#define FLEX_PAGER_EVENT_DELAY                  (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 37)


#define FLEX_TIME_UNTIL_SHUTDOWN                (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 38)
#define IS_LINE_FAIL_RUN_TIME_ENABLED           (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 39)

#define FLEX_DEFAULT_ACTION_LIST                (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 40)

#define FLEX_EVENT_NAME                         (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 41)
#define IS_FLEX_EVENTS                          (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 42)
#define FLEX_EVENT_NAME_LIST                    (FLEX_EVENT + FLEX_EVENT_ATTRIBUTES + 43)


#define FLEX_EDIT_USERS                         (FLEX_EVENT + FLEX_EVENT_EVENTS + 1)
    
#define FLEX_ACTION_LOG                         (FLEX_EVENT + FLEX_EVENT_ACTIONS + 1)
#define FLEX_ACTION_ADMIN_NOTIFY                (FLEX_EVENT + FLEX_EVENT_ACTIONS + 2)
#define FLEX_ACTION_USER_NOTIFY                 (FLEX_EVENT + FLEX_EVENT_ACTIONS + 3)
#define FLEX_ACTION_SHUTDOWN                    (FLEX_EVENT + FLEX_EVENT_ACTIONS + 4)
#define FLEX_ACTION_COMMAND                     (FLEX_EVENT + FLEX_EVENT_ACTIONS + 5)
#define FLEX_ACTION_PAGE                        (FLEX_EVENT + FLEX_EVENT_ACTIONS + 6)
#define FLEX_ACTION_EMAIL                       (FLEX_EVENT + FLEX_EVENT_ACTIONS + 7)

#define FLEX_RESET_ACTIONS                      (FLEX_EVENT + FLEX_EVENT_ACTIONS + 1)

#define PAGE_USERS                              (FLEX_EVENT + FLEX_EVENT_ACTIONS + 2)
#define MAIL_USERS                              (FLEX_EVENT + FLEX_EVENT_ACTIONS + 3)

#define FLEX_RENAME_PAGER_SERVICE               (FLEX_EVENT + FLEX_EVENT_ACTIONS + 4)


#define FLEX_EVENT_BASE                         20000

#define FLEX_NOTIFY_ALL                         (FLEX_EVENT + FLEX_EVENT_VALUES + 1)
#define FLEX_NOTIFY_NAMES                       (FLEX_EVENT + FLEX_EVENT_VALUES + 2)
#define FLEX_NOTIFY_DOMAIN                      (FLEX_EVENT + FLEX_EVENT_VALUES + 3)

#define FLEX_TEST_AN_ACTION				        (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS)
#define FLEX_TEST_NOTIFY				        (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 1)
#define FLEX_TEST_NOTIFY_TYPE                   (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 2)
#define FLEX_TEST_NOTIFY_USERS                  (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 3)
#define FLEX_TEST_NOTIFY_MESSAGE                (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 4)
#define FLEX_TEST_AVAILABLE                     (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 5)
#define FLEX_TEST_RUN_COMMAND			        (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 21)
#define FLEX_TEST_RUN_COMMAND_FILE              (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 22)
#define FLEX_TEST_EMAIL					        (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 31)
#define FLEX_TEST_EMAIL_USERS   		        (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 32)
#define FLEX_TEST_EMAIL_ADDL_MESSAGE            (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 33)
#define FLEX_TEST_EMAIL_EVENT_CODE              (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 34)
#define FLEX_TEST_PAGE					        (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 41)
#define FLEX_TEST_PAGE_USERS                    (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 42)
#define FLEX_TEST_PAGE_MESSAGE                  (FLEX_EVENT + FLEX_EVENT_TEST_ACTIONS + 43)

//****  E-mail stuff

#define EMAIL                                   30000
#define EMAIL_ATTRIBUTES                        0

#define EMAIL_SMTP_SERVER                       (EMAIL + EMAIL_ATTRIBUTES + 1)
#define EMAIL_SMTP_ACCOUNT                      (EMAIL + EMAIL_ATTRIBUTES + 2)
#define EMAIL_SMTP_DOMAIN                       (EMAIL + EMAIL_ATTRIBUTES + 3)
#define IS_SMTP_EMAIL                           (EMAIL + EMAIL_ATTRIBUTES + 4)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\chgsensr.cxx ===
/*
 *  pcy17Dec92  Added Validate()
 *  cad10Jun93:  fixed GetState()
 *
 */

#include "cdefine.h"

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "event.h"
#include "apc.h"
#include "chgsensr.h"
#include "utils.h"
#include "device.h"


//Constructor
ChangeSensor :: ChangeSensor(PDevice aParent, 
                             PCommController aCommController, 
                             INT aSensorCode, 
                             INT anUpperEventCode,
                             INT aLowerEventCode,
                             ACCESSTYPE anACCESSTYPE)
: StateSensor(aParent,aCommController, aSensorCode, anACCESSTYPE)
{
    theUpperEventCode = anUpperEventCode;
    theLowerEventCode = aLowerEventCode;

    // Disable validation checking until the sensor value 
    // is initialized
    theValidationCheckingEnabled = 0;
}

INT ChangeSensor::Validate(INT aCode, const PCHAR aValue)
{

   INT err = StateSensor::Validate(aCode, aValue);

   if (theValidationCheckingEnabled)
   {
     if (err != ErrNO_STATE_CHANGE ) 
     {
       PEvent change_event;

       // Check for a positive change
       if (strcmp(aValue, theValue) > 0) 
       {
           change_event = new Event(theUpperEventCode, "");
        }
       // Otherwise the change must be negative
       else 
       {
           change_event = new Event(theLowerEventCode, "");
       }
       theDevice->Update(change_event);
       delete change_event;
       change_event = NULL;
     }
   }
   else
   {
    // Enable validation checking once the sensor value 
    // has been initialized
     theValidationCheckingEnabled = 1;
   }
   return err;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\contrlr.h ===
/*
 * REVISIONS:
 *  pcy17Nov92: Equal() now uses const reference and is const
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  mwh05May94: #include file madness , part 2
 */

#ifndef __CONTRLR_H
#define __CONTRLR_H

_CLASSDEF(Controller)

#include "update.h"

#if (C_NETWORK & C_IPX)
_CLASSDEF(NetAddr)
_CLASSDEF(SpxSocket)
#endif

class Event;
class Dispatcher;


class Controller : public UpdateObj
{
public:
	Controller();
	virtual INT          Initialize() = 0;
	virtual INT          Get(INT code, CHAR* value) = 0;
	virtual INT          Set(INT code, const PCHAR value) = 0;
#if (C_NETWORK & C_IPX)
   virtual PNetAddr     GetNetAddr(PCHAR) = 0;
   virtual PSpxSocket   GetTheSocket(VOID) = 0;
#endif
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\comctrl.h ===
/*
* REVISIONS:
*  pcy17Nov92: Equal() now uses reference and is const
*  ane03Feb93: Added destructors
*  pcy03Mar93: Cleaned up include files and use _CLASSDEFed types
*  pcy30Apr93: Moved DevComController to its own file and gor rid of IsA
*  rct17May93: Added IsA() -- sorry if it's not supposed to be pure virt.,
*              but nobody could of used it as is anyway...
*  mwh05May94: #include file madness , part 2
*  tjg26Jan98: Added Stop method
*/
#ifndef __COMCTRL_H
#define __COMCTRL_H

//
// Defines
//
_CLASSDEF(CommController)

//
// Implementation uses
//
#include "contrlr.h"

//
// Interface uses
//
_CLASSDEF(UpdateObj)
_CLASSDEF(CommDevice)


class CommController : public Controller {

protected:

    PCommDevice theCommDevice;

public:

    CommController();
    virtual ~CommController();

    INT RegisterEvent(INT anEventCode, PUpdateObj aAttribute);
    INT UnregisterEvent(INT anEventCode, PUpdateObj aAttribute);

    virtual INT  Initialize();
    virtual INT  Get(INT code, PCHAR value);
    virtual INT  Set(INT code, const PCHAR value);
            VOID Stop();

    PCommDevice GetDevice () { return theCommDevice; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\contrlr.cxx ===
/*
 * REVISIONS:
 *  pcy26Nov92: Added #if C_OS2 around os2.h
 *
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */
#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
}
#include "_defs.h"
#include "event.h"
#include "err.h"
#include "contrlr.h"
#include "dispatch.h"


Controller :: Controller()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\coprites.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 */
#ifndef COPRITES_H
#define COPRITES_H

#include "sensor.h"
 
_CLASSDEF(CopyrightSensor)
 
class CopyrightSensor : public Sensor {
   
public:
   CopyrightSensor(PDevice aParent, PCommController aCommController = NULL);
   virtual INT IsA() const { return COPYRIGHTSENSOR; };

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\comctrl.cxx ===
/*
* REVISIONS:
*  pcy26Nov92: Added #if C_OS2 around os2.h
*  ane03Feb93: Added destructor and error checking
*  pcy30Apr93: Moved DevCOmController to its own file
*  mwh18Nov93: changed EventID to INT
*  tjg26Jan98: Added Stop method
*/
#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

#include "_defs.h"
#include "event.h"
#include "codes.h"
#include "err.h"
#include "cdevice.h"
#include "comctrl.h"


CommController :: CommController()
: Controller()
{
}

CommController :: ~CommController()
{
    if (theCommDevice) {
        delete theCommDevice;
        theCommDevice = NULL;
    }
}

INT CommController::Initialize()
{
    theObjectStatus = theCommDevice->Initialize();
    
    return theObjectStatus;
}

INT CommController :: RegisterEvent(INT code, PUpdateObj sensor)
{
    Controller :: RegisterEvent(code, sensor);
    theCommDevice->RegisterEvent(code ,(PUpdateObj)this);
    return ErrNO_ERROR;
}

INT CommController :: UnregisterEvent(INT code, PUpdateObj sensor)
{
    theCommDevice->UnregisterEvent(code ,(PUpdateObj)this);
    Controller :: UnregisterEvent(code, sensor);
    return ErrNO_ERROR;
}


INT CommController :: Get(INT aCode, PCHAR aValue) 
{ 
    return theCommDevice->Get((INT)aCode, aValue);
}

INT   CommController :: Set(INT aCode, PCHAR aValue) 
{
    return theCommDevice->Set((INT)aCode, aValue);
}

VOID  CommController::Stop()
{
    if (theCommDevice) {
        Event event(EXIT_THREAD_NOW, (PCHAR)NULL);
        theCommDevice->Update(&event);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\coprites.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "coprites.h"

CopyrightSensor :: CopyrightSensor(PDevice aParent, PCommController aCommController)
			: Sensor(aParent, aCommController, COPYRIGHT)
{
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\cwccons.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ash16Oct95: creation
 *  djs23Apr96: moved GCIP constants to gcip.h
 *  srt21Jun96: Added consts for RPC events
 */


#ifndef __CONSTNTS_H
#define __CONSTNTS_H

#include "_defs.h"
#include "w32utils.h"

// Common constants
#define GCIP_BUFFER_SIZE            4096
#define BUFFER_SIZE                 128
#define NAME_SIZE                   64
#define CREATE_STATUS               1
#define CREATE_ALERT                2
#define TCP_CLIENT                  0
#define SPX_CLIENT                  1
#define RPC_CLIENT                  2
#define IA_PROTO                    0

#define RPC_CLIENT_LIST_LOCK        "Local_Client_List_Mutex"
#define RPC_REQUEST_LIST_LOCK       "_Request_List_Mutex"
#define RPC_RESPONSE_LIST_LOCK      "_Response_List_Mutex"
#define RPC_ALERT_LIST_LOCK         "_Alert_List_Lock"
#define RPC_PROTOCOL_SEQ	        "ncalrpc"
#define RPC_ENDPOINT		        "pwrchute"
#define RPC_CLIENT_MUTEX		    "_Status_Mutex"
#define RPC_CLIENT_NAME		        "PowerChute"
#define RPC_REQUEST_LIST_EVENT      "_Request_List_Event"
#define RPC_RESPONSE_LIST_EVENT     "_Response_List_Event"
#define RPC_ALERT_LIST_EVENT	    "_Alert_List_Event"

#define RPC_CLIENT_DISC_TIMEOUT     20 //seconds



// Client only
#define POLLING_INTERVAL    4    // 4 seconds
#define FINDERLOOPTIME      4    // 4 seconds

// Server only
#define TIMEOUT 1000
#define MAX_BUF_LEN                 8192 

#define UDP_SERVICE_NAME            "PwrChuteUdp"
#define TCP_STATUS_SERVICE          "PwrChuteTcpS"
#define TCP_ALERT_SERVICE           "PwrChuteTcpA"
#define IPX_SERVICE_NAME            "PwrChuteIpx"
#define SPX_STATUS_SERVICE          "PwrChuteSpxS"
#define SPX_ALERT_SERVICE           "PwrChuteSpxA"
#define IP_ADDR_LEN                 16
#define SPX_ADDR_LEN                14
#define MAXNAMELEN                  80
#define MAX_PROTOCOLS 20
#define TCP_PROTOCOL                "TCP"
#define SPX_PROTOCOL                "SPX"
#define RPC_PROTOCOL                "LOCAL"

// Client only

// Server only
#define QUEUE_LEN                   5

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\datalog.h ===
/*
 * REVISIONS:
 *  ane15Jan93: Initial Revision
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  cgm11Dec95: Switch to Watcom 10.5 compiler for NLM 
 */

#ifndef __DATALOG_H
#define __DATALOG_H


#include "cdefine.h"
#include "codes.h"
#include "apcobj.h"

_CLASSDEF(DataLog)


class DataLog : public Obj {

private:
   
public:
   DataLog() {};
   virtual LONG GetMaximumSize(void)=0;
   virtual const PCHAR GetFileName(void)=0;
   virtual void SetMaximumSize(long)=0;
   virtual INT SetFileName(const PCHAR)=0;
   virtual INT AppendRecord(const PCHAR)=0;
   virtual INT ClearFile()=0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\dcfrmrev.h ===
/*
 */

#ifndef __DECIMAL_FIRMSENS_H
#define __DECIMAL_FIRMSENS_H

#include "_defs.h"

#include "sensor.h"

_CLASSDEF(DecimalFirmwareRevSensor)


class DecimalFirmwareRevSensor : public Sensor {

protected:

public:

   DecimalFirmwareRevSensor(PDevice aParent, PCommController aCommController = NULL);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\dcomctrl.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  xxxddMMMyy 
 *
 *  jps20jul94: added extern "C" for stdio.h (os2 1.x)
 */

#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"
#include "_defs.h"

#include "dcomctrl.h"
#include "upsdev.h"
#include "event.h"
#include "codes.h"
extern "C" {
#include <stdio.h>
}


DevComContrl::DevComContrl(PUpdateObj aParent)
	: CommController(), theParent(aParent)
{
    theCommDevice = new UpsCommDevice(this);
}

DevComContrl::~DevComContrl()
{
   if (theParent)
      {
      theParent->UnregisterEvent(EXIT_THREAD_NOW, this);
      }
}

INT DevComContrl::Initialize()
{
   if (theParent)
      {
      theParent->RegisterEvent(EXIT_THREAD_NOW, this);
      }

   return CommController::Initialize();
}

INT DevComContrl::Update(PEvent anEvent)
{
   return UpdateObj::Update(anEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\datetime.cxx ===
/*
* NOTES:
*
* REVISIONS:
*  pcy10Mar95: Initial revision
*  pav22Sep95: Fixed leap year check
*  djs11Sep95: Port to UNIX
*  ntf03Jan96: Added operator<< functionality so that datetime.cxx would compile
*  jps20Nov96: Added adjustment for >2000 (+= 100) in DateObj constr.
*  tjg22Nov97: Added adjustment Year 2000 adjustment for leap year calculation
*  tjg27Mar98: Year adjustment must happen before call to GetDaysInMonth
*
*  v-stebe  29Jul2000   added check for NULL in constructor (bug #46328)
*/

#ifdef APCDEBUG
#include <iostream.h>
#endif

#include "cdefine.h"
#include "apc.h"

extern "C" {
#include <time.h>
#include <stdio.h>
}

#if (C_OS & C_UNIX)
#include "utils.h"
#endif


#if (C_OS & C_SUNOS4)
#include "incfix.h"
#endif

#include "datetime.h"


INT NumberOfDays[12] = {31,28,31,30,31,30,31,31,30,31,30,31};

/*
Name   :TimeObj
Synop  :This constructor provides a default of the current time
*/
TimeObj::TimeObj ()
{
   time_t curr = time(0);
   struct tm *currTime = localtime(&curr);
   
   theHours = currTime->tm_hour;
   theMinutes = currTime->tm_min;
   theSeconds = currTime->tm_sec;
}

TimeObj::TimeObj (PCHAR aTime)
{
   INT hour;
   INT minute;
   CHAR am_or_pm[16];
   
   am_or_pm[0] = 0;
   
   if (sscanf(aTime,"%d:%d %s", &hour, &minute, am_or_pm) == 3) {
      theHours = hour;
      
      if ((_strcmpi(am_or_pm, "PM") == 0) && (hour < 12)) {
         theHours += 12;
      }
      else if ((_strcmpi(am_or_pm, "AM") == 0) && (hour == 12)) {
         theHours = 0;
      }
      theMinutes = minute;
      theSeconds = 0;
   }
   else {
      theHours = 0;
      theMinutes = 0;
      theSeconds = 0;
   }
}


INT  TimeObj::  Equal(PTimeObj atime)
{
   if ( (theHours   ==  atime->theHours) && 
      (theMinutes ==  atime->theMinutes) &&
      (theSeconds ==  atime->theSeconds) )
      return TRUE;
   
   return FALSE;
}

INT TimeObj::operator < (RTimeObj cmp) const
{
   INT ret = FALSE;
   
   if (GetHour() < cmp.GetHour()) {
      ret = TRUE;
   }
   else if(GetHour() == cmp.GetHour() &&
      GetMinutes() < cmp.GetMinutes()) {
      ret = TRUE;
   }
   else if(GetHour() == cmp.GetHour() &&
      GetMinutes() == cmp.GetMinutes() &&
      GetSeconds() < cmp.GetSeconds()) {
      ret = TRUE;
   }
   return ret;
}


#if (C_OS & C_WIN311)
TimeObj::TimeObj(INT aHours, INT aMinutes, INT aSeconds)
{
   if ( ((aHours < 0) || (aHours > 23)) ||
        ((aMinutes < 0) || (aMinutes > 59)) ||
        ((aSeconds < 0) || (aSeconds > 59))) {
      SetObjectStatus(ErrINVALID_DATE);
   }
#else
TimeObj::TimeObj(ULONG aHours, ULONG aMinutes, ULONG aSeconds)
{
   if ( (aHours > 23) ||
        (aMinutes > 59) ||
        (aSeconds > 59)) {
      SetObjectStatus(ErrINVALID_DATE);
   }
#endif
   else {
      theHours    = aHours;
      theMinutes  = aMinutes;
      theSeconds  = aSeconds;
   }
};


#if (C_OS & C_WIN311)
INT TimeObj::GetHour() const
#else   
ULONG TimeObj::GetHour() const   
#endif
{
   return theHours;
};


#if (C_OS & C_WIN311)
INT TimeObj::GetMinutes() const
#else 
ULONG TimeObj::GetMinutes() const 
#endif
{
   return theMinutes;
};


#if (C_OS & C_WIN311)
INT TimeObj::GetSeconds() const
#else 
ULONG TimeObj::GetSeconds() const 
#endif
{
   return theSeconds;
};


#if (C_OS & C_WIN311)
VOID TimeObj::SetHour(INT hour) 
#else
VOID TimeObj::SetHour(ULONG hour) 
#endif
{
   theHours = hour;
};


#if (C_OS & C_WIN311)
VOID TimeObj::SetMinutes(INT minutes)
#else 
VOID TimeObj::SetMinutes(ULONG minutes)
#endif 
{
   theMinutes = minutes;
};


#if (C_OS & C_WIN311)
VOID TimeObj::SetSeconds(INT seconds) 
#else
VOID TimeObj::SetSeconds(ULONG seconds)
#endif 
{
   theSeconds = seconds;
};


WeekObj::WeekObj()
{
   time_t curr = time(0);
   struct tm *currTime = localtime(&curr);
   
   theWeekDay = currTime->tm_wday;
}

WeekObj::WeekObj(PCHAR weekStr)
{
   if (_strcmpi(weekStr, "SUNDAY") == 0)
      theWeekDay = 0;
   else if (_strcmpi(weekStr, "MONDAY") == 0)
      theWeekDay = 1;
   else if (_strcmpi(weekStr, "TUESDAY") == 0)
      theWeekDay = 2;
   else if (_strcmpi(weekStr, "WEDNESDAY") == 0)
      theWeekDay = 3;
   else if (_strcmpi(weekStr, "THURSDAY") == 0)
      theWeekDay = 4;
   else if (_strcmpi(weekStr, "FRIDAY") == 0)
      theWeekDay = 5;
   else if (_strcmpi(weekStr, "SATURDAY") == 0)
      theWeekDay = 6;
   else {
      SetObjectStatus(ErrINVALID_DATE);
      theWeekDay = 0;
   }
}


#if (C_OS & C_WIN311)
WeekObj::WeekObj(INT aDay)
#else
WeekObj::WeekObj(ULONG aDay)
#endif
{
   theWeekDay = aDay;
};


#if (C_OS & C_WIN311)
INT WeekObj::GetWeekDay()
#else
ULONG WeekObj::GetWeekDay()
#endif
{ 
   return theWeekDay;
};


#if (C_OS & C_WIN311)
DateObj::DateObj(INT aMonth, INT aDay, INT aYear)
{
   // Y2K fix for the year ... 2000 will be represented by 00 and 
   // must be incremented.  NOTE: This must happen before the
   // call to GetDaysInMonth!
   if (aYear < 70) {
      aYear += 100;
   }
   INT days = GetDaysInMonth(aMonth, aYear);
   if (((aMonth < 0) || (aMonth > 12)) ||
      ((aDay < 0) || (aDay > days)) ||
      (aYear < 0)) {
      SetObjectStatus (ErrINVALID_DATE);
   }

#else
DateObj::DateObj(ULONG aMonth, ULONG aDay, ULONG aYear)
{  
   // Y2K fix for the year ... 2000 will be represented by 00 and 
   // must be incremented.  NOTE: This must happen before the
   // call to GetDaysInMonth!
   if (aYear < 70) {
      aYear += 100;
   }
   
   ULONG days = GetDaysInMonth(aMonth, aYear);
   if ((aMonth > 12) || (aDay > days) ) {
      SetObjectStatus (ErrINVALID_DATE);
   }
#endif
   else { 
      theMonth  = aMonth;
      theDay    = aDay;
      theYear   = aYear;
   }
};
   
   
   /*
   C+
   Name   :DateObj
   Synop  :This constructor provides a default of the current date
   
   */
   DateObj::DateObj ()
   {
      time_t curr = time(0);
      struct tm *currTime = localtime(&curr);
      
      theMonth = currTime->tm_mon + 1;
      theDay = currTime->tm_mday;
      theYear = currTime->tm_year;
   }
   
#if (C_OS & C_WIN311)
   INT DateObj::GetDaysInMonth(const INT aMonth, const INT aYear) const
   {
      INT ret = NumberOfDays[aMonth-1];
#else
      ULONG DateObj::GetDaysInMonth(const ULONG aMonth, const ULONG aYear) const
      {
         ULONG ret = NumberOfDays[aMonth-1];
#endif
         
		 // Need temp_year variable to convert the year back to 4-digits.  
		 // If not, the leap year check below will fail on 2000 (2000 == 100 
		 // with our Y2K fixes).
		 INT temp_year = aYear + 1900;		 

         if ((((temp_year % 4 == 0) && (temp_year % 100 != 0)) || (temp_year % 400 == 0)) && 
            (aMonth == 2)) {
            ret++;
         }
         return ret;
      }
      
      
      INT DateObj::operator == (RDateObj cmp) const
      {
         INT ret = FALSE;
         
         if ((GetYear() == cmp.GetYear()) &&
            (GetMonth() == cmp.GetMonth()) &&
            (GetDay() == cmp.GetDay())) {
            
            ret = TRUE;
         }
         return ret;
      }
      
      
      INT DateObj::operator < (RDateObj cmp) const
      {
         INT ret = FALSE;
         
         if (GetYear() < cmp.GetYear()) {
            ret = TRUE;
         }
         else if (GetYear() == cmp.GetYear()) {
            
            if (GetMonth() < cmp.GetMonth()) {
               ret = TRUE;
            }
            else if (GetMonth() == cmp.GetMonth()) {
               
               if (GetDay() < cmp.GetDay()) {
                  ret = TRUE;
               }
            }
         }
         return ret;
      }
      
      
      // Return days between this and cmp
      //
      LONG DateObj::operator - (RDateObj cmp) const
      {
         RDateObj early = cmp, late = (RDateObj)(*this);
         LONG ret = 0;
         
#if (C_OS & C_WIN311)
         // in following code typecast the returns from GetMonth()... etc. to LONG for compatibility
         // with 32 bit code.
         INT year, month;
#else 
         ULONG year, month;
#endif
         
         if ((RDateObj)(*this) < cmp) {
            return ((early - late) * (-1));
         }
         
         if (early.GetYear() == late.GetYear()) {
            
            if (early.GetMonth() == late.GetMonth()) {
#if (C_OS & C_WIN311)
               ret += (LONG)(late.GetDay() - early.GetDay());
#else
               ret += (late.GetDay() - early.GetDay());
#endif
            }
            else {
#if (C_OS & C_WIN311)
               ret += (LONG)(early.GetDaysInMonth() - early.GetDay());
#else
               ret += (early.GetDaysInMonth() - early.GetDay());
#endif
               
               for (month=early.GetMonth()+1; month<late.GetMonth(); month++) {
#if (C_OS & C_WIN311)
                  ret += (LONG)GetDaysInMonth(month, GetYear());
#else
                  ret += GetDaysInMonth(month, GetYear());
#endif
               }
#if (C_OS & C_WIN311)
               ret += (LONG)late.GetDay();
#else
               ret += late.GetDay();
#endif
            }
         }
         else {
#if (C_OS & C_WIN311)
            ret += (LONG)(early.GetDaysInMonth() - early.GetDay());
#else
            ret += (early.GetDaysInMonth() - early.GetDay());
#endif
            for (month=early.GetMonth()+1; month<=12; month++) {
#if (C_OS & C_WIN311)
               ret += (LONG)GetDaysInMonth(month, early.GetYear());
#else
               ret += GetDaysInMonth(month, early.GetYear());
#endif
            }
            
            for (year=early.GetYear()+1; year<late.GetYear(); year++) {
               
               for (month=1; month<=12; month++) {
#if (C_OS & C_WIN311)
                  ret += (LONG)GetDaysInMonth(month, year);
#else
                  ret += GetDaysInMonth(month, year);
#endif
               }
            }
            
            for (month=1; month < late.GetMonth(); month++) {
#if (C_OS & C_WIN311)
               ret += (LONG)GetDaysInMonth(month, late.GetYear());
#else
               ret += GetDaysInMonth(month, late.GetYear());
#endif
            }
#if (C_OS & C_WIN311)
            ret += (LONG)late.GetDay();
#else
            ret += late.GetDay();
#endif
         }
         return ret;
      }
      
      
#if (C_OS & C_WIN311)
      INT DateObj::GetMonth() const
#else 
         ULONG DateObj::GetMonth() const 
#endif
      {
         return theMonth;
      };
      
#if (C_OS & C_WIN311)
      INT DateObj::GetDay() const 
#else
         ULONG DateObj::GetDay() const
#endif 
      {
         return theDay;
      };
      
#if (C_OS & C_WIN311)
      INT DateObj::GetYear() const 
#else
         ULONG DateObj::GetYear() const
#endif 
      {
         return theYear;
      };
      
      
#if (C_OS & C_WIN311)
      INT DateObj::GetDaysInMonth() const 
#else
         ULONG DateObj::GetDaysInMonth() const 
#endif
      {
         return GetDaysInMonth(theMonth,theYear);
      };
      
#if (C_OS & C_WIN311)
      VOID DateObj::SetMonth(INT aMonth) 
#else
         VOID DateObj::SetMonth(ULONG aMonth)
#endif 
      {
         theMonth = aMonth;
      };
      
#if (C_OS & C_WIN311)
      VOID DateObj::SetDay(INT aDay)
#else
         VOID DateObj::SetDay(ULONG aDay)
#endif
      {
         theDay = aDay;
      };
      
      
#if (C_OS & C_WIN311)
      VOID DateObj::SetYear(INT aYear)
#else
         VOID DateObj::SetYear(ULONG aYear)
#endif
      {
         theYear = aYear;
      };
      
      
      
#if (C_OS & C_WIN311)
      DateTimeObj::DateTimeObj(INT aMonth, INT aDay, INT aYear, INT anHour, 
         INT aMinutes, INT aSeconds)
#else
         DateTimeObj::DateTimeObj(ULONG aMonth, ULONG aDay, ULONG aYear, ULONG anHour, 
         ULONG aMinutes, ULONG aSeconds)
#endif
      {
         
         theDate = new DateObj(aMonth, aDay, aYear);
         theTime = new TimeObj(anHour, aMinutes, aSeconds);
         
         if ((theDate == NULL) || (theTime == NULL) || (theDate->GetObjectStatus() != ErrNO_ERROR) || 
            (theTime->GetObjectStatus() != ErrNO_ERROR))
            SetObjectStatus(ErrINVALID_DATE);    
      };
      
      
      DateTimeObj::DateTimeObj (RDateTimeObj aDate)
      {
         theDate = new DateObj(aDate.theDate->GetMonth(),
            aDate.theDate->GetDay(),
            aDate.theDate->GetYear());
         theTime = new TimeObj(aDate.theTime->GetHour(),
            aDate.theTime->GetMinutes(),
            aDate.theTime->GetSeconds());
      }
      
      DateTimeObj::~DateTimeObj()
      {
         if(theDate)  {
            delete theDate;
            theDate = (PDateObj)NULL;
         }
         
         if(theTime) {
            delete theTime;
            theTime = (PTimeObj)NULL;
         }
      }
      
      
      PDateObj DateTimeObj::GetDate() const
      {
         return theDate;
      };
      
      
      PTimeObj DateTimeObj::GetTime() const 
      {
         return theTime;
      };
      
      
      /*
      C+
      Name   :DateTimeObj
      Synop  :This constructor provides a default of the current date and time
      
      */
      DateTimeObj::DateTimeObj ()
      {
         theDate = new DateObj;
         theTime = new TimeObj;
      }
      
      INT DateTimeObj::operator < (RDateTimeObj cmp) const
      {
         INT ret = FALSE;
         
         if (*(GetDate()) < *(cmp.GetDate())) {
            ret = TRUE;
         }
         else if (*(GetDate()) == *(cmp.GetDate()) &&
            *(GetTime()) < *(cmp.GetTime())) {
            ret = TRUE;
         }
         return ret;
      }
      
      
      LONG DateTimeObj::GetSeconds(VOID) {
         LONG    seconds;
         struct tm t;
         time_t    Now,Then;
         
         t.tm_year  = (int)theDate->GetYear();
         t.tm_mon   = (int)theDate->GetMonth()-1;
         t.tm_mday  = (int)theDate->GetDay();
         t.tm_hour  = (int)theTime->GetHour();
         t.tm_min   = (int)theTime->GetMinutes();
         t.tm_sec   = (int)theTime->GetSeconds();
         t.tm_isdst = -1;
         
         Then = mktime(&t);
         Now = time(0);
         seconds = (LONG) (difftime(Then,Now));
         return (seconds);
      } 
      
      
      LONG DateTimeObj::GetMilliseconds(VOID)
      {
         struct tm t;
         
         t.tm_year  = theDate->GetYear();
         t.tm_mon   = theDate->GetMonth()-1;
         t.tm_mday  = theDate->GetDay();
         t.tm_hour  = theTime->GetHour();
         t.tm_min   = theTime->GetMinutes();
         t.tm_sec   = theTime->GetSeconds();
         t.tm_isdst = -1;
         
         time_t Then = mktime(&t);
         time_t Now = time(0);
         double sec = difftime(Then,Now);
         if(sec < 0)  {
            sec = 0;
         }
         return ((LONG)(sec*1000));
      } 
      
      
#ifdef APCDEBUG
      ostream & operator<< (ostream& os, DateObj & obj) {
         return(obj.printMeOut(os));
      }
      
      ostream& DateObj::printMeOut(ostream& os)
      {
         os << theMonth << "/" << theDay << "/" << theYear;
         return os;
      }
      
      ostream & operator<< (ostream& os, TimeObj & obj) {
         return(obj.printMeOut(os));
      }
      
      ostream& TimeObj::printMeOut(ostream& os)
      {
         os << theHours << ":" << theMinutes << ":" << theSeconds;
         return os;
      }
      
      ostream & operator<< (ostream& os, DateTimeObj & obj) {
         return(obj.printMeOut(os));
      }
      
      ostream& DateTimeObj::printMeOut(ostream& os)
      {
         os << *theDate << " at " << *theTime;
         return os;
      }
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\dcfrmrev.cxx ===
/*
 * REVISIONS:
 */

#include "cdefine.h"

#if (C_OS & C_OS2)
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#endif

extern "C" {
#if (C_PLATFORM & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>

#include <string.h>
}

#include "dcfrmrev.h"


//-------------------------------------------------------------------

DecimalFirmwareRevSensor :: DecimalFirmwareRevSensor
(PDevice aParent, PCommController aCommController)
      : Sensor(aParent, aCommController, DECIMAL_FIRMWARE_REV)
{
    theDevice = aParent;
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\dcomctrl.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy30Apr93: Split off from comctrl
 *  pcy02May93: Added missing endif
 *  cad19May93: Added IsA() method
 *  cad27May93: added include file to reduce lib size
 *
 */
#ifndef __DCOMCTRL_H
#define __DCOMCTRL_H

#include "_defs.h"
//
// Defines
//
_CLASSDEF(DevComContrl)

//
// Implementation uses
//
#include "comctrl.h"


class DevComContrl : public CommController {

protected:

   PUpdateObj  theParent;

public:

	DevComContrl(PUpdateObj aParent);
	virtual ~DevComContrl();

   virtual INT Initialize();
   virtual INT Update(PEvent anEvent);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\devctrl.h ===
/*
*
* NOTES:
*
* REVISIONS:
*  pcy24Nov92: Get rid of PopUps, EventLog.  It belongs in the App.
*              Use _CLASSDEF rather than includes for interfaces.
*              Use apc.h
*  pcy15Dec92: Include comctrl.h and ups.h since definition uses
*  ane11Jan93: Added slave related members
*  ane03Feb93: Added state and SetInvalid
*  rct06Feb93: Removed VOID form SlaveOn's args, made isA() IsA()
*  tje24Feb93: Conditionally removed slave stuff for Window's version
*  cad11Jun93: Added mups
*  cad15Nov93: Changed how comm lost works
*  pcy08Apr94: Trim size, use static iterators, dead code removal
*  ajr13Feb96: Port to SINIX.  can't mix // with cpp directives
*  tjg26Jan98: Added Stop method
*/

#ifndef __DEVCTRL_H
#define __DEVCTRL_H

#include "_defs.h"
#include "apc.h"

_CLASSDEF(DeviceController)

//
// Definition uses
//
#include "contrlr.h"
#include "comctrl.h"
#include "ups.h"
#include "mainapp.h"

//
// Interface Uses
//
_CLASSDEF(Event)
_CLASSDEF(CommController)
_CLASSDEF(UpdateObj)



class DeviceController : public Controller
{
public:
    DeviceController(PMainApplication anApp);
    virtual ~DeviceController();

    virtual INT    Get(INT code, PCHAR value);
    virtual INT    Set(INT code, const PCHAR value);
    virtual INT    Update(PEvent aEvent);
    virtual INT    RegisterEvent(INT aEventCode, PUpdateObj aUpdateObj);
    virtual INT    Initialize();
    virtual INT    CreateUps();
    VOID   SetInvalid();
    VOID   Stop();

protected:
    PCommController   theCommController;
    PUps              theUps;
    PMainApplication  theApplication;

    INT           slaveEnabled;

private:
    INT theState;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\device.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  xxxddMMMyy 
 *
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */
#include "cdefine.h"

extern "C" {
#include <stdlib.h>
#include <string.h>
}

#include "_defs.h"
#include "apc.h"
#include "device.h"
#include "devctrl.h"
#include "err.h"

Device :: Device(PUpdateObj aDeviceController, PCommController aCommController)
	: UpdateObj()
{
	theCommController = aCommController;
	theDeviceController = aDeviceController;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\datetime.h ===
/*
* NOTES:
*
* REVISIONS:
*  pcy30Mar95: Initial revision
*  pav11Jul95: Merged in Windows 16 bit needs
*  djs12Sep95: Port to Unix
*  ntf03Jan96: Added operator<< functionality so that datetime.cxx would compile
*  ajr14Feb96: SINIX merge
*/

#ifndef _DATETIME_H
#define _DATETIME_H

#include "apc.h"
#include "_defs.h"

_CLASSDEF(DateTimeObj)
_CLASSDEF(DateObj)
_CLASSDEF(TimeObj)
_CLASSDEF(WeekObj)

#ifdef APCDEBUG
class ostream;
#endif

#include "err.h"
#include "apcobj.h"

#if (C_OS & C_UNIX)
#if (!(C_OS & C_SINIX))
#include <iostream.h>
#endif
#endif

#if (C_OS & C_WIN311)

class TimeObj : public Obj
{
private:
   INT theHours;
   INT theMinutes;
   INT theSeconds;
   
protected:
#ifdef APCDEBUG
   virtual ostream& printMeOut(ostream& os);
#endif
   
public:
   
#ifdef APCDEBUG
   friend ostream& operator<< (ostream& os, TimeObj &);
#endif
   
   TimeObj();
   TimeObj(PCHAR);
   TimeObj(INT aHours, INT aMinutes, INT aSeconds);
   
   virtual INT GetHour() const;
   virtual INT GetMinutes() const;
   virtual INT GetSeconds() const;
   VOID SetHour(INT hour);
   VOID SetMinutes(INT minutes);
   VOID SetSeconds(INT seconds);
   INT Equal(PTimeObj atime);
   virtual INT operator < (const RTimeObj cmp) const;
};

class WeekObj : public Obj
{
private:
   INT theWeekDay;
   
public:
   WeekObj();
   WeekObj(PCHAR);
   WeekObj(INT Day);
   INT GetWeekDay();
};

class DateObj : public Obj
{
private:
   INT theMonth;
   INT theDay;
   INT theYear;
   
protected:
#ifdef APCDEBUG
   virtual ostream& printMeOut(ostream& os);
#endif
   
public:
   
#ifdef APCDEBUG
   friend ostream& operator<< (ostream& os, DateObj &);
#endif
   
   DateObj();
   DateObj(INT aMonth,INT aDay,INT aYear);
   
   virtual INT GetMonth() const;
   virtual INT GetDay()   const;
   virtual INT GetYear()  const;
   virtual INT GetDaysInMonth() const;
   virtual INT GetDaysInMonth (const INT, const INT aYear = 1) const;   
   virtual INT operator == (const RDateObj cmp) const;
   virtual INT operator < (const RDateObj cmp) const;
   virtual LONG operator - (const RDateObj cmp) const;
   VOID SetMonth(INT month);
   VOID SetDay(INT day);
   VOID SetYear(INT year);
};


// The constructor takes the following arguements.
// Month - 1-12
// Day   - 1-31 , Depending upon the month.
// Year  -- YY  , Example 92
// Hour  -- HH , Military time. ( 24 Hour Clock)
// Minutes -- MM ,0-59
// Seconds -- SS, 0-59
class DateTimeObj : public Obj
{
private:
   PDateObj theDate;
   PTimeObj theTime;
   
protected:
#ifdef APCDEBUG
   virtual ostream& printMeOut(ostream& os);
#endif
   
public:
   
#ifdef APCDEBUG
   friend ostream& operator<< (ostream& os, DateTimeObj &);
#endif
   
   DateTimeObj();
   DateTimeObj(INT aMonth,INT aDay, INT aYear,INT anHour, INT aMinutes,
      INT aSeconds);
   DateTimeObj (const RDateTimeObj aDate);
   virtual ~DateTimeObj();
   PDateObj GetDate() const;
   PTimeObj GetTime() const;
   virtual INT   operator < (const RDateTimeObj cmp) const;
   virtual LONG GetMilliseconds();
   virtual LONG GetSeconds();
};

#else

class TimeObj : public Obj
{
private:
   ULONG theHours;
   ULONG theMinutes;
   ULONG theSeconds;
   
protected:
#ifdef APCDEBUG
   virtual ostream& printMeOut(ostream& os);
#endif
   
public:
   
#ifdef APCDEBUG
   friend ostream& operator<< (ostream& os, TimeObj &);
#endif
   
   TimeObj();
   TimeObj(PCHAR);
   TimeObj(ULONG aHours, ULONG aMinutes, ULONG aSeconds);
   
   virtual ULONG GetHour() const;
   virtual ULONG GetMinutes() const;
   virtual ULONG GetSeconds() const;
   VOID SetHour(ULONG hour);
   VOID SetMinutes(ULONG minutes);
   VOID SetSeconds(ULONG seconds);
   INT Equal(PTimeObj atime);
   virtual INT operator < (RTimeObj cmp) const;
};

class WeekObj : public Obj
{
private:
   ULONG theWeekDay;
   
public:
   WeekObj();
   WeekObj(PCHAR);
   WeekObj(ULONG Day);
   ULONG GetWeekDay();
};

class DateObj : public Obj
{
private:
   ULONG theMonth;
   ULONG theDay;
   ULONG theYear;
   
protected:
#ifdef APCDEBUG
   virtual ostream& printMeOut(ostream& os);
#endif
   
public:
   
#ifdef APCDEBUG
   friend ostream& operator<< (ostream& os, DateObj &);
#endif
   
   DateObj();
   DateObj(ULONG aMonth,ULONG aDay,ULONG aYear);
   
   virtual ULONG GetMonth() const;
   virtual ULONG GetDay()   const;
   virtual ULONG GetYear()  const;
   virtual ULONG GetDaysInMonth() const;
   virtual ULONG GetDaysInMonth (const ULONG, const ULONG aYear = 1) const;   
   virtual INT operator == (RDateObj cmp) const;
   virtual INT operator < (RDateObj cmp) const;
   virtual LONG operator - (RDateObj cmp) const;
   VOID SetMonth(ULONG month);
   VOID SetDay(ULONG day);
   VOID SetYear(ULONG year);
};


// The constructor takes the following arguements.
// Month - 1-12
// Day   - 1-31 , Depending upon the month.
// Year  -- YY  , Example 92
// Hour  -- HH , Military time. ( 24 Hour Clock)
// Minutes -- MM ,0-59
// Seconds -- SS, 0-59
class DateTimeObj : public Obj
{
private:
   PDateObj theDate;
   PTimeObj theTime;
   
protected:
#ifdef APCDEBUG
   virtual ostream& printMeOut(ostream& os);
#endif
   
public:
   
#ifdef APCDEBUG
   friend ostream& operator<< (ostream& os, DateTimeObj &);
#endif
   
   DateTimeObj();
   DateTimeObj(ULONG aMonth,ULONG aDay,ULONG aYear,ULONG anHour,ULONG aMinutes,
      ULONG aSeconds);
   DateTimeObj (RDateTimeObj aDate);
   virtual ~DateTimeObj();
   PDateObj GetDate() const;
   PTimeObj GetTime() const;
   virtual INT   operator < (RDateTimeObj cmp) const;
   virtual LONG GetMilliseconds();
   virtual LONG GetSeconds();
};

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\devctrl.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy24Nov92: Use apc.h.  Remove Popups and event log (now in App).
 *  SjA11Dec92: Registers events with the theUps now. Doesn't update twice now.
 *  pcy11Dec92: include smartups.h instead of backups.h
 *  pcy11Dec92: Initialize theCommController in the constructor
 *  ane16Dec92: Comment out passing of gets/sets to host object, handled in app now
 *  ane05Jan93: Added code to support slaves
 *  ane11Jan93: Register for additional events when a slave
 *  pcy26Jan93: Construct SmartUps/BackUps based on ini file
 *  pcy26Jan93: Return construction errors in theObjectStatus
 *  ane03Feb93: Added state and SetInvalid and state checking
 *  pcy16Feb93: Get rid of SORRY CHARLIE debug msg
 *  tje24Feb93: Added Windows support
 *  jod14May93: Added Matrix changes.
 *  cad10Jun93: Added MeasureUPS support
 *  cad15Jul93: Moved add-ons to under smart comm
 *  cad04Aug93: Fixed up admin shutdown handling
 *  cad27Aug93: Added handler for is measureups attached get
 *  cad14Sep93: Handling measureups non-null, but not really there
 *  cad20Oct93: Better MUPS checking
 *  cad27Oct93: even better than that
 *  jod02Nov93: Added CIBC conditional statements
 *  cad11Nov93: Changed handling of Comm Lost
 *  cad17Nov93: .. more little fixups
 *  rct21Dec93: fixed bug in Get()
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  ajr22Aug94: Lets not auto-detect mups because of ShareUps problems.
 *  ajr14Feb96: Sinix merge
 *  cgm29Feb96: Delete the created UPS if lost comm in first 3-10 sec
 *  djs22Feb96: Changed to new firmware rev interface
 *  cgm29Feb96: (NetWare) Override switch
 *  cgm17Apr96: Delete the ups before commcontroller
 *  cgm17Apr96: Don't create measureups without valid ups object
 *  djs17May96: Added DarkStar device
 *  srt02Apr97: Added fix for potential bug
 *  tjg02Dec97: Changed darkstar to symmetra
 *  tjg26Jan98: Added Stop method
 *  clk13May98: When getting value for IS_SYMMETRA, always get value from UPS
 *  mholly12May1999:  special handling of TURN_OFF_SMART_MODE code
 *
 *  v-stebe  29Jul2000   Fixed PREfix error (bug #112614)
 */


#include "cdefine.h"

extern "C" {
#include <stdio.h>
#include <stdlib.h>
}

#include "_defs.h"
#include "apc.h"
#include "cdevice.h"
#include "devctrl.h"
#include "ups.h"
#include "err.h"
#include "dispatch.h"
#include "smartups.h"
#include "matrix.h"
#include "codes.h"
#include "cfgmgr.h"
#include "dcomctrl.h"



DeviceController::DeviceController(PMainApplication anApp)
: Controller(),
  theApplication(anApp),
  slaveEnabled(FALSE),
  theUps((PUps)NULL)
{
    INT err = ErrNO_ERROR;

    theCommController = new DevComContrl(this);

    theCommController->RegisterEvent(COMMUNICATION_STATE, this);


    theCommController->RegisterEvent(SHUTDOWN,this);
    theCommController->RegisterEvent(UPS_OFF_PENDING,this);
    theObjectStatus = theCommController->GetObjectStatus();

    if(theObjectStatus == ErrNO_ERROR)  {

        if (theUps) {
            theObjectStatus = theUps->GetObjectStatus();
        }
    }
    else {
        theUps = (PUps)NULL;
    }

    theApplication->RegisterEvent(EXIT_THREAD_NOW, this);
}



DeviceController::~DeviceController()
{
    theApplication->UnregisterEvent(EXIT_THREAD_NOW, this);

    // Must delete theUps object before theCommController
    delete theUps;
    theUps = (PUps)NULL;

    delete theCommController;
    theCommController = (PCommController)NULL;
}


INT DeviceController::Initialize()
{
    INT err = ErrNO_ERROR;

    theCommController->Initialize();

    return err;
}


INT DeviceController::CreateUps()
{
    INT err = ErrNO_ERROR;
    CHAR value[32];

    if (!theUps) {
        _theConfigManager->Get(CFG_UPS_SIGNALLING_TYPE, value);

        if( (_strcmpi(value, "SIMPLE") == 0) || (slaveEnabled == TRUE)) {
            theUps = new BackUps(this, theCommController);
        }
        else {
            FirmwareRevSensor theFirmwareRevSensor(((PDevice)NULL), theCommController);

            CHAR Is_Ups_A_Symmetra[32];
            theFirmwareRevSensor.Get(IS_SYMMETRA,Is_Ups_A_Symmetra);

            if (_strcmpi(Is_Ups_A_Symmetra,"Yes") == 0) {
                theUps = new Matrix(this, theCommController);
            }
            else {
                CHAR Is_Ups_A_Matrix[32];
                theFirmwareRevSensor.Get(IS_MATRIX,Is_Ups_A_Matrix);

                if (_strcmpi(Is_Ups_A_Matrix,"Yes") == 0) {
                    theUps = new Matrix(this, theCommController);
                }
                else {
                    theUps = new SmartUps(this, theCommController);

                    if ((theUps->GetObjectStatus()) == ErrSMART_MODE_FAILED) {
                        delete theUps;
                        theUps = (PUps) NULL;
                    }
                }
            }
        }

        if (theUps) {
            theUps->Initialize();
            theDispatcher->RefreshEventRegistration(theUps, this);
            theCommController->GetDevice()->OkToPoll();
        }
    }
    return err;
}


INT DeviceController::Get(INT code, PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    INT comm = FALSE;

    switch(code/1000)
    {
    case UPS/1000:
        if (code == COMMUNICATION_STATE) {

            if (theCommController) {
                err = theCommController->Get(COMMUNICATION_STATE, aValue);
            }
            else {
                sprintf(aValue, "%d", COMMUNICATION_LOST);
            }
        }
        else if (theUps && theCommController &&
            !(theCommController->GetDevice()->HasLostComm())) {
            err = theUps->Get(code, aValue);
        }
        else if (theUps && (code == IS_SYMMETRA)) {
            err = theUps->Get(code, aValue);
        }
        else {
            err = ErrINVALID_VALUE;
        }
        break;

    case MEASURE_UPS/1000:
        if (code == IS_MEASURE_UPS_ATTACHED) {
            strcpy(aValue, "No");
        }
        else {
            err = ErrNO_MEASURE_UPS;
        }
        break;

    case INTERNAL/1000:
        if ((code == RETRY_CONSTRUCT) && theCommController) {
            err = theCommController->Get(code, aValue);
        }
        break;

    case IS_LINE_FAIL_RUN_TIME_ENABLED/1000:
        theApplication->Get(code, aValue);
        break;
    }
    return err;
}



INT DeviceController::Set(INT code, const PCHAR aValue)
{
    INT err = ErrNO_ERROR;

    switch(code/1000)  {

    case UPS/1000:

        if (theUps && theCommController &&
            !(theCommController->GetDevice()->HasLostComm())) {

            if (TURN_OFF_SMART_MODE == code) {
                err = theCommController->Set(code, aValue);
            }
            else {
                err = theUps->Set(code, aValue);
            }
        }
        break;

    case MEASURE_UPS/1000:
        err = ErrNO_MEASURE_UPS;
        break;

    case INTERNAL/1000:
        if ((code == RETRY_CONSTRUCT) && theCommController) {
            err = theCommController->Set(code, aValue);
        }
        break;
    }
    return err;
}


INT DeviceController::Update(PEvent anEvent)
{
    switch (anEvent->GetCode()) {
    case COMMUNICATION_STATE:

        if (atoi(anEvent->GetValue()) == COMMUNICATION_ESTABLISHED) {
            CreateUps();
        }
        else {

            if(theUps) {
                CHAR val[32];
                theUps->Get(UPS_STATE, val);

                if(atoi(val) & UPS_STATE_ON_BATTERY)  {
                    anEvent->SetValue(COMMUNICATION_LOST_ON_BATTERY);
                }
            }
        }
        break;
    }
    INT err;

    if ( (theCommController->GetDevice()->HasLostComm() == FALSE) ||
        (anEvent!=NULL && anEvent->GetCode()==COMMUNICATION_STATE &&
        atoi(anEvent->GetValue()) != COMMUNICATION_ESTABLISHED))
    {
        err = UpdateObj::Update(anEvent);
    }
    return err;
}


INT DeviceController::RegisterEvent(INT id, UpdateObj* object)
{
    INT err = UpdateObj::RegisterEvent(id,object);

    if (err == ErrNO_ERROR) {

        if (id == SHUTDOWN_STATUS ||
            id == ADMIN_SHUTDOWN ||
            id == CANCEL_SHUTDOWN)  {
            theApplication->RegisterEvent(id, this);
        }
        else {

            switch(id/1000)  {

            case UPS/1000:

                if (theUps) {
                    err = theUps->RegisterEvent(id, object);
                }
                break;

            case MEASURE_UPS/1000:
                break;
            }
        }
    }
    return err;
}


VOID DeviceController::SetInvalid()
{
}


VOID DeviceController::Stop()
{
    if (theCommController) {
        theCommController->Stop();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\dispatch.cxx ===
/*
 * REVISIONS:
 *  pcy30Nov92: Added header 
 *  ane02Dec92: Changed Dispatcher to inherit from Obj (see comment)
 *  rct09Feb93: Corrected some #ifdefs
 *  pcy21Apr93: Added method to get list and re register
 *  pcy15May93: Cleaned up
 *  cad19May93: bug fix, RListIterator decl as ListIterator
 *  cad27Sep93: Not adding to event nodes twice, returning error code in Add
 *  cad28Feb94: nulling list after delete
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *
 *  v-stebe  29Jul2000   Fixed PREfix errors (bug #46362)
 */

#include "cdefine.h"


#if (C_OS & C_OS2)
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#endif

#if (C_OS & (C_WINDOWS | C_WIN311))
#define NOLFILEIO
#include <windows.h>
#endif

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#if (C_OS & C_NLM)
#include <process.h>
#endif
}
#include "err.h"
#include "event.h" 
#include "dispatch.h" 


// =========================================================================
// Method Definitions for the EventNode Class.

/*
  Name  :EventNode
  Synop :Constructor for the EventNode. Use this when you are first creating
         and eventNode. anUpdateObj is the first updateable object in the
         internal linked list managed by the EventNode.
*/
EventNode::EventNode(INT anEventCode,PUpdateObj anUpdateObj)
{
  // 1. Create the list
  theUpdateList = new List();
  theEventCode  = anEventCode;

  // 2. Add the first node to the list.
  Add(anUpdateObj);
}

/*
  Name  :~EventNode
  Synop :Destructor. Will delete the internal linked list. The Linked list
         flush'es its nodes and all will be well. Does not delete the updateable
         objects which it contains in the linked list. We don't own those.
*/
EventNode::~EventNode()
{
  delete theUpdateList;
  theUpdateList = NULL;
}

INT EventNode::Add(PUpdateObj anUpdateObj)
{
   INT err = ErrNO_ERROR;

   if (theUpdateList)
      {
      ListIterator  obj_iter(*theUpdateList);

      INT add_the_obj = TRUE;
      INT num_attrs = theUpdateList->GetItemsInContainer();
      for (INT i=0; i<num_attrs; i++)
         {
         RUpdateObj an_obj = (RUpdateObj)obj_iter.Current();
         if(an_obj == *anUpdateObj)
            {
            add_the_obj = FALSE;
            break;
            }
         obj_iter++;
         }

      if(add_the_obj)
         {
         theUpdateList->Append(anUpdateObj);
         }
      else
         {
         err = ErrALREADY_REGISTERED;
         }
    }
   return err;
}

/*
  Name  :Detach
  SYnop :Removes an updateable object from the EventNode.
*/

VOID EventNode::Detach(PUpdateObj anUpdateObj)
{
   if (theUpdateList)
      {
      // The Equal() method for the Object must be implemented correctly
      // for this to work...

      theUpdateList->Detach(*anUpdateObj);
      }
}

/*
  Name  :Update
  Synop :Update will update all the updateable objects in its internal linked
         list. It handles all of that. Returns after all the updateable objects
         have been updated.
*/
INT EventNode::Update(PEvent anEvent)
{
    ListIterator an_iterator(*theUpdateList);
    INT items_in_container = theUpdateList->GetItemsInContainer();

    for(INT i=0;i<items_in_container;i++) {
        PUpdateObj an_update_obj=(PUpdateObj)&an_iterator.Current();
        an_iterator++;
        an_update_obj->Update(anEvent);
    }
    return ErrNO_ERROR;
}

// =========================================================================
// Method definitions for the Dispatcher Object.



Dispatcher::Dispatcher()
{
    theDispatchEntries = (PList)NULL;
}


/*
  Name  :~Dispatcher
  Synop :The destructor of the dispatcher which simply delete the list
        object. It is important to note that this does NOT cause the
        list object to delete the UpdateAble objects we have stored within
        the list. We DO NOT WANT those object to be deleted since we do
        not own them. Imagine what would happen if we did. If you revise
        the dispatcher, don't forget that!

*/
Dispatcher::~Dispatcher()
{
    if(theDispatchEntries) {
        theDispatchEntries->FlushAll();
        delete theDispatchEntries;
        theDispatchEntries = (PList)NULL;
    }
}


INT  Dispatcher::RegisterEvent(INT id, PUpdateObj item)
{
   if (theDispatchEntries == NULL)
      {
      theDispatchEntries = new List();
      }
    
   INT err = ErrNO_ERROR;
   INT not_in_list = TRUE;

   if (theDispatchEntries != NULL) {
     ListIterator an_iterator(*theDispatchEntries);
     INT items_in_container=theDispatchEntries->GetItemsInContainer();
     for (INT i = 0; (i < items_in_container) && not_in_list; i++)
        {
        REventNode an_event_node = (REventNode) an_iterator.Current();
        an_iterator++;

        if (an_event_node.GetEventCode() == id)
           {
           err = an_event_node.Add(item);
           not_in_list = FALSE;
           }
        }

     if (not_in_list && (err == ErrNO_ERROR))
        {
        theDispatchEntries->Append(new EventNode(id,item));
        }
   }
   else {
     err = ErrREGISTER_FAILED;
   }

   return err;
}

INT  Dispatcher::UnregisterEvent(INT id, PUpdateObj item)
{
   INT err = ErrINVALID_CODE;
   ListIterator an_iterator(*theDispatchEntries);

   INT items_in_container = theDispatchEntries->GetItemsInContainer();

   for(INT i = 0; i < items_in_container; i++)
      {
      REventNode an_event_node=(REventNode)an_iterator.Current();
      an_iterator++;
      if (an_event_node.GetEventCode() == id)
         {
         an_event_node.Detach(item);
         err = ErrNO_ERROR;
         break;
         }
      }

   return err;;
}


INT  Dispatcher:: Update(PEvent anEvent)
{
   ListIterator an_iterator(*theDispatchEntries);

   INT items_in_container=theDispatchEntries->GetItemsInContainer();
   for(INT i=0;i<items_in_container;i++)
      {
      PEventNode an_event_node=(PEventNode)&an_iterator.Current();
   
      if(an_event_node->GetEventCode() == anEvent->GetCode())
         {
         an_event_node->Update(anEvent);
         break;
         }
      an_iterator++;

      #if (C_OS & C_NLM)
	ThreadSwitch();
      #endif
      }

   return ErrNO_ERROR;
}





INT
Dispatcher :: RefreshEventRegistration(PUpdateObj anUpdater, 
                                       PUpdateObj aRegistrant)
{
    ListIterator an_iterator(*theDispatchEntries);

    INT items_in_container=theDispatchEntries->GetItemsInContainer();

    for(INT i=0;i<items_in_container;i++)  {
        REventNode an_event_node=(REventNode)an_iterator.Current();
        INT code = an_event_node.GetEventCode();
        anUpdater->RegisterEvent(code, aRegistrant);
        an_iterator++;
    }

    return ErrNO_ERROR;
}


INT Dispatcher :: GetRegisteredCount(INT id)
{
    INT the_count = 0;
    ListIterator an_iterator(*theDispatchEntries);


    INT items_in_container=theDispatchEntries->GetItemsInContainer();

    for(INT i=0;i<items_in_container;i++) {
        REventNode an_event_node=(REventNode)an_iterator.Current();
        an_iterator++;
        if (an_event_node.GetEventCode() == id) {
            the_count = an_event_node.GetCount();
            break;
        }
    }

    return the_count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\device.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy28Dec92: A Device's parent is now an UpdateObj
 *  rct17May93: Added IsA()
 *
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */
#ifndef __DEVICE_H
#define __DEVICE_H

#include "_defs.h"
#include "update.h"
#include "comctrl.h"

_CLASSDEF(Device)
_CLASSDEF(CommController)
_CLASSDEF(Event)
_CLASSDEF(Dispatcher)
_CLASSDEF(Sensor)



class Device : public UpdateObj
{
public:
	Device(PUpdateObj aDevice, PCommController aCommController);
	virtual int    Get(int code, PCHAR value) = 0;
	virtual int    Set(int code, const PCHAR value) = 0;
    virtual VOID   GetAllowedValue(INT code, PCHAR aValue) {};

protected:
	PCommController theCommController;
	PUpdateObj theDeviceController;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\dispatch.h ===
/*
 * REVISIONS:
 *  pcy30Nov92: Added header 
 *  pcy21Apr93: Added method to get list and re register
 *  cad27Sep93: Add now return error code
 *  cad28Sep93: Made sure destructor(s) virtual
 */

#ifndef     __DISPATCH_H
#define     __DISPATCH_H 


#include "apc.h"

//
// Defines
//
_CLASSDEF(Dispatcher)
_CLASSDEF(EventNode)

//
// Implementation uses
//
#include "update.h"
#include "list.h"


//
// Interface uses
//
_CLASSDEF(Event)


class EventNode : public UpdateObj
{
protected:
  PList theUpdateList;
  INT   theEventCode;

public:
   EventNode(INT anEventCode,PUpdateObj anUpdateObj);
   virtual ~EventNode();
   virtual INT   Update(PEvent anEvent);
   virtual INT IsA() const{return EVENTNODE;};

   virtual INT       RegisterEvent(INT, PUpdateObj)   {return 0;};
   virtual INT       UnregisterEvent(INT, PUpdateObj) {return 0;};

   virtual INT  Add(PUpdateObj anUpdateObj);
   virtual INT  GetEventCode() { return theEventCode; };
   virtual INT  GetCount() { return theUpdateList->GetItemsInContainer(); };
   virtual VOID Detach (PUpdateObj anUpdateObj);
};

/*************************  DISPATCHER *****************************/

// Dispatcher _cannot_ inherit from UpdateObj since UpdateObj has a dispatcher
// as a data member.  If the Dispatcher class inherits from UpdateObj, then
// the construction of an UpdateObj leads to an infinite loop of the
// UpdateObj constructor calling the Dispatcher constructor which turns around
// and calls the UpdateObj constructor.

class Dispatcher : public Obj {

private:

   PList   theDispatchEntries;

public:

    Dispatcher();
    virtual ~Dispatcher();

    virtual INT RegisterEvent(INT id,PUpdateObj anUpdateObj);
    virtual INT UnregisterEvent(INT id,PUpdateObj anUpdateObj);
    virtual INT Update(PEvent anEvent);
    virtual INT RefreshEventRegistration(PUpdateObj anUpdater, 
					 PUpdateObj aRegistrant);
    virtual PList GetDispatchList() { return theDispatchEntries; };
    virtual INT GetRegisteredCount(INT id);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\errlog.h ===
/*
 * REVISIONS:
 *  ane20Jan93:  Initial Revision
 *  cad27Dec93: include file madness
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  jps13Jul94: removed os2.h, caused problem in 1.x
 *  cgm11Dec95: use LONG type; switch to Watcom 10.5 compiler for NLM 
 */

#ifndef __ERRLOG_H
#define __ERRLOG_H


#include "cdefine.h"

#include "codes.h"
#include "apcobj.h"

_CLASSDEF(ErrorLog)


class ErrorLog : public Obj {

private:
   
public:
   ErrorLog() {};
   virtual LONG GetMaximumSize(void)=0;
   virtual const PCHAR GetFileName(void)=0;
   virtual void SetMaximumSize(long)=0;
   virtual INT AppendRecord(const PCHAR)=0;
   virtual INT ClearFile()=0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\eeprom.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker04DEC92  Initial OS/2 Revision 
 *  pcy26Jan93: Superclassed EepromChoiceSensor w/ EepromSensor
 *  pcy26Jan93: Handle Dip switch events
 *  rct15Jun93: Added error code for getAllowedValues()
 *  cad04Mar94: fix for access problem
 *  dml13Oct95: fixed assignment in logical expression (needed ==)
 *  cgm12Apr96: Add destructor with unregister
 *  inf20Mar97: Loaded error string from resource file
 *  mholly22Oct98	: recognize ErrITEM_NOT_FOUND as a valid error from
 *					theConfigManager->Get in the getAllowedValues method
 */

extern "C" {
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "eeprom.h"
#include "cfgmgr.h"
#include "event.h"
#include "device.h"


//Constructor

EepromSensor::EepromSensor(PDevice aParent, PCommController aCommController,
      INT aSensorCode, ACCESSTYPE anACCESSTYPE)
      : Sensor(aParent,aCommController, aSensorCode, anACCESSTYPE)
{
   theCommController->RegisterEvent(EEPROM_CHANGED, this);
}

EepromSensor::~EepromSensor()
{
   theCommController->UnregisterEvent(EEPROM_CHANGED, this);
}

INT EepromSensor::Update(PEvent anEvent)
{
   INT val;

    switch(anEvent->GetCode())  {
      case EEPROM_CHANGED:
            //
            //
            DeepGet();
            break;
        case DIP_SWITCH_POSITION:
            //
            // If the dip swicthes change, reget the valu from the UPS
            // and if not all zeros, we cant change the settings so we
            // set our access to read only.  This probably shouldn't be
            // here since it ties UPS implementation to the values of the
            // Dip switches.  Oh well.
            //
            DeepGet();

            val = (atoi(anEvent->GetValue()) == 0) ? AREAD_WRITE : AREAD_ONLY;
            SetEepromAccess(val);
            break;
        default:
            Sensor::Update(anEvent);
            break;
    }
    return ErrNO_ERROR;
}

INT EepromSensor::Set(const PCHAR aValue)
{
    return Sensor::Set(aValue);
}
    

VOID EepromSensor::SetEepromAccess(INT anAccessCode)
{
    readOnly = (ACCESSTYPE)anAccessCode;
}


INT EepromSensor::setInitialValue()
{
    return ErrNO_ERROR;
}


EepromChoiceSensor:: EepromChoiceSensor(PDevice aParent, PCommController aCommController,
                                        INT aSensorCode, ACCESSTYPE anACCESSTYPE)
:EepromSensor(aParent,aCommController, aSensorCode, anACCESSTYPE)
{
   //Set the Values
   theAllowedValues = (PCHAR)NULL;
}

 EepromChoiceSensor::~EepromChoiceSensor() {
     free(theAllowedValues);
 }

INT EepromChoiceSensor::Validate(INT aCode, const PCHAR aValue)
{
    INT err = ErrNO_ERROR;

    if(aCode!=theSensorCode)
        err =  ErrINVALID_CODE;

    if(theAllowedValues != (PCHAR)NULL)  {
        if(strstr(theAllowedValues, aValue))
            err = ErrNO_ERROR;
        else
            err = ErrINVALID_VALUE;
    }
    else  {
        err = ErrINVALID_VALUE;
    }
    return err;
}


INT EepromChoiceSensor::Get(INT aCode, PCHAR aValue)
{
   INT err = ErrNO_ERROR;

   switch(aCode)
   {
      case ALLOWED_VALUES:
          getCurrentAllowedValues(aValue);
          break;

      default:
          err = Sensor::Get(aCode, aValue);
          break;
   }
   return err;
}



INT EepromChoiceSensor::getAllowedValues()
{
    CHAR value[128];
    CHAR allowedValue[128] = "";
    
    INT cCode = _theConfigManager->GetListValue(lookupSensorName(IsA()), 
        "AllowedValues", value);
    theDevice->GetAllowedValue(theSensorCode, allowedValue);
    
    if (strlen(allowedValue))
    {
        theAllowedValues = _strdup(allowedValue);
        return ErrNO_ERROR;
    }
    else
    {
        theAllowedValues = _strdup(value);
        return cCode;
    }
}


VOID EepromChoiceSensor::getCurrentAllowedValues(PCHAR aValue)
{
   if (theAllowedValues)
      {
      strcpy(aValue, theAllowedValues);
      }
   else
      {
      strcpy(aValue, "");
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\errlogr.cxx ===
/*
 * REVISIONS:
 *  ane20Jan93: Initial Revision
 *  ajr22Feb93: Gave var init its own scope in case statement
 *  pcy07Sep93: Only include FILE and LINE in error message if DEBUG
 *  cad28Sep93: plugged a leak
 *  jod12Nov93: Name Problem Changed name to ErrTextGen
 *  ajr06Dec93: Added errno string on Unix system errors.
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  ajr25Dec94: Changes for SUNOS4
 *  mwh05May94: #include file madness , part 2
 *  mwh06May94: port for SUNOS4 - XOL
 *  cad16Jun94: made error string buffer bigger, some debug msgs needed it!
 *  inf30Mar97: Added overloaded LogError implementation
 */

#include "cdefine.h"
#include "errlogr.h"
#include "err.h"


PErrorLogger _theErrorLogger = NULL;

//
//Constructor
//
ErrorLogger::ErrorLogger(PUpdateObj aParentObject)
{
   _theErrorLogger = this;
}

//
//Destructor
//
ErrorLogger::~ErrorLogger()
{
}


INT ErrorLogger::LogError(INT resourceID, PCHAR aString, PCHAR aFile, INT aLineNumber, INT use_errno)
{
    return ErrNO_ERROR;
}


INT ErrorLogger::LogError(PCHAR anError, PCHAR aFile, INT aLineNumber, INT use_errno)
{
    return ErrNO_ERROR;
}


//
// Get some attribute values
//
INT ErrorLogger::Get(INT aCode, PCHAR aValue)
{
   return ErrNO_ERROR;   
}

//
// Set some attribute values
//
INT ErrorLogger::Set(INT aCode, PCHAR aValue)
{
   return ErrNO_ERROR;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\eeprom.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker04DEC92   Initial OS/2 Revision
 *  pcy14Dec92: Changed READ_ONLY to AREAD_ONLY
 *  pcy26Jan93: Superclass EepromChoice w/ EepromSensor
 *  rct15Jun93: Added error code for getAllowedValues()
 *  ajr29Nov93: Removed methods from class def and resolved some undefined
 *              functions in header
 *  cgm12Apr96: Add destructor with unregister
 *
 */
 
#ifndef __EEPROM_H
#define __EEPROM_H

#include "sensor.h"
#include "errlogr.h"

_CLASSDEF(EepromSensor)
_CLASSDEF(EepromChoiceSensor)

class EepromSensor : public Sensor {
  protected:
    INT setInitialValue();
    

  public:

    EepromSensor(PDevice aParent, PCommController aCommController,
		 INT aSensorCode = NO_SENSOR_CODE, ACCESSTYPE anACCESSTYPE = AREAD_ONLY);

    // overidden interfaces;
    virtual ~EepromSensor();
	virtual INT Set(const PCHAR);
    virtual INT    Update(PEvent anEvent);
    VOID           SetEepromAccess(INT anAccessCode);
};

			  
class EepromChoiceSensor : public EepromSensor {

  protected:

    PCHAR theAllowedValues; 
    virtual VOID getCurrentAllowedValues(PCHAR aValue);
    virtual INT  getAllowedValues();

  public:

    EepromChoiceSensor(PDevice aParent, PCommController aCommController,
		       INT aSensorCode = NO_SENSOR_CODE, ACCESSTYPE anACCESSTYPE = AREAD_ONLY);
    virtual ~EepromChoiceSensor() ;


    // overidden interfaces;

    virtual INT   Get(INT aCode, PCHAR aValue);
    virtual INT   Validate(INT, const PCHAR);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\err.h ===
/*
 * REVISIONS:
 *  pcy07Dec92: Added ErrINVALID_VALUE
 *  pcy21Dec92: Added ErrTEST_IN_PROGRESS
 *  rct29Jan93: Added CfgMgr & file access error codes
 *  pcy18Feb93: Added ErrUPS_STATE_SET
 *  rct21Apr93: Added Process Control errors
 *  tje20Feb93: Added NO_TIMER error
 *  cad10Jun93: Added mups not attached error code
 *  cad02Jul93: Added error for unavailable lights test
 *  pcy16Jul93: Added errors for thread creation and mailslots
 *  pcy09Sep93: Added NOT_LOGGED_IN and renumbered to fix duplicates
 *  cad10Sep93: Added code for standalone network
 *  rct16Nov93: Added SPX and single thread errors
 *  cad11Jan94: added generally useful codes
 *  ntf28Dec95: had to add ErrNO_PROCESSORS to this version of err.h
 *              someone used this is utils.cxx at some stage but it
 *              seems to have been merged out of err.h at some stage.
 *  djs22Feb96: Added increment error codes
 *  djs17May96: Added DarkStar codes
 *  ash17Jun96: Added RPC codes
 *  pav19Jun96: Added sockets codes
 *  tjg18Sep96: Added server connection codes
 *  tjg03Dec97: Added ErrNOT_INSTALLED for IM and RIM error conditions
 *  clk12Jan98: Added ErrWINDOW_CLOSE_FAILED to close all windows
 *  jk19Aug98:  Added smart schedule events overflow error codes
 */
#ifndef __ERR_H
#define __ERR_H

#define ErrNO_ERROR                       0
#define ErrMEMORY                         1
#define ErrREAD_ONLY                      2
#define ErrSAME_VALUE                     3
#define ErrNO_VALUE                       4
#define ErrINVALID_CODE                   5
#define ErrCONTINUE                       6
#define ErrOPEN_FAILED                    7
#define ErrUNSUPPORTED                    8
#define ErrNOT_POLLABLE                   9
#define ErrWRITE_FAILED                   10
#define ErrREAD_FAILED                    11
#define ErrTIMED_OUT                      12
#define ErrTYPE_COMBINATION               13

#define ErrSMART_MODE_FAILED              14
#define ErrLIGHTSTEST_REQUEST_FAILED      15
// see ErrLIGHTSTEST_NOT_AVAIL below
#define ErrTURNOFFAFTERDELAY_NOT_AVAIL    16
#define ErrSHUTDOWN_NOT_AVAIL             17
#define ErrSIMULATEPOWERFAILURE_NOT_AVAIL 18
#define ErrBATTERYTEST_NOT_AVAIL          19
#define ErrBATTERYCALIBRATION_CAP_TOO_LOW 20
#define ErrBATTERYCALIBRATION_NOT_AVAIL   21
#define ErrBYPASSTEST_ERROR               22
#define ErrBATTERYTEST_BAD_BATTERY        23
#define ErrBATTERYTEST_NO_RECENT_TEST     24
#define ErrBATTERYTEST_INVALID_TEST       25
#define ErrCOPYRIGHT_RESP_ERROR           26
#define ErrEEPROM_RESP_ERROR              27
#define ErrDECREMENT_NOT_AVAIL            28
#define ErrDECREMENT_NOT_ALLOWED          29

#define ErrSET_VALUE_NOT_FOUND            30
#define ErrSET_FAILED                     31
#define ErrBUILD_FAILED                   32
#define ErrBAD_RESPONSE_VALUE             33
#define ErrCOMMUNICATION_LOST             34
#define ErrINVALID_VALUE                  35
#define ErrNO_STATE_CHANGE                36

#define ErrDELETE_FAILED                  37
#define ErrRENAME_FAILED                  38
#define ErrTEST_IN_PROGRESS               39

#define ErrSCHEDULE_CONFLICT              40
#define ErrUSE_MASTER                     41
#define ErrINVALID_ITEM_CODE              42
#define ErrITEM_NOT_CACHED                43
#define ErrDEFAULT_VALUE_USED             44

#define ErrFILE_NOT_FOUND                 45
#define ErrACCESS_DENIED                  46
#define ErrBUF_TOO_SMALL                  47
#define ErrCOMPONENT_NOT_FOUND            48
#define ErrITEM_NOT_FOUND                 49
#define ErrINVALID_ITEM                   50
#define ErrUNKNOWN_FAILURE                51

#define ErrRETRYING_COMM                  52
#define ErrUPS_STATE_SET                  53

#define ErrSEM_BLOCK_NG                   54
#define ErrSEM_TIMED_OUT                  55
#define ErrSEM_RELEASE_ERROR              56
#define ErrSEM_CREATE_FAILED              57
#define ErrSEM_GENERAL_ERROR              58
#define ErrSEM_CLOSING_FLAG_SET           59

#define ErrLIST_EMPTY                     60
#define ErrPOSITION_NOT_FOUND             61

#define ErrCLOSING                        62
#define ErrBLOCK                          63
#define ErrNO_BLOCK                       64
#define ErrBAD_HANDLE                     65

#define ErrNO_TIMER                       66
#define ErrALREADY_REGISTERED             67

#define ErrNO_MEASURE_UPS                 68
#define ErrOUT_OF_RANGE                   69

#define ErrNETWORK_DOWN                   70
#define ErrINVALID_PASSWORD               71

#define ErrLIGHTSTEST_NOT_AVAIL           72
#define ErrTHREAD_CREATE_FAILED           73

#define ErrFAILED_TOGETMAILINFO           74
#define ErrFAILED_TOWRITEMAIL             75
#define ErrFAILED_TOCREATEMAILFILE        76
#define ErrFAILED_MAILSLOTCREATION        77
#define ErrFAILED_TOREADMAILBOX           78
#define ErrFAILED_TOCLOSEMAILSLOT         79

#define ErrTRIP_SET                       80
#define ErrTRIP1_SET                      81
#define ErrSTATE_SET                      82

#define ErrNOT_LOGGED_ON                  83
#define ErrSTANDALONE_SYSTEM              84

#define ErrINVALID_CONNECTION             85
#define ErrCONNECTION_OPEN                86
#define ErrCONNECTION_FAILED              87
#define ErrNO_MESSAGE                     88
#define ErrBUFFER_NULL                    89
#define ErrECB_NOT_READY                  90

#define ErrNOT_CANCELLABLE                91
#define ErrEVENT_NOT_TRIGGERED            92
#define ErrNO_PROCESS                     93

#define ErrNO_CLIENTS_WAITING             94
#define ErrNO_SERVERS_WAITING             95
#define ErrCOMPONENT                      96

#define ErrINVALID_ARGUMENT              100
#define ErrINVALID_TYPE                  101

#define ErrNOT_INITIALIZED               102
#define ErrINTERFACE_NOT_INITIALIZED     103

#define ErrMAPI_LOGIN_FAILED             104
#define ErrMAPI_LOGOFF_FAILED            105 
#define ErrMAPI_SEND_MAIL_FAILED         106
#define ErrMAPI_NO_ADDRESS_SPECIFIED     107

#define ErrSERVER_NOT_IN_LIST            108

#define ErrDDECONNECT_FAILED             109
#define ErrDDEWAIT_ACK_FAILED            110
#define ErrDDESEND_FAILED                111

#define ErrINVALID_DATE                  112
#define ErrPAST_DATE                     113
#define ErrDELETED                       114
#define ErrNO_PROCESSORS                 115

#define ErrINCREMENT_NOT_AVAIL           116 
#define ErrINCREMENT_NOT_ALLOWED         117 

#define ErrNT_SECURITY_FAILED            116
#define ErrSOCK_CREATION                 117
#define ErrSOCK_SERVER_NAME              118
#define ErrSOCK_EXISTS                   119
#define ErrSOCK_INVALID                  120
#define ErrSOCK_OPT_INVALID              121
#define ErrSOCK_WRITE                    122
#define ErrSOCK_READ                     123
#define ErrSOCK_STARTUP                  124
#define ErrSOCK_CLEANUP                  125
#define ErrINVALID_IP_ADDRESS            126
#define ErrSOCK_BIND                     127
#define ErrSOCK_CONNECT                  128
#define ErrSOCK_LISTEN                   129
#define ErrSOCK_ACCEPT                   130
#define ErrSOCK_CLOSED                   131
#define ErrSOCK_HOSTENT                  132
#define ErrSOCK_NOT_STARTED              133
#define ErrSOCK_BUFFER_TOO_SMALL         134

#define ErrPROT_NOTAVAIL                 135

#define ErrABNORMAL_CONDITION_SET        136 
#define ErrMODULE_COUNTS_SET             137 
#define ErrVOLTAGE_FREQUENCY_SET         138 
#define ErrVOLTAGE_CURRENTS_SET          139 

#define ErrRPC_INVALID_BINDING		     140
#define ErrRPC_NO_CONNECTED_CLIENT	     141

#define ErrREGISTER_FAILED               142
#define ErrUNREGISTER_FAILED             143

#define ErrINVALID_SERVER                144
#define ErrNO_DNS                        145

#define ErrFOREIGN_DOMAIN                146
#define ErrWEBAGENT_NOT_RUNNING          147

#define ErrNOT_INSTALLED                 148
#define ErrWINDOW_CLOSE_FAILED           149

#define ErrOVER_SHUTDOWN_EVT             150
#define ErrOVER_CALIBRATION_EVT          151
#define ErrOVER_TEST_EVT                 152
#define ErrNO_FRONT_END                  153

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\errlogr.h ===
/*
 * REVISIONS:
 *  ane20Jan93:  Initial Revision
 *  cad31Aug93: removing compiler warnings
 *  jod12Nov93: Name Problem Changed name to ErrTextGen
 *  cad27Dec93: include file madness
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  jps13Jul94: removed os2.h, caused problem in 1.x
 *  inf30Mar97: Added overloaded LogError definition
 */

#ifndef _INC__ERRLOGR_H
#define _INC__ERRLOGR_H

#include "cdefine.h"

#include "apc.h"
#include "update.h"

_CLASSDEF(ErrorLogger)

extern PErrorLogger _theErrorLogger;

class ErrorLogger : public UpdateObj {

public:
   ErrorLogger(PUpdateObj);
   virtual ~ErrorLogger();
   virtual INT LogError(PCHAR theError, PCHAR aFile = (PCHAR)NULL,
       INT aLineNum = 0, INT use_errno = 0);

   virtual INT LogError(INT resourceID, PCHAR aString = (PCHAR)NULL,
       PCHAR aFile = (PCHAR)NULL, INT aLineNum = 0, INT use_errno = 0);
   INT Get(INT, PCHAR);
   INT Set(INT, const PCHAR);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\event.cxx ===
/*
*
* NOTES:
*
* REVISIONS:
*  sja05Nov92: Call FlushALL method of list object to destroy event attributes
*  sja05Nov92: Added new constructor which allows #define'ed values to 
*              be used as values
*  ker19Nov92: Added GetAttributeValue function and made attribute list
*              work correctly, changed GetNextAttribute to return a pointer
*              rather than a reference.
*  pcy02Dec92: include err.h
*  jod01Feb93: Changed Do - While to While loops.
*  ane08Feb93: Added Copy constructor
*  pcy16Jan93: Have set attribute add the attribute if its not there
*  cad07Oct93: Plugging Memory Leaks
*  cad27Dec93: include file madness
*  pcy08Apr94: Trim size, use static iterators, dead code removal
*  jps15Jul94: Changed some INTs to LONG (os2 1.x)
*
*  v-stebe  29Jul2000   Changed allocation from dyn. to heap (bug #46335)
*/

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"
#include "apc.h"

#include "event.h"
#if (C_OS & C_UNIX)
#include "isa.h"
#endif

#ifdef APCDEBUG
#include <iostream.h>
#endif

extern "C" {
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
}


// Initialize static variable to count events...

INT Event::EventCount = 0;

//-------------------------------------------------------------------

Event::Event(INT aCode, PCHAR aValue)
: theEvent(aCode, aValue)
{
   // Check against MAX?
   theId = ++EventCount;
   
   //   theTime           = new TimeStamp();
   theExtendedList   = new List();
}

//-------------------------------------------------------------------

Event :: Event(INT anEventCode, LONG aValue)
: theEvent(anEventCode, aValue)
{
   theId             = ++EventCount;
   //   theTime           = new TimeStamp();
   theExtendedList   = new List();
}


//-------------------------------------------------------------------

Event :: Event (const Event &anEvent)
: theEvent (anEvent.theEvent)
{
   // Generate a new Id or copy the one from anEvent?
   //   theId = ++EventCount;
   theId = anEvent.theId;
   
   // Generate a new timestamp or use the one from anEvent?
   //   theTime           = new TimeStamp();
   theExtendedList   = new List();
   
   // Copy theExtendedList from anEvent
   if (anEvent.theExtendedList && 
      anEvent.theExtendedList->GetItemsInContainer())
   {
      PAttribute tempAttr = (PAttribute)anEvent.theExtendedList->GetHead();
      ListIterator tempIter(*(anEvent.theExtendedList));
      while(tempAttr)
      {
         PAttribute to_append = 
            new Attribute(tempAttr->GetCode(),tempAttr->GetValue());
         theExtendedList->Append(to_append);
         tempAttr = (PAttribute)tempIter.Next();   
      }
   }
   
}

//-------------------------------------------------------------------

Event::~Event()
{
   if (theExtendedList != (PList) NULL) {
      theExtendedList->FlushAll();
      delete theExtendedList;
      theExtendedList = NULL;
   }
}

const PCHAR Event::GetAttributeValue(INT aCode)
{
   if (theExtendedList && theExtendedList->GetItemsInContainer()) {
      PAttribute the_test_attribute= (PAttribute)theExtendedList->GetHead();
      ListIterator the_temp_iter(*theExtendedList);
      
      while(the_test_attribute) {
         if( (the_test_attribute->GetCode()) == (aCode)) {
            return the_test_attribute->GetValue();
         }
         the_test_attribute=(PAttribute)the_temp_iter.Next();   
      }
   }
   return (PCHAR)NULL;
}

INT Event::SetValue(LONG aValue)
{
   return theEvent.SetValue(aValue);   
}

INT Event::SetValue(const PCHAR aValue)
{
   return theEvent.SetValue(aValue);
}

const PCHAR Event::GetValue()
{
   return theEvent.GetValue();   
} 

INT Event::SetAttributeValue(INT aCode, LONG aValue)
{
   CHAR the_temp_string[32];
   sprintf(the_temp_string, "%ld", aValue);
   INT the_return_value=SetAttributeValue(aCode, the_temp_string);
   return the_return_value;   
}

INT Event::SetAttributeValue(INT aCode, const PCHAR aValue)
{
   if(!aValue)
      return ErrNO_VALUE;
   
   PAttribute the_test_attribute= (PAttribute)theExtendedList->GetHead();
   ListIterator the_temp_iter(*theExtendedList);
   
   while(the_test_attribute)
   {
      if( (the_test_attribute->GetCode()) == (aCode))
      {
         return the_test_attribute->SetValue(aValue);
      }
      the_test_attribute=(PAttribute)the_temp_iter.Next();   
   }
   
   
   //
   // If the attribute isn't there, add it
   //
   AppendAttribute(aCode, aValue);
   return ErrNO_ERROR;
}

//-------------------------------------------------------------------

void Event::AppendAttribute(INT aCode, PCHAR aValue)
{
   if(aValue)  {
      PAttribute to_append = new Attribute(aCode, aValue);
      
      theExtendedList->Append(to_append);
   }
}

void Event::AppendAttribute(INT aCode, FLOAT aValue)
{
   CHAR str_value[32];
   
   sprintf(str_value, "%.2f", aValue);
   AppendAttribute(aCode, str_value);
}

//-------------------------------------------------------------------

void Event::AppendAttribute(RAttribute anAttribute)
{
   theExtendedList->Append((PObj)(&anAttribute));
}

//-------------------------------------------------------------------

INT Event::Equal( RObj anObject ) const
{
   if (anObject.IsA() != IsA())
      return FALSE;
   
   return theEvent.Equal( *((REvent) anObject).GetEvent());
}

#ifdef APCDEBUG
ostream& Event::printMeOut(ostream& os)
{
   os << "Event: " << theEvent << endl;
   
   if (theExtendedList && theExtendedList->GetItemsInContainer()) {
      PAttribute the_test_attribute= (PAttribute)theExtendedList->GetHead();
      ListIterator the_temp_iter(*theExtendedList);
      
      while(the_test_attribute) {
         os << "\t" << *the_test_attribute << endl;
         the_test_attribute=(PAttribute)the_temp_iter.Next();   
      }
   }
   
   return os;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\eventime.cxx ===
/*
*  jod07Dec92: Fixed the Consrtuctor and added the Destructor.
*  ane11Jan93: Added copy constructor
*
*/

#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

#include "event.h"
#include "update.h"
#include "eventime.h"

//#include "apc.h"
//#include "update.h"

/*
C+
Name  :EventTimer
SYnop :Constructor. Simply stores the Event and the UpdateObject to
notify.
*/
EventTimer::EventTimer(PEvent anEvent,PUpdateObj anUpdateObj,
                       ULONG MilliSecondDelay)
                       :Timer(MilliSecondDelay)
                       //c-
{
   theEvent            =anEvent;
   theUpdateableObject =anUpdateObj;
}

EventTimer :: EventTimer (REventTimer aTimer) : Timer (aTimer)
{
   theEvent = aTimer.theEvent;
   theUpdateableObject = aTimer.theUpdateableObject;
}

EventTimer ::  ~EventTimer()
{
   if (theEvent) {
       delete theEvent;
       theEvent = NULL;
   }
};

VOID EventTimer::Execute()
//c-
{
   if (theUpdateableObject&&theEvent) theUpdateableObject->Update(theEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\eventime.h ===
/*
* REVISIONS:
*  pcy02Dec92: Removed include of typedefs.h 
*  jod07Dec92: Moved the Destructor out of line.
*  ane11Jan93: Added copy constructor
*  cad09Jul93: added getid
*  mwh05May94: #include file madness , part 2
*/

#ifndef _EVENTTIME_H
#define _EVENTTIME_H

//#include "apc.h"
//#include "_defs.h"
#include "event.h"
#include "timer.h"

_CLASSDEF(Timer)
_CLASSDEF(UpdateObj)
_CLASSDEF(EventTimer)

class EventTimer : public Timer
{
protected:
   PEvent      theEvent;
   PUpdateObj  theUpdateableObject;
   
public:
   EventTimer(PEvent anEvent,PUpdateObj anUpdateObj,ULONG MilliSecondDelay);
   EventTimer(REventTimer aTimer);
   virtual ~EventTimer();
   virtual INT IsA() const {return EVENTTIMER;};
   virtual INT GetEventID() {return theEvent ? theEvent->GetId() : 0;};
   virtual VOID Execute();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\evntlog.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker05Nov92:  Initial Revision
 *  pcy14Dec92:  if C_OS2 around os2.h, add cdefine.h, and change object.h to
 *               apcobj.h
 *  ane18Jan93:  Added ClearFile
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  cgm11Dec95: use LONG type; switch to Watcom 10.5 compiler for NLM
 */

#ifndef __EVNTLOG_H
#define __EVNTLOG_H


#include "cdefine.h"

#include "codes.h"
#include "apcobj.h"

_CLASSDEF(EventLog)


class EventLog : public Obj {

private:
   
public:
   EventLog() {};
   virtual LONG GetMaximumSize(void)=0;
   virtual const PCHAR GetFileName(void)=0;
   virtual void SetMaximumSize(long)=0;
   virtual INT AppendRecord(const PCHAR)=0;
   virtual INT ClearFile()=0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\event.h ===
/*
* REVISIONS:
*  sja05Nov92: Calls FlushALL method of the list object to destroy the 
*              event attributes
*  sja05Nov92: Added new constructor which allows #define'ed values to be 
*              used as values
*  pcy23Nov92: ifdef around os2.h
*  pcy26Nov92: Fixed ifdef syntax
*  ane08Feb93: Added Copy constructor
*  jps13Jul94: removed os2.h; changed value from INT to LONG
*
*/
#ifndef __EVENT_H
#define __EVENT_H


#if !defined ( __LIST_H )
#include "list.h"
#endif

#if !defined ( __ATTRIB_H )
#include "attrib.h"
#endif


_CLASSDEF(Event)

#define MAX_EVENT_COUNT       1000


class Event : public Obj {
   
private:
   
   static INT  EventCount;
   
   INT            theId;
   Attribute      theEvent;
   PList          theExtendedList;
   
protected:
#ifdef APCDEBUG
   virtual ostream& printMeOut(ostream& os);
#endif
   
public:
   
   Event(INT anEventCode, LONG aValue);
   Event(INT, PCHAR);
   Event(const Event &anEvent);
   virtual ~Event();
   INT               GetId() const { return theId; };
   PAttribute        GetEvent() { return &theEvent; };
   INT               GetCode() const { return theEvent.GetCode();};
   const PCHAR       GetValue();
   VOID SetCode(INT aCode) { theEvent.SetCode(aCode);};
   INT SetValue(LONG);
   INT SetAttributeValue(INT,LONG);
   INT SetValue(const PCHAR);
   INT SetAttributeValue(INT, const PCHAR);
   PList GetAttributeList() { return theExtendedList; }
   const PCHAR GetAttributeValue(INT);
   void  AppendAttribute(INT, PCHAR);
   void  AppendAttribute(INT, FLOAT);
   void  AppendAttribute(RAttribute);
   
   virtual INT     IsA() const { return APC_EVENT; };
   virtual INT       Equal( RObj ) const;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\firmrevs.h ===
/*
 *  djs05Jun96: Broke into two objects: firmmanager/firmrevsensor
 *  tjg02Dec97: Changed darkstar to symmetra
 */

#ifndef __FIRMSENS_H
#define __FIRMSENS_H

#include "_defs.h"
#include "firmman.h"

#if !defined( __SENSOR_H )
#include "sensor.h"
#endif

//
// Defines
//

_CLASSDEF(FirmwareRevSensor)

//
// Uses
//

_CLASSDEF(Device)
_CLASSDEF(CommController)
_CLASSDEF(DecimalFirmwareRevSensor)
_CLASSDEF(FirmwareRevManager)
_CLASSDEF(Sensor)





class FirmwareRevSensor : public Sensor {

protected:

  PDecimalFirmwareRevSensor       theDecimalFirmwareRevSensor;
  PFirmwareRevManager             theFirmwareRevManager;

  virtual INT   IsXL();
  virtual INT   IsSymmetra();

public:

   FirmwareRevSensor(PDevice aParent, PCommController aCommController = NULL);

   virtual INT IsA() const { return FIRMWAREREVSENSOR; };
   virtual INT Get( INT code, PCHAR value );
   INT IsBackUpsPro();

 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\firmman.h ===
/*
 *
 *  djs05Jun96: Broke off from firmware rev sensor
 *  srt09Jun97: Added a proper parent object argument
 *  tjg03Dec97: Changed darkstar to symmetra
 *  tjg30Jan98: Added destructor
 */

#ifndef __FIRMMAN_H
#define __FIRMMAN_H



//
// Defines
//
 #include "_defs.h"
 #include "update.h"
 #include "apcobj.h"

_CLASSDEF(FirmwareRevManager)


class FirmwareRevManager : public Obj{

protected:

    PUpdateObj theParent;
    PCHAR   theValue;

    virtual INT   Is250();
    virtual INT   Is370();
    virtual INT   Is400();
    virtual INT   Is400_or_370();
    virtual INT   Is600();
    virtual INT   Is900();
    virtual INT   Is1250();
    virtual INT   Is2000();
    virtual INT   Is3000();
    virtual INT   Is5000();
    virtual INT   Is120VoltUps();
    virtual INT   Is100VoltUps();
    virtual INT   Is208VoltUps();
    virtual INT   Is220VoltUps();
    virtual INT   Is200VoltUps();
    virtual INT   IsMatrix();
    virtual INT   IsXL();
    virtual INT   IsSymmetra();
    virtual INT   IsBackUps();
    virtual INT   IsFirstGen();
    virtual INT   IsSecondGen();
    virtual INT   IsThirdGen();

    virtual VOID GetNumberOfInternalBatteryPacks(PCHAR aValue);
    virtual VOID GetUPSNameFromFirmware(PCHAR aValue);
    virtual VOID GetUPSModelChar(PCHAR aValue);
    virtual VOID GetCountryCode(PCHAR aValue);

    virtual CHAR  GetFirmwareRevChar(VOID);


public:

   FirmwareRevManager(PUpdateObj aParent, PCHAR aFirmwareRevChars);
   
   virtual ~FirmwareRevManager();
   virtual VOID ReInitialize(PCHAR aFirmwareRevChars);
   virtual INT IsA() const;
   virtual INT Get( INT aCode, PCHAR aValue );

   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\firmrevs.cxx ===
/*
*  djs05Feb96: Added firmware rev codes
*  djs05Jun96: Broke into two objects: firmmanager/firmrevsensor
*  djs26Jul96: Added Max/Min line voltage ranges for DarkStar
*  djs28May97: Expanded range for Symmetra support
*  srt09JUn97: Passing a parent to the firmware rev mgr.
*  tjg11Jul97: Added CURRENT_FIRMWARE_REV code
*  tjg02Dec97: Changed darkstar to symmetra
*  tjg22Jan98: Updated IsSymmetra to use TokenString instead of strtok
*/

#include "cdefine.h"

#if (C_OS & C_OS2)
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#endif

extern "C" {
#if (C_PLATFORM & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "apc.h"
#include "_defs.h"
#include "comctrl.h"
#include "err.h"        
#include "codes.h"
#include "cfgmgr.h"
#include "firmrevs.h"
#include "utils.h"
#include "smartups.h"
#include "dcfrmrev.h"
#include "tokenstr.h"

_CLASSDEF(CommController)
_CLASSDEF(UpdateObj)
_CLASSDEF(Device)


//-------------------------------------------------------------------

FirmwareRevSensor :: FirmwareRevSensor(PDevice aParent, PCommController aCommController)
: Sensor(aParent, aCommController, FIRMWARE_REV)
{
   theDevice = aParent;
   theDecimalFirmwareRevSensor = new DecimalFirmwareRevSensor(aParent, aCommController);

   DeepGet();
   theFirmwareRevManager = new FirmwareRevManager(aParent, theValue);
}


INT FirmwareRevSensor :: IsXL()
{ 
   INT UPS_Is_An_XL = FALSE;
   CHAR UPS_Name[40];
   
   theDevice->Get(UPS_MODEL,UPS_Name);
   
   // If the UPS name contains the string "XL" then the UPS
   // is an XL.  It doesn't take Lassie to figure this one out.
   
   PCHAR xl_string = strstr(UPS_Name,"xl");
   if (xl_string != NULL)
   {
      UPS_Is_An_XL = TRUE;
   }
   else
   {
      
      // Don't offend any UPS just because it's of the wrong case...
      
      xl_string = strstr(UPS_Name,"XL");
      if (xl_string != NULL)
      {
         UPS_Is_An_XL = TRUE;
      }
   } 
   return UPS_Is_An_XL;
}

INT FirmwareRevSensor :: IsSymmetra()
{
   INT is_symmetra = FALSE;
   CHAR value[20];
   
   INT err = Get(DECIMAL_FIRMWARE_REV, value);

   if (err == ErrNO_ERROR && value) {
      TokenString token_str(value, ".");
      
      // The UPSs SKU is the first element in the decimal firmware rev
      PCHAR sku_string = token_str.GetCurrentToken();

      if (sku_string != NULL) {
         INT sku_number = atoi(sku_string);
         if (sku_number >= 200 && sku_number <= 279) {
            is_symmetra = TRUE;
         }
      }
   }

   return is_symmetra;
}


INT FirmwareRevSensor::IsBackUpsPro()
{
    INT is_bk_pro = FALSE;
    
    if (theValue) {
      // Back UPS Pro's (half wits) do not response correctly to 'V'
      if (_stricmp(theValue, "NA") == 0) {
        is_bk_pro = TRUE;
      }

      if (strlen(theValue) == 0) {
        is_bk_pro = TRUE;
      }
    }
    else {
      is_bk_pro = TRUE;
    }

    return is_bk_pro;
}


INT FirmwareRevSensor::Get(INT aCode, PCHAR aValue)
{
   INT err = ErrNO_ERROR;
   
   switch(aCode)
   {
   case IS_EXT_SLEEP_UPS:
      err = theFirmwareRevManager->Get(aCode,aValue);
      break;
      
   case EXTERNAL_PACKS_CHANGEABLE:
      { 
         if(!IsXL()) {
            strcpy(aValue,"No");
         }
         else {
            strcpy(aValue,"Yes");
         }
      }
      break;
      
   case IS_SYMMETRA:
      if (!IsSymmetra()) {
         strcpy(aValue,"No");
      }
      else {
         strcpy(aValue,"Yes");
      }
      break;
      
   case EXTERNAL_BATTERY_PACKS:
      if (!IsSymmetra()) {
         strcpy(aValue,"No");
      }
      else {
         strcpy(aValue,"Yes");
      }
      break;
      
   case DECIMAL_FIRMWARE_REV:
      {
         err = theDecimalFirmwareRevSensor->Get(DECIMAL_FIRMWARE_REV, aValue);
      }
      break;
      
   case FIRMWARE_REV:
      {
         err = Sensor::Get(FIRMWARE_REV, aValue);
      }
      break;
      
   case CURRENT_FIRMWARE_REV:
      {
         err = theDecimalFirmwareRevSensor->Get(DECIMAL_FIRMWARE_REV, aValue);
         INT args = 0;
         if (aValue) {
            INT i, j;
            CHAR c;
            args = sscanf(aValue, "%d.%d.%c", &i, &j, &c);
         }
         if (args != 3) {
            err = Sensor::Get(FIRMWARE_REV, aValue);
         }
      }
      break;
      
      
   case MIN_VOLTAGE_RANGE_VALUE:
      {
         if (IsSymmetra()){
            strcpy(aValue,"180");
         }
         else {
            err = theFirmwareRevManager->Get(aCode,aValue);
         }
      }
      break;
      
   case MAX_VOLTAGE_RANGE_VALUE:
      {
         if (IsSymmetra()){
            strcpy(aValue,"280");
         }
         else {
            err = theFirmwareRevManager->Get(aCode,aValue);
         }
      }
      break;
      
   case IS_FREQUENCY:
   case IS_BATTERY_CAPACITY:
   case IS_BATTERY_VOLTAGE:
   case IS_RUNTIME_REMAINING:
   case IS_SENSITIVITY:
   case IS_LOW_BATTERY_DURATION:
   case IS_ALARM_DELAY:
   case IS_TURN_ON_DELAY:
   case IS_SHUTDOWN_DELAY:
   case IS_MANUFACTURE_DATE:
   case IS_UTILITY_VOLTAGE:
   case IS_OUTPUT_VOLTAGE:
   case IS_UPS_LOAD:
   case IS_BATTERY_DATE:
   case IS_SELF_TEST_SCHEDULE:
   case IS_BATTERY_CALIBRATION:
   case IS_RATED_OUTPUT_VOLTAGE:
   case IS_HIGH_TRANSFER_VOLTAGE:
   case IS_LOW_TRANSFER_VOLTAGE:
   case IS_SMARTBOOST:
   case IS_SMARTTRIM:
   case IS_MIN_RETURN_CAPACITY:
   case IS_CTRL_Z:
   case IS_LOAD_SENSING:
       {
           if (IsBackUpsPro()) {
               strcpy(aValue,"No");
           }
           else {
               err = theFirmwareRevManager->Get(aCode,aValue);
           }
       }
       break;

   default:
      {
         err = theFirmwareRevManager->Get(aCode,aValue);
      }
   }
   
   return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\icodes.h ===
/*
 */
#define ILOWBATTERY                               1000
#define IBATTERYDISCHARGED                        1001
#define IRETURNFROMBATTERYDISCHARGED 1002
#define IABNORMALCONDITION 1003
#define IRETURNFROMABNORMALCONDITION 1004
#define IOVERLOAD 1005
#define IRETURNFROMOVERLOAD 1006
#define IREPLACEBATTERY 1007
#define IDONTREPLACEBATTERY 1008
#define ICOMMUNICATIONESTABLISHED  1009
#define ICOMMUNICATIONLOST  1010
#define ISELFTESTPASSED  1011
#define ISELFTESTFAILED 1012
#define IRUNTIMECALIBRATIONSTARTED 1013
#define IRUNTIMECALIBRATIONFINISHED 1014
#define IRUNTIMECALIBRATIONCANCELLED 1015
#define ILINEFAIL 1016
#define ILINEGOOD 1017
#define ISHUTDOWN 1018
#define IPREPAREFORSHUTDOWN 1019
#define IPOWERCHUTESTARTED 1020
#define IPOWERCHUTESTOPPED 1021
#define IRUNTIMEEXPIRED 1022
#define ISMARTBOOST 1023
#define ILOWRUNTIME 1024
#define ILOWAMBIENTTEMPERATURE 1025
#define IHIGHAMBIENTTEMPERATURE 1026
#define INORMALAMBIENTTEMPERATURE 1027
#define ILOWHUMIDITY 1028
#define IHIGHHUMIDITY 1029
#define INORMALHUMIDITY 1030
#define ICONTACTFAULT 1031
#define ICONTACTNORMAL 1032
#define ICHECKSMARTCELLSIGNAL 1033
#define IONBYPASSFAILURE 1034
#define IONBYPASSMAINTENANCE 1035
#define INOTONBYPASS 1036
#define IMATRIXFANFAILURE 1037
#define IBYPASSPOWERSUPPLYFAILURE 1038  
#define ISMARTTRIM 1039


#define IUPS  100
#define ISIGNALLINGTYPE 101
#define IPORTNAME  102
#define IPORTTYPE  103
#define IPROTOCOL  104
#define IMAXBATTERYRUNTIME 105
#define ISLAVEENABLED 106
#define IMASTERNAME 107
#define IEVENTLOGGING 108
#define IEVENTLOGENABLED 109
#define IEVENTLOGNAME 110
#define IEVENTLOGMAXSIZE 111
#define IEVENTLOGROLLPERCENTAGE 112
#define IDATALOGGING 113
#define IDATALOGENABLED 114
#define IDATALOGNAME 115
#define IDATALOGMAXSIZE 116
#define IDATALOGINTERVAL 117
#define IDATALOGROLLPERCENTAGE 118
#define IMESSAGING 119
#define IPOWERFAILMSG 122
#define IUNLIMITEDPOWERFAILMSG 123
#define IPOWERRETURNMESSAGE 124
#define ILOWBATTERYMESSAGE 125
#define IRUNTIMEEXPIREDMESSAGE 126
#define IFINALSHUTDOWNMESSAGE 127
#define ICANCELSHUTDOWNMESSAGE 128
#define IPREPARESHUTDOWNMESSAGE 129
#define IENABLEPOPUPS 130
#define IENABLEBROADCASTMESSAGING 131
#define ISELFTESTS 132
#define IENABLESELFTESTS 133
#define ISELFTESTSCHEDULE 134
#define ISELFTESTDAY 135
#define ISELFTESTTIME 136
#define ILASTSELFTESTRESULT 137
#define ILASTSELFTESTDAY 138
#define ILOWBATTERYSHUTDOWNDELAY 139
#define IADMINSHUTDOWNDELAY 140
#define IDAILYSHUTDOWNENABLED 141
#define IDAILYSHUTDOWNTIME 142
#define IDAILYWAKEUPTIME 143
#define IWEEKLYSHUTDOWNENABLED 144
#define IWEEKLYSHUTDOWNDAY 145
#define IWEEKLYSHUTDOWNTIME 146
#define IWEEKLYWAKEUPDAY 147
#define IWEEKLYWAKEUPTIME 148
#define ILANMANAGER  149
#define ILOCALBINDERYADDRESS 150
#define ISERVER  151
#define IHOSTNAME 152
#define IPAUSEENABLED 153
#define ICLIENTADDRESS 154
#define IALERTADDRESS 155
#define ISERVERSBINDERYADDRESS 156
#define IBINDERYRESPONSEADDRESS 157
#define IHUMIDITYSENSOR 158
#define IENABLELOWTHRESHOLD 159
#define IENABLEHIGHTHRESHOLD 160
#define ILOWTHRESHOLDVALUE 161
#define IHIGHTHRESHOLDVALUE 162
#define IAMBIENTTEMPERATURESENSOR 163
#define ICONTACTSENSOR1 168
#define ICONTACTSENSOR2 169
#define ICONTACTSENSOR3 170
#define ICONTACTSENSOR4 171
#define IENABLED 172
#define IDEFAULTSTATE 173
#define IDESCRIPTION 174
#define IUSERINTERFACE 175
#define ITEMPERATUREUNITS 176
#define ISOUNDEFFECTS 177
#define IFREQUENCYSENSOR 178
#define IBATTERYVOLTAGESENSOR  183
#define ILINEVOLTAGESENSOR 184
#define IMAXLINEVOLTAGESENSOR 185
#define IMINLINEVOLTAGESENSOR 186
#define IOUTPUTVOLTAGESENSOR 187
#define IUPSLOADSENSOR 188
#define IUPSTEMPERATURESENSOR 189
#define IBATTERYRUNTIMESENSOR 190
#define IALARMDELAYSENSOR 191
#define IHIGHTRANSFERVOLTAGESENSOR 192
#define ILOWTRANSFERVOLTAGESENSOR 193
#define ILOWBATTERYDURATIONSENSOR 194
#define IMINRETURNCAPACITYSENSOR 195
#define IRATEDOUTPUTVOLTAGESENSOR 196
#define ISELFTESTSCHEDULESENSOR 197
#define ISHUTDOWNDELAYSENSOR 198
#define ITURNOFFDELAYSENSOR 199
#define ITURNONDELAYSENSOR 200
#define IUPSSENSITIVITYSENSOR 201
#define IALLOWEDVALUES 202
#define IBATTERYCALIBRATION 203
#define ILASTCALIBRATIONDATE 204
#define ILASTCALIBRATIONRESULT 205
#define IBATTERYCALIBRATIONDAY 206
#define IBATTERYCALIBRATIONTIME 207
#define ITRANSPORTS 209
#define IDEVICES 210
#define IBATTERYRUNTIMEENABLED 211
#define IAUTOUPSREBOOTENABLED 212
#define IBATTERYAGELIMIT 213
#define IBATTERYREPLACEMENTDATE 214
#define IERRORLOGGING 215
#define IERRORLOGENABLED 216
#define IERRORLOGNAME 217
#define IERRORLOGMAXSIZE 218
#define IERRORLOGROLLPERCENTAGE 219
#define IBARGRAPHTYPE 221
#define IINDICATORCOLOR 222
#define IBORDERCOLOR 223
#define ITICKCOLOR 224
#define IINRANGECOLOR 225
#define IOUTOFRANGECOLOR 226
#define IDATACOLOR 227
#define ILABELCOLOR 228
#define IDISABLEDCOLOR 229
#define IWINDOWCOLOR 230
#define ILIGHTSHADOWCOLOR 231
#define IDARKSHADOWCOLOR 232
#define ISTATUSPANECOLOR 233
#define IEVENTPANECOLOR 234
#define IERRORCOLOR 235
#define IWARNINGCOLOR 236
#define IUPSPOLLINTERVAL 237

#define IMESSAGEDELAY      1
#define IMESSAGEINTERVAL   2
#define IPOPUPMESSAGE      3
#define IPOPUPTEXT         4
#define IEVENTTEXT         5
#define ISHUTDOWNDELAY     7
#define IACTIONS           9
#define ICOMMANDFILE       10
#define ICOMMANDFILEDELAY  11
#define IINTERNATIONAL     12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\itemcode.h ===
/*
* REVISIONS:
*  ane11Dec92: Minor type casting changes
*  pcy14Dec92: Removes const from GetAssoc so it will compile
*  ane16Dec92: Added destructor
*  rct19Jan93: modified constructors & destructors
*
*/

//
// This is the header file for item codes held by the config mgr
//
// R. Thurston
//
//

#ifndef __ITEMCODE_H
#define __ITEMCODE_H

extern "C"  {
#include <string.h>
}
#include "tattrib.h"


_CLASSDEF( ItemCode )


class ItemCode : public Obj {
   
private:
   
   INT         theCode;
   PCHAR         theComponent;
   PCHAR         theItem;
   PCHAR       theDefaultValue;
   
public:
   
   ItemCode( INT aCode, PCHAR aComponent, PCHAR anItem, 
      PCHAR aDefault = NULL );
   ItemCode( INT aCode ) : theCode(aCode), theComponent((PCHAR) NULL), theItem((PCHAR) NULL), theDefaultValue((PCHAR) NULL) {};
   
   virtual ~ItemCode();
   
   const PCHAR GetComponent() const { return theComponent; };
   const PCHAR GetItem() const { return theItem; };
   const INT GetCode() const { return theCode; };
   const PCHAR GetDefaultValue() const { return theDefaultValue; };
   
   virtual INT          Equal( RObj ) const;
   virtual INT        IsA() const { return ITEMCODE; };
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\itemcode.cxx ===
/*
* REVISIONS:
*  pcy04Dec92: Added string.h
*  ane16Dec92: Added destructor
*  rct19Jan93: modified constructors & destructors
*  mwh01Jun94: port for INTERACTIVE
*  mwh07Jun94: port for NCR
*  jps13Jul94: os2 needs stdlib
*  daf17May95: port for ALPHA/OSF
*  djs02Sep95: port for AIX 4.1
*/

//
// This is the implementation for item codes (held by the config mgr)
//
// R. Thurston
//
//

#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#include <string.h>
#if  (C_OS & (C_INTERACTIVE | C_OS2 | C_ALPHAOSF)) || ((C_OS & C_AIX) && (C_AIX_VERSION & C_AIX4))
#  include <stdlib.h>
#else
#  include <malloc.h>
#endif
}

#include "itemcode.h"

#if (C_OS & C_NCR)
#  include "incfix.h"
#endif


//-------------------------------------------------------------------

ItemCode::ItemCode( INT aCode, PCHAR aComponent, PCHAR anItem, PCHAR aDefault )
: theComponent(aComponent), theItem(anItem), theCode(aCode)
{
   if(aComponent)
      theComponent = _strdup(aComponent);
   if(anItem)
      theItem = _strdup(anItem);
   if(aDefault)
      theDefaultValue = _strdup(aDefault);
}


//-------------------------------------------------------------------

ItemCode::~ItemCode()
{
   if(theComponent)
      free(theComponent);
   if(theItem)
      free(theItem);
   if (theDefaultValue != NULL)
      free(theDefaultValue);
}

//-------------------------------------------------------------------

//
// Equals method
//

INT ItemCode::Equal( RObj anObject ) const
{
   if (anObject.IsA() != IsA())  
      return FALSE;
   
   INT code = ((RItemCode) anObject).GetCode();
   PCHAR comp = ((RItemCode) anObject).GetComponent();
   PCHAR item = ((RItemCode) anObject).GetItem();
   
   
   if ((theCode == code) && 
      (strcmp(theComponent, comp) == 0) &&
      (strcmp(theItem, item) == 0)) {
      return TRUE;
   }
   else  {
      return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\isa.h ===
/*
 *
 * REVISIONS:
 *  pcy21Jan93: Added TextGenerator, TurnOffDelaySensor, SelfTestSensor
 *  pcy22Jan93: Fixed multiple definitions of VOLTAGEMANAGER
 *  pcy22Jan93: Removed use mUps for measure ups vars.  Breaks cfgmgr.
 *  pcy22Jan93: Added EepromSensor
 *  rct07Feb93: added NlmTimerManager
 *  pcy30Apr93: Added XVT front end isa stuff
 *  jwa04May93: Add more front end isa stuff and PollLoop isa definition
 *  jod14May93: Added Matrix changes.
 *  rct17May93: added nlm stuff, fixed indexing, added some other stuff
 *  rct23Jun93: switched isa's back to long text
 *  rct23Jun93: added lost items...
 *  cad24jun93: added new xvt field type
 *  cad04Aug93: added new dialog
 *  cad26Aug93: added mups firware sensor and dialog
 *  cad31Aug93: Added smart edit controls
 *  djs22Feb96: Added smart trim sensor
 *  djs17May96: Added DarkStar codes
 *  mds18Jun97: Added codes used for ApcBinderyEntrySortable and ApcIntSortable
 *  mds13Aug97: Added codes used for ApcStripIntSortable
 *  tjg02Dec97: Changed darkstar to symmetra, minloadcapability to 
 *              maxloadcapability and added MODULESCOUNTSBADBATTERIESSENSOR
 */

#ifndef __ISA_H
#define __ISA_H

#ifdef DECLARE_ISA_TEXT
#define ISA_EXTERN extern
#define ISA_INIT(x) =x
#else
#define ISA_EXTERN extern
#define ISA_INIT(x)
#endif

#if (!(C_OS & C_UNIX) && !(C_OS & C_OS2))

ISA_EXTERN const INT OBJ                            ISA_INIT(1);  
ISA_EXTERN const INT ABNORMALCONDITIONSENSOR        ISA_INIT(1);  
ISA_EXTERN const INT ALARMDELAYSENSOR               ISA_INIT(2);  
ISA_EXTERN const INT ATTRIBUTE                      ISA_INIT(3);  
ISA_EXTERN const INT BACKUPS                        ISA_INIT(4);  
ISA_EXTERN const INT BATTERYCALIBRATIONTESTSENSOR   ISA_INIT(5);  
ISA_EXTERN const INT BATTERYCAPACITYSENSOR          ISA_INIT(6);  
ISA_EXTERN const INT BATTERYCONDITIONSENSOR         ISA_INIT(7);  
ISA_EXTERN const INT BATTERYREPLACEMENTDATESENSOR   ISA_INIT(9);  
ISA_EXTERN const INT BATTERYVOLTAGESENSOR           ISA_INIT(11); 
ISA_EXTERN const INT NMPIPEBINDERYENTRY             ISA_INIT(12); 
ISA_EXTERN const INT COMMDEVICE                     ISA_INIT(13); 
ISA_EXTERN const INT SERVERCOMMCONTROLLER           ISA_INIT(16); 
ISA_EXTERN const INT COMMUNICATIONSTATESENSOR       ISA_INIT(18); 
ISA_EXTERN const INT COPYRIGHTSENSOR                ISA_INIT(19); 
ISA_EXTERN const INT DIPSWITCHPOSITIONSENSOR        ISA_INIT(23); 
ISA_EXTERN const INT EVENTNODE                      ISA_INIT(24); 
ISA_EXTERN const INT DEVICECONTROLLER               ISA_INIT(26); 
ISA_EXTERN const INT ERRORMESSAGE                   ISA_INIT(32); 
ISA_EXTERN const INT APC_EVENT                      ISA_INIT(34); 
ISA_EXTERN const INT EVENTTIMER                     ISA_INIT(35); 
ISA_EXTERN const INT EVENTMESSAGE                   ISA_INIT(38); 
ISA_EXTERN const INT FILE_ISA                       ISA_INIT(40); 
ISA_EXTERN const INT FIRMWAREREVSENSOR              ISA_INIT(41); 
ISA_EXTERN const INT OUTPUTFREQUENCYSENSOR          ISA_INIT(42); 
ISA_EXTERN const INT HIGHTRANSFERVOLTAGESENSOR      ISA_INIT(43); 
ISA_EXTERN const INT ITEMCODE                       ISA_INIT(45); 
ISA_EXTERN const INT LINEVOLTAGESENSOR              ISA_INIT(49); 
ISA_EXTERN const INT LIST                           ISA_INIT(50); 
ISA_EXTERN const INT LIGHTSTESTSENSOR               ISA_INIT(51); 
ISA_EXTERN const INT LOWBATTERYDURATIONSENSOR       ISA_INIT(52); 
ISA_EXTERN const INT LOWTRANSFERVOLTAGESENSOR       ISA_INIT(53); 
ISA_EXTERN const INT MANUFACTUREDATESENSOR          ISA_INIT(54); 
ISA_EXTERN const INT MAXLINEVOLTAGESENSOR           ISA_INIT(55); 
ISA_EXTERN const INT MESSAGE                        ISA_INIT(57); 
ISA_EXTERN const INT MINLINEVOLTAGESENSOR           ISA_INIT(58); 
ISA_EXTERN const INT MINRETURNCAPACITYSENSOR        ISA_INIT(59); 
ISA_EXTERN const INT NMPIPESTREAM                   ISA_INIT(61); 
ISA_EXTERN const INT NODE                           ISA_INIT(62); 
ISA_EXTERN const INT OUTPUTVOLTAGESENSOR            ISA_INIT(64); 
ISA_EXTERN const INT OVERLOADSENSOR                 ISA_INIT(65); 
ISA_EXTERN const INT POLLMAXLINEVOLTAGESENSOR       ISA_INIT(66); 
ISA_EXTERN const INT POLLMINLINEVOLTAGESENSOR       ISA_INIT(67); 
ISA_EXTERN const INT POLLPARAM                      ISA_INIT(68); 
ISA_EXTERN const INT PORT                           ISA_INIT(72); 
ISA_EXTERN const INT RATEDBATTERYVOLTAGESENSOR      ISA_INIT(77); 
ISA_EXTERN const INT REPLACEBATTERYSENSOR           ISA_INIT(78); 
ISA_EXTERN const INT RESETEEPROMDEFAULTSSENSOR      ISA_INIT(79); 
ISA_EXTERN const INT RATEDLINEVOLTAGESENSOR         ISA_INIT(80); 
ISA_EXTERN const INT RATEDOUTPUTVOLTAGESENSOR       ISA_INIT(81); 
ISA_EXTERN const INT RUNTIMEREMAININGSENSOR         ISA_INIT(82); 
ISA_EXTERN const INT SCHEDULELISTENTRY              ISA_INIT(83); 
ISA_EXTERN const INT SCRIPT                         ISA_INIT(85); 
ISA_EXTERN const INT SELFTESTRESULTSENSOR           ISA_INIT(87); 
ISA_EXTERN const INT SELFTESTSCHEDULESENSOR         ISA_INIT(88); 
ISA_EXTERN const INT SHUTDOWNDELAYSENSOR            ISA_INIT(91); 
ISA_EXTERN const INT SMARTUPS                       ISA_INIT(93); 
ISA_EXTERN const INT SMARTBOOSTSENSOR               ISA_INIT(94); 
ISA_EXTERN const INT SMARTTRIMSENSOR                ISA_INIT(95); 
ISA_EXTERN const INT TIMESTAMP                      ISA_INIT(96); 
ISA_EXTERN const INT TATTRIBUTE                     ISA_INIT(97); 
ISA_EXTERN const INT TIMER                          ISA_INIT(100);
ISA_EXTERN const INT TURNOFFUPSIMMEDIATELYSENSOR    ISA_INIT(102);
ISA_EXTERN const INT TURNOFFWITHDELAYSENSOR         ISA_INIT(103);
ISA_EXTERN const INT TRANSACTIONITEM                ISA_INIT(105);
ISA_EXTERN const INT TRANSACTIONGROUP               ISA_INIT(106);
ISA_EXTERN const INT TRANSFERCAUSESENSOR            ISA_INIT(107);
ISA_EXTERN const INT TRIPREGISTERSENSOR             ISA_INIT(108);
ISA_EXTERN const INT TURNONDELAYSENSOR              ISA_INIT(110);
ISA_EXTERN const INT TURNOFFUPSONBATTERYSENSOR      ISA_INIT(111);
ISA_EXTERN const INT UTILITYLINECONDITIONSENSOR     ISA_INIT(112);
ISA_EXTERN const INT UNSUPPORTEDSENSOR              ISA_INIT(113);
ISA_EXTERN const INT PUTUPSTOSLEEPSENSOR            ISA_INIT(116);
ISA_EXTERN const INT UPSBATTERYTYPESENSOR           ISA_INIT(117);
ISA_EXTERN const INT UPSIDSENSOR                    ISA_INIT(118);
ISA_EXTERN const INT UPSLOADSENSOR                  ISA_INIT(119);
ISA_EXTERN const INT UPSSENSITIVITYSENSOR           ISA_INIT(120);
ISA_EXTERN const INT UPSSERIALNUMBERSENSOR          ISA_INIT(121);
ISA_EXTERN const INT UPSSIMULATEPOWERFAILSENSOR     ISA_INIT(122);
ISA_EXTERN const INT UPSTEMPERATURESENSOR           ISA_INIT(123);
ISA_EXTERN const INT TURNOFFDELAYSENSOR             ISA_INIT(126);
ISA_EXTERN const INT SELFTESTSENSOR                 ISA_INIT(127);
ISA_EXTERN const INT DDESTREAM                      ISA_INIT(128);
ISA_EXTERN const INT DDEBINDERYENTRY                ISA_INIT(129);
ISA_EXTERN const INT NUMBERBATTERYPACKSSENSOR       ISA_INIT(130); 
ISA_EXTERN const INT FIRMWAREREVMANAGER             ISA_INIT(131);



// measure ups stuff

ISA_EXTERN const INT AMBIENTTEMPERATURESENSOR       ISA_INIT(136);
ISA_EXTERN const INT HUMIDITYSENSOR                 ISA_INIT(137);
ISA_EXTERN const INT CONTACTSENSOR                  ISA_INIT(138);

ISA_EXTERN const INT APCSTRING                      ISA_INIT(139);

ISA_EXTERN const INT NUMBERBADBATTERIESSENSOR       ISA_INIT(148);
ISA_EXTERN const INT STATEREGISTERSENSOR            ISA_INIT(149);
ISA_EXTERN const INT FANFAILURESENSOR               ISA_INIT(150);
ISA_EXTERN const INT BATTERYCHARGERSENSOR           ISA_INIT(151);
ISA_EXTERN const INT OVERTEMPFAULTSENSOR            ISA_INIT(152);
ISA_EXTERN const INT BYPASSMODESENSOR               ISA_INIT(154);
ISA_EXTERN const INT BYPASSRELAYFAILEDSENSOR        ISA_INIT(156);
ISA_EXTERN const INT BYPASSPOWERSUPPLYFAULTSENSOR   ISA_INIT(157);
ISA_EXTERN const INT MATRIX                         ISA_INIT(158);


ISA_EXTERN const INT MEASUREUPS                     ISA_INIT(162);
ISA_EXTERN const INT MUPS_CONTACT_MGR               ISA_INIT(163);
ISA_EXTERN const INT MUPSFIRMWAREREVSENSOR               ISA_INIT(163);
ISA_EXTERN const INT CLIENTBINDERY               ISA_INIT(164);
ISA_EXTERN const INT VOLTAGEMANAGER               ISA_INIT(165);
ISA_EXTERN const INT BATTERYRUNTIMESENSOR         ISA_INIT(166);
ISA_EXTERN const INT RUNTIMEAFTERLOWBATTERYSENSOR         ISA_INIT(167);
ISA_EXTERN const INT PANELPASSWORDSENSOR         ISA_INIT(168);
ISA_EXTERN const INT UPSMODELSENSOR         ISA_INIT(169);

ISA_EXTERN const INT INTELLIGENCEMODULESENSOR       ISA_INIT(170); 
ISA_EXTERN const INT IMINSTALLATIONSTATUSSENSOR     ISA_INIT(171); 
ISA_EXTERN const INT RIMSTATUSSENSOR                ISA_INIT(172); 
ISA_EXTERN const INT RIMINSTALLATIONSTATUSSENSOR    ISA_INIT(173); 
ISA_EXTERN const INT SYSTEMLEVELFANSENSOR           ISA_INIT(174); 
ISA_EXTERN const INT BYPASSCONTACTORSENSOR          ISA_INIT(175); 
ISA_EXTERN const INT INPUTCIRCUITBREAKERSENSOR      ISA_INIT(176); 
ISA_EXTERN const INT REDUNDANCYCONDITIONSENSOR      ISA_INIT(177); 
ISA_EXTERN const INT LOADCAPABILITYSTATESENSOR      ISA_INIT(178); 
ISA_EXTERN const INT UPSMODULESTATUSENSOR           ISA_INIT(179); 
ISA_EXTERN const INT NUMBERUPSMODULESSENSOR         ISA_INIT(180); 
ISA_EXTERN const INT NUMBERBADUPSMODULESSENSOR      ISA_INIT(181); 
ISA_EXTERN const INT PHASEAINPUTVOLTAGESENSOR       ISA_INIT(182); 
ISA_EXTERN const INT PHASEBINPUTVOLTAGESENSOR       ISA_INIT(183); 
ISA_EXTERN const INT PHASECINPUTVOLTAGESENSOR       ISA_INIT(184); 
ISA_EXTERN const INT PHASEAOUTPUTVOLTAGESENSOR      ISA_INIT(185); 
ISA_EXTERN const INT PHASEBOUTPUTVOLTAGESENSOR      ISA_INIT(186); 
ISA_EXTERN const INT PHASECOUTPUTVOLTAGESENSOR      ISA_INIT(187); 
ISA_EXTERN const INT MINIMUMREDUNDANCYSENSOR        ISA_INIT(188); 
ISA_EXTERN const INT CURRENTREDUNDANCYSENSOR        ISA_INIT(189); 
ISA_EXTERN const INT CURRENTLOADSENSOR              ISA_INIT(190); 
ISA_EXTERN const INT SYMMETRA                       ISA_INIT(191); 
ISA_EXTERN const INT NUMBERINPUTPHASESSENSOR        ISA_INIT(192); 
ISA_EXTERN const INT NUMBEROUTPUTPHASESSENSOR       ISA_INIT(193); 
ISA_EXTERN const INT CURRENTLOADCAPABILITYSENSOR    ISA_INIT(194); 
ISA_EXTERN const INT MAXIMUMLOADCAPABILITYSENSOR    ISA_INIT(195); 
ISA_EXTERN const INT APCBINDERYENTRYSORTABLE        ISA_INIT(196);
ISA_EXTERN const INT APCINTSORTABLE                 ISA_INIT(197);
ISA_EXTERN const INT APCSTRIPINTSORTABLE            ISA_INIT(198);
ISA_EXTERN const INT MODULESCOUNTSBADBATTERIESSENSOR ISA_INIT(199);
#endif

#if ((C_OS & C_UNIX) || (C_OS & C_OS2))

#define OBJ                            1  
#define ABNORMALCONDITIONSENSOR        1  
#define ALARMDELAYSENSOR               2  
#define ATTRIBUTE                      3  
#define BACKUPS                        4  
#define BATTERYCALIBRATIONTESTSENSOR   5  
#define BATTERYCAPACITYSENSOR          6  
#define BATTERYCONDITIONSENSOR         7  
#define BATTERYREPLACEMENTDATESENSOR   9  
#define BATTERYVOLTAGESENSOR           11 
#define NMPIPEBINDERYENTRY             12 
#define COMMDEVICE                     13 
#define SERVERCOMMCONTROLLER           16 
#define COMMUNICATIONSTATESENSOR       18 
#define COPYRIGHTSENSOR                19 
#define DIPSWITCHPOSITIONSENSOR        23 
#define EVENTNODE                      24 
#define DEVICECONTROLLER               26 
#define ERRORMESSAGE                   32 
#define APC_EVENT                      34 
#define EVENTTIMER                     35 
#define EVENTMESSAGE                   38 
#define FILE_ISA                       40 
#define FIRMWAREREVSENSOR              41 
#define OUTPUTFREQUENCYSENSOR          42 
#define HIGHTRANSFERVOLTAGESENSOR      43 
#define ITEMCODE                       45 
#define LINEVOLTAGESENSOR              49 
#define LIST                           50 
#define LIGHTSTESTSENSOR               51 
#define LOWBATTERYDURATIONSENSOR       52 
#define LOWTRANSFERVOLTAGESENSOR       53 
#define MANUFACTUREDATESENSOR          54 
#define MAXLINEVOLTAGESENSOR           55 
#define MESSAGE                        57 
#define MINLINEVOLTAGESENSOR           58 
#define MINRETURNCAPACITYSENSOR        59 
#define NMPIPESTREAM                   61 
#define NODE                           62 
#define OUTPUTVOLTAGESENSOR            64 
#define OVERLOADSENSOR                 65 
#define POLLMAXLINEVOLTAGESENSOR       66 
#define POLLMINLINEVOLTAGESENSOR       67 
#define POLLPARAM                      68 
#define PORT                           72 
#define RATEDBATTERYVOLTAGESENSOR      77 
#define REPLACEBATTERYSENSOR           78 
#define RESETEEPROMDEFAULTSSENSOR      79 
#define RATEDLINEVOLTAGESENSOR         80 
#define RATEDOUTPUTVOLTAGESENSOR       81 
#define RUNTIMEREMAININGSENSOR         82 
#define SCHEDULELISTENTRY              83 
#define SCRIPT                         85 
#define SELFTESTRESULTSENSOR           87 
#define SELFTESTSCHEDULESENSOR         88 
#define SHUTDOWNDELAYSENSOR            91 
#define SMARTUPS                       93 
#define SMARTBOOSTSENSOR               94 
#define SMARTTRIMSENSOR                95 
#define TIMESTAMP                      96 
#define TATTRIBUTE                     97 
#define TIMER                          100
#define TURNOFFUPSIMMEDIATELYSENSOR    102
#define TURNOFFWITHDELAYSENSOR         103
#define TRANSACTIONITEM                105
#define TRANSACTIONGROUP               106
#define TRANSFERCAUSESENSOR            107
#define TRIPREGISTERSENSOR             108
#define TURNONDELAYSENSOR              110
#define TURNOFFUPSONBATTERYSENSOR      111
#define UTILITYLINECONDITIONSENSOR     112
#define UNSUPPORTEDSENSOR              113
#define PUTUPSTOSLEEPSENSOR            116
#define UPSBATTERYTYPESENSOR           117
#define UPSIDSENSOR                    118
#define UPSLOADSENSOR                  119
#define UPSSENSITIVITYSENSOR           120
#define UPSSERIALNUMBERSENSOR          121
#define UPSSIMULATEPOWERFAILSENSOR     122
#define UPSTEMPERATURESENSOR           123
#define TURNOFFDELAYSENSOR             126
#define SELFTESTSENSOR                 127
#define DDESTREAM                      128
#define DDEBINDERYENTRY                129
#define NUMBERBATTERYPACKSSENSOR       130
#define FIRMWAREREVMANAGER             131

// measure ups stuff

#define AMBIENTTEMPERATURESENSOR       136
#define HUMIDITYSENSOR                 137
#define CONTACTSENSOR                  138

#define APCSTRING                      139

#define NUMBERBADBATTERIESSENSOR       148
#define STATEREGISTERSENSOR            149
#define FANFAILURESENSOR               150
#define BATTERYCHARGERSENSOR           151
#define OVERTEMPFAULTSENSOR            152
#define BYPASSMODESENSOR               154
#define BYPASSRELAYFAILEDSENSOR        156
#define BYPASSPOWERSUPPLYFAULTSENSOR   157
#define MATRIX                         158


#define MEASUREUPS                     162
#define MUPS_CONTACT_MGR               163
#define MUPSFIRMWAREREVSENSOR               163
#define CLIENTBINDERY               164
#define VOLTAGEMANAGER               165
#define BATTERYRUNTIMESENSOR         166
#define RUNTIMEAFTERLOWBATTERYSENSOR         167
#define PANELPASSWORDSENSOR         168
#define UPSMODELSENSOR               169

#define INTELLIGENCEMODULESENSOR       170
#define IMINSTALLATIONSTATUSSENSOR     171 
#define RIMSTATUSSENSOR                172 
#define RIMINSTALLATIONSTATUSSENSOR    173 
#define SYSTEMLEVELFANSENSOR           174 
#define BYPASSCONTACTORSENSOR          175 
#define INPUTCIRCUITBREAKERSENSOR      176 

#define REDUNDANCYCONDITIONSENSOR      177 
#define LOADCAPABILITYSTATESENSOR      178 
#define UPSMODULESTATUSENSOR           179 
#define NUMBERUPSMODULESSENSOR         180 
#define NUMBERBADUPSMODULESSENSOR      181 
#define PHASEAINPUTVOLTAGESENSOR       182 
#define PHASEBINPUTVOLTAGESENSOR       183 
#define PHASECINPUTVOLTAGESENSOR       184 
#define PHASEAOUTPUTVOLTAGESENSOR      185 
#define PHASEBOUTPUTVOLTAGESENSOR      186 
#define PHASECOUTPUTVOLTAGESENSOR      187 
#define MINIMUMREDUNDANCYSENSOR        188 
#define CURRENTREDUNDANCYSENSOR        189 
#define CURRENTLOADSENSOR              190 
#define SYMMETRA                       191
#define NUMBERINPUTPHASESSENSOR        192
#define NUMBEROUTPUTPHASESSENSOR       193
#define CURRENTLOADCAPABILITYSENSOR    194 
#define MAXIMUMLOADCAPABILITYSENSOR    195 
#define APCBINDERYENTRYSORTABLE        196
#define APCINTSORTABLE                 197 
#define APCSTRIPINTSORTABLE            198
#define MODULESCOUNTSBADBATTERIESSENSOR 199 
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\firmman.cxx ===
/*
 *  pcy28jun96: Added IS_ stuff for menus
 *  pcy28jun96: Cleaned up. Handles BackUps. Removed 1G.
 *  pcy18Jul96: Made to work with old back ends
 *  pcy19Jul96: Made to work with for backups
 *  djs31Jul96: And still more IS_ stuff....
 *  das17Oct96: Prevented EVENT_LOG_UPDATE data from getting overwritten
 *  srt16Dec96: Added values to 220v allowed values list.
 *  inf25Feb97: Loaded localisable strings from the resource file
 *  srt04Jun97: Added IS_EXT_SLEEP_UPS case to get.
 *  srt09Jun97: Added a parent that is an Update obj.
 *  ntf20Aug97: If connected to an "old" Back-UPS Pro (simple) with Smart in
 *              the INI file, with a PnP cable attached, and when compiled
 *              with VC++ 4.2 then FirmwareRevManager constructor crashed
 *              because passed a NULL pointer to strdup, add check for this,
 *              and allocated an empty string.
 *  ntf20Aug97: Added free(theValue) in ReInitialize
 *  tjgOct1097: Implemented IsDarkStar method
 *  tjgOct1597: Fixed IS_LIGHTS_TEST Get ... not supported by DarkStar
 *  tjg10Nov97: Fixed IsDarkStar to check for NULL values
 *  tjg02Dec97: Changed darkstar to symmetra
 *  tjg30Jan98: Added destructor
 *  clk27Sep98: Added IS_MULTIBYTE and IS_SINGLEBYTE to get (determines 
 *              if we're using a single byte resource file or multibyte)
 * 
 *  v-stebe  29Jul2000   Added checks for mem. alloc. failures (bug #46334)
 */

#include "cdefine.h"
#include "apc.h"
#include "err.h"	      
#include "codes.h"
#include "cfgmgr.h"
#include "firmman.h"
#include "utils.h"

extern "C" {
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
}

// @@@ start
// @@@ end

//-------------------------------------------------------------------
// Global internal constants for class

const INT UPS_MODEL_CHAR         =  0;
const INT REVISION_LETTER_CHAR   =  1;
const INT UTILITY_VOLTAGE_CHAR      =  2;

const CHAR SU_250_FIRMWARE_CHAR  =   '2';
const CHAR SU_370_FIRMWARE_CHAR  =   '3';
const CHAR SU_400_FIRMWARE_CHAR  =   '4';
const CHAR SU_600_FIRMWARE_CHAR  =   '6';
const CHAR SU_900_FIRMWARE_CHAR  =   '7';
const CHAR SU_1250_FIRMWARE_CHAR =   '8';
const CHAR SU_2000_FIRMWARE_CHAR =   '9';
const CHAR PO_3000_FIRMWARE_CHAR =   '0';
const CHAR PO_5000_FIRMWARE_CHAR =   '5';
				  
const CHAR SU_100_VOLT_CHAR      =   'A';
const CHAR SU_120_VOLT_CHAR      =   'D';
const CHAR SU_208_VOLT_CHAR      =   'M';
const CHAR SU_220_VOLT_CHAR      =   'I';
const CHAR SU_200_VOLT_CHAR      =   'J';
const CHAR BACKUPS_CHAR          =   'Q';
const CHAR FIRST_GEN_CHAR        =   'A';
const CHAR SECOND_GEN_CHAR       =   'Q';
const CHAR THIRD_GEN_CHAR        =   'W';

const FIRMWARE_LENGTH_C          =    3;

//-------------------------------------------------------------------
//   Description:  Constructor               
//-------------------------------------------------------------------
FirmwareRevManager :: FirmwareRevManager(PUpdateObj aParent, PCHAR aFirmwareRevChars) :
theParent(aParent),
theValue(NULL)
{
    if (aFirmwareRevChars != NULL) {
      theValue = _strdup(aFirmwareRevChars);
    }
    else {
      theValue = (char *) malloc(1);
      if (theValue != NULL) {
        *theValue = '\0';
      }
    }
}

FirmwareRevManager :: ~FirmwareRevManager()
{
    if (theValue) {
        free(theValue);
        theValue = NULL;
    }
}

//-------------------------------------------------------------------
//   Description:  Save new firmware rev value.  This method avoids
//                 the destruction/creation cycle necessary
//                 otherwise. 
//-------------------------------------------------------------------
VOID FirmwareRevManager :: ReInitialize(PCHAR aFirmwareRevChars) 
{
   if (theValue) {
       free(theValue);
       theValue = NULL;
   }
   if (aFirmwareRevChars) {
       theValue = _strdup(aFirmwareRevChars);
   }
}
//-------------------------------------------------------------------
//   Description:  Class identifier
//-------------------------------------------------------------------
INT FirmwareRevManager :: IsA() const
{
   return FIRMWAREREVMANAGER;
}

//-------------------------------------------------------------------
//   Description:  Check for a 100 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is100VoltUps()
{
 INT answer = FALSE;

    if (theValue) {
      if (theValue[UTILITY_VOLTAGE_CHAR] == SU_100_VOLT_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}
//-------------------------------------------------------------------
//   Description:  Check for a 120 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is120VoltUps()
{
 INT answer = FALSE;

    if (theValue) {
      if (theValue[UTILITY_VOLTAGE_CHAR] == SU_120_VOLT_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a 200 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is200VoltUps()
{
    if(theValue)  {
	return (theValue[UTILITY_VOLTAGE_CHAR] == SU_200_VOLT_CHAR);
    }
    else {
	return FALSE;
    }
}

//-------------------------------------------------------------------
//   Description:  Check for a 208 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is208VoltUps()
{
    if(theValue)  {
	return (theValue[UTILITY_VOLTAGE_CHAR] == SU_208_VOLT_CHAR);
    }
    else {
	return FALSE;
    }
}
//-------------------------------------------------------------------
//   Description:  Check for a 220 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is220VoltUps()
{
    if(theValue)  {
	return (theValue[UTILITY_VOLTAGE_CHAR] == SU_220_VOLT_CHAR);
    }
    else {
	return FALSE;
    }
}

//-------------------------------------------------------------------
//   Description:  Check for a 250 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is250()
{
  INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == SU_250_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a 370 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is370()
{
 INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == SU_370_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a 400 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is400()
{
  INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == SU_400_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a 370 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is400_or_370()
{
  INT answer = FALSE;
  if (Is400() || Is370()) 
  {
     answer = TRUE;	
  }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a 600 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is600()
{
  INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == SU_600_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}
 
//-------------------------------------------------------------------
//   Description:  Check for a 900 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is900()
{
  INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == SU_900_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a 1250 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is1250()
{
  INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == SU_1250_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}
    
//-------------------------------------------------------------------
//   Description:  Check for a 2000 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is2000()
{
  INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == SU_2000_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a 3000 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is3000()
{
  INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == PO_3000_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a 5000 volt UPS  
//-------------------------------------------------------------------
INT FirmwareRevManager :: Is5000()
{
  INT answer = FALSE;

    if (theValue) {
      if (theValue[UPS_MODEL_CHAR] == PO_5000_FIRMWARE_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a Matrix
//-------------------------------------------------------------------
INT FirmwareRevManager :: IsMatrix()
{
   return (Is3000() || Is5000());
}

//-------------------------------------------------------------------
//   Description:  Dark Stars are not supported on old back-ends
//-------------------------------------------------------------------
INT FirmwareRevManager :: IsSymmetra()
{
    INT err = FALSE;

    CHAR value[10];
    theParent->Get(DECIMAL_FIRMWARE_REV, value);

	if (value) {
		PCHAR token = strtok(value, ".");
		
		if (token) {
			INT sku = atoi(token);
			
			if (sku >= 200 && sku <= 279) {
				err = TRUE;
			}
		}
	}

    return (err);
}

//-------------------------------------------------------------------
//   Description:  XL units are not supported on old back-ends  
//-------------------------------------------------------------------
INT FirmwareRevManager :: IsXL()
{
   return FALSE;
}

//-------------------------------------------------------------------
//   Description:  Get the number of internal battery packs.
//-------------------------------------------------------------------
VOID FirmwareRevManager :: GetNumberOfInternalBatteryPacks(PCHAR aValue)
{
 INT Number_Of_Internal_Packs = 1;

 if (IsMatrix()) 
 {
   Number_Of_Internal_Packs = 0;
 } 
   _itoa(Number_Of_Internal_Packs,aValue,10);
}

//-------------------------------------------------------------------
//   Description:  Check for a Back-UPS
//-------------------------------------------------------------------
INT FirmwareRevManager :: IsBackUps()
{
  //
  // Set to -1 to indicate unitialized;
  //
  static INT im_a_backups = -1;

  //
  // If we haven't done so already, go check the INI file to see if
  // we're using simple signalling.  To us, anything that uses simple
  // signalling is  BackUPS
  //
  if(im_a_backups == -1)  {
    CHAR signalling_type[128];
    _theConfigManager->Get(CFG_UPS_SIGNALLING_TYPE, signalling_type);
    if(_strcmpi(signalling_type, "Simple") == 0) {
      im_a_backups = TRUE;
    }
    else {
      im_a_backups = FALSE;
    }
  }

  return im_a_backups;
}
  

//-------------------------------------------------------------------
//   Description:  Check for a first gen UPS and only a first gen UPS
//-------------------------------------------------------------------
INT FirmwareRevManager :: IsFirstGen()
{
  INT answer = FALSE;

    if (theValue) {
      if ((theValue[REVISION_LETTER_CHAR] >= FIRST_GEN_CHAR) &&
         (theValue[REVISION_LETTER_CHAR] < SECOND_GEN_CHAR)){
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a second gen and only second gen UPS
//-------------------------------------------------------------------
INT FirmwareRevManager :: IsSecondGen()
{
  INT answer = FALSE;

    if (theValue) {
      if ((theValue[REVISION_LETTER_CHAR] >= SECOND_GEN_CHAR) &&
          (theValue[REVISION_LETTER_CHAR] < THIRD_GEN_CHAR)) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description:  Check for a third gen UPS or greater  The upper
//                 bound should be modified when a fourth gen UPS 
//                 exists.
//-------------------------------------------------------------------
INT FirmwareRevManager :: IsThirdGen()
{
 INT answer = FALSE;

    if (theValue) {
      if (theValue[REVISION_LETTER_CHAR] >= THIRD_GEN_CHAR) {
        answer = TRUE;		
      }
    }
   return answer;
}

//-------------------------------------------------------------------
//   Description: Determine UPS name based on firmware rev 
//-------------------------------------------------------------------
VOID FirmwareRevManager::GetUPSNameFromFirmware(PCHAR aValue)
{
    const INT Maximum_UPS_Name_Length_C = 10;
    CHAR model_char[Maximum_UPS_Name_Length_C];

    GetUPSModelChar(model_char);

    INT err =_theConfigManager->Get(CFG_UPS_MODEL_BASE +
	      atoi(model_char), aValue);
 
    if ((err != ErrNO_ERROR) && (err != ErrDEFAULT_VALUE_USED)) {
	err = ErrNO_ERROR;
    strcpy(aValue, "UNKNOWN MODEL");

    }

}

//-------------------------------------------------------------------
//   Description:  Determine UPS model character
//-------------------------------------------------------------------
VOID FirmwareRevManager::GetUPSModelChar(PCHAR aValue)
{
    if(theValue)  {
	_itoa(theValue[UPS_MODEL_CHAR],aValue,10);
    }
    else {
	_itoa(FALSE,aValue,10);
    }
}

//-------------------------------------------------------------------
//   Description:  Determine UPS firmware rev character
//-------------------------------------------------------------------
CHAR  FirmwareRevManager::GetFirmwareRevChar(VOID)
{
    return theValue[REVISION_LETTER_CHAR];
}

//-------------------------------------------------------------------
//   Description:  Determine country code
//-------------------------------------------------------------------
VOID FirmwareRevManager::GetCountryCode(PCHAR aValue)
{
    if (theValue)  {
	_itoa(theValue[UTILITY_VOLTAGE_CHAR],aValue,10);
    }
    else {
	_itoa(FALSE,aValue,10);
    }
}




//-------------------------------------------------------------------------
// Description:  Public interface to return firmware rev parameters.
//-------------------------------------------------------------------------

INT FirmwareRevManager::Get(INT aCode, PCHAR aValue)
{
  INT err = ErrNO_ERROR;


  //
  //  Back-UPS only handle a few codes.  Handle it separately.
  //
  if(IsBackUps()) {
    switch(aCode)  {
    case IS_BACKUPS:
      strcpy(aValue,"Yes");
      break;
    case UPS_MODEL:
      strcpy(aValue,"Back-UPS");
      break;
    
	// Do not overwrite data
    case EVENT_LOG_UPDATE:
      break;   
	  
      //
      // These are for compatibility for pre-Viper back-ends who
      // won't answer us
      //
    case IS_FLEX_EVENTS:
    case IS_EVENT_LOGGING:
      strcpy(aValue, "Yes");
      break;

    case SUPPORTED_FEATURES:
      sprintf(aValue, "%d,%d,%d,%d", UTILITY_LINE_CONDITION, 
              BATTERY_CONDITION, TURN_OFF_UPS_ON_BATTERY, TURN_OFF_UPS, 
              TURN_ON_SMART_MODE);
      break;

    default:
      //
      // Unless we specifically say we support something, we don't.
      //
      strcpy(aValue, "No");
      break;

    }
  }
  else {
    //
    // All other UPSs are handled here
    // 
    

    switch(aCode)
      {
      case COUNTRY_CODE:
        GetCountryCode(aValue);
        break;

      case UPSMODEL_CHAR:
        GetUPSModelChar(aValue);
        break;


      case IS_BACKUPS:
        //
        // Back-UPS are handled earlier.  This code is for smart UPSs only.
        //
        strcpy(aValue,"No");
        break;

      case IS_FIRST_GEN:
        {
          if(IsFirstGen()) {
            strcpy(aValue,"Yes");
          }
          else {
            strcpy(aValue,"No");
          }
        }
        break;

      case IS_SECOND_GEN:
        {
          //
          // For now we lie and say third gens are second gens.  Third gen
          // feature support is asked individually. Eventually we should
          // never have to ask what UPS we are, just if we support the feature.
          //
          if(IsSecondGen() || IsThirdGen())  {
            strcpy(aValue,"Yes");
          }
          else {
            strcpy(aValue,"No");
          }
        }
        break;

      case IS_THIRD_GEN:
        {
          if(IsThirdGen())  {
            strcpy(aValue,"Yes");
          }
          else {
            strcpy(aValue,"No");
          }
        }
        break;

      case IS_MATRIX:
        if (IsMatrix()) {
          strcpy(aValue,"Yes");
        }
        else {
          strcpy(aValue,"No");
        }
        break;

      case IS_SYMMETRA:
        if (IsSymmetra()) {
          strcpy(aValue,"Yes");
        }
        else {
          strcpy(aValue,"No");
        }
        break;
	
      case SUPPORTED_FEATURES:
        sprintf(aValue, "%d,%d,%d,%d", UTILITY_LINE_CONDITION, BATTERY_CONDITION,
                TURN_OFF_UPS_ON_BATTERY, TURN_OFF_UPS, TURN_ON_SMART_MODE);
        break;


        //
        // All UPSs do this, or they better
        //
      case IS_SELF_TEST:
      case IS_SIMULATE_POWER_FAIL:
        strcpy(aValue,"Yes");
        break;
        
      case IS_LIGHTS_TEST:
          if (IsSymmetra()) {
              strcpy(aValue, "No");
          }
          else {
              strcpy(aValue, "Yes");
          }
          break;

        //
        //  2G features and later.  If UPSs don't these they should
      case IS_FREQUENCY:
      case IS_BATTERY_CAPACITY:
      case IS_BATTERY_VOLTAGE:
      case IS_COPYRIGHT:
      case IS_RUNTIME_REMAINING:
      case IS_SENSITIVITY:
      case IS_LOW_BATTERY_DURATION:
      case IS_ALARM_DELAY:
      case IS_SHUTDOWN_DELAY:
      case IS_TURN_ON_DELAY:
      case IS_MANUFACTURE_DATE:
      case IS_SERIAL_NUMBER:
      case IS_UPS_ID:
      case IS_UTILITY_VOLTAGE:
      case IS_OUTPUT_VOLTAGE:
      case IS_UPS_LOAD:
      case IS_BATTERY_DATE:
      case IS_SELF_TEST_SCHEDULE:
      case IS_BATTERY_CALIBRATION:
      case IS_RATED_OUTPUT_VOLTAGE:
      case IS_HIGH_TRANSFER_VOLTAGE:
      case IS_LOW_TRANSFER_VOLTAGE:
        strcpy(aValue,"Yes");
        break;




        //
        // Dark-Star and Matrix don't do this
        //
      case IS_SMARTBOOST:
        if(IsSymmetra() || IsMatrix())  {
          strcpy(aValue,"No");
        }
        else {
          strcpy(aValue,"Yes");
        }
        break;


        //
        // Smart-Trim is supported only 3G Smart-UPSs
        //
      case IS_SMARTTRIM:
        {
          if (IsSecondGen() || IsMatrix() || IsSymmetra())  {
            strcpy(aValue,"No");
          }
          else {
            strcpy(aValue,"Yes");
          }
        }
        break;



        //
        // Matrix doesn't do this.  WHo knows why?
        //
      case IS_MIN_RETURN_CAPACITY:
        {
          if (IsMatrix()) {
            strcpy(aValue,"No");
          }
          else {
            strcpy(aValue,"Yes");
          }
        }
        break;


	
        // 
        // All post 2G UPSs should implement this.
        //  
      case IS_CTRL_Z:
        {
          if (IsSecondGen()) {
            strcpy(aValue,"No");
          }
          else {
            strcpy(aValue,"Yes");
          }
        }
        break;


        //
        // Special things the Smart-UPS 400 and 250 do.
        //
      case IS_LOAD_SENSING:
        {
          if (Is400_or_370()||Is250() )  {
            strcpy(aValue,"Yes");
          }
          else {
            strcpy(aValue,"No");
          }
        }
        break;



        //
        // Things the Smart-UPS 400 and 250 can't do.
        //
      case IS_TURN_OFF_WITH_DELAY:
      case IS_EEPROM_PROGRAM_CAPABLE:
      case IS_ADMIN_SHUTDOWN:
        {
          if (Is400_or_370()||Is250() )  {
            strcpy(aValue,"No");
          }
          else {
            strcpy(aValue,"Yes");
          }
        }
        break;




        //
        // Only Matrix and Dark-Star do bypass
      case IS_BYPASS:
        if(IsMatrix() || IsSymmetra())  {
          strcpy(aValue,"Yes");
        }
        else {
          strcpy(aValue,"No");
        }
        break;


        //
        // This is really for 2G Smart-UPS only.  All other UPSs should
        // be able to tell us themself with CTRL-Z
        //
      case HIGH_TRANSFER_VALUES:
        {
          if ( Is100VoltUps() )  {
            strcpy(aValue, "108,110,112,114");
          }
          else if ( Is208VoltUps() )  {
            if(IsMatrix())  {
              strcpy(aValue, "240,244,248,252");
            }
            else  {
              strcpy(aValue, "224,229,234,239");
            }
          }
          else if ( Is220VoltUps() )
            strcpy(aValue, "253,264,271,280");
          else {
            // 120 Volt UPS
            strcpy(aValue, "129,132,135,138");
          }
        }
        break;



        //
        // This is really for 2G Smart-UPS only.  All other UPSs should
        // be able to tell us themself with CTRL-Z
        //
      case LOW_TRANSFER_VALUES:
        {
          if ( !Is120VoltUps() ) {
            if ( Is100VoltUps() ) {
              if(GetFirmwareRevChar() < 'T')  {
                strcpy(aValue, "081,083,085,087");
              }
              else if(GetFirmwareRevChar() == 'T')  {
                strcpy(aValue, "081,083,087,090");
              }
              else {
                strcpy(aValue, "081,085,090,092");
              }
            }
            else if ( Is208VoltUps() )  {
              if(IsMatrix())  {
                strcpy(aValue, "156");
              }
              else  {
                strcpy(aValue, "168,172,177,182");
              }
            }
            else if ( Is220VoltUps() )  {
              strcpy(aValue, "188,196,204,208");
            }
          }
          // 120 Volt UPS
          else {
            strcpy(aValue, "097,100,103,106");
          }
        }
        break;


      case RATED_OUTPUT_VALUES:
        {
          if (Is120VoltUps()) {
            strcpy(aValue, "115");
          }
          else if (Is100VoltUps()) {
            strcpy(aValue, "100");
          }
          else if ( Is208VoltUps() )  {
            strcpy(aValue, "208");
          }
          else if ( Is220VoltUps() ) {
            strcpy(aValue, "220,225,230,240");
          }
          else if ( Is200VoltUps() ) {
            strcpy(aValue, "200");
          }
          else {
            //
            // We screwed up, but return something meaningful.
            //
            strcpy(aValue, "115");
          }
        }
        break;


        //
        // For those UPSs too dumb to know
        //
      case SINGLE_HIGH_TRANSFER_VALUE:
        {
          if ( Is120VoltUps() )  {
            strcpy(aValue, "132");
          }
          else if ( Is100VoltUps() )  {
            strcpy(aValue, "110");
          }
          else if ( Is208VoltUps() )  {
            strcpy(aValue, "229");
          }
          else if ( Is220VoltUps() )  {
            strcpy(aValue, "253");
          }
        }
        break;

        //
        // For those UPSs too dumb to know
        //
      case SINGLE_LOW_TRANSFER_VALUE:
        {
          if ( Is120VoltUps() )  {
            strcpy(aValue, "103");
          }
          else if ( Is100VoltUps() )  {
            strcpy(aValue, "85");
          }
          else if ( Is208VoltUps() )  {
            strcpy(aValue, "177");
          }
          else if ( Is220VoltUps() )  {
            strcpy(aValue, "196");
          }
        }
        break;

      case UPS_NAME:
        GetUPSNameFromFirmware(aValue);
        break;

      case INTERNAL_BATTERY_PACKS:
        GetNumberOfInternalBatteryPacks(aValue);
        break;


        //
        // External packs are editable only on XL UPSs.  UPSs like
        // Matrix and Dark-Star are smart enough to figure it out
        // themself
        //
      case EXTERNAL_PACKS_CHANGEABLE:
        {
          if(IsXL())  {
            strcpy(aValue,"Yes");
          }
          else {
            strcpy(aValue,"No");
          }
        }
        break;

      case MAX_VOLTAGE_RANGE_VALUE:
        {
          if ( Is120VoltUps() )  {
            strcpy(aValue, "140");
          }
          else if ( Is100VoltUps() )  {
            strcpy(aValue, "130");
          }
          else if (Is208VoltUps() || Is200VoltUps()) {
            strcpy(aValue, "260");
          }
          else if ( Is220VoltUps() )  {
            strcpy(aValue, "280");
          }
        }
        break;

      case MIN_VOLTAGE_RANGE_VALUE:
        {
          if ( Is120VoltUps() )  {
            strcpy(aValue, "90");
          }
          else if ( Is100VoltUps() )  {
            strcpy(aValue, "80");
          }
          else if (Is208VoltUps() || Is200VoltUps()) {
            strcpy(aValue, "160");
          }
          else if ( Is220VoltUps() )  {
            strcpy(aValue, "180");
          }
        }
        break;

        //
        // These are for compatibility for pre-Viper back-ends who
        // won't answer us
        //
      case IS_FLEX_EVENTS:
      case IS_EVENT_LOGGING:
      case IS_DATA_LOGGING:
      case IS_UPS_TEMPERATURE:
        strcpy(aValue, "Yes");
        break;

      case DECIMAL_FIRMWARE_REV:      
      case FIRMWARE_REV:
        strcpy(aValue, theValue);
        break;

      case IS_EXT_SLEEP_UPS:
          strcpy(aValue,"No");

          if (IsThirdGen() &&   // Not supported by 2nd gen and matrix units
             !IsMatrix()) {
              CHAR theDFRev[32], *tmp;
              INT err;

              err = theParent->Get(DECIMAL_FIRMWARE_REV,theDFRev);   //fails if comm lost...now what?
              if (err == ErrNO_ERROR) {
                  strtok(theDFRev,".");
                  tmp = strtok(NULL,".");
                  if (tmp && atoi(tmp) >= 11) {  // middle # of dec firm rev must be >=11
                      strcpy(aValue,"Yes");
                  }
              }
          }
          break;

      default:
        strcpy(aValue, "No");
        break;
      }
  }
  
  return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\list.h ===
/*
*
* NOTES:
*
* REVISIONS:
*  pcy26Nov92: Removed windows debug stuff and changed to apcobj.h
*  rct01Feb94: List no longer inherits from container or collection
*  pcy08Apr94: Trim size, use static iterators, dead code removal
*  mwh05May94: #include file madness , part 2
*/

#ifndef __LIST_H
#define __LIST_H

#include "apcobj.h"

_CLASSDEF(Node)
_CLASSDEF(List)
_CLASSDEF(ListIterator)

class  List : public Obj {
   
protected:
   
   INT   theItemsInContainer;
   
   PNode   theHead;
   PNode   theTail;
   
   virtual PNode     FindNode(PObj);
   PNode             GetHeadNode() {return theHead;}
   PNode             GetTailNode() {return theTail;}
   
   friend class ListIterator;
   
public:
   
   List();
   List(List*);
   virtual ~List() { Flush(); };
   
   RObj   PeekHead() const;
   
   virtual VOID   Add( RObj );
   virtual VOID   Append( PObj );
   virtual VOID   Detach( RObj );
   virtual VOID   Flush();
   virtual VOID   FlushAll();
   
   virtual INT    GetItemsInContainer() const { return theItemsInContainer; };
   virtual RListIterator InitIterator() const;
   
   virtual INT    Equal( RObj ) const;
   virtual PObj   GetHead();
   virtual PObj   GetTail();
   virtual PObj   Find(PObj);
   
};

//-------------------------------------------------------------------

class ListIterator {
   
private:
   
   PList theList;
   PNode theCurrentElement;
   
public:
   
   ListIterator( RList );
   
   virtual RObj Current();
   
   virtual RObj operator ++ ( INT );
   virtual RObj operator ++ ();
   virtual VOID Reset();
   PObj Next();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\lobatdur.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  pcy14Dec92: Changed READ_WRITE to AREAD_WRITE
 *
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "lobatdur.h"

LowBatteryDurationSensor :: LowBatteryDurationSensor(PDevice aParent, PCommController aCommController)
			: EepromChoiceSensor(aParent, aCommController, LOW_BATTERY_DURATION, AREAD_WRITE)
{
	getAllowedValues();
    setInitialValue();
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\litesnsr.cxx ===
/*
 *
 * REVISIONS:
 *  ker25NOV92  Initial OS/2 Revision 
 *  pcy11Dec92: New defines for lite sensor stuff used
 *  cad23Jun93: Fixed on/off events
 *  cad07Oct93: Plugging Memory Leaks
 *  cad11Nov93: Making sure all timers are cancelled on destruction
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "litesnsr.h"
#include "comctrl.h"
#include "dispatch.h"
#include "timerman.h"

//Constructor

LightsTestSensor :: LightsTestSensor(PDevice aParent, 
                                     PCommController aCommController)
    : StateSensor(aParent,aCommController,LIGHTS_TEST,AREAD_WRITE),
      theTimerId(0)
{
    storeState(NO_LIGHTS_TEST_IN_PROGRESS);
}


LightsTestSensor::~LightsTestSensor()
{
   if (theTimerId) {
      _theTimerManager->CancelTimer(theTimerId);
      theTimerId = 0;
   }
}


INT LightsTestSensor::Set(const PCHAR aValue)
{
    if( atoi(aValue) == LIGHTS_TEST )
    {
        CHAR buffer[16] = {NULL};
        _itoa(LIGHTS_TEST_IN_PROGRESS, buffer, 10);
        INT the_return=Sensor::Set(buffer);

//Tell the CommController that we're doing a lights test
        theCommController->Set(theSensorCode, aValue);
        
        Event the_event(LIGHTS_TEST, LIGHTS_TEST_IN_PROGRESS);
        Update(&the_event);
        
        if (theTimerId) {
           _theTimerManager->CancelTimer(theTimerId);
           theTimerId = 0;
        }
        
        Event done_event(LIGHTS_TEST, NO_LIGHTS_TEST_IN_PROGRESS);
        theTimerId = _theTimerManager->SetTheTimer((ULONG)LIGHTS_TEST_SECONDS,
           &done_event, this);
        return the_return;
    }
    else
        return ErrINVALID_VALUE;
}

INT LightsTestSensor::Update(PEvent anEvent)
{
    INT the_temp_code;
    PCHAR the_temp_value;
    INT the_int_value;
    
    the_temp_code=anEvent->GetCode();
    the_temp_value=anEvent->GetValue();
    
    the_int_value=atoi(the_temp_value);
    
    if( (the_temp_code == LIGHTS_TEST) && (the_int_value == NO_LIGHTS_TEST_IN_PROGRESS)) {
        Set(the_temp_value);
        theTimerId = 0;
    }
    return UpdateObj::Update(anEvent);
}


#if 0
***  Removed for size concerns.  This is really a redundant feature since
***  protocol generates these events

INT LightsTestSensor::Validate(INT aCode, const PCHAR aValue)
{
    INT the_temp_value=atoi(aValue);
    
    if( (aCode == LIGHTS_TEST) && (
        (the_temp_value == LIGHTS_TEST_IN_PROGRESS)||(the_temp_value == NO_LIGHTS_TEST_IN_PROGRESS)))
        return ErrNO_ERROR;
    else
        return ErrINVALID_VALUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\list.cxx ===
/*
*
* NOTES:
*
* REVISIONS:
*  pcy26Nov92: Removed windows.h debug stuff
*  jod03Dec92: Changed the  == tests to  x.Equal in a couple of places.
*  TSC11May93: In Equal(), cast theItemsInContainer as
*     (int) theItemsInContainer
*  TSC11May93: Changed operator ++ (INT) to always return a value,
*              including *(NULL) !! This allows a clean compile,
*     but is not a good solution. PCY SHOULD REVIEW.
*  cad27Sep93: Return before delete moved
*  rct01Feb94: List no longer inherits from Container
*  pcy08Apr94: Trim size, use static iterators, dead code removal
*  mwh05May94: #include file madness , part 2
*  ajr24May94: Added some casts for Uware
*  jps13Jul94: added stdlib.h for os2, changed include order
*  ntf12Oct95: Added line to Next ListIterator::Next function to stop it
*              bombing if theCurrentElement is NULL.
*  cgm24Apr96: Current() returns NULL when theCurrentElement is NULL
*
*  v-stebe  29Jul2000   Added checks for mem. alloc. failures 
*                       (bugs #46329, #46330, #46331, #46332, #46333)
*/


#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <stdlib.h>
#endif
#include <string.h>
#if (C_OS & C_NLM)
#include <process.h>
#endif
}

#include "list.h"
#include "node.h"

//------------------------------------------------------------------------

List::List() : 
theItemsInContainer(0),
theHead((PNode)NULL),
theTail((PNode)NULL)
{
}


//------------------------------------------------------------------------

List::List(PList anOldList) :
theItemsInContainer(0),
theHead((PNode)NULL),
theTail((PNode)NULL)

{
   INT err = ErrNO_ERROR;
   INT items_in_list = anOldList->GetItemsInContainer();
   
   if (items_in_list == 0)
   {
      err =  ErrLIST_EMPTY;
   }
   else
   {
      PObj current_object = (PObj)anOldList->GetHead();
      ListIterator list_iterator(*anOldList);
      
      while ((current_object) && (err == ErrNO_ERROR))
      {
         if (theTail == theHead)
         {
            theTail = new Node(current_object);
            if (theTail == NULL) {
              // Memory allocation error
              err = ErrMEMORY;
              break;
            }

            if (theHead == (PNode)NULL)
            {
               theHead = theTail;
               theHead->SetNext((PNode)NULL);
               theHead->SetPrev((PNode)NULL);
            }
            else
            {
               theHead->SetNext(theTail);
               theTail->SetPrev(theHead);
            }
         }
         else
         {
            PNode temp = new Node(current_object);
            theTail->SetNext(temp);
            temp->SetPrev(theTail);
            theTail = temp;
         }
         
         theItemsInContainer++;
         current_object = (PObj)list_iterator.Next();
      }
   }
   
}

//------------------------------------------------------------------------


RObj List::PeekHead() const 
{ 
   return *(theHead->theNext->theData); 
}


//------------------------------------------------------------------------


VOID List::Add( RObj anObject )
{
   if (theHead == (PNode)NULL)
   {
      theHead = new Node( &anObject);
      theTail = theHead;
      theItemsInContainer++;
   }
   else
   {
      PNode temp = new Node( &anObject, theHead );
      if (temp != NULL) {
        theHead->SetPrev(temp);
        temp->SetNext(theHead);
        theHead = temp;
        theItemsInContainer++;
      }
   }
}

//------------------------------------------------------------------------

VOID List::Append( PObj anObject )
{
   if (theTail == theHead)
   {
      theTail = new Node(anObject);
      if (theTail != NULL) {
        if (theHead == (PNode)NULL)
        {
           theHead = theTail;
           theHead->SetNext((PNode)NULL);
           theHead->SetPrev((PNode)NULL);
        }
        else
        {
           theHead->SetNext(theTail);
           theTail->SetPrev(theHead);
        }

        theItemsInContainer++;
      }
   }
   else
   {
      PNode temp = new Node(anObject);
      if (temp != NULL) {
        theTail->SetNext(temp);
        temp->SetPrev(theTail);
        theTail = temp;
        theItemsInContainer++;
      }
   }
}

//------------------------------------------------------------------------

PObj  List::GetHead()
{
   if (theHead != (PNode)NULL)
      return theHead->GetData();
   return (PObj)NULL;
}

//------------------------------------------------------------------------

PObj  List::GetTail()
{
   if (theTail != (PNode)NULL)
      return theTail->GetData();
   return (PObj)NULL;
}
//------------------------------------------------------------------------

PObj List::Find( PObj anObject )
{
   PNode cursor = theHead;
   
   while ( cursor != (PNode)NULL)
   {
      //        if (*anObject == *(cursor->GetData()) )
      if (anObject->Equal(*(cursor->GetData())) )
         return cursor->GetData();
      cursor = cursor->GetNext();
   }
   return (PObj)NULL;
}

//------------------------------------------------------------------------

PNode List::FindNode( PObj anObject )
{
   PNode cursor = theHead;
   
   while ( cursor != (PNode)NULL)
   {
      //        if (*anObject == *(cursor->GetData()) )
      if (anObject->Equal(*(cursor->GetData())) )
         return cursor;
      cursor = cursor->GetNext();
   }
   return (PNode)NULL;
}

//------------------------------------------------------------------------

VOID List::Detach( RObj anObject )
{
   PNode thenode = FindNode( &anObject );
   if (thenode == (PNode)NULL)
      return;   // Not in  the List
   
   PNode next = thenode->theNext;
   PNode prev = thenode->thePrev;
   
   if (prev)                                // If there is a previous node
      prev->SetNext(thenode->GetNext()); // assign its next field
   else
      theHead = next;
   
   if (next)
      next->SetPrev(thenode->GetPrev());
   else
      theTail = prev;
   
   theItemsInContainer--;
   delete thenode;
   thenode = NULL;
}

//------------------------------------------------------------------------

/*
C+
Name  :FlushALL
Synop :Will delete all the NODES in the list along with the user objects
as well. The user objects in the list are held by the NODES.
*/
VOID  List::FlushAll()
//c-
{
   PNode current = theHead;
   
   while( current != (PNode)NULL)       //theTail )
   {
      PNode temp = current;
      current = current->theNext;
      // Delete the User Data. List is a friend of node
      if(temp->theData) {
          delete temp->theData;
      }
      delete temp; // Delete the Node now.
      temp = NULL;
   }
   theHead = (PNode)NULL;
   theTail = (PNode)NULL;
   theItemsInContainer = 0;
   
}


VOID List::Flush()
{
   //    PNode current = theHead->theNext;
   PNode current = theHead;
   
   while( current != (PNode)NULL )
   {
      PNode temp = current;
      current = current->theNext;
      delete temp;
      temp = NULL;
   }
   theHead = (PNode)NULL;
   theTail = (PNode)NULL;
   theItemsInContainer = 0;
   
}

//------------------------------------------------------------------------

INT List::Equal( RObj anObject ) const
{
   if (anObject.IsA() != IsA())
   {
      return FALSE;
   }
   
   RList tmplist = (RList)anObject;
   if (tmplist.GetItemsInContainer() != (int) theItemsInContainer)
   {
      return FALSE;
   }
   
   RListIterator test_iterator = (RListIterator) tmplist.InitIterator();
   RListIterator our_iterator = (RListIterator) InitIterator();
   
   INT ccode = TRUE;
   for (INT i=0; i < theItemsInContainer; i++)
   {
      if (test_iterator++ != our_iterator++)
      {
         ccode = FALSE;
         break;
      }
   }
   
   delete &test_iterator;
   delete &our_iterator;
   return ccode;
}

//------------------------------------------------------------------------

RListIterator List::InitIterator() const
{
   return *( new ListIterator( (RList)*this ) );
}

//------------------------------------------------------------------------

ListIterator::ListIterator( RList aList )
{
   theList = (PList)&aList;
   theCurrentElement =  theList->GetHeadNode();
}


//------------------------------------------------------------------------

RObj ListIterator::Current()
{
   if (theCurrentElement)
      return *(theCurrentElement->GetData());
   else
      return *((PObj)NULL);
}

//------------------------------------------------------------------------


RObj ListIterator::operator ++ ( INT )

{
   PObj theData = (PObj) NULL;
   if (theCurrentElement)
   {
      theData = theCurrentElement->GetData();
      PNode tmp = theCurrentElement->GetNext();
      if (tmp)
      {
         theCurrentElement = tmp;
      }
   }
   
   return (*theData);   // TSC: Warning!! Can return *(NULL)
}

//------------------------------------------------------------------------

RObj ListIterator::operator ++ ()
{
   PObj theData = (PObj)NULL;
   
   if (theCurrentElement)
   {
      PNode tmp = theCurrentElement->GetNext();
      if (tmp)
      {
         theCurrentElement = tmp;
         theData = theCurrentElement->GetData();
      }
   }
   
   return (*theData);   // TSC: Warning!! Can return *(NULL)
}

//------------------------------------------------------------------------

VOID ListIterator::Reset()
{
   theCurrentElement = theList->GetHeadNode();
}

//------------------------------------------------------------------------

PObj ListIterator:: Next()
{
   
   //ntf12Oct95: Added next line to stop this function bombing
   if (theCurrentElement == NULL) return((PObj) NULL);
   
   PNode tmp = theCurrentElement->GetNext(); //If above if not there, could bomb
   if (tmp)
   {
      theCurrentElement = tmp;
      return theCurrentElement->GetData();
   }
   return (PObj)NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\litesnsr.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker25NOV92   Initial OS/2 Revision
 *  cad23Jun93	 Added time delay vals
 *  cad11Nov93: Making sure all timers are cancelled on destruction
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */
 
#ifndef __LITESNSR_H
#define __LITESNSR_H

#include "stsensor.h"
#include "event.h"

#define LIGHTS_TEST_SECONDS	(5)	// a little extra just in case
#define LIGHTS_TEST_MSECS	(LIGHTS_TEST_SECONDS * 1000)

_CLASSDEF(LightsTestSensor)

			  
class LightsTestSensor : public StateSensor {


protected:
    ULONG theTimerId;

public:
	LightsTestSensor(      PDevice 	  aParent, 
                          PCommController aCommController);
    virtual ~LightsTestSensor();

//overidden interfaces

	virtual INT IsA() const { return LIGHTSTESTSENSOR; };
        virtual INT Set(const PCHAR);
        virtual INT Update(PEvent);
//        virtual INT Validate(INT, const PCHAR);
	
//Additional Interfaces

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\lobatdur.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *
 */
#ifndef LOBATDUR_H
#define LOBATDUR_H

#include "eeprom.h"

_CLASSDEF(LowBatteryDurationSensor)
 
class LowBatteryDurationSensor : public EepromChoiceSensor {
   
public:
   LowBatteryDurationSensor(PDevice aParent, PCommController aCommController=NULL);
   virtual INT IsA() const { return LOWBATTERYDURATIONSENSOR; };
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\mainapp.h ===
/*
 * REVISIONS:
 *  pcy30Nov92: Added header
 *  ane22Dec92: Added GetHost member function
 *  ane18Jan93: Added the data logger
 *  ane21Jan93: Added the error logger
 *  ane03Feb93: Added params to CreateXXXController routines
 *  rct07Feb93: removed some VOIDs..split off client & server apps
 *  tje20Feb93: Conditionally removed ErrorLogger for Window's version
 *  cad10Dec93: added transitem get/set
 *  ram21Mar94: Removed old windows stuff
 *  mwh05May94: #include file madness , part 2
 */
#ifndef _MAINAPP_H
#define _MAINAPP_H

#include "apc.h"
#include "_defs.h"

#include "update.h"

_CLASSDEF(MainApplication)

_CLASSDEF(TransactionItem)
_CLASSDEF(TimerManager)
_CLASSDEF(ConfigManager)
_CLASSDEF(ErrorLogger)


class MainApplication : public UpdateObj
{
public:
    virtual INT Start() =0;
    virtual VOID Idle()  =0;
    virtual VOID Quit()  =0;
    virtual INT  Get(INT code,CHAR *value)=0;
    virtual INT  Get(PTransactionItem)=0;
    virtual INT  Set(INT code,const PCHAR value)=0;
    virtual INT  Set(PTransactionItem)=0;

protected:
    PTimerManager     theTimerManager;
    PConfigManager    theConfigManager;
    PErrorLogger      theErrorLog;

    MainApplication();
    virtual ~MainApplication();

};

/*c-*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\mainapp.cxx ===
/*
 * REVISIONS:
 *  pcy30Nov92: Added header 
 *  ane16Dec92: Moved some functions up from platform specific apps
 *  pcy17Dec92: Added construction of theConfigManager to MainApp
 *  ane11Jan93: Call Host::RegisterForEvents explicitly
 *  ane18Jan93: Added data logger and updated Set function
 *  ane21Jan93: Added error logger
 *  pcy29Jan93: Generate a MONITORING_STARTED event in ServerApp::Start()
 *  jod02Feb93: Moved MONITORING_STARTED to Os2ServerApp::Start()
 *  ane02Feb93: Moved MONITORING_STARTED back to ServerApp::Start()
 *  ane03Feb93: Changed order of construction and added some initialization
 *  rct09Feb93: Split client and server app to thier own files
 *  tje26Feb93: Added stdlib.h header for getenv() prototype
 *  cad07Jun93: made bcfgmgr.h include only for windows
 *  pcy09Sep93: Log file not found error to errlog if inifile isnt there
 *  rct05Nov93: Added hook to allow 'passing' of directory to mainapp for NLMs
 *  cad19Nov93: better ini file delim
 *  mwh16Mar94: better path check for .ini file
 *  ram21Mar94: Added some windows specific stuff and also modified ctor and 
 *              dtor.  
 *  mwh05May94: #include file madness , part 2
 *  ajr22Jul94: Fixed crash if "configuration" file isn't found.
 *  dml21Jun95: Modified for general utility to get default pwrchute 
 *              directory, req'd for Windows
 *  ajr07Nov95: port for SINIX
 *  pam02Apr96: When deleting theTimerManager, I check to see if 
 *              _theTimerManager exists as well *   
 *  inf01Mar97: Loaded all localisable strings from the resource file
 *  inf28Apr97: Used FormatMessage() to display message about ini file missing.
 *  ntf08May97: Changed mainapp.cxx to use NTConfigManager on Win95
 *  inf10May97: Loaded resource file in MainApplication because it had to be
 *              loaded before the ErrorLogger object was created
 *  ntf03Oct97: Removed C_WIN95. NTConfigManager now used in both NT and 95.
 *  cgm25Nov97: Removed the duplicate creation of theErrorLog 
 *  awm02Oct97: Moved setting _theConfigManager to NULL when the main ini 
 *              configuration manager is destroyed to the main application 
 *              from the object itself in order to support multiple 
 *              configuration managers operating at once.

 */

#include "cdefine.h"

#include "_defs.h"
#include "mainapp.h"
#include "errlogr.h"
#include "timerman.h"
#include "ntcfgmgr.h"



/*
C+
  Name  :MainApplication
  Synop :
         Constructor. Can be called from any class dervived from
         MainApplication. Initializes a Dispatcher.
         Any object derived from this class should NEW the
         TimerManager object.
*/
MainApplication::MainApplication() : theTimerManager((PTimerManager)NULL)
{
    theConfigManager = new NTConfigManager();

    // need to do this here, after we check for the existance of pwrchute.ini and
    // the resource file, because the resource file is used when ErrorLogger
    // is created
    theErrorLog = new ErrorLogger(this);
}


/***************************************************************************
 ***************************************************************************/
MainApplication::~MainApplication()
{
    delete theConfigManager;
    _theConfigManager = (PConfigManager) NULL;
    
    delete theErrorLog;
    theErrorLog = NULL;
    
    if (theTimerManager && (_theTimerManager)) {
        delete theTimerManager;
        theTimerManager = NULL;
    }
    _theTimerManager = theTimerManager = (PTimerManager)NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\manudate.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *
 */
#ifndef MANUDATE_H
#define MANUDATE_H

#include "sensor.h"

_CLASSDEF(ManufactureDateSensor)

class ManufactureDateSensor : public Sensor {
   
public:
   ManufactureDateSensor( PDevice aParent, PCommController aCommController=NULL);
   virtual INT IsA() const { return MANUFACTUREDATESENSOR; };
   
};

 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\matrix.h ===
/*
 *
 * REVISIONS:
 *  cad11Nov93: Making sure all timers are cancelled on destruction
 *  djs22Feb96: Added smart trim sensor
 */

#ifndef _INC__MATRIX_H
#define _INC__MATRIX_H


#include "smartups.h"


_CLASSDEF(Matrix)


//-------------------------------------------------------------------

class Matrix : public SmartUps {

protected:

    //
    // required sensors
    //
   PSensor theNumberBadBatteriesSensor;
   PSensor theBypassModeSensor;


   INT theIgnoreBattConditionOKFlag;
   ULONG theTimerID;

   virtual VOID   HandleBatteryConditionEvent( PEvent aEvent );
   virtual VOID   HandleLineConditionEvent( PEvent aEvent );
   virtual VOID   handleBypassModeEvent( PEvent aEvent );
   virtual VOID   handleSmartCellSignalCableStateEvent( PEvent aEvent );
   virtual INT    MakeSmartBoostSensor( const PFirmwareRevSensor rev );
   virtual INT    MakeSmartTrimSensor(const PFirmwareRevSensor rev);

   virtual VOID   registerForEvents();
   virtual VOID   reinitialize();

public:

   Matrix( PUpdateObj aDeviceController, PCommController aCommController );
   virtual ~Matrix();

   virtual INT  IsA() const { return MATRIX; };
   virtual INT Get( INT code, PCHAR value );
   virtual INT Set( INT code, const PCHAR value );
   virtual INT Update( PEvent event );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\manudate.cxx ===
/*
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "manudate.h"

ManufactureDateSensor :: ManufactureDateSensor(PDevice aParent, PCommController aCommController)
			: Sensor(aParent, aCommController, MANUFACTURE_DATE)
{
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\matrix.cxx ===
/*
*
* REVISIONS:
*
*  cad08Sep93: Fix for setting from front end
*  pcy13Sep93: Override SmartUps::HandleLineFail so we dont worry about boost
*  cad16Sep93: Fixed state check bug
*  pcy18Sep93: Cleaned up include files
*  pcy20Sep93: Add line condition to smrt cable event so we dont crash in host
*  cad02Nov93: name fix
*  cad11Nov93: Making sure all timers are cancelled on destruction
*  cad08Jan94: took out get for ups model (virtualized in smartups)
*  pcy08Apr94: Trim size, use static iterators, dead code removal
*  djs22Feb96: Removed smart trim sensor
*/
#include <stdlib.h>

#include "cdefine.h"
#include "_defs.h"

#include "matrix.h"
#include "batpacks.h"
#include "badbatts.h"
#include "bypmodes.h"
#include "timerman.h"
#include "unssens.h"


Matrix::Matrix(PUpdateObj aDeviceController, PCommController aCommController)
: SmartUps(aDeviceController, aCommController),
 theIgnoreBattConditionOKFlag(FALSE),
 theTimerID(0)
{
    theNumberBadBatteriesSensor = new NumberBadBatteriesSensor(this, aCommController);
    theBypassModeSensor         = new BypassModeSensor(this, aCommController);
}


Matrix::~Matrix()
{
    if (theTimerID) {
        _theTimerManager->CancelTimer(theTimerID);
        theTimerID = 0;
    }
    delete theNumberBadBatteriesSensor;
    theNumberBadBatteriesSensor = NULL;
    delete theBypassModeSensor;
    theBypassModeSensor = NULL;
}


//-------------------------------------------------------------------------

VOID Matrix::registerForEvents()
{
    SmartUps::registerForEvents();

    theBypassModeSensor->RegisterEvent(BYPASS_MODE, this);
    theNumberBatteryPacksSensor->RegisterEvent(SMART_CELL_SIGNAL_CABLE_STATE, this);
}


//-------------------------------------------------------------------------

INT Matrix::Get(INT code, char *aValue)
{
    INT err = ErrINVALID_CODE;

    switch(code)
    {
        // These, however, have no meaning to Matrix
    case ALLOWED_LOW_TRANSFER_VOLTAGES:
    case MIN_RETURN_CAPACITY:
    case ALLOWED_MIN_RETURN_CAPACITIES:
        //
        // These are not implemented on Matrix so dont ask the SmartUps
        // to do them.
        break;

    case MATRIX_FAN_STATE:
        err = ErrUNSUPPORTED;
        break;
    case BAD_BATTERY_PACKS:
        err = theNumberBadBatteriesSensor->Get(code, aValue);
        break;
    case BYPASS_POWER_SUPPLY_CONDITION:
        err = ErrUNSUPPORTED;
        break;
    case BYPASS_MODE:
        err = theBypassModeSensor->Get(code, aValue);
        break;
    case UPS_FRONT_PANEL_PASSWORD:
        err = ErrUNSUPPORTED;
        break;
    case UPS_RUN_TIME_AFTER_LOW_BATTERY:
        err = ErrUNSUPPORTED;
        break;
    case ALLOWED_UPS_RUN_TIME_AFTER_LOW_BATTERY:
        err = ErrUNSUPPORTED;
        break;
    default:
        err = SmartUps::Get(code, aValue);
        break;
    }

    return err;
}

//-------------------------------------------------------------------------

INT Matrix::Set(INT code, const PCHAR aValue)
{
    INT err = ErrINVALID_CODE;

    switch(code)
    {
    case LOW_TRANSFER_VOLTAGE:
    case ALLOWED_LOW_TRANSFER_VOLTAGES:
    case MIN_RETURN_CAPACITY:
    case ALLOWED_MIN_RETURN_CAPACITIES:
        break;
    case BYPASS_MODE:
        err = theBypassModeSensor->Set(code, aValue);
        break;
    case UPS_FRONT_PANEL_PASSWORD:
        err = ErrUNSUPPORTED;
        break;
    case UPS_RUN_TIME_AFTER_LOW_BATTERY:
        err = ErrUNSUPPORTED;
        break;
    default:
        err = SmartUps::Set(code, aValue);
        break;
    }
    return err;
}


INT Matrix::Update(PEvent anEvent)
{
    switch(anEvent->GetCode())  {
    case BYPASS_MODE:
        handleBypassModeEvent(anEvent);
        break;

    case BYPASS_POWER_SUPPLY_CONDITION:
        break;

    case SMART_CELL_SIGNAL_CABLE_STATE:
        handleSmartCellSignalCableStateEvent(anEvent);
        break;

    default:
        SmartUps::Update(anEvent);
        break;
    }
    return ErrNO_ERROR;
}


VOID Matrix::HandleLineConditionEvent(PEvent anEvent)
{
    switch(atoi(anEvent->GetValue())) {

    case LINE_GOOD:
        if (IS_STATE(UPS_STATE_ON_BATTERY)) {
            BackUps::HandleLineConditionEvent(anEvent);
        }
        break;

    case LINE_BAD:
        {
            CHAR value[32];
            theBypassModeSensor->Get(BYPASS_MODE, value);
            INT bypmode = atoi(value);

            if (bypmode != UPS_ON_BYPASS) {
                BackUps::HandleLineConditionEvent(anEvent);
            }
        }
        break;
    }
}


VOID Matrix::HandleBatteryConditionEvent(PEvent anEvent)
{
    CHAR value[32];

    theNumberBatteryPacksSensor->DeepGet(value);
    INT packs = atoi(value);

    // If packs is 0 we assume the smart cell signal cable is not plugged in
    // and ignore the battery condition events the UPS puts out (a UPSLink-ism)
    if (packs > 0)  {
        INT val = atoi(anEvent->GetValue());

        if((val == BATTERY_BAD) ||
            ((val == BATTERY_GOOD) && (theIgnoreBattConditionOKFlag == FALSE))) {
            SmartUps::HandleBatteryConditionEvent(anEvent);
        }
    }
}


VOID Matrix::handleBypassModeEvent(PEvent anEvent)
{
    INT bit_to_use = 0;
    INT cause = atoi(anEvent->GetAttributeValue(BYPASS_CAUSE));

    switch(cause)  {
    case BYPASS_BY_SOFTWARE:
    case BYPASS_BY_SWITCH:
        bit_to_use = BYPASS_MAINT_BIT;
        break;
    case BYPASS_BY_DC_IMBALANCE:
    case BYPASS_BY_VOLTAGE_LIMITS:
    case BYPASS_BY_TOP_FAN_FAILURE:
    case BYPASS_BY_INTERNAL_TEMP:
    case BYPASS_BY_BATT_CHARGER_FAILED:
        bit_to_use = BYPASS_MODULE_FAILED_BIT;
        break;
    }


    INT val = atoi(anEvent->GetValue());
    switch(val)  {
    case UPS_ON_BYPASS:
        SET_BIT(theUpsState, bit_to_use);
        break;

    case UPS_NOT_ON_BYPASS:
        CLEAR_BIT(theUpsState, bit_to_use);
        break;
    }
    UpdateObj::Update(anEvent);
}


VOID Matrix::handleSmartCellSignalCableStateEvent(PEvent anEvent)
{
    INT val = atoi(anEvent->GetValue());
    switch(val)  {
    case CHECK_CABLE:
    case CABLE_OK:

        if(IS_STATE(UPS_STATE_ON_BATTERY)) {
            anEvent->AppendAttribute(UTILITY_LINE_CONDITION, LINE_BAD);
        }
        else {
            anEvent->AppendAttribute(UTILITY_LINE_CONDITION, LINE_GOOD);
        }
        UpdateObj::Update(anEvent);
        break;

    case IGNORE_BATTERY_GOOD:
        {
            Event cable_event(SMART_CELL_SIGNAL_CABLE_STATE,
                RESPOND_TO_BATTERY_GOOD);
            theIgnoreBattConditionOKFlag = TRUE;
            theTimerID = _theTimerManager->SetTheTimer(5, &cable_event, this);
            UpdateObj::Update(anEvent);
        }
        break;
    case RESPOND_TO_BATTERY_GOOD:
        theIgnoreBattConditionOKFlag = FALSE;
        break;
    }
}


INT Matrix::MakeSmartBoostSensor(const PFirmwareRevSensor rev)
{
    //
    // Smart-Boost is not supported on the Matrix
    //
    theSmartBoostSensor = &_theUnsupportedSensor;
    return ErrNO_ERROR;
}


INT Matrix::MakeSmartTrimSensor(const PFirmwareRevSensor rev)
{
    //
    // SmartTrim is not supported on the Matrix
    //
    theSmartTrimSensor = &_theUnsupportedSensor;
    return ErrNO_ERROR;
}


VOID Matrix::reinitialize()
{
    SmartUps::reinitialize();
    theNumberBadBatteriesSensor->DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\mutexlck.h ===
/*
 *
 * REVISIONS:
 *  cad09Jul93: Initial Revision
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */


#ifndef __MUTEXLCK_H
#define __MUTEXLCK_H

#include "apcobj.h"


_CLASSDEF( MutexLock )

class MutexLock : public Obj {

protected:

public:
   MutexLock() {};

   virtual INT   Request() {return TimedRequest(-1L);};
   virtual INT   TimedRequest(LONG aMillisecondTimeOut) = 0;
   virtual INT   IsHeld() = 0;
   virtual INT   Release() = 0;
};


class AutoMutexLocker
{
public:
    AutoMutexLocker(MutexLock * aLock) 
        : theLock(aLock) 
    {
        if (theLock) {
            theLock->Request();
        }
    };

    //
    // the destructor is not declared virtual because this
    // class is not intended to be derived from - so there
    // is no need to add a Vtable when it isn't needed
    //
    ~AutoMutexLocker() 
    {
        if (theLock) {
            theLock->Release();
        }
    };

protected:
private:
    MutexLock * theLock;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\message.h ===
/*
* REVISIONS:
*  pcy29Nov92: Changed obj.h to apcobj.h; removed upsdefs.h
*              removed MessageType enums; Added IsA, fixed Equal
*  cad28Sep93: Made sure destructor(s) virtual
*  mwh18Nov93: Changed EventID to INT
*  mwh05May94: #include file madness , part 2
*/

#ifndef __MESSAGE_H
#define __MESSAGE_H

_CLASSDEF(Message)

#include "apcobj.h"

class Message :public Obj
{
protected:
   INT     Id;
   Type        MsgType;
   INT         Timeout;
   CHAR*       Submit;
   CHAR*       Value;
   CHAR*       Compare;
   CHAR*       Response;
   INT         Errcode;
   ULONG       theWaitTime;
   
public:
   Message();
   Message(PMessage aMessage);
   Message(INT id);
   Message(INT id, Type type);
   Message(INT id, Type type, CHAR* value);
   Message(INT id, Type type, int value);
   virtual ~Message();
   
   VOID    setId(INT id) {Id = id;}
   VOID    setType(Type type) {MsgType = type;}
   VOID    setTimeout(INT timeout) {Timeout = timeout;}
   VOID    setSubmit(CHAR* submit);
   VOID    setValue(CHAR* value);
   VOID    setCompare(CHAR* value);
   VOID    setResponse(CHAR* response);
   VOID    setErrcode(INT errcode) {Errcode = errcode;}
   VOID    setWaitTime(ULONG thetime) {theWaitTime = thetime;}
   INT     getId() {return Id;}
   Type    getType() {return MsgType;}
   INT     getTimeout() {return Timeout;}
   CHAR*   getSubmit() {return Submit;}
   CHAR*   getValue() {return Value;}
   CHAR*   getCompare() {return Compare;}
   CHAR*   getResponse() {return Response;}
   INT     getErrcode() {return Errcode;}
   ULONG   getWaitTime() {return theWaitTime;}
   VOID    ReleaseResponse();
   
   virtual INT IsA() const {return MESSAGE;}
   INT         Equal( RObj ) const;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\mutexnt.cxx ===
/*
 *
 * REVISIONS:
 *  pcy16Jul93: Added NT semaphores
 *  ash10Jun96: Cleaned up the class - overloaded the constructor
 *              and added logic to handle interprocess synchronization
 *
 */
#include "cdefine.h"

extern "C" 
{
    #include <windows.h>
}
#include "mutexnt.h"
#include "err.h"


/* -------------------------------------------------------------------------
   ApcMutexLock::ApcMutexLock() - The mutex is created as unnamed and shared
 
-------------------------------------------------------------------------  */

ApcMutexLock::ApcMutexLock(VOID) : 
   MutexLock()
{
    SetObjectStatus(ErrNO_ERROR);
    
	theSemHand = CreateMutex((LPSECURITY_ATTRIBUTES)NULL,
		                          FALSE,
		                          (LPTSTR)NULL);
    if(!theSemHand)
	{
		SetObjectStatus(ErrSEM_CREATE_FAILED);
	}
}


/* -------------------------------------------------------------------------
   ApcMutexLock::ApcMutexLock() - creates an named mutex for interprocess
   synchronization
 
-------------------------------------------------------------------------  */

ApcMutexLock::ApcMutexLock(PCHAR aUniqueMutexName) : MutexLock()
{
    SetObjectStatus(ErrNO_ERROR);
    
	theSemHand = CreateMutex((LPSECURITY_ATTRIBUTES)NULL,
		                          FALSE,
		                          (LPTSTR)aUniqueMutexName);
    if(!theSemHand )
	{
		SetObjectStatus(ErrSEM_CREATE_FAILED);
	}
}



/* -------------------------------------------------------------------------
   ApcMutexLock::~ApcMutexLock() - Close the mutex handle
 
-------------------------------------------------------------------------  */

ApcMutexLock::~ApcMutexLock()
{
    CloseHandle(theSemHand);
}


/* -------------------------------------------------------------------------
   ApcMutexLock::GetExistingMutex() - Opens the handle to an existing
   mutex by specifying the mutex name. We need full access to the mutex object
   before the mutex handle can be used in any of the wait functions.
 
-------------------------------------------------------------------------  */

INT ApcMutexLock::GetExistingMutex(TCHAR aMutexName)
{
	INT err = ErrNO_ERROR;

	theSemHand  = OpenMutex(MUTEX_ALL_ACCESS,   // Request full access
		                       FALSE,
							   (LPCTSTR)aMutexName); // Mutex name

	if (!theSemHand )
	{
		err = ErrSEM_GENERAL_ERROR;
	}

	return err;
}


/* -------------------------------------------------------------------------
   ApcMutexLock::TimedRequest() - Wait for lock to be available

   ulTimeout: 0 - Don't wait at all
             <0 - Wait forever (same as Request())
    	     >0 - Wait for ulTimeout milliseconds

-------------------------------------------------------------------------  */

INT ApcMutexLock::TimedRequest(LONG ulTimeout) 
{
    INT err;
    DWORD time_out = (ulTimeout < 0) ? INFINITE : ulTimeout;
    DWORD waitresult = WaitForSingleObject(theSemHand, time_out);
     
    if(waitresult == 0)
    {
	    err = ErrNO_ERROR;
    }
    else if (waitresult == WAIT_TIMEOUT)
    {
	    err = ErrSEM_TIMED_OUT;
    }
    else
    {
	    err = ErrSEM_GENERAL_ERROR;
    }


    return err;
}


/* -------------------------------------------------------------------------
   ApcMutexLock::IsHeld() - Checks the state of the mutex
 
-------------------------------------------------------------------------  */

INT ApcMutexLock::IsHeld(VOID)
{
    INT ret;
    DWORD waitresult = WaitForSingleObject(theSemHand ,(DWORD)0);
      
    if(waitresult == 0)
    {
	    ret = ErrNO_ERROR;
    }
    else 
    {
	    ret = ErrSEM_BLOCK_NG;
    }
    return ret;
}


/* -------------------------------------------------------------------------
   ApcMutexLock::Release() - Releases control of a mutex previously held
 
-------------------------------------------------------------------------  */

INT ApcMutexLock::Release(VOID)
{
    INT err;
    
	if(!ReleaseMutex(theSemHand ))
	{
	    err =ErrSEM_GENERAL_ERROR;
	}
    else
	{
		err = ErrNO_ERROR; 
	}

    return err;
}



/* -------------------------------------------------------------------------
   ApcMutexLock::Wait() - Waits indefinitely for a mutex to be released
 
-------------------------------------------------------------------------  */

INT ApcMutexLock::Wait() 
{
    DWORD waitresult = WaitForSingleObject(theSemHand , INFINITE);

    if(waitresult == 0)
	{
	    return ErrNO_ERROR;
	}
    else
    {
		return ErrSEM_GENERAL_ERROR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\message.cxx ===
/*
* REVISIONS:
*  mwh18Nov93: changed EventID to INT 
*
*  mwh07Jun94: port for NCR
*/
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
}
#include "_defs.h"
#include "message.h"

#if (C_OS & C_NCR)
#  include "incfix.h"
#endif


Message :: Message() : Id(0),
MsgType((Type)0),
Timeout(0),
Submit((CHAR*)NULL),
Value((CHAR*)NULL),
Compare((CHAR*)NULL),
Response((CHAR*)NULL),
Errcode(0),
theWaitTime(40)
{
}

Message :: Message(PMessage aMessage) : Id(aMessage->getId()),
MsgType(aMessage->getType()),
Timeout(aMessage->getTimeout()),
Submit((CHAR*)NULL),
Value((CHAR*)NULL),
Compare((CHAR*)NULL),
Response((CHAR*)NULL),
Errcode(aMessage->getErrcode()),
theWaitTime(aMessage->getWaitTime())
{
   setSubmit(aMessage->getSubmit());
   setValue(aMessage->getValue());
   setCompare(aMessage->getCompare());
   setResponse(aMessage->getResponse());
}


Message :: Message(INT id) : Id(id),
MsgType((Type)0),
Timeout(0),
Submit((CHAR*)NULL),
Value((CHAR*)NULL),
Compare((CHAR*)NULL),
Response((CHAR*)NULL),
Errcode(0),
theWaitTime(40)
{
}

Message :: Message(INT id, Type type) : Id(id),
MsgType(type),
Timeout(0),
Submit((CHAR*)NULL),
Value((CHAR*)NULL),
Compare((CHAR*)NULL),
Response((CHAR*)NULL),
Errcode(0),
theWaitTime(40)
{
}

Message :: Message(INT id, Type type, CHAR* value) : Id(id),
MsgType(type),
Timeout(0),
Submit((CHAR*)NULL),
Value((CHAR*)NULL),
Compare((CHAR*)NULL),
Response((CHAR*)NULL),
Errcode(0),
theWaitTime(40)
{
   setValue(value);
}


Message::~Message()
{
   if(Submit)  {
      free(Submit);
   }
   if(Value)  {
      free(Value);
   }
   if(Compare)  {
      free(Compare);
   }
   if(Response)  {
      free(Response);
   }
}

VOID
Message::  ReleaseResponse()
{
   if (Response)
      free(Response);
   Response = (CHAR *)NULL;
}


INT   Message::  Equal(RObj comp) const
{
   RMessage item = (RMessage)comp;
   if ( Id == item.getId() )
      return TRUE;
   return FALSE;
}


VOID
Message :: setSubmit(CHAR* submit)
{
   if(Submit)
      free(Submit);
   
   Submit = ((submit == (CHAR*)NULL) ? (CHAR*)NULL : _strdup(submit));
}

VOID
Message :: setValue(CHAR* value)
{
   if(Value)
      free(Value);
   
   Value = ((value == (CHAR*)NULL) ? (CHAR*)NULL : _strdup(value));
}

VOID
Message :: setCompare(CHAR* value)
{
   if(Compare)
      free(Compare);
   
   Compare = ((value == (CHAR*)NULL) ? (CHAR*)NULL : _strdup(value));
}

VOID
Message :: setResponse(CHAR* response)
{
   if(Response)
      free(Response);
   
   Response = ((response == (CHAR*)NULL) ? (CHAR*)NULL : _strdup(response));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ntcfgmgr.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy15Sep93: Use NT Registry for some stuff, then use our ini file
 *
 */

#ifndef _INC__NTCFGMGR_H
#define _INC__NTCFGMGR_H

#include "cfgmgr.h"

// Defines
//
_CLASSDEF(NTConfigManager)

class NTConfigManager : public IniConfigManager {
public:
    NTConfigManager();
    virtual ~NTConfigManager();
    
    virtual INT Get(INT, PCHAR);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\mutexnt.h ===
/*
 *
 * REVISIONS:
 *  pcy16Jul93: Added NT semaphores
 *  ash10Jun96: Cleaned up the class - overloaded the constructor
 *              and added logic to handle interprocess synchronization
 *
 */

#ifndef __MUTEXNT_H
#define __MUTEXNT_H

#include <tchar.h>
#include "mutexlck.h"

_CLASSDEF( ApcMutexLock )

class ApcMutexLock : public MutexLock 
{
 protected:
    HANDLE theSemHand;

 public:
    ApcMutexLock();
	ApcMutexLock(PCHAR aUniqueMutexName);
    ~ApcMutexLock();
    
	virtual INT   GetExistingMutex(TCHAR aMutexName);
    virtual INT   TimedRequest(LONG aMillisecondTimeOut);
    virtual INT   IsHeld();	
    virtual INT   Release();
    virtual INT   Wait();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\node.cxx ===
/*
 * REVISIONS:
 *  ash16Oct95: creation
 */




#ifdef SMARTHEAP 
#define DEFINE_NEW_MACRO 1 
#define MEM_DEBUG 1
#include <smrtheap.hpp>          
#endif

#include "cdefine.h"

#include "node.h"
#if !defined( __OBJECT_H)
#include "apcobj.h"
#endif


/* -------------------------------------------------------------------------
   Node::SetNext()
 
-------------------------------------------------------------------------  */

VOID Node::SetNext(PNode item)
{
    if (item)
    {
    	theNext = item;
    }
    else
    {
    	theNext = (PNode)NULL;
    }
}  



/* -------------------------------------------------------------------------
   Node::SetPrev()
 
-------------------------------------------------------------------------  */

VOID Node::SetPrev(PNode item)
{
    if (item)
    {
    	thePrev = item;
    }
    else
    {
    	thePrev = (PNode)NULL;
    }
}  


/* -------------------------------------------------------------------------
   Node::SetData()
 
-------------------------------------------------------------------------  */

VOID Node::SetData(PObj data)
{
    if (data)
    {
    	theData = data;
    }
    else
    {
    	theData = (PObj)NULL;
    }
}  


/* -------------------------------------------------------------------------
   Node::GetData()
 
-------------------------------------------------------------------------  */

PObj Node::GetData()
{
    if (theData)
    {
    	return theData;
    }
    else
    {
    	return (PObj)NULL;
    }
}  


/* -------------------------------------------------------------------------
   Node::GetNext()
 
-------------------------------------------------------------------------  */

PNode Node::GetNext()
{
    if (theNext)
    {
    	return theNext;
    }
    else
    {
    	return (PNode)NULL;
    }
}   


/* -------------------------------------------------------------------------
   Node::GetPrev()
 
-------------------------------------------------------------------------  */

PNode Node::GetPrev()
{
    if (thePrev)
    {
    	return thePrev;
    }
    else
    {
    	return (PNode)NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ntcfgmgr.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy15Sep93: Use NT Registry for some stuff, then use our ini file
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  ntf29Jan97: Add code to access PnP info on Windows '95
 *  ntf07Feb97: Changed ScanConfigurationRegistry to get port name
 *              from INI file if not available in registry.
 */

#include "cdefine.h"

extern "C" {
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
}

#include "apc.h"
#include "ntcfgmgr.h"
#include "err.h"

#include "upsreg.h"


/********************************************************************
 *
 * NTConfigManager methods
 *
 ********************************************************************/

//-------------------------------------------------------------------
// Constructor

NTConfigManager::NTConfigManager()
	  : IniConfigManager()
{
  _theConfigManager = this;
}


//-------------------------------------------------------------------
// Destructor

NTConfigManager::~NTConfigManager()
{
    _theConfigManager = (PConfigManager) NULL;
}


INT NTConfigManager::Get(INT itemCode, PCHAR aValue) 
{
    int err = ErrNO_ERROR;
    
    switch (itemCode) {
    case CFG_UPS_PORT_NAME:
        {
           // Moved to serport.cxx
        }
        break;

    case CFG_MESSAGE_DELAY:
    case CFG_MESSAGE_INTERVAL:
    case CFG_SHUTDOWN_SCRIPT: 
        {
            err = IniConfigManager::Get(itemCode,aValue);
            break;
        }

    default: 
        {
            err = IniConfigManager::Get(itemCode,aValue);
            break;
        }
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\node.h ===
/*
* REVISIONS:
*  pcy29Nov92: Changed object.h to apcobj.h
*
*  mwh05May94: #include file madness , part 2
*/


#ifndef __NODE_H
#define __NODE_H

#include "_defs.h"
#include "apc.h"

#if !defined( __OBJECT_H)
#include "apcobj.h"
#endif


_CLASSDEF(Node)

class Node : public Obj {
   
private:
   
   PNode    theNext;
   PNode    thePrev;
   PObj     theData;
   
   friend class DoubleList;
   friend class DoubleListIterator;
   friend class List;
   friend class ListIterator;
   
public:
   
   Node( PObj anObject, PNode aNode1 = (PNode)NULL,
      PNode aNode2 = (PNode)NULL ) :  theNext((PNode)NULL),
      thePrev((PNode)NULL)
   { theData = anObject; theNext = aNode1; thePrev = aNode2; };
   
   
   VOID    SetNext(PNode item);
   VOID    SetPrev(PNode item);
   VOID    SetData(PObj data);
   PObj    GetData();
   PNode   GetNext();
   PNode   GetPrev();
   
   virtual INT     IsA() const { return NODE; };
   virtual INT     Equal( RObj anObject ) const { return theData->Equal(anObject); };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ntsrvap.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy18Feb93: Spilt server app and client app to separate files
 *  TSC20May93: Changed VOID Start() to INT Start();
 *  awm14Jan98: Added performance monitor object
 *  mholly12May1999:  add UPSTurnOff method
 */

#ifndef _INC_NTSRVAP_H
#define _INC_NTSRVAP_H

#include "apc.h"
#include "servapp.h"

//
// Defines
//
_CLASSDEF(NTServerApplication);

//
// Interface uses
//
_CLASSDEF(Event)


class NTServerApplication : public ServerApplication
{
public:
    NTServerApplication(VOID);
    ~NTServerApplication(VOID);
    
    INT Start();
    VOID Idle();
    VOID Quit();

    VOID UPSTurnOff();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ntsrvap.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy18Feb93: Spilt server app and client app to separate files
 *  TSC20May93: Substituted nttimmn.* for os2timmn.*
 *  TSC28May93: Added defines for object pointers, see ntthrdbl.cxx for details
 *  pam04Apr96: Changed to accomodate CWC (nt timer manager)
 *  pam15Jul96: Added Sockets startup and shutdown
 *  pam15Jul96: Changed utils.h to w32utils.h
 *  awm14Jan98: Added performance monitor object and code to initialize it
 *  tjg29Jan98: Clean up if performance monitor object fails to start
 *  mds24Aug98: Set thePerformanceMonitors to NULL in constructor.  This stops
 *              back-end crash if the service is started without rengs.dll 
 *              file or pwrchute.ini file (SIR #7059)
 *  mholly12May1999:  add UPSTurnOff method
 */


#include "cdefine.h"

#include <windows.h>
#include "codes.h"
#include "nttimmn.h"
#include "ntsrvap.h"
#include "err.h"
#include "w32utils.h"


/*
  Name  :NTServerApplication
  Synop :The constructor for the main application object.

*/

NTServerApplication::NTServerApplication(VOID)
{
}


NTServerApplication::~NTServerApplication(VOID)
{
}


/*
  Name  :Start
  Synop :This starts the application running.
*/
INT NTServerApplication::Start()
{
    /* Construct the timer manager before the host object
       because it is needed when the host is constructed */
    _theTimerManager = theTimerManager = new NTTimerManager(this);

    // Construct everything before calling start on the parent class
    ServerApplication::Start();
    
    return (ErrNO_ERROR);
}


/*
  Name  :Idle
  Synop :Idle is called whenever idle time exists in the system.

*/
VOID NTServerApplication::Idle()
{
    Sleep((DWORD)2000);
}


/*
  Name  :Quit
  Synop :Quits the application immediately.

 */
VOID NTServerApplication::Quit()
{
	ServerApplication::Quit();
}


VOID NTServerApplication::UPSTurnOff()
{
    if (theDeviceController) {
        //
        // first stop the polling of the UPS
        //
        theDeviceController->Stop();
    }

    if (theTimerManager) {
        //
        // don't want the timermanager sending
        // anymore events
        //
        theTimerManager->Stop();
    }

    if (theDeviceController) {
        theDeviceController->Set(TURN_OFF_UPS_ON_BATTERY, NULL);
        Sleep(7000);
        theDeviceController->Set(TURN_OFF_SMART_MODE, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ntport.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  xxxddMMMyy
 *  TSC17May93: Added SmartSerialPort :: SYSTClosePort()
 *  TSC31May93: Added define for _theConfigManager, changed SmartSerialPort
 *              to native NT, added error logging
 *  srt28Mar96: Added plug-n-play cable support for simple.
 *  srt15Apr96: Added plug-n-play cable support for smart.
 *  pam04Apr96: Changed to accomodate CWC
 *  srl100696:  changed ExitWindowsEx to InitiateSystomShutdown to support clean shut down of 
 *	             mirrored drives
 *  srl100696:  commented out the lines to set pins high in simpleportwrite. This will keep 
 *              the (simple only) ups from shutting off before op. system has a chance to shut down.
 *  mds29Dec97: Set pins high in simple SYSTWriteToPort to correctly shutdown 
 *				    UPS when using a Share-Ups in Confirmed Mode
 *  tjg12Jan98: Fixed return code from SYSTWriteToPort (for TURN_OFF_UPS case)
 *
 *  v-stebe  29Jul2000   Fixed PREfix error (bug #112602)
 */

#include "cdefine.h"

extern "C" {
#include <stdlib.h>
#include <string.h>
#include <windows.h>
}

#include "_defs.h"
#include "serport.h"
#include "err.h"
#include "upsdev.h"
#include "cfgmgr.h"
#include "cfgcodes.h"
#include "codes.h"
#include "timerman.h"
#include "errlogr.h"
#include "utils.h"
extern "C"{
#include "upsreg.h"
}
#define ComMAXREADBUFSIZE       128
#define ComMAXWRITEBUFSIZE      128
#define ComMAXPORTNAMESIZE      10

#define INTERCHARACTER_DELAY    20      // Delay in msec between char writes

#define LOW_BATTERY_RETRYS  3
#define WRITEWAIT          50L
#define READWAIT           50L


INT  UpsCommDevice::CreatePort()
{
    CHAR szSignallingType[32];
    TCHAR szPortName[100];
    CHAR szPortType[32];
    INT err = ErrNO_ERROR;
    
    _theConfigManager->Get(CFG_UPS_SIGNALLING_TYPE, szSignallingType);
    _theConfigManager->Get(CFG_UPS_PORT_TYPE, szPortType);
    
	InitUPSConfigBlock();

	GetUPSConfigPort(szPortName);

    if (strcmp(szSignallingType, "Smart") == 0)
    {
        if (strcmp(szPortType, "Serial") == 0)
        {
            thePort = new SmartSerialPort(szPortName, theCableType);
        }
    }
    else if (strcmp(szSignallingType, "Simple") == 0)
    {
        if (strcmp(szPortType, "Serial") == 0)
        {
            //thePort = new SimpleSerialPort(szPortName);
        }
    }
    
    if (!thePort)
    {
        err = ErrINVALID_VALUE;
    }
    return err;
}

INT SmartSerialPort::SYSTOpenPort()
{
  INT err = ErrNO_ERROR;

    // If the port is already open, close it before trying to open it again
  if (FileHandle != INVALID_HANDLE_VALUE) {
      CloseHandle (FileHandle);
      FileHandle = INVALID_HANDLE_VALUE;
  }
    
    FileHandle = CreateFile(theSmartSerialPortName, 
                            GENERIC_READ | GENERIC_WRITE,
                            0, NULL, OPEN_EXISTING, 0,
                           NULL);

    if (FileHandle != INVALID_HANDLE_VALUE) {
      // If we get here, we have a good comm port handle
      DCB dcb;
    
      GetCommState(FileHandle, &dcb);
    
      // If here, a good handle and a filled-in dcb. So, set the comm params
      dcb.BaudRate = 2400;
      dcb.ByteSize = 8;
      dcb.Parity = NOPARITY;
      dcb.StopBits = ONESTOPBIT;
      dcb.EvtChar = '\n';
		  dcb.fOutxCtsFlow = FALSE;
		  dcb.fDtrControl = DTR_CONTROL_ENABLE;
    
	  if (theCableType == PNP) {
		  dcb.fRtsControl = RTS_CONTROL_DISABLE;
	  }
	  else {
		  dcb.fRtsControl = RTS_CONTROL_ENABLE;
	  }
      //ClearCommBreak(FileHandle);
      SetCommState(FileHandle, &dcb);

      SetCommMask(FileHandle, EV_RXFLAG);

      //
      // Set so we dont block\n
      //
      COMMTIMEOUTS wait_time;
      memset (&wait_time, 0, (DWORD) sizeof (COMMTIMEOUTS));
      wait_time.ReadTotalTimeoutMultiplier = 1L;
      wait_time.ReadTotalTimeoutConstant = (DWORD)0;
      SetCommTimeouts(FileHandle, &wait_time);
  
      CHAR buf[128]; 
      USHORT len = sizeof(buf);
  
      // Clear the port to avoid reading garbage
      while (SYSTReadFromPort(buf, (USHORT *) &len, 500L) == ErrNO_ERROR);  

      err = ErrNO_ERROR;
    }
    else {
      err = ErrOPEN_FAILED;
    }
    
    return err;
}


INT SmartSerialPort::SYSTWriteToPort(CHAR* lpszBuf)
{
    DWORD bytes_written;
    DWORD com_errors;
    COMSTAT com_status;

    INT err = ErrNO_ERROR;

    INT first_char = TRUE;

    while (*lpszBuf) {
        if(!first_char)  {
            Sleep(theWaitTime);
        }
        else {
            first_char = FALSE;
        }

        ClearCommError(FileHandle, &com_errors, &com_status);
        if(!WriteFile(FileHandle, lpszBuf, 1L, &bytes_written, NULL))  {
            err = ErrWRITE_FAILED;
            break;
        }

        lpszBuf++;
   }
    return(err);
}


INT SmartSerialPort::SYSTReadFromPort(PCHAR readbuf, USHORT* size,
                                      ULONG timeout)
{
    INT err = ErrNO_ERROR;

    DWORD com_errors;
    COMSTAT com_status;
    ClearCommError(FileHandle, &com_errors, &com_status);

    *size = 0;
    DWORD bytes_read = 0;
    Sleep(WRITEWAIT);
 
    ULONG time_slept = WRITEWAIT;
    while(TRUE)  {
        CHAR read_char;
        INT rval = ReadFile(FileHandle,(PVOID)&read_char, 1, &bytes_read, 
                            NULL);
        
        if(rval)  {
            if(bytes_read == 1)  {
                readbuf[*size] = read_char;
                (*size)++;
                if(read_char == '\n')  {
                    break;
                }
                
            }
            else {
                if(time_slept < timeout)  {
                    Sleep(READWAIT);
                    time_slept += READWAIT;
                }
                else {
                    err = ErrREAD_FAILED;
                    break;
                }
            }
        }
        else {
            err = ErrREAD_FAILED;
            break;
        }
    }
    readbuf[*size] = '\0';
    return err;
}


INT SmartSerialPort :: SYSTClosePort()
{
    CloseHandle (FileHandle);
    FileHandle = INVALID_HANDLE_VALUE;
    return (ErrNO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\nttimmn.h ===
/*
*
* NOTES:
*
* REVISIONS:
*  ane16Dec92: added NTTimerLoop class (named Os2TimerLoop class in os2timmn.h)
*  pcy28Jan93: Moved Loop obj to top to resolve refernce
*  TSC20May93: Created from os2timmn.h
*  pcy08Apr94: Trim size, use static iterators, dead code removal
*  tjg26Jan98: Added Stop method
*  mwh18Nov97: removed #include "MainApp.h"
*/

#ifndef _NTTIMMN_H
#define _NTTIMMN_H

#include <time.h>

#include "apc.h"
#include "_defs.h"
#include "err.h"
#include "apcobj.h"
#include "list.h"
#include "event.h"
#include "update.h"
#include "timerman.h"
#include "thread.h"

_CLASSDEF(EventTimer)
_CLASSDEF(DateTimeObj)
_CLASSDEF(DateObj)
_CLASSDEF(TimeObj)
_CLASSDEF(NTTimerManager)


class NTTimerLoop : public Threadable
{
   public:
       NTTimerLoop (PNTTimerManager aMgr);       
       virtual VOID ThreadMain();
       
   private:       
       PNTTimerManager theManager;
       
};

class NTTimerManager : public TimerManager
{
    
public:
    NTTimerManager(PMainApplication anApplication);
    virtual ~NTTimerManager();
    VOID Wait(ULONG MilliSecondDelay);
    VOID Stop();
    
    friend NTTimerLoop;
    
private:
    PThread theTimerThread;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\nttimmn.cxx ===
/*
*
* NOTES:
*
* REVISIONS:
*  ane16Dec92: added automatic kick off of timer thread and changed to use
*              threadable class
*  pcy16Jan93: TimerManager is now a second timer, not a msec timer (i hope
*              we dont have to change this back)
*  TSC20May93: Created from os2timmn.cxx
*  TSC28May93: Added defines, see ntthrdbl.cxx for details
*  pcy29May96: Reverted Wait back to Sleep since Peek/Post was using 100% CPU
*  srt21Oct96: Changed Wait to timedWait so thread could be exited faster
*  tjg26Jan98: Added Stop method
*
*  v-stebe  29Jul2000   Fixed PREfix errors (bug #46373)
*/

#include "cdefine.h"

#include <windows.h>

#include "apc.h"
#include "_defs.h"
#include "err.h"
#include "list.h"
#include "timerman.h"
#include "eventime.h"
#include "nttimmn.h"
#include "utils.h"

#undef GIVEUPCPU
#define GIVEUPCPU  2000
/*
C+
Name  :TimerManager
Synop :Constructor. INitializes the list.

*/

NTTimerManager::NTTimerManager(PMainApplication anApplication)
: TimerManager(anApplication)
//c-
{
    NTTimerLoop *timerLoop = new NTTimerLoop (this);
    theTimerThread = new Thread (timerLoop);

    if (theTimerThread != NULL) {
      theTimerThread->Start();
    }
}

/*
C+
Name  :~TimerManager
Synop :Destroys the internal list.

*/
NTTimerManager::~NTTimerManager()
//c-
{
    if (theTimerThread)
    {
        theTimerThread->ExitWait();
        delete theTimerThread;
        theTimerThread = NULL;
    }
} 


VOID  NTTimerManager:: Wait(ULONG aMilliSecondDelay)
{
    Sleep(aMilliSecondDelay);
}


VOID  NTTimerManager::Stop()
{
    if (theTimerThread) {
        theTimerThread->ExitWait();
        delete theTimerThread;
        theTimerThread = NULL;
    }
}



NTTimerLoop::NTTimerLoop (PNTTimerManager aMgr) : theManager(aMgr) 
{
    SetThreadName("NT Timer Loop");
}

VOID  NTTimerLoop::ThreadMain()
{
    while (ExitNow() == FALSE)
    {
        if (!theManager->ExecuteTimer()) {
#if (C_OS & C_NT)
            TimedWait(GIVEUPCPU);
#else
            theManager->Wait(GIVEUPCPU);
#endif
        }
    }    
    DoneExiting();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\protlist.cxx ===
/*
 *
 * NOTES:
 *
 *  ProtectedList:
 *
 *   Wraps the List class with a mutex lock. Each public method is
 *   protected first by accessing the mutex.  The entire list can
 *   be grabbed by using Access, ungrabbed by calling Release.
 *   You would want to Access the list almost always when using it,
 *   otherwise other threads could change the list without your
 *   knowledge, exactly what this class is trying to prevent
 *
 * REVISIONS:
 *  pcy29Nov92: Use PObj rather than PNode for return values
 *  pcy21Apr93: OS2 FE merge
 *  cad09Jul93: using new semaphores
 *  cad31Aug93: removing compiler warnings
 *  rct05Nov93: added NLM include files
 *  rct01Feb94: List no longer inherits from container
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  mwh08Apr97: add Access,Release methods & NOTES section
 */
#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

extern "C"
{
#if (C_OS & C_OS2)
#define INCL_DOSSEMAPHORES
#include <os2.h>
#endif
}

#include "protlist.h"

#if(C_OS & C_OS2)
 #include "mutexl2x.h"
#endif
#if (C_OS & C_NT)
#include "mutexnt.h"
#endif
#if (C_OS & C_NLM)
#include "nlmmutex.h"
#endif
#ifdef SINGLETHREADED
 #include "nullmutl.h"
#endif

ProtectedList::ProtectedList () : List(), accessLock((PMutexLock)NULL)
{
#ifdef SINGLETHREADED
   accessLock = new NullMutexLock();
#else
   accessLock = new ApcMutexLock();
#endif
}

ProtectedList::ProtectedList (ProtectedList* aProtectedList) : 
          List(aProtectedList), accessLock((PMutexLock)NULL)
{
#ifdef SINGLETHREADED
   accessLock = new NullMutexLock();
#else
   accessLock = new ApcMutexLock();
#endif

}

ProtectedList::~ProtectedList()
{
   Flush();
   delete accessLock;
   accessLock = NULL;
}

VOID ProtectedList :: Add (RObj elem)
{
   Request();
   List::Add(elem);
   Clear();
}

VOID ProtectedList :: Detach (RObj elem)
{
   Request();
   List::Detach(elem);
   Clear();
}

VOID ProtectedList :: Flush ()
{
   Request();
   List::Flush();
   Clear();
}

VOID ProtectedList :: FlushAll ()
{
   Request();
   List::FlushAll();
   Clear();
}


INT ProtectedList :: GetItemsInContainer () const
{
   Request();
   INT res = List::GetItemsInContainer();
   Clear();
   return res;
}

RListIterator ProtectedList :: InitIterator () const
{
   Request();
   RListIterator res = List::InitIterator();
   Clear();
   return res;
}

VOID ProtectedList :: Append (PObj elem)
{
   Request();
   List::Append(elem);
   Clear();
}

PObj ProtectedList :: GetHead ()
{
   Request();
   PObj res = List::GetHead();
   Clear();
   return res;
}


PObj ProtectedList :: Find (PObj elem)
{
   Request();
   PObj res = List::Find(elem);
   Clear();
   return res;
}

VOID ProtectedList :: Request () const
{
    accessLock->Request();
}

VOID ProtectedList :: Clear () const
{
    accessLock->Release();
}


/*  
   Use Access to lock the entire list object
   useful to block access completely to any other thread
   while one thread uses the list - don't forget to
   call Release when you're done - NOTE: although it
   is possible to still access this object w/o calling
   Access first, all of the public calls are protected
   by first trying to gain Access to the object first
*/  
VOID ProtectedList::Access() const
{
    Request();
}

VOID ProtectedList::Release() const
{
    Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ntthrd.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ane09DEC92: added code for rundown of threads
 *  ane30Dec92: increase stack size for threads
 *  TSC18May93: Removed os2 specific code, split off Threadable into ntthrdbl.cxx
 *  TSC20May93: Added error logging
 *  TSC28May93: Added define for theObject. See ntthrdbl.cxx for details
 *  pcy08Oct93: Removed redefinition of THREAD_EXIT_TIMEOUT
 *  cad24Nov93: defensive checks for deleteions
 *  pam02Apr96: changed CreateThread/TerminateThread to _beginthreadex and _endthreadex
 *  ash25Jun96: Removed dead code and added method to return the threadable object
 *  pam15Jul96: Changed utils.h to w32utils.h
 *  ash08Aug96: Added "new" handling capability to each thread
 *  dma17Apr98: Moved CloseHandle call to destructor to properly close threads.
 */
#include "cdefine.h"
#include "_defs.h"

#include <windows.h>
#include <process.h>

#include "apc.h"
#include "thread.h"
#include "apcsemnt.h"
#include "mutexnt.h"
#include "w32utils.h"

#include "err.h"

const int STACK_SIZE = 8192;

DWORD  BootstrapThread(LPDWORD PThread)
{
   Thread *thread = (Thread *)PThread;
   thread->RunMain();
   return ((DWORD) ErrNO_ERROR);
}

Thread::~Thread()
{
    if (theObject) 
    {
	delete theObject;
	theObject = NULL;
    }
    CloseHandle (theThreadHandle);
}

INT Thread::Start ()
{
    
    unsigned int thread_id;
    INT err;
    
    // Assume no error
    INT errReturn = ErrNO_ERROR;
    
    theThreadHandle = (HANDLE)_beginthreadex((VOID*)NULL, STACK_SIZE,
        (unsigned int (__stdcall *)(void *)) BootstrapThread,
        (VOID*)this, 0, &thread_id);
    
    // Do we have a valid thread?
    if (!theThreadHandle)
    {
        // Define the error
        errReturn = ErrTHREAD_CREATE_FAILED;
    }
    
    err = UtilSelectProcessor(theThreadHandle);
    return (errReturn);
}

VOID Thread::RunMain ()
{
    if (theObject != (PThreadable) NULL) {
        
        // Run the main member function of the threadable object
        theObject->ThreadMain();
    }
    
    
    // Kill the thread
    _endthreadex(0);
    
}


VOID Thread::TerminateThreadNow ()
{
    DWORD exit_code;
    GetExitCodeThread(theThreadHandle,&exit_code);
    
    // Terminate the thread
    if (exit_code == STILL_ACTIVE)
        TerminateThread (theThreadHandle, 0L);
    
    // Make sure
    WaitForSingleObject (theThreadHandle, INFINITE);
    
    // Close its handle
    CloseHandle (theThreadHandle);
    
    // Delete the Threadable object
    if (theObject != (PThreadable) NULL)
    {
        delete theObject;
        theObject = (PThreadable) NULL;
    }
    
}


PThreadable Thread::GetThreadableObject()
{
	return theObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\pollparm.h ===
/*
*  pcy29Nov92: Changed object.h to apcobj.h 
*  jod28Jan93: Added new Pollparams to support the Q command
*  ane03Feb93: Added destructors
*  jod05Apr93: Added changes for Deep Discharge
*  jod14May93: Added Matrix changes.
*  pcy14May93: Removed SIMPLE_SET, it's in types.h
*  cad10Jun93: Added mups parms
*  cad28Sep93: Made sure destructor(s) virtual
*  cad07Oct93: Plugging Memory Leaks
*  pcy08Apr94: Trim size, use static iterators, dead code removal
*  jps28aug94: shorted EepromAllowedValues and BattCalibrationCond for os2 1.3,
*              was causing link problems due to compiler truncation
*  djs22Feb96: added smart trim and increment poll params
*  djs07May96: Added Dark Star parameters
*  tjg03Dec97: Added CurrentLoadCapabilityPollParam and fixed bitmasks for
*              INPUT_BREAKER_TRIPPED, SYSTEM_FAN_FAILED and RIM_IN_CONTROL
*  mholly12May1999:  add TurnOffSmartModePollParam support
*/
#ifndef __POLLPARAM_H
#define __POLLPARAM_H

#include "_defs.h"

_CLASSDEF(List)

#include "apcobj.h"
#include "message.h"
#include "err.h"

#define NO_POLL         0
#define POLL         1

#define UPS_STATE_SET         3

#define REPLACEBATTERYMASK    128
#define LOWBATTERYMASK         64
#define OVERLOADMASK           32
#define ONBATTERYMASK          16
#define ONLINEMASK              8
#define SMARTBOOSTMASK          4
#define SMARTTRIMMASK           2
#define BATTERYCALIBRATIONMASK  1

#define ARMEDRECPSTANDBYMASK     128
#define RECEPTIVESTANDBYMASK      64
#define SWITCHEDBYPASSMASK        32
#define RETURNINGFROMBYPASSMASK   16
#define COMPSELECTBYPASSMASK       8
#define ENTERINGBYPASSMASK         4
#define UNDEFINEDMASK              2
#define WAKEUPMASK                 1

#define OVERTEMPMASK             128
#define BYPASSRELAYMASK           64
#define BATTERYCHARGERMASK        32

#define BYPASSDCIMBALANCEMASK      16
#define BYPASSOUTPUTLIMITSMASK     8
#define BYPASSPOWERSUPPLYMASK      4
#define BOTTOMFANFAILUREMASK       2
#define TOPFANFAILUREMASK          1

#define VARIABLE_LENGTH_RESPONSE    0

// Abnormal condition masks
const int FAILED_UPS_MASK              =      1;
const int IM_FAILED_MASK               =      2;
const int RIM_FAILED_MASK              =      4;
const int REDUNDANCY_FAILED_MASK       =     64;
const int BYPASS_STUCK_IN_BYPASS_MASK  =    256;
const int BYPASS_STUCK_IN_ONLINE_MASK  =    512; 
const int BYPASS_STUCK_MASK            =   BYPASS_STUCK_IN_BYPASS_MASK + BYPASS_STUCK_IN_ONLINE_MASK;
const int INPUT_BREAKER_TRIPPED_MASK   =   8192; 
const int SYSTEM_FAN_FAILED_MASK       =  16384;
const int RIM_IN_CONTROL_MASK          =  32768;


_CLASSDEF(PollParam)

class PollParam : public Obj {
   
protected:
   
   PCHAR    Command;
   INT      RequestTime;
   Type     SetType;
   INT      ID;
   INT      Pollable;
   
public:
   
   PollParam(INT id, CHAR* query, INT time, INT poll, Type type=(Type)NULL);
   virtual ~PollParam();
   
   virtual INT    ProcessValue(PMessage value, List* events=(List*)NULL) = 0;
   PCHAR          Query();
   INT            GetTime() {return RequestTime;}
   INT            GetID() {return ID;}
   Type           GetSetType() {return SetType;}
   INT            isPollable() {return Pollable;}
   VOID           SetSetType(Type type) {SetType = type;}
   INT            Equal( RObj item) const;
   virtual INT  IsA() const {return POLLPARAM;}
   virtual INT    IsPollSet() {return ErrNO_ERROR;};
};


class SimplePollParam : public PollParam {
   
public:
   SimplePollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   PollParam(id,query,time,poll,type) {};
   
   
   INT   ProcessValue(PMessage , List* ) {return 0;}   // This function is empty
};


class SmartPollParam : public PollParam {
   
protected:
   
   USHORT  theCurrentState;
   INT theResponseLength;
   INT ResponseLength();
   
public:
   
   SmartPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL, INT aResponseLength = 0) :
   PollParam(id,query,time,poll,type),
      theCurrentState(0), theResponseLength(aResponseLength) {};
   
   
   INT   ProcessValue(PMessage, PList);
   INT   NullTest(CHAR* value);
};

class SmartModePollParam : public SmartPollParam
{
public:
   SmartModePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class TurnOffSmartModePollParam : public SmartPollParam
{
public:
    TurnOffSmartModePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {};
   INT ProcessValue(PMessage value, List* events);
};


class LightsTestPollParam : public SmartPollParam
{
public:
   LightsTestPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class TurnOffAfterDelayPollParam : public SmartPollParam
{
public:
   TurnOffAfterDelayPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class ShutdownPollParam : public SmartPollParam
{
public:
   ShutdownPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class SimulatePowerFailurePollParam : public SmartPollParam
{
public:
   SimulatePowerFailurePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class BatteryTestPollParam : public SmartPollParam
{
public:
   BatteryTestPollParam(INT id, CHAR* query, INT time, INT poll,  
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class TurnOffUpsPollParam : public SmartPollParam
{
public:
   TurnOffUpsPollParam(INT id, CHAR* query, INT time, INT poll,  
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class ShutdownWakeupPollParam : public SmartPollParam
{
public:
   ShutdownWakeupPollParam(INT id, CHAR* query, INT time, INT poll,  
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class BatteryCalibrationPollParam : public SmartPollParam
{
public:
   BatteryCalibrationPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class BatteryTestResultsPollParam : public SmartPollParam
{
public:
   BatteryTestResultsPollParam(INT id, CHAR* query, INT time, INT poll,  
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class TransferCausePollParam : public SmartPollParam
{
public:
   TransferCausePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 1) {}
   INT   ProcessValue(PMessage value, List* events);
};

class FirmwareVersionPollParam : public SmartPollParam
{
public:
   FirmwareVersionPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, VARIABLE_LENGTH_RESPONSE) {}
};

class RunTimeAfterLowBatteryPollParam : public SmartPollParam
{
public:
   RunTimeAfterLowBatteryPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
};

class FrontPanelPasswordPollParam : public SmartPollParam
{
public:
   FrontPanelPasswordPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 4) {}
};

class BatteryTypePollParam : public SmartPollParam
{
public:
   BatteryTypePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class LineConditionPollParam : public SmartPollParam
{
public:
   LineConditionPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type) {}
   INT   ProcessValue(PMessage value, List* events);
};

class BatteryCapacityPollParam : public SmartPollParam
{
public:
   BatteryCapacityPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};



class TripRegisterPollParam : public SmartPollParam
{
protected:
   static  USHORT  thePollSet;
   
public:
   TripRegisterPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2)
   { theCurrentState = 0;}
   virtual ~TripRegisterPollParam() { thePollSet = FALSE; }
   INT             ProcessValue(PMessage value, List* events);
   virtual INT     IsPollSet();
};


class Trip1RegisterPollParam : public SmartPollParam
{
protected:
   static  USHORT  thePollSet;
   
public:
   Trip1RegisterPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2)
   { theCurrentState = 0;}
   virtual ~Trip1RegisterPollParam() { thePollSet = FALSE; }
   INT             ProcessValue(PMessage value, List* events);
   virtual INT     IsPollSet();
};


class StateRegisterPollParam : public SmartPollParam
{
protected:
   static  USHORT  thePollSet;
   
public:
   StateRegisterPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2)
   { theCurrentState = 0;}
   virtual ~StateRegisterPollParam() { thePollSet = FALSE; }
   INT             ProcessValue(PMessage value, List* events);
   virtual INT     IsPollSet();
};


class DipSwitchPollParam : public SmartPollParam
{
public:
   DipSwitchPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class RuntimeRemainingPollParam : public SmartPollParam
{
public:
   RuntimeRemainingPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

class CopyrightPollParam : public SmartPollParam
{
public:
   CopyrightPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 8) {}
   INT   ProcessValue(PMessage value, List* events);
};

class BatteryVoltagePollParam : public SmartPollParam
{
public:
   BatteryVoltagePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

class InternalTempPollParam : public SmartPollParam
{
public:
   InternalTempPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

class OutputFreqPollParam : public SmartPollParam
{
public:
   OutputFreqPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

class LineVoltagePollParam : public SmartPollParam
{
public:
   LineVoltagePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

class MaxVoltagePollParam : public SmartPollParam
{
public:
   MaxVoltagePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

class MinVoltagePollParam : public SmartPollParam
{
public:
   MinVoltagePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

class OutputVoltagePollParam : public SmartPollParam
{
public:
   OutputVoltagePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

class LoadPowerPollParam : public SmartPollParam
{
public:
   LoadPowerPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};

#if (C_OS & C_OS2)
class EepromAllowedValsPollParam : public SmartPollParam
#else
class EepromAllowedValuesPollParam : public SmartPollParam
#endif
{
public:
#if (C_OS & C_OS2)
   EepromAllowedValsPollParam(INT id, CHAR* query, INT time, INT poll,
#else
      EepromAllowedValuesPollParam(INT id, CHAR* query, INT time, INT poll,
#endif
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type) {}
   INT   ProcessValue(PMessage value, List* events);
};


class DecrementPollParam : public SmartPollParam
{
public:
   DecrementPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type) {}
   INT   ProcessValue(PMessage value, List* events);
};


class IncrementPollParam : public SmartPollParam
{
public:
   IncrementPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type) {}
   INT   ProcessValue(PMessage value, List* events);
};

class DataDecrementPollParam : public SmartPollParam
{
public:
   DataDecrementPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
};

class AutoSelfTestPollParam : public SmartPollParam
{
public:
   AutoSelfTestPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class UpsIdPollParam : public SmartPollParam
{
public:
   UpsIdPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 8) {}
   INT   ProcessValue(PMessage value, PList events);
};

class SerialNumberPollParam : public SmartPollParam
{
public:
   SerialNumberPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, VARIABLE_LENGTH_RESPONSE) {}
};

class ManufactureDatePollParam : public SmartPollParam
{
public:
   ManufactureDatePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 8) {}
};

class UpsModelPollParam : public SmartPollParam
{
public:
   UpsModelPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 
      VARIABLE_LENGTH_RESPONSE) {}
};

class UpsNewFirmwareRev : public SmartPollParam
{
public:
   UpsNewFirmwareRev(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 
      VARIABLE_LENGTH_RESPONSE) {}
};


class BatteryReplaceDatePollParam : public SmartPollParam
{
public:
   BatteryReplaceDatePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 8) {}
   INT   ProcessValue(PMessage value, PList events);
};

class HighTransferPollParam : public SmartPollParam
{
public:
   HighTransferPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class LowTransferPollParam : public SmartPollParam
{
public:
   LowTransferPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class MinCapacityPollParam : public SmartPollParam
{
public:
   MinCapacityPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
};

class RatedOutputVoltagePollParam : public SmartPollParam
{
public:
   RatedOutputVoltagePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class SensitivityPollParam : public SmartPollParam
{
public:
   SensitivityPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 1) {}
};

class LowBattDurationPollParam : public SmartPollParam
{
public:
   LowBattDurationPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
};

class AlarmDelayPollParam : public SmartPollParam
{
public:
   AlarmDelayPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 1) {}
};

class ShutdownDelayPollParam : public SmartPollParam
{
public:
   ShutdownDelayPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class TurnBackOnDelayPollParam : public SmartPollParam
{
public:
   TurnBackOnDelayPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class EarlyTurnOffPollParam : public SmartPollParam
{
public:
   EarlyTurnOffPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
};


class UPSStatePollParam : public SmartPollParam
{
protected:
   static  USHORT  thePollSet;
   
public:
   UPSStatePollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2)
   { theCurrentState = ONLINEMASK;}
   virtual ~UPSStatePollParam() { thePollSet = FALSE; }
   INT             ProcessValue(PMessage value, List* events);
   virtual INT     IsPollSet();
};

class UtilLineCondPollParam : public UPSStatePollParam
{
public:
   UtilLineCondPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   UPSStatePollParam(id,query, time, poll, type)
   { theCurrentState = ONLINEMASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class ReplaceBattCondPollParam : public UPSStatePollParam
{
public:
   ReplaceBattCondPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   UPSStatePollParam(id,query, time, poll, type)
   { theCurrentState = REPLACEBATTERYMASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class BatteryCondPollParam : public UPSStatePollParam
{
public:
   BatteryCondPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   UPSStatePollParam(id,query, time, poll, type)
   { theCurrentState = ONBATTERYMASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class OverLoadCondPollParam : public UPSStatePollParam
{
public:
   OverLoadCondPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   UPSStatePollParam(id,query, time, poll, type)
   { theCurrentState = OVERLOADMASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class SmartBoostCondPollParam : public UPSStatePollParam
{
public:
   SmartBoostCondPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   UPSStatePollParam(id,query, time, poll, type)
   { theCurrentState = SMARTBOOSTMASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class SmartTrimCondPollParam : public UPSStatePollParam
{
public:
   SmartTrimCondPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   UPSStatePollParam(id,query, time, poll, type)
   { theCurrentState = SMARTTRIMMASK; }
   INT             ProcessValue(PMessage value, List* events);
};


#if (C_OS & C_OS2)
class BattCalibrateCondPollParam : public UPSStatePollParam
#else
class BattCalibrationCondPollParam : public UPSStatePollParam
#endif
{
public:
#if (C_OS & C_OS2)
   BattCalibrateCondPollParam(INT id, CHAR* query, INT time, INT poll,
#else
      BattCalibrationCondPollParam(INT id, CHAR* query, INT time, INT poll, 
#endif
      Type type=(Type)NULL) :
   UPSStatePollParam(id,query, time, poll, type)
   { theCurrentState = BATTERYCALIBRATIONMASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class AbnormalCondPollParam : public SmartPollParam
{
protected:
   static  USHORT  thePollSet;
   
public:
   AbnormalCondPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2)
   { theCurrentState = FAILED_UPS_MASK;}
   virtual ~AbnormalCondPollParam() { thePollSet = FALSE; }
   INT             ProcessValue(PMessage value, List* events);
   virtual INT     IsPollSet();
};

class  UPSModuleStatusPollParam : public AbnormalCondPollParam {
public:
   UPSModuleStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   AbnormalCondPollParam(id,query, time, poll, type)
   { theCurrentState = FAILED_UPS_MASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class  IMStatusPollParam : public AbnormalCondPollParam {
public:
   IMStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   AbnormalCondPollParam(id,query, time, poll, type)
   { theCurrentState = IM_FAILED_MASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class  IMInstallationStatusPollParam : public AbnormalCondPollParam {
public:
   IMInstallationStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   AbnormalCondPollParam(id,query, time, poll, type)
   { theCurrentState = IM_FAILED_MASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class  RIMStatusPollParam : public AbnormalCondPollParam {
public:
   RIMStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   AbnormalCondPollParam(id,query, time, poll, type)
   { theCurrentState = RIM_FAILED_MASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class RedundancyConditionPollParam : public AbnormalCondPollParam {
public:
   RedundancyConditionPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   AbnormalCondPollParam(id,query, time, poll, type)
   { theCurrentState = REDUNDANCY_FAILED_MASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class BypassContactorStatusPollParam : public AbnormalCondPollParam {
public:
   BypassContactorStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   AbnormalCondPollParam(id,query, time, poll, type)
   { theCurrentState = BYPASS_STUCK_MASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class InputBreakerTrippedStatusPollParam : public AbnormalCondPollParam {
public:
   InputBreakerTrippedStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   AbnormalCondPollParam(id,query, time, poll, type)
   { theCurrentState = INPUT_BREAKER_TRIPPED_MASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class SystemFanStatusPollParam : public AbnormalCondPollParam {
public:
   SystemFanStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   AbnormalCondPollParam(id,query, time, poll, type)
   { theCurrentState = SYSTEM_FAN_FAILED_MASK; }
   INT             ProcessValue(PMessage value, List* events);
};

class ModuleCountsStatusPollParam : public SmartPollParam
{
protected:
   static  USHORT  thePollSet;
public:
   ModuleCountsStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2)
   { theCurrentState = 0;}
   virtual ~ModuleCountsStatusPollParam() { thePollSet = FALSE; }
   INT             ProcessValue(PMessage value, List* events);
   virtual INT     IsPollSet();
};

class NumberInstalledInvertersPollParam : public ModuleCountsStatusPollParam {
public:
   NumberInstalledInvertersPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   ModuleCountsStatusPollParam (id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class NumberBadInvertersPollParam : public ModuleCountsStatusPollParam {
public:
   NumberBadInvertersPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   ModuleCountsStatusPollParam (id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class RedundancyLevelPollParam : public ModuleCountsStatusPollParam {
public:
   RedundancyLevelPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   ModuleCountsStatusPollParam (id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class MinimumRedundancyPollParam : public ModuleCountsStatusPollParam {
public:
   MinimumRedundancyPollParam (INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   ModuleCountsStatusPollParam (id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class CurrentLoadCapabilityPollParam : public ModuleCountsStatusPollParam {
public:
   CurrentLoadCapabilityPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   ModuleCountsStatusPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class MaximumLoadCapabilityPollParam : public ModuleCountsStatusPollParam {
public:
   MaximumLoadCapabilityPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   ModuleCountsStatusPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class RIMInstallationStatusPollParam : public ModuleCountsStatusPollParam {
public:
   RIMInstallationStatusPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   ModuleCountsStatusPollParam (id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class InputVoltageFrequencyPollParam : public SmartPollParam
{
protected:
   static  USHORT  thePollSet;
public:
   InputVoltageFrequencyPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2)
   { theCurrentState = 0;}
   virtual ~InputVoltageFrequencyPollParam() { thePollSet = FALSE; }
   INT             ProcessValue(PMessage value, List* events);
   virtual INT     IsPollSet();
};

class PhaseAInputVoltagePollParam : public  InputVoltageFrequencyPollParam{
public:
   PhaseAInputVoltagePollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   InputVoltageFrequencyPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class PhaseBInputVoltagePollParam : public  InputVoltageFrequencyPollParam{
public:
   PhaseBInputVoltagePollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   InputVoltageFrequencyPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class PhaseCInputVoltagePollParam : public  InputVoltageFrequencyPollParam{
public:
   PhaseCInputVoltagePollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   InputVoltageFrequencyPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};


class InputFrequencyPollParam : public  InputVoltageFrequencyPollParam{
public:
   InputFrequencyPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   InputVoltageFrequencyPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};
class NumberOfInputPhasesPollParam : public  InputVoltageFrequencyPollParam{
public:
   NumberOfInputPhasesPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   InputVoltageFrequencyPollParam (id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};
class OutputVoltageCurrentsPollParam : public SmartPollParam
{
protected:
   static  USHORT  thePollSet;
public:
   OutputVoltageCurrentsPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2)
   { theCurrentState = 0;}
   virtual ~OutputVoltageCurrentsPollParam() { thePollSet = FALSE; }
   INT             ProcessValue(PMessage value, List* events);
   virtual INT     IsPollSet();
};

class PhaseAOutputVoltagePollParam : public OutputVoltageCurrentsPollParam {
public:
   PhaseAOutputVoltagePollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   OutputVoltageCurrentsPollParam (id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class PhaseBOutputVoltagePollParam : public  OutputVoltageCurrentsPollParam{
public:
   PhaseBOutputVoltagePollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   OutputVoltageCurrentsPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class PhaseCOutputVoltagePollParam : public OutputVoltageCurrentsPollParam {
public:
   PhaseCOutputVoltagePollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   OutputVoltageCurrentsPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};
class NumberOfOutputPhasesPollParam : public OutputVoltageCurrentsPollParam {
public:
   NumberOfOutputPhasesPollParam(INT id, CHAR* query, INT time, INT poll, 
      Type type=(Type)NULL) :
   OutputVoltageCurrentsPollParam(id,query, time, poll, type)
   { theCurrentState = 0; }
   INT             ProcessValue(PMessage value, List* events);
};

class NumberBatteryPacksPollParam : public SmartPollParam
{
public:
   NumberBatteryPacksPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class NumberBadBatteryPacksPollParam : public SmartPollParam
{
public:
   NumberBadBatteryPacksPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
};

class FanFailurePollParam : public Trip1RegisterPollParam
{
public:
   FanFailurePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   Trip1RegisterPollParam(id,query, time, poll, type) {}
   INT   ProcessValue(PMessage value, List* events);
};


class BypassPowerSupplyPollParam : public Trip1RegisterPollParam
{
public:
   BypassPowerSupplyPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   Trip1RegisterPollParam(id,query, time, poll, type) {}
   INT   ProcessValue(PMessage value, List* events);
};

class BypassModePollParam : public TripRegisterPollParam
{
public:
   BypassModePollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   TripRegisterPollParam(id,query, time, poll, type) {}
   INT   ProcessValue(PMessage value, List* events);
};

class MUpsTempPollParam : public SmartPollParam
{
public:
   MUpsTempPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};



class MUpsHumidityPollParam: public SmartPollParam
{
public:
   MUpsHumidityPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 5) {}
   INT   ProcessValue(PMessage value, List* events);
};


class MUpsContactPosPollParam: public SmartPollParam
{
public:
   MUpsContactPosPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 2) {}
   INT   ProcessValue(PMessage value, List* events);
};

class MUpsFirmwareRevPollParam: public SmartPollParam
{
public:
   MUpsFirmwareRevPollParam(INT id, CHAR* query, INT time, INT poll,
      Type type=(Type)NULL) :
   SmartPollParam(id,query, time, poll, type, 3) {}
   INT   ProcessValue(PMessage value, List* events);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\pollparm.cxx ===
/*
*
* NOTES:
*
* REVISIONS:
*  pcy29Nov92: Used new defines from codes.h to fix 32 char name limit
*  jod28Jan93: Added new Pollparams to support the Q command
*  pcy02Jan93: Made sure all functions return values
*  ane03Feb93: Added destructors
*  pcy16Feb93: Move UPS_STATE_SET define to err.h to avoid conflicts
*  pcy16Feb93: Correctly declare static class member thePollSet
*  pcy16Feb93: Fix handling of UPS_STATE_SET so UpsState params are pollable
*  pcy16Feb93: Fix Q command handling so all bits generate events
*  pcy16Feb93: Put codes for battery test results in response
*  pcy16Feb93: Convert run time remaining to seconds
*  jod05Apr93: Added changes for Deep Discharge
*  jod14May93: Added Matrix changes.
*  pcy21May93: Moved define of NO_RECENT_TEST to codes.h
*  cad10Jun93: Added mups parms, fixed pontential bugs
*  cad23Jun93: made sure state was known-sized type
*  pcy15Sep93: Change dipswitch value from hex to int before returning
*  pcy24Sep93: Convert upslink responses to 9 command to codes
*  cad07Oct93: Plugging Memory Leaks
*  ajr17Feb94: Added some checking to see if getValue returns NULL 
*  ajr09Mar94: Added some checking to see if getValue returns NULL 
*  ajr20Jul94: Made sure we cleared eepromValues between usages. prevent core
*  jps28aug94: shorten EepromAllowedValues and BattCalibrationCond to prevent
*              link problems in os2 1.3
*  djs14Jun95: Added additional event to Smart Boost Off condition.
*  djs22Feb96: Added Smart Trim and IncrementPollParm
*  djs07May96: Added Dark Star parameters
*  pav22May96: Added init of DS statics, aded INT as return value of DS IsPollSet
*  srt23May96: Checking return of sscanf in EepromAllowedValuesPollParam::ProcessValue
*  tjg03Dec97: 1. Updated ModuleCountsandStatusPollParam (and all inherited 
*                 pollparams) to check for NA response before processing.
*              2. Revamped AbnormalConditionPollParam to ensure it generates
*                 all possible events.
*              3. Added CurrentLoadCapabilityPollParam
*              4. Updated RimInstallationStatusPollParam to report PC+ code 
*                 RIM_INSTALLED/RIM_NOT_INSTALLED instead of Y/N.
*  tjg02Mar98: BATTERY_DOESNT_NEED_REPLACING is now reported for each poll
*  mds31Jul98: In NullTest(), check value before performing a strlen on it
*  mholly12May1999:  add TurnOffSmartModePollParam support
*
*  v-stebe  29Jul2000   Fixed PREfix errors (bugs #46337-#46341, #112598-#112609)
*  v-stebe  05Sep2000   Fixed additional PREfix errors
*/

#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
}

#include "_defs.h"
#include "apc.h"
#include "ulinkdef.h"
#include "list.h"
#include "pollparm.h"
#include "codes.h"
#include "event.h"
#include "utils.h"
#include "err.h"



//  Static member of UPSStatePollParam initialization
USHORT  UPSStatePollParam::thePollSet = 0;
USHORT  StateRegisterPollParam::thePollSet = 0;
USHORT  TripRegisterPollParam::thePollSet = 0;
USHORT  Trip1RegisterPollParam::thePollSet = 0;
USHORT  AbnormalCondPollParam::thePollSet = 0;
USHORT  ModuleCountsStatusPollParam::thePollSet = 0;
USHORT  InputVoltageFrequencyPollParam::thePollSet = 0;
USHORT  OutputVoltageCurrentsPollParam::thePollSet = 0;

PollParam :: PollParam(INT id, CHAR* query, INT time, INT poll, Type type)
: Command(NULL), ID(id), SetType(type), RequestTime(time), Pollable(poll)
{
   if (Command)
   {
      free(Command);
      Command = NULL;
   }
   if (query)
   {
      Command = _strdup(query);
   }
   else
   {
      Command = (CHAR*)NULL;
   }
}


PollParam::~PollParam()
{
   if (Command) free(Command);
}


CHAR* PollParam::   Query()
{
   if (Command)
      return _strdup(Command);
   return (CHAR*)NULL;
}

INT PollParam::   Equal(RObj comp) const
{
   RPollParam item = (RPollParam)comp;
   if ( ID == item.GetID() )
      return TRUE;
   
   return FALSE;
}

INT SmartPollParam::ResponseLength()
{
   return theResponseLength;
}

INT SmartPollParam::ProcessValue(PMessage value, PList eventList)
{
   INT rval = ErrBAD_RESPONSE_VALUE;
   PCHAR response = value->getResponse();
   if (response) {
      if ((ResponseLength() == VARIABLE_LENGTH_RESPONSE) ||
         (strlen(response) == (size_t) ResponseLength()))
          rval=ErrNO_ERROR;
   }
   return rval;
}

INT SmartPollParam ::  NullTest(CHAR* value)
{
   if (value || strlen(value))
      return FALSE;
   
   return TRUE;
}

INT  UPSStatePollParam:: IsPollSet()
{
   if (!thePollSet)
   {
      thePollSet = TRUE;
      return ErrUPS_STATE_SET;
   }
   return ErrSAME_VALUE;
}

INT UPSStatePollParam::  ProcessValue(PMessage value, List* events)
{
   int  err = ErrCONTINUE;
   
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (!events) {
      return ErrNO_VALUE;
   }
   USHORT cur_state = 0;
   
   if (sscanf(value->getResponse(),"%x",&cur_state) == EOF) {
      return ErrREAD_FAILED;
   }
   
   INT battery_calibration_in_progress = FALSE;
   if ( BATTERYCALIBRATIONMASK & cur_state)
   {
      PEvent tmp = new Event(BATTERY_CALIBRATION_CONDITION,
         BATTERY_CALIBRATION_IN_PROGRESS);
      battery_calibration_in_progress = TRUE;
      events->Append(tmp);
   }
   else if (BATTERYCALIBRATIONMASK & theCurrentState)
   {
      PEvent tmp = new Event(BATTERY_CALIBRATION_CONDITION,
         NO_BATTERY_CALIBRATION_IN_PROGRESS);
      events->Append(tmp);                
   }
   if ( ONBATTERYMASK & cur_state )
   {
      if (! battery_calibration_in_progress)
      {
         PEvent tmp = new Event(UTILITY_LINE_CONDITION, LINE_BAD);
         events->Append(tmp);
      }
   }
   if ( ONLINEMASK & cur_state )
   {
      PEvent tmp = new Event(UTILITY_LINE_CONDITION, LINE_GOOD);
      events->Append(tmp);
   }
   if ( LOWBATTERYMASK & cur_state )
   {
      PEvent tmp = new Event(BATTERY_CONDITION, BATTERY_BAD);
      events->Append(tmp);
   }
   else if (LOWBATTERYMASK & theCurrentState)
   {
      PEvent tmp = new Event(BATTERY_CONDITION, BATTERY_GOOD);
      events->Append(tmp);
   }
   if ( REPLACEBATTERYMASK & cur_state )
   {
      PEvent tmp = new Event(BATTERY_REPLACEMENT_CONDITION,
         BATTERY_NEEDS_REPLACING);
      events->Append(tmp);
   }
   else if (REPLACEBATTERYMASK & theCurrentState)
   {
      PEvent tmp = new Event(BATTERY_REPLACEMENT_CONDITION,
         BATTERY_DOESNT_NEED_REPLACING);
      
      events->Append(tmp);
   }
   if ( OVERLOADMASK & cur_state )
   {
      PEvent tmp = new Event(OVERLOAD_CONDITION, UPS_OVERLOAD);
      events->Append(tmp);
   }
   else if (OVERLOADMASK & theCurrentState)
   {
      PEvent tmp = new Event(OVERLOAD_CONDITION, NO_UPS_OVERLOAD);
      events->Append(tmp);
   }
   if ( SMARTBOOSTMASK & cur_state )
   {
      PEvent tmp = new Event(SMART_BOOST_STATE, SMART_BOOST_ON);
      events->Append(tmp);
   }
   else if (SMARTBOOSTMASK & theCurrentState)
   {
      PEvent tmp = new Event(SMART_BOOST_STATE, SMART_BOOST_OFF);
      events->Append(tmp);
   }
   if ( SMARTTRIMMASK & cur_state )
   {
      PEvent tmp = new Event(SMART_TRIM_STATE, SMART_TRIM_ON);
      events->Append(tmp);
   }
   else if (SMARTTRIMMASK & theCurrentState)
   {
      PEvent tmp = new Event(SMART_TRIM_STATE, SMART_TRIM_OFF);
      events->Append(tmp);
   }
   
   //  if ( UPSSHUTDOWNMASK & cur_state )            // Bitwise OR
   //  {
   //     PEvent tmp = new Event(UPS_STATE, UPS_SHUTDOWN);
   //     events->Append(tmp);
   //  }
   //  else if (UPSSHUTDOWNMASK & theCurrentState)
   //  {
   //     PEvent tmp = new Event(UPS_STATE, UPS_NOT_SHUTDOWN);
   //     events->Append(tmp);
   //  }
   
   theCurrentState = cur_state;
   
   //
   // Convert value from HEX to decimal for every one else
   //
   CHAR int_value[32];
   sprintf(int_value, "%d", cur_state);
   value->setResponse(int_value);
   
   return err;
}

INT AbnormalCondPollParam:: IsPollSet()
{
   if (!thePollSet)
   {
      thePollSet = TRUE;
      return ErrABNORMAL_CONDITION_SET;
   }
   return ErrSAME_VALUE;
}

INT AbnormalCondPollParam::  ProcessValue(PMessage value, List* events)
{
   int  err = ErrNO_ERROR;
   
   // Check for NULL
   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }

   else if ((_strcmpi(value->getResponse(), "NA") == 0) || !events) {
	   err = ErrNO_VALUE;
   }
   
   // If everything checks out OK
   if (err == ErrNO_ERROR) 
   {
      USHORT condition = 0;
      
      if (sscanf(value->getResponse(),"%x",&condition) == EOF) {
        err = ErrREAD_FAILED;
      }

      // Check if RIM is in control
      if (RIM_IN_CONTROL_MASK & condition) {

         // If the RIM is in control, we know its current status is OK
         PEvent rim_ok_event = new Event(RIM_STATUS, RIM_OK);
         events->Append(rim_ok_event);

         // If so, check the IM failed bit.  If the IM_FAILED bit is set, 
         // the IM is installed and has failed.
         if (IM_FAILED_MASK & condition) {
            PEvent im_installed_event = new Event(IM_INSTALLATION_STATE, IM_INSTALLED);
            PEvent im_failed_event = new Event(IM_STATUS, IM_FAILED);
            events->Append(im_failed_event);
            events->Append(im_installed_event);
         }
         // If the RIM is in control and the IM failed bit is not set, then
         // the IM is not installed.
         else {
            PEvent im_not_installed_event = new Event(IM_INSTALLATION_STATE, IM_NOT_INSTALLED);
            events->Append(im_not_installed_event);
         }
      }
      // If RIM is not in control, IM must be in control
      else {
         // Since IM is in control, its current state must be OK
         PEvent im_ok_event = new Event(IM_STATUS, IM_OK);
         PEvent im_installed_event = new Event(IM_INSTALLATION_STATE, IM_INSTALLED);
         
         events->Append(im_ok_event);
         events->Append(im_installed_event);

         // Check if the RIM has failed ... NOTE that the RIM_INSTALLATION_STATE
         // events will be generated by the ModuleCountsStatusPollParam
         if (RIM_FAILED_MASK & condition) {
            PEvent rim_failed_event = new Event(RIM_STATUS, RIM_FAILED);
            events->Append(rim_failed_event);
         }
         else {
            PEvent rim_ok_event = new Event(RIM_STATUS, RIM_OK);
            events->Append(rim_ok_event);
         }
      }

      // Check to see if any UPS modules have failed.  NOTE: the else is not
      // handled because we do not generate the UPS_MODULE_OK event ... this
      // condition is handled by the UPS module removed and added sequence.
      // (Bad modules must be removed before they will be OK again)
      if (FAILED_UPS_MASK & condition) {
         PEvent ups_module_failed_event = new Event(UPS_MODULE_FAILED, UPS_MODULE_FAILED);
         events->Append(ups_module_failed_event);
      }
      
      // Check Redundancy state
      if (REDUNDANCY_FAILED_MASK & condition) {
         PEvent redundancy_failed_event = new Event(REDUNDANCY_STATE, REDUNDANCY_FAILED);
         events->Append(redundancy_failed_event);
      }
      else {
         PEvent redundancy_ok_event = new Event(REDUNDANCY_STATE, REDUNDANCY_OK);
         events->Append(redundancy_ok_event);
      }

      // Check the Bypass contactor state
      if (BYPASS_STUCK_MASK & condition) {
         PEvent bypass_contactor_failed_event = new Event(BYPASS_CONTACTOR_STATE, BYPASS_CONTACTOR_FAILED);
         events->Append(bypass_contactor_failed_event);
      }
      else {
         PEvent bypass_contactor_ok_event = new Event(BYPASS_CONTACTOR_STATE, BYPASS_CONTACTOR_OK);
         events->Append(bypass_contactor_ok_event);
      }
      
      // Check the input circuit breaker state
      if (INPUT_BREAKER_TRIPPED_MASK & condition)
      {
         PEvent input_breaker_tripped_event = new Event(INPUT_BREAKER_STATE, BREAKER_OPEN);
         events->Append(input_breaker_tripped_event);
      }
      else {
         PEvent input_breaker_closed_event = new Event(INPUT_BREAKER_STATE, BREAKER_CLOSED);
         events->Append(input_breaker_closed_event);
      }

      // Check the system fan state
      if (SYSTEM_FAN_FAILED_MASK & condition)
      {
         PEvent fan_failed_event = new Event(SYSTEM_FAN_STATE, SYSTEM_FAN_FAILED);
         events->Append(fan_failed_event);
      }
      else {
         PEvent fan_ok_event = new Event(SYSTEM_FAN_STATE, SYSTEM_FAN_OK);
         events->Append(fan_ok_event);
      }
      
      theCurrentState = condition;
      
      //
      // Convert value from HEX to decimal for every one else
      //
      CHAR int_value[32];
      sprintf(int_value, "%d", condition);
      value->setResponse(int_value);
   }

   return err;
}

INT ModuleCountsStatusPollParam :: IsPollSet()
{
   if (!thePollSet)
   {
      thePollSet = TRUE;
      return ErrMODULE_COUNTS_SET;
   }
   return ErrSAME_VALUE;
}

// ProcessValue
//
// This routine parses the UPS response containing module counts and status.
// The response is assumed to be in the following format:
//    total UPS modules (dd)
//    bad UPS modules (dd)
//    fault tolerance level (d)
//    fault tolerance alarm threshold (d)
//    kVA capacity (dd.d)
//    kVA capacity alarm threshold (dd.d)
//    RIM present? (Y or N)
//
// All responses must be separated by a comma

INT ModuleCountsStatusPollParam ::  ProcessValue(PMessage value, List* events)
{
   INT err = ErrNO_ERROR;
   
   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   // Check for an NA response from the UPS.  This will be returned
   // if the the RIM is in control, because the RIM responds to a limited
   // subset of the full Symmetra UPS-Link spec.
   else if ( (!events) || (_strcmpi(value->getResponse(), "NA") == 0)) {
	   err = ErrNO_VALUE;
   }

   // If everything checks out OK
   if (err == ErrNO_ERROR) 
   {
      PCHAR module_counts;
      
      // Be a good neighbor and don't destroy the input parameters.
      PCHAR ups_response = value->getResponse();
      module_counts = _strdup(ups_response);
      
      PCHAR number_of_inverters = strtok(module_counts, ",");
      PEvent Number_Of_UPS_Modules_Event = 
         new Event(TOTAL_INVERTERS, number_of_inverters);
      events->Append(Number_Of_UPS_Modules_Event);
      
      PCHAR bad_inverters = strtok(NULL, ",");
      PEvent Bad_UPS_Modules_Event = 
         new Event(NUMBER_BAD_INVERTERS, bad_inverters);
      events->Append(Bad_UPS_Modules_Event);
      
      PCHAR current_redundancy = strtok(NULL, ",");
      PEvent Current_Redundancy_Event = 
         new Event(CURRENT_REDUNDANCY,current_redundancy);
      events->Append(Current_Redundancy_Event);
      
      PCHAR minimum_redundancy = strtok(NULL, ",");
      PEvent Minimum_Redundancy_Event = 
         new Event(MINIMUM_REDUNDANCY,minimum_redundancy );
      events->Append(Minimum_Redundancy_Event);
      
      PCHAR current_load_capability = strtok(NULL, ",");
      PEvent Current_Load_Capability_Event = 
         new Event(CURRENT_LOAD_CAPABILITY, current_load_capability);
      events->Append(Current_Load_Capability_Event);
      
      PCHAR maximum_load_capability = strtok(NULL, ",");
      PEvent Maximum_Load_Capability_Event = 
         new Event(MAXIMUM_LOAD_CAPABILITY, maximum_load_capability);
      events->Append(Maximum_Load_Capability_Event);
      
      
      PCHAR rim_installation_state = strtok(NULL, ",");
      PEvent RIM_Installation_State_Event;
      if ((rim_installation_state != NULL) && (_strcmpi(rim_installation_state, "y") == 0)) {
         RIM_Installation_State_Event = 
            new Event(RIM_INSTALLATION_STATE, RIM_INSTALLED);
      }
      else {
         RIM_Installation_State_Event = 
            new Event(RIM_INSTALLATION_STATE, RIM_NOT_INSTALLED);
      }
      events->Append(RIM_Installation_State_Event);
      
      // free local memory allocations
      free (module_counts);   
   }
   
   return err;
}

INT InputVoltageFrequencyPollParam :: IsPollSet()
{
   if (!thePollSet)
   {
      thePollSet = TRUE;
      return ErrVOLTAGE_FREQUENCY_SET;
   }
   return ErrSAME_VALUE;
}

// ProcessValue
//
// This routine parses the UPS response containing the input 
// voltages and frequency.
// The response is assumed to be in the following format:
//    utility input voltage for phase A
//    utility input voltage for phase B
//    utility input voltage for phase C
//    utility input frequency
// All responses must be separated by a comma

INT InputVoltageFrequencyPollParam ::  ProcessValue(PMessage value, List* events)
{
   INT err = ErrCONTINUE;
   
   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   if (!events)
   {
      err = ErrNO_VALUE;
   }
   if (err==ErrCONTINUE) 
   {
      PCHAR input_voltage_frequency;
      
      // Be a good neighbor and don't destroy the input parameters.
      PCHAR ups_response = value->getResponse();
      input_voltage_frequency = _strdup(ups_response);
      
      // At the minimum, there will always be a phase a voltage
      // and an input frequency.  At most there will be three
      // input voltages and a frequency      
      
      const PCHAR cVoltage_Frequency_Separator = ";";
      const PCHAR cVoltage_Parameter_Separator = ",";
      const PCHAR cZeroVoltage = "0.0";
      
      PCHAR input_voltages = strtok(input_voltage_frequency,cVoltage_Frequency_Separator);
      PCHAR input_frequency = strtok(NULL,cVoltage_Frequency_Separator );
      
      PCHAR phase_a_input_voltage = strtok(input_voltages,cVoltage_Parameter_Separator );
      PEvent Voltage_A_Event = new Event(INPUT_VOLTAGE_PHASE_A, phase_a_input_voltage );
      events->Append(Voltage_A_Event);
      
      PCHAR phase_b_input_voltage = strtok(NULL,cVoltage_Parameter_Separator );
      PCHAR phase_c_input_voltage;
      INT number_of_input_phases;
      if (phase_b_input_voltage == NULL) 
      {
         phase_b_input_voltage = cZeroVoltage;
         phase_c_input_voltage = cZeroVoltage;
         number_of_input_phases = 1;
      }
      else 
      {
         phase_c_input_voltage = strtok(NULL, cVoltage_Parameter_Separator);
         number_of_input_phases = 3;
         if (phase_c_input_voltage == NULL) 
         {
            phase_c_input_voltage = cZeroVoltage;
            number_of_input_phases = 2;
         }
      }
      
      PEvent Voltage_B_Event = new Event(INPUT_VOLTAGE_PHASE_B, phase_b_input_voltage );
      events->Append(Voltage_B_Event);
      PEvent Voltage_C_Event = new Event(INPUT_VOLTAGE_PHASE_C, phase_c_input_voltage );
      events->Append(Voltage_C_Event); 
      
      PEvent Input_Frequency_Event = new Event(INPUT_FREQUENCY, input_frequency );
      events->Append(Input_Frequency_Event); 
      
      CHAR input_phases[10];
      _itoa(number_of_input_phases,input_phases,10);
      PEvent Number_Of_Phases_Event = new Event(NUMBER_OF_INPUT_PHASES, input_phases );
      events->Append(Number_Of_Phases_Event); 
      
      // free local memory allocations
      free (input_voltage_frequency);  
      
   }
   return err;
}


INT OutputVoltageCurrentsPollParam :: IsPollSet()
{
   if (!thePollSet)
   {
      thePollSet = TRUE;
      return ErrVOLTAGE_CURRENTS_SET;
   }
   return ErrSAME_VALUE;
}

// ProcessValue
//
// This routine parses the UPS response containing the output
// voltages and currents.
// The response is assumed to be in the following format:
//      output voltage for phase A
//    output voltage for phase B
//    output voltage for phase C
//    current for phase A
//    current for phase B
//    current for phase C
// All responses must be separated by a comma

INT OutputVoltageCurrentsPollParam ::  ProcessValue(PMessage value, List* events)
{
   INT err = ErrCONTINUE;
   
   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   if (!events)
   {
      err = ErrNO_VALUE;
   }
   if (err==ErrCONTINUE) 
   {
      PCHAR output_voltage_currents;
      
      // Be a good neighbor and don't destroy the input parameters.
      PCHAR ups_response = value->getResponse();
      output_voltage_currents = _strdup(ups_response);
      
      // Separate the voltages from the currents and then process.
      const PCHAR cVoltage_Currents_Separator = ";";
      PCHAR output_voltages = strtok(output_voltage_currents,cVoltage_Currents_Separator );
      
      // Extract phase voltages 
      const PCHAR cParameter_Separator = ",";
      const PCHAR cZeroVoltage = "0.0";
      
      PCHAR phase_a_output_voltage = strtok(output_voltages,cParameter_Separator );
      PEvent Voltage_A_Event = new Event(OUTPUT_VOLTAGE_PHASE_A, phase_a_output_voltage );
      events->Append(Voltage_A_Event);
      
      PCHAR phase_b_output_voltage = strtok(NULL,cParameter_Separator );
      PCHAR phase_c_output_voltage;
      INT number_of_output_phases;
      if (phase_b_output_voltage == NULL) 
      {
         phase_b_output_voltage = cZeroVoltage;
         phase_c_output_voltage = cZeroVoltage;
         number_of_output_phases = 1;
      }
      else 
      {
         phase_c_output_voltage = strtok(NULL, cParameter_Separator);
         number_of_output_phases = 3;
         if (phase_c_output_voltage == NULL) 
         {
            phase_c_output_voltage = cZeroVoltage;
            number_of_output_phases = 2;
         }
      }
      
      PEvent Voltage_B_Event = new Event(OUTPUT_VOLTAGE_PHASE_B, phase_b_output_voltage );
      events->Append(Voltage_B_Event);
      
      PEvent Voltage_C_Event = new Event(OUTPUT_VOLTAGE_PHASE_C, phase_c_output_voltage );
      events->Append(Voltage_C_Event); 
      
      CHAR output_phases[10];
      _itoa(number_of_output_phases,output_phases,10);
      PEvent Number_Of_Phases_Event = new Event(NUMBER_OF_OUTPUT_PHASES, output_phases );
      events->Append(Number_Of_Phases_Event); 
      
      // free local memory allocations
      free (output_voltage_currents);  
      
   }
   
   return err;
}

//-------------------------------------------------------------
//  This handles the CTRL Z command for upss that support it
//-------------------------------------------------------------

#if (C_OS & C_OS2)
INT EepromAllowedValsPollParam::  ProcessValue(PMessage value, List* )
#else
INT EepromAllowedValuesPollParam::  ProcessValue(PMessage value, List* )
#endif
{
   CHAR response[512];
   CHAR returnString[512];
   INT done = FALSE;
   
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   strcpy (response, value->getResponse());
   
   CHAR *workString;
   CHAR command;
   CHAR commandString[7];
   CHAR upsType;
   CHAR numChoices;
   CHAR numCharPerChoice;
   INT index = 0;
   returnString[0] = 0;
   INT scanFlag;
   
   workString = &(response[0]);
   
   // Loop over all the parameters that have been return by CTRL Z
   //
   // The String is Formatted like this
   //
   //  ##CTcSxxxyyyzzz...  where ## is the delimiter
   //                            C is the command ex: u  -- High Transfer Points
   //                            T is the Ups Type ex M for 208,
   //                                               I for 240,
   //                                               A for 100,
   //                                               D for 120
   //                            c is Number of choices ex 3
   //                            S is the size of each choice 3
   //                          xxx is the first choice -- size = 3
   //                          yyy is the second choice -- size = 3
   //                          zzz is the third choice -- size = 3
   while (!done)
   {
      CHAR eepromValues[1024];
      memset(eepromValues,'\0',1024);
      
      //
      // Skip over #'s.  Old Matrix use two # delimeters.  3G and beyond
      // want to use only 1 #.
      //
      while(*workString == '#')  {
         workString++;
      }
      
      scanFlag = sscanf(workString, "%c%c%c%c%n", &command,&upsType, &numChoices,
         &numCharPerChoice, &index); //(SRT) can't rely on index to tell truth,
      // when response is trunc'd in middle of 
      // command so I've added scanFlag instead.
      switch (scanFlag) {
      case 4:    // normal process
         {                                  
            
            INT choices = (int)numChoices - 48;
            INT charsPChoice = (int)numCharPerChoice - 48;
            
            workString = &(workString[index]);
            
            if (strlen(workString)< (size_t) (choices*charsPChoice)) {
               done = TRUE;
               break;
            }
            
            for (INT i = 0; i < choices; i++)
            {
               if (i != 0)
                  strcat(eepromValues, ",");
               strncat(eepromValues, workString, charsPChoice);
               workString = &(workString[charsPChoice]);
            }
            
            // Convert command to the sensor id -- 
            // EX:  u High trans voltage to -- HIGH_TRANSFER_VOLTAGE
            
            INT id;
            commandString[0] = command;
            commandString[1] = 0;
            
            
            if (!strcmp(commandString, OUTPUTVOLTAGEREPORT))
            {
               id = OUTPUT_VOLTAGE_REPORT;
            }
            else if (!strcmp(commandString, LANGUAGE))
            {
               id = UPS_LANGUAGE;
               
            }
            else if (!strcmp(commandString, AUTOSELFTEST))
            {
               id = UPS_SELF_TEST_SCHEDULE;
            }
            else if (!strcmp(commandString, HIGHTRANSFERPOINT))
            {
               id = HIGH_TRANSFER_VOLTAGE;
            }
            else if (!strcmp(commandString, LOWTRANSFERPOINT))
            {
               id = LOW_TRANSFER_VOLTAGE;
            }
            else if (!strcmp(commandString, MINIMUMCAPACITY))
            {
               id = MIN_RETURN_CAPACITY;
            }   
            else if (!strcmp(commandString, OUTPUTVOLTAGESETTING))
            {
               id = RATED_OUTPUT_VOLTAGE;
            }
            else if (!strcmp(commandString, SENSETIVITY))
            {
               id = UPS_SENSITIVITY;
            }
            else if (!strcmp(commandString, LOWBATTERYRUNTIME))
            {
               id = LOW_BATTERY_DURATION;
            }
            else if (!strcmp(commandString, ALARMDELAY))
            {
               id = ALARM_DELAY;
            }
            else if (!strcmp(commandString, SHUTDOWNDELAY))
            {
               id = SHUTDOWN_DELAY;
            }
            else if (!strcmp(commandString, SYNCTURNBACKDELAY))
            {
               id = TURN_ON_DELAY;
            }
            else if (!strcmp(commandString, EARLYTURNOFF))
            {
               id = EARLY_TURN_OFF_POINTS;
            }
            
            CHAR tmp[124];
            sprintf(tmp, "#%d,%c,%s",id,upsType,eepromValues);
            
            strcat(returnString,tmp);
            break;
         }
      case 0:    // end of string?
      case EOF: // can be end of strin gor error, we'll assume end of string.
         done = TRUE;
         break;
         
      default:                // erroneous truncation
         done = TRUE;
         break;
      } //end switch
  } // end while
  
  strcat(returnString, "#");
  value->setResponse(returnString);
  return ErrNO_ERROR;
}

INT SmartModePollParam::ProcessValue(PMessage value, List* )
{ 
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (strcmp(value->getResponse(), SMARTMODE_OK))
      return ErrSMART_MODE_FAILED;
   
   return ErrNO_ERROR;
}

INT TurnOffSmartModePollParam::ProcessValue(PMessage value, List* )
{    
   return ErrNO_ERROR;
}

INT LineConditionPollParam::ProcessValue(PMessage value, List* events)
{
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (!events) {
      return ErrNO_VALUE;
   }
   
   
   //
   // Convert UPS Link responses to our codes and generate appropriate
   // event
   //
   CHAR code_value[32];
   INT code = 0;
   if (!strcmp(value->getResponse(), "FF" ))  {
      code = NO_ABNORMAL_CONDITION;
   } 
   else  {
      code = ABNORMAL_CONDITION;
   }
   sprintf(code_value, "%d", code);
   value->setResponse(code_value);
   PEvent tmp = new Event(LINE_CONDITION_TEST, code);
   events->Append(tmp);                
   return ErrCONTINUE;
}

INT LightsTestPollParam::  ProcessValue(PMessage value, List* )
{
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (strcmp(value->getResponse(), LIGHTSTEST_RESP))
      return ErrLIGHTSTEST_REQUEST_FAILED;
   
   return ErrNO_ERROR;
}

INT TurnOffAfterDelayPollParam::ProcessValue(PMessage value, List* )
{
   PCHAR tmp_value = value->getResponse();
   if (tmp_value) {
      if (!strcmp(tmp_value, TURNOFFAFTERDELAY_NOT_AVAIL)) {
         return ErrTURNOFFAFTERDELAY_NOT_AVAIL;
      }
   }
   
   return ErrNO_ERROR;
}

INT ShutdownPollParam::ProcessValue(PMessage value, List* )
{
   INT rval = ErrNO_ERROR;
   PCHAR response = value->getResponse();
   if (response) {
      if (strcmp(response,SHUTDOWN_RESP)) { 
         if (!strcmp(response, SHUTDOWN_NOT_AVAIL))
            rval=ErrSHUTDOWN_NOT_AVAIL;
      }
   }
   return rval;
}

INT SimulatePowerFailurePollParam::ProcessValue(PMessage value, List* )
{
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (strcmp(value->getResponse(), SIMULATEPOWERFAILURE_OK))
   { 
      if (!strcmp(value->getResponse(), SIMULATEPOWERFAILURE_NOT_AVAIL))
         return ErrSIMULATEPOWERFAILURE_NOT_AVAIL;
   }
   return ErrNO_ERROR;
}

INT BatteryTestPollParam::  ProcessValue(PMessage value, List* )
{
   if (!strcmp(value->getResponse(), BATTERYTEST_NOT_AVAIL))
   { 
      return ErrBATTERYTEST_NOT_AVAIL;
   }
   return ErrNO_ERROR;
}

INT TurnOffUpsPollParam::  ProcessValue(PMessage value, List* )
{
   if (!strcmp(value->getResponse(), NOT_AVAIL))
   { 
      return ErrREAD_FAILED;  //This error should be ErrTURN_OFF_UPS_NOT_AVAIL
   }
   return ErrNO_ERROR;
}

INT ShutdownWakeupPollParam::  ProcessValue(PMessage value, List* )
{
   if (!strcmp(value->getResponse(), NOT_AVAIL))
   { 
      return ErrREAD_FAILED;  //This error should be ErrSHUT_WAKE_NOT_AVAIL
   }
   return ErrNO_ERROR;
}

INT BatteryCalibrationPollParam::  ProcessValue(PMessage value, List* )
{
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (strcmp(value->getResponse(), BATTERYCALIBRATION_OK))
   { 
      if (!strcmp(value->getResponse(), BATTERYCALIBRATION_CAP_TOO_LOW))
         return ErrBATTERYCALIBRATION_CAP_TOO_LOW;
      if (!strcmp(value->getResponse(), BATTERYCALIBRATION_NOT_AVAIL))
         return ErrBATTERYCALIBRATION_NOT_AVAIL;
   }
   return ErrNO_ERROR;
}


INT BatteryTestResultsPollParam::  ProcessValue(PMessage value, List* )
{
   if ((value == NULL) || (NullTest(value->getResponse()) ))
      return ErrREAD_FAILED;
   
   char buffer[20], *val;
   val = value->getResponse();

   if (val == NULL) 
     return ErrREAD_FAILED;

   if (!strcmp(val, BATTERYTEST_OK))
      value->setResponse(_itoa(SELF_TEST_PASSED,buffer,10));
   if (!strcmp(val, BATTERYTEST_BAD_BATTERY))
      value->setResponse(_itoa(SELF_TEST_FAILED,buffer,10));
   if (!strcmp(val, BATTERYTEST_NO_RECENT_TEST))
      value->setResponse(_itoa(SELF_TEST_NO_RECENT_TEST,buffer,10));
   if (!strcmp(val, BATTERYTEST_INVALID_TEST))
      value->setResponse(_itoa(SELF_TEST_INVALID,buffer,10));
   return ErrNO_ERROR;
}

INT TransferCausePollParam::  ProcessValue(PMessage value, List* )
{
   if ((value == NULL) || (NullTest(value->getResponse())) )
      return ErrREAD_FAILED;
   
   char buffer[20], *val;
   val = value->getResponse();

   if (val == NULL) 
     return ErrREAD_FAILED;

   
   if (!strcmp(val, TRANSFERCAUSE_NO_TRANSFERS))
      value->setResponse(_itoa(NO_TRANSFERS,buffer,10));
   if (!strcmp(val, TRANSFERCAUSE_SELF_TEST))
      value->setResponse(_itoa(SELF_TEST_TRANSFER,buffer,10));
   if (!strcmp(val, TRANSFERCAUSE_LINE_DETECTED))
      value->setResponse(_itoa(NOTCH_SPIKE_TRANSFER,buffer,10));
   if (!strcmp(val, TRANSFERCAUSE_LOW_LINE_VOLTAGE))
      value->setResponse(_itoa(LOW_LINE_TRANSFER,buffer,10));
   if (!strcmp(val, TRANSFERCAUSE_HIGH_LINE_VOLTAGE))
      value->setResponse(_itoa(HIGH_LINE_TRANSFER,buffer,10));
   if (!strcmp(val, TRANSFERCAUSE_RATE_VOLTAGE_CHANGE))
      value->setResponse(_itoa(RATE_TRANSFER,buffer,10));
   if (!strcmp(val, TRANSFERCAUSE_INPUT_BREAKER_TRIPPED))
      value->setResponse(_itoa(INPUT_BREAKER_TRIPPED_TRANSFER,buffer,10));
   
   return ErrNO_ERROR;
}



INT  BatteryCapacityPollParam::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if ((*(value->getResponse()+3)) == '.')
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}


INT  DipSwitchPollParam::  ProcessValue(PMessage value, List* )
{
   int cur_state = 0;
   
   if (sscanf(value->getResponse(),"%x",&cur_state) == EOF) {
     return ErrREAD_FAILED;
   }
   
   //
   // Convert value from HEX to decimal for every one else
   //
   CHAR int_value[32];
   sprintf(int_value, "%d", cur_state);
   value->setResponse(int_value);
   
   return ErrNO_ERROR;
}

INT  RuntimeRemainingPollParam::  ProcessValue(PMessage value, List* )
{
   INT err = ErrNO_ERROR;
   PCHAR val = value->getResponse();
   INT len = strlen(val);
   if (len == 4)  {
      if(strcmp(val, ">>>>") == 0)  {
         value->setResponse("9999");
      }
      else  {
         err = ErrBAD_RESPONSE_VALUE;
      }
   }
   else if(len == 5)  {
      PCHAR time_in_minutes = strtok(value->getResponse(), ":");
      if(time_in_minutes)  {
         LONG secs = atol(time_in_minutes) * 60;
         CHAR time_in_seconds[32];
         value->setResponse(_ltoa(secs, time_in_seconds, 10));
      }
      else  {
         err = ErrBAD_RESPONSE_VALUE;
      }
   }
   else  {
      err = ErrBAD_RESPONSE_VALUE;
   }
   return err;
}

INT CopyrightPollParam::  ProcessValue(PMessage value, List* )
{
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (strcmp(value->getResponse(), COPYRIGHT_RESP))
   { 
      return ErrCOPYRIGHT_RESP_ERROR;
   }
   return ErrNO_ERROR;
}

INT  BatteryVoltagePollParam::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if (((*(value->getResponse()+2)) == '.') || ((*(value->getResponse()+3)) == '.'))
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}

INT  InternalTempPollParam::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if ((*(value->getResponse()+3)) == '.')
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}

INT  OutputFreqPollParam::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if ((*(value->getResponse()+2)) == '.')
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}

INT  LineVoltagePollParam::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if ((*(value->getResponse()+3)) == '.')
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}

INT  MaxVoltagePollParam::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if ((*(value->getResponse()+3)) == '.')
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}

INT  MinVoltagePollParam::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if ((*(value->getResponse()+3)) == '.')
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}

INT  OutputVoltagePollParam::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if ((*(value->getResponse()+3)) == '.')
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}

INT LoadPowerPollParam ::  ProcessValue(PMessage value, List* aList)
{
   if(SmartPollParam::ProcessValue(value, aList) == ErrNO_ERROR)
   {
      if ((*(value->getResponse()+3)) == '.')
         return ErrNO_ERROR;
   }
   return ErrBAD_RESPONSE_VALUE;
}


INT DecrementPollParam::  ProcessValue(PMessage value, List* )
{
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (strcmp(value->getResponse(), DECREMENT_OK))
   { 
      if (!strcmp(value->getResponse(), DECREMENT_NOT_AVAIL))
         return ErrDECREMENT_NOT_AVAIL;
      if (!strcmp(value->getResponse(), DECREMENT_NOT_ALLOWED))
         return ErrDECREMENT_NOT_ALLOWED;
   }
   return ErrNO_ERROR;
}

INT IncrementPollParam::  ProcessValue(PMessage value, List* )
{
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (strcmp(value->getResponse(), INCREMENT_OK))
   { 
      if (!strcmp(value->getResponse(), INCREMENT_NOT_AVAIL))
         return ErrINCREMENT_NOT_AVAIL;
      if (!strcmp(value->getResponse(), INCREMENT_NOT_ALLOWED))
         return ErrINCREMENT_NOT_ALLOWED;
   }
   return ErrNO_ERROR;
}



INT  UpsIdPollParam::  ProcessValue(PMessage value, List* )
{
   //  I had to do this because UPS don't always return a response without
   //  a significant delay after a data set. We get a response by asking
   //  for the EEPROM data param twice.  The second one always works. pcy.
   //  The same is tru for the BatteryReplaceDate pollparam. pcy.
   return ErrNO_ERROR;
}


INT  BatteryReplaceDatePollParam::  ProcessValue(PMessage value, List* )
{
   //  I had to do this because UPS don't always return a response without
   //  a significant delay after a data set. We get a response by asking
   //  for the EEPROM data param twice.  The second one always works.
   //  The same is tru for the UpsId pollparam. pcy.
   return ErrNO_ERROR;
}


INT  BatteryCondPollParam::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( LOWBATTERYMASK & cur_state )             // Bitwise OR
   {
      value->setResponse(_itoa(BATTERY_BAD,buffer,10));
      theCurrentState = BATTERY_BAD;
   }
   else if (LOWBATTERYMASK & theCurrentState)
   {
      value->setResponse(_itoa(BATTERY_GOOD,buffer,10));
      theCurrentState = BATTERY_GOOD;
   }
   return ErrNO_ERROR;
}

INT  UtilLineCondPollParam::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( ONBATTERYMASK & cur_state )              // Bitwise OR
   {
      value->setResponse(_itoa(LINE_BAD,buffer,10));
      theCurrentState = LINE_BAD;
   }
   if ( ONLINEMASK & cur_state )                 // Bitwise OR
   {
      value->setResponse(_itoa(LINE_GOOD,buffer,10));
      theCurrentState = LINE_GOOD;
   }
   return ErrNO_ERROR;
}

INT  ReplaceBattCondPollParam::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( REPLACEBATTERYMASK & cur_state )         // Bitwise OR
   {
      value->setResponse(_itoa(BATTERY_NEEDS_REPLACING,buffer,10));
      theCurrentState = BATTERY_NEEDS_REPLACING;
   }
   else
   {
      value->setResponse(_itoa(BATTERY_DOESNT_NEED_REPLACING,buffer,10));
      theCurrentState = BATTERY_DOESNT_NEED_REPLACING;
   }
   return ErrNO_ERROR;
}

INT  OverLoadCondPollParam::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( OVERLOADMASK & cur_state )               // Bitwise OR
   {
      value->setResponse(_itoa(UPS_OVERLOAD,buffer,10));
      theCurrentState = UPS_OVERLOAD;
   }
   else if (OVERLOADMASK & theCurrentState)
   {
      value->setResponse(_itoa(NO_UPS_OVERLOAD,buffer,10));
      theCurrentState = NO_UPS_OVERLOAD;
   }
   return ErrNO_ERROR;
}

INT  SmartBoostCondPollParam::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( SMARTBOOSTMASK & cur_state )             // Bitwise OR
   {
      value->setResponse(_itoa(SMART_BOOST_ON,buffer,10));
      theCurrentState = (USHORT) cur_state;  //  SMART_BOOST_ON;
   }
   else if (SMARTBOOSTMASK & theCurrentState)
   {
      value->setResponse(_itoa(SMART_BOOST_OFF,buffer,10));
      theCurrentState = (USHORT) cur_state;  //   SMART_BOOST_OFF;
   }
   else
      value->setResponse(_itoa(SMART_BOOST_OFF,buffer,10));
   
   return ErrNO_ERROR;
}

INT  SmartTrimCondPollParam::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( SMARTTRIMMASK & cur_state )             // Bitwise OR
   {
      value->setResponse(_itoa(SMART_TRIM_ON,buffer,10));
      theCurrentState = (USHORT) cur_state;  //  SMART_TRIM_ON;
   }
   else if (SMARTTRIMMASK & theCurrentState)
   {
      value->setResponse(_itoa(SMART_TRIM_OFF,buffer,10));
      theCurrentState = (USHORT) cur_state;  //   SMART_TRIM_OFF;
   }
   else
      value->setResponse(_itoa(SMART_TRIM_OFF,buffer,10));
   
   return ErrNO_ERROR;
}

INT  RedundancyConditionPollParam ::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_condition = UtilHexStringToInt(value->getResponse());
   
   if ( REDUNDANCY_FAILED_MASK & cur_condition )             // Bitwise OR
   {
      value->setResponse(_itoa(REDUNDANCY_FAILED,buffer,10));
      theCurrentState = (USHORT) cur_condition;  
   }
   else if (REDUNDANCY_FAILED_MASK & theCurrentState)
   {
      value->setResponse(_itoa(REDUNDANCY_OK,buffer,10));
      theCurrentState = (USHORT) cur_condition;  
   }
   else
      value->setResponse(_itoa(REDUNDANCY_OK,buffer,10));
   
   return ErrNO_ERROR;
}

INT IMInstallationStatusPollParam ::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( RIM_IN_CONTROL_MASK & cur_state )             // Bitwise OR
   {
      if (IM_FAILED_MASK & cur_state) 
      {
         value->setResponse(_itoa(IM_INSTALLED,buffer,10));
         theCurrentState = (USHORT) cur_state;  
      }  
      else 
      {  
         value->setResponse(_itoa(IM_NOT_INSTALLED,buffer,10));
         theCurrentState = (USHORT) cur_state;  
      }
   }
   else
   {
      value->setResponse(_itoa(IM_INSTALLED,buffer,10));
   }
   return ErrNO_ERROR;
}

INT IMStatusPollParam ::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if (IM_FAILED_MASK & cur_state) {
      value->setResponse(_itoa(IM_FAILED,buffer,10));
   } 
   else {
      value->setResponse(_itoa(IM_OK,buffer,10));
   }
   
   return ErrNO_ERROR;
}

INT RIMStatusPollParam ::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( RIM_FAILED_MASK & cur_state )             // Bitwise OR
   {
      value->setResponse(_itoa(RIM_FAILED,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   } 
   else {
	   value->setResponse(_itoa(RIM_OK,buffer,10));
   }
   
   return ErrNO_ERROR;
}

INT SystemFanStatusPollParam ::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( SYSTEM_FAN_FAILED_MASK & cur_state )             // Bitwise OR
   {
      value->setResponse(_itoa(SYSTEM_FAN_FAILED,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   } 
   else if (SYSTEM_FAN_FAILED_MASK & theCurrentState)
   {
      value->setResponse(_itoa(SYSTEM_FAN_OK,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   }
   else
      value->setResponse(_itoa(SYSTEM_FAN_OK,buffer,10));
   
   return ErrNO_ERROR;
}

INT BypassContactorStatusPollParam ::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if (BYPASS_STUCK_MASK  & cur_state )             // Bitwise OR
   {
      value->setResponse(_itoa(SYSTEM_FAN_FAILED,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   } 
   else if (SYSTEM_FAN_FAILED_MASK & theCurrentState)
   {
      value->setResponse(_itoa(BYPASS_CONTACTOR_FAILED,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   }
   else
      value->setResponse(_itoa(BYPASS_CONTACTOR_OK, buffer,10));
   
   return ErrNO_ERROR;
}

INT InputBreakerTrippedStatusPollParam ::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if (INPUT_BREAKER_TRIPPED_MASK  & cur_state )             // Bitwise OR
   {
      value->setResponse(_itoa(BREAKER_OPEN,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   } 
   else if (INPUT_BREAKER_TRIPPED_MASK & theCurrentState)
   {
      value->setResponse(_itoa(BREAKER_CLOSED,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   }
   else
      value->setResponse(_itoa(BREAKER_CLOSED, buffer,10));
   
   return ErrNO_ERROR;
}


INT UPSModuleStatusPollParam ::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( FAILED_UPS_MASK & cur_state )             // Bitwise OR
   {
      value->setResponse(_itoa(UPS_MODULE_FAILED,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   } 
   else if (FAILED_UPS_MASK & theCurrentState)
   {
      value->setResponse(_itoa(UPS_MODULE_OK,buffer,10));
      theCurrentState = (USHORT) cur_state;  
   }
   else
      value->setResponse(_itoa(UPS_MODULE_OK, buffer,10));
   
   return ErrNO_ERROR;
}

INT NumberInstalledInvertersPollParam ::  ProcessValue(PMessage value, List* )
{
   INT err = ErrNO_ERROR;
   PCHAR ups_response = value->getResponse();

   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   else if (_strcmpi(value->getResponse(), "NA") == 0) {
	   err = ErrNO_VALUE;
   }

   else {
	   PCHAR module_counts = _strdup(ups_response);
	   PCHAR number_of_inverters = strtok(module_counts, ",");
	   value->setResponse(number_of_inverters);

	   free (module_counts);
   }
   
   return err;
}

INT NumberBadInvertersPollParam ::  ProcessValue(PMessage value, List* )
{
   INT err = ErrNO_ERROR;
   PCHAR ups_response = value->getResponse();

   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   else if (_strcmpi(value->getResponse(), "NA") == 0) {
	   err = ErrNO_VALUE;
   }

   else {
	   
	   PCHAR module_counts = _strdup(ups_response);
	   
	   // Number of bad inverters is the second parameter in list
	   PCHAR number_of_bad_inverters = strtok(module_counts, ",");
	   number_of_bad_inverters = strtok(NULL, ",");
	   value->setResponse(number_of_bad_inverters);
	   
	   free (module_counts);
   }

   return err;
}

INT RedundancyLevelPollParam ::  ProcessValue(PMessage value, List* )
{
   INT err = ErrNO_ERROR;
   PCHAR ups_response = value->getResponse();

   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   else if (_strcmpi(value->getResponse(), "NA") == 0) {
	   err = ErrNO_VALUE;
   }

   else {
	   
	   PCHAR module_counts = _strdup(ups_response);
	   
	   // Remove the first parameter.
	   // current redundancy is the second parameter
	   
	   PCHAR current_redundancy = strtok(module_counts, ",");
	   current_redundancy = strtok(NULL, ",");
      current_redundancy = strtok(NULL, ",");
	   value->setResponse(current_redundancy);

	   free (module_counts);
   }
   
   return err;
}

INT MinimumRedundancyPollParam ::  ProcessValue(PMessage value, List* )
{
   INT err = ErrNO_ERROR;
   PCHAR ups_response = value->getResponse();

   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   else if (_strcmpi(value->getResponse(), "NA") == 0) {
	   err = ErrNO_VALUE;
   }

   else {
	   
	   PCHAR module_counts = _strdup(ups_response);
	   
	   // Remove unwanted parameters.
	   // minimum redundancy level is the third parameter
	   PCHAR minimum_redundancy = strtok(module_counts, ",");
	   minimum_redundancy = strtok(NULL, ",");
	   minimum_redundancy = strtok(NULL, ",");
      minimum_redundancy = strtok(NULL, ",");
	   value->setResponse(minimum_redundancy);

	   free (module_counts);
   }
   
   return err;
}

INT CurrentLoadCapabilityPollParam ::  ProcessValue(PMessage value, List* )
{
   INT err = ErrNO_ERROR;
   PCHAR ups_response = value->getResponse();

   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   else if (_strcmpi(value->getResponse(), "NA") == 0) {
	   err = ErrNO_VALUE;
   }

   else {
	   
	   PCHAR module_counts = _strdup(ups_response);
	   
	   // Remove unwanted parameters.
	   // current load capability is the fifth parameter	   
	   PCHAR current_load_capability = strtok(module_counts, ",");
	   current_load_capability = strtok(NULL, ",");
	   current_load_capability = strtok(NULL, ",");
	   current_load_capability = strtok(NULL, ",");	   
      current_load_capability = strtok(NULL, ",");
	   value->setResponse(current_load_capability);

	   free (module_counts);
   }
   
   return err;
}



INT MaximumLoadCapabilityPollParam ::  ProcessValue(PMessage value, List* )
{
   INT err = ErrNO_ERROR;
   PCHAR ups_response = value->getResponse();

   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   else if (_strcmpi(value->getResponse(), "NA") == 0) {
	   err = ErrNO_VALUE;
   }

   else {
	   
	   PCHAR module_counts = _strdup(ups_response);
	   
	   // Remove unwanted parameters.
	   // maximum load capability is the sixth parameter	   
	   PCHAR maximum_load_capability = strtok(module_counts, ",");
	   maximum_load_capability = strtok(NULL, ",");
	   maximum_load_capability = strtok(NULL, ",");
	   maximum_load_capability = strtok(NULL, ",");	   
      maximum_load_capability = strtok(NULL, ",");
      maximum_load_capability = strtok(NULL, ",");
	   value->setResponse(maximum_load_capability);

	   free (module_counts);
   }
   
   return err;
}


INT RIMInstallationStatusPollParam ::  ProcessValue(PMessage value, List* )
{
   INT err = ErrNO_ERROR;
   PCHAR ups_response = value->getResponse();

   if ( NullTest(value->getResponse()) ) 
   {
      err = ErrREAD_FAILED;
   }
   
   else if (_strcmpi(value->getResponse(), "NA") == 0) {
	   err = ErrNO_VALUE;
   }

   else {
	   PCHAR module_counts = _strdup(ups_response);
	   
	   // Remove unwanted parameters.
	   // RIM installation state is the seventh parameter
	   PCHAR rim_installation_state = strtok(module_counts, ",");
	   rim_installation_state = strtok(NULL, ",");
	   rim_installation_state = strtok(NULL, ",");
	   rim_installation_state = strtok(NULL, ",");
	   rim_installation_state = strtok(NULL, ",");
	   rim_installation_state = strtok(NULL, ",");
      rim_installation_state = strtok(NULL, ",");
      
      CHAR buf[10];
      if ((rim_installation_state != NULL) && (_strcmpi(rim_installation_state, "Y") == 0)) {
         value->setResponse(_itoa(RIM_INSTALLED, buf, 10));
      }
      else {
         value->setResponse(_itoa(RIM_NOT_INSTALLED, buf, 10));
      }
	   free (module_counts);
   }
   
   return err;
}


INT PhaseAInputVoltagePollParam ::  ProcessValue(PMessage value, List* )
{
   PCHAR ups_response = value->getResponse();
   PCHAR input_voltage_frequency = _strdup(ups_response);
   
   // Phase A input voltage is the first parameter
   
   const PCHAR cVoltage_Frequency_Separator = ";";
   const PCHAR cVoltage_Separator = ",";
   PCHAR input_voltages = strtok(input_voltage_frequency,cVoltage_Frequency_Separator);
   
   PCHAR  phase_a_input_voltage = strtok(input_voltages,cVoltage_Separator );
   
   value->setResponse(phase_a_input_voltage);
   
   free (input_voltage_frequency);
   
   return ErrNO_ERROR;
}

INT PhaseBInputVoltagePollParam ::  ProcessValue(PMessage value, List* )
{
   PCHAR ups_response = value->getResponse();
   PCHAR input_voltage_frequency = _strdup(ups_response);
   const PCHAR cZeroVoltage = "0.0";
   
   // Phase B input voltage is the second parameter before the 
   // the frequency separator.  Phase B input voltage may not
   // be provided in the case of single phase input.
   const PCHAR cVoltage_Parameter_Separator = ",";
   const PCHAR cVoltage_Frequency_Separator = ";";
   
   PCHAR input_voltages = strtok(input_voltage_frequency,cVoltage_Frequency_Separator );
   PCHAR phase_b_input_voltage = strtok(input_voltages, cVoltage_Parameter_Separator);
   if (phase_b_input_voltage != NULL) 
   {
      phase_b_input_voltage = strtok(NULL, cVoltage_Parameter_Separator);
      if (phase_b_input_voltage == NULL) 
      {
         phase_b_input_voltage = cZeroVoltage;
      }
   }
   else 
   {
      phase_b_input_voltage = cZeroVoltage;
   }
   
   value->setResponse(phase_b_input_voltage);
   
   free (input_voltage_frequency);
   
   return ErrNO_ERROR;
}

INT PhaseCInputVoltagePollParam ::  ProcessValue(PMessage value, List* )
{
   PCHAR ups_response = value->getResponse();
   PCHAR input_voltage_frequency = _strdup(ups_response);
   const PCHAR cZeroVoltage = "0.0";
   
   // Phase C input voltage is the third parameter before the 
   // the frequency separator.  Phase C input voltage may not
   // be provided in the case of single phase input.
   
   const PCHAR cVoltage_Parameter_Separator = ",";
   const PCHAR cFrequency_Parameter_Separator = ";";
   PCHAR input_voltages = strtok(input_voltage_frequency,cFrequency_Parameter_Separator ); 
   
   PCHAR  phase_c_input_voltage = strtok(input_voltages, cVoltage_Parameter_Separator); 
   if (phase_c_input_voltage != NULL) 
   {
      phase_c_input_voltage = strtok(NULL, cVoltage_Parameter_Separator);
      if (phase_c_input_voltage != NULL) 
      {
         phase_c_input_voltage = strtok(NULL, cVoltage_Parameter_Separator);  
         if (phase_c_input_voltage == NULL) 
         {
            phase_c_input_voltage = cZeroVoltage;  
         }  
      }
      else 
      {
         phase_c_input_voltage = cZeroVoltage;  
      }
   }
   else 
   {
      phase_c_input_voltage = cZeroVoltage;  
   }
   
   value->setResponse(phase_c_input_voltage);
   
   free (input_voltage_frequency);
   
   return ErrNO_ERROR;
}

INT InputFrequencyPollParam ::  ProcessValue(PMessage value, List* )
{
   const PCHAR cFrequency_Parameter_Separator = ";";
   
   PCHAR ups_response = value->getResponse();
   PCHAR input_voltage_frequency = _strdup(ups_response);
   PCHAR  input_voltages = strtok(input_voltage_frequency,cFrequency_Parameter_Separator ); 
   
   PCHAR  input_frequency = strtok(NULL, cFrequency_Parameter_Separator); 
   value->setResponse(input_frequency);
   
   free (input_voltage_frequency);
   
   return ErrNO_ERROR;
}

INT NumberOfInputPhasesPollParam ::  ProcessValue(PMessage value, List* )
{
   const PCHAR cFrequency_Parameter_Separator = ";";
   const PCHAR cVoltage_Parameter_Separator = ",";
   
   PCHAR ups_response = value->getResponse();
   PCHAR input_voltage_frequency = _strdup(ups_response);
   PCHAR  input_voltages = strtok(input_voltage_frequency,cFrequency_Parameter_Separator ); 
   
   input_voltages = strtok(input_voltages, cVoltage_Parameter_Separator); 
   input_voltages = strtok(NULL, cVoltage_Parameter_Separator); 
   
   INT number_of_input_phases;
   if (input_voltages != NULL) 
   {
      input_voltages = strtok(NULL, cVoltage_Parameter_Separator); 
      if (input_voltages != NULL) 
      {
         number_of_input_phases = 3;
      }
      else 
      {
         number_of_input_phases = 2;
      }
   }
   else 
   {
      number_of_input_phases = 1;
   }
   CHAR phases_string[8];
   _itoa(number_of_input_phases,phases_string,10);
   
   value->setResponse(phases_string);
   
   free (input_voltage_frequency);
   
   return ErrNO_ERROR;
}

INT PhaseAOutputVoltagePollParam ::  ProcessValue(PMessage value, List* )
{
   PCHAR ups_response = value->getResponse();
   PCHAR output_voltage_currents = _strdup(ups_response);
   
   // Phase A output voltage is the first parameter
   
   const PCHAR cVoltage_Current_Separator = ";";
   const PCHAR cVoltage_Separator = ",";
   
   PCHAR output_voltages = strtok(output_voltage_currents,cVoltage_Current_Separator);
   PCHAR phase_a_output_voltage = strtok(output_voltages,cVoltage_Separator );
   
   value->setResponse(phase_a_output_voltage);
   free (output_voltage_currents);
   
   return ErrNO_ERROR;
}


INT PhaseBOutputVoltagePollParam ::  ProcessValue(PMessage value, List* )
{
   PCHAR ups_response = value->getResponse();
   PCHAR output_voltage_current = _strdup(ups_response);
   const PCHAR cZeroVoltage = "0.0";
   
   // Phase B output voltage is the second parameter
   // Phase B output voltage may not be provided in 
   // the case of single phase input.
   const PCHAR cVoltage_Parameter_Separator = ",";
   const PCHAR cVoltage_Current_Separator = ";";
   
   PCHAR output_voltages = strtok(output_voltage_current,cVoltage_Current_Separator );
   PCHAR phase_b_output_voltage = strtok(output_voltages, cVoltage_Parameter_Separator);
   if (phase_b_output_voltage != NULL) 
   {
      phase_b_output_voltage = strtok(NULL, cVoltage_Parameter_Separator);
      if (phase_b_output_voltage == NULL) 
      {
         phase_b_output_voltage = cZeroVoltage;
      }
   }
   else 
   {
      phase_b_output_voltage = cZeroVoltage;
   }
   
   value->setResponse(phase_b_output_voltage);
   
   free (output_voltage_current);
   
   return ErrNO_ERROR;
}

INT PhaseCOutputVoltagePollParam ::  ProcessValue(PMessage value, List* )
{
   PCHAR ups_response = value->getResponse();
   PCHAR output_voltage_current = _strdup(ups_response);
   
   // Phase C output voltage is the third parameter before the 
   // the current separator.  Phase C output voltage may not
   // be provided in the case of single phase output.
   
   const PCHAR cVoltage_Parameter_Separator = ",";
   const PCHAR cVoltage_Current_Separator = ";";
   const PCHAR cZeroVoltage = "0.0";
   
   PCHAR output_voltages = strtok(output_voltage_current, cVoltage_Current_Separator); 
   
   PCHAR  phase_c_output_voltage = strtok(output_voltages, cVoltage_Parameter_Separator); 
   if (phase_c_output_voltage != NULL) 
   {
      phase_c_output_voltage = strtok(NULL, cVoltage_Parameter_Separator);
      if (phase_c_output_voltage != NULL) 
      {
         phase_c_output_voltage = strtok(NULL, cVoltage_Parameter_Separator); 
         if (phase_c_output_voltage == NULL) 
         {
            phase_c_output_voltage = cZeroVoltage; 
         }  
      }
      else 
      {
         phase_c_output_voltage = cZeroVoltage; 
      }
   }
   else 
   {
      phase_c_output_voltage = cZeroVoltage; 
   }
   
   value->setResponse(phase_c_output_voltage);
   
   free (output_voltage_current);
   
   return ErrNO_ERROR;
}

INT NumberOfOutputPhasesPollParam ::  ProcessValue(PMessage value, List* )
{
   const PCHAR cCurrent_Parameter_Separator = ";";
   const PCHAR cVoltage_Parameter_Separator = ",";
   
   PCHAR ups_response = value->getResponse();
   PCHAR output_voltage_current = _strdup(ups_response);
   PCHAR output_voltages = strtok(output_voltage_current,cCurrent_Parameter_Separator ); 
   
   output_voltages = strtok(output_voltages,cVoltage_Parameter_Separator); 
   output_voltages = strtok(NULL,cVoltage_Parameter_Separator); 
   
   INT number_of_output_phases;
   if (output_voltages != NULL) 
   {
      output_voltages = strtok(NULL,cVoltage_Parameter_Separator); 
      if (output_voltages != NULL) 
      {
         number_of_output_phases = 3;
      }
      else 
      {
         number_of_output_phases = 2;
      }
   }
   else 
   {
      number_of_output_phases = 1;
   }
   CHAR phases_string[8];
   _itoa(number_of_output_phases,phases_string,10);
   
   value->setResponse(phases_string);
   
   free (output_voltage_current);
   
   return ErrNO_ERROR;
}


#if (C_OS & C_OS2)
INT  BattCalibrateCondPollParam::  ProcessValue(PMessage value, List* )
#else
INT  BattCalibrationCondPollParam::  ProcessValue(PMessage value, List* )
#endif
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( BATTERYCALIBRATIONMASK & cur_state )     // Bitwise OR
   {
      value->setResponse(_itoa(BATTERY_CALIBRATION_IN_PROGRESS,buffer,10));
      theCurrentState = BATTERY_CALIBRATED;
   }
   else if (BATTERYCALIBRATIONMASK & theCurrentState)
   {
      value->setResponse(_itoa(NO_BATTERY_CALIBRATION_IN_PROGRESS,buffer,10));
      theCurrentState = NO_BATTERY_CALIBRATION;
   }
   return ErrNO_ERROR;
}



INT  StateRegisterPollParam:: IsPollSet()
{
   if (!thePollSet)
   {
      thePollSet = TRUE;
      return ErrSTATE_SET;
   }
   return ErrSAME_VALUE;
}


INT StateRegisterPollParam::  ProcessValue(PMessage value, List* events)
{
   int  event_code = 0;
   int  event_value = 0;
   int  err = ErrCONTINUE;
   
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (!events) {
      return ErrNO_VALUE;
   }
   
   int cur_state = 0;
   
   if (sscanf(value->getResponse(),"%x",&cur_state) == EOF) {
     return ErrREAD_FAILED;
   }
   
   CHAR cause[32];
   if ( COMPSELECTBYPASSMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(BYPASS_MODE, UPS_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_SOFTWARE);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   else if (COMPSELECTBYPASSMASK & theCurrentState)  {
      PEvent tmp = new Event(BYPASS_MODE, UPS_NOT_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_SOFTWARE);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   
   if ( SWITCHEDBYPASSMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(BYPASS_MODE, UPS_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_SWITCH);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   else if (SWITCHEDBYPASSMASK & theCurrentState)  {
      PEvent tmp = new Event(BYPASS_MODE, UPS_NOT_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_SWITCH);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   
   theCurrentState = (USHORT) cur_state;
   
   //
   // Convert value from HEX to decimal for every one else
   //
   CHAR int_value[32];
   sprintf(int_value, "%d", cur_state);
   value->setResponse(int_value);
   
   return err;
}


INT  TripRegisterPollParam:: IsPollSet()
{
   if (!thePollSet)
   {
      thePollSet = TRUE;
      return ErrTRIP_SET;
   }
   return ErrSAME_VALUE;
}


INT TripRegisterPollParam::  ProcessValue(PMessage value, List* events)
{
   int  event_code = 0;
   int  event_value = 0;
   int  err = ErrCONTINUE;
   
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (!events) {
      return ErrNO_VALUE;
   }
   
   int cur_state = 0;
   
   if (sscanf(value->getResponse(),"%x",&cur_state) == EOF) {
      return ErrREAD_FAILED;
   }
   
   CHAR cause[32];
   if ( OVERTEMPMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(BYPASS_MODE, UPS_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_INTERNAL_TEMP);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   else if (OVERTEMPMASK & theCurrentState)  {
      PEvent tmp = new Event(BYPASS_MODE, UPS_NOT_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_INTERNAL_TEMP);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   
   if ( BATTERYCHARGERMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(BYPASS_MODE, UPS_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_BATT_CHARGER_FAILED);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   else if (BATTERYCHARGERMASK & theCurrentState)  {
      PEvent tmp = new Event(BYPASS_MODE, UPS_NOT_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_BATT_CHARGER_FAILED);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   
   theCurrentState = (USHORT) cur_state;
   
   //
   // Convert value from HEX to decimal for every one else
   //
   CHAR int_value[32];
   sprintf(int_value, "%d", cur_state);
   value->setResponse(int_value);
   
   return err;
}


INT  Trip1RegisterPollParam:: IsPollSet()
{
   if (!thePollSet)
   {
      thePollSet = TRUE;
      return ErrTRIP1_SET;
   }
   return ErrSAME_VALUE;
}



INT Trip1RegisterPollParam::  ProcessValue(PMessage value, List* events)
{
   int  err = ErrCONTINUE;
   
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if (!events) {
      return ErrNO_VALUE;
   }
   
   int cur_state = 0;
   
   if (sscanf(value->getResponse(),"%x",&cur_state) == EOF) {
      return ErrREAD_FAILED;
   }
   
   if ( BOTTOMFANFAILUREMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(MATRIX_FAN_STATE, FAN_FAILURE_IN_BOTTOM_BOX);
      events->Append(tmp);
   }
   else if (BOTTOMFANFAILUREMASK & theCurrentState)  {
      PEvent tmp = new Event(MATRIX_FAN_STATE, FAN_OK);
      events->Append(tmp);
   }
   
   
   if ( BYPASSPOWERSUPPLYMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(BYPASS_POWER_SUPPLY_CONDITION, BYPASS_POWER_SUPPLY_OK);
      events->Append(tmp);
   }
   else if (BYPASSPOWERSUPPLYMASK & theCurrentState)  {
      PEvent tmp = new Event(BYPASS_POWER_SUPPLY_CONDITION, BYPASS_POWER_SUPPLY_FAULT);
      events->Append(tmp);
   }
   
   
   
   CHAR cause[32];
   if ( BYPASSDCIMBALANCEMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(BYPASS_MODE, UPS_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_DC_IMBALANCE);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   else if (BYPASSDCIMBALANCEMASK & theCurrentState)  {
      PEvent tmp = new Event(BYPASS_MODE, UPS_NOT_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_DC_IMBALANCE);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   
   if ( BYPASSOUTPUTLIMITSMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(BYPASS_MODE, UPS_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_VOLTAGE_LIMITS);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   else if (BYPASSOUTPUTLIMITSMASK & theCurrentState)  {
      PEvent tmp = new Event(BYPASS_MODE, UPS_NOT_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_VOLTAGE_LIMITS);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   
   if ( TOPFANFAILUREMASK & cur_state )              // Bitwise OR
   {
      PEvent tmp = new Event(BYPASS_MODE, UPS_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_TOP_FAN_FAILURE);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   else if (TOPFANFAILUREMASK & theCurrentState)  {
      PEvent tmp = new Event(BYPASS_MODE, UPS_NOT_ON_BYPASS);
      if (tmp != NULL) {
        sprintf(cause, "%d", BYPASS_BY_TOP_FAN_FAILURE);
        tmp->AppendAttribute(BYPASS_CAUSE, cause);
        events->Append(tmp);
      }
   }
   
   theCurrentState = (USHORT) cur_state;
   
   //
   // Convert value from HEX to decimal for every one else
   //
   CHAR int_value[32];
   sprintf(int_value, "%d", cur_state);
   value->setResponse(int_value);
   
   
   return err;
}


INT  BypassPowerSupplyPollParam::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   
   if ( BYPASSPOWERSUPPLYMASK & cur_state )     // Bitwise OR
   {
      value->setResponse(_itoa(BYPASS_POWER_SUPPLY_FAULT,buffer,10));
      theCurrentState = BYPASSPOWERSUPPLYMASK;
   }
   else if (BYPASSPOWERSUPPLYMASK & theCurrentState)
   {
      value->setResponse(_itoa(BYPASS_POWER_SUPPLY_OK,buffer,10));
      theCurrentState = 0;
   }
   return ErrNO_ERROR;
}

INT  FanFailurePollParam::  ProcessValue(PMessage value, List* )
{
   char buffer[20];
   
   int cur_state = UtilHexStringToInt(value->getResponse());
   
   if ( BOTTOMFANFAILUREMASK & cur_state )     // Bitwise OR
   {
      value->setResponse(_itoa(FAN_FAILURE_IN_BOTTOM_BOX,buffer,10));
      theCurrentState = BOTTOMFANFAILUREMASK;
   }
   else if ( TOPFANFAILUREMASK & cur_state )     // Bitwise OR
   {
      value->setResponse(_itoa(FAN_FAILURE_IN_TOP_BOX,buffer,10));
      theCurrentState = TOPFANFAILUREMASK;
   }
   else if (BYPASSPOWERSUPPLYMASK & theCurrentState)
   {
      value->setResponse(_itoa(FAN_OK,buffer,10));
      theCurrentState = 0;
   }
   return ErrNO_ERROR;
}

INT BypassModePollParam::  ProcessValue(PMessage value, List* )
{
   if ( NullTest(value->getResponse()) )
      return ErrREAD_FAILED;
   
   if ( (strcmp(value->getResponse(), BYPASS_IN_BYPASS)) && 
      (strcmp(value->getResponse(), BYPASS_OUT_OF_BYPASS)) )
   { 
      return ErrINVALID_VALUE;
   }
   return ErrNO_ERROR;
}

INT
MUpsTempPollParam::ProcessValue(
                                PMessage value,
                                List* )
{
   INT err = ErrNO_ERROR;
   
   if ( NullTest(value->getResponse()) ) {
      err = ErrNO_MEASURE_UPS;
   }
   else if ( (strlen(value->getResponse()) != 5) ||
      (((value->getResponse())[2]) != '.')) {
      err = ErrBAD_RESPONSE_VALUE;
   }
   return( err );
}



INT
MUpsHumidityPollParam::ProcessValue(
                                    PMessage value,
                                    List* )
{
   INT err = ErrNO_ERROR;
   
   if ( NullTest(value->getResponse()) ) {
      err = ErrNO_MEASURE_UPS;
   }
   else if ( (strlen(value->getResponse()) != 5) ||
      (((value->getResponse())[3]) != '.')) {
      err = ErrBAD_RESPONSE_VALUE;
   }
   return( err );
}


INT
MUpsContactPosPollParam::ProcessValue(
                                      PMessage value,
                                      List* )
{
   INT err = ErrNO_ERROR;
   
   if ( NullTest(value->getResponse()) ) {
      err = ErrNO_MEASURE_UPS;
   }
   else if (strlen(value->getResponse()) != 2) {
      err = ErrBAD_RESPONSE_VALUE;
   }
   return( err );
}

INT
MUpsFirmwareRevPollParam::ProcessValue(
                                       PMessage value,
                                       List* )
{
   INT err = ErrNO_ERROR;
   PCHAR resp = value->getResponse(); 
   
   if ( NullTest(resp) ) {
      err = ErrNO_MEASURE_UPS;
   }
   else if ((strlen(resp) != 3) || (resp[0] != '4') || (resp[2] != 'x')) {
      err = ErrBAD_RESPONSE_VALUE;
   }
#ifdef MUPSCLEANUPFIRMWAREREV
   else {
      char buffer[2];
      
      buffer[0] = resp[1];
      buffer[1] = '\0';
      value->setResponse(buffer);
   }
#endif
   return( err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\protlist.h ===
/*
 *
 * NOTES:
 *
 *  ProtectedList:
 *
 *   Wraps the List class with a mutex lock. Each public method is
 *   protected first by accessing the mutex.  The entire list can
 *   be grabbed by using Access, ungrabbed by calling Release.
 *   You would want to Access the list almost always when using it,
 *   otherwise other threads could change the list without your
 *   knowledge, exactly what this class is trying to prevent
 *
 * REVISIONS:
 *  pcy29Nov92: Use PObj rather than PNode for return values
 *  pcy21Apr93: OS2 FE merge
 *  cad09Jul93: using new semaphores
 *  cad31Aug93: removing compiler warnings
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  mwh05May94: #include file madness , part 2
 *  mwh08Apr97: add Access,Release methods & NOTES section
 */

#ifndef _PROTLIST_H
#define _PROTLIST_H

#include "list.h"

_CLASSDEF(ProtectedList)
_CLASSDEF(MutexLock)

class ProtectedList : public List {

private:
    PMutexLock accessLock;

protected:
    VOID Request() const;
    VOID Clear() const;
   
public:
    ProtectedList ();
    ProtectedList(ProtectedList*);
    virtual ~ProtectedList();

    virtual VOID   Add( RObj );
    virtual VOID   Detach( RObj );

    virtual VOID   Flush();
    virtual VOID   FlushAll();

    virtual INT    GetItemsInContainer() const;
    virtual RListIterator InitIterator() const;

    virtual VOID   Append(PObj);
    virtual PObj   GetHead();
    virtual PObj   Find(PObj);

    //
    // Use Access to lock the entire list object
    // useful to block access completely to any other thread
    // while one thread uses the list - don't forget to
    // call Release when you're done - NOTE: although it
    // is possible to still access this object w/o calling
    // Access first, all of the public calls are protected
    // by first trying to gain Access to the object first
    //
    VOID Access() const;

    //
    // Unlocks a list object that has been locked
    // by a thread
    //
    VOID Release() const;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\proto.cxx ===
/*
 * REVISIONS:
 *  pcy29Nov92: New defines from codes.h
 *  sja08Dec92: Changed #define BATTERY_TYPE to RATED_BATTERY_VOLTAGE
 *  jod13Jan93: Added eventList to InterpretMessage
 *  jod28Jan93: Added fixes for support of Data and Decrement Sets
 *  pcy02Feb93: InterpretSetMessage needs to return a value
 *  ane03Feb93: Changed BuildPollTransactionGroupMessages to check IsPollSet
 *              differently
 *  jod14Feb93: Handle mulit char sets (@ddd, KK, etc)
 *  pcy16Feb92: Move UPS_STATE_SET define to err.h to avoid conflicts
 *  pcy16Feb92: Allow gets of UpsState params
 *  pcy16Feb93: Made battery test results pollable
 *  pcy21Apr93: OS/2 2.0 FE Merge
 *  jod05Apr93: Added changes for Deep Discharge
 *  jod14May93: Added Matrix changes.
 *  cad10Jun93: Added Mups parms
 *  cad22Jul93: Fixed up destructor conflicts and omissions
 *  cad27Aug93: Added MeasureUPS firmware poll param
 *  rct05Nov93: Added a useful destructor
 *  jps14Jul94: added stdlib.h for os2
 *  ajr08Nov95: SINIX Port
 */

#define INCL_BASE
#define INCL_NOPM
/* #define INCL_NOPMAPI  jwa */

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <stdlib.h>
#endif
}

#include "pollparm.h"
#include "trans.h"
#include "proto.h"


INT Protocol::currentTransactionId = 0;

Protocol::Protocol()
{
   theOriginalTransactionItem = (PTransactionItem)NULL;
   theCurrentTransactionGroup = (PTransactionGroup)NULL;

   for (int i=0; i<PROTOSIZE; i++)
      {
       ProtoList[i] = (PPollParam)NULL;
      }
}

Protocol::~Protocol()
{
   for (int i=0; i<PROTOSIZE; i++)
      {
      if (ProtoList[i] != (PPollParam) NULL) {
       delete (PPollParam) ProtoList[i];
       ProtoList[i] = NULL;
      }
}
}

INT Protocol::IsEventCodePollable(INT aCode)
{
   PollParam* poll_param = ProtoList[aCode];
   if(poll_param)
      {
      if (poll_param->isPollable())
         {
       return TRUE;
         }
      }
   return FALSE;
}

VOID Protocol::SetCurrentTransactionGroup(PTransactionGroup aTransactionGroup)
{
    theCurrentTransactionGroup = aTransactionGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\replbatt.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  ker04DEC92: Added Validate Function
 *  dma10Nov97: Added virtual destructor for ReplaceBatterySensor class.
 *  dma06Feb98: Added register/unregister for BATTERY_REPLACEMENT_CONDITION
 *  tjg25Feb98: Added update method to handle problems with 2G replace
 *              battery notifications
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "replbatt.h"
#include "comctrl.h"
#include "event.h"
#include "device.h"


ReplaceBatterySensor :: ReplaceBatterySensor(PDevice aParent, PCommController aCommController)
			  : StateSensor(aParent, aCommController, BATTERY_REPLACEMENT_CONDITION)
{
    storeState(BATTERY_DOESNT_NEED_REPLACING);
    theCommController->RegisterEvent(BATTERY_REPLACEMENT_CONDITION, this);
    
}

ReplaceBatterySensor :: ~ReplaceBatterySensor()
{
   theCommController->UnregisterEvent(BATTERY_REPLACEMENT_CONDITION, this);
}


INT ReplaceBatterySensor :: Update(PEvent anEvent)
{
   INT err = ErrNO_ERROR;

   INT event_code = anEvent->GetCode();
   PCHAR event_value = anEvent->GetValue();
   
   // Ensure that the new value is different from the cached value
   if (err = Validate(event_code, event_value) == ErrNO_ERROR) {

      // If battery needs replacing ....
      if (atoi(event_value) == BATTERY_NEEDS_REPLACING) {
         CHAR buffer[16] = {NULL};
         theDevice->Get(LIGHTS_TEST, buffer);

         // ... and UPS is NOT doing a lights test
         if (atoi(buffer) != LIGHTS_TEST_IN_PROGRESS) {
            // store the new value in the cache and tell the world
            storeValue(event_value);
            UpdateObj::Update(anEvent);
         }
      }

      // If battery doesn't need replacing, store the new value in
      // the cache and tell the world
      else if (atoi(event_value) == BATTERY_DOESNT_NEED_REPLACING) {
         storeValue(event_value);
         UpdateObj::Update(anEvent);
      }
   }

   return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\protsmrt.h ===
/*
 * NOTES:
 *
 * REVISIONS:
 *  jod30Nov92: Added GCIP object stuff 
 *  jod02Dec92: Fixed Jim's sloppy code
 *  jod13Jan93: Added eventList to InterpretMessage
 *  pcy21Apr93: OS2 FE merge
 *  pcy21May93: PROTOSIZE changed from 2600 to 8000
 *  cad22Jul93: Fixed up destructor conflicts and omissions
 *  pcy17Aug93: Removing strtok() requires new arg in InterpretParameters
 *  cad28Sep93: Made sure destructor(s) virtual
 *  cad07Oct93: Made methods virtual
 *  djs22Feb96: Added ChangeSet method
 *  cgm04May96: TestResponse now uses BufferSize
 */
#ifndef __PROTSMRT_H
#define __PROTSMRT_H

#include "_defs.h"
#include "apc.h"

//
// Defines
//
_CLASSDEF(UpsLinkProtocol)

//
// Implementation uses
//
#include "protsimp.h"
#include "err.h"
#include "trans.h"

//
//  Interface uses
//
_CLASSDEF(List)
_CLASSDEF(Message)


class UpsLinkProtocol : public SimpleUpsProtocol
{
  private:
    PCHAR FindCRLF(PCHAR InBuffer);
  protected:
    virtual VOID EventSearch(PCHAR Buffer, PList eventlist);
    virtual VOID SetupMessage(PMessage msg);
    virtual INT InterpretSetMessage(PMessage msg, PList newmsglist);
    
  public:
    UpsLinkProtocol();
    VOID InitProtocol();
    virtual INT BuildPollTransactionGroupMessages(PTransactionGroup 
						  aTransactionGroup);
    virtual INT BuildMessage(PMessage msg, PList msglist=(PList)NULL);
    virtual INT InterpretMessage(PMessage msg, PList eventList, 
				 PList newmsglist=(PList)NULL);
    virtual INT TestResponse(PMessage msg,PCHAR Buffer,USHORT BufferSize);

    virtual PList BuildTransactionMessageList(Type aType, INT aCode, 
					      PCHAR aValue);
    virtual PList BuildDataSetMessage(INT aCode, PCHAR aValue);
    virtual PList BuildDecrementSetMessage(INT aCode, PCHAR aValue);
    virtual PList BuildPauseSetMessage(INT aCode, PCHAR aValue);
    virtual PList BuildChangeSetMessage(INT aCode, PCHAR aValue);
    virtual INT BuildPollMessage(PMessage msg, PList msglist=(PList)NULL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\proto.h ===
/*
 * REVISIONS:
 *  jod30Nov92: Added GCIP object stuff 
 *  jod02Dec92: Fixed Jim's sloppy code
 *  jod13Jan93: Added eventList to InterpretMessage
 *  pcy21Apr93: OS2 FE merge
 *  pcy21May93: PROTOSIZE changed from 2600 to 8000
 *  cad22Jul93: Fixed up destructor conflicts and omissions
 *  pcy17Aug93: Removing strtok() requires new arg in InterpretParameters
 *  rct05Nov93: moved destructor to CXX file
 *  ajr08Mar94: Increased the size of PROTOSIZE to reflect changes someone
 *              made in codes.h
 *
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  cgm04May96: TestResponse now uses BufferSize
 */
#ifndef __PROTOCOL_H
#define __PROTOCOL_H

#include "_defs.h"
#include "apc.h"

//
// Defines
//
_CLASSDEF(Protocol)

//
// Implementation uses
//
#include "err.h"
#include "trans.h"
#include "pollparm.h"

//
//  Interface uses
//
_CLASSDEF(List)
_CLASSDEF(Message)



#define PROTOSIZE     10000

class Protocol
{
  protected:
    PPollParam ProtoList[PROTOSIZE];

    static INT        currentTransactionId;  //mwh changed from int

    PTransactionItem  theOriginalTransactionItem;
    PTransactionGroup theCurrentTransactionGroup;
  public:
    Protocol();
    virtual ~Protocol();
    virtual INT BuildTransactionGroupMessages(PTransactionGroup agroup) = 0;
    virtual INT BuildPollTransactionGroupMessages(PTransactionGroup 
                          aTransactionGroup) = 0;
    virtual INT InterpretMessage(PMessage msg, PList eventList, 
                 PList newmsglist=(PList)NULL) = 0;
    virtual PTransactionGroup  InterpretTransactionGroup(PCHAR msg) = 0;
    virtual INT TestResponse(PMessage msg,PCHAR Buffer,USHORT BufferSize) =0;
    VOID SetCurrentTransactionGroup(PTransactionGroup current);
    PTransactionGroup GetCurrentTransactionGroup() {return theCurrentTransactionGroup;};
    INT IsEventCodePollable(INT aCode);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\protsimp.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  jod30Nov92: Added GCIP object stuff 
 *  jod02Dec92: Fixed Jim's sloppy code
 *  jod13Jan93: Added eventList to InterpretMessage
 *  pcy21Apr93: OS2 FE merge
 *  pcy21May93: PROTOSIZE changed from 2600 to 8000
 *  cad22Jul93: Fixed up destructor conflicts and omissions
 *  pcy17Aug93: Removing strtok() requires new arg in InterpretParameters
 *  cad28Sep93: Made sure destructor(s) virtual
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  cgm04May96: TestResponse uses BufferSize
 */
#ifndef __PROTSIMP_H
#define __PROTSIMP_H

#include "_defs.h"
#include "apc.h"

//
// Defines
//
_CLASSDEF(SimpleUpsProtocol)

//
// Implementation uses
//
#include "proto.h"
#include "err.h"
#include "trans.h"

//
//  Interface uses
//
_CLASSDEF(List)
_CLASSDEF(Message)




class SimpleUpsProtocol : public Protocol
{
  protected:
    PList theEventList;
    virtual  PList BuildTransactionMessageList(Type , INT , PCHAR);
    PList BuildGetMessage(INT );
    virtual PList BuildStandardSetMessage(INT , PCHAR);
    
  public:
    SimpleUpsProtocol();
    virtual ~SimpleUpsProtocol();
    virtual VOID InitProtocol();
    virtual INT BuildTransactionGroupMessages(PTransactionGroup );
    virtual INT BuildPollTransactionGroupMessages(PTransactionGroup );
    virtual INT BuildMessage(PMessage msg, PList msglist=(PList)NULL);
    virtual PTransactionGroup  InterpretTransactionGroup(PCHAR) 
    {return (PTransactionGroup)NULL;}
    virtual INT InterpretMessage(PMessage msg, PList eventList, 
				 PList newmsglist=(PList)NULL);
    virtual INT TestResponse(PMessage msg,PCHAR Buffer,USHORT BufferSize) {return ErrNO_ERROR;};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\regdefs.h ===
//Generated code, do not edit...


#ifndef _REGDEFS_H_
#define _REGDEFS_H_


#ifdef __cplusplus
extern "C"{
#endif


  ServiceProviderStructure _theStaticProvidersTable[] = {
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Back-UPS"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Back-UPS Pro"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Basic Port on Communications Accessory"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Basic signaling to any APC UPS"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Matrix-UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("PowerStack"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Smart-UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Smart signaling to any APC UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Symmetra Power Array"), TEXT("0x7F;apcups.dll")},
    {NULL, NULL, NULL}
  };


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\protsimp.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy29Nov92: New defines from codes.h
 *  sja08Dec92: Changed #define BATTERY_TYPE to RATED_BATTERY_VOLTAGE
 *  jod13Jan93: Added eventList to InterpretMessage
 *  jod28Jan93: Added fixes for support of Data and Decrement Sets
 *  pcy02Feb93: InterpretSetMessage needs to return a value
 *  ane03Feb93: Changed BuildPollTransactionGroupMessages to check IsPollSet
 *              differently
 *  jod14Feb93: Handle mulit char sets (@ddd, KK, etc)
 *  pcy16Feb92: Move UPS_STATE_SET define to err.h to avoid conflicts
 *  pcy16Feb92: Allow gets of UpsState params
 *  pcy16Feb93: Made battery test results pollable
 *  pcy21Apr93: OS/2 2.0 FE Merge
 *  jod05Apr93: Added changes for Deep Discharge
 *  jod14May93: Added Matrix changes.
 *  cad10Jun93: Added Mups parms
 *  cad22Jul93: Fixed up destructor conflicts and omissions
 *  cad27Aug93: Added MeasureUPS firmware poll param
 *  cad07Oct93: Plugging Memory Leaks
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  mwh01Jun94: port for INTERACTIVE
 *  jps14Jul94: commented out INCL_NOPMAPI
 *  ajr15Feb96: Sinix Merge
 *  cgm23Jul97: BuildStandardSetMessage creates Message(aCode,SET)
 *
 *  v-stebe  29Jul2000   Fixed PREfix errors (bugs #46353-#46355)
 */
#define INCL_BASE
#define INCL_NOPM
/* #define INCL_NOPMAPI  jwa */

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <process.h>
#include <os2.h>
#endif
#include <stdlib.h>
#if (!(C_OS & C_INTERACTIVE))
#include <malloc.h>
#endif
#include <string.h>
#include <time.h>
}

#include "_defs.h"
#include "event.h"
#include "codes.h"
#include "message.h"
#include "pollparm.h"
#include "trans.h"
#include "protsimp.h"
#include "err.h"

#if (C_OS & C_UNIX)
#include "utils.h"
#endif




SimpleUpsProtocol::  SimpleUpsProtocol() : Protocol()
{
   InitProtocol();
}

SimpleUpsProtocol::  ~SimpleUpsProtocol()
{
}

VOID SimpleUpsProtocol::InitProtocol()
{
   char buffer[5];

   for(int i=0; i<PROTOSIZE; i++)  {
   	ProtoList[i]=(PollParam*)NULL;
   }

   ProtoList[UTILITY_LINE_CONDITION] = new SimplePollParam(UTILITY_LINE_CONDITION, _itoa(UTILITY_LINE_CONDITION,buffer,10), 0, POLL);
   ProtoList[BATTERY_CONDITION] = new SimplePollParam(BATTERY_CONDITION, _itoa(BATTERY_CONDITION,buffer,10), 0, POLL);
   ProtoList[TURN_OFF_UPS] = new SimplePollParam(TURN_OFF_UPS, _itoa(TURN_OFF_UPS,buffer,10), 0, NO_POLL);
   ProtoList[TURN_ON_SMART_MODE] = new SimplePollParam(TURN_ON_SMART_MODE, _itoa(TURN_ON_SMART_MODE,buffer,10), 0, NO_POLL);
   ProtoList[TURN_OFF_UPS_ON_BATTERY] = new SimplePollParam(TURN_OFF_UPS_ON_BATTERY, _itoa(TURN_OFF_UPS_ON_BATTERY,buffer,10), 0, NO_POLL);

   return;
}

INT   SimpleUpsProtocol :: BuildMessage(Message*, List* )
{
  return 1;
}

INT SimpleUpsProtocol :: BuildPollTransactionGroupMessages(PTransactionGroup aTransactionGroup)
{
  int err = ErrNO_ERROR;

  PTransactionItem theItem = aTransactionGroup->GetFirstTransactionItem();
  while ((theItem != NULL) && (err == ErrNO_ERROR))
  {
       if (ProtoList[theItem->GetCode()] != (PollParam*)NULL)
       {
           PollParam* poll_param = ProtoList[theItem->GetCode()];
          /********************************************************
          *                                                       *
          *  There is no test for POLLABLE in the Simple Protocol *
          *                                                       *
          *********************************************************/
       }
       else
          err = ErrNOT_POLLABLE;

       theItem = aTransactionGroup->GetNextTransactionItem();
  }
  if (err == ErrNO_ERROR)
  {
      err = BuildTransactionGroupMessages(aTransactionGroup);
  }
  return err;
} 

INT SimpleUpsProtocol :: BuildTransactionGroupMessages(PTransactionGroup aTransactionGroup)
{
  int err = ErrNO_ERROR;

  PTransactionItem theItem = aTransactionGroup->GetFirstTransactionItem();
  while ((theItem != NULL) && (err == ErrNO_ERROR))
  {
     List* msglist = BuildTransactionMessageList(theItem->GetType(), theItem->GetCode(), theItem->GetValue());

     if (msglist)
     {
        ListIterator iterator(*msglist);

        PMessage msg = (PMessage)&(iterator.Current());
        while (msg)  {
            theItem->AddMessage(msg);
            PMessage copy_msg = new Message(msg);
            aTransactionGroup->AddMessage(copy_msg);
            msg = (PMessage)iterator.Next();
        }
	// don't flush list, we just gave away all the elements
	delete msglist;
    msglist = NULL;
     }
     else
     {
     	 theItem->SetErrorCode(ErrBUILD_FAILED);
     	 err = ErrBUILD_FAILED;
     }
     theItem = aTransactionGroup->GetNextTransactionItem();
  }
  return err;
}


List* SimpleUpsProtocol :: BuildTransactionMessageList(Type aType, INT aCode, CHAR* aValue)
{
	List* msglist;

	PollParam* poll_param = ProtoList[aCode];

	if(poll_param == NULL)  {
		return (List*)NULL;
	}

	switch(aType)  {
		case GET:
			msglist = BuildGetMessage(aCode);
            break;

		case SET:
			msglist = BuildStandardSetMessage(aCode, aValue);
            break;
	}

	return msglist;
}

List* SimpleUpsProtocol :: BuildGetMessage(INT aCode)
{
    List*  msglist = NULL;

    PMessage msg = new Message(aCode); 

    if (msg)
    {  
       PollParam* poll_param = ProtoList[aCode];
       PCHAR cmd = poll_param->Query();

       msg->setSubmit(cmd);
       msg->setTimeout(poll_param->GetTime());

       msglist = new List();
       msglist->Append(msg);

       free(cmd);
    }
    else  {
	    ;//	setError(ErrMESSAGE_CREATE_FAILED);
    }
    return msglist;
}

List* SimpleUpsProtocol :: BuildStandardSetMessage(INT aCode, CHAR* aValue)
{
  List*  msglist = new List();

  // Really only action type stuff.  How will we deal with commands that
  // require two letters (S, wait 1 seconds, S).  Possibly use
  // TURN_OFF_UPS as the code, and set an inter character delay as part of
  // protocol message.  For now this only handles the simple stuff. 
  PollParam* poll_param = ProtoList[aCode];
  PMessage msg = new Message(aCode,SET);

  CHAR submit_string[50];
  *submit_string = '\0';
  PCHAR cmd = poll_param->Query();

  if (cmd != NULL) {
    strcpy(submit_string,cmd);
    free(cmd);
  }

  if(poll_param->GetSetType() != SIMPLE_SET)  {
    if (aValue)  {
      strcat(submit_string,aValue);
    }
  }

  if (msg != NULL) {
    msg->setSubmit(submit_string);
    msg->setTimeout(poll_param->GetTime());
    msglist->Append(msg);
  }

  return msglist;
}




INT  SimpleUpsProtocol :: InterpretMessage(Message* msg, List* eventList, List* newmsglist)
{
	PList tiList = theCurrentTransactionGroup->GetTransactionItemList();
	TransactionItem tmpti(GET,msg->getId());
    PTransactionItem trans_item = (PTransactionItem)tiList->Find(&tmpti);
    if (trans_item) {
        trans_item->SetErrorCode(msg->getErrcode());
        trans_item->SetValue(msg->getResponse());
    }

#if 0
	 PEvent event = new Event(msg->getId(), msg->getResponse());
//   event->setResponse(msg->getResponse());
	 eventList->Append(event);
#endif
   return ErrNO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\replbatt.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92: Initial break out of sensor classes into separate files 
 *  dma10Nov97: Created virtual destructor for ReplaceBatterySensor class.
 *  tjg02Mar98: Added Update method 
 */
#ifndef REPLBATT_H
#define REPLBATT_H

#include "stsensor.h"
 
_CLASSDEF(ReplaceBatterySensor)

class ReplaceBatterySensor : public StateSensor {

public:
   ReplaceBatterySensor(PDevice aParent, PCommController aCommController=NULL);
   virtual ~ReplaceBatterySensor();
   virtual INT Update(PEvent anEvent);
   virtual INT IsA() const { return REPLACEBATTERYSENSOR; };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\protsmrt.cxx ===
/*
*
* REVISIONS:
*  pcy29Nov92: New defines from codes.h
*  sja08Dec92: Changed #define BATTERY_TYPE to RATED_BATTERY_VOLTAGE
*  jod13Jan93: Added eventList to InterpretMessage
*  jod28Jan93: Added fixes for support of Data and Decrement Sets
*  pcy02Feb93: InterpretSetMessage needs to return a value
*  ane03Feb93: Changed BuildPollTransactionGroupMessages to check IsPollSet
*              differently
*  jod14Feb93: Handle mulit char sets (@ddd, KK, etc)
*  pcy16Feb92: Move UPS_STATE_SET define to err.h to avoid conflicts
*  pcy16Feb92: Allow gets of UpsState params
*  pcy16Feb93: Made battery test results pollable
*  pcy21Apr93: OS/2 2.0 FE Merge
*  jod05Apr93: Added changes for Deep Discharge
*  jod14May93: Added Matrix changes.
*  cad10Jun93: Added Mups parms
*  cad22Jul93: Fixed up destructor conflicts and omissions
*  cad27Aug93: Added MeasureUPS firmware poll param
*  pcy12Sep93: Split off of proto.cxx
*  pcy12Sep93: Made simulate power fail & lights test poll param a simple set
*  cad07Oct93: Plugging Memory Leaks
*  jod02Nov93: Added CIBC conditional statements
*  ajr17Feb94: Made EventSearch check Buffer before using it.
*  jps14Jul94: commented out INCL_NOPMAPI; replaced strtok() call in findCRLF -
*                I think non-reentrency was causing problems in os2
*  jps28aug94: shorted EepromAllowedValues and BattCalibrationCond for os2 1.3
*  djs22Feb96: added CHANGESET
*  cgm16Apr96: testresponse will not test an incomplete response
*  djs07May96: Added Dark Star parameters
*  cgm05Apr96: Fixed TestResponse
*  srt23May96: Modified test response to accept erroneous serial number responses.
*  djs23Oct96: Modified HIGH_TRANSFER_VOLTAGE to use DECREMENTSET
*  dma05Nov97: Added SYSTEM_FAN_STATE to ProtoList
*  mholly12May1999: add TurnOffSmartModePollParam support
*
*  v-stebe  29Jul2000   Added checks for mem. alloc. failures (bugs #46342-46352)
*  v-stebe  05Sep2000   Fixed additional PREfix errors
*/

#define INCL_BASE
#define INCL_NOPM
//#define INCL_NOPMAPI // jwa

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <process.h>
#include <os2.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
}

#include "_defs.h"
#include "event.h"
#include "codes.h"
#include "message.h"
#include "pollparm.h"
#include "ulinkdef.h"
#include "trans.h"
#include "protsmrt.h"
#include "err.h"
#include "cfgmgr.h"

#if (C_OS & C_UNIX)
#include "utils.h"
#endif

#define PAUSEWAIT 2100


UpsLinkProtocol :: UpsLinkProtocol()
: SimpleUpsProtocol()
{
   InitProtocol();
}


CHAR* UpsLinkProtocol :: FindCRLF(CHAR *InBuffer)
{
   PCHAR pszTest;
   for (pszTest = InBuffer; *pszTest != 0; ++pszTest)
   {
      if ((*pszTest == '\r' && *(pszTest + 1) == '\n') || *pszTest == '\n')
      {
         *pszTest = 0;
         return InBuffer;
      }
   }
   return (PCHAR)NULL;
}

/*--------------------------------------------------------------------
*
*       Function...:   EventSearch
*
*       Description:   .
*
*-------------------------------------------------------------------*/
VOID UpsLinkProtocol :: EventSearch(CHAR *Buffer, List* eventlist)
{
   if (Buffer) {
      
      int event_code;
      int event_value;
      BOOL do_event;
      INT  bypass;
      CHAR *tmpstr = Buffer;
      
      while ((tmpstr = strpbrk(tmpstr, ASYNC_CHARS)))
      {
         do_event = TRUE;     // until proven otherwise
         bypass   = FALSE;
         
         switch (*tmpstr)
         {
         case LINEFAILCHAR :
            event_code = UTILITY_LINE_CONDITION;
            event_value = LINE_BAD;
            break;
         case RETLINEFAILCHAR :
            event_code = UTILITY_LINE_CONDITION;
            event_value = LINE_GOOD;
            break;
         case LOWBATERYCHAR :
            event_code = BATTERY_CONDITION;
            event_value = BATTERY_BAD;
            break;
         case RETLLOWBATCHAR:
            event_code = BATTERY_CONDITION;
            event_value = BATTERY_GOOD;
            break;
         case REPLACEBATCHAR:
            if ( *(tmpstr+1) == '#') 
            {
               tmpstr = tmpstr+2;
               bypass = TRUE;
            }
            do_event = FALSE;
            
            
            break;
         case EEPROMCHANGECHAR:
            event_code = EEPROM_CHANGED;
            event_value = EEPROM_CHANGED;
            break;
         case MUPSALARMCHAR:
         case LOADOFFCHAR :
            //                 event = new Message(SHUTDOWN,EVENT);    //SHUTDOWN;
         default :
            do_event = FALSE;
            break;
         }
         
         if (do_event)
         {
            PEvent event = new Event(event_code, event_value);
            eventlist->Append(event);
         }
         
         if (!bypass)
            strcpy(tmpstr, (tmpstr+1));
      }
   }
}

INT   UpsLinkProtocol :: BuildMessage(Message*, List* )
{
   return 1;
}

VOID UpsLinkProtocol :: SetupMessage(Message* msg)
{
   
   int msg_id = msg->getId();
   char data[32];
   PCHAR cmd;
   
   switch(msg_id)  {
   case SET_DATA:
      sprintf(data, "%s%-8s", DECREMENTPARAMETER, msg->getValue());
      msg->setSubmit(data);
      msg->setTimeout(ProtoList[msg_id]->GetTime());
      break;
      
   default:
      cmd = ProtoList[msg_id]->Query();
      msg->setSubmit(cmd);
      free(cmd);
      msg->setTimeout(ProtoList[msg_id]->GetTime());
      if (msg->getType() == SET)
         msg->setType(ProtoList[msg_id]->GetSetType());
      
   }
}

INT UpsLinkProtocol :: BuildPollMessage(Message* msg, List* msglist)
{
   int err = ErrNO_ERROR;
   
   int msg_id = msg->getId();
   
   if (ProtoList[msg_id] == (PollParam*)NULL)
   {
      msg->setErrcode(ErrUNSUPPORTED);
      err = ErrUNSUPPORTED;
   }
   
   if(!err)  {
      if(ProtoList[msg_id]->isPollable())  {
         PCHAR cmd = ProtoList[msg_id]->Query();
         msg->setSubmit(cmd);
         free(cmd);
         msg->setTimeout(ProtoList[msg_id]->GetTime());
         msglist->Append(msg);
      }
   }
   else  {
      err = ErrNOT_POLLABLE;
   }
   return err;
}


INT UpsLinkProtocol :: BuildPollTransactionGroupMessages(PTransactionGroup aTransactionGroup)
{
   int err = ErrNO_ERROR;
   
   PTransactionItem theItem = aTransactionGroup->GetFirstTransactionItem();
   while ((theItem != NULL) && (err == ErrNO_ERROR))
   {
      if (ProtoList[theItem->GetCode()] != (PollParam*)NULL)
      {
         PollParam* poll_param = ProtoList[theItem->GetCode()];
         if ( !(poll_param->isPollable()) )
         {
            theItem->SetErrorCode(ErrNOT_POLLABLE);
            err = ErrBUILD_FAILED;
         }
         
         if(!err)  {
            //
            //  We ask the poll param if we're already polling
            //  for the poll_param.  Most pollparms return ErrNO_ERROR.
            //  The special ones TRIP, TRIP1, UPS_STATE, STATE, 
            //  MODULE_COUNTS_AND_STATUS, ABNORMAL_CONDITION_REGISTER,
            //  INPUT_VOLTAGE_FREQUENCY, and OUTPUT_VOLTAGE_CURRENTS have
            //  multiple poll params that use the same ups link character.
            //  We dont want send the same char twice in one poll loop, so
            //  we let the poll param tell us if its been added by someone
            //  else.
            //
            err = poll_param->IsPollSet();
            if (err == ErrUPS_STATE_SET)  {
               err = ErrNO_ERROR;
               theItem->SetCode(UPS_STATE);   // Switch the code
            }
            else if (err == ErrTRIP_SET)  {
               err = ErrNO_ERROR;
               theItem->SetCode(TRIP_REGISTER);   // Switch the code
            }
            else if (err == ErrTRIP1_SET)  {
               err = ErrNO_ERROR;
               theItem->SetCode(TRIP1_REGISTER);   // Switch the code
            }
            else if (err == ErrSTATE_SET)  {
               err = ErrNO_ERROR;
               theItem->SetCode(STATE_REGISTER);   // Switch the code to be upssate
            }
            if (err == ErrABNORMAL_CONDITION_SET)  {
               err = ErrNO_ERROR;
               theItem->SetCode(ABNORMAL_CONDITION_REGISTER); 
            }
            if (err == ErrMODULE_COUNTS_SET)  {
               err = ErrNO_ERROR;
               theItem->SetCode(MODULE_COUNTS_AND_STATUS);  
            }
            if (err == ErrVOLTAGE_FREQUENCY_SET)  {
               err = ErrNO_ERROR;
               theItem->SetCode(INPUT_VOLTAGE_FREQUENCY);   
            }
            if (err == ErrVOLTAGE_CURRENTS_SET)  {
               err = ErrNO_ERROR;
               theItem->SetCode(OUTPUT_VOLTAGE_CURRENTS);  
            }
            else  if(err == ErrSAME_VALUE) {
               err = ErrBUILD_FAILED;
               theItem->SetErrorCode(ErrSAME_VALUE);
            }
            else  {
               err = ErrNO_ERROR;
            }
         }
      }
      else
         err = ErrNOT_POLLABLE;
      
      theItem = aTransactionGroup->GetNextTransactionItem();
   }
   if (err == ErrNO_ERROR)
   {
      err = BuildTransactionGroupMessages(aTransactionGroup);
   }
   return err;
} 


List* UpsLinkProtocol :: BuildTransactionMessageList(Type aType, INT aCode, CHAR* aValue)
{
   List* msglist;
   
   PollParam* poll_param = ProtoList[aCode];
   
   if(poll_param == NULL)  {
      return (List*)NULL;
   }
   
   switch(aType)  {
   case GET:
      msglist = BuildGetMessage(aCode);
      break;
      
   case SET: {
      int set_type = poll_param->GetSetType();
      switch(set_type)  {
      case DATASET:
         msglist = BuildDataSetMessage(aCode, aValue);
         break;
         
      case DECREMENTSET:
         msglist = BuildDecrementSetMessage(aCode, aValue);
         break;
         
      case PAUSESET:
         msglist = BuildPauseSetMessage(aCode, aValue);
         break;
         
      case CHANGESET:
         msglist = BuildChangeSetMessage(aCode, aValue);
         break;
         
      default:
         msglist = BuildStandardSetMessage(aCode, aValue);
         break;
      }
             }
   }
   
   return msglist;
}

List* UpsLinkProtocol :: BuildDataSetMessage(INT aCode, CHAR* aValue)
{
   List*  msglist = new List();
   
   
   // Initial get
   PollParam* poll_param = ProtoList[aCode];
   PMessage msg = new Message(aCode);
   PCHAR cmd = poll_param->Query();
   
   if (msg != NULL) {
     msg->setSubmit(cmd);
     msg->setTimeout(poll_param->GetTime());
     msglist->Append(msg);
   }
   
   free(cmd);
   
   
   // Data
   poll_param = ProtoList[SET_DATA];
   PMessage datamsg = new Message(SET_DATA);
   char data[32];
   if (datamsg != NULL) {

     sprintf(data, "%s%8s", DECREMENTPARAMETER, aValue);
     datamsg->setSubmit(data);
     datamsg->setTimeout(poll_param->GetTime());
     msglist->Append(datamsg);
   }

   // Put in two dummy gets to fix UPSLinkism that requires a unspecified
   // delay after getting the last OK.  I'm sorry I had to do this, but its
   // December 14, I go on vacation next week an we have to get this don.:(
   poll_param = ProtoList[aCode];
   cmd = poll_param->Query();
   
   Message* dummy_get = new Message(aCode);
   if (dummy_get != NULL) {
     dummy_get->setSubmit(cmd);
     dummy_get->setTimeout(poll_param->GetTime());
     msglist->Append(dummy_get);
   }
   
   dummy_get = new Message(aCode);
   if (dummy_get != NULL) {
     dummy_get->setSubmit(cmd);
     dummy_get->setTimeout(poll_param->GetTime());
     msglist->Append(dummy_get);
   }
   
   
   // Verify with get
   Message* get = new Message(aCode);
   if (get != NULL) {
     get->setSubmit(cmd);
     get->setTimeout(poll_param->GetTime());
     get->setCompare(&(data[1]));   // skip the first char (-)
     msglist->Append(get);
   }
   
   free(cmd);
   
   return msglist;
}



List* UpsLinkProtocol :: BuildPauseSetMessage(INT aCode, CHAR* aValue)
{
   
   List*  msglist = new List();
   
   // Really only action type stuff.  How will we deal with commands that
   // require two letters (S, wait 1 seconds, S).  Possibly use
   // TURN_OFF_UPS as the code, and set an inter character delay as part of
   // protocol message.  For now this only handles the simple stuff. 
   PollParam* poll_param = ProtoList[aCode];
   PMessage msg = new Message(aCode);
   
   if ((msg != NULL) && (msglist != NULL)) {
     CHAR submit_string[50];
     PCHAR cmd = poll_param->Query();
   
     *submit_string = '\0';
     if (cmd != NULL) {
       strcpy(submit_string,cmd);
       strcat(submit_string,cmd);
       free(cmd);
     }
   
     //  if(poll_param->GetSetType() != SIMPLE_SET)  {
     //    if (aValue)  {
     //      strcat(submit_string,aValue);
     //    }
     //  }
   
     msg->setSubmit(submit_string);
     msg->setTimeout(poll_param->GetTime());
     msg->setWaitTime(PAUSEWAIT);
     msglist->Append(msg);
   }
   else {
     // Clean up memory so we don't leak
     delete msglist;
     delete msg;
   }

   return msglist;
}


List* UpsLinkProtocol :: BuildChangeSetMessage(INT aCode, CHAR* aValue)
{
   List*  msglist = new List();
   
   
   // Initial get.  InterpretMessage will verify.
   PollParam* poll_param = ProtoList[aCode];
   PMessage msg = new Message(aCode);
   if (msg != NULL) {
     PCHAR cmd = poll_param->Query();
   
     msg->setSubmit(cmd);
     msg->setTimeout(poll_param->GetTime());
     msg->setCompare(aValue);
     msglist->Append(msg);
   
     free(cmd);
   }
   
   return msglist;
}

List* UpsLinkProtocol :: BuildDecrementSetMessage(INT aCode, CHAR* aValue)
{
   List*  msglist = new List();
   
   
   // Initial get.  InterpretMessage will verify.
   PollParam* poll_param = ProtoList[aCode];
   PMessage msg = new Message(aCode);
   if (msg != NULL) {
     PCHAR cmd = poll_param->Query();
   
     msg->setSubmit(cmd);
     msg->setTimeout(poll_param->GetTime());
     msg->setCompare(aValue);
     msglist->Append(msg);
   
     free(cmd);
   }
   
   return msglist;
}

INT UpsLinkProtocol :: InterpretSetMessage(Message* msg, List* newmsglist)
{
   INT err = ErrNO_ERROR;
   
   if (msg->getCompare()) {
      
      if (strncmp(msg->getCompare(), msg->getResponse(), 8 ) == 0) {
         msg->setErrcode(ErrNO_ERROR);
      }
      else {
         
         if (theCurrentTransactionGroup->GetInitialSetResponse() == (CHAR*)NULL)
            theCurrentTransactionGroup->SetInitialSetResponse(msg->getResponse());
         else {  
            
            if (!strncmp(theCurrentTransactionGroup->GetInitialSetResponse(),
               msg->getResponse(), strlen(msg->getResponse()) )){
               
               if (theCurrentTransactionGroup->GetInitialSetResponseRepeated()) {
                  msg->setErrcode(ErrSET_VALUE_NOT_FOUND);
                  return ErrSET_VALUE_NOT_FOUND;
               }
               else {
                  theCurrentTransactionGroup->SetInitialSetResponseRepeated(TRUE);
               }
            }
         }
         CHAR compare[32];
         
         PollParam* poll_param = (PollParam*)NULL;
         Message* decrement = (Message*)NULL;
         Message* verify = (Message*)NULL;
         PCHAR cmd;
         
         PollParam* orig_poll_param = ProtoList[msg->getId()];
         
         switch(orig_poll_param->GetSetType()) {
            
         case DECREMENTSET:
            {
               // save the compare value, we'll use it later
               strcpy(compare, msg->getCompare());
               
               PMessage orig_msg = new Message(msg->getId(),
                  msg->getType(),
                  msg->getValue());

               if (orig_msg !=NULL) {
                 orig_msg->setSubmit(msg->getSubmit());
                 orig_msg->setTimeout(msg->getTimeout());
                 newmsglist->Append(orig_msg);
               }
               
               
               // Reset get message. should we create a new message here,
               // or is it OK to use the old one??
               // msg->setResponse((CHAR*)NULL);
               // msg->setErrcode(ErrNO_ERROR);
               // msg->setCompare((CHAR*)NULL);
               //           newmsglist = new List();
               // newmsglist->Append(msg);
               
               // Now add the Decrement message
               poll_param = ProtoList[EEPROM_DECREMENT];
               decrement = new Message(EEPROM_DECREMENT);
               if (decrement != NULL) {
                 cmd = poll_param->Query();
               
                 decrement->setSubmit(cmd);
                 decrement->setTimeout(poll_param->GetTime());
                 newmsglist->Append(decrement);
               
                 free(cmd);
               }
               
               // Now Verify with another get
               verify = new Message(msg);
               if (verify!=NULL) {
                 verify->setCompare(compare);
                 newmsglist->Append(verify);
               }
            }
            break;      //   this is new ?????  JIMD
            
         case CHANGESET:
            {
               // A CHANGESET message will increment or
               // decrement a UPS parameter  based upon the 
               // current value stored in the UPS.
               
               // save the compare value, we'll use it later
               strcpy(compare, msg->getCompare());
               
               PMessage orig_msg = new Message(msg->getId(),
                  msg->getType(),
                  msg->getValue());
               if (orig_msg != NULL) {
                 orig_msg->setSubmit(msg->getSubmit());
                 orig_msg->setTimeout(msg->getTimeout());
                 newmsglist->Append(orig_msg);
               }
               
               // Now add the Change message
               PMessage changemsg = (PMessage)NULL;
               if (atoi(msg->getCompare()) < atoi(msg->getResponse())) 
               {
                  poll_param = ProtoList[EEPROM_DECREMENT];
                  changemsg = new Message(EEPROM_DECREMENT);
               }
               else {
                  poll_param = ProtoList[EEPROM_INCREMENT];
                  changemsg = new Message(EEPROM_INCREMENT);
               }  

               if (changemsg != NULL) {
                 cmd = poll_param->Query();
               
                 changemsg->setSubmit(cmd);
                 changemsg->setTimeout(poll_param->GetTime());
                 newmsglist->Append(changemsg);
               
                 free(cmd);
               }
               
               // Now Verify with another get
               verify = new Message(msg);
               if (verify != NULL) {
                 verify->setCompare(compare);
                 newmsglist->Append(verify);
               }
            }
            break;
            
         case DATASET:
            
         default:
            msg->setErrcode(ErrSET_FAILED);
         }        // end switch
   }        // end strncmp
    }
    else  {
       PollParam* orig_poll_param = ProtoList[msg->getId()];
       err = orig_poll_param->ProcessValue(msg, (PList)NULL);
       msg->setErrcode(err);
    }
    return err;
}

INT UpsLinkProtocol :: InterpretMessage(Message* msg, List* eventList, List* newmsglist)
{
   PList tiList = (PList)NULL;
   PTransactionItem trans_item = (PTransactionItem)NULL;
   PTransactionItem tmpti = (PTransactionItem)NULL;
   
   EventSearch(msg->getResponse(),eventList);
   
   FindCRLF(msg->getResponse());
   
   PollParam* orig_poll_param = ProtoList[msg->getId()];
   switch(theCurrentTransactionGroup->GetType())
   {
     case SET:
        InterpretSetMessage(msg, newmsglist);
        break;
     case GET:
        msg->setErrcode(orig_poll_param->ProcessValue(msg, eventList));
        
        tiList = theCurrentTransactionGroup->GetTransactionItemList();
        tmpti = new TransactionItem(GET,msg->getId());
        trans_item = (PTransactionItem)tiList->Find(tmpti);
        if (trans_item)
        {
           trans_item->SetErrorCode(msg->getErrcode());
           trans_item->SetValue(msg->getResponse());
        }
        delete tmpti;
        tmpti = NULL;
        break;
   }        // end switch GetType()
   
   return msg->getErrcode();
}
INT UpsLinkProtocol :: TestResponse(Message* msg,CHAR* Buffer,USHORT BufferSize)
{
   
   int err = ErrREAD_FAILED;
   CHAR lBuffer[512];
   PCHAR lPtr = NULL;
   strncpy(lBuffer,Buffer,BufferSize);      //make a local copy
   lBuffer[BufferSize]= '\0';
   switch (msg->getId()) {
   case UPS_SERIAL_NUMBER: {// fixes serial number problem
      for(INT i=0;i<BufferSize;i++) {
           if(Buffer[i]=='\n') {
              Message tmpMsg(msg->getId());
              tmpMsg.setResponse(Buffer);
              PollParam* pollparm = ProtoList[msg->getId()];
              
              err = pollparm->ProcessValue(&tmpMsg);
              break;
           }
      }
      return err;
                           }
      break;
   case UPS_ALLOWED_VALUES:
      // test allowed values response, a bad snmp adaptor will truncate
      // the response, but terminate it with \r\n making it look valid.
      if ((lPtr = strstr(lBuffer, "\r\n")) == NULL)
           return err;        // broken ctrl-z (no \r\n), return error.
      break;               // possibly real, allow response to be validated.
      
      
   default:
      if ((lPtr = strstr(lBuffer, "\r\n")) == NULL)
           return err;
      break;          // should hardly ever get here cuz this function is only
      // called for HARD read errors or responses w/o \r\n.
      // though you can get here if using a flaky snmp adapter
      // which truncates commands and terminates them w/ \r\n
      // making them look valid.  IN such a case, the individual
      // response's processValue funciton should catch the error.
   }
   
   *lPtr = '\0';     // most ProcessValue funcs expect \0 not \r\n, so convert.
   Message tmpMsg(msg->getId());
   tmpMsg.setResponse(lBuffer);
   
   PollParam *pollparm = ProtoList[msg->getId()];
   err = pollparm->ProcessValue(&tmpMsg);        
   
   return err;
}

/*--------------------------------------------------------------------
*
*       Function...:   InitProtocol
*
*       Description:   Initializes all the protocol. 
*
*-------------------------------------------------------------------*/

VOID UpsLinkProtocol::InitProtocol()
{
   FLOAT DELAY_FACTOR = (FLOAT)50.0;
   
   // I wish there was a better way...
   //
   delete ProtoList[UTILITY_LINE_CONDITION];
   ProtoList[UTILITY_LINE_CONDITION] = NULL;
   delete ProtoList[BATTERY_CONDITION];
   ProtoList[BATTERY_CONDITION] = NULL;
   delete ProtoList[TURN_OFF_UPS];
   ProtoList[TURN_OFF_UPS] = NULL;
   delete ProtoList[TURN_OFF_UPS_ON_BATTERY];
   ProtoList[TURN_OFF_UPS_ON_BATTERY] = NULL;
   delete ProtoList[TURN_ON_SMART_MODE];
   ProtoList[TURN_ON_SMART_MODE] = NULL;
   ProtoList[TURN_ON_SMART_MODE] = new SmartModePollParam(TURN_ON_SMART_MODE, SMARTMODE, (int)(50*DELAY_FACTOR), NO_POLL);
   ProtoList[TURN_OFF_SMART_MODE] = new TurnOffSmartModePollParam(TURN_OFF_SMART_MODE, TURNOFFSMARTMODE, (int)(50*DELAY_FACTOR), NO_POLL);
   ProtoList[LIGHTS_TEST] = new LightsTestPollParam(LIGHTS_TEST, LIGHTSTEST, (int)(50*DELAY_FACTOR), NO_POLL, SIMPLE_SET);
   ProtoList[TURN_OFF_UPS_AFTER_DELAY] = new TurnOffAfterDelayPollParam(TURN_OFF_UPS_AFTER_DELAY, TURNOFFAFTERDELAY, (int)(50*DELAY_FACTOR), NO_POLL, PAUSESET);
   ProtoList[TURN_OFF_UPS_ON_BATTERY] = new ShutdownPollParam(TURN_OFF_UPS_ON_BATTERY,TURNOFFUPSONBATT , (int)(50*DELAY_FACTOR), NO_POLL);
   ProtoList[SIMULATE_POWER_FAIL] = new SimulatePowerFailurePollParam(SIMULATE_POWER_FAIL, SIMULATEPOWERFAIL, (int)(50*DELAY_FACTOR), NO_POLL, SIMPLE_SET);
   ProtoList[SELF_TEST] = new BatteryTestPollParam(SELF_TEST, BATTERYTEST, (int)(50*DELAY_FACTOR), NO_POLL);
   ProtoList[TURN_OFF_UPS] = new TurnOffUpsPollParam(TURN_OFF_UPS, SHUTDOWNUPS, (int)(50*DELAY_FACTOR), NO_POLL, PAUSESET);
   ProtoList[PUT_UPS_TO_SLEEP] = new ShutdownWakeupPollParam(PUT_UPS_TO_SLEEP, SHUTDOWNUPSWAKEUP, (int)(50*DELAY_FACTOR), NO_POLL);
   ProtoList[BATTERY_CALIBRATION_TEST] = new BatteryCalibrationPollParam(BATTERY_CALIBRATION_TEST, BATTERYCALIBRATION,(int)(50*DELAY_FACTOR), NO_POLL, SIMPLE_SET);
#ifndef CIBC
   ProtoList[BYPASS_MODE] = new BypassModePollParam(BYPASS_MODE, BYPASSMODE, (int)(50*DELAY_FACTOR), POLL,SIMPLE_SET);
   ProtoList[BYPASS_POWER_SUPPLY_CONDITION] = new BypassPowerSupplyPollParam(BYPASS_POWER_SUPPLY_CONDITION, TRIPREGISTER1, (int)(50*DELAY_FACTOR), POLL);
#endif
   /****   STATUS INQUERY COMMANDS  ****/
   ProtoList[SELF_TEST_RESULT] = new BatteryTestResultsPollParam(SELF_TEST_RESULT, BATTERYTESTRESULT, (int)(50*DELAY_FACTOR), POLL);
#ifndef CIBC
   //    ProtoList[BATTERY_PACKS] = new NumberBatteryPacksPollParam(BATTERY_PACKS, BATTERYPACKS, (int)(60*DELAY_FACTOR), POLL,CHANGESET);
   ProtoList[EXTERNAL_BATTERY_PACKS] = new NumberBatteryPacksPollParam(EXTERNAL_BATTERY_PACKS, BATTERYPACKS, (int)(60*DELAY_FACTOR), POLL,CHANGESET);
   ProtoList[BAD_BATTERY_PACKS] = new NumberBadBatteryPacksPollParam(BAD_BATTERY_PACKS, BADBATTERYPACKS, (int)(60*DELAY_FACTOR), POLL);
#endif
   ProtoList[DECIMAL_FIRMWARE_REV] = new FirmwareVersionPollParam(DECIMAL_FIRMWARE_REV, UPSNEWFIRMWAREREV, (int)(60*DELAY_FACTOR), NO_POLL);
   ProtoList[TRANSFER_CAUSE] = new TransferCausePollParam(TRANSFER_CAUSE,TRANSFERCAUSE, (int)(40*DELAY_FACTOR), NO_POLL);
   ProtoList[FIRMWARE_REV] = new FirmwareVersionPollParam(FIRMWARE_REV, FIRMWAREREV, (int)(60*DELAY_FACTOR), NO_POLL);
   ProtoList[RATED_BATTERY_VOLTAGE] = new BatteryTypePollParam(RATED_BATTERY_VOLTAGE, UPSTYPE, (int)(60*DELAY_FACTOR), NO_POLL);
   ProtoList[BATTERY_CAPACITY] = new BatteryCapacityPollParam(BATTERY_CAPACITY, BATTERYCAPACITY,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[UPS_STATE] = new UPSStatePollParam(UPS_STATE, UPSSTATE, (int)(50*DELAY_FACTOR), POLL);
#ifndef CIBC
   ProtoList[STATE_REGISTER] = new StateRegisterPollParam(STATE_REGISTER, STATEREGISTER, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[MATRIX_FAN_STATE] = new FanFailurePollParam(MATRIX_FAN_STATE, TRIPREGISTER1, (int)(50*DELAY_FACTOR), POLL);
#endif
   ProtoList[DIP_SWITCH_POSITION] = new DipSwitchPollParam(DIP_SWITCH_POSITION, DIPSWITCHES, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[RUN_TIME_REMAINING] = new RuntimeRemainingPollParam(RUN_TIME_REMAINING, BATTERYRUNTIMEAVAIL, (int)(80*DELAY_FACTOR), POLL);
   ProtoList[COPYRIGHT] = new CopyrightPollParam(COPYRIGHT, COPYRIGHTCOMMAND,(int)(100*DELAY_FACTOR), NO_POLL);
   ProtoList[BATTERY_VOLTAGE] = new BatteryVoltagePollParam(BATTERY_VOLTAGE, BATTERYVOLTAGE,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[UPS_TEMPERATURE] = new InternalTempPollParam(UPS_TEMPERATURE, INTERNALTEMP,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[OUTPUT_FREQUENCY] = new OutputFreqPollParam(OUTPUT_FREQUENCY, OUTPUTFREQ,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[LINE_VOLTAGE] = new LineVoltagePollParam(LINE_VOLTAGE, LINEVOLTAGE,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[MAX_LINE_VOLTAGE] = new MaxVoltagePollParam(MAX_LINE_VOLTAGE, MAXLINEVOLTAGE,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[MIN_LINE_VOLTAGE] = new MinVoltagePollParam(MIN_LINE_VOLTAGE, MINLINEVOLTAGE,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[OUTPUT_VOLTAGE] = new OutputVoltagePollParam(OUTPUT_VOLTAGE, OUTPUTVOLTAGE,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[UPS_LOAD] = new LoadPowerPollParam(UPS_LOAD, LOADPOWER,(int)(80*DELAY_FACTOR), POLL);
   ProtoList[EEPROM_DECREMENT] = new DecrementPollParam(EEPROM_DECREMENT, DECREMENTPARAMETER, (int)(50*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[EEPROM_INCREMENT] = new IncrementPollParam(EEPROM_INCREMENT, INCREMENTPARAMETER, (int)(50*DELAY_FACTOR), NO_POLL,INCREMENTSET);
   ProtoList[DATA_DECREMENT] = new DataDecrementPollParam(DATA_DECREMENT, DECREMENTPARAMETER, 50, NO_POLL);
   ProtoList[UPS_SELF_TEST_SCHEDULE] = new AutoSelfTestPollParam(UPS_SELF_TEST_SCHEDULE, AUTOSELFTEST, (int)(60*DELAY_FACTOR), NO_POLL, DECREMENTSET);
   ProtoList[UPS_ID] = new UpsIdPollParam(UPS_ID, UPSID, (int)(250*DELAY_FACTOR), NO_POLL,DATASET);
   ProtoList[UPS_SERIAL_NUMBER] = new SerialNumberPollParam(UPS_SERIAL_NUMBER, UPSSERIALNUMBER, (int)(250*DELAY_FACTOR), NO_POLL, DATASET);
   ProtoList[MANUFACTURE_DATE] = new ManufactureDatePollParam(MANUFACTURE_DATE, UPSMANUFACTUREDATE, (int)(250*DELAY_FACTOR), NO_POLL, DATASET);
   ProtoList[BATTERY_REPLACEMENT_DATE] = new BatteryReplaceDatePollParam(BATTERY_REPLACEMENT_DATE, BATTERYREPLACEDATE,
      (int)(250*DELAY_FACTOR), NO_POLL, DATASET);
   ProtoList[HIGH_TRANSFER_VOLTAGE] = new HighTransferPollParam(HIGH_TRANSFER_VOLTAGE,
      HIGHTRANSFERPOINT, (int)(60*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[LOW_TRANSFER_VOLTAGE] = new LowTransferPollParam(LOW_TRANSFER_VOLTAGE, LOWTRANSFERPOINT, (int)(60*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[MIN_RETURN_CAPACITY] = new MinCapacityPollParam(MIN_RETURN_CAPACITY, MINIMUMCAPACITY, (int)(50*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[RATED_OUTPUT_VOLTAGE] = new RatedOutputVoltagePollParam(RATED_OUTPUT_VOLTAGE,
      OUTPUTVOLTAGESETTING, (int)(60*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[UPS_SENSITIVITY] = new SensitivityPollParam(UPS_SENSITIVITY, SENSETIVITY, (int)(40*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[LOW_BATTERY_DURATION] = new LowBattDurationPollParam(LOW_BATTERY_DURATION,
      LOWBATTERYRUNTIME, (int)(50*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[ALARM_DELAY] = new AlarmDelayPollParam(ALARM_DELAY, ALARMDELAY, (int)(40*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[SHUTDOWN_DELAY] = new ShutdownDelayPollParam(SHUTDOWN_DELAY, SHUTDOWNDELAY, (int)(60*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[TURN_ON_DELAY] = new TurnBackOnDelayPollParam(TURN_ON_DELAY, SYNCTURNBACKDELAY, (int)(60*DELAY_FACTOR), NO_POLL,DECREMENTSET);
   ProtoList[SET_DATA] = new SimplePollParam(SET_DATA, "", (int)(250*DELAY_FACTOR), NO_POLL);
   ProtoList[NO_MSG] = new SimplePollParam(NO_MSG, "", (int)(250*DELAY_FACTOR), NO_POLL);
   ProtoList[LINE_CONDITION_TEST] = new LineConditionPollParam(LINE_CONDITION_TEST, LINECONDITIONTEST, (int)(60*DELAY_FACTOR), POLL);
   ProtoList[UTILITY_LINE_CONDITION] = new UtilLineCondPollParam(UTILITY_LINE_CONDITION, UPSSTATE, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[BATTERY_CONDITION] = new BatteryCondPollParam(BATTERY_CONDITION, UPSSTATE, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[BATTERY_REPLACEMENT_CONDITION] = new ReplaceBattCondPollParam(BATTERY_REPLACEMENT_CONDITION, UPSSTATE, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[OVERLOAD_CONDITION] = new OverLoadCondPollParam(OVERLOAD_CONDITION, UPSSTATE, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[SMART_BOOST_STATE] = new SmartBoostCondPollParam(SMART_BOOST_STATE, UPSSTATE, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[SMART_TRIM_STATE] = new SmartTrimCondPollParam(SMART_TRIM_STATE, UPSSTATE, (int)(50*DELAY_FACTOR), POLL);
#if (C_OS & C_OS2)
   ProtoList[BATTERY_CALIBRATION_CONDITION] = new BattCalibrateCondPollParam(BATTERY_CALIBRATION_CONDITION, UPSSTATE, (int)(50*DELAY_FACTOR),
      POLL);
#else
   ProtoList[BATTERY_CALIBRATION_CONDITION] = new BattCalibrationCondPollParam(BATTERY_CALIBRATION_CONDITION, UPSSTATE, (int)(50*DELAY_FACTOR),
      POLL);
#endif
   ProtoList[AMBIENT_TEMPERATURE] = new MUpsTempPollParam(AMBIENT_TEMPERATURE, MUPSAMBIENTTEMP, (int)(80*DELAY_FACTOR), POLL);
   ProtoList[HUMIDITY] = new MUpsHumidityPollParam(HUMIDITY, MUPSHUMIDITY, (int)(80*DELAY_FACTOR), POLL);
   ProtoList[MUPS_FIRMWARE_REV] = new MUpsFirmwareRevPollParam(MUPS_FIRMWARE_REV, MUPSFIRMWAREREV, (int)(60*DELAY_FACTOR), NO_POLL);
   ProtoList[CONTACT_POSITION] = new MUpsContactPosPollParam(CONTACT_POSITION, MUPSCONTACTPOSITION, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[UPS_FRONT_PANEL_PASSWORD] = new FrontPanelPasswordPollParam(UPS_FRONT_PANEL_PASSWORD, EEPROMPASSWORD, (int)(125*DELAY_FACTOR), POLL);
   ProtoList[UPS_RUN_TIME_AFTER_LOW_BATTERY] = new RunTimeAfterLowBatteryPollParam(UPS_RUN_TIME_AFTER_LOW_BATTERY, EARLYTURNOFF, (int)(50*DELAY_FACTOR), POLL);
#ifndef CIBC
   ProtoList[TRIP_REGISTER] = new TripRegisterPollParam(TRIP_REGISTER, TRIPREGISTERS, (int)(50*DELAY_FACTOR), POLL);
   ProtoList[TRIP1_REGISTER] = new Trip1RegisterPollParam(TRIP1_REGISTER, TRIPREGISTER1, (int)(50*DELAY_FACTOR), POLL);
#if (C_OS & C_OS2)
   ProtoList[UPS_ALLOWED_VALUES] = new EepromAllowedValsPollParam(UPS_ALLOWED_VALUES, EEPROMVALUES, (int)(2000*DELAY_FACTOR), NO_POLL);
#else
   ProtoList[UPS_ALLOWED_VALUES] = new EepromAllowedValuesPollParam(UPS_ALLOWED_VALUES, EEPROMVALUES, (int)(2000*DELAY_FACTOR), NO_POLL);
#endif
   ProtoList[UPS_MODEL_NAME] = new UpsModelPollParam(UPS_MODEL_NAME, UPSMODELNAME, (int)(2000*DELAY_FACTOR), NO_POLL);
#endif
   
   const INT TBD = 200;  // This must be finalized by hardware group
   // Dark Star additions
   ProtoList[TOTAL_INVERTERS] = new NumberInstalledInvertersPollParam(TOTAL_INVERTERS, MODULECOUNTSSTATUS, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[NUMBER_BAD_INVERTERS] = new NumberBadInvertersPollParam(NUMBER_BAD_INVERTERS, MODULECOUNTSSTATUS, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[CURRENT_REDUNDANCY] = new RedundancyLevelPollParam(CURRENT_REDUNDANCY,MODULECOUNTSSTATUS , (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[MINIMUM_REDUNDANCY] = new MinimumRedundancyPollParam(MINIMUM_REDUNDANCY, MODULECOUNTSSTATUS, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[CURRENT_LOAD_CAPABILITY] = new CurrentLoadCapabilityPollParam(CURRENT_LOAD_CAPABILITY, MODULECOUNTSSTATUS, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[MAXIMUM_LOAD_CAPABILITY] = new MaximumLoadCapabilityPollParam(MAXIMUM_LOAD_CAPABILITY, MODULECOUNTSSTATUS, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[INPUT_VOLTAGE_PHASE_A] = new PhaseAInputVoltagePollParam(INPUT_VOLTAGE_PHASE_A,INPUTVOLTAGEFREQ , (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[INPUT_VOLTAGE_PHASE_B] = new PhaseBInputVoltagePollParam(INPUT_VOLTAGE_PHASE_B,INPUTVOLTAGEFREQ , (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[INPUT_VOLTAGE_PHASE_C] = new PhaseCInputVoltagePollParam(INPUT_VOLTAGE_PHASE_C, INPUTVOLTAGEFREQ, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[INPUT_FREQUENCY] = new InputFrequencyPollParam(INPUT_FREQUENCY, INPUTVOLTAGEFREQ, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[OUTPUT_VOLTAGE_PHASE_A] = new PhaseAOutputVoltagePollParam(OUTPUT_VOLTAGE_PHASE_A,OUTPUTVOLTAGECURRENT , (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[OUTPUT_VOLTAGE_PHASE_B] = new PhaseBOutputVoltagePollParam(OUTPUT_VOLTAGE_PHASE_B,OUTPUTVOLTAGECURRENT , (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[OUTPUT_VOLTAGE_PHASE_C] = new PhaseCOutputVoltagePollParam(OUTPUT_VOLTAGE_PHASE_C, OUTPUTVOLTAGECURRENT, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[MODULE_COUNTS_AND_STATUS] = new ModuleCountsStatusPollParam(MODULE_COUNTS_AND_STATUS, MODULECOUNTSSTATUS, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[ABNORMAL_CONDITION_REGISTER] = new AbnormalCondPollParam(ABNORMAL_CONDITION_REGISTER, ABNORMALCONDITION, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[INPUT_VOLTAGE_FREQUENCY] = new InputVoltageFrequencyPollParam(INPUT_VOLTAGE_FREQUENCY, INPUTVOLTAGEFREQ, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[OUTPUT_VOLTAGE_CURRENTS] = new OutputVoltageCurrentsPollParam(OUTPUT_VOLTAGE_CURRENTS,OUTPUTVOLTAGECURRENT , (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[IM_STATUS] = new IMStatusPollParam(IM_STATUS, ABNORMALCONDITION, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[IM_INSTALLATION_STATE] = new IMInstallationStatusPollParam(IM_INSTALLATION_STATE, ABNORMALCONDITION, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[RIM_INSTALLATION_STATE] = new RIMInstallationStatusPollParam(RIM_INSTALLATION_STATE, MODULECOUNTSSTATUS, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[RIM_STATUS] = new RIMStatusPollParam(RIM_STATUS, ABNORMALCONDITION, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[REDUNDANCY_STATE] = new RedundancyConditionPollParam(REDUNDANCY_STATE, ABNORMALCONDITION, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[BYPASS_CONTACTOR_STATE] = new BypassContactorStatusPollParam(BYPASS_CONTACTOR_STATE, ABNORMALCONDITION, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[INPUT_BREAKER_STATE] = new InputBreakerTrippedStatusPollParam(INPUT_BREAKER_STATE, ABNORMALCONDITION, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[NUMBER_OF_INPUT_PHASES] = new NumberOfInputPhasesPollParam(NUMBER_OF_INPUT_PHASES, INPUTVOLTAGEFREQ, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[NUMBER_OF_OUTPUT_PHASES] = new NumberOfOutputPhasesPollParam(NUMBER_OF_OUTPUT_PHASES, INPUTVOLTAGEFREQ, (int)(TBD*DELAY_FACTOR), POLL);
   ProtoList[SYSTEM_FAN_STATE] = new SystemFanStatusPollParam(SYSTEM_FAN_STATE, ABNORMALCONDITION, (int)(TBD*DELAY_FACTOR), POLL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\runtrems.cxx ===
/*
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  pcy28Apr93: Changed file name from rtrthsen to runtrems
 *  cgm12Apr96: Add destructor with unregister
 *
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "runtrems.h"
#include "comctrl.h"


RunTimeRemainingSensor :: RunTimeRemainingSensor(PDevice aParent,
		 PCommController aCommController)
	         : ThresholdSensor(aParent, aCommController,
                                   RUN_TIME_REMAINING, AREAD_ONLY) 
{
    getConfigThresholds();
    theThresholdState = IN_RANGE;
    theCommController->RegisterEvent(RUN_TIME_REMAINING, this);
}

RunTimeRemainingSensor :: ~RunTimeRemainingSensor() 
{
    theCommController->UnregisterEvent(RUN_TIME_REMAINING, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\runtrems.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *  cgm12Apr96:  Add destructor with unregister
 */
#ifndef RTRTHSEN_H
#define RTRTHSEN_H

#include "thsensor.h"

_CLASSDEF(RunTimeRemainingSensor)

class RunTimeRemainingSensor : public ThresholdSensor {
public:
   RunTimeRemainingSensor(PDevice aParent, PCommController aCommController);
   virtual ~RunTimeRemainingSensor();
   virtual INT IsA() const { return BATTERYRUNTIMESENSOR; };
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smart_driver.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\scan.h ===
/*
 *  rct09Feb93:  removed # as a comment delimeter
 *  mholly06Oct98   : removed dead code, macros, and #defines - are left with
 *                  only the StripTrailingWhiteSpace function
 *
 */
// This is the header module for the Scanner:             
//    Included here are the exported function prototypes, 
//    symbol definitions, and macros.
//
// R. Thurston
//
//

#ifndef __SCAN_H
#define __SCAN_H

// Prototypes...

void StripTrailingWhiteSpace(char * aString);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\scan.cxx ===
/*
 * REVISIONS:
 *  ane11Dec92: Changed true and false to TRUE and FALSE, added os/2 includes
 *  rct27Jan93: Fixed problem with comments
 *  pcy16Feb93: Fixed removing trailing blanks from null strings ("")
 *  cad18Nov93: Fix for EOF returned but not feof()
 *  mholly06Oct98   : removed dead code, macros, and #defines - are left with
 *                  only the StripTrailingWhiteSpace function
 */

extern "C" {
#include <ctype.h>
#include <string.h>
}

#include "scan.h"

// Macro definitions...
#define NEWLINE_SYMBOL     '\n'

#define isNewline(c)    (c == NEWLINE_SYMBOL)
#define isBlank(c)      (isspace(c) && !isNewline(c))

//-------------------------------------------------------------------

// Removes trailing whitespace from the string


void StripTrailingWhiteSpace(char * aString)
{
    int index = (strlen(aString)-1);
    
    while (isBlank(aString[index]) && index >= 0) {
        index--;
    }
    aString[index+1] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\semaphor.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  rct 09Feb93   Made Equal()  const
 *  jwa 09FEB93   Changed return types for Wait and TimedWait to CHAR
 *                Added theClosingFlag to be used to signal when the destructor has been called
 *  rct 20Apr93   Changed return types, added some comments
 *  cad27May93	  added contant apc_semaphore
 *  cad09Jul93: re-wrote as event semaphore
 *
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */

#ifndef __SEMAPHOR_H
#define __SEMAPHOR_H

#include "cdefine.h"
#include "_defs.h"
#include "apc.h"
#include "apcobj.h"

_CLASSDEF( Semaphore )

class Semaphore : public Obj {

 protected:

 public:
    Semaphore() : Obj() {};

    virtual INT   Post()      = 0;
    virtual INT   Clear()     = 0;
    virtual INT   Pulse()     {INT err = Post(); Clear(); return err;};

    virtual INT   IsPosted()  = 0;
    
    virtual INT   Wait()      {return TimedWait(-1L);};// wait indefinitely
    #if (C_OS & C_NLM)
    virtual INT   TimedWait(  SLONG aTimeOut ) = 0;// 0, <0 (block), n>0
    #else
    virtual INT   TimedWait(  LONG aTimeOut ) = 0;// 0, <0 (block), n>0
    #endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\sensor.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker23NOV92  Initial OS/2 Revision 
 *  pcy07Dec92: DeepGet no longer needs aCode
 *  pcy11Dec92: Rework
 *  pcy16Feb93: Have DeepGet return the value it gets event if error
 *  cad07Oct93: Plugging Memory Leaks
 *  ajr09Dec93: Added some error condition alerts through _theErrorLogger
 *  cad16Dec93: fixed lookupsensorname
 *  rct06Jan94: fixed sensor IsaCode stuff & lookupSensorName()
 *  cad04Mar94: fix for mups sensor isa translation
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
 *  awm27Oct97: Added performance monitor offset to sensor class, and initialized
 *              counters here
 *  dma16Dec97: Changed DeepGet implementation to make an Update call.
 *  awm14Jan98: Removed performance monitor offset to sensor class
 *  clk11Feb98: Added DeepGetWithoutUpdate function 
 *  mholly25Sep98   : change the buffer size in DeepGet & DeepGetWithoutUpdate
 *                  to MAX_UPS_LINK_RESPONSE_LENGTH - now set at 256, granted
 *                  an arbitrary value, but it was set at 32, a value that was
 *                  too small to hold the allowed return of ^A
 */
#include "cdefine.h"
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "apc.h"
#include "sensor.h"
#include "utils.h"
#include "comctrl.h"
#include "event.h"
#include "errlogr.h"
#include "isa.h"


#define MAX_UPS_LINK_RESPONSE_LENGTH 256


//Constructor
Sensor :: Sensor(PDevice 		aParent, 
		 PCommController 	aCommController, 
		 INT 			aSensorCode, 
		 ACCESSTYPE 		anACCESSTYPE)
	: UpdateObj() 
{
	theDevice               = aParent;
	theCommController       = aCommController;
    theSensorCode           = aSensorCode; 
    readOnly                = anACCESSTYPE;
	theValue                = (PCHAR)NULL;
}
//Destructor
Sensor :: ~Sensor()
{
    if(theValue)
	   free(theValue);
}

//Member Functions
INT Sensor::Get(PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    if(theValue)  {
	   strcpy(aValue,theValue);
    }
    else {
        err = ErrNO_VALUE;
    }
    return err;
}
//Default behavior is to only support gets and sets on your own code


//  this does a deep get to the UPS, but will not update the sensor value
INT Sensor::DeepGetWithoutUpdate(PCHAR aValue)
{
    CHAR the_temp_value[MAX_UPS_LINK_RESPONSE_LENGTH] = {NULL};
    INT err = ErrNO_ERROR;
    
    if ((err = theCommController->Get(theSensorCode, the_temp_value)) == ErrNO_ERROR) {
        if(aValue) {
            strcpy(aValue, the_temp_value);
        }
    }
    return err;
}


INT Sensor::DeepGet(PCHAR aValue)
{
    CHAR the_temp_value[MAX_UPS_LINK_RESPONSE_LENGTH];
    strcpy(the_temp_value,"");
    INT err = ErrNO_ERROR;
    if((err = theCommController->Get(theSensorCode, the_temp_value)) == ErrNO_ERROR)  {
	if((err = Validate(theSensorCode, the_temp_value)) == ErrNO_ERROR)  {
	    storeValue(the_temp_value);
        PEvent sensor_event = new Event(theSensorCode, theValue);
        err = UpdateObj::Update(sensor_event);
        delete sensor_event;
        sensor_event = NULL;
    } 
    else {
#ifdef AJR_DEBUG
	    CHAR tmp_error[80];
	    sprintf(tmp_error,"Sensor::Validate fails with %d\0",err);
	    _theErrorLogger->LogError(tmp_error,__FILE__,__LINE__);
#endif
	}
    } else {
#ifdef AJR_DEBUG
	CHAR tmp_error[80];
	sprintf(tmp_error,"Sensor::DeepGet theommController->Get fails with %d\0",err);
	_theErrorLogger->LogError(tmp_error,__FILE__,__LINE__);
#endif
    }
    if(aValue) {
        strcpy(aValue, the_temp_value);
    }
    return err;
}

INT
Sensor::storeValue(const PCHAR aValue)
{
    if(aValue)  {
        UtilStoreString(theValue, aValue);
    }
    return ErrNO_ERROR;
}

INT Sensor::Get(INT aCode, PCHAR aValue)
{
   if(aCode == theSensorCode)
      return Get(aValue);
   else
      return ErrINVALID_CODE;         
}

INT Sensor::Set(const PCHAR aValue)
{
	INT err = ErrNO_ERROR;
	if(readOnly == AREAD_ONLY)  {
    	err =  ErrREAD_ONLY;
    }
    else  {
   		if(aValue) {
      		if((err = Validate(theSensorCode, aValue)) == ErrNO_ERROR)  {
         		if((err = theCommController->Set(theSensorCode, aValue)) == ErrNO_ERROR)  {
                	storeValue(aValue);
                }
            }
        }
    }
    return err;
}


INT Sensor::Set(INT aCode, const PCHAR aValue)
{
      INT err = ErrNO_ERROR;

      if(aCode == theSensorCode)
         err = Set(aValue);
      else
         err = ErrINVALID_CODE;

      return err;
}
 
INT Sensor::Update(PEvent anEvent)
{
	INT err = ErrNO_ERROR;
	INT the_temp_code;
	PCHAR the_temp_value;
   the_temp_code=anEvent->GetCode();
   the_temp_value=anEvent->GetValue();
   if((err = Validate(the_temp_code, the_temp_value)) == ErrNO_ERROR)  {
		storeValue(the_temp_value);
   		err = UpdateObj::Update(anEvent);
   }
   return err;
}


typedef struct IsaCode {
   INT isa_code;
   PCHAR sensor_name;
} ISACODE;

static ISACODE isa_codes[] = {
   { ABNORMALCONDITIONSENSOR,       "AbnormalConditionSensor" },
   { ALARMDELAYSENSOR,              "AlarmDelaySensor" },
   { BATTERYCALIBRATIONTESTSENSOR,  "BatteryCalibrationTestSensor" },
   { BATTERYCAPACITYSENSOR,         "BatteryCapacitySensor" },
   { BATTERYCONDITIONSENSOR,        "BatteryConditionSensor" },
   { BATTERYREPLACEMENTDATESENSOR,  "BatteryReplacementDateSensor" },
   { BATTERYVOLTAGESENSOR,          "BatteryVoltageSensor" },
   { COMMUNICATIONSTATESENSOR,      "CommunicationStateSensor" },
   { COPYRIGHTSENSOR,               "CopyrightSensor" },
   { DIPSWITCHPOSITIONSENSOR,       "DipSwitchPositionSensor" },
   { FIRMWAREREVSENSOR,             "FirmwareRevSensor" },
   { OUTPUTFREQUENCYSENSOR,         "FrequencySensor" },
   { HIGHTRANSFERVOLTAGESENSOR,     "HighTransferVoltageSensor" },
   { LINEVOLTAGESENSOR,             "LineVoltageSensor" },
   { LIGHTSTESTSENSOR,              "LightsTestSensor" },
   { LOWBATTERYDURATIONSENSOR,      "LowBatteryDurationSensor" },
   { LOWTRANSFERVOLTAGESENSOR,      "LowTransferVoltageSensor" },
   { MANUFACTUREDATESENSOR,         "ManufactureDateSensor" },
   { MAXLINEVOLTAGESENSOR,          "MaxLineVoltageSensor" },
   { MINLINEVOLTAGESENSOR,          "MinLineVoltageSensor" },
   { MINRETURNCAPACITYSENSOR,       "MinReturnCapacitySensor" },
   { OUTPUTVOLTAGESENSOR,           "OutputVoltageSensor" },
   { OVERLOADSENSOR,                "OverloadSensor" },
   { RATEDBATTERYVOLTAGESENSOR,     "RatedBatteryVoltageSensor" },
   { REPLACEBATTERYSENSOR,          "ReplaceBatterySensor" },
   { RATEDLINEVOLTAGESENSOR,        "RatedLineVoltageSensor" },
   { RATEDOUTPUTVOLTAGESENSOR,      "RatedOutputVoltageSensor" },
   { RUNTIMEREMAININGSENSOR,        "RunTimeRemainingSensor" },
   { SELFTESTRESULTSENSOR,          "SelfTestResultSensor" },
   { SELFTESTSCHEDULESENSOR,        "SelfTestScheduleSensor" },
   { SHUTDOWNDELAYSENSOR,           "ShutdownDelaySensor" },
   { SMARTBOOSTSENSOR,              "SmartBoostSensor" },
// unused   { TURNOFFUPSIMMEDIATELYSENSOR,   "TurnOffUpsImmediatelySensor" },
   { TURNOFFWITHDELAYSENSOR,        "TurnOffWithDelaySensor" },
   { TRANSFERCAUSESENSOR,           "TransferCauseSensor" },
   { TRIPREGISTERSENSOR,            "TripRegisterSensor" },
   { TURNONDELAYSENSOR,             "TurnOnDelaySensor" },
   { TURNOFFUPSONBATTERYSENSOR,     "TurnOffUpsOnBatterySensor" },
   { UTILITYLINECONDITIONSENSOR,    "UtilityLineConditionSensor" },
   { UNSUPPORTEDSENSOR,             "UnsupportedSensor" },
   { PUTUPSTOSLEEPSENSOR,           "PutUpsToSleepSensor" },
   { UPSBATTERYTYPESENSOR,          "UpsBatteryTypeSensor" },
   { UPSIDSENSOR,                   "UpsIdSensor" },
   { UPSLOADSENSOR,                 "UpsLoadSensor" },
   { UPSSENSITIVITYSENSOR,          "UpsSensitivitySensor" },
   { UPSSERIALNUMBERSENSOR,         "UpsSerialNumberSensor" },
   { UPSSIMULATEPOWERFAILSENSOR,    "UpsSimulatePowerFailSensor" },
   { UPSTEMPERATURESENSOR,          "UpsTemperatureSensor" },
   { TURNOFFDELAYSENSOR,            "TurnOffDelaySensor" },
   { SELFTESTSENSOR,                "SelfTestSensor" },
   { AMBIENTTEMPERATURESENSOR,      "AmbientTemperatureSensor" },
   { HUMIDITYSENSOR,                "HumiditySensor" },
   { CONTACTSENSOR,                 "ContactSensor" },
   { NUMBERBATTERYPACKSSENSOR,      "NumberBatteryPacksSensor" },
   { NUMBERBADBATTERIESSENSOR,      "NumberBadBatteriesSensor" },
   { STATEREGISTERSENSOR,           "StateRegisterSensor" },
   { FANFAILURESENSOR,              "FanFailureSensor" },
   { BATTERYCHARGERSENSOR,          "BatteryChargerSensor" },
   { OVERTEMPFAULTSENSOR,           "OverTempFaultSensor" },
   { BYPASSMODESENSOR,              "BypassModeSensor" },
   { BYPASSRELAYFAILEDSENSOR,       "BypassRelayFailedSensor" },
   { BYPASSPOWERSUPPLYFAULTSENSOR,  "BypassPowerSupplyFaultSensor" },
   { MUPSFIRMWAREREVSENSOR,         "MupsFirmwareRevSensor" },
   { BATTERYRUNTIMESENSOR,          "BatteryRunTimeSensor" },
   { PANELPASSWORDSENSOR,          "FrontPanelPasswordSensor" },
   { RUNTIMEAFTERLOWBATTERYSENSOR,  "RunTimeAfterLowBatterySensor" },
   { 0,                             "NoMatch" }
};


PCHAR Sensor::lookupSensorName(INT anIsaCode)
{
   ISACODE * code = isa_codes;
    
   while(code->isa_code != 0)
      {
      if(code->isa_code == anIsaCode)
         {
         break;
         }
      code++;
      }
   return code->sensor_name;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\sensor.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker13NOV92   Initial OS/2 Revision
 *  pcy07Dec92: DeepGet no longer needs aCode
 *  pcy11Dec92: Rework
 *  cad31Aug93: removing compiler warnings (some anyway)
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  awm27Oct97: Added performance monitor offset to sensor class
 *  awm14Jan98: Removed performance monitor offset -- this exists in own class now
 *  clk11Feb98: Added DeepGetWithoutUpdate function
 */
 
#ifndef __SENSOR_H
#define __SENSOR_H

#include "cdefine.h"
#include "_defs.h"
#include "codes.h"
#include "err.h"
#include "apc.h"
#include "update.h"


_CLASSDEF(CommController)
_CLASSDEF(Device)
_CLASSDEF(Event)
_CLASSDEF(Sensor)

#define NO_SENSOR_CODE 666

enum ACCESSTYPE		{ AREAD_ONLY, AREAD_WRITE };

class Sensor : public UpdateObj {
protected:
	PDevice 		theDevice;
	PCommController theCommController;
	INT 			theSensorCode;
	ACCESSTYPE 		readOnly;
	PCHAR 			theValue;
    virtual INT storeValue(const PCHAR aValue);
    PCHAR lookupSensorName(INT anIsaCode);
    

public:
	Sensor( PDevice aParent, PCommController aCommController, INT aSensorCode, ACCESSTYPE aReadOnly = AREAD_ONLY);
	virtual ~Sensor();
	
//overidden interfaces

	virtual INT Update(PEvent anEvent);

//additional public interfaces

	virtual INT Get(PCHAR);
	virtual INT Get(INT, PCHAR);
	virtual INT DeepGet(PCHAR = (PCHAR)NULL);
    virtual INT DeepGetWithoutUpdate(PCHAR = NULL);
	virtual INT Set(const PCHAR);
	virtual INT Set(INT, const PCHAR);
	virtual INT Validate(INT, const PCHAR) { return ErrNO_ERROR; } ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\shutdel.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  pcy14Dec92: Changed READ_WRITE to AREAD_WRITE
 *
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "shutdel.h"

ShutdownDelaySensor :: ShutdownDelaySensor(PDevice aParent, PCommController aCommController)
			: EepromChoiceSensor(aParent, aCommController, SHUTDOWN_DELAY, AREAD_WRITE)
{
	getAllowedValues();
    setInitialValue();
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\shutdel.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *
 */
#ifndef SHUTDEL_H
#define SHUTDEL_H

#include "eeprom.h"

_CLASSDEF(ShutdownDelaySensor)

class ShutdownDelaySensor : public EepromChoiceSensor {
   
public:
   ShutdownDelaySensor(PDevice aParent, PCommController aCommController=NULL);
   virtual INT IsA() const { return SHUTDOWNDELAYSENSOR; };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\serport.h ===
/*
 * REVISIONS:
 *  rct03Nov93: Broke off from port.h
 *  cad08Dec93: slight interface changes
 *  ajr01Feb94: Added backups support for unix
 *  ajr01Feb94: Added Shared Memory stuff for unix backups client communications
 *  srt28Mar96: Added support for pnp cables.
 *  cgm08Dec95: Added rTag as static variable for NLM
 *  dml17Jun96: Removed include port.h for NT platforms
*/



#ifndef _INC__SERPORT_H
#define _INC__SERPORT_H

/**************************************************************************/
#include <tchar.h>
#include "cdefine.h"
#include "_defs.h"
#include "apc.h"
#include "update.h"

#include "stream.h"


#include <windows.h>
enum cableTypes {NORMAL,PNP};

_CLASSDEF(SmartSerialPort)


/**************************************************************************
 *
 * Serial Port Classes
 * 
 **************************************************************************/

class SmartSerialPort : public Stream {

private:

    HANDLE  FileHandle;
    cableTypes theCableType;

	INT      RetryStatus;
	INT      BaudRate;
	PCHAR    DataBits; 
  	PCHAR    Parity; 
  	PCHAR    StopBits;
	ULONG    theWaitTime;

    TCHAR theSmartSerialPortName[32];

public:
   SmartSerialPort(TCHAR* aPortName, cableTypes aCableType);
   INT      Read(CHAR* buffer, USHORT* size, ULONG timeout = READ_TIMEOUT);
   INT      Read(CHAR* buffer, USHORT* size) {return 0;};
   INT      SYSTOpenPort();
   INT      SYSTClosePort();
   INT      SYSTWriteToPort(PCHAR command);
   INT      SYSTReadFromPort(PCHAR buffer, USHORT* size, ULONG timeout = READ_TIMEOUT);

   SmartSerialPort(cableTypes aCableType);
   virtual ~SmartSerialPort() {Close();};
   INT   Initialize () {return (Open());}   	
   INT   Open();
   INT   Write(CHAR* command);
   INT   Close();
   VOID  SetWaitTime(ULONG time) {theWaitTime = time;};
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\servapp.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy30Nov92: Added header
 *  ane22Dec92: Added GetHost member function
 *  ane18Jan93: Added the data logger
 *  ane21Jan93: Added the error logger
 *  ane03Feb93: Added params to CreateXXXController routines
 *  rct07Feb93: removed some VOIDs...split off from mainapp
 *  rct17Feb93: Added host stuff
 *  tje26Feb93: Added support for Windows version
 *  cad11Nov93: Making sure timers aren't being left around
 *  cad15Nov93: Changed how comm lost handled
 *  cad18Nov93: ...more minor fixes
 *  cad10Dec93: added transitem get/set
 */

#ifndef _INC__SERVAPP_H
#define _INC__SERVAPP_H

#include "cdefine.h"
#include "_defs.h"
#include "apc.h"

//
// Defines
//
_CLASSDEF(ServerApplication)

//
// Implementation uses
//
#include "mainapp.h"
#include "devctrl.h"

extern PServerApplication _theApp;

//
// Interface uses
//
_CLASSDEF(Event)

class ServerApplication : public MainApplication {

public:
    ServerApplication();
    virtual ~ServerApplication();

    virtual INT  Start();
    virtual VOID Idle() = 0;
    virtual VOID Quit();
    virtual INT  Get(INT code,PCHAR value);
    virtual INT  Get(PTransactionItem);
    virtual INT  Set(INT code,const PCHAR value);
    virtual INT  Set(PTransactionItem);
    virtual INT  Update (PEvent anEvent);

    VOID DisableEvents(void);

protected:
    PDeviceController theDeviceController;
    INT               theForceDeviceRebuildFlag;
    ULONG             theTimerID;

private:
    INT CreateDeviceController(PEvent anEvent);
    INT InitializeDeviceController();

    INT theDeviceControllerInitialized;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\serport.cxx ===
/*
 *
 * REVISIONS:
 *  TSC17May93: Added SmartSerialPort :: SYSTClosePort()
 *  TSC31May93: Added define for _theConfigManager, changed SmartSerialPort
 *                       to native NT, added error logging
 *  rct03Nov93: Broke off from port.cxx
 *  cad08Dec93: slight interface changes, added constructors
 *  cad04Jan94: added debug flags
 *  pcy08Feb94: #if UNIX around theRLock
 *  rct07Mar94: Re-Added SimpleSerialPort::Close()
 *  jps14Jul94: commented out INCL_NOPMAPI; put os2.h inside extern "C"
 *  daf25Nov95: support for PNP cable   
 *  srt24Jan96: Windows specific functions moved into w31port.cxx  
 *  srt24Jan96: added theCableType field initialization on windows
 *  pav16Jun96: #ifdef !NT constructors that NT doesn't use
 *  dml17Jun96: Added missing return value for GetCableType
 *  pcy28Jun96: Initialize file handle so we dont crash
 *  cgm05Jul96: Changed Simple::Initialize to check Open() error code
 *  poc28Sep96: Added valuable debugging code.
 *  mds28Dec97: Initialized FileHandle to INVALID_HANDLE_VALUE in SimpleSerialPort
 *              constructor (for NT)
 */

#include "cdefine.h"

extern "C"{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
}

#include "serport.h"


#include "_defs.h"
#include "serport.h"
#include "err.h"
#include "cfgmgr.h"
#include "utils.h"

//
// Smart Serial Port class
//-------------------------------------------------------------------------

//++srb
SmartSerialPort::SmartSerialPort(cableTypes aCableType) :
      DataBits ("8"),
      Parity   ("0"),
      StopBits ("1"),
      BaudRate (2400),
      RetryStatus(0),
      theWaitTime(40L)
{  
		theCableType = aCableType; 
}

//++srb
SmartSerialPort::SmartSerialPort(TCHAR* aPortName, cableTypes aCableType) : 
                              DataBits ("8"),
                              Parity   ("0"),
                              StopBits ("1"),
                              BaudRate (2400),
                              RetryStatus(0),
                              theWaitTime(40L) 
{
			theCableType = aCableType;  

#if C_API & C_WIN32
   FileHandle=INVALID_HANDLE_VALUE;
#endif
    _stprintf(theSmartSerialPortName,_TEXT("%s\0"),aPortName);
}
    

//--------------------------------------------------------------------

INT  SmartSerialPort::Open()
{
   int ret = SYSTOpenPort();
   SetState (OPEN);

   return ret;
}



//-----------------------------------------------------------------------------

INT  SmartSerialPort::Write(PCHAR command)
{
   return SYSTWriteToPort(command);
}

//-----------------------------------------------------------------------------

INT  SmartSerialPort::Read(PCHAR buffer, USHORT* size, ULONG timeout)
{ 
   INT err = SYSTReadFromPort(buffer, size, timeout);
   return err;
}


//------------------------------------------------------------------------------

INT  SmartSerialPort::Close()
{ 
   if (GetState() == OPEN)
       SYSTClosePort();   
   SetState(CLOSED); 
   return ErrNO_ERROR; //TRUE; (SRT)  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\servapp.cxx ===
/*
*
* REVISIONS:
*/


#include "cdefine.h"

extern "C" {
#include <stdlib.h>
}

#include "_defs.h"
#include "servapp.h"
#include "codes.h"
#include "cfgmgr.h"
#include "trans.h"
#include "timerman.h"
#include "sysstate.h"
#include "event.h"

#include "utils.h"
// Retry a failed construction every 3 seconds
//const INT RETRY_CONSTRUCT_DELAY = 3000;
const INT RETRY_CONSTRUCT_DELAY = 3;


// When setting the port name, it might fix comm on its own
// making this == 0 will force a rebuild immediately, on
// the same thread
//
// #define WAIT_FOR_SET_TO_WORK    250     // 1/4 seconds
#define WAIT_FOR_SET_TO_WORK    1 /* 1 second */

// theDeviceControllerInitialized values
#define NEVER_DONE      0
#define IN_PROGRESS     1
#define COMPLETED       2


// This should be initialized in the main module

PServerApplication _theApp = NULL;


//-------------------------------------------------------------------

ServerApplication::ServerApplication() :
theTimerID(0),
theDeviceControllerInitialized(NEVER_DONE),
theForceDeviceRebuildFlag(FALSE),
theDeviceController((PDeviceController)NULL)
{
    _theApp = this;
}

//-------------------------------------------------------------------

ServerApplication::~ServerApplication()
{
    if (theTimerID) {

        if (_theTimerManager) {
            _theTimerManager->CancelTimer(theTimerID);
        }
        theTimerID = 0;
    }
}

//-------------------------------------------------------------------

INT ServerApplication::Start()
{

    // set the timezone variables
    SetTimeZone();

    Event start_event(MONITORING_STATUS, MONITORING_STARTED);
    Update(&start_event);

    CreateDeviceController((PEvent)NULL);

    InitializeDeviceController();

    return ErrNO_ERROR;
}

//-------------------------------------------------------------------

VOID ServerApplication::Quit()
{
    DisableEvents();  //srt28Mar97

    // Tell everyone that the service is stopping
    Event start_event(MONITORING_STATUS, MONITORING_STOPPED);
    Update(&start_event);

    // Stop all active threads ... NOTE that they are stopped
    // in a specific order.  theDataLog is independent and is stopped first,
    // theDeviceController will stop the UPS polling.  theServerController
    // will stop all incoming client requests and current connections.  Finally,
    // theTimerManager will stop executing timed events.
    if (theDeviceController) {
        theDeviceController->Stop();
    }

    if (_theTimerManager) {
        _theTimerManager->Stop();
    }

    // Return to simple signalling
    theDeviceController->Set(TURN_OFF_SMART_MODE, NULL);

    delete theDeviceController;
    theDeviceController = NULL;

    delete _theTimerManager;
    _theTimerManager = theTimerManager = NULL;
}

//-------------------------------------------------------------------

INT  ServerApplication::Set(INT code,const PCHAR value)
{
    INT err = ErrNO_ERROR;

    switch(code/1000) {
    case 0:                   // Ups
    case 1:                   // Measure ups

        if (theDeviceController)  {
            err = theDeviceController->Set(code,value);
        }
        else  {
            err = ErrCOMMUNICATION_LOST;
        }
        break;

    case 2:                   // Host

        if (code == RESET_UPS_COMM_PORT) {
            // Set this TRUE. If just setting the .ini file value
            // causes the retry to succeed, then the flag will be
            // reset and we won't bother forcing a rebuild
            // Note that by sending the event on the timer thread,
            // we serialize with the retries.
            //
            theForceDeviceRebuildFlag = TRUE;

            Event ev(COMMUNICATION_STATE, UPS_COMM_PORT_CHANGED);

#if (WAIT_FOR_SET_TO_WORK > 0)
            _theTimerManager->SetTheTimer(WAIT_FOR_SET_TO_WORK, &ev, this);
#else
            Update(&ev);
#endif
        }
        break;
    }
    return err;
}


//-------------------------------------------------------------------

INT ServerApplication::Set(PTransactionItem trans)
{
    INT err = ErrNO_ERROR;

    return err;
}


//-------------------------------------------------------------------

INT  ServerApplication::Get(INT code, PCHAR value)
{
    INT err = ErrNO_ERROR;

    switch(code/1000)  {
    case 0:               // Ups
        if (code == SYSTEM_STATE || code == UPS_STATE) {
            //
            // Really all we want is sytem state.  Ups state hangs around
            // to be compatible with old software (PowerNet)
            //
            ULONG system_state = 0;
            if (theDeviceController) {
                value[0] = 0;
                err = theDeviceController->Get(COMMUNICATION_STATE, value);
                ULONG comm_state = atol(value);
                if (comm_state == COMMUNICATION_ESTABLISHED) {

                    //
                    // Only get UPS State if we have Comm
                    //
                    value[0] = 0;
                    err = theDeviceController->Get(UPS_STATE, value);
                    system_state = atol(value);

                    //
                    // Just to make sure
                    //
                    CLEAR_BIT(system_state, COMMUNICATIONS_BIT);
                    CLEAR_BIT(system_state, SHUTDOWN_IN_PROGRESS_BIT);
                }
                else {
                    //
                    // pcy - I don't know why we don't return communication
                    // lost as an error here, but we do below.
                    //
                    SET_BIT(system_state, COMMUNICATIONS_BIT);
                }
                _ltoa(system_state, value, 10);
            }
            else  {
                SET_BIT(system_state, COMMUNICATIONS_BIT);
                _ltoa(system_state, value, 10);
                err = ErrCOMMUNICATION_LOST;
            }
            break;
        }

    case 1:               // Measure ups
        value[0] = 0;
        if (theDeviceController)  {
            err = theDeviceController->Get(code,value);
        }
        else  {
            err = ErrCOMMUNICATION_LOST;
        }
        break;

    case 2:               // Host
        //           printf("Getting from host\n");
        value[0] = 0;
        break;

    }
    return err;
}

//-------------------------------------------------------------------

INT ServerApplication::Get(PTransactionItem trans)
{
    INT err = ErrNO_ERROR;
    return err;
}


//-------------------------------------------------------------------

INT  ServerApplication::Update(PEvent anEvent)
{
    INT err = ErrNO_ERROR;
    int sentEventOn = FALSE;

    // If the communication is lost or we change ports, then
    // schedule a rebuild of the device controller
    if (anEvent->GetCode() == COMMUNICATION_STATE) {
        switch(atoi(anEvent->GetValue())) {

        case UPS_COMM_PORT_CHANGED:

            if (theForceDeviceRebuildFlag) {
                err = MainApplication::Update(anEvent);
                sentEventOn = TRUE;
                theDeviceController->Set(RETRY_CONSTRUCT, "Yes");
            }
            break;

        case COMMUNICATION_ESTABLISHED:

            if (theDeviceControllerInitialized == NEVER_DONE) {
                err = InitializeDeviceController();
            }
            theForceDeviceRebuildFlag = FALSE;
            // Fall through
        }
    }

    if (!sentEventOn) {
        err = MainApplication::Update(anEvent);
    }
    return err;
}

//-------------------------------------------------------------------
VOID ServerApplication::DisableEvents()
{
    if (theDeviceController) {
    theDeviceController->UnregisterEvent(UTILITY_LINE_CONDITION,this);
    theDeviceController->UnregisterEvent(BATTERY_CONDITION,this);
    theDeviceController->UnregisterEvent(RUN_TIME_EXPIRED,this);
    theDeviceController->UnregisterEvent(RUN_TIME_REMAINING,this);
    theDeviceController->UnregisterEvent(UPS_OFF_PENDING,this);
    // Register with the device for Shutdown - this will happen when the
    // server is a slave
    theDeviceController->UnregisterEvent(SHUTDOWN,this);
    theDeviceController->UnregisterEvent(SMART_BOOST_STATE,this);
    theDeviceController->UnregisterEvent(SMART_TRIM_STATE,this);
    theDeviceController->UnregisterEvent(UPS_LOAD,this);
    theDeviceController->UnregisterEvent(COMMUNICATION_STATE,this);
    theDeviceController->UnregisterEvent(SELF_TEST_RESULT,this);
    theDeviceController->UnregisterEvent(BATTERY_CALIBRATION_CONDITION,this);
    theDeviceController->UnregisterEvent(MIN_LINE_VOLTAGE,this);
    theDeviceController->UnregisterEvent(MAX_LINE_VOLTAGE,this);
    theDeviceController->UnregisterEvent(BYPASS_MODE, this);
    theDeviceController->UnregisterEvent(MATRIX_FAN_STATE, this);
    theDeviceController->UnregisterEvent(BYPASS_POWER_SUPPLY_CONDITION, this);
    theDeviceController->UnregisterEvent(SMART_CELL_SIGNAL_CABLE_STATE, this);
    theDeviceController->UnregisterEvent(REDUNDANCY_STATE, this);
    theDeviceController->UnregisterEvent(UPS_MODULE_ADDED, this);
    theDeviceController->UnregisterEvent(UPS_MODULE_REMOVED, this);
    theDeviceController->UnregisterEvent(UPS_MODULE_FAILED, this);
    theDeviceController->UnregisterEvent(BATTERY_ADDED, this);
    theDeviceController->UnregisterEvent(BATTERY_REMOVED, this);
    theDeviceController->UnregisterEvent(IM_OK, this);
    theDeviceController->UnregisterEvent(IM_FAILED, this);
    theDeviceController->UnregisterEvent(IM_INSTALLATION_STATE, this);
    theDeviceController->UnregisterEvent(RIM_INSTALLATION_STATE, this);
    theDeviceController->UnregisterEvent(RIM_OK, this);
    theDeviceController->UnregisterEvent(RIM_FAILED, this);
    theDeviceController->UnregisterEvent(SYSTEM_FAN_STATE, this);
    theDeviceController->UnregisterEvent(BYPASS_CONTACTOR_STATE, this);
    theDeviceController->UnregisterEvent(INPUT_BREAKER_STATE, this);
    theDeviceController->UnregisterEvent(UPS_TEMPERATURE, this);

    // MeasureUPS Events
    theDeviceController->UnregisterEvent(AMBIENT_TEMPERATURE,this);
    theDeviceController->UnregisterEvent(HUMIDITY,this);
    theDeviceController->UnregisterEvent(CONTACT_STATE,this);

    theDeviceController->UnregisterEvent(IM_STATUS,this);
    theDeviceController->UnregisterEvent(RIM_STATUS,this);
    theDeviceController->UnregisterEvent(BATTERY_REPLACEMENT_CONDITION,this);


    }
}

//-------------------------------------------------------------------

INT  ServerApplication::CreateDeviceController (PEvent anEvent)
{
    INT err = ErrNO_ERROR;

    //    printf("Entering CreateDeviceController\n");

    // Delete any existing device controller
    if (theDeviceController) {
        delete theDeviceController;
        theDeviceController = (PDeviceController)NULL;
    }

    // Now create a new device controller
    theDeviceController   = new DeviceController(this);

    theDeviceController->RegisterEvent(UTILITY_LINE_CONDITION,this);
    theDeviceController->RegisterEvent(BATTERY_CONDITION,this);
    theDeviceController->RegisterEvent(RUN_TIME_EXPIRED,this);
    theDeviceController->RegisterEvent(RUN_TIME_REMAINING,this);
    theDeviceController->RegisterEvent(UPS_OFF_PENDING,this);
    // Register with the device for Shutdown - this will happen when the
    // server is a slave
    theDeviceController->RegisterEvent(SHUTDOWN,this);
    theDeviceController->RegisterEvent(SMART_BOOST_STATE,this);
    theDeviceController->RegisterEvent(SMART_TRIM_STATE,this);
    theDeviceController->RegisterEvent(UPS_LOAD,this);
    theDeviceController->RegisterEvent(COMMUNICATION_STATE,this);
    theDeviceController->RegisterEvent(SELF_TEST_RESULT,this);
    theDeviceController->RegisterEvent(BATTERY_CALIBRATION_CONDITION,this);
    theDeviceController->RegisterEvent(MIN_LINE_VOLTAGE,this);
    theDeviceController->RegisterEvent(MAX_LINE_VOLTAGE,this);
    theDeviceController->RegisterEvent(BYPASS_MODE, this);
    theDeviceController->RegisterEvent(MATRIX_FAN_STATE, this);
    theDeviceController->RegisterEvent(BYPASS_POWER_SUPPLY_CONDITION, this);
    theDeviceController->RegisterEvent(SMART_CELL_SIGNAL_CABLE_STATE, this);
    theDeviceController->RegisterEvent(REDUNDANCY_STATE, this);
    theDeviceController->RegisterEvent(UPS_MODULE_ADDED, this);
    theDeviceController->RegisterEvent(UPS_MODULE_REMOVED, this);
    theDeviceController->RegisterEvent(UPS_MODULE_FAILED, this);
    theDeviceController->RegisterEvent(BATTERY_ADDED, this);
    theDeviceController->RegisterEvent(BATTERY_REMOVED, this);
    theDeviceController->RegisterEvent(IM_STATUS, this);
    theDeviceController->RegisterEvent(IM_OK, this);
    theDeviceController->RegisterEvent(IM_FAILED, this);
    theDeviceController->RegisterEvent(IM_INSTALLATION_STATE, this);
    theDeviceController->RegisterEvent(RIM_INSTALLATION_STATE, this);
    theDeviceController->RegisterEvent(RIM_STATUS, this);
    theDeviceController->RegisterEvent(RIM_OK, this);
    theDeviceController->RegisterEvent(RIM_FAILED, this);
    theDeviceController->RegisterEvent(SYSTEM_FAN_STATE, this);
    theDeviceController->RegisterEvent(BYPASS_CONTACTOR_STATE, this);
    theDeviceController->RegisterEvent(INPUT_BREAKER_STATE, this);
    theDeviceController->RegisterEvent(UPS_TEMPERATURE, this);
    theDeviceController->RegisterEvent(TOTAL_INVERTERS, this);
    theDeviceController->RegisterEvent(NUMBER_BAD_INVERTERS, this);
    theDeviceController->RegisterEvent(BAD_BATTERY_PACKS, this);
    theDeviceController->RegisterEvent(EXTERNAL_BATTERY_PACKS, this);
    theDeviceController->RegisterEvent(BATTERY_REPLACEMENT_CONDITION, this);

    // MeasureUPS Events
    theDeviceController->RegisterEvent(AMBIENT_TEMPERATURE,this);
    theDeviceController->RegisterEvent(HUMIDITY,this);
    theDeviceController->RegisterEvent(CONTACT_STATE,this);

    return err;
}

//-------------------------------------------------------------------


INT ServerApplication::InitializeDeviceController()
{
    INT err = theDeviceController->GetObjectStatus();

    // Make sure that the object constructed ok

    if (err == ErrNO_ERROR) {
        theDeviceControllerInitialized = IN_PROGRESS;
        err = theDeviceController->Initialize();

        if (err == ErrNO_ERROR)  {
            theDeviceControllerInitialized = COMPLETED;
        }
    }
    return err;
}


//-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\simpsens.h ===
/*
 *
 * REVISIONS:
 *  xxxddMMMyy 
 *
 */
#ifndef __SIMPSENS_H
#define __SIMPSENS_H

#include "ulinecon.h"
#include "battcond.h"
#include "turnoff.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\slist.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy14Dec92: Changed Sortable to ApcSortable 
 *  cad31Aug93: removing compiler warnings
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */

#ifndef __SLIST_H
#define __SLIST_H

#include "apc.h"

#include "apcobj.h"
#include "node.h"
#include "list.h"
#include "protlist.h"

_CLASSDEF(List)
_CLASSDEF(ApcSortable)
_CLASSDEF(SortedList)
_CLASSDEF(ProtectedSortedList)

class  SortedList : public List {
protected:
   friend class ListIterator;
public:

   SortedList();
   virtual ~SortedList() { Flush(); };

   virtual VOID     Add( RObj ) {};
   virtual VOID     Add( RApcSortable );
};

class  ProtectedSortedList : public ProtectedList {
protected:
   friend class ListIterator;
public:

   ProtectedSortedList();

   virtual VOID     Add( RObj ) {};
   virtual VOID     Add( RApcSortable );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\slist.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy14Dec92: Changed Sortable to ApcSortable 
 *  ane11Jan93: Reassign theHead in Add when appropriate
 *  jps14Jul94: added stdlib.h for os2
 *
 */

#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

extern "C"
{
#if (C_OS & C_OS2)
#include <stdlib.h>
#endif
#include <string.h>
}

#include "slist.h"
#include "sortable.h"


//------------------------------------------------------------------------
SortedList::   SortedList() :  List()
{
}

//------------------------------------------------------------------------
void SortedList::Add( RApcSortable anObject )
{
    if (theHead == (PNode)NULL)
    {
        theHead = new Node( &anObject);
        theTail = theHead;
    }
    else
    {
        INT Done = FALSE;
        PNode current = GetHeadNode();
        PNode previous = current->GetPrev();  // This shouldbe NULL
        while (!Done)
        {
            PApcSortable sortobj = (PApcSortable)current->GetData();
            if ( sortobj->LessThan(&anObject) )
            {
                previous = current;
                current = previous->GetNext();
                if (!current)   // At the end
                    Done = TRUE;
            }
            else
            {
               Done = TRUE;
            }
        }

        PNode temp = new Node( &anObject, current, previous);
        if (current)
            current->SetPrev(temp);
        if (previous)            //  Just in case you are adding to the head
            previous->SetNext(temp);
        else
            theHead = temp;
    }
    theItemsInContainer++;
}

//------------------------------------------------------------------------
ProtectedSortedList::ProtectedSortedList() :  ProtectedList()
{
}

//------------------------------------------------------------------------
void ProtectedSortedList::Add( RApcSortable anObject )
{
    Request();

    if (theHead == (PNode)NULL)
    {
        theHead = new Node( &anObject);
        theTail = theHead;
    }
    else
    {
        INT Done = FALSE;
        PNode current = GetHeadNode();
        PNode previous = current->GetPrev();  // This shouldbe NULL
        while (!Done)
        {
            PApcSortable sortobj = (PApcSortable)current->GetData();
            if ( sortobj->LessThan(&anObject) )
            {
                previous = current;
                current = previous->GetNext();
                if (!current)   // At the end
                    Done = TRUE;
            }
            else
            {
               Done = TRUE;
            }
        }

        PNode temp = new Node( &anObject, current, previous);
        if (current)
            current->SetPrev(temp);
        if (previous)            //  Just in case you are adding to the head
            previous->SetNext(temp);
        else
            theHead = temp;
    }
    theItemsInContainer++;

    Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\smboosen.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker25NOV92   Initial OS/2 Revision
 *  cgm12Apr96: Destructor with unregister
 */
 
#ifndef __SMBOOSEN_H
#define __SMBOOSEN_H

#include "stsensor.h"
#include "event.h"

_CLASSDEF(SmartBoostSensor)

			  
class SmartBoostSensor : public StateSensor {


protected:
        
public:
	SmartBoostSensor( PDevice 	  aParent, 
                      PCommController aCommController);
    virtual ~SmartBoostSensor();
	
//overidden interfaces

	virtual INT IsA() const { return SMARTBOOSTSENSOR; };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\smartups.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  rct11Dec92	Compiled w/o the managers
 *  pcy27Dec92	Added the managers
 *  pcy26Jan92: Added handling of dip switch changed/eeprom access
 *  ane03Feb93: added destructor
 *  jod05Apr93: Added changes for Deep Discharge
 *  cad08Jan94: made firmrevsensor specific type
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  jps14Jul94: made ...TimerId LONG
 *  djs14Mar95: Added OverloadSensor
 */

#ifndef _INC__SMARTUPS_H_
#define _INC__SMARTUPS_H_


#include "backups.h"

#include "sensor.h"
#include "battmgr.h"
#include "event.h"

_CLASSDEF(FirmwareRevSensor)
_CLASSDEF(SmartUps)


//-------------------------------------------------------------------

class SmartUps : public BackUps {

public:

    SmartUps( PUpdateObj aDeviceController, PCommController aCommController );
    virtual ~SmartUps();

    virtual INT  IsA() const { return SMARTUPS; };
    virtual INT Get( INT code, PCHAR value );
    virtual INT Set( INT code, const PCHAR value );
    virtual INT Update( PEvent event );
    virtual VOID GetAllowedValue(INT theSensorCode, CHAR *allowedValue);

protected:
    //
    // required sensors
    //
    PSensor                    theLightsTestSensor;
    PFirmwareRevSensor         theFirmwareRevSensor;
    PDecimalFirmwareRevSensor  theDecimalFirmwareRevSensor;
    PSensor                    theUpsModelSensor;
    PSensor                    theUpsSerialNumberSensor;
    PSensor                    theManufactureDateSensor;
    PSensor                    thePutUpsToSleepSensor;
    PSensor                    theBatteryCapacitySensor;
    PSensor                    theSmartBoostSensor;
    PSensor                    theSmartTrimSensor;
    PSensor                    theCopyrightSensor;
    PSensor                    theRunTimeRemainingSensor;
    PSensor                    theNumberBatteryPacksSensor;
    PBatteryReplacementManager theBatteryReplacementManager;
    PSensor                    theTripRegisterSensor;
    PSensor                    theTurnOffWithDelaySensor;
    PSensor                    theLowBatteryDurationSensor;
    PSensor                    theShutdownDelaySensor;

    virtual VOID   HandleLineConditionEvent( PEvent aEvent );
    virtual VOID   HandleBatteryConditionEvent( PEvent aEvent );
    virtual VOID   HandleSmartBoostEvent( PEvent aEvent );
    virtual VOID   HandleSmartTrimEvent( PEvent aEvent );
    virtual VOID   HandleOverloadConditionEvent( PEvent aEvent );
    virtual VOID   HandleSelfTestEvent( PEvent aEvent );
    virtual VOID   HandleBatteryCalibrationEvent( PEvent aEvent );
    virtual VOID   HandleLightsTestEvent( PEvent aEvent );

    virtual INT    MakeBatteryCapacitySensor( const PFirmwareRevSensor rev );
    virtual INT    MakeSmartBoostSensor( const PFirmwareRevSensor rev );
    virtual INT    MakeSmartTrimSensor( const PFirmwareRevSensor rev );
    virtual INT    MakeCopyrightSensor( const PFirmwareRevSensor rev );
    virtual INT    MakeRunTimeRemainingSensor( const PFirmwareRevSensor rev );
    virtual INT    MakeManufactureDateSensor( const PFirmwareRevSensor rev );
    virtual INT    MakeLowBatteryDurationSensor( const PFirmwareRevSensor rev );
    virtual INT    MakeShutdownDelaySensor(const PFirmwareRevSensor rev);
    virtual INT    MakeUpsSerialNumberSensor( const PFirmwareRevSensor rev );
    virtual INT    MakeTurnOffWithDelaySensor( const PFirmwareRevSensor rev );
    virtual INT    MakePutUpsToSleepSensor();

    LONG           pendingEventTimerId;
    PEvent         pendingEvent;

    virtual VOID   registerForEvents();
    virtual VOID   reinitialize();

    VOID setEepromAccess(INT anAccessCode);
    INT GetAllAllowedValues(PList ValueList);
    INT  ParseValues(CHAR* string, PList ValueList);
    INT  AllowedValuesAreGettable(PSensor theFirmwareRevSensor);
    VOID FindAllowedValues(INT code, CHAR *aValue, PFirmwareRevSensor theFirmwareRevSensor );
};


class AllowedValueItem  : public Obj
{

protected:
   INT   theCode;
   CHAR theUpsType;
   CHAR* theValue;

public:
   AllowedValueItem(INT Code,CHAR Type, CHAR* Value);
   virtual ~AllowedValueItem();

   CHAR  GetUpsType() {return theUpsType;}
   INT   GetUpsCode() {return theCode;}
   CHAR* GetValue()   {return theValue;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\smartups.cxx ===
/*
 *  cad07Oct93: SU400 changes, added get codes for programming and load sens
 *  cad12Oct93: Oops, missed one.
 *  cad02Nov93: name changes
 *  cad09Nov93: su250/400 fixes
 *  cad09Nov93: Turn off eeprom access during calibration
 *  cad11Nov93: Making sure all timers are cancelled on destruction
 *  cad10Dec93: fix for dip switches changing on the fly
 *  rct21Dec93: changed determineXferCause() & HandleLineCond...
 *  cad08Jan94: fixes for sub-sensors, getting ups model from ini file
 *  ajr15Feb94: fixed TIMED_RUN_TIME_REMAINING case in SmartUps
 *  pcy04Mar94: fixed overload handling
 *  cad04Mar94: fixed up eeprom access
 *  ajr09Mar94: made HandleBatteryConditionEvent check for ErrUNSUPPORTED
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
 *  pcy19Apr94: port for SGI
 *  ajr25Apr94: Some compilers balk at the auto array init....
 *  ajr24May94: had to explicitly scope dip_sensor->Get for Unixware...
 *  ajr10Aug94: Could not match with ^\0 in scanf.  Had to go with ^# in
 *              SmartUps::ParseValues
 *  jps01Oct94: Commented out deepget of boost in reinit: was causing back end to
 *              miss transitions to/from boost while no comm.
 *  djs14Mar95: Added OverloadSensor
 *  ajr03Jun95: Stopped carrying time around in milliseconds
 *  djs05Feb96: Added firmware rev codes and smarttrim
 *  cgm29Feb96: Test for Smart mode
 *  cgm17Apr96: Test return value on GetAllowedValues for a fail
 *  pcy28Jun96: Added IS_ stuff for menus
 *  djs12Jul96: Added IS_ stuff for bar graphs
 *  djs23Sep96: Added check for smart boost off without on battery condition
 *  djs02Oct96: Added Duet UPS_TEMP check
 *  jps14Oct96: Changed AUTO_REBOOT_ENABLED ->Get() to ->Set() in Set()
 *  jps17Oct96: Added low battery event when LOW_BATTERY_DURATION changed to value
 *              smaller than current run time remaining
 *  jps15Nov96: Added LIGHTS_TEST test to HandleOverloadConditionEvent(), SIR 4536
 *  djs19Nov96: Added Battery Calibration Test to Get
 *  djs01Dec96: Cleaned up processing of Boost/Trim and lost comm
 *  srt31Jan96: Fixed small bug w/ state test in HandleOverloadCondition.
 *  srt11Jun97: Added IS_EXT_SLEEP_UPS case
 *  dma26Nov97: Fixed bug with monitoring a 2G Smart-Ups.
 *  dma15Dec97: Eliminated Update call in HandleSmartTrimEvent and
 *              HandleSmartBoostEvent to eliminate duplicate logging
 *              of SmartTrim/SmartBoost events.  Update is now called in our
 *              new DeepGet
 *  dma06Jan98: Removed the restraint on UTILITY_LINE_CONDITION case of
 *              Update which would not allow the battery line condition
 *              to be updated during a self test.
 *  clk11Feb98: Changed DeepGet to DeepGetWithoutUpdate in HandleLineCondition
 *              and added Update to HandleSmartBoost/TrimEvent's
 *  dma11Feb98: Fixed problem with detecting a battery that needed replacement.
 *  tjg02Mar98: Added handling for LIGHTS_TEST code to Get
 *
 *  v-stebe  29Jul2000   Fixed PREfix errors (bugs #112610, #112613)
 */


#include "cdefine.h"
#include "_defs.h"
#include <stdlib.h>

extern "C" {
#include <stdio.h>
}

#include "smartups.h"
#include "unssens.h"
#include "smrtsens.h"
#include "simpsens.h"
#include "firmrevs.h"
#include "dcfrmrev.h"
#include "timerman.h"
#include "dispatch.h"
#include "cfgmgr.h"
#include "cfgcodes.h"

_CLASSDEF( DeviceController )
_CLASSDEF( UnsupportedSensor )
			
PList AllowedValuesList;

SmartUps::SmartUps(PUpdateObj aDeviceController, PCommController aCommController)
: BackUps(aDeviceController, aCommController),
  pendingEventTimerId(0)
{
    INT err = ErrNO_ERROR;

    // Turn on Smart Mode
    if((err = theCommController->Set(TURN_ON_SMART_MODE, (CHAR*)NULL)) != ErrNO_ERROR) {
        theObjectStatus = ErrSMART_MODE_FAILED;
        theFirmwareRevSensor = (PFirmwareRevSensor)NULL;
        theDecimalFirmwareRevSensor = (PDecimalFirmwareRevSensor)NULL;
        theCopyrightSensor = (PSensor)NULL;
        theTripRegisterSensor = (PSensor)NULL;
        theLightsTestSensor = (PSensor)NULL;
        theBatteryReplacementManager = (PBatteryReplacementManager)NULL;
        theBatteryCapacitySensor = (PSensor)NULL;
        theSmartBoostSensor = (PSensor)NULL;
        theRunTimeRemainingSensor = (PSensor)NULL;
        theLowBatteryDurationSensor = (PSensor)NULL;
        theShutdownDelaySensor = (PSensor)NULL;
        theManufactureDateSensor = (PSensor)NULL;
        theUpsSerialNumberSensor = (PSensor)NULL;
        theTurnOffWithDelaySensor = (PSensor)NULL;
        thePutUpsToSleepSensor = (PSensor)NULL;
    }
    else  {
        // NEW CODE
        theObjectStatus = ErrNO_ERROR;

        theFirmwareRevSensor = new FirmwareRevSensor(this, aCommController);
        theDecimalFirmwareRevSensor = new DecimalFirmwareRevSensor(this, aCommController);


        // New for CTRL Z  processing    ---  JOD
        AllowedValuesList = new List();
        err = GetAllAllowedValues(AllowedValuesList);

        if (err != ErrNO_ERROR) {
            theObjectStatus = ErrSMART_MODE_FAILED;

            theUpsModelSensor = (PSensor)NULL;
            theNumberBatteryPacksSensor = (PSensor)NULL;
            theCopyrightSensor = (PSensor)NULL;
            theTripRegisterSensor = (PSensor)NULL;
            theLightsTestSensor = (PSensor)NULL;
            theBatteryReplacementManager = (PBatteryReplacementManager)NULL;
            theBatteryCapacitySensor = (PSensor)NULL;
            theSmartBoostSensor = (PSensor)NULL;
            theRunTimeRemainingSensor = (PSensor)NULL;
            theLowBatteryDurationSensor = (PSensor)NULL;
            theShutdownDelaySensor = (PSensor)NULL;
            theManufactureDateSensor = (PSensor)NULL;
            theUpsSerialNumberSensor = (PSensor)NULL;
            theTurnOffWithDelaySensor = (PSensor)NULL;
            thePutUpsToSleepSensor = (PSensor)NULL;
        }
        else
        {
            theUpsModelSensor = new UpsModelSensor(this, theCommController, theFirmwareRevSensor);
            theNumberBatteryPacksSensor = new NumberBatteryPacksSensor(this, aCommController,theFirmwareRevSensor);

            MakeCopyrightSensor( theFirmwareRevSensor );

            if ((theCopyrightSensor != NULL) && ((err = theCopyrightSensor->GetObjectStatus()) != ErrNO_ERROR)) {
                theObjectStatus = ErrCOPYRIGHT_RESP_ERROR;
            }

            theTripRegisterSensor = new TripRegisterSensor(this, aCommController );
            theLightsTestSensor = new LightsTestSensor(this, aCommController );

            theBatteryReplacementManager = new BatteryReplacementManager(this, aCommController, theFirmwareRevSensor );

            MakeBatteryCapacitySensor( theFirmwareRevSensor );
            MakeSmartBoostSensor( theFirmwareRevSensor );
            MakeSmartTrimSensor( theFirmwareRevSensor );
            MakeRunTimeRemainingSensor( theFirmwareRevSensor );

            MakeLowBatteryDurationSensor( theFirmwareRevSensor );
            MakeShutdownDelaySensor( theFirmwareRevSensor );
            MakeManufactureDateSensor( theFirmwareRevSensor );
            MakeUpsSerialNumberSensor( theFirmwareRevSensor );

            MakeTurnOffWithDelaySensor( theFirmwareRevSensor );
            MakePutUpsToSleepSensor();

            CHAR programmable[32];
            Get(IS_EEPROM_PROGRAMMABLE, programmable);

            setEepromAccess((_strcmpi(programmable, "YES") == 0) ? AREAD_WRITE : AREAD_ONLY);
            pendingEvent = (PEvent)NULL;
        }

        if (AllowedValuesList) {
            AllowedValuesList->FlushAll();
            delete AllowedValuesList;
            AllowedValuesList = (List*)NULL;
        }
    }				
}
								

SmartUps::~SmartUps()
{
    if (pendingEventTimerId) {
        _theTimerManager->CancelTimer(pendingEventTimerId);
        pendingEventTimerId = 0;
    }
    delete theNumberBatteryPacksSensor;
    theNumberBatteryPacksSensor = NULL;

    delete theFirmwareRevSensor;
    theFirmwareRevSensor = NULL;

    delete theDecimalFirmwareRevSensor;
    theDecimalFirmwareRevSensor = NULL;

    delete theTripRegisterSensor;
    theTripRegisterSensor = NULL;

    delete theLightsTestSensor;
    theLightsTestSensor = NULL;

    delete theBatteryReplacementManager;
    theBatteryReplacementManager = NULL;

    if (theCopyrightSensor && (theCopyrightSensor != &_theUnsupportedSensor)) {
        delete theCopyrightSensor;
        theCopyrightSensor = NULL;
    }

    if (theBatteryCapacitySensor && (theBatteryCapacitySensor != &_theUnsupportedSensor)) {
        delete theBatteryCapacitySensor;
        theBatteryCapacitySensor = NULL;
    }

    if (theSmartBoostSensor && (theSmartBoostSensor != &_theUnsupportedSensor)) {
        delete theSmartBoostSensor;
        theSmartBoostSensor = NULL;
    }

    if (theSmartTrimSensor && (theSmartTrimSensor != &_theUnsupportedSensor)) {
        delete theSmartTrimSensor;
        theSmartTrimSensor = NULL;
    }

    if (theRunTimeRemainingSensor && (theRunTimeRemainingSensor != &_theUnsupportedSensor)) {
        delete theRunTimeRemainingSensor;
        theRunTimeRemainingSensor = NULL;
    }

    if (theLowBatteryDurationSensor && (theLowBatteryDurationSensor != &_theUnsupportedSensor)) {
        delete theLowBatteryDurationSensor;
        theLowBatteryDurationSensor = NULL;
    }

    if (theShutdownDelaySensor && (theShutdownDelaySensor != &_theUnsupportedSensor)) {
        delete theShutdownDelaySensor;
        theShutdownDelaySensor = NULL;
    }

    if (theManufactureDateSensor && (theManufactureDateSensor != &_theUnsupportedSensor)) {
        delete theManufactureDateSensor;
        theManufactureDateSensor = NULL;
    }

    if (theUpsSerialNumberSensor && (theUpsSerialNumberSensor != &_theUnsupportedSensor)) {
        delete theUpsSerialNumberSensor;
        theUpsSerialNumberSensor = NULL;
    }

    if (theTurnOffWithDelaySensor && (theTurnOffWithDelaySensor != &_theUnsupportedSensor)) {
        delete theTurnOffWithDelaySensor;
        theTurnOffWithDelaySensor = NULL;
    }

    if (thePutUpsToSleepSensor && (thePutUpsToSleepSensor != &_theUnsupportedSensor)) {
        delete thePutUpsToSleepSensor;
        thePutUpsToSleepSensor = NULL;
    }
    delete theUpsModelSensor;
    theUpsModelSensor = NULL;
}


//-------------------------------------------------------------------------

VOID SmartUps::registerForEvents()
{
    BackUps::registerForEvents();

    theCommController->RegisterEvent(COMMUNICATION_STATE, this);
    theSmartBoostSensor->RegisterEvent(SMART_BOOST_STATE, this);
    theSmartTrimSensor->RegisterEvent(SMART_TRIM_STATE, this);
    theLightsTestSensor->RegisterEvent(LIGHTS_TEST, this);
    thePutUpsToSleepSensor->RegisterEvent(UPS_OFF_PENDING, this);
    theTurnOffWithDelaySensor->RegisterEvent(UPS_OFF_PENDING, this);
    theRunTimeRemainingSensor->RegisterEvent(RUN_TIME_REMAINING, this);
    theBatteryReplacementManager->RegisterEvent(BATTERY_REPLACEMENT_CONDITION, this);
}



//-------------------------------------------------------------------------

INT SmartUps::Get(INT code, PCHAR aValue)
{
    INT err = ErrNO_ERROR;

    switch(code)
    {

    case UTILITY_LINE_CONDITION:
    case BATTERY_CONDITION:
    case UPS_STATE:
    case MAX_BATTERY_RUN_TIME:
    case TIME_ON_BATTERY:
        err = BackUps::Get(code, aValue);
        break;
    case BATTERY_CALIBRATION_TEST:
        err = ErrUNSUPPORTED;
        break;

    case IS_UPS_LOAD:
    case IS_UTILITY_VOLTAGE:
    case IS_OUTPUT_VOLTAGE:
        strcpy(aValue,"Yes");
        break;
    case IS_ADMIN_SHUTDOWN:
        err = theFirmwareRevSensor->Get(code, aValue);
        break;

    case EXTERNAL_PACKS_CHANGEABLE:
        err = theFirmwareRevSensor->Get(code, aValue);
        break;

    case EXTERNAL_BATTERY_PACKS:
        err = theNumberBatteryPacksSensor->Get(code,aValue);
        break;
    case INTERNAL_BATTERY_PACKS:
        err = theNumberBatteryPacksSensor->Get(code,aValue);
        break;

    case TOTAL_BATTERY_PACKS:
        err = theNumberBatteryPacksSensor->Get(code, aValue);
        break;

    case DECIMAL_FIRMWARE_REV:
        err = theDecimalFirmwareRevSensor->Get(DECIMAL_FIRMWARE_REV, aValue);
        break;

    case LIGHTS_TEST:
        err = theLightsTestSensor->Get(code, aValue);
        break;

    case IS_UPS_TEMPERATURE:
        {
            err = theDecimalFirmwareRevSensor->Get(DECIMAL_FIRMWARE_REV, aValue);
            if (err == ErrNO_ERROR)
            {
                INT first_segment = atoi(strtok(aValue,"."));

                // Duet UPSs (b firmware response 10,11,12,21 and 22) do not support UPS temp

                if ((first_segment > 9 && first_segment < 13) ||
                    (first_segment > 20 && first_segment < 23))
                {
                    strcpy(aValue, "NO");
                }
                else
                {
                    strcpy(aValue, "YES");
                }
            }
            else
            {
                strcpy(aValue, "YES");
            }
            err = ErrNO_ERROR;
        }
        break;

    case SELF_TEST_STATE:
    case SELF_TEST_DAY:
    case SELF_TEST_TIME:
    case SELF_TEST_SETTING:
    case SELF_TEST_RESULT:
    case SELF_TEST_LAST_DATE:
    case SELF_TEST_LAST_TIME:
    case SELFTEST_LIST:
        err = ErrUNSUPPORTED;
        break;

    case SMART_BOOST_STATE:
        err = theSmartBoostSensor->Get(code, aValue);
        break;

    case SMART_TRIM_STATE:
        err = theSmartTrimSensor->Get(code, aValue);
        break;

    case BATTERY_VOLTAGE:
    case RATED_BATTERY_VOLTAGE :
    case LOW_BATTERY_VOLTAGE_THRESHOLD:
    case HIGH_BATTERY_VOLTAGE_THRESHOLD:
        err = ErrUNSUPPORTED;
        break;

    case BATTERY_CAPACITY:
        err = theBatteryCapacitySensor->Get(code, aValue);
        break;

    case UPS_TEMPERATURE:
        err = ErrUNSUPPORTED;
        break;

    case LOW_UPS_TEMP_THRESHOLD:
        err = ErrUNSUPPORTED;
        break;

    case HIGH_UPS_TEMP_THRESHOLD:
        err = ErrUNSUPPORTED;
        break;

    case LOW_UPS_TEMP_THRESHOLD_ENABLED:
        err = ErrUNSUPPORTED;
        break;

    case HIGH_UPS_TEMP_THRESHOLD_ENABLED:
        err = ErrUNSUPPORTED;
        break;

    case OUTPUT_FREQUENCY:
        err = ErrUNSUPPORTED;
        break;

    case RATED_OUTPUT_VOLTAGE:
    case LINE_VOLTAGE:
    case MIN_LINE_VOLTAGE:
    case MAX_LINE_VOLTAGE:
    case OUTPUT_VOLTAGE:
    case HIGH_TRANSFER_VOLTAGE:
    case LOW_TRANSFER_VOLTAGE:
    case ALLOWED_RATED_OUTPUT_VOLTAGES:
    case ALLOWED_HIGH_TRANSFER_VOLTAGES:
    case ALLOWED_LOW_TRANSFER_VOLTAGES:
        err = ErrUNSUPPORTED;
        break;


    case UPS_LOAD:
        err = ErrUNSUPPORTED;
        break;
    case LOW_LOAD_THRESHOLD:
        err = ErrUNSUPPORTED;
        break;

    case HIGH_LOAD_THRESHOLD:
        err = ErrUNSUPPORTED;
        break;

    case TRIP_REGISTER:
        err = theTripRegisterSensor->Get(code, aValue);
        break;

    case RUN_TIME_REMAINING:
        err = theRunTimeRemainingSensor->Get(code, aValue);
        break;

    case BATTERY_REPLACEMENT_DATE:
    case BATTERY_AGE_LIMIT:
        err = theBatteryReplacementManager->Get(code, aValue);
        break;

    case UPS_ID:
        err = ErrUNSUPPORTED;
        break;

    case UPS_SENSITIVITY:
        err = ErrUNSUPPORTED;
        break;

    case ALLOWED_UPS_SENSITIVITIES:
        err = ErrUNSUPPORTED;
        break;

    case LOW_BATTERY_DURATION:
        err = theLowBatteryDurationSensor->Get(code, aValue);
        break;

    case ALLOWED_LOW_BATTERY_DURATIONS:
        err = theLowBatteryDurationSensor->Get(ALLOWED_VALUES, aValue);
        break;

    case ALARM_DELAY:
        err = ErrUNSUPPORTED;
        break;

    case ALLOWED_ALARM_DELAYS:
        err = ErrUNSUPPORTED;
        break;

    case SHUTDOWN_DELAY:
        err = theShutdownDelaySensor->Get(code, aValue);
        break;

    case ALLOWED_SHUTDOWN_DELAYS:
        err = theShutdownDelaySensor->Get(ALLOWED_VALUES, aValue);
        break;

    case TURN_ON_DELAY:
        err = ErrUNSUPPORTED;
        break;

    case ALLOWED_TURN_ON_DELAYS:
        err = ErrUNSUPPORTED;
        break;

    case MIN_RETURN_CAPACITY:
        err = ErrUNSUPPORTED;
        break;

    case ALLOWED_MIN_RETURN_CAPACITIES:
        err = ErrUNSUPPORTED;
        break;

    case DIP_SWITCH_POSITION :
        err = ErrUNSUPPORTED;
        break;

    case COPYRIGHT :
        err = theCopyrightSensor->Get(code, aValue);
        break;

    case MANUFACTURE_DATE :
        err = theManufactureDateSensor->Get(code, aValue);
        break;

    case UPS_SERIAL_NUMBER :
        err = theUpsSerialNumberSensor->Get(code, aValue);
        break;

    case UPS_MODEL :
        err = theUpsModelSensor->Get(UPS_MODEL_NAME, aValue);
        break;

    case TIMED_RUN_TIME_REMAINING:
        if(theRunTimeExpiration)
        {
            // some compilers balk at auto array initialization
            CHAR enabled[64];
            memset(enabled,(int)'\0',64);
            theDeviceController->Get(IS_LINE_FAIL_RUN_TIME_ENABLED,enabled);

            if (_strcmpi(enabled,"NO") == 0)
            {
                err =theRunTimeRemainingSensor->Get(RUN_TIME_REMAINING,
                    aValue);
            }
            else
            {
                err = ErrUNSUPPORTED;
            }
        }
        else
        {
            err = ErrNO_VALUE;
        }

        break;

    case BATTERY_CALIBRATION_DAY:
    case BATTERY_CALIBRATION_TIME:
    case BATTERY_CALIBRATION_ENABLED:
    case BATTERY_CALIBRATION_LAST_DATE:
    case BATTERY_CALIBRATION_LIST:
        err = ErrUNSUPPORTED;
        break;

    case AUTO_REBOOT_ENABLED:
        err = theTurnOffUpsOnBatterySensor->Get(code, aValue);
        break;

    case IS_LOAD_SENSING_ON:
        {
            strcpy(aValue,"No");
        }
        break;

    case IS_EEPROM_PROGRAMMABLE:
        {
            strcpy(aValue, "Yes");
        }
        break;

    case TRANSFER_CAUSE:
        {
            CHAR buf[32];
            _itoa(theLastTransferCause, buf, 10);
            strcpy(aValue, buf);
            err = ErrNO_ERROR;
        }
        break;

    case NUMBER_OF_INPUT_PHASES:
    case NUMBER_OF_OUTPUT_PHASES:
        {
            CHAR buf[32];
            _itoa(1, buf, 10);
            strcpy(aValue, buf);
            err = ErrNO_ERROR;
        }
        break;

    default:
    case IS_THIRD_GEN:
    case IS_SECOND_GEN:
    case IS_FIRST_GEN:
    case IS_BACKUPS:
    case MAX_VOLTAGE_RANGE_VALUE:
    case MIN_VOLTAGE_RANGE_VALUE:
    case IS_SELF_TEST:
    case IS_LIGHTS_TEST:
    case IS_SIMULATE_POWER_FAIL:
    case IS_BATTERY_CALIBRATION:
    case IS_BYPASS:
    case FIRMWARE_REV:
    case IS_EXT_SLEEP_UPS:
        err = theFirmwareRevSensor->Get(code, aValue);
        break;
    }

    return err;
}


//-------------------------------------------------------------------------
VOID SmartUps:: GetAllowedValue(INT code, CHAR *aValue)
{
    FindAllowedValues(code, aValue,  (PFirmwareRevSensor) theFirmwareRevSensor );
}

//-------------------------------------------------------------------------

INT SmartUps::Set(INT code, const PCHAR aValue)
{
    INT err = ErrNO_ERROR;

    switch(code) {
    case UPS_ID:
        err = ErrUNSUPPORTED;
        break;

    case BATTERY_REPLACEMENT_DATE:
    case BATTERY_AGE_LIMIT:
        err = theBatteryReplacementManager->Set(code, aValue);
        break;


    case HIGH_TRANSFER_VOLTAGE:
    case LOW_TRANSFER_VOLTAGE:
    case RATED_OUTPUT_VOLTAGE:
        err = ErrUNSUPPORTED;
        break;

    case LOW_LOAD_THRESHOLD:
        err = ErrUNSUPPORTED;
        break;

    case HIGH_LOAD_THRESHOLD:
        err = ErrUNSUPPORTED;
        break;

    case UPS_SENSITIVITY:
        err = ErrUNSUPPORTED;
        break;

    case LOW_BATTERY_DURATION:
        err = theLowBatteryDurationSensor->Set(code, aValue);

        // see if new low battery warning time is greater than the
        // current run time - if so, generate a low battery event
        char run_time_rem[32];
        if ((err = Get(RUN_TIME_REMAINING, run_time_rem)) == ErrNO_ERROR)
        {
            int run_time, low_battery;
            run_time = atoi(run_time_rem);
            low_battery = atoi(aValue) * 60;

            if (run_time <= low_battery)
            {
                PEvent tmp = new Event(BATTERY_CONDITION, BATTERY_BAD);
                Update(tmp);
            }
        }
        break;

    case ALARM_DELAY:
        err = ErrUNSUPPORTED;
        break;

    case MIN_RETURN_CAPACITY:
        err = ErrUNSUPPORTED;
        break;

    case SHUTDOWN_DELAY:
        err = theShutdownDelaySensor->Set(code, aValue);
        break;

    case TURN_ON_DELAY:
        err = ErrUNSUPPORTED;
        break;

    case SELF_TEST:
        if (isOnBattery()) {
            err = ErrBATTERYTEST_NOT_AVAIL;
            break;
        }
        // else drop through
    case SELF_TEST_DAY:
    case SELF_TEST_TIME:
    case SELF_TEST_SETTING:
    case RESCHEDULE_SELF_TEST:
    case SELFTEST_LIST:
        err = ErrUNSUPPORTED;
        break;

    case TURN_OFF_UPS_ON_BATTERY:
        err = theTurnOffUpsOnBatterySensor->Set(code, aValue);
        break;

    case TURN_OFF_UPS_AFTER_DELAY:
        err = theTurnOffWithDelaySensor->Set(code, aValue);
        break;

    case PUT_UPS_TO_SLEEP:
        err = thePutUpsToSleepSensor->Set(code, aValue);
        break;

    case LIGHTS_TEST:
        if (isOnBattery()) {
            err = ErrLIGHTSTEST_NOT_AVAIL;
        }
        else {
            err = theLightsTestSensor->Set(code, aValue);
        }
        break;

    case BATTERY_CALIBRATION_TEST:
    case BATTERY_CALIBRATION_DAY:
    case BATTERY_CALIBRATION_TIME:
    case BATTERY_CALIBRATION_ENABLED:
    case BATTERY_CALIBRATION_LAST_DATE:
    case BATTERY_CALIBRATION_LIST:
        err = ErrUNSUPPORTED;
        break;

    case SIMULATE_POWER_FAIL:
        err = ErrSIMULATEPOWERFAILURE_NOT_AVAIL;
        break;
    case AUTO_REBOOT_ENABLED:
        err = theTurnOffUpsOnBatterySensor->Set(code, aValue);
        break;

    case EXTERNAL_BATTERY_PACKS:
        err = theNumberBatteryPacksSensor->Set(code,aValue);
        break;

    default:
        err = BackUps::Set(code, aValue);
        break;
  }
  return err;
}


//-------------------------------------------------------------------------

INT SmartUps::Update(PEvent anEvent)
{
    switch(anEvent->GetCode())
    {
    case UTILITY_LINE_CONDITION:
        HandleLineConditionEvent(anEvent);
        break;

    case BATTERY_CONDITION:
        HandleBatteryConditionEvent(anEvent);
        break;

    case LIGHTS_TEST:
        HandleLightsTestEvent(anEvent);
        break;

    case BATTERY_CALIBRATION_CONDITION:
        HandleBatteryCalibrationEvent(anEvent);
        break;

    case SELF_TEST_STATE:
    case SELF_TEST_RESULT:
        HandleSelfTestEvent(anEvent);
        break;

    case SMART_BOOST_STATE:
        HandleSmartBoostEvent(anEvent);
        break;

    case SMART_TRIM_STATE:
        HandleSmartTrimEvent(anEvent);
        break;

    case OVERLOAD_CONDITION:
        HandleOverloadConditionEvent(anEvent);
        break;

    case DIP_SWITCH_POSITION:
        setEepromAccess((atoi(anEvent->GetValue()) == 0) ? AREAD_WRITE : AREAD_ONLY);
        break;

    case SIMULATE_POWER_FAIL:
        switch(atoi(anEvent->GetValue()))  {
        case SIMULATE_POWER_FAIL:
            SET_BIT(theUpsState, SIMULATE_POWER_FAIL_BIT);
            break;

        case SIMULATE_POWER_FAIL_OVER:
            CLEAR_BIT(theUpsState, SIMULATE_POWER_FAIL_BIT);
            break;
        }
        UpdateObj::Update(anEvent);
        break;

        case BATTERY_REPLACEMENT_CONDITION:
            switch(atoi(anEvent->GetValue())) {
            case BATTERY_NEEDS_REPLACING :
                SET_BIT(theUpsState, BATTERY_REPLACEMENT_BIT);
                break;
            case BATTERY_DOESNT_NEED_REPLACING :
                CLEAR_BIT(theUpsState, BATTERY_REPLACEMENT_BIT);
                break;
            }
            UpdateObj::Update(anEvent);
            break;

            case COMMUNICATION_STATE:
                switch(atoi(anEvent->GetValue()))  {
                case COMMUNICATION_ESTABLISHED:
                    reinitialize();
                    break;
                }
                break;

                default:
                    BackUps::Update(anEvent);
                    break;
    }

    return ErrNO_ERROR;
}



VOID SmartUps::reinitialize()
{
    theFirmwareRevSensor->DeepGet();
    theNumberBatteryPacksSensor->DeepGet();
    theCopyrightSensor->DeepGet();
    theTripRegisterSensor->DeepGet();
    theBatteryReplacementManager->Reinitialize();
    theBatteryCapacitySensor->DeepGet();

    theRunTimeRemainingSensor->DeepGet();
    theLowBatteryDurationSensor->DeepGet();
    theShutdownDelaySensor->DeepGet();
    theManufactureDateSensor->DeepGet();
    theUpsSerialNumberSensor->DeepGet();
    theUpsModelSensor->DeepGet();

    CHAR programmable[32];
    Get(IS_EEPROM_PROGRAMMABLE, programmable);

    setEepromAccess((_strcmpi(programmable, "YES") == 0) ? AREAD_WRITE : AREAD_ONLY);

}


//-------------------------------------------------------------------------
// Determine status of line and generate an event with this status
//-------------------------------------------------------------------------

VOID SmartUps::HandleLineConditionEvent(PEvent anEvent)
{
    switch(atoi(anEvent->GetValue())) {

    case LINE_GOOD:
        {
            CHAR boost[32] = { NULL };
            CHAR trim[32] = { NULL };

            // Get status of boost and trim from the UPS and
            // determine the previous state of trim and boost

            INT err_boost = theSmartBoostSensor->DeepGetWithoutUpdate(boost);
            INT err_trim  = theSmartTrimSensor->DeepGetWithoutUpdate(trim);
            INT we_were_on_trim = (IS_STATE(UPS_STATE_ON_TRIM));
            INT we_were_on_boost = (IS_STATE(UPS_STATE_ON_BOOST));
            //
            // Cancel a pending line fail event
            //
            if (isLineFailPending()) {
                _theTimerManager->CancelTimer(pendingEventTimerId);
                pendingEventTimerId = 0;
            }

            if ((err_boost != ErrUNSUPPORTED) &&
                (atoi(boost) == SMART_BOOST_ON)) {
                setLineGood();
                SET_BIT(theUpsState, SMART_BOOST_BIT);
                CLEAR_BIT(theUpsState, SMART_TRIM_BIT);
                Event boost_event(SMART_BOOST_STATE, SMART_BOOST_ON);
                UpdateObj::Update(&boost_event);
                theLastTransferCause = BROWNOUT;
                BackUps::HandleLineConditionEvent(anEvent);
            }
            else if ((err_trim != ErrUNSUPPORTED)
                && (atoi(trim) == SMART_TRIM_ON)) {
                setLineGood();
                SET_BIT(theUpsState, SMART_TRIM_BIT);
                CLEAR_BIT(theUpsState, SMART_BOOST_BIT);
                Event trim_event(SMART_TRIM_STATE, SMART_TRIM_ON);
                UpdateObj::Update(&trim_event);
                theLastTransferCause = HIGH_LINE_VOLTAGE;
                BackUps::HandleLineConditionEvent(anEvent);
            }
            else if (err_boost != ErrUNSUPPORTED && we_were_on_boost) {
                CLEAR_BIT(theUpsState, SMART_BOOST_BIT);
                BackUps::HandleLineConditionEvent(anEvent);
            }
            else if (err_trim != ErrUNSUPPORTED && we_were_on_trim) {
                CLEAR_BIT(theUpsState, SMART_TRIM_BIT);
                BackUps::HandleLineConditionEvent(anEvent);
            }
            else if (err_boost != ErrUNSUPPORTED) {

                if (pendingEvent) {
                    UpdateObj::Update(pendingEvent);
                }
                BackUps::HandleLineConditionEvent(anEvent);
            }
            else {
                BackUps::HandleLineConditionEvent(anEvent);
            }

            // A LINE_GOOD will void all pending events (see comment in LINE_BAD)

            delete pendingEvent;
            pendingEvent = NULL;
        }
        break;

    case LINE_BAD:
        if(!isLineFailPending()) {
            // Start a LINE_BAD timer.
            // if the timer expires and the UPS status does not change from
            // on battery, then the pending event will handled

            pendingEvent = new Event(*anEvent);
            pendingEventTimerId = _theTimerManager->SetTheTimer((ULONG)5, anEvent, this);
            setLineFailPending();
        }
        else {
            delete pendingEvent;
            pendingEvent = (PEvent)NULL;
            BackUps::HandleLineConditionEvent(anEvent);
        }
        break;

    case ABNORMAL_CONDITION:
        BackUps::HandleLineConditionEvent(anEvent);
        break;

    default:
        break;
    }
}

//-------------------------------------------------------------------------

VOID SmartUps::HandleBatteryConditionEvent(PEvent anEvent)
{
    CHAR value[32];

    INT err = theBatteryCapacitySensor->DeepGet(value);
    if (err != ErrUNSUPPORTED) {
        anEvent->AppendAttribute(BATTERY_CAPACITY, value);
    }

    BackUps::HandleBatteryConditionEvent(anEvent);
}

//-------------------------------------------------------------------------

VOID SmartUps::HandleLightsTestEvent(PEvent anEvent)
{
    switch(atoi(anEvent->GetValue())) {
      case LIGHTS_TEST_IN_PROGRESS:
	SET_BIT(theUpsState, LIGHTS_TEST_BIT);
	break;
	
      case NO_LIGHTS_TEST_IN_PROGRESS:
	CLEAR_BIT(theUpsState, LIGHTS_TEST_BIT);
	break;
	
      default:
	break;
    }
    UpdateObj::Update(anEvent);
}

//-------------------------------------------------------------------------

//-------------------------------------------------------------------------

VOID SmartUps::HandleSelfTestEvent(PEvent anEvent)
{
    switch(atoi(anEvent->GetValue())) {
      case SELF_TEST_IN_PROGRESS:
	SET_BIT(theUpsState, SELF_TEST_BIT);
	break;
	
      case NO_SELF_TEST_IN_PROGRESS:
	CLEAR_BIT(theUpsState, SELF_TEST_BIT);
	break;
	
      default:
	break;
    }
    UpdateObj::Update(anEvent);
}

//-------------------------------------------------------------------------

VOID SmartUps::HandleBatteryCalibrationEvent(PEvent anEvent)
{
    switch(atoi(anEvent->GetValue())) {
      case BATTERY_CALIBRATION_IN_PROGRESS:
	SET_BIT(theUpsState, BATTERY_CALIBRATION_BIT);
	break;
	
      case NO_BATTERY_CALIBRATION_IN_PROGRESS:
      case BATTERY_CALIBRATION_CANCELLED:
	//   printf("Battery Calibration Cancelled/ended\n");
	CLEAR_BIT(theUpsState, BATTERY_CALIBRATION_BIT);
	break;
	
      default:
	break;
    }
    UpdateObj::Update(anEvent);
}

//-------------------------------------------------------------------------

VOID SmartUps::HandleSmartBoostEvent(PEvent anEvent)
{
   switch(atoi(anEvent->GetValue()))
      {
      case SMART_BOOST_ON:
	 // If we're not already on boost, Send the event

	 if (!(IS_STATE(UPS_STATE_ON_BOOST | UPS_STATE_IN_LIGHTS_TEST)))
	    {
	    SET_BIT(theUpsState, SMART_BOOST_BIT);
        UpdateObj::Update(anEvent);
	    }
	 break;

      case SMART_BOOST_OFF:
        if (IS_STATE(UPS_STATE_ON_BOOST)) {
          CLEAR_BIT(theUpsState, SMART_BOOST_BIT);
          UpdateObj::Update(anEvent);
        }
	 break;
      // THIS WILL BE HANDLED BY THE HandleLineCondition
      default:
	 break;
      }
}

//-------------------------------------------------------------------------

VOID SmartUps::HandleSmartTrimEvent(PEvent anEvent)
{
   switch(atoi(anEvent->GetValue()))
      {
      case SMART_TRIM_ON:
         // If we're not already on trim, Send the event

         if (!(IS_STATE(UPS_STATE_ON_TRIM | UPS_STATE_IN_LIGHTS_TEST)))
            {
            SET_BIT(theUpsState, SMART_TRIM_BIT);
            UpdateObj::Update(anEvent);
            }
         break;

      case SMART_TRIM_OFF:
        if (IS_STATE(UPS_STATE_ON_TRIM)) {
          CLEAR_BIT(theUpsState, SMART_TRIM_BIT);
          UpdateObj::Update(anEvent);
        }
      default:
         break;
      }
}

//-------------------------------------------------------------------------

VOID SmartUps::HandleOverloadConditionEvent(PEvent anEvent)
{
    switch(atoi(anEvent->GetValue()))  {
      case UPS_OVERLOAD:
		if (!IS_STATE(UPS_STATE_IN_LIGHTS_TEST))
			SET_BIT(theUpsState, OVERLOAD_BIT);
		break;

      case NO_UPS_OVERLOAD:
		CLEAR_BIT(theUpsState, OVERLOAD_BIT);
		break;

      default:
	break;
    }
    UpdateObj::Update(anEvent);
}

//-------------------------------------------------------------------------

INT SmartUps::MakeBatteryCapacitySensor(const PFirmwareRevSensor rev)
{

    INT make_sensor = FALSE;
    CHAR Battery_Capacity_Capable[32];
    rev->Get(IS_BATTERY_CAPACITY,Battery_Capacity_Capable);
    if (_strcmpi(Battery_Capacity_Capable,"Yes") == 0)
    {
	    make_sensor = TRUE;
	}
    if (make_sensor)  {
	theBatteryCapacitySensor =
	    new BatteryCapacitySensor(this, theCommController);
    }
    else {
	theBatteryCapacitySensor = &_theUnsupportedSensor;
    }
    return ErrNO_ERROR;
}

//-------------------------------------------------------------------------

INT SmartUps::MakeSmartBoostSensor(const PFirmwareRevSensor rev)
{
    CHAR Smart_Boost_Capable[32];
    rev->Get(IS_SMARTBOOST,Smart_Boost_Capable);

    if (_strcmpi(Smart_Boost_Capable, "Yes") == 0)
	{
      theSmartBoostSensor = new SmartBoostSensor(this, theCommController);
		}
	    else
		{
      theSmartBoostSensor = &_theUnsupportedSensor;
		}


    return ErrNO_ERROR;
	}

//-------------------------------------------------------------------------

INT SmartUps::MakeSmartTrimSensor(const PFirmwareRevSensor rev)
	{
    CHAR Smart_Trim_Capable[32];
    rev->Get(IS_SMARTTRIM,Smart_Trim_Capable);

    if (_strcmpi(Smart_Trim_Capable, "Yes") == 0)
		{
      theSmartTrimSensor = new SmartTrimSensor (this, theCommController);
			}
		    else
			{
      theSmartTrimSensor = &_theUnsupportedSensor;
			}

    return ErrNO_ERROR;
}

//-------------------------------------------------------------------------

INT SmartUps::MakeCopyrightSensor(const PFirmwareRevSensor rev)
{

        CHAR Copyright_Capable[32];
        rev->Get(IS_COPYRIGHT,Copyright_Capable);
        if (_strcmpi(Copyright_Capable, "No") == 0)
	{
	    theCopyrightSensor = &_theUnsupportedSensor;
	}
    else
	{
	    theCopyrightSensor = new CopyrightSensor(this, theCommController);
	}
    return ErrNO_ERROR;
}


//-------------------------------------------------------------------------

INT SmartUps::MakeRunTimeRemainingSensor(const PFirmwareRevSensor rev)
{
      CHAR Run_Time_Capable[32];
    rev->Get(IS_RUNTIME_REMAINING,Run_Time_Capable);

      if (_strcmpi(Run_Time_Capable, "No") == 0)
	{
	    theRunTimeRemainingSensor = &_theUnsupportedSensor;
	}
    else
	{
	    theRunTimeRemainingSensor = new RunTimeRemainingSensor(this, theCommController);
	}
    return ErrNO_ERROR;
}

//-------------------------------------------------------------------------


INT SmartUps::MakeLowBatteryDurationSensor(const PFirmwareRevSensor rev)
{
    CHAR Low_Battery_Duration_Capable[32];
    rev->Get(IS_LOW_BATTERY_DURATION,Low_Battery_Duration_Capable);
    if (_strcmpi(Low_Battery_Duration_Capable, "No") == 0)
	{
	    theLowBatteryDurationSensor = &_theUnsupportedSensor;
	}
    else
	{
	    theLowBatteryDurationSensor = new LowBatteryDurationSensor(this, theCommController);
	}

    return ErrNO_ERROR;
}

//-------------------------------------------------------------------------

INT SmartUps::MakeShutdownDelaySensor(const PFirmwareRevSensor rev)
{
    CHAR Shutdown_Delay_Capable[32];
    rev->Get(IS_SHUTDOWN_DELAY,Shutdown_Delay_Capable);
    if (_strcmpi(Shutdown_Delay_Capable, "No") == 0)
	{
	    theShutdownDelaySensor = &_theUnsupportedSensor;
	}
    else
	{
	    theShutdownDelaySensor = new ShutdownDelaySensor(this, theCommController);
	}

    return ErrNO_ERROR;
}


//-------------------------------------------------------------------------

INT SmartUps::MakeManufactureDateSensor(const PFirmwareRevSensor rev)
{
    CHAR Manufacture_Date_Capable[32];
    rev->Get(IS_MANUFACTURE_DATE,Manufacture_Date_Capable);
    if (_strcmpi(Manufacture_Date_Capable, "No") == 0)
	{
	    theManufactureDateSensor = &_theUnsupportedSensor;
	}
    else
	{
	    theManufactureDateSensor = new ManufactureDateSensor(this, theCommController);
	}
    return ErrNO_ERROR;
}

//-------------------------------------------------------------------------

INT SmartUps::MakeUpsSerialNumberSensor(const PFirmwareRevSensor rev)
{
    CHAR Serial_Number_Capable[32];
    rev->Get(IS_SERIAL_NUMBER,Serial_Number_Capable);
    if (_strcmpi(Serial_Number_Capable, "No") == 0)
	{
	    theUpsSerialNumberSensor = &_theUnsupportedSensor;
	}
    else
	{
	    theUpsSerialNumberSensor = new UpsSerialNumberSensor(this, theCommController);
	}
    return ErrNO_ERROR;
}

//-------------------------------------------------------------------------

INT SmartUps::MakeTurnOffWithDelaySensor(const PFirmwareRevSensor rev)
{
    CHAR Turn_Off_Delay_Capable[32];
    rev->Get(IS_TURN_OFF_WITH_DELAY,Turn_Off_Delay_Capable);
    if (_strcmpi(Turn_Off_Delay_Capable, "No") == 0)
    {
	theTurnOffWithDelaySensor = &_theUnsupportedSensor;
    }
    else {
	theTurnOffWithDelaySensor =
	    new TurnOffWithDelaySensor(this, theCommController);
    }

    return ErrNO_ERROR;
}


//-------------------------------------------------------------------------

INT SmartUps::MakePutUpsToSleepSensor()
{
    // SU400/370 and SU250 don't support sleep mode if auto-on
    // is enabled.
    //
    CHAR val[32];

    Get(IS_LOAD_SENSING_ON, val);

    if (_strcmpi(val, "YES") == 0) {
	thePutUpsToSleepSensor = &_theUnsupportedSensor;
    }
    else {
	thePutUpsToSleepSensor =
	    new PutUpsToSleepSensor(this, theCommController);
    }

    return ErrNO_ERROR;
}

VOID
SmartUps::setEepromAccess(INT anAccessCode)
{
    ((PEepromChoiceSensor)theCopyrightSensor)->SetEepromAccess(anAccessCode);
    ((PEepromChoiceSensor)theManufactureDateSensor)->SetEepromAccess(anAccessCode);
    ((PEepromChoiceSensor)theLowBatteryDurationSensor)->SetEepromAccess(anAccessCode);
    ((PEepromChoiceSensor)theShutdownDelaySensor)->SetEepromAccess(anAccessCode);
    ((PEepromChoiceSensor)theUpsSerialNumberSensor)->SetEepromAccess(anAccessCode);

    theBatteryReplacementManager->SetEepromAccess(anAccessCode);
}


//-------------------------------------------------------------------------
//  This function is only used when the following function
//  SmartUps:: AllowedValuesAreGettable returns TRUE.  This
//  function constructs the EepromAllowedValuesSensor and then
//  parses all the information returned from the sensors DeepGet.
//
//-------------------------------------------------------------------------
INT SmartUps:: GetAllAllowedValues(PList ValueList)
{
//  Check to see if CTRL Z is an option
    INT cCode = ErrNO_ERROR;

    if (AllowedValuesAreGettable(theFirmwareRevSensor))
    {
//  if CTRL Z load CTRL Z values into non Default values.

	CHAR  value[512];
        INT cCode =theCommController->Get(UPS_ALLOWED_VALUES, value);
	
	if (cCode == ErrNO_ERROR)
		cCode = ParseValues(value, ValueList);
    }
return cCode;

}

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
INT SmartUps:: ParseValues(CHAR* string, PList ValueList)
{
   INT  Done = FALSE;
   CHAR sensorCode[56];
   CHAR upsType[10];
   CHAR allValues[128];



   while (!Done)
   {
       CHAR value[128];

       string = string+1;  // skip the first "#" sign
       INT valsize = strcspn(string,"#");

       strncpy(value,string,valsize);
       value[valsize] = 0;
       if (sscanf(value, "%[^,],%1c,%[^#]",sensorCode, upsType, allValues) != EOF) {
         AllowedValueItem* item = new AllowedValueItem(atoi(sensorCode),
						      upsType[0],
						      allValues);
         ValueList->Append(item);
       }
       string = string + valsize;
       if (string[1] == 0)
	   Done = TRUE;

   }
   return ErrNO_ERROR;
}


//-------------------------------------------------------------------------
// This function checks the firmware revision to determine if the CTRL Z
// command is valid to use on this UPS.
//
//-------------------------------------------------------------------------
INT SmartUps:: AllowedValuesAreGettable(PSensor theFirmwareRevSensor)
{
    CHAR CTRL_Z_Capable[32];
    theFirmwareRevSensor->Get(IS_CTRL_Z,CTRL_Z_Capable);
    if (_strcmpi(CTRL_Z_Capable, "No") == 0)
       return FALSE;
    else
      return TRUE;
   }

VOID SmartUps:: FindAllowedValues(INT code, CHAR *aValue, PFirmwareRevSensor aFirmwareSensor )
{
    INT Found = FALSE;
    aValue[0] = 0;

    if (AllowedValuesList)
    {
       AllowedValueItem* item = (AllowedValueItem*)AllowedValuesList->GetHead();
       ListIterator iter((RList)*AllowedValuesList);

       while(!Found && item)
       {
	  if (item->GetUpsCode() == code)
	  {
            CHAR Country_Code[32];
            aFirmwareSensor->Get(COUNTRY_CODE,Country_Code);

             INT cc = atoi(Country_Code);
	     if ( (item->GetUpsType() == '4') ||
		  ( (INT)item->GetUpsType() == cc) )
	     {
		 strcpy(aValue, item->GetValue());
		 Found = TRUE;
	     }
	  }
	  item = (AllowedValueItem*)iter.Next();
       }

    }
}


AllowedValueItem :: AllowedValueItem(INT Code,CHAR Type, CHAR* Value) :
		    theUpsType(0),
		    theValue((CHAR*)NULL)
{
   theCode = Code;
   theUpsType = Type;
   theValue = _strdup(Value);
}


AllowedValueItem :: ~AllowedValueItem()
{
   if (theValue)
      free(theValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\sortable.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy11Dec92: Use __APCSORTABLE_ so not to cause conflicts 
 *  pcy14Dec92: Changed Sortable to ApcSortable 
 *
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */

#ifndef __APCSORTABLE_H
#define __APCSORTABLE_H

#include "_defs.h"
#include "apc.h"
#include "apcobj.h"

_CLASSDEF(Obj)
_CLASSDEF(ApcSortable)

class ApcSortable : public Obj
{
protected:
   ApcSortable() {};

public:

   virtual INT          GreaterThan(PApcSortable) = 0;
   virtual INT          LessThan(PApcSortable) = 0;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\smrtsens.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  rct11Dec92 Added includes for 'action' sensors
 *  pcy15Jan92 Added selftest.h and smroutvs.h
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */
#ifndef _INC__SMRTSENS_H
#define _INC__SMRTSENS_H

#include "batcalt.h"
#include "batpacks.h"
#include "battcaps.h"
#include "battrep.h"
#include "coprites.h"
#include "eeprom.h"
#include "firmrevs.h"
#include "litesnsr.h"
#include "lobatdur.h"
#include "shutdel.h"
#include "manudate.h"
#include "replbatt.h"
#include "runtrems.h"
#include "smboosen.h"
#include "trimsen.h"
#include "tripregs.h"
#include "upssers.h"
#include "towdels.h"
#include "ups2slep.h"
#include "upsmodl.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\smboosen.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker25NOV92  Initial OS/2 Revision 
 *  pcy07Dec92: Changed defines used for smart boost state values. 
 *  pcy14Dec92: Changed READ_WRITE to AREAD_WRITE
 *  pcy16Feb93: Made to work like a state sensor
 *  cgm12Apr96: Destructor with unregister
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "smboosen.h"
#include "comctrl.h"

//Constructor

SmartBoostSensor :: SmartBoostSensor(PDevice 		aParent, 
		         PCommController 	aCommController)
:	StateSensor(aParent,aCommController, SMART_BOOST_STATE,AREAD_WRITE)
{
      storeState(SMART_BOOST_OFF);
      theCommController->RegisterEvent(SMART_BOOST_STATE, this);
}
      
SmartBoostSensor :: ~SmartBoostSensor()
{
      theCommController->UnregisterEvent(SMART_BOOST_STATE, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\stream.cxx ===
/*
 *  The main use of this class is to get or set the state of the port,
 *  which is either open or closed.
 *
 * REFERENCES:
 *
 * NOTES:
 *
 * REVISIONS:
 *  ash11Dec95: Redesigned the class
 *  pcy10May96: Initialize theAddress to NULL 
 */

#include "cdefine.h"

#ifdef SMARTHEAP 
#define DEFINE_NEW_MACRO 1 
#define MEM_DEBUG 1
#include <smrtheap.hpp>          
#endif

#include <stdlib.h>
#include <string.h>

#include "stream.h"
#include "err.h"


/* -------------------------------------------------------------------------
   Stream class constructor
 
-------------------------------------------------------------------------  */

Stream::Stream() : UpdateObj()
{ 
    theState = CLOSED;
}

 
/* -------------------------------------------------------------------------
   Stream destructor
 
-------------------------------------------------------------------------  */

Stream::~Stream()
{
}

/* -------------------------------------------------------------------------
   Stream::GetState()
 
-------------------------------------------------------------------------  */

enum StreamState Stream::GetState()
{
    return theState; 
}    
 
 

/* -------------------------------------------------------------------------
   Stream::SetState()
   Set the state of the stream.  It can be OPEN or CLOSED.
 
-------------------------------------------------------------------------  */

VOID Stream::SetState(const StreamState aNewState)
{
    theState = aNewState; 
}    
 
/* -------------------------------------------------------------------------
   Stream::SetWaitTime()

    These next 2 functions are here because of serport.  Smart and Simple
    ports inherit from Stream, and thePort used in Upsdev is a PStream 
    variable, and Serport has these methods.  SetRequestCode is over -
    ridden.  And as far as I could tell, SetWaitTIme is not used, so I 
    am assuming that since Upsdev is common code, another platform uses 
    it, so I am not going to remove the call to SetWaitTime from Upsdev.
 
-------------------------------------------------------------------------  */


VOID Stream::SetWaitTime(ULONG ) 
{
};

/* -------------------------------------------------------------------------
   Stream::SetRequestCode()

   See above text.
 
-------------------------------------------------------------------------  */

VOID Stream::SetRequestCode(INT ) 
{
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\stream.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ash12Dec95: Redesigned the class
 */

#ifndef __STREAM_H
#define __STREAM_H

#include "apc.h"
#include "update.h"


_CLASSDEF(Stream)
_CLASSDEF(AddressType)
_CLASSDEF(NetAddr)


const ULONG READ_TIMEOUT = ULONG_MAX;
enum StreamState { OPEN, CLOSED };
      

class Stream : public UpdateObj
{   
private:
    StreamState theState;

public:
    Stream();
    virtual ~Stream();

    enum StreamState GetState(); 
    VOID             SetState(const StreamState aNewState);

    virtual INT Initialize() = 0;
    virtual INT Open() = 0;
    virtual INT Write(PCHAR aBuffer) = 0;
    virtual INT Close() = 0;
	virtual INT Read(PCHAR aBuffer, USHORT* aBufferSize, ULONG aTimeout = 4000) = 0;

    virtual VOID SetWaitTime(ULONG );
    virtual VOID SetRequestCode(INT );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\stsensor.cxx ===
/*
 *
 * REVISIONS:
 *  ker23NOV92  Initial OS/2 Revision 
 *  pcy17Dec92  Added Validate()
 *  cad10Jun93:  fixed GetState()
 *
 */

#include "cdefine.h"

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "apc.h"
#include "stsensor.h"
#include "utils.h"

//Constructor

StateSensor :: StateSensor(PDevice 		aParent, 
		         PCommController 	aCommController, 
          		 INT 			aSensorCode, 
	         	 ACCESSTYPE 		anACCESSTYPE)
:Sensor(aParent,aCommController, aSensorCode, anACCESSTYPE)
{
    storeState(STATE_UNKNOWN);
}

INT StateSensor::GetState(INT aCode, INT *aState)
{
   *aState = atoi(theValue);
   return ErrNO_ERROR;
}

INT StateSensor::SetState(INT aCode, INT aState)
{
   CHAR the_temp_string[32];

   _itoa(aState, the_temp_string, 10);
   if(Validate(aCode, the_temp_string) == ErrNO_ERROR)
      {
      INT the_return=Set(aCode, the_temp_string);
      return the_return;
      }
   else
      {
      return ErrINVALID_VALUE;
      }
}

INT StateSensor::Validate(INT aCode, const PCHAR aValue)
{
   INT err = ErrNO_ERROR;
   if(theValue)  {
      if(strcmp(aValue, theValue) == 0)  {
    	  err = ErrNO_STATE_CHANGE;
      }
   }
   return err;	
}


INT StateSensor::storeState(const INT aState)
{
    CHAR the_temp_state[32];

    _itoa(aState, the_temp_state, 10);
    INT err = Sensor::storeValue(the_temp_state);
    return ErrNO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\stsensor.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker23NOV92   Initial OS/2 Revision
 *  pcy14Dec92: Changed READ_ONLY to AREAD_ONLY
 *  pcy17Dec92: Added Validate
 *  cad28Sep93: Made sure destructor(s) virtual
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */
 
#ifndef __STSENSOR_H
#define __STSENSOR_H

#include "sensor.h"
#include "isa.h"

_CLASSDEF(StateSensor)

			  
class StateSensor : public Sensor {


protected:
    virtual INT storeState(const INT aState);

public:
	StateSensor(PDevice aParent, 
                PCommController aCommController, 
                INT aSensorCode = NO_SENSOR_CODE, 
                ACCESSTYPE anACCESSTYPE = AREAD_ONLY);

//overidden interfaces

	virtual INT Validate(INT, const PCHAR);

//Additional Interfaces

    virtual INT GetState(INT, INT *);
    virtual INT SetState(INT, INT);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\sysstate.h ===
/*
 *  pcy08Jan93: Initial implementation taken from ups.h
 *  cad26Aug93: Bypass mode convenience
 *  srt02Feb96: Added UPS_STATE_NO_COMMUNICATION
 *  djs29Jul96: Added DarkStar states
 *  tjg03Dec97: Added bit for IM_NOT_INSTALLED
 */

#ifndef __SYSSTATE_H
#define __SYSSTATE_H

// The System State is implemented as a bit field as follows.
// Bit 0 - Utility Line Status   0=line good              1=line bad
// Bit 1 - Battery Status        0=battery good           1=battery bad
// Bit 2 - SmartBoost            0=smart boost off        1=smart boost on
// Bit 3 - BatteryCalibration    0=not in progress        1=in progress
// Bit 4 - BatteryReplacement    0=doesnt need replaceing 1=needs replacing
// Bit 5 - Self Test             0=not in progress        1=in progress
// Bit 6 - Line Fail Pending     0=no                     1=no
// Bit 7 - Lights Test           0=not in progress        1=in progress
// Bit 8 - Overload              0=no overload            1=overload
// Bit 9 - Abnormal condition    0=no abnormal condition  1=abnormal condition
// Bit 10 - Shutdown in Progress 0=no abnormal condition  1=abnormal condition
// Bit 11 - Bypass, Maint.       0=not on bypass          1=on bypass
// Bit 12 - Bypass, Module Fail. 0=not on bypass          1=on bypass
// Bit 13 - Bypass, Supply Fail. 0=power supply ok        1=ps failed
// Bit 14 - Simulate power Fail  0=no simulation          1=simulated
// Bit 15 - Communications       0=comm ok                1=no comm
// Bit 16 - SmartTrim            0=smart trim off         1=smart trim on
// Bit 17 - Bypass Cont Fail.    0=not on bypass          1=on bypass
// Bit 18 - Redundancy           0=redundnacy ok          1=no redundancy 
// Bit 19 - IM                   0=IM ok                  1=IM failed
// Bit 20 - RIM                  0=RIM ok                 1=RIM failed
// Bit 21 - IM Installation      0=Installed              1=Not Installed
// System State values
//

#define LINE_STATUS_BIT          0
#define BATTERY_STATUS_BIT       1
#define SMART_BOOST_BIT          2
#define BATTERY_CALIBRATION_BIT  3
#define BATTERY_REPLACEMENT_BIT  4
#define SELF_TEST_BIT            5
#define LINE_FAIL_PENDING_BIT    6
#define LIGHTS_TEST_BIT          7
#define OVERLOAD_BIT             8
#define ABNORMAL_CONDITION_BIT   9
#define SHUTDOWN_IN_PROGRESS_BIT 10
#define BYPASS_MAINT_BIT         11
#define BYPASS_MODULE_FAILED_BIT 12
#define BYPASS_SUPPLY_FAILED_BIT 13
#define SIMULATE_POWER_FAIL_BIT  14
#define COMMUNICATIONS_BIT       15
#define SMART_TRIM_BIT           16
#define BYPASS_CONT_FAILED_BIT   17
#define REDUNDANCY_LOST_BIT      18
#define IM_FAILED_BIT            19
#define RIM_FAILED_BIT           20
#define IM_NOT_INSTALLED_BIT     21


#define UPS_STATE_ON_BATTERY           ( 1 << LINE_STATUS_BIT )
#define UPS_STATE_BATTERY_BAD          ( 1 << BATTERY_STATUS_BIT )
#define UPS_STATE_ON_BOOST             ( 1 << SMART_BOOST_BIT )
#define UPS_STATE_IN_CALIBRATION       ( 1 << BATTERY_CALIBRATION_BIT )
#define UPS_STATE_BATTERY_NEEDED       ( 1 << BATTERY_REPLACEMENT_BIT )
#define UPS_STATE_IN_SELF_TEST         ( 1 << SELF_TEST_BIT )
#define UPS_STATE_LINE_FAIL_PENDING    ( 1 << LINE_FAIL_PENDING_BIT )
#define UPS_STATE_IN_LIGHTS_TEST       ( 1 << LIGHTS_TEST_BIT )
#define UPS_STATE_OVERLOAD             ( 1 << OVERLOAD_BIT )
#define UPS_STATE_ABNORMAL_CONDITION   ( 1 << ABNORMAL_CONDITION_BIT )
#define SHUTDOWN_IN_PROGRESS           ( 1 << SHUTDOWN_IN_PROGRESS_BIT )
#define UPS_STATE_BYPASS_MAINT         ( 1 << BYPASS_MAINT_BIT )
#define UPS_STATE_BYPASS_MODULE_FAILED ( 1 << BYPASS_MODULE_FAILED_BIT )
#define UPS_STATE_BYPASS_SUPPLY_FAILED ( 1 << BYPASS_SUPPLY_FAILED_BIT )
#define UPS_STATE_SIMULATED_POWER_FAIL ( 1 << SIMULATE_POWER_FAIL_BIT )
#define UPS_STATE_NO_COMMUNICATION     ( 1 << COMMUNICATIONS_BIT )	

//  All bit masks greater than bit 15 cannot reliable use bit shifting
//  across all platforms.
 
#define UPS_STATE_ON_TRIM                65536
#define UPS_STATE_BYPASS_CONT_FAILED    131072
#define UPS_STATE_LOST_REDUNDANCY       262144 
#define UPS_STATE_IM_FAILED             524288
#define UPS_STATE_RIM_FAILED           1048576
#define UPS_STATE_IM_NOT_INSTALLED     2097152
 

#define UPS_STATE_ANY_BYPASS_MODE       (UPS_STATE_BYPASS_MAINT|\
					 UPS_STATE_BYPASS_MODULE_FAILED|\
					 UPS_STATE_BYPASS_SUPPLY_FAILED)

#define UPS_STATE_LOW_BATTERY   (UPS_STATE_ON_BATTERY & \
                                 UPS_STATE_BATTERY_BAD)

#define SET_BIT(byte, bitnum)    (byte |= ( 1L << bitnum ))
#define CLEAR_BIT(byte, bitnum)  (byte &= ~( 1L << bitnum ))
#define IS_STATE(state)          (theUpsState & (state) ? 1 : 0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\tattrib.h ===
/*
*
* NOTES:
*
* REVISIONS:
*  rct30Nov92 entered into system
*  pcy04Dec92: Added apc.h and renamed object.h to apc.h
*  ane11Dec92: Added copy constructor and made inheritance from Obj public
*  pcy17Dec92: Changes to get cfgmgr to work
*  rct20Feb93: Added ItemEqual method
*
*/

#ifndef __TATTRIB_H
#define __TATTRIB_H

#include "apc.h"
#include "apcobj.h"



_CLASSDEF(TAttribute);

class TAttribute : public Obj {
   
private:
   
   PCHAR    theItem;
   PCHAR    theValue;
   
public:
   
   TAttribute( PCHAR anItem, PCHAR aValue = NULL );
   TAttribute( RTAttribute anAttr );
   virtual ~TAttribute();
   
   const PCHAR    GetItem() const { return theItem; };
   const PCHAR    GetValue() const { return theValue; };
   VOID           SetValue( PCHAR );
   
   INT          ItemEqual( RObj ) const; 
   virtual INT          Equal( RObj ) const;
   virtual INT        IsA() const { return TATTRIBUTE; };
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\stdcfg.cxx ===
/*
*  pcy28Apr93: For now use isa number strings for Allowed values. Fix later.
*  jod05Apr93: Added changes for Deep Discharge
*  rct29Jun93: Added msg for batt RT disabled, fixed pipe names
*  cad03Sep93: Re-ordered some allowed values
*  pcy07Sep93: Made default signalling type = Smart
*  cad08Sep93: Fixed low battery voltage
*  cad16Sep93: Cleaned up self test stuff
*  cad12Oct93: Added colors used in front end
*  cad24Nov93: special color for NT windows
*  ajr03Dec93: Added default network socket address
*  cad24Jan94: changed xvt defines to c_os
*  pcy28Jan94: Added more flex user stuff
*  ajr01Feb94: Added ftok_id defaults for shared mem id's.
*  cad02Feb94: Redid flex event user stuff
*  cad08Jan94: added ups models, removed run time enabled stuff
*  cad28Feb94: added unix-default port name
*  rct28Feb94: added EMail items
*  pcy04Mar94: Default for overload should be yes
*  cad04Mar94: fixes for allowed port names
*  cad16Mar94: added pager services, modem stuff
*  pcy04Apr94: Implement admin notification
*  ram16May94: Added 14400 option for baud rate option & bogus prefill chars.
*              in Tests dialog box
*  ajr10Jun94: Added LowBatteryShutdownType
*  dml26Apr95: Added SMS Mif file creation defs
*  ajr31May95: Add network support back for SCO
*  djs17May96: Added DarkStar codes
*  ntf11Jun96: Added CFG_LEFT_BARGRAPH ... CFG_RIGHT_BARGRAPH
*  ntf24Jun96: Changed LEFT to FIRST, MIDDLE to SECOND, ...
*  ntf28Jun96: Changed "Input Voltage" to "Utility Voltage"
*  pam03Jul96: Added Communication component
*  das01Aug96: Added CFG_IGNORE_APPS_LIST, changed ApplicationShutdownEnabled
*              to AppShutdownEnabled, added CFG_CABLE_TYPE, added windows
*              changes (KLT)
*  das01Aug96: Added CFG_SHUTDOWN_SOON_MSG
*  jps25Sep96: AppShutdownEnabled -> ApplicationShutdownEnabled (SIR 4339)
*  tjg14Oct96: Added COM5-COM8 to CFG_ALLOWED_PORT_NAMES
*  tjg21Oct96: Added CFG_HELP_BROWSER and CFG_HELP_PATH
*  srt05Nov96: Changed CFG_UPS_SERVER_RESP_TIMEOUT from 30 to 60 secs
*  djs05Nov96: Changed default paging modem to COM3
*  djs05Nov96: Removed default message for MUPS contact closures
*  tjg30Jun97: Added SMTP codes
*  dma30Jun97: Updated help link to intro.htm to consolidate identical help files.
*  mwh29Aug97: add finder interval config support
*  awm25Sep97: Changed STATUSPANECOLOR from white to light grey for main screen revamp
Changed INRANGECOLOR from green to light grey
Changed OUTRANGECOLOR from red to grey
Changed TICKCOLOR to black
*  mds29Dec97: Added CFG_SHARE_UPS_CONFIRMED_MODE_ENABLED
*  dma23Jan98: Changed default value of CFG_AMB_TEMP_VALUE_HIGH_THRESHOLD to 65, since
*              this is the maximum that PowerChute will now allow a user to enter.
*  tjg30Jan98: Updated defaults for SMTP mail stuff from No to blank
*  daharoni05Feb99: Added CFG_COMMAND_FILE_SHOW_WINDOW
*/

#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"
#include "cfgmgr.h"
#include "icodes.h"

//-------------------------------------------------------------------

// Standard Config codes
struct _ConfigItemList_T ConfigItemList[] = {
    
    {CFG_UPS_SIGNALLING_TYPE, "Ups", "SignallingType", "Smart"},
#if (C_OS & C_UNIX)
    {CFG_ALLOWED_PORT_NAMES, "Ups", "AllowedPortNames", "/dev/tty0,/dev/tty1"},
    {CFG_UPS_PORT_NAME, "Ups", "PortName", "/dev/tty0"},
#else
    {CFG_ALLOWED_PORT_NAMES, "Ups", "AllowedPortNames", "COM1,COM2,COM3,COM4,COM5,COM6,COM7,COM8"},
    {CFG_UPS_PORT_NAME, "Ups", "PortName", "COM1"},
#endif
    {CFG_UPS_PORT_TYPE, "Ups", "PortType", "Serial"},
    {CFG_UPS_PROTOCOL, "Ups", "Protocol", "UpsLink"},
    {CFG_UPS_MAX_BATTERY_RUN_TIME, "Ups", "MaxBatteryRunTime", "300"},
#ifdef MULTI_SERVER_SUPPORT    
    {CFG_UPS_SLAVE_ENABLED, "Ups", "SlaveEnabled", "No"},
    {CFG_UPS_MASTER_NAME, "Ups", "MasterName", ""},
#endif
    {CFG_UPS_POLL_INTERVAL, "Ups", "UpsPollInterval", "4"},
    {CFG_UPS_SERVER_RESP_TIMEOUT, "Ups", "UpsServerResponseTimeout", "60"},
    
#if (C_OS & (C_NLM | C_DOS))
    {CFG_DEVICE_BOARD, "Ups", "BoardNumber", "0"},
    {CFG_DEVICE_PORT, "Ups", "PortNumber", "0"},
    {CFG_DEVICE_HARDWARE_TYPE, "Ups", "HardwareType", "COM Port"},
#endif
    
#if (C_OS & C_NLM)
    {CFG_NLM_SAP_ENABLED, "Nlm", "SapEnabled", "Yes"},
    {CFG_NLM_RUN_PRIORITY, "Nlm", "RunTimePriority", "10"},
    {CFG_NLM_EXIT_AFTER_DOWN, "Nlm", "ExitAfterDown", "No"},
    {CFG_NLM_OVERRIDE_SIGNAL, "Nlm","OverrideSignal","No"},     
#endif
#if (C_OS & (C_NLM | C_DOS | C_WINDOWS))
    {CFG_NLM_SPX_TIMEOUT, "Nlm", "SpxTimeout", "30"},
#endif
    
    {CFG_EVENT_LOG_ENABLED, "EventLogging", "EventLogEnabled",  "YES"},
#if (C_OS & C_UNIX)
    {CFG_EVENT_LOG_NAME, "EventLogging", "EventLogName", "powerchute.log"},
    {CFG_BKFTOK_ID,"Ups","VersionId","7"},
#else
    {CFG_EVENT_LOG_NAME, "EventLogging", "EventLogName", "pwrchute.log"},
#endif
    
    {CFG_EVENT_LOG_MAX_SIZE, "EventLogging", "EventLogMaxSize", "50000"},
    {CFG_EVENT_LOG_ROLL_PCT, "EventLogging", "EventLogRollPercentage", "30"},
    
    {CFG_DATA_LOG_ENABLED, "DataLogging", "DataLogEnabled", "YES"},
#if (C_OS & C_UNIX)
    {CFG_MUPS_ENABLED,"Devices","MeasureUps","NO"},
    {CFG_DATA_LOG_NAME, "DataLogging", "DataLogName", "powerchute.dat"},
#else
    {CFG_DATA_LOG_NAME, "DataLogging", "DataLogName", "pwrchute.dat"},
#endif
    
    {CFG_DATA_LOG_MAX_SIZE, "DataLogging", "DataLogMaxSize", "50000"},
    {CFG_DATA_LOG_INTERVAL, "DataLogging", "DataLogInterval", "600"},
    {CFG_DATA_LOG_ROLL_PCT, "DataLogging", "DataLogRollPercentage", "30"},
    
    {CFG_MESSAGE_DELAY, "Messaging", "MessageDelay", "5"},
    {CFG_MESSAGE_INTERVAL, "Messaging", "MessageInterval", "30"},
    {CFG_POWER_FAIL_MSG, "Messaging", "PowerFailMsg", "Power failed"},
    {CFG_UNLIMITED_POWER_FAIL_MSG, "Messaging", "UnlimitedPowerFailMsg", "Power failed at server #HOSTNAME#, shutdown is imminent."},
    {CFG_POWER_RETURN_MSG, "Messaging", "PowerReturnMessage", "Power returned"},
    {CFG_LOW_BATTERY_MSG, "Messaging", "LowBatteryMessage", "Low battery"},
    {CFG_RUN_TIME_EXPIRED_MSG, "Messaging", "RuntimeExpiredMessage", "Run time expired"},
    {CFG_FINAL_SHUTDOWN_MSG, "Messaging", "FinalShutdownMessage", "System Shutting Down !"},
    {CFG_CANCEL_SHUTDOWN_MSG, "Messaging", "CancelShutdownMessage", "Cancel System Shutdown"},
    {CFG_PREPARE_SHUTDOWN_MSG, "Messaging", "PrepareShutdownMessage", "Prepare For System Shutting Down"},
    {CFG_SHUTDOWN_MSG, "Messaging", "ShutdownWarningMessage", "#HOSTNAME# will shutdown #TIME_REMAINING#"},
    {CFG_SHUTDOWN_SOON_MSG, "Messaging", "ShutdownSoonMessage", "#HOSTNAME# will shutdown soon."},  
    {CFG_POPUPS_ENABLED, "Messaging", "EnablePopups", "Yes"},
    {CFG_BRDCAST_ENABLED, "Messaging", "EnableBroadcastMessaging", "NO"},
#if (C_OS & (C_UNIX|C_NLM))
    {CFG_ALLOWED_NOTIFY_TYPES, "Messaging", "AllowedNotifyTypes", "All,Some"},
    {CFG_NOTIFY_TYPE, "Messaging", "NotifyType", "All"},
#elif (C_OS & C_WIN95)
    {CFG_ALLOWED_NOTIFY_TYPES, "Messaging", "AllowedNotifyTypes", "Domain,Some"},
    {CFG_NOTIFY_TYPE, "Messaging", "NotifyType", "Domain"},
#else
    {CFG_ALLOWED_NOTIFY_TYPES, "Messaging", "AllowedNotifyTypes", "All,Domain,Some"},
    {CFG_NOTIFY_TYPE, "Messaging", "NotifyType", "Domain"},
#endif
    {CFG_NOTIFY_USER_LIST, "Messaging", "NotifyUsers", ""}, 
    {CFG_ADMIN_NOTIFY_USER_LIST, "Messaging", "AdminNotifyUsers", ""}, 
    
    {CFG_FLEX_USERS, "EventUsers", "Users", ""},
    
    {CFG_ENABLE_SELF_TESTS, "SelfTests", "EnableSelfTests", "YES"},
    {CFG_SELF_TEST_SCHEDULE, "SelfTests", "SelfTestSchedule", "At turn on"},
    {CFG_SELF_TEST_DAY, "SelfTests", "SelfTestDay", "MONDAY"},
    {CFG_SELF_TEST_TIME, "SelfTests", "SelfTestTime", "8:00 PM"},
    {CFG_LAST_SELF_TEST_RESULT, "SelfTests", "LastSelfTestResult", "Unknown"},
    {CFG_LAST_SELF_TEST_DAY, "SelfTests", "LastSelfTestDay", "Unknown"},
    
    {CFG_LAST_BATTERY_CALIBRATION_DATE, "BatteryCalibration", "LastCalibrationDate", "Unknown"},
    {CFG_LAST_BATTERY_CALIBRATION_RESULT, "BatteryCalibration", "LastCalibrationResult", "No Calibration Test"},
    {CFG_BATTERY_CALIBRATION_DAY, "BatteryCalibration", "BatteryCalibrationDay", "MONDAY"},
    {CFG_BATTERY_CALIBRATION_TIME, "BatteryCalibration", "BatteryCalibrationTime", "7:00 AM"},
    {CFG_BATTERY_CALIBRATION_ENABLED, "BatteryCalibration", "Enabled", "YES"},
    
    
    {CFG_LOW_BATTERY_SHUTDOWN_DELAY, "Shutdown", "LowBatteryShutdownDelay", "30"},
    {CFG_SHUTDOWN_DELAY, "Shutdown", "ShutdownDelay", "300"},
    {CFG_ADMIN_SHUTDOWN_DELAY, "Shutdown", "AdminShutdownDelay", "900"},
    {CFG_DAILY_SHUTDOWN_ENABLED, "Shutdown", "DailyShutdownEnabled", "NO"},
    {CFG_DAILY_SHUTDOWN_TIME, "Shutdown", "DailyShutdownTime", "5:00 PM"},
    {CFG_DAILY_WAKE_UP_TIME, "Shutdown", "DailyWakeupTime", "7:00 AM"},
    {CFG_WEEKLY_SHUTDOWN_ENABLED, "Shutdown", "WeeklyShutdownEnabled", "NO"},
    {CFG_WEEKLY_SHUTDOWN_DAY, "Shutdown", "WeeklyShutdownDay", "Friday"},
    {CFG_WEEKLY_SHUTDOWN_TIME, "Shutdown", "WeeklyShutdownTime", "5:00 PM"},
    {CFG_WEEKLY_WAKEUP_DAY, "Shutdown", "WeeklyWakeupDay", "Monday"},
    {CFG_WEEKLY_WAKEUP_TIME, "Shutdown", "WeeklyWakeupTime", "7:00 AM"},
    
#if (!(C_OS & C_NLM))
    {CFG_LOCAL_BINDERY_ADDRESS, "LanManager", "LOCALBINDERYADDRESS", "c:\\PWRCHUTE\\BINDERY.DAT"},
    {CFG_NET_SOCKET_ADDRESS_DATA,"NetWork","NETSOCKETADDRESSData","6547"},
    {CFG_NET_SOCKET_ADDRESS_ALERT,"NetWork","NETSOCKETADDRESSALERT","6548"},
    {CFG_NET_SOCKET_ADDRESS_BINDERY,"NetWork","NETSOCKETADDRESSBINDERY","6549"},
    {CFG_HOST_NAME, "Server", "HostName", "System"},
    {CFG_SERVER_PAUSE_ENABLED, "Server", "PAUSEEnabled", "YES"},
    
    {CFG_NET_TCP_SOCKET_ADDRESS_POLL,"NetWork","NETTCPSOCKETADDRESSPOLL","6667"},
    {CFG_NET_TCP_SOCKET_ADDRESS_ALERT,"NetWork","NETTCPSOCKETADDRESSALERT","6668"},
    {CFG_NET_TCP_SOCKET_ADDRESS_BINDERY,"NetWork","NETTCPSOCKETADDRESSBINDERY","6666"},
    {CFG_NET_SPX_SOCKET_ADDRESS_POLL,"NetWork","NETSPXSOCKETADDRESSPOLL","26547"},
    {CFG_NET_SPX_SOCKET_ADDRESS_ALERT,"NetWork","NETSPXSOCKETADDRESSALERT","26548"},
    {CFG_NET_SPX_SOCKET_ADDRESS_BINDERY,"NetWork","NETSPXSOCKETADDRESSBINDERY","26549"},
    
    {CFG_CLIENT_ADDRESS, "LanManager", "CLIENTADDRESS", "\\PIPE\\SERVRCON"},
    {CFG_ALERT_ADDRESS, "LanManager", "ALERTADDRESS", "\\PIPE\\ALERTS"},
    {CFG_SERVER_BINDERY_ADDRESS, "LanManager", "SERVERSBINDERYADDRESS", "\\MAILSLOT\\BINDERY"},
    {CFG_BINDERY_RESPONSE_ADDRESS, "LanManager", "BINDERYRESPONSEADDRESS", "\\MAILSLOT\\BINDRESP"},
#endif
    
    {CFG_HUMIDITY_ENABLED_LOW_THRESHOLD, "HumiditySensor", "EnableLowThreshold", "NO"},
    {CFG_HUMIDITY_ENABLED_HIGH_THRESHOLD, "HumiditySensor", "EnableHighThreshold", "NO"},
    {CFG_HUMIDITY_VALUE_LOW_THRESHOLD, "HumiditySensor", "LowThresholdValue", "20"},
    {CFG_HUMIDITY_VALUE_HIGH_THRESHOLD, "HumiditySensor", "HighThresholdValue", "80"},
    
    {CFG_AMB_TEMP_ENABLED_LOW_THRESHOLD, "AmbientTemperatureSensor", "EnableLowThreshold", "NO"},
    {CFG_AMB_TEMP_ENABLED_HIGH_THRESHOLD, "AmbientTemperatureSensor", "EnableHighThreshold", "NO"},
    {CFG_AMB_TEMP_VALUE_LOW_THRESHOLD, "AmbientTemperatureSensor", "LowThresholdValue", "20"},
    {CFG_AMB_TEMP_VALUE_HIGH_THRESHOLD, "AmbientTemperatureSensor", "HighThresholdValue", "65"},
    
    {CFG_MUPS_CONTACT1_ENABLED, "ContactSensor1", "Enabled", "NO"},
    {CFG_MUPS_CONTACT2_ENABLED, "ContactSensor2", "Enabled", "NO"},
    {CFG_MUPS_CONTACT3_ENABLED, "ContactSensor3", "Enabled", "NO"},
    {CFG_MUPS_CONTACT4_ENABLED, "ContactSensor4", "Enabled", "NO"},
    {CFG_MUPS_CONTACT1_DEFAULT, "ContactSensor1", "DefaultState", "Open"},
    {CFG_MUPS_CONTACT2_DEFAULT, "ContactSensor2", "DefaultState", "Open"},
    {CFG_MUPS_CONTACT3_DEFAULT, "ContactSensor3", "DefaultState", "Open"},
    {CFG_MUPS_CONTACT4_DEFAULT, "ContactSensor4", "DefaultState", "Open"},
    {CFG_MUPS_CONTACT1_DESCRIPTION, "ContactSensor1", "Description", ""},
    {CFG_MUPS_CONTACT2_DESCRIPTION, "ContactSensor2", "Description", ""},
    {CFG_MUPS_CONTACT3_DESCRIPTION, "ContactSensor3", "Description", ""},
    {CFG_MUPS_CONTACT4_DESCRIPTION, "ContactSensor4", "Description", ""},
    
    {CFG_TEMPERATURE_UNITS, "UserInterface", "TemperatureUnits", "F"},
    {CFG_SOUND_EFFECTS, "UserInterface", "SoundEffects", "OFF"},
    
    {CFG_FREQUENCY_ENABLED_LOW_THRESHOLD, "FrequencySensor", "EnableLowThreshold", "NO"},
    {CFG_FREQUENCY_ENABLED_HIGH_THRESHOLD, "FrequencySensor", "EnableHighThreshold", "NO"},
    {CFG_FREQUENCY_VALUE_LOW_THRESHOLD, "FrequencySensor", "LowThresholdValue", "55"},
    {CFG_FREQUENCY_VALUE_HIGH_THRESHOLD, "FrequencySensor", "HighThresholdValue", "65"},
    {CFG_BATTVOLT_ENABLED_LOW_THRESHOLD, "BatteryVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_BATTVOLT_ENABLED_HIGH_THRESHOLD, "BatteryVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_BATTVOLT_VALUE_LOW_THRESHOLD, "BatteryVoltageSensor", "LowThresholdValue", "19"},
    {CFG_BATTVOLT_VALUE_HIGH_THRESHOLD, "BatteryVoltageSensor", "HighThresholdValue", "28"},
    
    {CFG_LINE_VOLTAGE_ENABLED_LOW_THRESHOLD, "LineVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_LINE_VOLTAGE_ENABLED_HIGH_THRESHOLD, "LineVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_LINE_VOLTAGE_VALUE_LOW_THRESHOLD, "LineVoltageSensor", "LowThresholdValue", "100"},
    {CFG_LINE_VOLTAGE_VALUE_HIGH_THRESHOLD, "LineVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_MAX_LINEV_ENABLED_LOW_THRESHOLD, "MaxLineVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_MAX_LINEV_ENABLED_HIGH_THRESHOLD, "MaxLineVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_MAX_LINEV_VALUE_LOW_THRESHOLD, "MaxLineVoltageSensor", "LowThresholdValue", "100"},
    {CFG_MAX_LINEV_VALUE_HIGH_THRESHOLD, "MaxLineVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_MIN_LINEV_ENABLED_LOW_THRESHOLD, "MinLineVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_MIN_LINEV_ENABLED_HIGH_THRESHOLD, "MinLineVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_MIN_LINEV_VALUE_LOW_THRESHOLD, "MinLineVoltageSensor", "LowThresholdValue", "100"},
    {CFG_MIN_LINEV_VALUE_HIGH_THRESHOLD, "MinLineVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_PHASE_A_INPUT_VOLTAGE_ENABLED_LOW_THRESHOLD, "PhaseAInputVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_PHASE_A_INPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD, "PhaseAInputVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_PHASE_A_INPUT_VOLTAGE_VALUE_LOW_THRESHOLD, "PhaseAInputVoltageSensor", "LowThresholdValue", "100"},
    {CFG_PHASE_A_INPUT_VOLTAGE_VALUE_HIGH_THRESHOLD, "PhaseAInputVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_PHASE_B_INPUT_VOLTAGE_ENABLED_LOW_THRESHOLD, "PhaseBInputVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_PHASE_B_INPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,"PhaseBInputVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_PHASE_B_INPUT_VOLTAGE_VALUE_LOW_THRESHOLD,   "PhaseBInputVoltageSensor", "LowThresholdValue", "100"},
    {CFG_PHASE_B_INPUT_VOLTAGE_VALUE_HIGH_THRESHOLD,  "PhaseBInputVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_PHASE_C_INPUT_VOLTAGE_ENABLED_LOW_THRESHOLD, "PhaseCInputVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_PHASE_C_INPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,"PhaseCInputVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_PHASE_C_INPUT_VOLTAGE_VALUE_LOW_THRESHOLD,   "PhaseCInputVoltageSensor", "LowThresholdValue", "100"},
    {CFG_PHASE_C_INPUT_VOLTAGE_VALUE_HIGH_THRESHOLD,  "PhaseCInputVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD, "OutputVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD, "OutputVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD, "OutputVoltageSensor", "LowThresholdValue", "100"},
    {CFG_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD, "OutputVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_PHASE_A_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD, "PhaseAOutputVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_PHASE_A_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,"PhaseAOutputVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_PHASE_A_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD,   "PhaseAOutputVoltageSensor", "LowThresholdValue", "100"},
    {CFG_PHASE_A_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD,  "PhaseAOutputVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_PHASE_B_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD, "PhaseBOutputVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_PHASE_B_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,"PhaseBOutputVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_PHASE_B_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD,   "PhaseBOutputVoltageSensor", "LowThresholdValue", "100"},
    {CFG_PHASE_B_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD,  "PhaseBOutputVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_PHASE_C_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD, "PhaseCOutputVoltageSensor", "EnableLowThreshold", "NO"},
    {CFG_PHASE_C_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,"PhaseCOutputVoltageSensor", "EnableHighThreshold", "NO"},
    {CFG_PHASE_C_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD,   "PhaseCOutputVoltageSensor", "LowThresholdValue", "100"},
    {CFG_PHASE_C_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD,  "PhaseCOutputVoltageSensor", "HighThresholdValue", "130"},
    
    {CFG_UPS_LOAD_ENABLED_LOW_THRESHOLD, "UpsLoadSensor", "EnableLowThreshold", "NO"},
    {CFG_UPS_LOAD_ENABLED_HIGH_THRESHOLD, "UpsLoadSensor", "EnableHighThreshold", "Yes"},
    {CFG_UPS_LOAD_VALUE_LOW_THRESHOLD, "UpsLoadSensor", "LowThresholdValue", "20"},
    {CFG_UPS_LOAD_VALUE_HIGH_THRESHOLD, "UpsLoadSensor", "HighThresholdValue", "100"},
    
    {CFG_UPS_TEMP_ENABLED_LOW_THRESHOLD, "UpsTemperatureSensor", "EnableLowThreshold", "NO"},
    {CFG_UPS_TEMP_ENABLED_HIGH_THRESHOLD, "UpsTemperatureSensor", "EnableHighThreshold", "NO"},
    {CFG_UPS_TEMP_VALUE_LOW_THRESHOLD, "UpsTemperatureSensor", "LowThresholdValue", "20"},
    {CFG_UPS_TEMP_VALUE_HIGH_THRESHOLD, "UpsTemperatureSensor", "HighThresholdValue", "80"},
    
    {CFG_BATTERY_RUN_TIME_VALUE_LOW_THRESHOLD,"BatteryRunTimeSensor","LowThresholdValue","300"},
    {CFG_BATTERY_RUN_TIME_VALUE_HIGH_THRESHOLD,"BatteryRunTimeSensor","HighThresholdValue","6000"},
    
    {CFG_ALLOWED_ALARM_DELAYS, "AlarmDelaySensor", "AllowedValues", "0,T,L,N"},
    {CFG_ALLOWED_HIGH_TRANSFER_VOLTAGES, "HighTransferVoltageSensor", "AllowedValues", "129,132,135,138"},
    {CFG_ALLOWED_LOW_TRANSFER_VOLTAGES, "LowTransferVoltageSensor", "AllowedValues", "097,100,103,106"},
    {CFG_ALLOWED_LOW_BATTERY_DURATIONS, "LowBatteryDurationSensor", "AllowedValues", "02,05,07,10"},
    {CFG_ALLOWED_MIN_RETURN_CAPACITIES, "MinReturnCapacitySensor", "AllowedValues", "00,10,25,90"},
    {CFG_ALLOWED_RATED_OUTPUT_VOLTAGES, "RatedOutputVoltageSensor", "AllowedValues", "115"},
    {CFG_ALLOWED_SELF_TEST_SCHEDULES, "SelfTestScheduleSensor", "AllowedValues", "ON ,OFF"},
    {CFG_ALLOWED_SHUTDOWN_DELAYS, "ShutdownDelaySensor", "AllowedValues", "020,180,300,600"},
    {CFG_ALLOWED_TURN_OFF_DELAYS, "TurnoffDelaySensor", "AllowedValues", "00,02,05,10"},
    {CFG_ALLOWED_TURN_ON_DELAYS, "TurnonDelaySensor", "AllowedValues", "000,060,180,300"},
    {CFG_ALLOWED_SENSITIVITIES, "UpsSensitivitySensor", "AllowedValues", "H,M,L"},
    {CFG_ALLOWED_RUN_TIMES_AFTER_LOW_BATTERY, "RunTimeAfterLowBatterySensor", "AllowedValues", "02,05,08,NO"},
    
    
    
    
    
    
    {CFG_COMMAND_FILE_DELAY, "CommandFiles", "CommandFileDelay", "0"},
    
    {CFG_AUTO_UPS_REBOOT_ENABLED, "Ups", "AutoUpsRebootEnabled", "YES"},
    {CFG_BATTERY_AGE_LIMIT, "Ups", "BatteryAgeLimit", "1"},
    {CFG_BATTERY_REPLACEMENT_DATE, "Ups", "BatteryReplacementDate", "N/A"},
    
    {CFG_ERROR_LOG_ENABLED, "ErrorLogging", "ErrorLogEnabled",  "YES"},
#if (C_OS & C_UNIX)
    {CFG_ERROR_LOG_NAME, "ErrorLogging", "ErrorLogName", "powerchute.err"},
#else
    {CFG_ERROR_LOG_NAME, "ErrorLogging", "ErrorLogName", "pwrchute.err"},
#endif
    
    {CFG_ERROR_LOG_MAX_SIZE, "ErrorLogging", "ErrorLogMaxSize", "50000"},
    {CFG_ERROR_LOG_ROLL_PCT, "ErrorLogging", "ErrorLogRollPercentage", "30"},
    
    {CFG_PAGER_ENABLED, "Pager", "Enabled", "Yes"},
    {CFG_PAGER_DELAY, "Pager", "Delay", "10"},
    {CFG_PAGER_RETRIES, "Pager", "Retries", "1"},
    {CFG_PAGER_SERVICE_LIST, "Pager", "Services", ""},
#if (C_OS & C_UNIX)
    {CFG_MODEM_PORT_NAME, "Modem", "PortName", "/dev/tty1"},
#else
    {CFG_MODEM_PORT_NAME, "Modem", "PortName", "COM3"},
#endif
    {CFG_MODEM_ENABLED, "Modem", "Enabled", "No"},
    {CFG_MODEM_INIT_STRING, "Modem", "InitializationString", ""},
    {CFG_MODEM_DIAL_TYPE, "Modem", "DialType", "Tone"},
    {CFG_MODEM_DRIVER_TYPE, "Modem", "HardwareType", "1"},
    {CFG_MODEM_PORT_NUMBER, "Modem", "PortNumber", "0"},
    {CFG_MODEM_BOARD_NUMBER, "Modem", "BoardNumber", "1"},
    {CFG_MODEM_BAUD_RATE, "Modem", "BaudRate", "2400"},
    {CFG_MODEM_ALLOWED_BAUD_RATES, "Modem", "AllowedBaudRates",
    "300,1200,2400,9600,14400,19200"},
    
    {CFG_EMAIL_ENABLED, "EMail", "Enabled", "No"},
    {CFG_EMAIL_DELAY, "EMail", "MessageDelay", "10"},
    {CFG_EMAIL_FILE_PATH, "Email", "FilePath", "SYS:MHS\\MAIL\\SND"},
#if (C_OS & C_WIN95)
    {CFG_EMAIL_LOGIN_NAME, "Email", "LoginName", "pwrchute"},
#else
    {CFG_EMAIL_LOGIN_NAME, "Email", "LoginName", ""},
#endif
    {CFG_EMAIL_USER_LIST, "Email", "Users", ""},
    {CFG_EMAIL_HEADER, "Email", "Header", "Message from PowerChute@#HOSTNAME#:"},
    {CFG_EMAIL_PASSWORD, "Email", "Password", ""},
    {CFG_EMAIL_TYPE, "Email", "SMFType", "SMF-71"},
    {CFG_EMAIL_SMTP_SERVER, "Email", "SmtpServerName", " "},
    {CFG_EMAIL_SMTP_ACCOUNT, "Email", "SmtpAccount", " "},
    {CFG_EMAIL_SMTP_DOMAIN, "Email", "SmtpDomain", " "},
    {CFG_SHARE_UPS_CONFIRMED_MODE_ENABLED, "ShareUps", "ConfirmedModeEnabled","No"},
    
#if (!(C_OS & C_NLM))
    {CFG_TEMPERATURE_UNITS, "UserInterface", "TemperatureUnits", "Fahrenheit"},
    {CFG_INDICATOR_COLOR, "UserInterface", "INDICATORCOLOR", "Black"},
#if (C_OS & C_DOS)
    {CFG_BORDER_COLOR, "UserInterface", "BORDERCOLOR", "White"},
    {CFG_TICK_COLOR, "UserInterface", "TICKCOLOR", "Black"},
#else
    {CFG_BORDER_COLOR, "UserInterface", "BORDERCOLOR", "Black"},
    {CFG_TICK_COLOR, "UserInterface", "TICKCOLOR", "Black"},
#endif
    {CFG_IN_RANGE_COLOR, "UserInterface", "INRANGECOLOR", "LightGray"},
    {CFG_OUT_OF_RANGE_COLOR, "UserInterface", "OUTOFRANGECOLOR", "Gray"},
#if (C_OS & C_DOS)
    {CFG_DATA_COLOR, "UserInterface", "DataCOLOR", "Cyan"},
    {CFG_LABEL_COLOR, "UserInterface", "LABELCOLOR", "White"},
#else
    {CFG_DATA_COLOR, "UserInterface", "DataCOLOR", "Blue"},
    {CFG_LABEL_COLOR, "UserInterface", "LABELCOLOR", "Black"},
#endif
    {CFG_DISABLED_COLOR, "UserInterface", "DISABLEDCOLOR", "LightGray"},
    
#if (C_OS & ( C_WIN311 | C_WINDOWS | C_NT ) )
    {CFG_WINDOW_COLOR, "UserInterface", "WINDOWCOLOR", "LightGray"},
#elif (C_OS & C_DOS)
    {CFG_WINDOW_COLOR, "UserInterface", "WINDOWCOLOR", "Blue"},
#else
    {CFG_WINDOW_COLOR, "UserInterface", "WINDOWCOLOR", "204,204,204"},
#endif
    
#if (C_OS & C_DOS)
    {CFG_LIGHT_SHADOW_COLOR, "UserInterface","LIGHTSHADOWCOLOR","White"},
    {CFG_DARK_SHADOW_COLOR, "UserInterface", "DARKSHADOWCOLOR", "LightGray"},
    {CFG_STATUS_PANE_COLOR, "UserInterface", "STATUSPANECOLOR", "Blue"},
    {CFG_EVENT_PANE_COLOR, "UserInterface", "EventPANECOLOR", "Blue"},
    {CFG_ERROR_COLOR, "UserInterface", "ErrorCOLOR", "Red"},
    {CFG_WARNING_COLOR, "UserInterface", "WARNINGCOLOR", "Magenta"},
#else
    {CFG_LIGHT_SHADOW_COLOR, "UserInterface","LIGHTSHADOWCOLOR","224,224,224"},
    {CFG_DARK_SHADOW_COLOR, "UserInterface", "DARKSHADOWCOLOR", "DarkGray"},
    {CFG_STATUS_PANE_COLOR, "UserInterface", "STATUSPANECOLOR", "LightGray"},  
    {CFG_EVENT_PANE_COLOR, "UserInterface", "EventPANECOLOR", "LightGray"},
    {CFG_ERROR_COLOR, "UserInterface", "ErrorCOLOR", "Red"},
    {CFG_WARNING_COLOR, "UserInterface", "WARNINGCOLOR", "Yellow"},
#endif
#endif
    
    {CFG_UPS_MODEL_BASE+(INT)('2'), "UPSModel", "2", "Smart-UPS 250"},
    {CFG_UPS_MODEL_BASE+(INT)('3'), "UPSModel", "3", "Smart-UPS 400"},
    {CFG_UPS_MODEL_BASE+(INT)('4'), "UPSModel", "4", "Smart-UPS 400"},
    {CFG_UPS_MODEL_BASE+(INT)('6'), "UPSModel", "6", "Smart-UPS 600"},
    {CFG_UPS_MODEL_BASE+(INT)('7'), "UPSModel", "7", "Smart-UPS 900"},
    {CFG_UPS_MODEL_BASE+(INT)('8'), "UPSModel", "8", "Smart-UPS 1250"},
    {CFG_UPS_MODEL_BASE+(INT)('9'), "UPSModel", "9", "Smart-UPS 2000"},
    {CFG_UPS_MODEL_BASE+(INT)('0'), "UPSModel", "0", "Matrix 3000"},
    {CFG_UPS_MODEL_BASE+(INT)('5'), "UPSModel", "5", "Matrix 5000"},
    {CFG_UPS_MODEL_BASE+(INT)('A'), "UPSModel", "A", "Smart-UPS 1400"},
    {CFG_UPS_MODEL_BASE+(INT)('B'), "UPSModel", "B", "Smart-UPS 1000"},
    {CFG_UPS_MODEL_BASE+(INT)('C'), "UPSModel", "C", "Smart-UPS 650"},
    {CFG_UPS_MODEL_BASE+(INT)('D'), "UPSModel", "D", "Smart-UPS 420"},
    {CFG_UPS_MODEL_BASE+(INT)('E'), "UPSModel", "E", "Smart-UPS 280"},
    {CFG_UPS_MODEL_BASE+(INT)('F'), "UPSModel", "F", "Smart-UPS 450"},
    {CFG_UPS_MODEL_BASE+(INT)('G'), "UPSModel", "G", "Smart-UPS 700"},
    {CFG_UPS_MODEL_BASE+(INT)('H'), "UPSModel", "H", "Smart-UPS 700XL"},
    {CFG_UPS_MODEL_BASE+(INT)('I'), "UPSModel", "I", "Smart-UPS 1000"},
    {CFG_UPS_MODEL_BASE+(INT)('J'), "UPSModel", "J", "Smart-UPS 1000XL"},
    {CFG_UPS_MODEL_BASE+(INT)('K'), "UPSModel", "K", "Smart-UPS 1400"},
    {CFG_UPS_MODEL_BASE+(INT)('L'), "UPSModel", "L", "Smart-UPS 1400XL"},
    {CFG_UPS_MODEL_BASE+(INT)('M'), "UPSModel", "M", "Smart-UPS 2200"},
    {CFG_UPS_MODEL_BASE+(INT)('N'), "UPSModel", "N", "Smart-UPS 2200XL"},
    {CFG_UPS_MODEL_BASE+(INT)('O'), "UPSModel", "O", "Smart-UPS 3000"},
    {CFG_UPS_MODEL_BASE+(INT)('P'), "UPSModel", "P", "Smart-UPS 5000"},
    
    // BACKUPS_FIRMWARE_REV has been define as 'Q' in backups.cxx
    {CFG_UPS_MODEL_BASE+(INT)('Q'), "UPSModel", "Q", "Back-UPS"},
    {CFG_TRANSPORTS, "Transports", "0" , "NamedPipes"},
    {CFG_DEVICES, "Devices", "0", "Ups"},
    {CFG_USERS, "Users", "0", "Ups"},
    {CFG_BATTERY_RUN_TIME_ENABLED,"Ups","BatteryRuntimeEnabled","YES"},
    {CFG_UPSOFF_FILE,"Shutdown","UpsOffFile","/upsoff.cmd"},
    {CFG_UPSOFF_PATH,"Shutdown","UpsOffPath","0"},
    {CFG_LOWBAT_SHUTDOWN_TYPE,"Shutdown","LowBatteryShutdownType", "Normal"},
    {CFG_SERVER_SECURITY,"Server","Security","Yes"},
#if C_OS & C_WIN311
    //(SRT){CFG_MACRO_FILE_NAME,"MacroRecorder","MacroFileName","c:\\pwrchute\\macros.ini"},
    // KLT      Added 9/9/94 for LITE                                      
    {CFG_NOTIFY_DELAY, "LineFail", "NotifyDelay", "5"},
    {CFG_NOTIFY_INTERVAL, "LineFail", "NotifyInterval", "30"},
    {CFG_NOTIFY_SHUTDOWN_DELAY, "LineFail", "ShutdownDelay", "300"},
    {CFG_NOTIFY_ACTIONS, "LineFail", "Actions", "LUS"},
#endif
    {CFG_CABLE_TYPE, "Ups", "CableType", "Normal"},
#if (C_OS & C_OS2)
    {CFG_SERVER_NETVIEW,"Ups","NetViewAlerts","No"},
#endif
#if (C_OS & C_INTERACTIVE)
    {CFG_USE_TCP, "Network","UseTCP","No"},
#else
    {CFG_USE_TCP, "Network","UseTCP","Yes"},
#endif
    
    {CFG_GENERATE_MIF_FILE,"Server","GenerateMif","Yes"},
    {CFG_MIF_DIRECTORY,"Server","MifDirectory",""},
    
    {CFG_FIRST_BARGRAPH,  "UserInterface", "FirstBarGraphType",  "Utility Voltage"},
    {CFG_SECOND_BARGRAPH, "UserInterface", "SecondBarGraphType", "Output Voltage"},
    {CFG_THIRD_BARGRAPH,  "UserInterface", "ThirdBarGraphType",  "Battery Capacity"},
    
#if (C_OS & C_NT)
    {CFG_COMM_RPC, "Communication", "Rpc",  "Yes"},
    {CFG_COMM_TCPIP, "Communication", "TcpIp", "Yes"},
    {CFG_COMM_IPXSPX, "Communication", "IpxSpx",  "Yes"},
    {CFG_COMM_NP, "Communication", "NamePipe",  "Yes"},
    
    {CFG_COMM_RPC_FINDER_INTERVAL, "Communication", "RpcFinderInterval", "4000"},
    {CFG_COMM_TCP_FINDER_INTERVAL, "Communication", "TcpFinderInterval", "4000"},
    {CFG_COMM_IPX_FINDER_INTERVAL, "Communication", "IpxFinderInterval", "4000"},
    {CFG_COMM_NP_FINDER_INTERVAL, "Communication", "NpFinderInterval", "4000"},
    
    {CFG_PREPARE_FOR_SHUTDOWN_DELAY, "PrepareForShutdown", "ShutdownDelay", "60"},   
    {CFG_APP_SHUTDOWN_TIMER, "AppShutDownTimer","AppShutDownTimerValue","6"}, 
    {CFG_DATASAFE_ENABLED, "PrepareForShutdown", "ApplicationShutdownEnabled", "YES"},
    {CFG_IGNORE_APPS_LIST,"PrepareForShutdown","AppsToIgnore",""},
    
    // The default path for help browser and files is %PWRCHUTE%\help
    {CFG_HELP_VIEWER, "Help", "BrowserPath", "help\\iexplore.exe"},
    {CFG_HELP_FILENAME, "Help", "File", "help\\intro.htm"},

	// New code implemented in PC+ v5.0.1.3, by default will show DOS window when
	// executing a command file.

	{CFG_COMMAND_FILE_SHOW_WINDOW, "CommandFile", "ShowWindow", "Yes"},

#endif
    
    { LAST_ENTRY, "0", "0", ""}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\tattrib.cxx ===
/*
*
* NOTES:
*
* REVISIONS:
*  rct30Nov92  Added to system
*  pcy04Dec92: Tried to fix Bob's excellent code
*  ane11Dec92: Added copy constructor implementation
*  rct19Jan93: Modified constructor so it work with Pete's messed up notion
*              of a NULL TAttribute in the ConfigMgr...
*  mwh01Jun94: port for INTERACTIVE
*  mwh07Jun94: port for NCR
*  daf17May95: port for ALPHA/OSF
*  djs02Sep95: port for AIX 4.1

*/

#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#include <string.h>
#if  (C_OS & (C_INTERACTIVE | C_OS2 | C_ALPHAOSF)) || ((C_OS & C_AIX) && (C_AIX_VERSION & C_AIX4))
#  include <stdlib.h>
#else
#  include <malloc.h>
#endif
}

#include "tattrib.h"

#if (C_OS & C_NCR)
#  include "incfix.h"
#endif


//-------------------------------------------------------------------

// Constructor

TAttribute::TAttribute( PCHAR anItem, PCHAR aValue)
{
   if ( anItem != NULL )
      theItem = _strdup(anItem);
   else
      theItem = (PCHAR) NULL;
   
   if ( aValue != NULL )
      theValue = _strdup(aValue);
   else
      theValue = (PCHAR) NULL;
}

//-------------------------------------------------------------------

// Copy Constructor

TAttribute::TAttribute ( RTAttribute anAttr )
{
   if (anAttr.theValue)
      theValue = _strdup (anAttr.theValue);
   else
      theValue = (PCHAR)NULL;
   
   if (anAttr.theItem)
      theItem = _strdup (anAttr.theItem);
   else
      theItem = (PCHAR)NULL;
}

//-------------------------------------------------------------------

// Destructor

TAttribute::~TAttribute()
{
   if ( theItem != NULL )
      free(theItem);
   if ( theValue != NULL )
      free(theValue);
}

//-------------------------------------------------------------------

// Set the value member

VOID TAttribute::SetValue( PCHAR aValue )
{
   if ( theValue != NULL )
      free(theValue);
   theValue = _strdup( aValue );
}

//-------------------------------------------------------------------

// Comparison function

INT TAttribute::Equal( RObj anObject ) const
{
   if (!(anObject.IsA() == IsA()))  
      return FALSE;
   
   return ( !strcmp(theItem, ((RTAttribute) anObject).GetItem()) ) &&
      ( !strcmp(theValue, ((RTAttribute) anObject).GetValue()) );
}

//-------------------------------------------------------------------

INT TAttribute::ItemEqual( RObj anObject ) const
{
   if (anObject.IsA() != IsA())  
      return FALSE;
   return ( !strcmp(theItem, ((RTAttribute) anObject).GetItem()) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\thrdable.h ===
/*
*
* NOTES:
*
* REVISIONS:
*  ane12Jan93: made Threadable an updateable object
*  pcy04Mar93: spilt off from thread.  thrdable is not OS specific.
*  rct17May93: added IsA() method
*  cad19May93: defined IsA() to default (tired of fixing children)
*  cad09Jul93: using new semaphores
*  cad07Oct93: Made methods virtual
*  rct16Nov93: Added single thread implementation
*  cad11Jan94: Changes for new process manager
*  ajr02May95: Need to stop carrying time in milliseconds
*/
#ifndef _THRDABLE_H
#define _THRDABLE_H

#include "_defs.h"

_CLASSDEF(Threadable)

#include "apc.h"
#include "update.h"
#include "semaphor.h"

/* const LONG DEFAULT_SERVICE_PERIOD = 10000L;   // Ten Seconds */
/* const ULONG THREAD_EXIT_TIMEOUT = 1000L; */

const LONG DEFAULT_SERVICE_PERIOD = 10; // Ten Seconds
const ULONG THREAD_EXIT_TIMEOUT = 1;  // one second;

const INT MAX_THREAD_NAME = 32;


class Threadable : public UpdateObj {
   
protected:
   
   PSemaphore  theResumeFlag;
   PSemaphore  theExitSem;
   PSemaphore  theExitDoneSem;
   
   CHAR        theThreadName[MAX_THREAD_NAME+1];
   
#ifdef SINGLETHREADED
   ULONG       theServicePeriod;
   ULONG       theLastPeriod;
   ULONG       theNextPeriod;
#endif
   
   INT ExitNow();
   INT DoneExiting();
   
public:
   
   Threadable ();
   virtual ~Threadable ();
   
   virtual VOID   ThreadMain () = 0;
   
   virtual VOID   SetThreadName(PCHAR aName);
   virtual PCHAR  GetThreadName(VOID);
   
#ifdef SINGLETHREADED
   virtual ULONG  GetServicePeriod() const;
   virtual VOID   SetServicePeriod(ULONG period = DEFAULT_SERVICE_PERIOD);
   
   virtual ULONG  GetLastPeriod(void);
   virtual VOID   SetLastPeriod(ULONG period = 0L);
   
   virtual ULONG  GetNextPeriod(void);
   virtual VOID   SetNextPeriod(ULONG period = 0L);
   
#endif
   
   virtual INT Wait () {return theResumeFlag->Wait();}; 
   virtual INT Release () {return theResumeFlag->Pulse();};
   virtual INT Exit();
   virtual INT ExitWait();
#if (C_OS & C_NLM)
   virtual SLONG TimedWait(SLONG msDelay) { return theResumeFlag->TimedWait(msDelay); };
#else
   virtual INT TimedWait(INT msDelay) { return theResumeFlag->TimedWait(msDelay); };
#endif
   virtual INT Equal(RObj anObj) const { return ((PObj) this == &anObj); };
   virtual INT Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\thread.h ===
/*
 *
 * REVISIONS:
 *  ane12Jan93: made Threadable an updateable object
 *  rct22Apr93: added new Start() method, added return types
 *  cad09Jul93: using new semaphores
 *
 */

#ifndef __THREAD_H
#define __THREAD_H

#if (C_OS & C_NT)
#include <windows.h>
#endif
#include "thrdable.h"


_CLASSDEF(Thread)

class Thread {

private:
   PThreadable theObject;

#if (C_OS & C_NT)
   HANDLE theThreadHandle;
#endif

public:
   Thread(PThreadable object) : theObject (object) {};
   virtual ~Thread();

   INT Start();              // Start thread with parent's context
   INT Start(INT notUsed);   // Start thread with it's own context
   VOID RunMain();
   INT  Wait()       { return theObject->Wait(); };
   INT  Release()    { return theObject->Release(); };
   INT  Exit()       { return theObject->Exit(); };
   INT  ExitWait()   { return theObject->ExitWait(); };
   INT  Reset()      { return theObject->Reset(); };

   PThreadable GetThreadableObject();

#if (C_OS & C_NT)
	VOID TerminateThreadNow();
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\thrdable.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ane09DEC92 - added code for rundown of threads
 *  ane30Dec92 - increase stack size for threads
 *  jod02Feb93 - increase stack size for threads to 10240
 *  ane08Feb93 - added ExitWait
 *  pcy05Mar93 - split off from thread.cxx
 *  rct20Apr93 - changed ExitNow(), added appropriate header files
 *  pcy28Apr93 - Removed debug puts() left in code
 *  cad27May93 - fixed semaphore handling to let thread exit
 *  tje01Jun93 - Added use of NullSemaphore for single-threaded platforms
 *  cad09Jul93: using new semaphores
 *  cad15Jul93: releasing during exitwait to avoid deadlocks
 *  cad07Oct93: Moved timeout constant to .h file
 *  cad27Oct93: Fixed problem with global possibly being gone on exitwait()
 *  rct16Nov93: Added single thread implementation
 *  ajr24Nov93: Added SetLastPeriod.  Took method out of header file.
 *  ajr24Nov93: Initialized theLastPeriod in constructor
 *  cad11Jan94: Changes for new process manager
 *  jps28aug94: added test of theExitSem in ExitNow()
 *  ajr02May95: Need to stop carrying time in milliseconds
 *  srt24Oct96: Fixed time_out value usage
 */
#include "cdefine.h"
extern "C" {
#if(C_OS & C_OS2)
#define INCL_BASE
#define INCL_NOPM
#define UINT UINT_os2
#define ULONG ULONG_os2
#define COLOR COLOR_os2
#include "os2.h"
#undef UINT
#undef ULONG
#undef COLOR
#endif
#ifdef SINGLETHREADED
#include <time.h>
#endif
}
#include "thrdable.h"
#if (C_OS & C_OS2)
 #include "apcsem2x.h"
#elif (C_OS & C_NLM)
 #include "nlmsem.h"
#elif (C_OS & C_NT)
#include "apcsemnt.h"
#include "mutexnt.h"
#endif
#ifdef SINGLETHREADED
#include "nullsem.h"
#include "procmgr.h"
#endif
//#include "timerman.h"

//-------------------------------------------------------------------
Threadable::Threadable ()
{
    SetThreadName("Unknown");

#ifdef MULTITHREADED
   theResumeFlag = new ApcSemaphore();
   theExitSem = new ApcSemaphore();
   theExitDoneSem = new ApcSemaphore();
#else
   theResumeFlag = new NullSemaphore();
   theExitSem = new NullSemaphore();
   theExitDoneSem = new NullSemaphore();
   theServicePeriod = DEFAULT_SERVICE_PERIOD;
   theLastPeriod = 0;
   theNextPeriod = 0;

#endif
}
//-------------------------------------------------------------------
Threadable::~Threadable ()
{
#if (C_OS & C_NT)
    //
    // Dont remove this wait.  NT needs it for some reason??
    Sleep(0);
#endif

    delete theResumeFlag;
    theResumeFlag = (PSemaphore)NULL;
    delete theExitSem;
    theExitSem = (PSemaphore)NULL;
    delete theExitDoneSem;
    theExitDoneSem = (PSemaphore)NULL;
}

//-------------------------------------------------------------------

// This function is used to tell a threadable object to exit - it will
// pause for THREAD_EXIT_TIMEOUT milliseconds for the thread to exit and
// then will continue

INT Threadable::Exit()
{
#ifdef SINGLETHREADED 
   return _theProcessManager->RemoveThread(this);
#else
   theResumeFlag->Pulse();      // just in case
   theExitSem->Post();
   return theExitDoneSem->TimedWait((THREAD_EXIT_TIMEOUT*1000));
#endif
}

VOID Threadable::SetThreadName(PCHAR aName)
{
    strncpy(theThreadName, aName, MAX_THREAD_NAME);
}


PCHAR Threadable::GetThreadName(VOID)
{
    return theThreadName;
}


//-------------------------------------------------------------------

// This function is used to tell a threadable object to exit - it will
// wait indefinitely for the thread to exit

INT Threadable::ExitWait()
{
#ifdef SINGLETHREADED
   return _theProcessManager->RemoveThread(this);
#else
   theExitSem->Post();               // tell them to go away
   theResumeFlag->Post();            // just in case
   return theExitDoneSem->Wait();    // wait for them to do so
#endif
}
//-------------------------------------------------------------------

INT Threadable::Reset()
{
   if (theExitSem->IsPosted())
      {
      theExitSem->Clear();
      }
   if (theResumeFlag->IsPosted())
      {
      theResumeFlag->Clear();
      }
   if (theExitDoneSem->IsPosted())
      {
      theExitDoneSem->Clear();
      }
   return ErrNO_ERROR;
}
//-------------------------------------------------------------------

// This function is called from within a thread to see if Exit or ExitWait
// has been called.

INT Threadable::ExitNow()
{
#ifdef MULTITHREADED
    if (theExitSem)
       return (theExitSem->IsPosted());
    else
      return TRUE;
#else
    return ErrNO_ERROR;
#endif 
}

//-------------------------------------------------------------------

// This function is called from within a thread to mark the fact that the
// thread has been exited.

INT Threadable::DoneExiting()
{
    INT err = ErrNO_ERROR;
   
    if (this != NULL && theExitDoneSem != NULL) {
        theExitDoneSem->Post();
    }
   
    return err;
}

//-------------------------------------------------------------------

#ifdef SINGLETHREADED
ULONG Threadable::GetServicePeriod() const
{
    return theServicePeriod;
}


VOID Threadable::SetServicePeriod(ULONG period)
{
    theServicePeriod = period;

    ULONG next_period = 0L;

    if (theLastPeriod > 0) {
        next_period = theLastPeriod + theServicePeriod;
    }
    _theProcessManager->SetNextServiceTime(this, next_period);
}


ULONG Threadable::GetLastPeriod(void)
{
    return theLastPeriod;
}


VOID Threadable::SetLastPeriod(ULONG period)
{
    theLastPeriod = period;
}


ULONG Threadable::GetNextPeriod(void)
{
    return theNextPeriod;
}


VOID Threadable::SetNextPeriod(ULONG period)
{
    theNextPeriod = period;

    _theProcessManager->SetNextServiceTime(this, theNextPeriod);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\thsensor.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker25NOV92  Initial OS/2 Revision 
 *  pcy07Dec92: DeepGet no longer needs aCode
 *  pcy11Dec92: Rework
 *  pcy22Jan93: Included the threshold value in the event
 *  cad26Aug93: Coordinating yes/no as well as updating ini file
 *  cad31Aug93: Forcing two decimal places, seen occ in front end
 *  cad14Sep93: rewrote checkState() to avoid chattering
 *  cad04Mar94: doing get/set of thresh values properly
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  cad22Jun94: Doing cfgmgr gets via codes, fixes lost comm problem
 *              related to cache not being around after startup
 *  djs17May96: Added multi-phase voltage parameters
 *
 *  v-stebe  29Jul2000   Fixed PREfix errors (bugs #112611, #112612)
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "thsensor.h"
#include "cfgmgr.h"
#include "event.h"
#include "dispatch.h"
#include "isa.h"

#if (C_OS & C_UNIX)
#include "utils.h"
#endif

//Constructor

ThresholdSensor :: ThresholdSensor(PDevice 	aParent, 
		   PCommController 	        aCommController, 
		   INT 			        aSensorCode, 
		   ACCESSTYPE 		        anACCESSTYPE)
	: Sensor(aParent, aCommController, aSensorCode, anACCESSTYPE),
      theMaxThresholdValue((FLOAT)0.0), theMinThresholdValue((FLOAT)0.0),
      theMaxThresholdControl(OFF), theMinThresholdControl(OFF),
      theThresholdState(IN_RANGE)

{
}

typedef struct cfg_code {
   INT isa_code;
   INT low_enable_code, high_enable_code;
   INT low_code, high_code;
} CFGCODE;

static CFGCODE cfg_codes[] = {
   { BATTERYVOLTAGESENSOR,     
     CFG_BATTVOLT_ENABLED_LOW_THRESHOLD,
     CFG_BATTVOLT_ENABLED_HIGH_THRESHOLD,
     CFG_BATTVOLT_VALUE_LOW_THRESHOLD,
     CFG_BATTVOLT_VALUE_HIGH_THRESHOLD },

   { OUTPUTFREQUENCYSENSOR,          
     CFG_FREQUENCY_ENABLED_LOW_THRESHOLD,
     CFG_FREQUENCY_ENABLED_HIGH_THRESHOLD,
     CFG_FREQUENCY_VALUE_LOW_THRESHOLD,
     CFG_FREQUENCY_VALUE_HIGH_THRESHOLD },

   { LINEVOLTAGESENSOR,        
     CFG_LINE_VOLTAGE_ENABLED_LOW_THRESHOLD,
     CFG_LINE_VOLTAGE_ENABLED_HIGH_THRESHOLD,
     CFG_LINE_VOLTAGE_VALUE_LOW_THRESHOLD,
     CFG_LINE_VOLTAGE_VALUE_HIGH_THRESHOLD },

   { MAXLINEVOLTAGESENSOR,     
     CFG_MAX_LINEV_ENABLED_LOW_THRESHOLD,
     CFG_MAX_LINEV_ENABLED_HIGH_THRESHOLD,
     CFG_MAX_LINEV_VALUE_LOW_THRESHOLD,
     CFG_MAX_LINEV_VALUE_HIGH_THRESHOLD },

   { MINLINEVOLTAGESENSOR,     
     CFG_MIN_LINEV_ENABLED_LOW_THRESHOLD,
     CFG_MIN_LINEV_ENABLED_HIGH_THRESHOLD,
     CFG_MIN_LINEV_VALUE_LOW_THRESHOLD,
     CFG_MIN_LINEV_VALUE_HIGH_THRESHOLD },

   { OUTPUTVOLTAGESENSOR,      
     CFG_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD,
     CFG_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,
     CFG_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD,
     CFG_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD },
	
   { UPSLOADSENSOR,            
     CFG_UPS_LOAD_ENABLED_LOW_THRESHOLD,
     CFG_UPS_LOAD_ENABLED_HIGH_THRESHOLD,
     CFG_UPS_LOAD_VALUE_LOW_THRESHOLD,
     CFG_UPS_LOAD_VALUE_HIGH_THRESHOLD },

   { UPSTEMPERATURESENSOR,     
     CFG_UPS_TEMP_ENABLED_LOW_THRESHOLD,
     CFG_UPS_TEMP_ENABLED_HIGH_THRESHOLD,
     CFG_UPS_TEMP_VALUE_LOW_THRESHOLD,
     CFG_UPS_TEMP_VALUE_HIGH_THRESHOLD },

   { AMBIENTTEMPERATURESENSOR, 
     CFG_AMB_TEMP_ENABLED_LOW_THRESHOLD,
     CFG_AMB_TEMP_ENABLED_HIGH_THRESHOLD,
     CFG_AMB_TEMP_VALUE_LOW_THRESHOLD,
     CFG_AMB_TEMP_VALUE_HIGH_THRESHOLD },

   { HUMIDITYSENSOR,                
     CFG_HUMIDITY_ENABLED_LOW_THRESHOLD,
     CFG_HUMIDITY_ENABLED_HIGH_THRESHOLD,
     CFG_HUMIDITY_VALUE_LOW_THRESHOLD,
     CFG_HUMIDITY_VALUE_HIGH_THRESHOLD },

   { PHASEAINPUTVOLTAGESENSOR ,                
     CFG_PHASE_A_INPUT_VOLTAGE_ENABLED_LOW_THRESHOLD,
     CFG_PHASE_A_INPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,
     CFG_PHASE_A_INPUT_VOLTAGE_VALUE_LOW_THRESHOLD,
     CFG_PHASE_A_INPUT_VOLTAGE_VALUE_HIGH_THRESHOLD },
   
/*   { PHASEBINPUTVOLTAGESENSOR,        
     CFG_PHASE_B_VOLTAGE_ENABLED_LOW_THRESHOLD,
     CFG_PHASE_B_VOLTAGE_ENABLED_HIGH_THRESHOLD,
     CFG_PHASE_B_VOLTAGE_VALUE_LOW_THRESHOLD,
     CFG_PHASE_B_VOLTAGE_VALUE_HIGH_THRESHOLD },

   { PHASECINPUTVOLTAGESENSOR,        
     CFG_PHASE_C_VOLTAGE_ENABLED_LOW_THRESHOLD,
     CFG_PHASE_C_VOLTAGE_ENABLED_HIGH_THRESHOLD,
     CFG_PHASE_C_VOLTAGE_VALUE_LOW_THRESHOLD,
     CFG_PHASE_C_VOLTAGE_VALUE_HIGH_THRESHOLD },

   { PHASEAOUTPUTVOLTAGESENSOR,      
     CFG_PHASE_A_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD,
     CFG_PHASE_A_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,
     CFG_PHASE_A_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD,
     CFG_PHASE_A_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD },

   { PHASEBOUTPUTVOLTAGESENSOR,      
     CFG_PHASE_B_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD,
     CFG_PHASE_B_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,
     CFG_PHASE_B_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD,
     CFG_PHASE_B_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD },

   { PHASECOUTPUTVOLTAGESENSOR,      
     CFG_PHASE_C_OUTPUT_VOLTAGE_ENABLED_LOW_THRESHOLD,
     CFG_PHASE_C_OUTPUT_VOLTAGE_ENABLED_HIGH_THRESHOLD,
     CFG_PHASE_C_OUTPUT_VOLTAGE_VALUE_LOW_THRESHOLD,
     CFG_PHASE_C_OUTPUT_VOLTAGE_VALUE_HIGH_THRESHOLD },
  */

   { 0, NO_CODE, NO_CODE, NO_CODE, NO_CODE }
};


VOID ThresholdSensor::getConfigThresholds()
{
    PCHAR s_name = lookupSensorName(IsA());
    INT err = ErrNO_ERROR;
    CHAR value[32];

    CFGCODE * code = cfg_codes;
    
    while ((code->isa_code != 0) && (code->isa_code != IsA())) {
        code++;
    }

    if (code->low_enable_code != NO_CODE) {
        _theConfigManager->Get(code->low_enable_code, value);

        if(_strcmpi(value, "YES") == 0)  {
            theMinThresholdControl = ON;
        }
        else  {
            theMinThresholdControl = OFF;
        }
    }

    if (code->low_code != NO_CODE) {
        _theConfigManager->Get(code->low_code, value);
        theMinThresholdValue = (float)atof(value);
    }

    if (code->high_enable_code != NO_CODE) {
        _theConfigManager->Get(code->high_enable_code, value);

        if(_strcmpi(value, "YES") == 0)  {
            theMaxThresholdControl = ON;
        }
        else  {
            theMaxThresholdControl = OFF;
        }
    }

    if (code->high_code != NO_CODE) {
        _theConfigManager->Get(code->high_code, value);
        theMaxThresholdValue = (float)atof(value);
    }
}


//Member Functions



INT ThresholdSensor::storeValue(const PCHAR aValue)
{
	INT err = ErrNO_ERROR;

	if((err = Sensor::storeValue(aValue)) == ErrNO_ERROR)  {
    	checkState();
    }

    return err;
}


VOID ThresholdSensor :: checkState()
{
    if (theValue)  {
        THSTATE new_state = IN_RANGE;
        float val = (float)atof(theValue);
        
        if ((theMaxThresholdControl == TRUE) &&
            (val >= theMaxThresholdValue)) {
            
            new_state = ABOVE_RANGE;
            
            if (theThresholdState != ABOVE_RANGE) {
                GenerateAboveMessage();
            }
        }
        else if ((theMinThresholdControl == TRUE) &&
                 (val <= theMinThresholdValue)) {
            
            new_state = BELOW_RANGE;
            
            if (theThresholdState != BELOW_RANGE) {
                GenerateBelowMessage();
            }
        }
        
        if ((new_state == IN_RANGE) && (theThresholdState != IN_RANGE)) {
            GenerateInRangeMessage();
        }
    }
}

//Private Functions

INT ThresholdSensor::GetMaxThresholdValue(PCHAR aValue)
{
    sprintf(aValue,"%.2f",theMaxThresholdValue);
    return ErrNO_ERROR;
}

INT ThresholdSensor::GetMinThresholdValue(PCHAR aValue)
{
    sprintf(aValue,"%.2f",theMinThresholdValue);
    return ErrNO_ERROR;
}

INT ThresholdSensor::SetMaxThresholdValue(const PCHAR aValue)
{
  INT err = ErrNO_ERROR;
    //TBD do we want range checking on these???
    //   theMaxThresholdValue=atof(aValue);
  if (sscanf(aValue, "%f", &theMaxThresholdValue) == EOF) {
    err = ErrREAD_FAILED;
  }
//    _theConfigManager->Set(lookupSensorName(IsA()), "HighThresholdValue", aValue);
    checkState();
    return err;
}

INT ThresholdSensor::SetMinThresholdValue(const PCHAR aValue)
{
  INT err = ErrNO_ERROR;
    //   theMinThresholdValue=atof(aValue);
  if (sscanf(aValue, "%f", &theMinThresholdValue)==EOF) {
    err = ErrREAD_FAILED;
  }
//    _theConfigManager->Set(lookupSensorName(IsA()), "LowThresholdValue", aValue);
    checkState();
    return err;
}

INT ThresholdSensor::GetMaxThresholdControl(PCHAR aValue)
{
    sprintf(aValue, "%d", theMaxThresholdControl);
    return ErrNO_ERROR;
}

INT ThresholdSensor::GetMinThresholdControl(PCHAR aValue)
{
    sprintf(aValue, "%d", theMinThresholdControl);
    return ErrNO_ERROR;
}

INT ThresholdSensor::SetMaxThresholdControl(const PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    
    if (_strcmpi(aValue, "YES") == 0) {
        theMaxThresholdControl = ON;
    }
    else if (_strcmpi(aValue, "NO") == 0) {
        theMaxThresholdControl = OFF;
    }
    else {
        INT the_temp_value=atoi(aValue);
        
        if ((the_temp_value == TRUE) || (the_temp_value == FALSE))
          {
              theMaxThresholdControl=the_temp_value;
          }
        else {
            err = ErrINVALID_VALUE;
        }
    }
    
    if (err == ErrNO_ERROR) {
        CHAR val[32];
        strcpy(val, theMaxThresholdControl ? "Yes" : "No");
//        _theConfigManager->Set(lookupSensorName(IsA()), "EnableHighThreshold", val);
    }
    return err;
}


INT ThresholdSensor::SetMinThresholdControl(const PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    
    if (_strcmpi(aValue, "YES") == 0) {
        theMinThresholdControl = ON;
    }
    else if (_strcmpi(aValue, "NO") == 0) {
        theMinThresholdControl = OFF;
    }
    else {
        INT the_temp_value=atoi(aValue);
        
        if ((the_temp_value == TRUE) || (the_temp_value == FALSE))
          {
              theMinThresholdControl=the_temp_value;
          }
        else {
            err = ErrINVALID_VALUE;
        }
    }
    
    if (err == ErrNO_ERROR) {
        CHAR val[32];
        strcpy(val, theMinThresholdControl ? "Yes" : "No");
//        _theConfigManager->Set(lookupSensorName(IsA()), "EnableLowThreshold", val);
    }
    return err;
}


INT ThresholdSensor::GenerateAboveMessage(void)
{
    theThresholdState = ABOVE_RANGE;
    Event the_temp_event(theSensorCode, theValue);
    the_temp_event.AppendAttribute(HIGH_THRESHOLD_EXCEEDED, 
                                    theMaxThresholdValue);
    INT the_return=UpdateObj::Update(&the_temp_event);
    return the_return;
}

INT ThresholdSensor::GenerateBelowMessage(void)
{
    theThresholdState = BELOW_RANGE;
    Event the_temp_event(theSensorCode, theValue);
    the_temp_event.AppendAttribute(LOW_THRESHOLD_EXCEEDED, 
                                    theMinThresholdValue);
    INT the_return=UpdateObj::Update(&the_temp_event);
    return the_return;
}


INT ThresholdSensor::GenerateInRangeMessage(void)
{
    theThresholdState = IN_RANGE;
    Event the_temp_event(theSensorCode, theValue);
    the_temp_event.AppendAttribute(IN_THRESHOLD_RANGE, theValue);
    INT the_return=UpdateObj::Update(&the_temp_event);
    return the_return;     
}


INT ThresholdSensor::Set(INT aCode, const PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    switch(aCode)  {
      case LOW_THRESHOLD:
        SetMinThresholdValue(aValue);
        break;
      case HIGH_THRESHOLD:
        SetMaxThresholdValue(aValue);
        break;
      case LOW_THRESHOLD_ENABLED:
        SetMinThresholdControl(aValue);
        break;
      case HIGH_THRESHOLD_ENABLED:
        SetMaxThresholdControl(aValue);
        break;
      default:
        err = Sensor::Set(aCode, aValue);
        break;
    }
    return err;
}

INT ThresholdSensor::Get(INT aCode, PCHAR aValue)
{
    INT err = ErrNO_ERROR;
    switch(aCode)  {
      case LOW_THRESHOLD:
        GetMinThresholdValue(aValue);
        break;
      case HIGH_THRESHOLD:
        GetMaxThresholdValue(aValue);
        break;
      case LOW_THRESHOLD_ENABLED:
        GetMinThresholdControl(aValue);
        break;
      case HIGH_THRESHOLD_ENABLED:
        GetMaxThresholdControl(aValue);
        break;
      default:
        err = Sensor::Get(aCode, aValue);
        break;
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\timer.cxx ===
/*
*   The timers is an object that stores an alarm
*   setting, and an action to be performed when the alarm
*   setting is reached. This is an abstract object.
*
* REVISIONS:
*  pcy02Dec92: Removed include of typedefs.h 
*  jod07Dec92: Added new Sorted List to the object.
*  pcy14Dec92: Changed Sortable to ApcSortable 
*  ane11Jan93: Added copy constructor
*  ane18Jan93: Implemented Equal operator
*  pcy16Jan93: Timers are now in seconds since time in msec is too big
*
*/
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"


extern "C" {
#include <time.h>
}
#include "apc.h"
#include "err.h"
#include "sortable.h"
#include "event.h"
#include "update.h"
#include "timer.h"

// 
static ULONG theCounter=1;

/*
C+
Name  :Timer
Synop :Constructor. This will assign a unique TimerID number
to theTimerID instance variable and will calculate the
system tiem at which the timer will elapse.
*/
Timer::Timer(ULONG MilliSecondDelay)
//c-
{
   theTimerID    =theCounter++;
   ULONG cur_time = (ULONG)(time(0));
   theAlarmTime  = cur_time + MilliSecondDelay;
}

Timer::Timer(RTimer aTimer)
{
   theTimerID = aTimer.theTimerID;
   theAlarmTime = aTimer.theAlarmTime;
}

INT  Timer:: GreaterThan(PApcSortable sortable)
{
   if (!sortable) return FALSE;
   
   PTimer timer = (PTimer)sortable;
   if (theAlarmTime > timer->GetAlarmTime())
      return TRUE;
   return FALSE;
}

INT  Timer:: LessThan(PApcSortable sortable)
{
   if (!sortable) return FALSE;
   
   PTimer timer = (PTimer)sortable;
   if (theAlarmTime < timer->GetAlarmTime())
      return TRUE;
   return FALSE;
}

INT Timer::Equal (RObj aTimerObj) const
{
   RTimer aTimer = (RTimer)aTimerObj;
   
   if ((theTimerID == aTimer.theTimerID) &&
      (theAlarmTime == aTimer.theAlarmTime))
      return TRUE;
   
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\timer.h ===
/*
*
* NOTES:
*
* REVISIONS:
*  pcy30Nov92: Added header
*  jod07Dec92: Made the timer a sortable Object.
*  pcy11Dec92: Changed #ifndef to _APCTIME_H so not to cause problems w/ TIME
*  pcy14Dec92: Changed Sortable to ApcSortable
*  ane11Jan93: Added copy constructor
*  ane18Jan93: Implemented Equal operator
*  srt12Jul96: Changed _APCTIME_H to _TIMERAPC_H cuz APCTIME.H now exists
*
*/
#ifndef _TIMERAPC_H
#define _TIMERAPC_H

//#include "apc.h"
//#include "apcobj.h"
#include "sortable.h"

_CLASSDEF(Timer)
_CLASSDEF(ApcSortable)

class Timer : public ApcSortable
{
protected:
   ULONG         theTimerID;
   ULONG         theAlarmTime;
   virtual ULONG GetAlarmTime() {return theAlarmTime;};
   
public:
   Timer(ULONG MilliSecondDelay);
   Timer(RTimer aTimer);
   virtual INT   GreaterThan(PApcSortable);
   virtual INT   LessThan(PApcSortable);
   virtual INT IsA() const {return TIMER;};
   virtual ULONG GetTimerID(){return theTimerID;};
   virtual ULONG GetTime(){return theAlarmTime;};
   virtual VOID  Execute()=0;
   virtual INT   Equal( RObj ) const;
}; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\thsensor.h ===
/*
 *  pcy11Dec92: Rework
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  djs03Dec96: Changed generate methods to virtual
 */
 
#ifndef __THSENSOR_H
#define __THSENSOR_H

#include "sensor.h"

_CLASSDEF(ThresholdSensor)


enum THSTATE { ABOVE_RANGE, IN_RANGE, BELOW_RANGE };

#define ON      TRUE
#define OFF     FALSE
			  
class ThresholdSensor : public Sensor {
protected:
   FLOAT  theMaxThresholdValue;
   FLOAT  theMinThresholdValue;
   THSTATE theThresholdState;
   INT theMaxThresholdControl;
   INT theMinThresholdControl;


//Functions

   INT GetMaxThresholdValue(PCHAR);
   INT GetMinThresholdValue(PCHAR);
   INT SetMaxThresholdValue(const PCHAR);
   INT SetMinThresholdValue(const PCHAR);
   INT GetMaxThresholdControl(PCHAR);
   INT GetMinThresholdControl(PCHAR);      
   INT SetMaxThresholdControl(const PCHAR);
   INT SetMinThresholdControl(const PCHAR);
   virtual INT GenerateBelowMessage();
   virtual INT GenerateAboveMessage();
   INT GenerateInRangeMessage();
   virtual INT storeValue(const PCHAR aValue);
   VOID checkState();
   virtual VOID getConfigThresholds();

   
public:
	ThresholdSensor(PDevice aParent, 
                    PCommController aCommController, 
            		INT aSensorCode = NO_SENSOR_CODE, 
                    ACCESSTYPE anACCESSTYPE = AREAD_ONLY);
	

	virtual INT Get(INT, PCHAR);
	virtual INT Set(INT, const PCHAR);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\timerman.cxx ===
/*
*  for the scheduling of events.
*
*  The interface(s) provided are:
*     1. Provide an event to the TimerManager that should be sent back to an
*        UpdateableObject when the specified time elapses.
*
* REVISIONS:
*  pcy30Nov92: list.h added; Insert, Find, and Remove reworked for new list.
*  jod07Dec92: Added Wait to the Timerman.h
*  pcy11Dec92: Added global _theTimerManager
*  ane16Dec92: Added default constructors for DateObj, TimeObj, and DateTimeObj
*  ane23Dec92: Minor changes to DateObj, TimeObj, and WeekObj classes
*  ane11Jan93: Changed theTimerList to a sortable list
*  ane10Feb93: Added RemoveTimer which takes an EventTimer, also added copy
*              of event object when it is added to the timer list
*  pcy16Feb93: Cleanup
*  jod05Apr93: Added changes for Deep Discharge
*  cad02Jul93: Fixed compiler warnings that might be legit
*  cad16Sep93: Added -,< operators, new GetDaysInMonth that take month/year
*  cad12Oct93: Fixed time and week contstructors, added ==
*  pcy04Mar94: Get time until event from a timer
*  jps14Jul94: added (int)s; made timer_id s ULONG (os2 1.x)
*  ajr02May95: Need to stop carrying time in milliseconds
*  ajr29Jul95: More of the above...
*  jps24Oct96: fix CalculateMonthlyTime to return time THIS month if not that
*              time yet.
*  tjg28Jan98: Ensured that all method return paths will release theAccessLock 
*  tjg02Feb98: Delete the theAccessLock in the destructor
*  dma10Sep98: Fixed CalculateMonthlyTime to handle year rollover.
*  mholly03Dec98    : removed theAccessLock and instead use the Access/Release
*                   methods already available in theTimerList.  Made sure that
*                   all accesses to the list are protected correctly, and that
*                   the list is made available before calling out to other
*                   objects via ExecuteTimer().  If the list is not made
*                   available then deadlocks will occur.
*
*  v-stebe  29Jul2000   Fixed PREfix errors (bugs #46358, #46366, #112603)
*/
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
}
#include "apc.h"
#include "_defs.h"
#include "err.h"
#include "slist.h"
#include "codes.h"
#include "timerman.h"
#include "eventime.h"
#include "cfgmgr.h"
#include "utils.h"

#include "datetime.h"


PTimerManager _theTimerManager=NULL;


/*
Name  :TimerManager
Synop :Constructor. INitializes the list.

*/
TimerManager::TimerManager(PMainApplication anApplication)
:  theTimerList(new ProtectedSortedList()), 
   theApplication(anApplication)
{
    _theTimerManager = this;
}


/*
Name  :~TimerManager
Synop :Destroys the internal list.

*/
TimerManager::~TimerManager()
{
    if (theTimerList) {
        theTimerList->FlushAll();
        delete theTimerList;
        theTimerList = NULL;
    }
}


INT TimerManager::Update(PEvent anEvent)
{
    return UpdateObj::Update(anEvent);
}


/*
C+
Name  :CancelTimer
Synop :Cancels the timer. Please pass a good TimerID.
At this level we just remove it from the list.

*/
VOID TimerManager::CancelTimer(ULONG TimerID)
//c-
{
    RemoveEventTimer(TimerID);
}

/*
C+
Name  :SetTimer
Synop :Use this method to set a timer.

SecondDelay : The delay in seconds
  
anEvent          : The event to use during the update.
    
anUpdateObj      : The object to update with the above event.
     
        
RETURNS          : Returns the TimerID of the EventTimer
                   that is associated with the timer.
          
anUpdateObj will be equal to 'this' if you want the timer
to update YOU. anEvent should be dynamically allocated 'new'
and the timer will delete it when you invoke CancelTimer.

*/
ULONG TimerManager::SetTheTimer(ULONG SecondsDelay, PEvent anEvent,
                                PUpdateObj anUpdateObj)
{
    INT timer_id = 0;
    
    //  You must have anEvent and anUpdateObj
    if(anEvent && anUpdateObj)  {
        PEvent newEvent = new Event (*anEvent);
        if (newEvent) {
          ULONG sec_time = SecondsDelay;
          PEventTimer anEventTimer = new EventTimer(newEvent, anUpdateObj, sec_time);
        
          if (anEventTimer) {
              timer_id = anEventTimer->GetTimerID();
              newEvent->SetAttributeValue(TIMER_ID, timer_id);
              InsertEventTimer(anEventTimer);
          }
        }
    }    
    return timer_id;
}

/*
C+
Name  :SetTimer
Synop :Use this method to set a timer.

DateTime         : A DateTimeObj which is not deallocated by the system
                   This DateTimeObj will contain an absolute date value.
  
anEvent          : The event to use during the update.
    
anUpdateObj      : The object to update with the above event.
      
        
RETURNS          : Returns the TimerID of the EventTimer
                   that is associated with the timer.
          
anUpdateObj will be equal to 'this' if you want the timer
to update YOU. anEvent should be dynamically allocated 'new'
and the timer will delete it when you invoke CancelTimer.
*/
ULONG TimerManager::SetTheTimer(PDateTimeObj aDateTime,
                                PEvent anEvent,PUpdateObj anUpdateObj)
{
    INT timer_id = 0;
    
    // Must have anEvent, anUpdateObj and aDateTime
    if(anEvent && anUpdateObj && aDateTime)  {
        ULONG sec = (ULONG)(aDateTime->GetSeconds());        
        PEvent newEvent = new Event (*anEvent);        
        PEventTimer anEventTimer = new EventTimer(newEvent, anUpdateObj, sec);

        if (anEventTimer) {
            timer_id = anEventTimer->GetTimerID();
            InsertEventTimer(anEventTimer);
        }
    }
    return timer_id;
}




/*
Name  :InsertEventTimer
Synop :Inserts the Eventtimer inside the internal linked list.
The EventTimer has a unique TimerID which is used to
retrieve the node inthe list.
*/
VOID  TimerManager::InsertEventTimer(PEventTimer anEventTimer)
{
    // Use the add function which should insert in timer order
    theTimerList->Add((RApcSortable)*anEventTimer);
}


/*
Name  :FindEventTimer
Synop :Finds the Event Timer in the internal linked list.

*/
PEventTimer TimerManager::FindEventTimer(ULONG aTimerId)
{
    PEventTimer return_timer = NULL;
    
    // Lock access to the list
    theTimerList->Access();

    // Iterate through the list
    ListIterator iter(*theTimerList);
    PEventTimer test_node = (PEventTimer)theTimerList->GetHead();
    BOOL found = FALSE;

    while (test_node && !found) {

        if (test_node->GetTimerID() == aTimerId) {
            return_timer = test_node;
            found = TRUE;
        }
        test_node = (PEventTimer)iter.Next();
    }
    theTimerList->Release();
    return return_timer;
}

/*
Name  :RemoveEventTimer
Synop :Removes the EventTimer object from the internval linked list.
*/
VOID TimerManager::RemoveEventTimer(ULONG aTimerId)
{
    theTimerList->Access();
    PEventTimer aTimer = FindEventTimer(aTimerId);
    
    if (aTimer) {
        theTimerList->Detach(*aTimer);
        delete aTimer;
        aTimer = NULL;
    }
    theTimerList->Release();
}


ULONG TimerManager::GetTimeEventOccurs(ULONG aTimerID)
{
    ULONG return_value = 0;

    theTimerList->Access();
    PEventTimer timer = FindEventTimer(aTimerID);
    
    if (timer) {
        return_value = timer->GetTime();
    }
    theTimerList->Release();
    return return_value;
}


/*
Name  :RemoveEventTimer
Synop :Removes the EventTimer object from the internval linked list.
*/
VOID TimerManager::RemoveEventTimer(PEventTimer anEventTimer)
{
    if (theTimerList && anEventTimer) {
        theTimerList->Detach(*anEventTimer);
        delete anEventTimer;
        anEventTimer = NULL;
    }
}


/*
Name  :NotifyClient
Synop :Given anEventTimer object, will notify the client that a timer
has fired.
*/
VOID TimerManager::NotifyClient(PEventTimer anEventTimer)
{
    if (anEventTimer) {
        anEventTimer->Execute();
    }
}

/*****************************************************************************
****************************************************************************/
PDateTimeObj TimerManager::CalculateDailyTime (RTimeObj aTime, ULONG threshold)
{
    DateObj currDate;
    TimeObj currTime;
    ULONG newDay = currDate.GetDay();
    ULONG newMonth = currDate.GetMonth();
    ULONG newYear = currDate.GetYear();
    
    // If the calculated time is earlier than the current time, then
    // adjust the day forward by one (and possibly the month and year)
    if ((currTime.GetHour() > aTime.GetHour()) ||
        ((currTime.GetHour() == aTime.GetHour()) &&
        (currTime.GetMinutes() > aTime.GetMinutes())) ||
        ((currTime.GetHour() == aTime.GetHour()) &&
        (currTime.GetMinutes() == aTime.GetMinutes()) &&
        (currTime.GetSeconds() > aTime.GetSeconds())))
    {
        newDay++;
        CalculateNextDay (currDate.GetDaysInMonth(),
            currDate.GetMonth(),
            newDay, newMonth, newYear);
    }
    
    // Take the year, month, day from currDate and the hour,min,and sec
    // from specified time
    PDateTimeObj retTime = new DateTimeObj (newMonth,
        newDay,
        newYear,
        aTime.GetHour(),
        aTime.GetMinutes(),
        aTime.GetSeconds());
    
    
    // If the time until the time to be returned is less than the specified
    // threshold, then make it the next day
    //if (retTime->GetMilliseconds() < (LONG)threshold)
    if (retTime->GetSeconds() < (LONG)threshold)
    {
        newDay++;
        CalculateNextDay (currDate.GetDaysInMonth(),
            currDate.GetMonth(),
            newDay, newMonth, newYear);
        
        delete retTime;
        retTime = NULL;
        
        // Take the year, month, day from currDate and the hour,min,and sec
        // from specified time
        PDateTimeObj retTime = new DateTimeObj (newMonth,
            newDay,
            newYear,
            aTime.GetHour(),
            aTime.GetMinutes(),
            aTime.GetSeconds());
    }
    return retTime;
}



PDateTimeObj TimerManager::CalculateMonthlyTime (PCHAR aDay, PCHAR aTime)
{
    time_t now_time = time(NULL);
    struct tm *now = localtime(&now_time);
    INT day_number = UtilDayToDayOfWeek(aDay);
    if(now->tm_wday < day_number)  {
        now->tm_wday = day_number;
    }
    else {
        now->tm_mon += 1;
        if(now->tm_mon > 11)  {
            now->tm_mon = 0;
            now->tm_year += 1;
        }
    }
    
    now->tm_mday = 0;
    mktime(now);
    
    INT hour, minute, second;
    hour = minute = second = 0;
    if (sscanf(aTime, "%d:%d:%d", &hour, &minute, &second) == EOF) {
      // An error parsing the time occured
      return NULL;
    }

    PDateTimeObj monthly_time = new DateTimeObj(now->tm_mon, 
        now->tm_mday,
        now->tm_year,
        hour,
        minute,
        second);
    
    return monthly_time;
}

/*****************************************************************************
****************************************************************************/
PDateTimeObj TimerManager::CalculateMonthlyTime (RWeekObj aDay, RTimeObj aTime)
{
    INT done = FALSE;
    
    DateObj today;
    PDateTimeObj weekday = CalculateWeeklyTime (aDay, aTime);
    PDateTimeObj retTime = (PDateTimeObj)NULL;
    
    if (weekday != NULL) {
      if ( weekday->GetDate()->GetMonth() - 1 == (today.GetMonth()) % 12 ) {
          return weekday;
      }
    
      ULONG newDay = weekday->GetDate()->GetDay();
      ULONG newMonth = weekday->GetDate()->GetMonth();
      ULONG newYear = weekday->GetDate()->GetYear();
    
      if (newDay <= 7 && newMonth == today.GetMonth()) { 
          return weekday;
      }
    
      while (!done)
      {
          newDay += 7;
          CalculateNextDay(weekday->GetDate()->GetDaysInMonth(),
              weekday->GetDate()->GetMonth(),
              newDay, newMonth, newYear);
          if (newMonth != weekday->GetDate()->GetMonth())
          {
              retTime = new DateTimeObj (newMonth, newDay, newYear,
                  aTime.GetHour(),
                  aTime.GetMinutes(),
                  aTime.GetSeconds());
              done = TRUE;
          }
      }
      delete weekday;
      weekday = NULL;
    }
    
    return retTime;
}

/*****************************************************************************
****************************************************************************/
PDateTimeObj TimerManager::CalculateWeeklyTime (RWeekObj aDay, RTimeObj aTime)
{
    WeekObj currWeek;
    DateObj currDate;
    TimeObj currTime;
    
    ULONG newDay = currDate.GetDay();
    ULONG newMonth = currDate.GetMonth();
    ULONG newYear = currDate.GetYear();
    
    // Determine which day the shutdown should occur on
    if (currWeek.GetWeekDay() < aDay.GetWeekDay())
        newDay = currDate.GetDay() + 
        aDay.GetWeekDay() - currWeek.GetWeekDay();
    else if (currWeek.GetWeekDay() > aDay.GetWeekDay())
        newDay = currDate.GetDay() + 7 - 
        (currWeek.GetWeekDay() - aDay.GetWeekDay());
    // The day to schedule for is the same as the current day, so check to
    // see if the time is before the current time
    else if ((currTime.GetHour() > aTime.GetHour()) ||
        ((currTime.GetHour() == aTime.GetHour()) &&
        (currTime.GetMinutes() > aTime.GetMinutes())) ||
        ((currTime.GetHour() == aTime.GetHour()) &&
        (currTime.GetMinutes() == aTime.GetMinutes()) &&
        (currTime.GetSeconds() > aTime.GetSeconds())))
        // If the time to schedule for is before the current time, then
        // schedule for next week
        newDay += 7;
    
    // If the calculated day is more than there are days in the month,
    // then wrap into the next month
    CalculateNextDay (currDate.GetDaysInMonth(),
        currDate.GetMonth(),
        newDay, newMonth, newYear);
    
    PDateTimeObj retTime = new DateTimeObj (newMonth,
        newDay,
        newYear,
        aTime.GetHour(),
        aTime.GetMinutes(),
        aTime.GetSeconds());
    
    return retTime;
}

/*****************************************************************************
****************************************************************************/
VOID TimerManager::CalculateNextDay(ULONG daysInMonth,
                                    ULONG theMonth,
                                    ULONG &newDay, 
                                    ULONG &newMonth, 
                                    ULONG &newYear)
{
    if (newDay > daysInMonth) {
        newDay %= daysInMonth;
        
        if (theMonth == 12) {
            newMonth = 1;
            newYear++;
        }
        else {
            newMonth++;
        }
    }
}


BOOL TimerManager::ExecuteTimer()
{
    BOOL timer_executed = FALSE;
    ULONG_PTR now = time(0);

    //
    // get access to the list
    //
    theTimerList->Access();
    PEventTimer timer = (PEventTimer)(theTimerList->GetHead());
    
    if (timer && (timer->GetTime() <= now)) {
        //
        // detach the eventTimer before firing it
        //
        theTimerList->Detach(*timer);
        //
        // now that the eventTimer is detached
        // it is safe (and required) that the
        // list be released
        //
        theTimerList->Release();
        NotifyClient(timer);
        delete timer;
        timer_executed = TRUE;
    }
    else {
        theTimerList->Release();
    }
    return timer_executed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\timerman.h ===
/*
* REVISIONS:
*  pcy30Nov92: Changed obj.h to apcobj.h; InsertEventTimer now returns VOID.
*  jod07Dec92: Added a pure virtual Wait function to TimerManager.
*  pcy11Dec92: Added global _theTimerManager
*  ane11Dec92: Moved mainapp.h
*  ane16Dec92: Added default constructors for date/time classes
*  ane22Dec92: Added constructor to take string of form "8:00 AM"
*  ane11Jan93: Changed theTimerList to a sortable list
*  ane08Feb93: Added new RemoveEventTimer function
*  ajr22Feb93: Changed case of mainApp.h to mainapp.h
*  jod05Apr93: Added changes for Deep Discharge
*  cad09Jul93: allowing access to findeventtimer
*  cad16Sep93: Added -, < operators to DateObj, made some methods const
*  cad28Sep93: Made sure destructor(s) virtual
*  cad12Oct93: Added == operator
*  ajr02May95: Need to stop carrying time in milliseconds
*  tjg26Jan98: Added Stop method
*  mholly03Dec98    : removed theAccessLock and instead use the Access/Release
*                   methods already available in theTimerList.  Also removed
*                   the Suspend()/Release()/IsSuspended() methods (not used)
*/

#ifndef _TIMERMAN_H
#define _TIMERMAN_H

extern "C" {
#include <time.h>
}
#include "apc.h"
#include "_defs.h"

_CLASSDEF(TimerManager)

_CLASSDEF(EventTimer)
_CLASSDEF(ProtectedSortedList)
_CLASSDEF(MainApplication)

#include "err.h"
#include "apcobj.h"
#include "update.h"
#include "datetime.h"


//
// Global
//
extern PTimerManager _theTimerManager;


class TimerManager : public UpdateObj {
    
public:
    
    TimerManager(PMainApplication anApplication);
    virtual ~TimerManager();
    
    virtual INT    Update(PEvent anEvent);
    
    virtual PEventTimer  FindEventTimer(ULONG TimerID);
    virtual VOID         CancelTimer(ULONG TimerID);
    virtual ULONG        SetTheTimer(PDateTimeObj aDateTime,
                                     PEvent anEvent, 
                                     PUpdateObj anUpdateObj);
    virtual ULONG        SetTheTimer(ULONG SecondsDelay,
                                     PEvent anEvent, 
                                     PUpdateObj anUpdateObj); 
            ULONG        GetTimeEventOccurs(ULONG aTimerId);    
    virtual VOID         Wait(ULONG Delay) = 0;
    
    PDateTimeObj CalculateDailyTime(RTimeObj aTime, ULONG threshold = 0);
    PDateTimeObj CalculateWeeklyTime(RWeekObj aDay, RTimeObj aTime);
    PDateTimeObj CalculateMonthlyTime (RWeekObj aDay, RTimeObj aTime);
    PDateTimeObj CalculateMonthlyTime (PCHAR aDay, PCHAR aTime);
    
    VOID CalculateNextDay (ULONG daysInMonth, 
                           ULONG theMonth,
                           ULONG &newDay, 
                           ULONG &newMonth, 
                           ULONG &newYear);
    
    virtual VOID  Stop()        { };

    virtual BOOL ExecuteTimer();

protected:
    ULONG    theSystemTime;
    
    PMainApplication     theApplication; 
    
    virtual VOID   InsertEventTimer(PEventTimer anEventTimer);
    virtual VOID   RemoveEventTimer(ULONG TimerID);
    virtual VOID   RemoveEventTimer(PEventTimer anEventTimer);  
    virtual VOID   NotifyClient(PEventTimer anEventTimer);
    PProtectedSortedList theTimerList;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\towdels.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy13Jan92: Get rid of Update/Validate; Return err from Set
 */
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "towdels.h"
#include "comctrl.h"
#include "dispatch.h"

//Constructor

TurnOffWithDelaySensor :: TurnOffWithDelaySensor(PDevice aParent, PCommController aCommController)
:	Sensor(aParent,aCommController,TURN_OFF_UPS_AFTER_DELAY,AREAD_WRITE)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\tokenstr.cxx ===
/*
* Copyright 1998 American Power Conversion, All Rights Reserved
*
* NAME: tokenstr.cxx
*
* PATH: 
*
* REVISION: 
*
* DESCRIPTION:
*    This file contains the class definition for the TokenString class.  It
* is designed to replace the strtok() function, because when using strtok 
* "if multiple or simultaneous calls are made ... a high potential for data 
* corruption and innacurate results exists." -- MSVC OnLine Help
*
* REFERENCES:
*    Initially created by Todd Giaquinto
*
* NOTES:
*  This function mimics the behavior of strtok in all aspects.  
*  Examples:
*     String: ,,,,1,2,3  Sep: ,  Tokens: "1" "2" "3"
*     String: ,#1#2,3#4  Sep: ,# Tokens: "1" "2" "3" "4"
*
*  Typical Usage:
*     TokenString token_str(string, sep);
*     PCHAR tok = token_str.GetCurrentToken();
*     while (tok) {
*        .....
*        tok = token_str.GetCurrentToken();
*     }
*
*  The GetCurrentToken call will return a pointer to the current string token
*  and then move the internal pointer to the start of the next token.  If
*  GetCurrentToken is called without an argument, the separator string passed
*  to the constructor is used to gather each token.  However, GetCurrentToken
*  is overloaded so that one implementation can take a new separator string
*  as an argument.  Once a new separator string is passed in, all subsequent
*  calls to the parameter-less GetCurrentToken will use the last passed in
*  separator.
*
* REVISIONS:
*   tjg19Jan98: Initial implementation
*   tjg29Jan98: Included formal code review comments
*
*  v-stebe  29Jul2000   Fixed PREfix errors (bugs #46356, #46357)
*/

#include "cdefine.h"
#include "tokenstr.h"



//   Function: TokenString Constructor
// Parameters: 1. Character pointer containing the string (ie "#str#str2#")
//             2. Character pointer containing the separator (ie "#")
//  Ret Value: None
//    Purpose: Initializes all class member variables to defaults.  Then
//             stores the argument values.
TokenString::TokenString(PCHAR aString, PCHAR aSeparatorString) :
theString(NULL),
theSeparators(NULL),
theCurrentLocation(NULL),
theSeparatorLength(0)
{
   if (aString) {
      theString = new CHAR[strlen(aString) + 1];

      if (theString != NULL) {
        strcpy(theString, aString);
      }

      theCurrentLocation = theString;
   }
   
   storeSeparatorString(aSeparatorString);
}



//   Function: TokenString Destructor
// Parameters: None
//  Ret Value: None
//    Purpose: Cleans up all allocated memory.  
TokenString::~TokenString()
{
   delete [] theString;
   theString = NULL;

   delete [] theSeparators;
   theSeparators = NULL;
}



//   Function: storeSeparatorString
// Parameters: Character pointer to the new separator string
//  Ret Value: None
//    Purpose: Stores the parameter aString as theSeparators.  This method is
//             optimized to allocate memory only if the current buffer is too
//             small.
VOID TokenString::storeSeparatorString(PCHAR aString)
{
   if (aString) {
      INT length = strlen(aString);
      if (length > theSeparatorLength) {
         delete [] theSeparators;
         theSeparatorLength = length;
         theSeparators = new CHAR[length + 1];
      }

      if (theSeparators != NULL) {
        strcpy(theSeparators, aString);
      }
   }
}



//   Function: isSeparator
// Parameters: A character to check against theSeparators
//  Ret Value: TRUE,  if theSeparators contains aCharacter
//             FALSE, otherwise
//    Purpose: Searches through theSeparators string looking for an
//             occurrence of aCharacter
BOOL TokenString::isSeparator(CHAR aCharacter)
{
   BOOL is_separator = FALSE;

   PCHAR current_sep = theSeparators;

   // Run this loop while the pointer and contents are non-NULL, and
   // we have not determined that aCharacter is a separator.
   while ((current_sep != NULL) && 
          (*current_sep != NULL) && 
          (is_separator == FALSE)) {

      if (*current_sep == aCharacter) {
         is_separator = TRUE;
      }
      current_sep++;
   }

   return is_separator;
}



//   Function: GetCurrentToken
// Parameters: Character pointer to a new separator string
//  Ret Value: Pointer to the current string in the list
//    Purpose: Sets theSeparators to aSeparatorString and gets the next token
//             in the string (using the new separator string)
PCHAR TokenString::GetCurrentToken(PCHAR aSeparatorString)
{
   storeSeparatorString(aSeparatorString);
   return GetCurrentToken();
}



//   Function: GetCurrentToken
// Parameters: None
//  Ret Value: Pointer to the current string in the list
//    Purpose: Gets the next token in the string using theSeparators as
//             the separator string
PCHAR TokenString::GetCurrentToken()
{
   BOOL recording_token = FALSE;
   BOOL done = FALSE;
   PCHAR current_token = NULL;

   // While there is stuff in the list and the current token has not ended
   while (theCurrentLocation && *theCurrentLocation && !done) {

      // Check if the current character is a separator
      BOOL is_separator = isSeparator(*theCurrentLocation);

      // If we found a separator and we were recording a token,
      // change this separator to a NULL and reset flags
      if (is_separator && recording_token) {
         *theCurrentLocation = NULL;        
         recording_token = FALSE;
         done = TRUE;
      }

      // If the character isn't a separator and not 
      // already recording a token, mark the beginning of the token
      else if (!is_separator && !recording_token) {
         current_token = theCurrentLocation;
         recording_token = TRUE;
      }

      theCurrentLocation++;
   }

   return current_token;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\tokenstr.h ===
/*
* Copyright 1998 American Power Conversion, All Rights Reserved
*
* NAME: tokenstr.h
*
* PATH: 
*
* REVISION: 
*
* DESCRIPTION:
*    This file contains the class definition for the TokenString class.  It
* is designed to replace the strtok() function, because when using strtok 
* "if multiple or simultaneous calls are made ... a high potential for data 
* corruption and innacurate results exists." -- MSVC OnLine Help
*
* REFERENCES:
*    Initially created by Todd Giaquinto
*
* NOTES:
*  This function mimics the behavior of strtok in all aspects.  
*  Examples:
*     String: ,,,,1,2,3  Sep: ,  Tokens: "1" "2" "3"
*     String: ,#1#2,3#4  Sep: ,# Tokens: "1" "2" "3" "4"
*
*  Typical Usage:
*     TokenString token_str(string, sep);
*     PCHAR tok = token_str.GetCurrentToken();
*     while (tok) {
*        .....
*        tok = token_str.GetCurrentToken();
*     }
*
*  The GetCurrentToken call will return a pointer to the current string token
*  and then move the internal pointer to the start of the next token.  If
*  GetCurrentToken is called without an argument, the separator string passed
*  to the constructor is used to gather each token.  However, GetCurrentToken
*  is overloaded so that one implementation can take a new separator string
*  as an argument.  Once a new separator string is passed in, all subsequent
*  calls to the parameter-less GetCurrentToken will use the last passed in
*  separator.
*
* REVISIONS:
*   tjg19Jan98: Initial implementation
*   tjg29Jan98: Included formal code review comments
*/

#ifndef __TOKENSTR_H
#define __TOKENSTR_H

#include "cdefine.h"
#include "apcobj.h"

class TokenString {
private:
   PCHAR        theString;
   PCHAR        theSeparators;
   PCHAR        theCurrentLocation;
   INT          theSeparatorLength;

   VOID         storeSeparatorString(PCHAR aString);
   BOOL         isSeparator(CHAR aCharacter);

                // Declare a private copy constructor and operator = so 
                // that any would-be users will get compilation errors
                TokenString(const TokenString &anExistingTokenString);
   TokenString& operator = (const TokenString &anExistingTokenString);

public:
                TokenString(PCHAR aString, PCHAR aSeparatorString = NULL);
   virtual      ~TokenString();

   PCHAR        GetCurrentToken();
   PCHAR        GetCurrentToken(PCHAR aSeparatorString);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\trimsen.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker25NOV92   Initial OS/2 Revision
 *  cgm12Apr96: Destructor with unregister
 */
 
#ifndef __TRIMSEN_H
#define __TRIMSEN_H

#include "stsensor.h"
#include "event.h"

_CLASSDEF(SmartTrimSensor)

			  
class SmartTrimSensor : public StateSensor {


protected:
        
public:
	SmartTrimSensor( PDevice 	  aParent, 
                      PCommController aCommController);
    virtual ~SmartTrimSensor();
	
//overidden interfaces

	virtual INT IsA() const { return SMARTTRIMSENSOR; };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\tripregs.cxx ===
/*
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "tripregs.h"

TripRegisterSensor :: TripRegisterSensor(PDevice aParent, PCommController aCommController)
			: Sensor(aParent, aCommController, TRIP_REGISTER)
{
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\towdels.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  rct11Dec92	Created as stub for SmartUps
 *  ane11Jan93  Replaced stubs with real function implementations
 *  pcy13Jan92: Get rid of Update/Validate; Return err from Set
 */
 
#ifndef __TOWDELS_H
#define __TOWDELS_H

#include "sensor.h"
#include "event.h"

_CLASSDEF(TurnOffWithDelaySensor)

           
class TurnOffWithDelaySensor : public Sensor {

protected:
        
public:

   TurnOffWithDelaySensor( PDevice aParent, PCommController aCommController);

//overidden interfaces

   virtual INT  IsA() const { return TURNOFFWITHDELAYSENSOR; };
//Additional Interfaces

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\trimsen.cxx ===
/*
 * NOTES:
 *
 * REVISIONS:
 *  ker25NOV92  Initial OS/2 Revision 
 *  pcy07Dec92: Changed defines used for smart boost state values. 
 *  pcy14Dec92: Changed READ_WRITE to AREAD_WRITE
 *  pcy16Feb93: Made to work like a state sensor
 *  djs22Feb96: Created trim sensor from boost code
 *  cgm12Apr96: Destructor with unregister
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "trimsen.h"
#include "comctrl.h"

//Constructor

SmartTrimSensor :: SmartTrimSensor(PDevice 		aParent, 
		         PCommController 	aCommController)
:	StateSensor(aParent,aCommController, SMART_TRIM_STATE,AREAD_WRITE)
{
      storeState(SMART_TRIM_OFF);
      theCommController->RegisterEvent(SMART_TRIM_STATE, this);
}
      
SmartTrimSensor :: ~SmartTrimSensor()
{
      theCommController->UnregisterEvent(SMART_TRIM_STATE, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\trans.cxx ===
/*
 * REVISIONS:
 *  jod30NOV92  Changes made due to GCIP stuff 
 *  ane16DEC92  Added cdefine.h
 *  pcy02Feb93: AddEvent must return a value.  Changed to return ErrNO_ERROR
 *  cad29Oct93: added get next attr
 *  cad08Dec93: added extended get/set types
 *  mwh05May94: #include file madness , part 2
 *  mwh07Jun94: port for NCR
 *  jbc07Nov96: added check to only allow one transaction per code
 *  mds10Jul97: modified Transaction Item Equal() function
 *  mds10Jul97: changed GetFirstAttribute() to const to work with Equal() 
 *  mds14Jul97: StrIntCmpI was renamed to ApcStrIntCmpI 
 */

#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

#include "_defs.h"
extern "C" {
#include <stdlib.h>
#include <string.h>
}

#include "trans.h"
#include "apc.h"
#include "err.h"
#include "event.h"
#include "list.h"
#include "message.h"
#include "utils.h"

#if (C_OS & C_NCR)
#  include "incfix.h"
#endif 


TransactionObject::TransactionObject(Type type, INT anId)
: theType(type),
theId(anId),
theProtocolMessageList((List*)NULL),
thePMIterator((ListIterator*)NULL)
{
   theProtocolMessageList = new List();
   if (theProtocolMessageList)
      thePMIterator = &(RListIterator)(theProtocolMessageList->InitIterator());
   else
      SetObjectStatus(ErrMEMORY);
}

TransactionObject:: ~TransactionObject()
{
   if (theProtocolMessageList)
      theProtocolMessageList->FlushAll();
   delete theProtocolMessageList;
   theProtocolMessageList = (List*)NULL;
   delete thePMIterator;
   thePMIterator = NULL;
}

VOID TransactionObject::AddMessage(PMessage aMessage)
{
   theProtocolMessageList->Append(aMessage);
}


INT TransactionItem::transactionItemCount = 0;

TransactionItem::TransactionItem(Type aType, INT aCode, CHAR* aValue)
: TransactionObject(aType, transactionItemCount++),
theCode(aCode),
theErrorCode(0),
theValue((CHAR*)NULL),
theAttributeList((List*)NULL),
theAttribIterator((ListIterator*)NULL)
{
   SetValue(aValue);
   theAttributeList = new List();
   if (theAttributeList)
      theAttribIterator = &(RListIterator)(theAttributeList->InitIterator());
}

TransactionItem::~TransactionItem()
{
   if (theValue)
      free(theValue);
   theValue = (CHAR*)NULL;
   
   if (theAttributeList)
      theAttributeList->FlushAll();
   delete theAttributeList;
   theAttributeList = (List*)NULL;
   delete theAttribIterator;
   theAttribIterator = (ListIterator*)NULL;
}

VOID TransactionItem::SetValue(CHAR* aValue)
{
   if (theValue != (CHAR*)NULL)
   {
      free(theValue);
      theValue = (CHAR*)NULL;
   }
   if (aValue != (CHAR*)NULL)
      theValue = _strdup(aValue);
}


VOID TransactionItem::AddAttribute(PAttribute anAttribute)
{
   theAttributeList->Append(anAttribute);
}

VOID TransactionItem::AddAttribute(INT aCode, CHAR* aValue)
{
   PAttribute attribute = new Attribute(aCode, aValue);
   AddAttribute(attribute);
}

PAttribute TransactionItem:: GetFirstAttribute() const
{
   theAttribIterator->Reset();
   return (Attribute*)theAttributeList->GetHead();
}

PAttribute TransactionItem:: GetNextAttribute()
{
   PAttribute ret = (PAttribute)(theAttribIterator->Next());
   
   return ret;
}

INT TransactionItem:: Equal(RObj obj) const
{
   INT ret_value = FALSE;

   RTransactionItem trans_item = (RTransactionItem) obj;
  
   if (trans_item.GetCode() == GetCode()){
      ret_value = TRUE;
      
      // if the code values are the same, this does not 
      // necessarily mean that the transaction items are equal
      // A transaction item contains a list of attributes, and 
      // if the first attributes of each transaction item are
      // not equal, then the transaction items are not equal.
      
      // get first attributes from the attribute list
      PAttribute attrib1 = trans_item.GetFirstAttribute();
      PAttribute attrib2 = GetFirstAttribute();

      // if both attributes are present
      if(attrib1 && attrib2){

         // get actual attribute values
         PCHAR attrib_str1 = attrib1->GetValue(); 
         PCHAR attrib_str2 = attrib2->GetValue();
         
         // check to make sure that attribute values are not NULL
         if(attrib_str1 != NULL && attrib_str2 != NULL){
            if(attrib_str1[0] != NULL && attrib_str2[0] != NULL){
               
               // if both of the attribute strings are not equal to
               // one another, then return false
               if(ApcStrIntCmpI(attrib_str1,attrib_str2) != EQUAL){
                  ret_value = FALSE;
               }
            }
         }
      }
   }
   return ret_value;
}

INT TransactionGroup::transactionGroupCount = 0;

TransactionGroup::TransactionGroup(Type aType)  :
TransactionObject(aType, transactionGroupCount++),
theAuthenticationString((CHAR*)NULL),
theResponse((CHAR*)NULL),
theEventList((List*)NULL),
theEventIterator((ListIterator*)NULL),
theTransactionList((List*)NULL),
theTransactionIterator((ListIterator*)NULL),
InitialSetResponseRepeated(0),
InitialSetResponse((CHAR*)NULL),
theErrorCode(0),
theErrorIndex(0)
{
   theEventList = new List();
   theEventIterator = &(RListIterator)(theEventList->InitIterator());
   theTransactionList = new List();
   theTransactionIterator = &(RListIterator)(theTransactionList->InitIterator());
}

TransactionGroup:: ~TransactionGroup()
{
   if (theAuthenticationString)
      free (theAuthenticationString);
   theAuthenticationString =(CHAR*)NULL;
   
   if (theResponse)
      free( theResponse);
   theResponse =(CHAR*)NULL;
   
   if (InitialSetResponse)
      free(InitialSetResponse);
   InitialSetResponse = (CHAR*)NULL;
   
   theEventList->FlushAll();
   delete theEventList;
   theEventList = (List*)NULL;
   delete theEventIterator;
   theEventIterator = NULL;
   theTransactionList->FlushAll();
   delete theTransactionList;
   theTransactionList = (List*)NULL;
   delete theTransactionIterator;
   theTransactionIterator = NULL;
}    



INT TransactionGroup:: Equal(RObj obj) const
{
   //   if (strcmp(obj.IsA(), IsA()))
   //      return FALSE;
   
   RTransactionGroup tg = (RTransactionGroup)obj;
   if (tg.GetId() == GetId())
      return TRUE;
   
   return FALSE;
}


VOID TransactionGroup::SetAuthentication(CHAR* aString)
{
   if (theAuthenticationString != (CHAR*)NULL)
   {
      free(theAuthenticationString);
      theAuthenticationString = (CHAR*)NULL;
   }
   if (aString != (CHAR*)NULL)
      theAuthenticationString = _strdup(aString);
}

VOID TransactionGroup::SetResponse(CHAR* aString)
{
   if (theResponse != (CHAR*)NULL)
   {
      free(theResponse);
      theResponse = (CHAR*)NULL;
   }
   if (aString != (CHAR*)NULL)
      theResponse = _strdup(aString);
}

VOID TransactionGroup:: SetInitialSetResponseRepeated(INT repeat)
{
   InitialSetResponseRepeated = repeat;
}

VOID TransactionGroup:: SetErrorIndex(INT index)
{
   theErrorIndex = index;
}

VOID TransactionGroup:: SetInitialSetResponse(CHAR* initialResponse)
{
   InitialSetResponse = _strdup(initialResponse);
}

INT TransactionGroup::AddTransactionItem(PTransactionItem aTransactionItem)
{
   int err = ErrNO_ERROR;
   Type addType = aTransactionItem->GetType();
   
   // simple transactions types can be added to complex groups, but
   // not vice-versa.  This is a completely arbitrary exclusion,
   // and could be changed if needed. For now it save a couple
   // of lines of code.
   //
   if ((addType == theType) ||
      ((theType == EXTENDED_GET) && (addType == GET)) ||
      ((theType == EXTENDED_SET) && (addType == SET)))
   {
      // Check to see if transaction already exists.
      PTransactionItem trans_item = (PTransactionItem)NULL;
      trans_item = (PTransactionItem)theTransactionList->Find(aTransactionItem);
      
      // If the transaction was not found, then add it to theTransactionList
      if (trans_item==NULL)
      {
         theTransactionList->Append(aTransactionItem);
      }
      
      if (theTransactionIterator == (ListIterator*)NULL) {
         theTransactionIterator =
            &(RListIterator)(theTransactionList->InitIterator());
      }
   }
   else
   {
      aTransactionItem->SetErrorCode(ErrTYPE_COMBINATION);
      err = ErrTYPE_COMBINATION;
   }
   return err;
}

INT TransactionGroup::AddEvent(PEvent aEvent)
{
   //   theEventList->Add(*aEvent);
   return ErrNO_ERROR;
}

PTransactionItem TransactionGroup::GetCurrentTransaction()
{
   return (PTransactionItem)(& (theTransactionIterator->Current()));
}

PTransactionItem TransactionGroup::GetFirstTransactionItem()
{
   theTransactionIterator->Reset();
   return (PTransactionItem) theTransactionList->GetHead();
}

PTransactionItem TransactionGroup::GetNextTransactionItem()
{
   return (PTransactionItem) theTransactionIterator->Next();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\trans.h ===
/*
* REVISIONS:
*  pcy02Feb93: GetCode() needs to be const
*  cad07Oct93: Plugging Memory Leaks
*  cad29Oct93: Added get next attr
*  mwh05May94: #include file madness , part 2
*  mds10Jul97: changed GetFirstAttribute() to const so that it can be
*              used by the Equal() method 
*/
#ifndef __TRANS_H
#define __TRANS_H

_CLASSDEF(Attribute)
_CLASSDEF(TransactionObject)
_CLASSDEF(TransactionItem)
_CLASSDEF(TransactionGroup)

_CLASSDEF(Event)
_CLASSDEF(List)
_CLASSDEF(ListIterator)
_CLASSDEF(Message)

#include "apc.h"
#include "apcobj.h"


class TransactionObject : public Obj
{
  protected:
     Type             theType;
     INT              theId;
     List*            theProtocolMessageList;
     ListIterator*    thePMIterator;
  public:
     TransactionObject(Type aType, INT anId);
     virtual ~TransactionObject();
     Type     GetType() {return theType;};
     INT      GetId() const {return theId;};
     List*    GetProtocolMessageList() {return theProtocolMessageList;}
     VOID     AddMessage(PMessage aMessage);
     VOID     SetType(Type thetype) {theType = thetype;};
     VOID     SetId(INT id) {theId = id;}
};



class TransactionItem : public TransactionObject
{
private:
   static INT transactionItemCount;
   
protected:
   INT            theCode;
   CHAR          *theValue;
   INT            theErrorCode;
   List          *theAttributeList;
   ListIterator  *theAttribIterator;
   
public:
   TransactionItem(Type aType, INT aCode, CHAR* aValue = NULL);
   virtual ~TransactionItem();
   INT        GetCode() const {return theCode;};
   CHAR*      GetValue() {return theValue;};
   INT        GetErrorCode() {return theErrorCode;};
   List*      GetAttributeList(){return theAttributeList;};
   VOID       SetValue(CHAR* aValue);
   VOID       SetCode(INT aCode) {theCode = aCode;};
   VOID       SetErrorCode(INT anErrorCode) {theErrorCode = anErrorCode;};
   VOID       AddAttribute(INT anAttributeCode, CHAR* aValue);
   VOID       AddAttribute(PAttribute anAttribute);
   PAttribute GetFirstAttribute() const;
   PAttribute GetNextAttribute();
   virtual INT        IsA() const { return TRANSACTIONITEM;}
   virtual INT      Equal( RObj ) const;
};


class TransactionGroup : public TransactionObject
{
private:
   static INT   transactionGroupCount;
protected:
   CHAR*        theAuthenticationString;
   List*        theEventList;
   ListIterator *theEventIterator;
   List*        theTransactionList;
   ListIterator *theTransactionIterator;
   CHAR*        theResponse;
   CHAR*        InitialSetResponse;
   INT          InitialSetResponseRepeated;
   INT          theErrorIndex;
   INT          theErrorCode;
   
public:
   TransactionGroup(Type aType);
   virtual ~TransactionGroup();
   PTransactionItem GetFirstTransactionItem();
   PTransactionItem GetNextTransactionItem();
   PTransactionItem GetCurrentTransaction();
   List*            GetEventList() {return theEventList;}
   List*            GetTransactionItemList() {return theTransactionList;}
   CHAR*            GetAuthentication() {return theAuthenticationString;};
   CHAR*            GetResponse() {return theResponse;};
   CHAR*            GetInitialSetResponse() {return InitialSetResponse;}
   INT              GetInitialSetResponseRepeated() {return InitialSetResponseRepeated;}
   INT              GetErrorIndex() {return theErrorIndex;}
   INT              GetErrorCode() {return theErrorCode;};
   VOID             SetErrorCode(INT anErrorCode) {theErrorCode = anErrorCode;};
   VOID             SetResponse(CHAR* aString);
   VOID             SetAuthentication(CHAR* aString);
   VOID             SetInitialSetResponseRepeated(INT repeat);
   VOID             SetInitialSetResponse(CHAR* initialResponse);
   VOID             SetErrorIndex(INT index);
   INT              AddTransactionItem(PTransactionItem aTransaction);
   INT              AddEvent(PEvent anEvent);
   virtual INT      IsA() const { return TRANSACTIONGROUP;}
   virtual INT      Equal( RObj ) const;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\tripregs.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *
 */
#ifndef TRIPREGS_H
#define TRIPREGS_H

#include "eeprom.h"

_CLASSDEF(TripRegisterSensor)

class TripRegisterSensor : public Sensor {
   
public:
   TripRegisterSensor(PDevice aParent, PCommController aCommController=NULL);
   virtual INT IsA() const { return TRIPREGISTERSENSOR; };
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\turnoff.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  xxxddMMMyy 
 *
 */
#ifndef __TURNOFF_H
#define __TURNOFF_H

#include "sensor.h"
#include "event.h"

_CLASSDEF(TurnOffUpsOnBatterySensor)

			  
class TurnOffUpsOnBatterySensor : public Sensor {


protected:
        INT AutoRebootEnabled;
public:
	TurnOffUpsOnBatterySensor(PDevice aParent, PCommController aCommController);

//overidden interfaces

    virtual INT IsA() const { return TURNOFFUPSONBATTERYSENSOR; };
    virtual INT Get(INT, PCHAR);
    virtual INT Set(INT, const PCHAR);

//Additional Interfaces

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\turnoff.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  xxxddMMMyy
 *  SjA10Dec92: Small Syntax error. READ_WRITE needs to be changed to AREAD_WRITE
 *  srt24Dec96: Fixe init to use config mgr instead of hard-coded disabled.
 */
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "turnoff.h"
#include "cfgmgr.h"
#include "comctrl.h"
#include "dispatch.h"

//Constructor

TurnOffUpsOnBatterySensor :: TurnOffUpsOnBatterySensor(PDevice 		aParent,
		         PCommController 	aCommController)
:	Sensor(aParent,aCommController,TURN_OFF_UPS_ON_BATTERY,AREAD_WRITE)
{
    CHAR aValue[8];
    INT err = _theConfigManager->Get(CFG_AUTO_UPS_REBOOT_ENABLED, aValue);
	//Make sure this value is correct
	AutoRebootEnabled = (('Y' == aValue[0]) || ('y' == aValue[0]));
}


INT TurnOffUpsOnBatterySensor::Get(INT aCode, PCHAR aValue)
{
   INT err = ErrNO_ERROR;

	switch(aCode) {
	  case AUTO_REBOOT_ENABLED:
	    err = _theConfigManager->Get(CFG_AUTO_UPS_REBOOT_ENABLED, aValue);
		//Make sure this value is correct
		AutoRebootEnabled = (('Y' == aValue[0]) || ('y' == aValue[0]));
		break;
	  default:
	  	break;
	}
	return err;    
}


INT TurnOffUpsOnBatterySensor::Set(INT aCode, const PCHAR aValue)
 {

   INT err = ErrNO_ERROR;

	switch(aCode) {
	  case AUTO_REBOOT_ENABLED:
//	    err = _theConfigManager->Set(CFG_AUTO_UPS_REBOOT_ENABLED, aValue);
		//Make sure this value is correct
		AutoRebootEnabled = (('Y' == aValue[0]) || ('y' == aValue[0]));
		break;
	  case TURN_OFF_UPS_ON_BATTERY:
	  	// We use this data member because the file system is down (in Novell)
		// before we check this config parameter in the INI file.  So we hold
		// this boolean value which is set every time we check AUTO_REBOOT_ENABLED
		// -- James
		if (AutoRebootEnabled) {
		  // reboot when power returns;
		  err = theCommController->Set(TURN_OFF_UPS_ON_BATTERY, (CHAR*)NULL);
		  } 
		else {
		  // Don't reboot when power returns;
		  err = theCommController->Set(TURN_OFF_UPS_AFTER_DELAY, (CHAR*)NULL);
		}
	  default:
	  	break;
	}
	return err;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ulinecon.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker03DEC92:  Initial break out of sensor classes into separate files 
 *  jod05Apr93: Added changes for Deep Discharge
 *  pcy12Oct93: 2 ABNORMALS to cause a line bad (fixes LF during cal)
 *  jps14Jul94: made theUpsState ULONG
 *
 */
#ifndef ULINECON_H
#define ULINECON_H

#include "stsensor.h"
#include "isa.h"

_CLASSDEF(UtilityLineConditionSensor)


class UtilityLineConditionSensor : public StateSensor {
   
protected:   
   ULONG theUpsState;
   INT theInformationSource;
   INT theLineFailCount;

   
public:
   UtilityLineConditionSensor(PDevice aParent, PCommController aCommController=NULL);
   virtual ~UtilityLineConditionSensor();
   virtual INT IsA() const { return UTILITYLINECONDITIONSENSOR; };
   virtual INT Validate(INT, const PCHAR);
   virtual INT Update(PEvent anEvent);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ulinecon.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  ker04DEC92: Initial Filling in of Member Functions
 *  SjA11Dec92: Validate method now returns ErrNO_ERROR rather than VALID.
 *  pcy17Dec92: Now I do StateSensor::Validate before doing my own.
 *  pcy16Feb93: No longer need to register for UPS_STATE
 *  pcy16Feb93: Get transfer cause and ignore if self test
 *  ajr22Feb93: included utils.h
 *  jod05Apr93: Added changes for Deep Discharge
 *  cad09Sep93: Fix for lights test causing events
 *  pcy09Sep93: Check LINE_AVAILABILITY to make sure line is bad
 *  pcy10Sep93: Hopefully this works now
 *  pcy18Sep93: Cleaned up line condition handling
 *  pcy20Sep93: handle line fails during tests and sim pwr fail
 *  pcy12Oct93: 2 ABNORMALS to cause a line bad (fixes LF during cal)
 *  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
 *  djs16Mar95: changed upsstate.h to sysstate.h
 *  cgm10Apr96: Destructor should unregister
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "ulinecon.h"
#include "comctrl.h"
#include "device.h"
#include "event.h"
#include "utils.h"
#include "sysstate.h"
#include "timerman.h"

#define QCOMMAND 0
#define NINECOMMAND 1

UtilityLineConditionSensor :: UtilityLineConditionSensor(PDevice aParent, PCommController aCommController)
   :  StateSensor(aParent, aCommController, UTILITY_LINE_CONDITION),
      theInformationSource(0), theLineFailCount(0), theUpsState(0)
{
   storeState(LINE_GOOD);
   theCommController->RegisterEvent(UTILITY_LINE_CONDITION, this);
   theDevice->RegisterEvent(BATTERY_CALIBRATION_CONDITION, this);
   theDevice->RegisterEvent(SIMULATE_POWER_FAIL, this);
   theDevice->RegisterEvent(SELF_TEST_STATE, this);
}
 

INT UtilityLineConditionSensor::Update(PEvent anEvent)
{
   INT err = ErrNO_ERROR;
   INT aCode = anEvent->GetCode();
   PCHAR aValue = anEvent->GetValue();
    
   switch(aCode)
      {
      case BATTERY_CALIBRATION_CONDITION:
         switch(atoi(aValue))
            {
            case BATTERY_CALIBRATION_IN_PROGRESS:
               theCommController->UnregisterEvent(UTILITY_LINE_CONDITION, this);
               theCommController->RegisterEvent(LINE_CONDITION_TEST, this);
               theInformationSource = NINECOMMAND;
               break;
            
            case NO_BATTERY_CALIBRATION:
            case NO_BATTERY_CALIBRATION_IN_PROGRESS:
            case BATTERY_CALIBRATION_CANCELLED:
               if (theInformationSource == NINECOMMAND)
                  {
                  theCommController->UnregisterEvent(LINE_CONDITION_TEST, this);
                  theCommController->RegisterEvent(UTILITY_LINE_CONDITION, this);
                  theInformationSource = QCOMMAND;
                  }
               break;
            }
         break;
        
      case LINE_CONDITION_TEST:
         //
         // Convert the event to a UTILITY_LINE_CONDITION event and
         // send it to myself
         //
         switch(atoi(aValue))
            {
            case ABNORMAL_CONDITION:
               {
               //
               // Only after the second successive abnormal condition should
               // we bother with this.  This is so we ignore ABNORMAL_COND
               // events at the start of deep discharge
               //
               if(theLineFailCount > 0)
                  {
                  CHAR lbtmp[31];
                  sprintf(lbtmp, "%d", LINE_BAD);
                  if ((err = StateSensor::Validate(UTILITY_LINE_CONDITION, 
                       lbtmp)) == ErrNO_ERROR)
                     {
                     Event evt(UTILITY_LINE_CONDITION, LINE_BAD);
                     storeValue(lbtmp);
                     UpdateObj::Update(&evt);
                     }
                  }
               else
                  {
                  theLineFailCount++;
                  }
               }
               break;
            
            case NO_ABNORMAL_CONDITION:
               {
               theLineFailCount = 0;
               CHAR lbtmp[31];
               sprintf(lbtmp, "%d", LINE_GOOD);
               if ((err = StateSensor::Validate(UTILITY_LINE_CONDITION, 
                     lbtmp)) == ErrNO_ERROR)
                  {
                  Event evt(UTILITY_LINE_CONDITION, LINE_GOOD);
                  storeValue(lbtmp);
                  UpdateObj::Update(&evt);
                  }
               }
               break;
            }          // switch for case LINE_CONDITION_TEST
         break;
        

      case UTILITY_LINE_CONDITION:    
         if ((err = Validate(aCode, aValue)) == ErrNO_ERROR)
            {
            storeValue(aValue);
            UpdateObj::Update(anEvent);
            }
         break;
        
      case SIMULATE_POWER_FAIL:
         switch(atoi(aValue))
            {
            case SIMULATE_POWER_FAIL:
               SET_BIT(theUpsState, SIMULATE_POWER_FAIL_BIT);
               break;
            
            case SIMULATE_POWER_FAIL_OVER:
               CLEAR_BIT(theUpsState, SIMULATE_POWER_FAIL_BIT);
               break;
            }
         break;
        
      case SELF_TEST_STATE:
         switch(atoi(aValue))
            {
            case SELF_TEST_IN_PROGRESS:
               SET_BIT(theUpsState, SELF_TEST_BIT);
               break;
            
            case NO_SELF_TEST_IN_PROGRESS:
               CLEAR_BIT(theUpsState, SELF_TEST_BIT);
               break;
            }
         break;
      }

   return err;          
}




INT UtilityLineConditionSensor::Validate(INT aCode, const PCHAR aValue)
{
   INT err = ErrNO_ERROR;
   if (aCode != theSensorCode)
      {
      err = ErrINVALID_CODE;
      }
   else if(IS_STATE(UPS_STATE_IN_SELF_TEST))
      {
      err = ErrTEST_IN_PROGRESS;
      }
   else
      {
      switch(atoi(aValue))
         {
         case LINE_GOOD:
            {
            theLineFailCount = 0;
            //
            // Make sure line is good to handle UPSLinkism
            // that doesnt change tranfer cause when line
            // fails during self test or sim pwrfail
            //
            CHAR line_state[32];
            theCommController->Get(LINE_CONDITION_TEST, 
                                   line_state);
            if(atoi(line_state) == ABNORMAL_CONDITION)
               {
               err = ErrINVALID_VALUE;
               }
            break;
            }

         case LINE_BAD:
            //
            // Dont do this if we're a BackUPS
            //
            if (theDevice->IsA() != BACKUPS)
               {
               //
               // If we're in DeepDischarge ignore LINE_BAD events
               //
               if(theInformationSource != NINECOMMAND)
                  {
                  //
                  // If we're simulating a power fail
                  // don't try to stop the event
                  //
                  if(!(IS_STATE(UPS_STATE_SIMULATED_POWER_FAIL)))
                     {
                     CHAR transfer_cause[32];
                     CHAR self_test[32];
                     CHAR line_state[32];
                     
                     //
                     // If transfer is due to a self test double check
                     // to see if line is bad
                     //
                     theCommController->Get(TRANSFER_CAUSE, transfer_cause);
                     _itoa(SELF_TEST_TRANSFER, self_test, 10);
                     
                     if (strcmp(transfer_cause, self_test) == 0)
                        {
                        //
                        // Make sure line is bad to handle UPSLinkism
                        // that doesnt change tranfer cause when line
                        // fails during self test or sim pwrfail
                        //
                        theCommController->Get(LINE_CONDITION_TEST, line_state);
                        if(atoi(line_state) == NO_ABNORMAL_CONDITION)
                           {
                           err = ErrINVALID_VALUE;
                           }
                        else
                           {
                           //
                           // Wait a while to handle UPS-Linkism for
                           // the 9 command that returns 00 at the start
                           // of a self test
                           //
                           _theTimerManager->Wait(3000L);
                           theCommController->Get(LINE_CONDITION_TEST, line_state);
                           if(atoi(line_state) == NO_ABNORMAL_CONDITION)
                              {
                              err = ErrINVALID_VALUE;
                              }
                           }
                        }
                      
                     //
                     // Same for Lights Test
                     //
                     CHAR ups_status[32];
                     theDevice->Get(UPS_STATE, ups_status);
                     if (atoi(ups_status) & UPS_STATE_IN_LIGHTS_TEST)
                        {
                        err = ErrINVALID_VALUE;
                        }
                     }
                  }
               }        // if (!= BACKUPS)
            break;

         default:
            err = ErrINVALID_VALUE;
            break;
         }
        
        
      if (err == ErrNO_ERROR)
         {
         err = StateSensor::Validate(aCode, aValue);
         }
      }
    
   return err; 
}



UtilityLineConditionSensor :: ~UtilityLineConditionSensor()
{
    if (theCommController)
       theCommController->UnregisterEvent(UTILITY_LINE_CONDITION, this);

    if (theDevice) {
        theDevice->UnregisterEvent(BATTERY_CALIBRATION_CONDITION, this);
        theDevice->UnregisterEvent(SIMULATE_POWER_FAIL, this);
        theDevice->UnregisterEvent(SELF_TEST_STATE, this);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\unssens.cxx ===
/*
 *
 * NOTES:
 *  This sensor is used for all sensors that are not supported on a
 *  particular device.  Rather than requiring the device to determine
 *  if the sensor is supported each time asked, it simply uses
 *  this dummy sensor which returns ErrUNSUPPORTED for all member functions
 *
 * REVISIONS:
 *  pcy29Jan93: Added to SCCS
 *  pcy29Jan93: Needs a newline at the end of the file
 *  jps14Jul94: added stdlib for os2
 *
 */
#define INCL_BASE
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <stdlib.h>
#endif
}

#include "unssens.h"

UnsupportedSensor _theUnsupportedSensor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\unssens.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  xxxddMMMyy
 *  tjg02Mar98: Override the DeepGetWithoutUpdate method that was recently
 *              added to sensor class
 *
 */
#ifndef __UNSSENS_H
#define __UNSSENS_H

#include "sensor.h"
#include "err.h"



_CLASSDEF(UnsupportedSensor)


#define UNSUPPORTED_SENSOR -1

class UnsupportedSensor : public Sensor {
   
public:
	UnsupportedSensor() : Sensor((PDevice)0,(PCommController)0,UNSUPPORTED_SENSOR){};
   virtual INT IsA() const {return UNSUPPORTEDSENSOR;};
   virtual INT Get(PCHAR aValue) {return ErrUNSUPPORTED;};
   virtual INT DeepGet(PCHAR aValue) {return ErrUNSUPPORTED;};
   virtual INT DeepGet(INT aCode, PCHAR aValue) {return ErrUNSUPPORTED;};
   virtual INT DeepGetWithoutUpdate(PCHAR aValue) {return ErrUNSUPPORTED;};
   virtual INT Set(const PCHAR aValue) {return ErrUNSUPPORTED;};
	
};

extern UnsupportedSensor _theUnsupportedSensor;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ups.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  rct08Dec92 fixed up some things ... finished implemantation
 *  rct11Dec92 added additional states
 *  SjA15Dec92 Fixed Macros SET_BIT and CLEAR_BIT.
 *  pcy27Dec92 Parent is now an UpdateObj
 *  pcy21Jan93 Moved state stuff into upsstate.h
 *
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  jps14Jul94: made theUpsState LONG
 */

#ifndef _INC__UPS_H
#define _INC__UPS_H

#include "apc.h"
#include "device.h"

//
// Defines
//

_CLASSDEF(Ups)


//
// Uses
//

class Ups : public Device {

protected:

   ULONG theUpsState;
   virtual VOID registerForEvents() = 0;

public:

   Ups(PUpdateObj aDeviceController, PCommController aCommController);

   virtual INT    Get(INT code, PCHAR value) = 0;
   virtual INT    Set(INT code, const PCHAR value) = 0;
   virtual INT    Update(PEvent event) = 0;
   INT    Initialize();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\update.cxx ===
/*
 * REVISIONS:
 *  ane11Nov92: Changed arg type in Equal 
 *  pcy30Nov92: Added dispatcher and Register/UnregisterEvent stuff
 *  sja09Dec92: Took out BAD Windows Debug Code.
 *  cad27Dec93: include file madness
 *  cad28Feb94: added copy constructor (just prints warning)
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 */
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
}
#include "_defs.h"
#include "update.h"
#include "event.h"
#include "err.h"
#include "dispatch.h"


UpdateObj::UpdateObj ()
{
    theDispatcher = (PDispatcher)NULL;
}


UpdateObj::UpdateObj (const UpdateObj&)
{
    theDispatcher = (PDispatcher)NULL;

#ifdef APCDEBUG
    printf("Warning: UpdateObj copy constructor called\n");
#endif
}


UpdateObj::~UpdateObj ()
{
    if (theDispatcher) {
        delete theDispatcher;
        theDispatcher = (PDispatcher)NULL;
    }
};


INT UpdateObj::Update(PEvent value)
{
    
    if(theDispatcher != NULL)  {
        theDispatcher->Update(value); // Send updates to all objects registered
    }
	return ErrNO_ERROR;
}

INT UpdateObj::Set(INT,PCHAR) {
    return ErrNO_ERROR;
}

INT UpdateObj::Get(INT,PCHAR) {
    return ErrNO_ERROR;
}


INT UpdateObj::RegisterEvent(INT EventCode,PUpdateObj anUpdateObj)
{
    if(theDispatcher == NULL)  {
        theDispatcher = new Dispatcher;
    }
    return theDispatcher->RegisterEvent(EventCode,anUpdateObj);
}


INT UpdateObj::UnregisterEvent(INT EventCode,PUpdateObj anUpdateObj)
{
    INT err = ErrNO_ERROR;
    
    if(theDispatcher)  {
        err = theDispatcher->UnregisterEvent(EventCode,anUpdateObj);
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ups2slep.cxx ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy13Jan92: Implement
 *  pcy16Feb93: Use %d for sleep time in sprintf to solve bug
 *  ajr09May95: Need to fix for keeping internal time in seconds.
 *  srt04Jun97: Added support for 15 day sleep.
 */
#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM
#include "cdefine.h"
extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "ups2slep.h"
#include "comctrl.h"
#include "dispatch.h"
#include "errlogr.h"
#include "utils.h"


//Constructor

PutUpsToSleepSensor :: PutUpsToSleepSensor(PDevice aParent, PCommController aCommController)
:       Sensor(aParent,aCommController, PUT_UPS_TO_SLEEP, AREAD_WRITE)
{
}

INT PutUpsToSleepSensor::Set(const PCHAR aValue)
{
    INT  err = ErrNO_ERROR;
    CHAR sleep_time[32];
    long iValue;
    CHAR sHuns[4];

    // only ups-compatible values should get to this point, having been validated in the FE & 
    if ((iValue=atol(aValue)/360) <= 3599) {                                // convert msecs to tenths of an hour (TOHs).
        sprintf(sleep_time,"%s%02d",_ltoa(iValue/100L,sHuns,36),iValue%100); // format the sleep command

        err  = theCommController->Set(PUT_UPS_TO_SLEEP, sleep_time);
    }
    else {
        err= ErrINVALID_VALUE;
    }

   return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ulinkdef.h ===
/*
 *
 * REVISIONS:
 *  pcy29Nov92: Changed define names to get around 32 char name limit
 *  jod14May93: Added Matrix changes.
 *  cad10Jun93: Added MUps codes
 *  ajr14Feb96: Sinix merges
 *  djs22Feb96: Added incrementparameter
 *  djs07May96: Added Dark Star parameters
 *  poc04Jul96: #define for UPSMODELNAME should have read \001 not ^A
 */

#define ASYNC_CHARS          "|!$%+?=*#&"

#define LINEFAILCHAR		 '!'
#define RETLINEFAILCHAR		 '$'
#define LOWBATERYCHAR		 '%'
#define RETLLOWBATCHAR		 '+'
#define LOADOFFCHAR			 '*'
#define REPLACEBATCHAR		 '#'
#define EEPROMCHANGECHAR 	 '|'
#define MUPSALARMCHAR            '&'

#define SMARTMODE            "Y"
#define TURNOFFSMARTMODE     "R"
#define LIGHTSTEST           "A"
#define TURNOFFAFTERDELAY    "K"
#define TURNOFFUPSONBATT     "UUS"
#define SIMULATEPOWERFAIL    "U"
#define BATTERYTEST          "W"
#define SHUTDOWNUPS          "Z"
#define SHUTDOWNUPSWAKEUP    "@"
#define BATTERYCALIBRATION   "D"
#define BYPASSMODE           "^"
#define BATTERYTESTRESULT    "X"
#define BATTERYPACKS         ">"
#define BADBATTERYPACKS      "<"
#define TRANSFERCAUSE        "G"
#define FIRMWAREREV          "V"
#define UPSTYPE              "g"
#define BATTERYCAPACITY      "f"
#define UPSSTATE             "Q"
#define STATEREGISTER        "~"
#define TRIPREGISTERS        "8"
#define TRIPREGISTER1        "'"
#define DIPSWITCHES          "7"
#define BATTERYRUNTIMEAVAIL  "j"
#define COPYRIGHTCOMMAND     "y"
#define COMMANDSET           "\025"       // CTRL U 
//#define AMPERESDRAWN         "/"
//#define PERCENTVOLTAMPS      "\"
#define BATTERYVOLTAGE       "B"
#define INTERNALTEMP         "C"
#define OUTPUTFREQ           "F"
#define LINEVOLTAGE          "L"
#define MAXLINEVOLTAGE       "M"
#define MINLINEVOLTAGE       "N"
#define OUTPUTVOLTAGE        "O"
#define LOADPOWER            "P"
#define EEPROMVALUES         "\032"       // CTRL Z 
#define EEPROMRESET          "z"
#define DECREMENTPARAMETER   "-"
#define INCREMENTPARAMETER   "+"
#define EEPROMPASSWORD       "\022"       // CTRL P 
#define OUTPUTVOLTAGEREPORT  "\026"       // CTRL V 
#define LANGUAGE             "\014"       // CTRL L 
#define AUTOSELFTEST         "E"
#define UPSID                "c"
#define UPSSERIALNUMBER      "n"
#define UPSMANUFACTUREDATE   "m"
#define BATTERYREPLACEDATE   "x"
#define HIGHTRANSFERPOINT    "u"
#define LOWTRANSFERPOINT     "l"
#define MINIMUMCAPACITY      "e"
#define OUTPUTVOLTAGESETTING "o"
#define SENSETIVITY          "s"
#define LOWBATTERYRUNTIME    "q"
#define ALARMDELAY           "k"
#define SHUTDOWNDELAY        "p"
#define SYNCTURNBACKDELAY    "r"
#define EARLYTURNOFF         "w"
#define LINECONDITIONTEST    "9"
#define UPSMODELNAME         "\001"	// Ctrl A
#define UPSNEWFIRMWAREREV    "b"

#define TIMESINCEON          "T"

// MeasureUPS
#define MUPSAMBIENTTEMP       "t"
#define MUPSHIGHTEMPBOUND     "["
#define MUPSLOWTEMPBOUND      "]"
#define MUPSHUMIDITY          "h"
#define MUPSHIGHHUMIDITY      "{"
#define MUPSLOWHUMIDITY       "}"
#define MUPSCONTACTPOSITION   "i"
#define MUPSFIRMWAREREV       "v"
#define MUPSENABLEREGISTER    "I"
#define MUPSALARMREGISTER     "J"
#define MUPSEDITPARAMETER     "-"

// Dark Star
#define MODULECOUNTSSTATUS     "\004"    // CTRL D
#define ABNORMALCONDITION      "\005"    // CTRL E

#define INPUTVOLTAGEFREQ       "\011"    // CTRL I

#define OUTPUTVOLTAGECURRENT   "\017"    // CTRL O


#define APC_COPYRIGHT "(C) APCC"

#define NOT_AVAIL                      "NA"
#define OK_RESP                        "OK"
#define SMARTMODE_OK                   "SM"
#define TURNOFFSMARTMODE_OK            "BYE"
#define LIGHTSTEST_RESP                "OK"
#define TURNOFFAFTERDELAY_NOT_AVAIL    "NA"
#define SHUTDOWN_RESP                  "OK"
#define SHUTDOWN_NOT_AVAIL             "NA"
#define SIMULATEPOWERFAILURE_OK        "OK"
#define SIMULATEPOWERFAILURE_NOT_AVAIL "NA"
#define BATTERYTEST_NOT_AVAIL          "NA"
#define BATTERYCALIBRATION_OK          "OK"
#define BATTERYCALIBRATION_CAP_TOO_LOW "NO"
#define BATTERYCALIBRATION_NOT_AVAIL   "NA"
#define BATTERYTEST_OK                 "OK"
#define BATTERYTEST_BAD_BATTERY        "BT"
#define BATTERYTEST_NO_RECENT_TEST     "NO"
#define BATTERYTEST_INVALID_TEST       "NG"
#define TRANSFERCAUSE_NO_TRANSFERS     "O"
#define TRANSFERCAUSE_SELF_TEST         "S"
#define TRANSFERCAUSE_LINE_DETECTED     "T"
#define TRANSFERCAUSE_LOW_LINE_VOLTAGE  "L"
#define TRANSFERCAUSE_HIGH_LINE_VOLTAGE "H"
#define TRANSFERCAUSE_RATE_VOLTAGE_CHANGE "R"
#define TRANSFERCAUSE_INPUT_BREAKER_TRIPPED "B"

#define COPYRIGHT_RESP                    ""
#define EEPROM_RESP                       ""
#define DECREMENT_OK                      ""
#define DECREMENT_NOT_AVAIL               ""
#define DECREMENT_NOT_ALLOWED             ""
#define INCREMENT_OK                      ""
#define INCREMENT_NOT_ALLOWED             ""
#define INCREMENT_NOT_AVAIL               ""
#define BYPASS_IN_BYPASS                  "BYP"
#define BYPASS_OUT_OF_BYPASS              "INV"
#define BYPASS_ERROR                      "ERR"
// #define UTILITY_LINE_CONDITION            ""
// #define LINE_FAIL                         ""
// #define EVENT                             ""
// #define LINE_GOOD                         ""

#define TRANSFERCAUSE_CODE_LINE_DETECTED         6601
#define TRANSFERCAUSE_CODE_NO_TRANSFERS          6602
#define TRANSFERCAUSE_CODE_SELF_TEST             6603
#define TRANSFERCAUSE_CODE_LOW_LINE_VOLTAGE      6604
#define TRANSFERCAUSE_CODE_HIGH_LINE_VOLTAGE     6605
#define TRANSFERCAUSE_CODE_RATE_VOLTAGE_CHANGE   6606
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\update.h ===
/*
 * REVISIONS:
 *  ane11Nov92: Changed IsA and Equal.
 *  pcy30Nov92: Added dispatcher and Register/UnregisterEvent
 *  pcy30Apr93: Made Register/Unregister for virtual, removed IsA
 *  cad07Oct93: Plugging Memory Leaks
 *  ajr03Dec93: Set and Get were good only for compiler warnings... fixed.
 *  cad28Feb94: added copy constructor
 *  mwh05May94: #include file madness , part 2
 */

#ifndef __UPDATEOBJ_H
#define __UPDATEOBJ_H

#include "_defs.h"
//
// Defines
//
_CLASSDEF(UpdateObj)
//
// Implementation uses
//
#include "apcobj.h"
//
// Interface uses
//
_CLASSDEF(Event)
_CLASSDEF(Dispatcher)

class UpdateObj : public Obj
{
  protected:
    PDispatcher      theDispatcher;

  public:
    UpdateObj();
    UpdateObj(const UpdateObj&);

    virtual ~UpdateObj();
    virtual INT Update(PEvent value);
    virtual INT RegisterEvent(INT anEventCode, PUpdateObj aAttribute);
    virtual INT UnregisterEvent(INT anEventCode, PUpdateObj aAttribute);
    virtual INT Set(INT code, const PCHAR value);
    virtual INT Get(INT code, PCHAR value);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ups.cxx ===
/*
 *
 * REVISIONS:
 *  pcy27Dec92: Parent is now an UpdateObj
 *  pcy22Jan93: Destructor is in h file
 *  pcy28Jan93: Removed netcons.h
 *
 */
#include "cdefine.h"
#include "_defs.h"

#include "ups.h"
#include "devctrl.h"
#include "comctrl.h"
#include "err.h"

_CLASSDEF(DeviceController)
_CLASSDEF(DeviceController)

Ups::Ups(PUpdateObj aDeviceController, PCommController aCommController)
	   : Device(aDeviceController, aCommController), theUpsState(0)
{
}

INT Ups::Initialize()
{
	registerForEvents();
    return ErrNO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsidsen.cxx ===
/*
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  pcy26Jan93: I'm a EepromSensor now
 *
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "upsidsen.h"

UpsIdSensor :: UpsIdSensor(PDevice aParent, PCommController aCommController)
			: EepromSensor(aParent, aCommController, UPS_ID, AREAD_WRITE)
{
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\ups2slep.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  rct11Dec92	Created as stub for SmartUps 
 *  pcy13Jan93  Replaced stubs with real function implementations
 *
 */
 
#ifndef __UPS2SLEP_H
#define __UPS2SLEP_H

#include "sensor.h"
#include "event.h"

_CLASSDEF(PutUpsToSleepSensor)

           
class PutUpsToSleepSensor : public Sensor {

protected:
        
public:

   PutUpsToSleepSensor( PDevice aParent, PCommController aCommController);

//overidden interfaces

   virtual INT  IsA() const { return PUTUPSTOSLEEPSENSOR; };
   virtual INT    Set(const PCHAR);

//Additional Interfaces

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsidsen.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *  pcy26Jan93: I'm a EepromSensor now
 *
 */
#ifndef UPSIDSEN_H
#define UPSIDSEN_H

#include "eeprom.h"

_CLASSDEF(UpsIdSensor)

class UpsIdSensor : public EepromSensor {
   
public:
   UpsIdSensor(PDevice aParent, PCommController aCommController=NULL);
   virtual INT IsA() const  { return UPSIDSENSOR; };
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsdev.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  pcy11Dec92: Get rid of list.h and node.h
 *  pcy11Dec92: Use _CLASSDEF for CommController and Message
 *  cad22Jul93: Had to add destructor
 *  cad15Nov93: Added Get
 *  cad18Nov93: Added forcecommflag
 *  mwh19Nov93: changed EventID to INT
 *  pcy10Mar94: Got rid of meaningless overides of Get and Set
 */
#ifndef __UPSDEV_H
#define __UPSDEV_H

_CLASSDEF(UpsCommDevice)
_CLASSDEF(TransactionGroup)
_CLASSDEF(CommController)
_CLASSDEF(Message)

#include "cdevice.h"
#include "serport.h"

#define UNKNOWN   0

class Message;

class UpsCommDevice : public CommDevice
{
// for windows version made some of these methods protected virtuals;
// we are super classing into W31UpsDevice
 protected:

 private:
    virtual INT  Connect();
 protected:
    virtual INT     Retry();
    virtual INT     AskUps(PMessage msg);
    INT rebuildPort();
    INT sendRetryMessage();
    ULONG theRetryTimer;
    INT theForceCommEventFlag;
    enum cableTypes theCableType;

 public:
    UpsCommDevice(PCommController control);
    virtual ~UpsCommDevice();
    virtual INT Initialize();
    virtual INT CreatePort();
    virtual INT CreateProtocol();
    virtual INT Update(PEvent anEvent);
    VOID    DeviceThread();
    virtual INT Get(INT pid, PCHAR value);
    virtual INT Set(INT pid, const PCHAR value);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsmodl.h ===
/*
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *
 */
#ifndef UPSMODL_H
#define UPSMODL_H

#include "sensor.h"

_CLASSDEF(UpsModelSensor)
_CLASSDEF(FirmwareRevSensor)
_CLASSDEF(Device)

class UpsModelSensor : public Sensor {
   
public:
   UpsModelSensor(PDevice aParent, PCommController aCommController=NULL, 
     PFirmwareRevSensor aFirmwareRev=NULL);
   virtual INT IsA() const { return UPSMODELSENSOR; };
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsdev.cxx ===
/*
 *  pcy30Nov92 - Changed object.h to apcobj.h
 *  ane02DEC92 - fixed memory corruption problem by allocating more space to
 *               receive message from UPS
 *  sja09Dec92 - Will Work with windows now.
 *  sja10Dec92 - Allocates a proper Stream under windows now.
 *  pcy11Dec92 - Move Windows stuff out of here
 *  pcy14Dec92 - #include "cfgmgr.h"
 *  pcy14Dec92 - Fixed misplaced else due to comment
 *  pcy27Dec92: GlobalCommDevice can't be static
 *  jod29Dec92: Edited Retry();
 *  ane11Jan93: Edited Retry();
 *  jod13Jan93: Fixed Retry to add the NO_COMM event to the eventList
 *  ane25Jan93: Added extra error checking and returns on initialization
 *  jod28Jan93: Fixed the Data and Decrement Sets
 *  ane03Feb93: Changed error checking
 *  rct17May93: fixed include files
 *  cad10Jun93: Changes to allow MUps
 *  cad14Sep93: Cleaning up theState
 *  cad15Nov93: Changing how lost comm works
 *  cad17Nov93: .. more little fixups
 *  mwh19Nov93: changed EventID to INT
 *  rct21Dec93: fixed rebuild port - if the open fails, writes won't occur
 *  cad14Jan94: not including old global stuff
 *  rct21Dec93: fixed rebuildPort again - if the open fails, writes won't occur
 *  ajr08Mar94: added some error checking to rebuildPort.
 *  pcy10Mar94: Got rid of meaningless overides of Get and Set
 *  pcy08Apr94: Trim size, use static iterators, dead code removal
 *  pcy13Apr94: Use automatic variables decrease dynamic mem allocation
 *  cad17Jun94: Flushing UPS Input after retry succeeds, re-syncs conversation
 *  ajr12Jul94: The Flushing stuff broke BackUps.  sendRetryMessage() should
 *              return true for Backups
 *  cgm28Feb96: Add override switch for nlm
 *  cgm04May96: TestResponse now uses BufferSize
 *  poc28Sep96: Added valuable debugging code.
 *  tjg10Nov97: Cancel the RetryTimer on RETRY_CONSTRUCT
 */

#include "cdefine.h"

extern "C" {
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
}


#include "_defs.h"
#include "codes.h"
#include "apcobj.h"
#include "list.h"
#include "dispatch.h"
#include "comctrl.h"
#include "event.h"
#include "message.h"
#include "pollparm.h"
#include "ulinkdef.h"
#include "trans.h"
#include "protsmrt.h"
#include "cdevice.h"
#include "upsdev.h"
#include "cfgmgr.h"
#include "timerman.h"
#include "protlist.h"
#include "err.h"
#include "stream.h"

#if APCDEBUG
#include "errlogr.h"
#endif

#define UNKNOWN       0

#define RETRY_FAILED  1
#define RETRY_SUCCESS 0

#define ASKUPS_FAILED 1
#define ASKUPS_OK     0

#define RETRY_MAX     3

UpsCommDevice::UpsCommDevice(CommController* control)
    : CommDevice(control),
      theRetryTimer(0),
      theForceCommEventFlag(FALSE),
      theCableType(NORMAL)
{
    CreateProtocol();
}


UpsCommDevice::~UpsCommDevice()
{
   theController->UnregisterEvent(EXIT_THREAD_NOW, this);

    if(theRetryTimer)  {
	_theTimerManager->CancelTimer(theRetryTimer);
	theRetryTimer = 0;
    }
}


INT UpsCommDevice::Initialize()
{
   CHAR value[64], cable_type[10];

   _theConfigManager->Get(CFG_UPS_POLL_INTERVAL, value);

   thePollInterval = atoi(value);

   INT err = rebuildPort();

   if (err == ErrNO_ERROR)
      {
      Connect();
      }

   // Register here instead of in CommDevice::Initialize() - that method
   // does things with the port we don't want to

   theController->RegisterEvent(EXIT_THREAD_NOW, this);

   return err;
}


/*--------------------------------------------------------------------
*
*       Function...:   Connect
*
*       Description:   Opens the device and make a comm connection.
*
*-------------------------------------------------------------------*/
INT UpsCommDevice::Connect()
{
    if (!thePollThread) {
    StartPollThread();
    }
    return ErrNO_ERROR;
}

INT UpsCommDevice::Get(INT pid, PCHAR value)
{
    INT err = ErrNO_ERROR;

    switch(pid)  {
      case COMMUNICATION_STATE:
	sprintf(value, "%d", theLostCommFlag ?
		COMMUNICATION_LOST : COMMUNICATION_ESTABLISHED);
	break;

      default:
	err = CommDevice::Get(pid, value);
	break;
    }

    return err;
}



INT UpsCommDevice::Set(INT pid, const PCHAR value)
{
    INT err = ErrNO_ERROR;

    switch(pid)  {
      case RETRY_CONSTRUCT:
	
	if (theRetryTimer) {
	    _theTimerManager->CancelTimer(theRetryTimer);
	    theRetryTimer = 0;
	}
	theLostCommFlag = TRUE;
	theForceCommEventFlag = TRUE;

        _theTimerManager->Wait(2000L);   // Allow On-going Operations to Stop

	err = rebuildPort();
	break;
	
      default:
	err = CommDevice::Set(pid, value);
	break;
    }

    return err;
}



INT UpsCommDevice::sendRetryMessage()
{
  INT done = FALSE;

  if ( !(Set(TURN_ON_SMART_MODE, (CHAR*)NULL)) ) {
    done = TRUE;
  }
  CHAR buf[128];
  USHORT len = sizeof(buf);

  //
  // clearing out extra chars in the serial buffer
  //
  while (thePort->Read(buf, (USHORT *) &len, 500L) == ErrNO_ERROR);

  return done;
}

/*--------------------------------------------------------------------
*
*       Function...:   Retry
*
*       Description:   .
*
*-------------------------------------------------------------------*/
INT   UpsCommDevice::Retry()
{
    INT    index = 0;

    if(theState != RETRYING)  {
        theState = RETRYING;

        INT done = sendRetryMessage();

        if (!done)
        {
            theLostCommFlag = TRUE;
            Event event(COMMUNICATION_STATE, COMMUNICATION_LOST);
            event.SetAttributeValue(FAILURE_CAUSE, COMMUNICATION_LOST);
            theForceCommEventFlag = FALSE;
            UpdateObj::Update(&event);

            if (!theRetryTimer)
            {
                Event retry_event(RETRY_CONSTRUCT, RETRY_PORT);
                theRetryTimer =_theTimerManager->SetTheTimer((ULONG)2,
                    &retry_event,
                    this);
            }
            return RETRY_FAILED;
        }
        theState = NORMAL_STATE;
    }

    return RETRY_SUCCESS;
}


INT   UpsCommDevice::Update(PEvent anEvent)
{
   INT err = ErrNO_ERROR;

   switch(anEvent->GetCode())
      {
      case RETRY_CONSTRUCT:
	 theRetryTimer = 0;
	 err = rebuildPort();
	 break;

      case EXIT_THREAD_NOW:
	 _theTimerManager->CancelTimer(theRetryTimer);
	 theRetryTimer = 0;
	 err = CommDevice::Update(anEvent);
	 break;
      }

   return err;
}

INT UpsCommDevice::rebuildPort()
{
    if(thePort)
    {
        delete thePort;
        thePort = (PStream)NULL;
    }


    INT err = CreatePort();
    if (thePort) {
        err = thePort->Initialize();  // don't reset this value !!!
    }

    INT have_comm = FALSE;

    if (err == ErrNO_ERROR)
    {
        have_comm = sendRetryMessage();
    }

    if (!have_comm) {
      // Toggle the cable type
      if (theCableType == NORMAL) {
        theCableType = PNP;
      }
      else {
        theCableType = NORMAL;
      }
    }

    if (have_comm)
    {
        theState = NORMAL_STATE;
        theLostCommFlag = FALSE;

        Event event(COMMUNICATION_STATE, COMMUNICATION_ESTABLISHED);
        UpdateObj::Update(&event);

        if (theCurrentTransaction == (PTransactionGroup)NULL)
        {
            theCurrentTransaction = (PTransactionGroup) thePollList->GetHead();
        }
    }
    else
    {
        if (!theLostCommFlag || theForceCommEventFlag)
        {
            if (!theLostCommFlag)
            {
                theState = COMM_STOPPED;
                theLostCommFlag = TRUE;
            }

            theForceCommEventFlag = FALSE;
            Event event(COMMUNICATION_STATE, COMMUNICATION_LOST);
            UpdateObj::Update(&event);
        }

        if ((!theRetryTimer) && (err == ErrNO_ERROR))
        {
            Event retry_event(RETRY_CONSTRUCT, RETRY_PORT);
            theRetryTimer =_theTimerManager->SetTheTimer((ULONG)5, &retry_event,
                this);
        }

    }

    return err;
}


/*--------------------------------------------------------------------
*
*       Function...:   AskUps
*
*       Description:   .
*
*-------------------------------------------------------------------*/
INT   UpsCommDevice::AskUps(Message* msg)
{
    CHAR    Buffer[512];
    USHORT  BufferSize = 0;
    INT writecomplete   = FALSE;
    INT ret = ErrNO_ERROR;

    //
    // Clean out old errors
    //
    msg->setErrcode(ErrNO_ERROR);

    if (!thePort)
    {
        return ret;
    }

    if (theAbortSem) {
        theAbortSem->TimedWait(250);
    }

    while (!writecomplete) {
        thePort->SetRequestCode(msg->getId());
        thePort->SetWaitTime(msg->getWaitTime());
        ret = thePort->Write(msg->getSubmit());
        if (ret == ErrWRITE_FAILED)
        {
            if (!theLostCommFlag && Retry() )/*  If RETY FAILED  */
            {
                msg->setErrcode(ErrCOMMUNICATION_LOST);


                return ASKUPS_OK;   /*  Return Ok-- Let */
            }                       /*  UPS do RESTART  */
            else
            {
                msg->setErrcode(ErrWRITE_FAILED);


                return ASKUPS_FAILED;
            }
        }
        else
            writecomplete = TRUE;
    }

    *Buffer = 0;
    BufferSize   = 511;
    INT readcomplete = FALSE;
    ret          = 0;


    while (!readcomplete) {
        int testRet;

        ret = thePort->Read(Buffer, &BufferSize, (ULONG)msg->getTimeout());

        if ((ret == ErrREAD_FAILED) && (testRet = theProtocol->TestResponse(msg,Buffer,BufferSize)) )
        {
            if (testRet == ErrNO_MEASURE_UPS)
            {
                msg->setErrcode(testRet);


                return ASKUPS_OK;
            }
            else
            {
                if ( Retry() )
                {               /*  If RETRY FAILED  */
                    msg->setErrcode(ErrCOMMUNICATION_LOST);


                    return ASKUPS_OK;/*  Return Ok-- Let */
                }               /*  UPS do RESTART  */
                else
                {
                    msg->setErrcode(ErrREAD_FAILED);


                    return ASKUPS_FAILED;
                }
            }
        }
        else
        {
            readcomplete = TRUE;
        }
    }
    Buffer[BufferSize] = '\0';

    msg->setResponse(Buffer);


    return ASKUPS_OK;
}

INT  UpsCommDevice::CreateProtocol()
{
    CHAR signal_type[64];
    _theConfigManager->Get(CFG_UPS_SIGNALLING_TYPE, signal_type);

      if(strcmp((_strupr(signal_type)), "SIMPLE") == 0)  {
	    theProtocol = new SimpleUpsProtocol();
        }
    else  {
	CHAR protocol[32];
	_theConfigManager->Get(CFG_UPS_PROTOCOL, protocol);
	if(strcmp((_strupr(protocol)), "UPSLINK") == 0)  {
	    theProtocol = new UpsLinkProtocol();
	}
	else if(strcmp((_strupr(protocol)), "GCIP") == 0)  {
	    //       theProtocol = new GcipProtocol();
	}
	else  {
	    theProtocol = new SimpleUpsProtocol();
	}
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsmodl.cxx ===
/*
 *  poc25Jun96: Needed stdlib.h for AIX 4.x
 *  djs05Nov96: Added check for 2G units to stop excessive waiting
 *  mholly24Sep98   : increased the buffer size for UPS_NAME to 64 from 32
 *                  the ^A command can return values up to 32 characters long
 *                  +1 for the NULL character - set it to 64 to allow room
 */

#include "cdefine.h"

extern "C" {
#if ((C_OS & C_AIX) && (C_AIX_VERSION & C_AIX4))
#include <stdlib.h>
#endif
}

#include <malloc.h>

#include "cfgmgr.h"
#include "upsmodl.h"
#include "firmrevs.h"


UpsModelSensor :: UpsModelSensor(PDevice aParent, PCommController 
     aCommController, PFirmwareRevSensor aFirmwareRev)
			: Sensor(aParent, aCommController, UPS_MODEL_NAME)
{
    // Try to get UPS name from the UPS itself.  If not supported, get UPS 
    // name from firmware revision


   // This is not the cleanest solution around but.....
   // If a 2G unit is asked to supply the ups model name, the delay
   // can be as long as 10 seconds.
 
    CHAR firmware_rev[32];
    aFirmwareRev->Get(IS_THIRD_GEN, firmware_rev);
    if (_strcmpi(firmware_rev, "yes")==0){
      DeepGet();
    }
 
    if (!theValue || strlen(theValue) == 0) {
        // Allocate enough memory for the UPS name
        // This memory is released by the sensor destructor
 
        theValue  = (char*) malloc(64);
        aFirmwareRev->Get(UPS_NAME,theValue);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsmsgs.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: IDMSG_UNKNOWN_EVENT_CODE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UNKNOWN_EVENT_CODE         ((DWORD)0x80FF0000L)

//
// MessageId: IDMSG_UPS_SERVICE_STOPPED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SERVICE_STOPPED        ((DWORD)0x40FF03E8L)

//
// MessageId: IDMSG_UPS_SERVICE_STARTED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SERVICE_STARTED        ((DWORD)0x40FF03E9L)

//
// MessageId: IDMSG_COMM_ESTABLISHED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_COMM_ESTABLISHED           ((DWORD)0x40FF03EAL)

//
// MessageId: IDMSG_UPS_COMM_STATE_LOST
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_COMM_STATE_LOST        ((DWORD)0x80FF03EBL)

//
// MessageId: IDMSG_COMM_LOST_ON_BATTERY
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_COMM_LOST_ON_BATTERY       ((DWORD)0x80FF03ECL)

//
// MessageId: IDMSG_UPS_CLIENT_COMM_LOST
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_CLIENT_COMM_LOST       ((DWORD)0x80FF03EDL)

//
// MessageId: IDMSG_COMM_STATE_ESTABLISHED_MASTER
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_COMM_STATE_ESTABLISHED_MASTER ((DWORD)0x40FF03F2L)

//
// MessageId: IDMSG_COMM_STATE_ESTABLISHED_SLAVE
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_COMM_STATE_ESTABLISHED_SLAVE ((DWORD)0x40FF03F3L)

//
// MessageId: IDMSG_UPS_RUN_TIME_INRANGE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_RUN_TIME_INRANGE       ((DWORD)0x40FF041AL)

//
// MessageId: IDMSG_UPS_RUN_EXPIRED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_RUN_EXPIRED            ((DWORD)0x80FF0424L)

//
// MessageId: IDMSG_UPS_RUN_TIME_LOW
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_RUN_TIME_LOW           ((DWORD)0x40FF0425L)

//
// MessageId: IDMSG_RUNTIME_LOW
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_RUNTIME_LOW                ((DWORD)0x40FF0426L)

//
// MessageId: IDMSG_UPS_BOOST_ON
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BOOST_ON               ((DWORD)0x40FF044CL)

//
// MessageId: IDMSG_UPS_TRIM_ON
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_TRIM_ON                ((DWORD)0x40FF044DL)

//
// MessageId: IDMSG_UPS_BATTERIES_OK
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATTERIES_OK           ((DWORD)0x40FF0456L)

//
// MessageId: IDMSG_UPS_BATTERY_COND_DIS
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATTERY_COND_DIS       ((DWORD)0x80FF0460L)

//
// MessageId: IDMSG_UPS_BATTERY_COND_RETURN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATTERY_COND_RETURN    ((DWORD)0x40FF0461L)

//
// MessageId: IDMSG_LOW_BATTERY
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_LOW_BATTERY                ((DWORD)0x80FF046AL)

//
// MessageId: IDMSG_UPS_BATTERY_REPLACE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATTERY_REPLACE        ((DWORD)0x40FF046BL)

//
// MessageId: IDMSG_UPS_BATTERY_COND_LOW_CAP
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATTERY_COND_LOW_CAP   ((DWORD)0x80FF0474L)

//
// MessageId: IDMSG_UPS_BATTERY_COND_DIS_CAP
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATTERY_COND_DIS_CAP   ((DWORD)0x80FF0475L)

//
// MessageId: IDMSG_UPS_BATTERY_COND_RETURN_CAP
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATTERY_COND_RETURN_CAP ((DWORD)0x40FF0476L)

//
// MessageId: IDMSG_UPS_UTIL_LINE_GOOD
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_GOOD         ((DWORD)0x40FF047EL)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD          ((DWORD)0x40FF0488L)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD_HIGH
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD_HIGH     ((DWORD)0x80FF0489L)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD_BLACK
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD_BLACK    ((DWORD)0x80FF048AL)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD_BROWN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD_BROWN    ((DWORD)0x80FF048BL)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD_SMALL_SAG
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD_SMALL_SAG ((DWORD)0x40FF048CL)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD_DEEP_SAG
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD_DEEP_SAG ((DWORD)0x80FF048DL)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD_SMALL_SPIKE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD_SMALL_SPIKE ((DWORD)0x40FF048EL)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD_LARGE_SPIKE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD_LARGE_SPIKE ((DWORD)0x80FF048FL)

//
// MessageId: IDMSG_UPS_UTIL_LINE_BAD_SIMULATED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_UTIL_LINE_BAD_SIMULATED ((DWORD)0x80FF0490L)

//
// MessageId: IDMSG_UPS_BATT_CAL_PROG
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATT_CAL_PROG          ((DWORD)0x40FF04B0L)

//
// MessageId: IDMSG_UPS_NO_BATT_CAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_NO_BATT_CAL            ((DWORD)0x40FF04B1L)

//
// MessageId: IDMSG_UPS_BATT_CAL_CAN_USER
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATT_CAL_CAN_USER      ((DWORD)0x40FF04B2L)

//
// MessageId: IDMSG_UPS_BATT_CAL_CAN_POW
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATT_CAL_CAN_POW       ((DWORD)0x40FF04B3L)

//
// MessageId: IDMSG_UPS_BATT_CAL_CAN_LOW
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATT_CAL_CAN_LOW       ((DWORD)0x40FF04B4L)

//
// MessageId: IDMSG_UPS_BATT_CAL_CAN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_BATT_CAL_CAN           ((DWORD)0x80FF04B5L)

//
// MessageId: IDMSG_UPS_SELF_TEST_PASS
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_PASS         ((DWORD)0x40FF04E2L)

//
// MessageId: IDMSG_UPS_SELF_TEST_PASS_USER
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_PASS_USER    ((DWORD)0x40FF04E3L)

//
// MessageId: IDMSG_UPS_SELF_TEST_PASS_SCHEDULE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_PASS_SCHEDULE ((DWORD)0x40FF04E4L)

//
// MessageId: IDMSG_UPS_SELF_TEST_PASS_UNKNOWN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_PASS_UNKNOWN ((DWORD)0x40FF04E5L)

//
// MessageId: IDMSG_UPS_SELF_TEST_FAIL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_FAIL         ((DWORD)0x80FF04ECL)

//
// MessageId: IDMSG_UPS_SELF_TEST_FAIL_USER
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_FAIL_USER    ((DWORD)0x80FF04EDL)

//
// MessageId: IDMSG_UPS_SELF_TEST_FAIL_SCHEDULE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_FAIL_SCHEDULE ((DWORD)0x80FF04EEL)

//
// MessageId: IDMSG_UPS_SELF_TEST_FAIL_UNKNOWN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_FAIL_UNKNOWN ((DWORD)0x80FF04EFL)

//
// MessageId: IDMSG_UPS_SELF_TEST_INV_USER
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_INV_USER     ((DWORD)0x80FF04F7L)

//
// MessageId: IDMSG_UPS_SELF_TEST_INV_SCHEDULE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_INV_SCHEDULE ((DWORD)0x80FF04F8L)

//
// MessageId: IDMSG_UPS_SELF_TEST_INV_UNKNOWN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SELF_TEST_INV_UNKNOWN  ((DWORD)0x80FF04F9L)

//
// MessageId: IDMSG_UPS_SHUTDOWN_PROG
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_PROG          ((DWORD)0x80FF0514L)

//
// MessageId: IDMSG_UPS_SHUTDOWN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN               ((DWORD)0x40FF0515L)

//
// MessageId: IDMSG_UPS_SHUTDOWN_DAILY
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_DAILY         ((DWORD)0x40FF0516L)

//
// MessageId: IDMSG_UPS_SHUTDOWN_WEEK
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_WEEK          ((DWORD)0x40FF0517L)

//
// MessageId: IDMSG_UPS_SHUTDOWN_USER
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_USER          ((DWORD)0x40FF0518L)

//
// MessageId: IDMSG_UPS_SHUTDOWN_RUN_TIME
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_RUN_TIME      ((DWORD)0x80FF0519L)

//
// MessageId: IDMSG_UPS_SHUTDOWN_LOW_BATTERY
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_LOW_BATTERY   ((DWORD)0x80FF051AL)

//
// MessageId: IDMSG_UPS_SHUTDOWN_CANCEL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_CANCEL        ((DWORD)0x40FF051EL)

//
// MessageId: IDMSG_UPS_SHUTDOWN_USER_CANCEL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_USER_CANCEL   ((DWORD)0x40FF051FL)

//
// MessageId: IDMSG_UPS_SHUTDOWN_DAILY_CANCEL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_DAILY_CANCEL  ((DWORD)0x40FF0520L)

//
// MessageId: IDMSG_UPS_SHUTDOWN_WEEK_CANCEL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SHUTDOWN_WEEK_CANCEL   ((DWORD)0x40FF0521L)

//
// MessageId: IDMSG_STARTED_SHUTDOWN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_STARTED_SHUTDOWN           ((DWORD)0x40FF0528L)

//
// MessageId: IDMSG_STARTED_SHUTDOWN_USER
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_STARTED_SHUTDOWN_USER      ((DWORD)0x40FF0529L)

//
// MessageId: IDMSG_STARTED_SHUTDOWN_DAILY
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_STARTED_SHUTDOWN_DAILY     ((DWORD)0x40FF052AL)

//
// MessageId: IDMSG_STARTED_SHUTDOWN_WEEKLY
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_STARTED_SHUTDOWN_WEEKLY    ((DWORD)0x40FF052BL)

//
// MessageId: IDMSG_UPS_SHUTDOWN_FAULT
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_UPS_SHUTDOWN_FAULT         ((DWORD)0x40FF0532L)

//
// MessageId: IDMSG_NOT_ON_BYPASS
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_NOT_ON_BYPASS              ((DWORD)0x40FF0546L)

//
// MessageId: IDMSG_BYPASS_TEMP
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_BYPASS_TEMP                ((DWORD)0x40FF0550L)

//
// MessageId: IDMSG_BYPASS_CHARGER
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_BYPASS_CHARGER             ((DWORD)0x40FF0551L)

//
// MessageId: IDMSG_BYPASS_DCIMBALANCE
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_BYPASS_DCIMBALANCE         ((DWORD)0x40FF0552L)

//
// MessageId: IDMSG_BYPASS_VOLTAGE
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_BYPASS_VOLTAGE             ((DWORD)0x40FF0553L)

//
// MessageId: IDMSG_BYPASS_FAN
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_BYPASS_FAN                 ((DWORD)0x40FF0554L)

//
// MessageId: IDMSG_BYPASS_SOFTWARE
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_BYPASS_SOFTWARE            ((DWORD)0x40FF0555L)

//
// MessageId: IDMSG_BYPASS_SWITCH
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_BYPASS_SWITCH              ((DWORD)0x40FF0556L)

//
// MessageId: IDMSG_CONTACT1_NORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_CONTACT1_NORMAL            ((DWORD)0x40FF0579L)

//
// MessageId: IDMSG_CONTACT2_NORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_CONTACT2_NORMAL            ((DWORD)0x40FF057AL)

//
// MessageId: IDMSG_CONTACT3_NORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_CONTACT3_NORMAL            ((DWORD)0x40FF057BL)

//
// MessageId: IDMSG_CONTACT4_NORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_CONTACT4_NORMAL            ((DWORD)0x40FF057CL)

//
// MessageId: IDMSG_CONTACT1_ABNORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_CONTACT1_ABNORMAL          ((DWORD)0x40FF0583L)

//
// MessageId: IDMSG_CONTACT2_ABNORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_CONTACT2_ABNORMAL          ((DWORD)0x40FF0584L)

//
// MessageId: IDMSG_CONTACT3_ABNORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_CONTACT3_ABNORMAL          ((DWORD)0x40FF0585L)

//
// MessageId: IDMSG_CONTACT4_ABNORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_CONTACT4_ABNORMAL          ((DWORD)0x40FF0586L)

//
// MessageId: IDMSG_UPS_CONTACT_NORMAL
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_CONTACT_NORMAL         ((DWORD)0x40FF058CL)

//
// MessageId: IDMSG_UPS_CONTACT_FAULT
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_CONTACT_FAULT          ((DWORD)0x80FF058DL)

//
// MessageId: IDMSG_AMB_TEMP_IN_RANGE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_AMB_TEMP_IN_RANGE          ((DWORD)0x40FF05AAL)

//
// MessageId: IDMSG_AMB_TEMP_LOW
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_AMB_TEMP_LOW               ((DWORD)0x80FF05ABL)

//
// MessageId: IDMSG_AMB_TEMP_HIGH
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_AMB_TEMP_HIGH              ((DWORD)0x80FF05ACL)

//
// MessageId: IDMSG_AMB_HUMID_IN_RANGE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_AMB_HUMID_IN_RANGE         ((DWORD)0x40FF05B4L)

//
// MessageId: IDMSG_AMB_HUMID_LOW
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_AMB_HUMID_LOW              ((DWORD)0x80FF05B5L)

//
// MessageId: IDMSG_AMB_HUMID_HIGH
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_AMB_HUMID_HIGH             ((DWORD)0x80FF05B6L)

//
// MessageId: IDMSG_MINIMUM_REDUNDANCY_LOST
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_MINIMUM_REDUNDANCY_LOST    ((DWORD)0x80FF05DCL)

//
// MessageId: IDMSG_MINIMUM_REDUNDANCY_GAINED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_MINIMUM_REDUNDANCY_GAINED  ((DWORD)0x40FF05DDL)

//
// MessageId: IDMSG_UPS_MODULE_ADDED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_MODULE_ADDED           ((DWORD)0x40FF05E6L)

//
// MessageId: IDMSG_UPS_MODULE_REMOVED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_MODULE_REMOVED         ((DWORD)0x40FF05E7L)

//
// MessageId: IDMSG_UPS_MODULE_FAILED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_MODULE_FAILED          ((DWORD)0x80FF05E8L)

//
// MessageId: IDMSG_BATTERY_ADDED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_BATTERY_ADDED              ((DWORD)0x40FF05F0L)

//
// MessageId: IDMSG_BATTERY_REMOVED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_BATTERY_REMOVED            ((DWORD)0x40FF05F1L)

//
// MessageId: IDMSG_IM_OK
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_IM_OK                      ((DWORD)0x40FF05FAL)

//
// MessageId: IDMSG_IM_ADDED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_IM_ADDED                   ((DWORD)0x40FF05FBL)

//
// MessageId: IDMSG_IM_REMOVED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_IM_REMOVED                 ((DWORD)0x40FF05FCL)

//
// MessageId: IDMSG_IM_FAILED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_IM_FAILED                  ((DWORD)0x80FF05FDL)

//
// MessageId: IDMSG_RIM_OK
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_RIM_OK                     ((DWORD)0x40FF0604L)

//
// MessageId: IDMSG_RIM_ADDED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_RIM_ADDED                  ((DWORD)0x40FF0605L)

//
// MessageId: IDMSG_RIM_REMOVED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_RIM_REMOVED                ((DWORD)0x40FF0606L)

//
// MessageId: IDMSG_RIM_FAILED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_RIM_FAILED                 ((DWORD)0x80FF0607L)

//
// MessageId: IDMSG_SYSTEM_FAN_FAILED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_SYSTEM_FAN_FAILED          ((DWORD)0x80FF060EL)

//
// MessageId: IDMSG_SYSTEM_FAN_OK
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_SYSTEM_FAN_OK              ((DWORD)0x40FF060FL)

//
// MessageId: IDMSG_BYPASS_CONTRACTOR_OK
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_BYPASS_CONTRACTOR_OK       ((DWORD)0x40FF0618L)

//
// MessageId: IDMSG_BYPASS_CONTRACTOR_FAILED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_BYPASS_CONTRACTOR_FAILED   ((DWORD)0x80FF0619L)

//
// MessageId: IDMSG_BREAKER_OPEN
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_BREAKER_OPEN               ((DWORD)0x40FF0622L)

//
// MessageId: IDMSG_BREAKER_CLOSED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_BREAKER_CLOSED             ((DWORD)0x40FF0623L)

//
// MessageId: IDMSG_UPS_NO_OVERLOAD_COND
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_NO_OVERLOAD_COND       ((DWORD)0x40FF07D0L)

//
// MessageId: IDMSG_UPS_OVERLOAD_COND
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_OVERLOAD_COND          ((DWORD)0x80FF07D1L)

//
// MessageId: IDMSG_UPS_NO_ABNORMAL_COND
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_NO_ABNORMAL_COND       ((DWORD)0x40FF07DAL)

//
// MessageId: IDMSG_UPS_ABNORMAL_COND
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_ABNORMAL_COND          ((DWORD)0x80FF07DBL)

//
// MessageId: IDMSG_UPS_SLAVE_REG
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SLAVE_REG              ((DWORD)0x40FF07E4L)

//
// MessageId: IDMSG_UPS_SLAVE_UNREG
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_SLAVE_UNREG            ((DWORD)0x40FF07E5L)

//
// MessageId: IDMSG_SMART_CELL_SIGNAL_RESTORED
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_SMART_CELL_SIGNAL_RESTORED ((DWORD)0x40FF07EEL)

//
// MessageId: IDMSG_CHECK_SMART_CELL_CABLE
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_CHECK_SMART_CELL_CABLE     ((DWORD)0x40FF07EFL)

//
// MessageId: IDMSG_PWRSUPPLY_BAD
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_PWRSUPPLY_BAD              ((DWORD)0x40FF07F8L)

//
// MessageId: IDMSG_BASE_FAN_BAD
//
// MessageText:
//
//  %l!s!
//
#define IDMSG_BASE_FAN_BAD               ((DWORD)0x40FF07F9L)

//
// MessageId: IDMSG_UPS_INTERNAL_TEMP_IN_RANGE
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_INTERNAL_TEMP_IN_RANGE ((DWORD)0x40FF0802L)

//
// MessageId: IDMSG_UPS_MAX_INTERNAL_TEMP
//
// MessageText:
//
//  %1!s!
//
#define IDMSG_UPS_MAX_INTERNAL_TEMP      ((DWORD)0x80FF0803L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ups.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsreg.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSREG.H
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
********************************************************************************/

// This file contains declarations that support accessing
// registry data passed between the UPS service and the
// UPS UI.


#ifndef _UPSREG_H_
#define _UPSREG_H_

#ifdef __cplusplus
extern "C" {
#endif

LONG getStringValue(struct _reg_entry *aRegEntry, LPTSTR aBuffer); 
LONG getDwordValue(struct _reg_entry *aRegEntry, LPDWORD aValue); 

/* 
 * Public Config function declarations
 */
LONG GetUPSConfigVendor( LPTSTR aBuffer);
LONG GetUPSConfigModel( LPTSTR aBuffer);
LONG GetUPSConfigPort( LPTSTR aBuffer);
LONG GetUPSConfigOptions( LPDWORD aValue);
LONG GetUPSConfigShutdownWait( LPDWORD aValue);			
LONG GetUPSConfigFirstMessageDelay( LPDWORD aValue);			
LONG GetUPSConfigMessageInterval( LPDWORD aValue);	
LONG GetUPSConfigServiceDLL( LPTSTR aBuffer);
LONG GetUPSConfigNotifyEnable( LPDWORD aValue);
LONG GetUPSConfigShutdownOnBatteryEnable( LPDWORD aValue);
LONG GetUPSConfigShutdownOnBatteryWait( LPDWORD aValue);
LONG GetUPSConfigRunTaskEnable( LPDWORD aValue);
LONG GetUPSConfigTaskName( LPTSTR aBuffer);
LONG GetUPSConfigTurnOffEnable( LPDWORD aValue);
LONG GetUPSConfigAPCLinkURL( LPTSTR aBuffer);
LONG GetUPSConfigUpgrade( LPDWORD aValue);
LONG GetUPSConfigCustomOptions( LPDWORD aValue);
LONG GetUPSConfigCriticalPowerAction( LPDWORD aValue);
LONG GetUPSConfigTurnOffWait( LPDWORD aValue);
LONG GetUPSConfigImagePath( LPTSTR aBuffer);
LONG GetUPSConfigObjectName( LPTSTR aBuffer);
LONG GetUPSConfigShowUPSTab( LPDWORD aValue);
LONG GetUPSConfigErrorControl( LPDWORD aValue);
LONG GetUPSConfigStart( LPDWORD aValue);
LONG GetUPSConfigType( LPDWORD aValue);

LONG SetUPSConfigVendor( LPCTSTR aBuffer);
LONG SetUPSConfigModel( LPCTSTR aBuffer);
LONG SetUPSConfigPort( LPCTSTR aBuffer);
LONG SetUPSConfigOptions( DWORD aValue);
LONG SetUPSConfigShutdownWait( DWORD aValue);			
LONG SetUPSConfigFirstMessageDelay( DWORD aValue);			
LONG SetUPSConfigMessageInterval( DWORD aValue);		
LONG SetUPSConfigServiceDLL( LPCTSTR aBuffer);
LONG SetUPSConfigNotifyEnable( DWORD aValue);
LONG SetUPSConfigShutdownOnBatteryEnable( DWORD aValue); 
LONG SetUPSConfigShutdownOnBatteryWait( DWORD aValue);
LONG SetUPSConfigRunTaskEnable( DWORD aValue);
LONG SetUPSConfigTaskName( LPCTSTR aBuffer);
LONG SetUPSConfigTurnOffEnable( DWORD aValue);
LONG SetUPSConfigAPCLinkURL( LPCTSTR aBuffer);
LONG SetUPSConfigUpgrade( DWORD aValue);
LONG SetUPSConfigCustomOptions( DWORD aValue);
LONG SetUPSConfigCriticalPowerAction( DWORD aValue);
LONG SetUPSConfigTurnOffWait( DWORD aValue);
LONG SetUPSConfigImagePath( LPCTSTR aBuffer);
LONG SetUPSConfigObjectName( LPCTSTR aBuffer);
LONG SetUPSConfigShowUPSTab( DWORD aValue);
LONG SetUPSConfigErrorControl( DWORD aValue);
LONG SetUPSConfigStart( DWORD aValue);
LONG SetUPSConfigType( DWORD aValue);

/*
 * Public Status function declarations
 */
LONG GetUPSStatusSerialNum( LPTSTR aBuffer);
LONG GetUPSStatusFirmRev( LPTSTR aBuffer);
LONG GetUPSStatusUtilityStatus( LPDWORD aValue);
LONG GetUPSStatusRuntime( LPDWORD aValue);
LONG GetUPSStatusBatteryStatus( LPDWORD aValue);
LONG GetUPSStatusCommStatus( LPDWORD aValue);
LONG GetUPSStatusBatteryCapacity( LPDWORD aValue);

LONG SetUPSStatusSerialNum( LPCTSTR aBuffer);
LONG SetUPSStatusFirmRev( LPCTSTR aBuffer);
LONG SetUPSStatusUtilityStatus( DWORD aValue);
LONG SetUPSStatusRuntime( DWORD aValue);
LONG SetUPSStatusBatteryStatus( DWORD aValue);
LONG SetUPSStatusCommStatus( DWORD aValue);
LONG SetUPSStatusBatteryCapacity( DWORD aValue);

/*
 * Public Reg Entry function declarations
 */
void InitUPSConfigBlock();
void InitUPSStatusBlock();
void RestoreUPSConfigBlock();
void RestoreUPSStatusBlock();
void SaveUPSConfigBlock(BOOL forceAll);
void SaveUPSStatusBlock(BOOL forceAll);
void FreeUPSConfigBlock();
void FreeUPSStatusBlock();

/*
 * Reg entry path string declarations
 */
#define UPS_DEFAULT_ROOT _T("SYSTEM\\CurrentControlSet\\Services\\UPS")
#define UPS_STATUS_ROOT  _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\Status")
#define UPS_CONFIG_ROOT  _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")
#define UPS_SERVICE_ROOT _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders")
#define UPS_PORT_ROOT    _T("HARDWARE\\DEVICEMAP\\SERIALCOMM")

#define UPS_UTILITYPOWER_UNKNOWN 0
#define UPS_UTILITYPOWER_ON      1
#define UPS_UTILITYPOWER_OFF     2

#define UPS_BATTERYSTATUS_UNKNOWN 0
#define UPS_BATTERYSTATUS_GOOD    1
#define UPS_BATTERYSTATUS_REPLACE 2

#define UPS_COMMSTATUS_UNKNOWN 0
#define UPS_COMMSTATUS_OK      1
#define UPS_COMMSTATUS_LOST    2

// Defines the values for the 'Options' bitmask registry key
#define UPS_INSTALLED               0x00000001
#define UPS_POWERFAILSIGNAL         0x00000002
#define UPS_LOWBATTERYSIGNAL        0x00000004
#define UPS_SHUTOFFSIGNAL           0x00000008
#define UPS_POSSIGONPOWERFAIL       0x00000010
#define UPS_POSSIGONLOWBATTERY      0x00000020
#define UPS_POSSIGSHUTOFF           0x00000040
#define UPS_RUNCMDFILE              0x00000080

#define UPS_DEFAULT_SIGMASK			0x0000007f
#define DEFAULT_CONFIG_IMAGEPATH    TEXT("%SystemRoot%\\System32\\ups.exe")

// Min / Max / Default values for  FirstMessageDelay (seconds)
#define WAITSECONDSFIRSTVAL				0
#define WAITSECONDSLASTVAL				120
#define WAITSECONDSDEFAULT				5

// Min / Max / Default values for  MessageInterval (seconds)
#define REPEATSECONDSFIRSTVAL			5
#define REPEATSECONDSLASTVAL			300
#define REPEATSECONDSDEFAULT			120

// Min / Max / Default values for  ShutdownOnBatteryWait (minutes)
#define SHUTDOWNTIMERMINUTESFIRSTVAL	2
#define SHUTDOWNTIMERMINUTESLASTVAL		720
#define SHUTDOWNTIMERMINUTESDEFAULT     2

// Shutdown behavior values
#define UPS_SHUTDOWN_SHUTDOWN   0
#define UPS_SHUTDOWN_HIBERNATE  1

/** ServiceProvider structure.  The structure defines the entries in the
*  ServiceProviders registry key.
*/
typedef struct {
LPTSTR  theVendorKey;		  // Vendor registry subkey
LPTSTR  theModelName;     // UPS model name
LPTSTR  theValue;         // UPS value data
} ServiceProviderStructure;


/**
* InitializeRegistry
*
* Description:
*   This function initiates the registry for the UPS service and the 
*   configuration application.  When called, this function examines 
*   the registry to determine if it needs to be initalized.  If the key
*   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\UPS\Config\ServiceProviderDLL
*   is present, the registry is assumed to be initialized and no initialization
*   is done.  If the key is not present the following Keys are updated:
*        Status
*        Config
*        ServiceProviders
*
*   The values for the ServiceProviders key is supplied in the regdefs.h
*   header file.
*
* Parameters:
*   none
*
* Returns:
*   TRUE if able to open registry keys with write access.
*/
BOOL InitializeRegistry();


///////////////
// upsdefines.h
#ifndef _ASSERT
#define _ASSERT(x) 
#endif

#define DIMENSION_OF(array) (sizeof(array)/sizeof(array[0]))

//This value is used in most of the text buffers in various places throughout
//the application.
#define MAX_MESSAGE_LENGTH      1024

//The following three strings are the registry value names where all
//the UPS data is stored. These values are used in the RegField array
//in datacces.c
#define UPS_KEY_NAME    TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS")
#define STATUS_KEY_NAME TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Status")
#define CONFIG_KEY_NAME TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")

//The following values are used in the DialogAssociations arrays in updatdlg.c
//and upsinfo.c
#define RESOURCE_FIXED     0
#define RESOURCE_INCREMENT 1
#define REG_ANY_DWORD_TYPE (REG_DWORD | REG_DWORD_BIG_ENDIAN | REG_DWORD_LITTLE_ENDIAN)

//This is a helper macro to help form a DialogAssociations array members.
#define MAKE_ARRAY(stub, insertID, indexID, stringType, indexMax, regAccessType, shallowAccessPtr, regEntryPtr)\
  { eREG_##stub, IDC_##stub##_LHS, IDC_##stub, insertID, indexID, stringType, indexMax, regAccessType, shallowAccessPtr, regEntryPtr }

//The following are all the registry values supported by the application.
//The amount and values to these enums correspond to the size of the array
//g_upsRegFields
typedef enum _tUPSDataItemID { eREG_VENDOR_NAME = 0,
                               eREG_MODEL_TYPE,
                               eREG_SERIAL_NUMBER,
                               eREG_FIRMWARE_REVISION,
                               eREG_POWER_SOURCE,
                               eREG_RUNTIME_REMAINING,
							   eREG_BATTERY_CAPACITY,
                               eREG_BATTERY_STATUS,
                               eREG_UPS_OPTIONS,
                               eREG_SERVICE_PROVIDER_DLL,
                               eREG_SHUTDOWN_ON_BATTERY_ENABLE,
                               eREG_SHUTDOWN_ON_BATTERY_WAIT,
                               eREG_TURN_UPS_OFF_ENABLE,
                               eREG_APC_LINKURL,
                               eREG_UPGRADE_ENABLE,
                               eREG_COMM_STATUS,
                               eREG_PORT } tUPSDataItemID;

//This enum is used in DialogAssociations below. This defines the
//type of registry query to perform when reading registry values.
//There are only two options, to perform a deep get, that is, go
//right to the registry every time, re-reading it from the registry, or to
//use the regfunc buffer value (shallow get).
typedef enum _tRegAccessType { eDeepGet = 0,
                               eShallowGet } tRegAccessType;

//This struct links the registry field and the dialog controls.
typedef struct _DialogAssociations {
  const tUPSDataItemID theFieldTypeID;              //the eREG_... id. This is used to read the
                                                    //registry data.
  DWORD                theStaticFieldID;            //A control id (usually for a static control). This
                                                    //is the left-hand side control. For example, in the
                                                    //on-screen text "Model Type: Back-UPS Pro" there are
                                                    //actually two controls the left-hand side (LHS) is
                                                    //"Model Type:" and the right-hand side is "Back-UPS Pro".
                                                    //These controls are separated as the LHS's behavior is
                                                    //different to the RHS when no data is present.
  DWORD                theDisplayControlID;         //A control id (usually an edit field or a static)
  DWORD                theResourceInsertID;         //The id of the string resource to insert the value into
                                                    //If the registry value is a DWORD then
                                                    //the insertion point should be %n!lu!, if
                                                    //it's a string then the insertion point can be just %n
  DWORD                theResourceIndexID;          //This is only relevant if theResourceStringType is
                                                    //of type RESOURCE_INCREMENT. This identifies the id
                                                    //of the string when the value read for this item is 0,
                                                    //it is assumed that the other string values are stored
                                                    //consequtively in the string table following this value.
                                                    //For an example see below.
  DWORD                theResourceStringType;       //This can be RESOURCE_FIXED or RESOURCE_INCREMENT.
                                                    //RESOURCE_FIXED means that the value needs no special
                                                    //handling. Simple insert the value into the string
                                                    //identified by theResourceInsertID. If it's equal to
                                                    //RESOURCE_INCREMENT then the string inserted is determined
                                                    //by reading the value from the registry (say it's equal
                                                    //to 1). The theResourceIndexID indentifies the id of the
                                                    //string resource corresponding to a value. A value of 1
                                                    //gives up the string with id theResourceIndexID + 1. This
                                                    //string is loaded and inserted into the string identified
                                                    //by theResourceInsertID.
  DWORD                theResourceIndexMax;         //This is only relevant if theResourceStringType is
                                                    //of type RESOURCE_INCREMENT. This identifies the maximum
                                                    //index value that is support for this increment type. This
                                                    //is to protect from unsupported registry value causing the
                                                    //"theResourceIndexID + value" addition going beyond the
                                                    //range of supported string resource values.
  tRegAccessType       theRegAccessType;            //This define whether the access to the registry value
                                                    //should use a "shallow" or "deep" get. See help on
                                                    //tUPSDataItemID above.
  void *               theShallowAccessFunctionPtr; //This point to the regfuncs function to use when performing
                                                    //a shallow get. This parameter is only required if
                                                    //theRegAccessType is set to eShallowGet, otherwise it can
                                                    //be 0.
  struct _reg_entry *  theRegEntryPtr;              //This is the _reg_entry * parameter passed to the regfuncs
                                                    //function (theShallowAccessFunctionPtr member) when
                                                    //performing a shallow get. This parameter is only required if
                                                    //theRegAccessType is set to eShallowGet, otherwise it can
                                                    //be 0.
  } DialogAssociations;

/*

  The following example helps to explain more the members of the DialogAssociations struct.

  Say we have an instance of this struct as follows:

  DialogAssociations da = { eREG_POWER_SOURCE,
                            IDC_POWER_SOURCE_LHS,
                            IDC_POWER_SOURCE,
                            IDS_STRING,
                            IDS_UTILITYPOWER_UNKNOWN,
                            RESOURCE_INCREMENT,
                            2,
                            eDeepGet,
                            0,
                            0 };

  This describes a registry field called eREG_POWER_SOURCE. If we look at
  tUPSDataItemID above we see that eREG_POWER_SOURCE has a value of 4. If
  we then look at g_upsRegFields in datacces.c we that the RegField at index
  4 has the following data:

  { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("UtilityPowerStatus"), REG_DWORD },

  The DoUpdateInfo function, for example, takes this information when updating
  the onscreen data in the main UPS page. The function gets the RegField
  information, as above. It then looks to see if it needs to do a deep get (read
  directly from the registry), or a shallow get (take data from the current
  values stored in the regfuncs buffers. If the registry item theValueType is
  one of the string type then the string value is copied into the resource
  string identified by theResourceInsertID. In this case theValueType is
  REG_DWORD. In this case the DWORD is read from the registry directly. Its
  value (say it had a value of 1) is then added to IDS_UTILITYPOWER_UNKNOWN
  giving a value which corresponds to IDS_UTILITYPOWER_ON. The string
  IDS_UTILITYPOWER_ON is then loaded and used as a parameter value when
  loaded the parameterized string resource identified by the
  theResourceInsertID string id. This string (which should include the inserted
  text) is then displayed in the control identified by theDisplayControlID.
*/


//this struct describes a registy field item 
typedef struct _RegField {
  HKEY    theRootKey;   //Handle to an existing registry key.
  LPCTSTR theKeyName;   //The name of the subkey relative to the above handle.
  LPCTSTR theValueName; //The name of the registry value.
  DWORD   theValueType; //The type of the value.
  } RegField;

///////////////////////////////////////////////////////////////////////////////

RegField * GetRegField      (DWORD index);

// upsdata.h
//Note that the order and numbering of the enums in tUPSDataItemID is linked to
//the contents of the array of RegFields defined in datacces.h. 
//Do not change these value without due care and attention. It's OK to change
//it as long as the array of RegFields is updated to match.

DWORD ReadRegistryValueData (HKEY aRootKey,
                             LPCTSTR aKeyName,
                             LPCTSTR aValueName,
                             DWORD aAllowedTypes,
                             DWORD * aTypePtr,
                             LPTSTR aReturnBuffer,
                             DWORD * aBufferSizePtr);

BOOL GetUPSDataItemDWORD  (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr);
BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID, LPTSTR aBufferPtr, DWORD * pSizeOfBufferPtr);



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upssers.cxx ===
/*
 *
 * REVISIONS:
 *  ker02DEC92: Initial breakout of sensor classes into indiv files
 *  pcy14Dec92: Changed READ_WRITE to AREAD_WRITE
 *
 */

#define INCL_BASE
#define INCL_DOS
#define INCL_NOPM

#include "cdefine.h"

extern "C" {
#if (C_OS & C_OS2)
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}

#include "upssers.h"

UpsSerialNumberSensor :: UpsSerialNumberSensor(PDevice aParent, PCommController aCommController)
			: Sensor(aParent, aCommController, UPS_SERIAL_NUMBER)
{
    DeepGet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upsreg.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSREG.C
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*	 Revision History:
*   v-stebe  23May2000  added check for NULL in ReadRegistryValue() (bug 112595)
*   v-stebe  23May2000  added code to avoid rewriting the registry value if the
*                       value is unchanged in setDwordValue() (bug #92799)
*   v-stebe  11Sep2000  Fixed PREfix error (bug #170456)
*******************************************************************************/

/*
 * system includes
 */
#include <windows.h>
#include <tchar.h>

/*
 * local includes
 */
//#include "upsdefines.h"
#include "upsreg.h"
#include "regdefs.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Reg entry info structure declaration
 */
struct _reg_entry
{
  HKEY    hKey;			/* the key */
  LPTSTR  lpSubKey;		/* address of SubKey name */
  LPTSTR  lpValueName;  /* address of name of value to query */
  DWORD   ulType;       /* buffer for value type */
  LPBYTE  lpData;       /* address of data buffer */
  DWORD   cbData;       /* data buffer size */
  BOOL    changed;		/* ID of dialog that changed this entry */
};

/*
 * local function pre-declarations
 */
void freeBlock(struct _reg_entry *aBlock[]);
void readBlock(struct _reg_entry *aBlock[], BOOL changed); 
void writeBlock(struct _reg_entry *aBlock[], BOOL forceAll);
LONG setDwordValue(struct _reg_entry *aRegEntry, DWORD aValue);
LONG setStringValue(struct _reg_entry *aRegEntry, LPCTSTR aBuffer);

static BOOL isRegistryInitialized();
static void CheckForUpgrade();
static void InitializeServiceKeys();
static void InitializeServiceProviders();
static void InitializeConfigValues();
static void InitializeStatusValues();


/* 
 * Reg entry value name declarations
 */
#define UPS_VENDOR				_T("Vendor")
#define UPS_MODEL				_T("Model")
#define UPS_SERIALNUMBER		_T("SerialNumber")
#define UPS_FIRMWAREREV			_T("FirmwareRev")
#define UPS_UTILITYSTATUS		_T("UtilityPowerStatus")
#define UPS_RUNTIME				_T("TotalUPSRuntime")
#define UPS_BATTERYSTATUS		_T("BatteryStatus")
#define UPS_PORT				_T("Port")
#define UPS_OPTIONS				_T("Options")
#define UPS_SHUTDOWNWAIT		_T("ShutdownWait")
#define UPS_FIRSTMESSAGEDELAY	_T("FirstMessageDelay")
#define UPS_MESSAGEINTERVAL		_T("MessageInterval")
#define UPS_SERVICEDLL			_T("ServiceProviderDLL")
#define UPS_NOTIFYENABLE		_T("NotifyEnable")
#define UPS_SHUTBATTENABLE		_T("ShutdownOnBatteryEnable")
#define UPS_SHUTBATTWAIT		_T("ShutdownOnBatteryWait")
#define UPS_RUNTASKENABLE		_T("RunTaskEnable")
#define UPS_TASKNAME			_T("TaskName")
#define UPS_TURNUPSOFFENABLE	_T("TurnUPSOffEnable")
#define UPS_APCLINKURL			_T("APCLinkURL")
#define UPS_CUSTOMOPTIONS       _T("CustomOptions")
#define UPS_UPGRADE				_T("Upgrade")
#define UPS_COMMSTATUS			_T("CommStatus")
#define UPS_CRITICALPOWERACTION  _T("CriticalPowerAction")
#define UPS_TURNUPSOFFWAIT           _T("TurnUPSOffWait")
#define UPS_SHOWTAB              _T("ShowUPSTab")
#define UPS_BATTERYCAPACITY       _T("BatteryCapacity")
#define UPS_IMAGEPATH			    _T("ImagePath")
#define UPS_ERRORCONTROL      _T("ErrorControl")
#define UPS_OBJECTNAME        _T("ObjectName")
#define UPS_START             _T("Start")
#define UPS_TYPE              _T("Type")

// This specifies the key to examine to determine if the registry
// has been updated for the UPS Service.
#define UPS_SERVICE_INITIALIZED_KEY   TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")

// Specifies the name of the BatteryLife key used in the NT 4.0 UPS Service
#define UPS_BATTLIFE_KEY              TEXT("BatteryLife")

// This specifies the default name for the shutdown Task
#define DEFAULT_SHUTDOWN_TASK_NAME    TEXT("") 

// Default values for the Config settings
#define DEFAULT_CONFIG_VENDOR_OLD               TEXT("\\(NONE)")
#define DEFAULT_CONFIG_VENDOR                   TEXT("")
#define DEFAULT_CONFIG_MODEL                    TEXT("")
#define DEFAULT_CONFIG_PORT                     TEXT("COM1")
#define DEFAULT_CONFIG_OPTIONS                  0x7e
#define DEFAULT_CONFIG_FIRSTMSG_DELAY           5  
#define DEFAULT_CONFIG_MESSAGE_INTERVAL         120
#define DEFAULT_CONFIG_PROVIDER_DLL             TEXT("")
#define DEFAULT_CONFIG_NOTIFY_ENABLE            1
#define DEFAULT_CONFIG_SHUTDOWN_ONBATT_ENABLE   FALSE
#define DEFAULT_CONFIG_SHUTDOWN_ONBATT_WAIT     2
#define DEFAULT_CONFIG_RUNTASK_ENABLE           FALSE
#define DEFAULT_CONFIG_TASK_NAME                DEFAULT_SHUTDOWN_TASK_NAME
#define DEFAULT_CONFIG_TURNOFF_UPS_ENABLE       TRUE
#define DEFAULT_CONFIG_CUSTOM_OPTIONS           UPS_DEFAULT_SIGMASK
#define DEFAULT_CONFIG_CRITICALPOWERACTION      UPS_SHUTDOWN_SHUTDOWN
#define DEFAULT_CONFIG_TURNOFF_UPS_WAIT         180
#define DEFAULT_CONFIG_ERRORCONTROL             1
#define DEFAULT_CONFIG_OBJECTNAME               TEXT("LocalSystem")
#define DEFAULT_CONFIG_START                    SERVICE_DEMAND_START
#define DEFAULT_CONFIG_TYPE                     16
#define DEFAULT_CONFIG_SHOWUPSTAB               FALSE

// Default values for the Status settings
#define DEFAULT_STATUS_SERIALNO                 TEXT("")
#define DEFAULT_STATUS_FIRMWARE_REV             TEXT("")
#define DEFAULT_STATUS_UTILITY_STAT             0
#define DEFAULT_STATUS_TOTAL_RUNTIME            0
#define DEFAULT_STATUS_BATTERY_STAT             0
#define DEFAULT_STATUS_BATTERY_CAPACITY         0

// Default values for upgraded services
#define UPGRADE_CONFIG_VENDOR_OLD               TEXT("\\Generic")
#define UPGRADE_CONFIG_VENDOR                   TEXT("")
#define UPGRADE_CONFIG_MODEL                    TEXT("")

/* 
 * Allocate the individual Configuration Reg entry records 
 */
struct _reg_entry UPSConfigVendor			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_VENDOR,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigModel			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_MODEL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigPort				= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_PORT,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigOptions			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_OPTIONS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigServiceDLL		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SERVICEDLL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigNotifyEnable		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_NOTIFYENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigFirstMessageDelay= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_FIRSTMESSAGEDELAY,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigMessageInterval	= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_MESSAGEINTERVAL,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShutBattEnable   = {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SHUTBATTENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShutBattWait     = {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SHUTBATTWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigRunTaskEnable	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_RUNTASKENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigTaskName			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TASKNAME,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigTurnOffEnable	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TURNUPSOFFENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigCustomOptions	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_CUSTOMOPTIONS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigAPCLinkURL		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_APCLINKURL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigShutdownWait		= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_SHUTDOWNWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigUpgrade			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_UPGRADE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigCriticalPowerAction	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_CRITICALPOWERACTION,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigTurnOffWait	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TURNUPSOFFWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigImagePath			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_IMAGEPATH,REG_EXPAND_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigObjectName			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_OBJECTNAME,REG_EXPAND_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigErrorControl			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_ERRORCONTROL,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigStart			    = {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_START,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigType     			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_TYPE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShowUPSTab			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_SHOWTAB,REG_DWORD,NULL,0,FALSE};

/* 
 * Allocate the individual Status Reg entry records 
 */
struct _reg_entry UPSStatusSerialNum	= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_SERIALNUMBER,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSStatusFirmRev		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_FIRMWAREREV,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSStatusUtilityStatus= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_UTILITYSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusRuntime		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_RUNTIME,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusBatteryStatus= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_BATTERYSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusCommStatus	= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_COMMSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusBatteryCapacity		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_BATTERYCAPACITY,REG_DWORD,NULL,0,FALSE};

/* 
 * Allocate an array of pointers to the Configuration Reg entry records
 */
struct _reg_entry *ConfigBlock[] =  {&UPSConfigVendor,
									&UPSConfigModel,
									&UPSConfigPort,
									&UPSConfigOptions,
									&UPSConfigServiceDLL,
									&UPSConfigNotifyEnable,
									&UPSConfigFirstMessageDelay,
									&UPSConfigMessageInterval,
									&UPSConfigShutBattEnable,
									&UPSConfigShutBattWait,
									&UPSConfigRunTaskEnable,
									&UPSConfigTaskName,
									&UPSConfigTurnOffEnable,
									&UPSConfigCustomOptions,
									&UPSConfigAPCLinkURL,
									&UPSConfigShutdownWait,
									&UPSConfigUpgrade,
									&UPSConfigCriticalPowerAction,
									&UPSConfigTurnOffWait,
                  &UPSConfigImagePath,
                  &UPSConfigObjectName,
                  &UPSConfigErrorControl,
                  &UPSConfigStart,
                  &UPSConfigType,   		
									&UPSConfigShowUPSTab,
									NULL};

/* 
 * Allocate an array of pointers to the Status Reg entry records
 */
struct _reg_entry *StatusBlock[] = {&UPSStatusSerialNum,
									&UPSStatusFirmRev,
									&UPSStatusUtilityStatus,
									&UPSStatusRuntime,
									&UPSStatusBatteryStatus,
									&UPSStatusCommStatus,
									&UPSStatusBatteryCapacity,
									NULL};


/******************************************************************
 * Public functions
 */

LONG GetUPSConfigVendor( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigVendor, aBuffer);
}

LONG GetUPSConfigModel( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigModel, aBuffer);
}

LONG GetUPSConfigPort( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigPort, aBuffer);
}

LONG GetUPSConfigOptions( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigOptions, aValue);
}

LONG GetUPSConfigServiceDLL( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigServiceDLL, aBuffer);
}

LONG GetUPSConfigNotifyEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigNotifyEnable, aValue);
}

LONG GetUPSConfigFirstMessageDelay( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigFirstMessageDelay, aValue);
}

LONG GetUPSConfigMessageInterval( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigMessageInterval, aValue);
}

LONG GetUPSConfigShutdownOnBatteryEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutBattEnable, aValue);
}

LONG GetUPSConfigShutdownOnBatteryWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutBattWait, aValue);
}

LONG GetUPSConfigRunTaskEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigRunTaskEnable, aValue);
}

LONG GetUPSConfigTaskName( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigTaskName, aBuffer);
}

LONG GetUPSConfigTurnOffEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigTurnOffEnable, aValue);
}

LONG GetUPSConfigCustomOptions( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigCustomOptions, aValue);
}

LONG GetUPSConfigAPCLinkURL( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigAPCLinkURL, aBuffer);
}

LONG GetUPSConfigShutdownWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutdownWait, aValue);
}

LONG GetUPSConfigUpgrade( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigUpgrade, aValue);
}

LONG GetUPSConfigCriticalPowerAction( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigCriticalPowerAction, aValue);
}

LONG GetUPSConfigTurnOffWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigTurnOffWait, aValue);
}

LONG GetUPSConfigShowUPSTab( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShowUPSTab, aValue);
}

LONG GetUPSConfigImagePath( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigImagePath, aBuffer);
}

LONG GetUPSConfigObjectName( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigObjectName, aBuffer);
}

LONG GetUPSConfigErrorControl( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigErrorControl, aValue);
}

LONG GetUPSConfigStart( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigStart, aValue);
}

LONG GetUPSConfigType( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigType, aValue);
}

///////////////////////////////////////////

LONG SetUPSConfigVendor( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigVendor, aBuffer);
}

LONG SetUPSConfigModel( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigModel, aBuffer);
}

LONG SetUPSConfigPort( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigPort, aBuffer);
}

LONG SetUPSConfigOptions( DWORD aValue)
{
	return setDwordValue( &UPSConfigOptions, aValue);
}

LONG SetUPSConfigServiceDLL( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigServiceDLL, aBuffer);
}

LONG SetUPSConfigNotifyEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigNotifyEnable, aValue);
}

LONG SetUPSConfigFirstMessageDelay( DWORD aValue)
{
	return setDwordValue( &UPSConfigFirstMessageDelay, aValue);
}

LONG SetUPSConfigMessageInterval( DWORD aValue)
{
	return setDwordValue( &UPSConfigMessageInterval, aValue);
}

LONG SetUPSConfigShutdownOnBatteryEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigShutBattEnable, aValue);
}

LONG SetUPSConfigShutdownOnBatteryWait( DWORD aValue) 
{
	return setDwordValue( &UPSConfigShutBattWait, aValue); 
}

LONG SetUPSConfigRunTaskEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigRunTaskEnable, aValue);
}

LONG SetUPSConfigTaskName( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigTaskName, aBuffer);
}

LONG SetUPSConfigTurnOffEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigTurnOffEnable, aValue);
}

LONG SetUPSConfigCustomOptions( DWORD aValue)
{
	return setDwordValue( &UPSConfigCustomOptions, aValue);
}

LONG SetUPSConfigAPCLinkURL( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigAPCLinkURL, aBuffer);
}

LONG SetUPSConfigShutdownWait( DWORD aValue)
{
	return setDwordValue( &UPSConfigShutdownWait, aValue);
}

LONG SetUPSConfigUpgrade( DWORD aValue)
{
	return setDwordValue( &UPSConfigUpgrade, aValue);
}

LONG SetUPSConfigCriticalPowerAction( DWORD aValue)
{
	return setDwordValue( &UPSConfigCriticalPowerAction, aValue);
}

LONG SetUPSConfigTurnOffWait( DWORD aValue)
{
	return setDwordValue( &UPSConfigTurnOffWait, aValue);
}

LONG SetUPSConfigShowUPSTab( DWORD aValue)
{
	return setDwordValue( &UPSConfigShowUPSTab, aValue);
}

LONG SetUPSConfigImagePath( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigImagePath, aBuffer);
}

LONG SetUPSConfigObjectName( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigObjectName, aBuffer);
}

LONG SetUPSConfigErrorControl( DWORD aValue)
{
	return setDwordValue( &UPSConfigErrorControl, aValue);
}

LONG SetUPSConfigStart( DWORD aValue)
{
	return setDwordValue( &UPSConfigStart, aValue);
}

LONG SetUPSConfigType( DWORD aValue)
{
	return setDwordValue( &UPSConfigType, aValue);
}


////////////////////////////////////////////////

LONG GetUPSStatusSerialNum( LPTSTR aBuffer)
{
	return getStringValue( &UPSStatusSerialNum, aBuffer);
}

LONG GetUPSStatusFirmRev( LPTSTR aBuffer)
{
	return getStringValue( &UPSStatusFirmRev, aBuffer);
}

LONG GetUPSStatusUtilityStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusUtilityStatus, aValue);
}

LONG GetUPSStatusRuntime( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusRuntime, aValue);
}

LONG GetUPSStatusBatteryStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusBatteryStatus, aValue);
}

LONG GetUPSStatusCommStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusCommStatus, aValue);
}

LONG GetUPSBatteryCapacity( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusBatteryCapacity, aValue);
}

/////////////////////////////////////////

LONG SetUPSStatusSerialNum( LPCTSTR aBuffer)
{
	return setStringValue( &UPSStatusSerialNum, aBuffer);
}

LONG SetUPSStatusFirmRev( LPCTSTR aBuffer)
{
	return setStringValue( &UPSStatusFirmRev, aBuffer);
}

LONG SetUPSStatusUtilityStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusUtilityStatus,aValue);
}

LONG SetUPSStatusRuntime( DWORD aValue)
{
	return setDwordValue( &UPSStatusRuntime,aValue);
}

LONG SetUPSStatusBatteryStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusBatteryStatus,aValue);
}

LONG SetUPSStatusCommStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusCommStatus,aValue);
}

LONG SetUPSStatusBatteryCapacity( DWORD aValue)
{
	return setDwordValue( &UPSStatusBatteryCapacity,aValue);
}

//////////////////////////////////////////////////////////////

void FreeUPSConfigBlock()
{
	freeBlock(ConfigBlock);
}

void FreeUPSStatusBlock()
{
	freeBlock(StatusBlock);
}

void InitUPSConfigBlock()
{
	readBlock(ConfigBlock,FALSE);
}

void InitUPSStatusBlock()
{
	readBlock(StatusBlock,FALSE);
}

void RestoreUPSConfigBlock()
{
	readBlock(ConfigBlock, TRUE);
}

void RestoreUPSStatusBlock()
{
	readBlock(StatusBlock, TRUE);
}

void SaveUPSConfigBlock(BOOL forceAll)
{
	writeBlock(ConfigBlock, forceAll);
}

void SaveUPSStatusBlock(BOOL forceAll)
{
	writeBlock(StatusBlock, forceAll);
}

/******************************************************************
 * Local functions
 */

/*
 * freeBlock()
 *
 * Description: Frees storage allocated when a block of registry 
 *				entries is read
 *
 * Parameters: aBlock - pointer to an array of _reg_entry structures
 *
 * Returns:
 */
void freeBlock(struct _reg_entry *aBlock[]) 
{
	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		if (NULL != anEntry->lpData)
		{
			LocalFree(anEntry->lpData);
		}
		anEntry->lpData = NULL;
		anEntry->cbData = 0;
		anEntry->changed = FALSE; 

		aBlock++;
	}
}

/*
 * readBlock()
 *
 * Description: Loads all of the items in a array of registry entries
 *
 * Parameters:  aBlock - pointer to an array of _reg_entry structures
 *				changed - boolean which, when true, causes only the
 *				structures that are marked as changed to be loaded.
 *
 * Returns:
 */
void readBlock(struct _reg_entry *aBlock[], BOOL changed) 
{
	LONG res;
	HKEY hkResult;

	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		/* 
		 * if changed is FALSE, we read all entries
		 * otherwise, only re-read the changed entries
		 */
		if ((FALSE == changed) || (TRUE == anEntry->changed))
		{
			/* 
			 * delete current value, in case this is a reload 
			 */
			if (NULL != anEntry->lpData)
			{
				LocalFree(anEntry->lpData);
			}
			anEntry->lpData = NULL;
			anEntry->cbData = 0;
			anEntry->changed = FALSE;

			/* 
			 * open key 
			 */
			res = RegOpenKeyEx( anEntry->hKey,
								anEntry->lpSubKey,
								0,
								KEY_QUERY_VALUE,
								&hkResult);

			if (ERROR_SUCCESS == res) 
			{
				DWORD ulTmpType;

				/* 
				 * query for the data size 
				 */
				res = RegQueryValueEx( hkResult,
										anEntry->lpValueName,
										NULL,
										&ulTmpType,
										NULL,
										&anEntry->cbData);

				/* 
				 * if the data has 0 size, we don't read it 
				 */
				if ((ERROR_SUCCESS == res) && 
					(anEntry->cbData > 0) && 
					(anEntry->ulType == ulTmpType) &&
					(NULL != (anEntry->lpData = (LPBYTE)LocalAlloc(LMEM_FIXED, anEntry->cbData))))
//					(NULL != (anEntry->lpData = (LPBYTE)malloc(anEntry->cbData))))
				{
					/* 
					 * query for data 
					 */
					res = RegQueryValueEx( hkResult,
											anEntry->lpValueName,
											NULL,
											&ulTmpType,
											anEntry->lpData,
											&anEntry->cbData);
					
					/* 
					 * something went wrong; reset 
					 */
					if (ERROR_SUCCESS != res)
					{
						LocalFree(anEntry->lpData);
						anEntry->lpData = NULL;
						anEntry->cbData = 0;
					}
				}
				else
				{
					anEntry->cbData = 0;
				}

				RegCloseKey(hkResult);
			}
		}

		aBlock++;
	}
}

/*
 * writeBlock()
 *
 * Description: Stores all of the items in a array of registry entries
 *
 * Parameters:  aBlock - pointer to an array of _reg_entry structures
 *				forceAll - boolean which, when true, causes all of the
 *				structures to be written to the registry, otherwise only
 *				those entries that are marked as changed are stored.
 *
 * Returns:
 */
void writeBlock(struct _reg_entry *aBlock[], BOOL forceAll) 
{
	LONG res;
	HKEY hkResult;

	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		/*
		 * if forcall is true, write out everything
		 * otherwise only write out the changed entries
		 */
		if ((NULL != anEntry->lpData) &&
			((TRUE == forceAll) || (TRUE == anEntry->changed)))
		{
			/* 
			 * open key 
			 */
			res = RegOpenKeyEx( anEntry->hKey,
								anEntry->lpSubKey,
								0,
								KEY_SET_VALUE,
								&hkResult);

			if (ERROR_SUCCESS == res) 
			{
				/* 
				 * set data 
				 */
				res = RegSetValueEx( hkResult,
										anEntry->lpValueName,
										0,
										anEntry->ulType,
										anEntry->lpData,
										anEntry->cbData);
				
				RegCloseKey(hkResult);
			}

			anEntry->changed = FALSE;  
		}

		aBlock++;
	}
}

/*
 * setDwordValue()
 *
 * Description: Sets the value of a REG_DWORD entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aValue - the value to store in the entry
 *
 * Returns: ERROR_SUCCESS, E_OUTOFMEMORY, ERROR_INVALID_PARAMETER
 */
LONG setDwordValue(struct _reg_entry *aRegEntry, DWORD aValue)
{
	LONG res = ERROR_SUCCESS;
	DWORD value_changed = TRUE;

	if (NULL != aRegEntry)
	{
		/*
		 * Check to see if a value already exists
		 */
		if (NULL != aRegEntry->lpData)
		{
			/*
			 * If the value is the different, delete it.  
			 */
			if (memcmp(aRegEntry->lpData, &aValue, sizeof(aValue)) != 0) {
				LocalFree (aRegEntry->lpData);
				aRegEntry->lpData = NULL;
				aRegEntry->cbData = 0;
			}
			else {
				/*
				 * The value is the same, don't change it.  That would cause an
				 * unnecessary write to the registry (see bug #92799)
				 */
				value_changed = FALSE;
			}
		}

		/*
		 * set value
		 */
		if (value_changed) {
			aRegEntry->cbData = sizeof(DWORD);
			if (NULL != (aRegEntry->lpData = LocalAlloc(LMEM_FIXED, aRegEntry->cbData)))
			{
				*((DWORD*)aRegEntry->lpData) = aValue;
				aRegEntry->changed = TRUE;
			}
			else 
			{ 
				res = E_OUTOFMEMORY;
				aRegEntry->cbData = 0;
			}
		}
	}
	else 
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}


/*
 * setStringValue()
 *
 * Description: Sets the value of a REG_SZ entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aBuffer - pointer to the string to store in the entry
 *
 * Returns: ERROR_SUCCESS, E_OUTOFMEMORY, ERROR_INVALID_PARAMETER
 */
LONG setStringValue(struct _reg_entry *aRegEntry, LPCTSTR aBuffer)
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aBuffer))
	{
		/*
		 * if value already exists, delete it
		 */
		if (NULL != aRegEntry->lpData)
		{
			LocalFree(aRegEntry->lpData);
			aRegEntry->lpData = NULL;
			aRegEntry->cbData = 0;
		}

		/*
		 * set value
		 */
		aRegEntry->cbData = (_tcslen(aBuffer)+1)*sizeof(TCHAR);
		if (NULL != (aRegEntry->lpData = LocalAlloc(LMEM_FIXED, aRegEntry->cbData)))
		{
			_tcscpy((LPTSTR)aRegEntry->lpData,aBuffer);
			aRegEntry->changed = TRUE;
		}
		else 
		{ 
			res = E_OUTOFMEMORY;
			aRegEntry->cbData = 0;
		}
	}
	else 
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}


/*
 * getStringValue()
 *
 * Description: Gets the value of a REG_SZ entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aBuffer - pointer to the string to receive the string
 *
 * Returns: ERROR_SUCCESS, REGDB_E_INVALIDVALUE, ERROR_INVALID_PARAMETER
 */
LONG getStringValue(struct _reg_entry *aRegEntry, LPTSTR aBuffer) 
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aBuffer))
	{
		if (NULL != aRegEntry->lpData)
		{
			_tcscpy(aBuffer, (LPCTSTR)aRegEntry->lpData);
		}
		else 
		{
			res = REGDB_E_INVALIDVALUE;
		}
	}
	else
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}

/*
 * getDwordValue()
 *
 * Description: Gets the value of a REG_DWORD entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aValue - pointer to the variable to receive the value
 *
 * Returns: ERROR_SUCCESS, REGDB_E_INVALIDVALUE, ERROR_INVALID_PARAMETER
 */
LONG getDwordValue(struct _reg_entry *aRegEntry, LPDWORD aValue) 
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aValue))
	{
		if (NULL != aRegEntry->lpData)
		{
			*aValue = *((DWORD*)aRegEntry->lpData);
		}
		else
		{
			res = REGDB_E_INVALIDVALUE;
		}
	}
	else
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}


/**
* InitializeRegistry
*
* Description:
*   This function initiates the registry for the UPS service and the 
*   configuration application.  When called, this function calls the
*   function isRegistryInitialized(..) to determine if the registry
*   has been initialied.  If it has not, the following Keys are updated:
*        Status
*        Config
*        ServiceProviders
*
*   The values for the ServiceProviders key is supplied in the regdefs.h
*   header file.
*
* Parameters:
*   none
*
* Returns:
*   TRUE if able to open registry keys with write access.
*/
BOOL InitializeRegistry() {
    BOOL ret_val = FALSE;
    HKEY key;

    TCHAR szKeyName[MAX_PATH] = _T("");

  // Initialize UPS Service registry keys 
  InitializeServiceKeys();

  // Check to see if the registry is already initialized
  if (isRegistryInitialized() == FALSE) {
    CheckForUpgrade();
    InitializeServiceProviders();
    InitializeConfigValues();
    InitializeStatusValues();
  }

    /*
     * Remove "(None)" and "Generic" Service Provider keys if they exist
     * This fixes a localization bug introduced in RC2
     */
  _tcscpy(szKeyName, UPS_SERVICE_ROOT);
  _tcscat(szKeyName, DEFAULT_CONFIG_VENDOR_OLD);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName);
  _tcscpy(szKeyName, UPS_SERVICE_ROOT);
  _tcscat(szKeyName, UPGRADE_CONFIG_VENDOR_OLD);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName);

  // ...and check if we have write access
  if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                   UPS_DEFAULT_ROOT,
                   0,
                   KEY_WRITE,
                   &key) == ERROR_SUCCESS )
  {
    RegCloseKey(key);
    ret_val = TRUE;
  }

  return ret_val;
}


/**
* isRegistryInitialized
*
* Description:
*   This function determines if the registry has been initialized for
*   the UPS service.  This is done by examine the registry key specified
*   by the identifier UPS_SERVICE_INITIALIED_KEY.  If the key is present,
*   the registry is assumed to be initialized and TRUE is returned.  
*   Otherwise, FALSE is returned.
*
* Parameters:
*   none
*
* Returns:
*   TRUE  - if the registry has been initialized for the UPS service
*   FALSE - otherwise
*/
static BOOL isRegistryInitialized() {
BOOL ret_val = FALSE;
HKEY key;

if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, UPS_SERVICE_INITIALIZED_KEY,
  0, KEY_QUERY_VALUE, &key) == ERROR_SUCCESS) {
  ret_val = TRUE;

  RegCloseKey(key);
}
return ret_val;
}

/**
* CheckForUpgrade
*
* Description:
*   This function determines if this installation is an upgrade from
*   the WINNT 4.x UPS service.  This is done by checking to see if the 
*   Config registry key is present.  If it is not present and the Options 
*   key is set to UPS_INSTALLED, then the Upgrade registry key is set to 
*   TRUE.  Otherwise, it is set to FALSE.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void CheckForUpgrade() {
DWORD result;
HKEY key;
DWORD options = 0;

// Create the Config key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_CONFIG_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Check to see if the Config key was present
    if (result != REG_OPENED_EXISTING_KEY) {
      // Config key was not found
      InitUPSConfigBlock();

      // Check the port value
      if (ERROR_SUCCESS != GetUPSConfigOptions(&options)) {
        // Options key is not found
        SetUPSConfigUpgrade(FALSE);
      }
      else if (options & UPS_INSTALLED) {
        // The Options key is present and UPS_INSTALLED is set
        // This is an upgrade
        SetUPSConfigUpgrade(TRUE);
      }
      else {
        // The Config key is present and UPS_INSTALLED is not set
        SetUPSConfigUpgrade(FALSE);
      }
    }
    else {
      // Config key does not exist
      SetUPSConfigUpgrade(FALSE);
    }

    // Write the Config values, force a save of all values
    SaveUPSConfigBlock(TRUE);

    // Free the Config block
    FreeUPSConfigBlock();
}
}

/**
* InitializeServiceKeys
*
* Description:
*   This function initializes the UPS service registry keys to
*   default values, if the values are not present.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeServiceKeys() {
  TCHAR tmpString[MAX_PATH];
  DWORD tmpDword;

  // Initialize the registry functions
  InitUPSConfigBlock();
  
  // Check the service keys and initialize any missing keys
  if (GetUPSConfigImagePath(tmpString) != ERROR_SUCCESS) {
    SetUPSConfigImagePath(DEFAULT_CONFIG_IMAGEPATH);
  }

  if (GetUPSConfigObjectName(tmpString) != ERROR_SUCCESS) {
    SetUPSConfigObjectName(DEFAULT_CONFIG_OBJECTNAME);
  }

  if (GetUPSConfigErrorControl(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigErrorControl(DEFAULT_CONFIG_ERRORCONTROL);
  }

  if (GetUPSConfigStart(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigStart(DEFAULT_CONFIG_START);
  }

  if (GetUPSConfigType(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigType(DEFAULT_CONFIG_TYPE);
  }

  // Write the Config values, force a save of all values
  SaveUPSConfigBlock(TRUE);
  
  // Free the Status block
  FreeUPSConfigBlock();
}

/**
* InitializeServiceProviders
*
* Description:
*   This function initializes the ServiceProviders registry keys with the
*   data provided in the global structure _theStaticProvidersTable.  This
*   structure is defined in the file regdefs.h and is automatically 
*   generated.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeServiceProviders() {
DWORD result;
HKEY key;

int index = 0;

// Loop through the list of Service Providers
while (_theStaticProvidersTable[index].theModelName != NULL) {
  // Open the vendor registry key
  if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, _theStaticProvidersTable[index].theVendorKey, 
    0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // Set the model value
    RegSetValueEx(key, _theStaticProvidersTable[index].theModelName, 0, REG_SZ, 
      (LPSTR) _theStaticProvidersTable[index].theValue, 
      wcslen(_theStaticProvidersTable[index].theValue)*sizeof(TCHAR));

    RegCloseKey(key);
  }

  // Increment counter
  index++;
}
}

/**
* InitializeConfigValues
*
* Description:
*   This function initializes the Config registry keys with
*   default values.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeConfigValues() {
DWORD result;
HKEY  key;
DWORD options_val, batt_life, type; 
DWORD batt_life_size = sizeof(DWORD);

// Create the Config key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_CONFIG_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Initialize the registry functions
    InitUPSConfigBlock();

    // Set default values
    SetUPSConfigServiceDLL(DEFAULT_CONFIG_PROVIDER_DLL);
    SetUPSConfigNotifyEnable(DEFAULT_CONFIG_NOTIFY_ENABLE);
    SetUPSConfigShutdownOnBatteryEnable(DEFAULT_CONFIG_SHUTDOWN_ONBATT_ENABLE);
    SetUPSConfigShutdownOnBatteryWait(DEFAULT_CONFIG_SHUTDOWN_ONBATT_WAIT);
    SetUPSConfigRunTaskEnable(DEFAULT_CONFIG_RUNTASK_ENABLE);
    SetUPSConfigTaskName(DEFAULT_CONFIG_TASK_NAME);
    SetUPSConfigTurnOffEnable(DEFAULT_CONFIG_TURNOFF_UPS_ENABLE);
    SetUPSConfigCustomOptions(DEFAULT_CONFIG_CUSTOM_OPTIONS);
    SetUPSConfigCriticalPowerAction(DEFAULT_CONFIG_CRITICALPOWERACTION);
    SetUPSConfigTurnOffWait(DEFAULT_CONFIG_TURNOFF_UPS_WAIT);

    // If this is not an upgrade, set the appropriate values
    if ((GetUPSConfigUpgrade(&result) != ERROR_SUCCESS) || (result == FALSE)) {
      SetUPSConfigVendor(DEFAULT_CONFIG_VENDOR);
      SetUPSConfigModel(DEFAULT_CONFIG_MODEL);
      SetUPSConfigPort(DEFAULT_CONFIG_PORT);
      SetUPSConfigOptions(DEFAULT_CONFIG_OPTIONS);
      SetUPSConfigFirstMessageDelay(DEFAULT_CONFIG_FIRSTMSG_DELAY);
      SetUPSConfigMessageInterval(DEFAULT_CONFIG_MESSAGE_INTERVAL);
    }
    else {
      // This is an upgrade
      SetUPSConfigVendor(UPGRADE_CONFIG_VENDOR);
      SetUPSConfigModel(UPGRADE_CONFIG_MODEL);

      // Migrate the run command file option bit to the RunTaskEnable key
      if ((GetUPSConfigOptions(&options_val) == ERROR_SUCCESS) && 
        (options_val & UPS_RUNCMDFILE)) {
        // Run command file is enabled, set RunTaskEnable to TRUE
        SetUPSConfigRunTaskEnable(TRUE);
      }
      else {
        // Run command file is not enabled
        SetUPSConfigRunTaskEnable(FALSE);
      }

      // Migrate the BatteryLife value to the ShutdownOnBatteryWait value
      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, UPS_DEFAULT_ROOT, 0, KEY_ALL_ACCESS, &key) == ERROR_SUCCESS) {

        result = RegQueryValueEx(key, UPS_BATTLIFE_KEY, NULL, &type, (LPBYTE) &batt_life,  &batt_life_size);

        if ((result == ERROR_SUCCESS) && (type == REG_DWORD)) {

          // Migrate the value and enable shutdown on battery
          SetUPSConfigShutdownOnBatteryWait(batt_life);
		  SetUPSConfigShutdownOnBatteryEnable(TRUE);

          // Delete the value
          RegDeleteValue(key, UPS_BATTLIFE_KEY);
        }

        // Close the key
        RegCloseKey(key);
      }
    }

    // Write the Config values, force a save of all values
    SaveUPSConfigBlock(TRUE);

    // Free the Config block
    FreeUPSConfigBlock();
  }
}

/**
* InitializeStatusValues
*
* Description:
*   This function initializes the Status registry keys with 
*   default values.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeStatusValues() {
DWORD result;
HKEY key;

// Create the Status key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_STATUS_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Initialize the registry functions
    InitUPSStatusBlock();

    // Put in default values
    SetUPSStatusSerialNum(DEFAULT_STATUS_SERIALNO);
    SetUPSStatusFirmRev(DEFAULT_STATUS_FIRMWARE_REV);
    SetUPSStatusUtilityStatus(DEFAULT_STATUS_UTILITY_STAT);
    SetUPSStatusRuntime(DEFAULT_STATUS_TOTAL_RUNTIME);
    SetUPSStatusBatteryStatus(DEFAULT_STATUS_BATTERY_STAT);
	SetUPSStatusBatteryCapacity(DEFAULT_STATUS_BATTERY_CAPACITY);

    // Write the Config values, force a save of all values
    SaveUPSStatusBlock(TRUE);

    // Free the Status block
    FreeUPSStatusBlock();
  }
}



///////////////////////////////////////////////////////////////////////////////
// upsdata.c
///////////////////////////////////////////////////////////////////////////////

//Note that the order of the following RegField is linked to the enum
//tUPSDataItemID.
//Do not change these value without due care and attention. It's OK to change
//them as long as the enum is updated to match.

//To access the RegField associated with Firmware, for example, use
//g_upsRegFields[(DWORD) eREG_FIRMWARE_REVISION]

static RegField g_upsRegFields[] = {
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Vendor"),                  REG_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Model"),                   REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("SerialNumber"),            REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("FirmwareRev"),             REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("UtilityPowerStatus"),      REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("TotalUPSRuntime"),         REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("BatteryCapacity"),         REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("BatteryStatus"),           REG_DWORD },
    { HKEY_LOCAL_MACHINE, UPS_KEY_NAME,    TEXT("Options"),                 REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ServiceProviderDLL"),      REG_EXPAND_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ShutdownOnBatteryEnable"), REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ShutdownOnBatteryWait"),   REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("TurnUPSOffEnable"),        REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("APCLinkURL"),              REG_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Upgrade"),                 REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("CommStatus"),              REG_DWORD },
    { HKEY_LOCAL_MACHINE, UPS_KEY_NAME,    TEXT("Port"),                    REG_SZ } };

// functions
///////////////////////////////////////////////////////////////////////////////

DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID,
                         DWORD aAllowedTypes,
                         DWORD * aTypePtr,
                         LPBYTE aReturnBuffer,
                         DWORD * aBufferSizePtr);

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// RegField * GetRegField (DWORD aIndex);
//
// Description: This function returns a pointer to a RegField from the
//              static array of RegFields named g_upsRegFields. The parameter
//              aIndex is an index into this array.
//
// Additional Information: 
//
// Parameters:
//
//   DWORD aIndex :- A index into array of known RegFields g_upsRegFields
//
// Return Value: If aIndex is within range this function returns a point to
//               the corresponding RegField, otherwise it ASSERTs and returns
//               NULL.
//
RegField * GetRegField (DWORD aIndex) {
  static const DWORD numRegFields = DIMENSION_OF(g_upsRegFields);
  RegField * pRequiredReg = NULL;

  if (aIndex < numRegFields) {
    pRequiredReg = &g_upsRegFields[aIndex];
    }
  else {
    _ASSERT(FALSE);
    }

  return(pRequiredReg);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL GetUPSDataItemDWORD (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr);
//
// Description: This function reads the DWORD value from the registry that
//              corresponds to the registry field identified by aDataItemID.
//              The registry value must be one of the DWORD types (REG_DWORD,
//              REG_DWORD_LITTLE_ENDIAN, REG_DWORD_BIG_ENDIAN)
//
//              For example, if aDataItemID is eREG_UPS_OPTIONS (=7), the
//              RegField at index 7 in g_upsRegFields identifies the required
//              registry information. The RegField identifies that the registry
//              key is HKLM\SYSTEM\CurrentControlSet\Services\UPS and the
//              value name is Options and it's of type DWORD. Using this
//              information this function gets the information from the
//              registry and puts the result in aReturnValuePtr.
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried. The value ranges
//                                       from eREG_VENDOR_NAME (which equals 0)
//                                       to eREG_PORT, the values incrementing
//                                       by 1 for each enum in the range. The
//                                       range of values in tUPSDataItemID
//                                       corresponds directly to the number of
//                                       elements in the array g_upsRegFields
//                                       because this enum is used to index the
//                                       elements in g_upsRegFields.
//
//   DWORD * aReturnValuePtr :- The DWORD value is returned through this
//                              pointer.
//
// Return Value: 
//
BOOL GetUPSDataItemDWORD (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr) {
  BOOL bGotValue = FALSE;
  DWORD nDWORDSize = sizeof(DWORD);

  if (ReadRegistryValue(aDataItemID, REG_DWORD, NULL, (LPBYTE) aReturnValuePtr, &nDWORDSize) == ERROR_SUCCESS) {
    bGotValue = TRUE;
    }

  return(bGotValue);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID, 
//                            LPTSTR aBufferPtr, 
//                            DWORD * pSizeOfBufferPtr);
//
// Description: This function reads the string value from the registry that
//              corresponds to the registry field identified by aDataItemID.
//              The registry value must be one of the string types (REG_SZ or
//              REG_EXPAND_SZ)
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried. The value must be
//                                       one of the string types (REG_SZ or
//                                       REG_EXPAND_SZ).
//
//   LPTSTR aBufferPtr :- The buffer into which the data is to be placed. This
//                        parameter can be NULL in which case no data is
//                        retrieved.
//
//   DWORD * pSizeOfBufferPtr :- This should point to a DWORD that contains the
//                               size of the buffer. This parameter cannot be
//                               NULL. When this function returns this value
//                               will contain the size actually required. This
//                               is useful if the user want to determine how
//                               big a buffer is required by calling this
//                               function with aBufferPtr set to NULL and
//                               pSizeOfBufferPtr pointing to a DWORD that
//                               is set to 0. When the function returns the
//                               DWORD pointed to by pSizeOfBufferPtr should
//                               contain the size of string required. This can
//                               then be used to dynamically allocate memory
//                               and call this function again with the buffer
//                               included this time.
//
// Return Value: The function returns TRUE if successful, FALSE otherwise.
//
BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID,
                           LPTSTR aBufferPtr,
                           DWORD * pSizeOfBufferPtr) {
  BOOL bGotValue = FALSE;
  DWORD nType = 0;

  if (ReadRegistryValue(aDataItemID,
                        REG_SZ | REG_EXPAND_SZ,
                        &nType,
                        (LPBYTE) aBufferPtr,
                        pSizeOfBufferPtr) == ERROR_SUCCESS) {
    //RegQueryValueEx stores the size of the data, in bytes, in the variable
    //pointed to by lpcbData. If the data has the REG_SZ, REG_MULTI_SZ or
    //REG_EXPAND_SZ type, then lpcbData will also include the size of the
    //terminating null character.
    //For Unicode the terminating NULL character is two-bytes.
    if ((pSizeOfBufferPtr != NULL) && (*pSizeOfBufferPtr > sizeof(TCHAR))) {
      if (nType == REG_EXPAND_SZ) {
        TCHAR expandBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
        DWORD expandBufferSize = DIMENSION_OF(expandBuffer);

        //ExpandEnvironmentStrings return number of bytes(ANSI) or
        //number of character(UNICODE) including the NULL character
        if (ExpandEnvironmentStrings(aBufferPtr, expandBuffer, expandBufferSize) > 0) {
          _tcscpy(aBufferPtr, expandBuffer);
          }
        }

      bGotValue = TRUE;
      }
    }

  return(bGotValue);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID, 
//                          DWORD aAllowedTypes, 
//                          DWORD * aTypePtr, 
//                          LPBYTE aReturnBuffer, 
//                          DWORD * aBufferSizePtr);
//
// Description: This function reads the registry value identified by
//              aDataItemID. This function can read any type of registry value
//              but the value must match that identified in the RegField
//              description for this field.
//              
//              For example, if aDataItemID is eREG_UPS_OPTIONS (=7), the
//              RegField at index 7 in g_upsRegFields identifies the required
//              registry information. The RegField identifies that the registry
//              key is HKLM\SYSTEM\CurrentControlSet\Services\UPS and the
//              value name is Options and it's of type DWORD. This function
//              will succeed only if it's called with an aAllowedTypes value
//              equal to REG_DWORD.
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried.
//
//   DWORD aAllowedTypes :- This identifies the allowed type of the registry
//                          data. The registry value types are not bit value
//                          that can be |'d (the types are sequentially
//                          numbered 0, 1, 2, 3, 4, not 0, 1, 2, 4, 8).
//                          However, the parameter is still called
//                          aAllowedTypes because we actually call the function
//                          with a value of REG_SZ | REG_EXPAND_SZ (1 | 2) to
//                          allow the same function to work if the value is
//                          either of these. Except for this case assume that
//                          the aAllowedTypes is actually aAllowedType.
//
//   DWORD * aTypePtr :- A pointer to the buffer that will receive the type.
//                       If the type is not required then this parameter can be
//                       set to NULL.
//
//   LPBYTE aReturnBuffer :- The buffer into which the data is to be placed.
//                           This parameter can be NULL in which case no data
//                           is retrieved.
//
//   DWORD * aBufferSizePtr :- This should point to a DWORD that contains the
//                             size of the buffer. This parameter cannot be
//                             NULL. When this function returns this value
//                             will contain the size actually required.
//
// Return Value: This function returns a Win32 error code, ERROS_SUCCESS on
//               success.
//
DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID,
                         DWORD aAllowedTypes,
                         DWORD * aTypePtr,
                         LPBYTE aReturnBuffer,
                         DWORD * aBufferSizePtr) {
  DWORD ret_val = ERROR_NO_MATCH;
  RegField * pRegField = GetRegField((DWORD) aDataItemID);

  if (pRegField != NULL ) {
		_ASSERT((pRegField->theValueType & aAllowedTypes) == pRegField->theValueType);

		ret_val = ReadRegistryValueData(pRegField->theRootKey,
																 pRegField->theKeyName,
																 pRegField->theValueName,
																 aAllowedTypes,
																 aTypePtr,
																 (LPTSTR) aReturnBuffer,
																 aBufferSizePtr);
  }

  return ret_val;
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD ReadRegistryValueData (HKEY aRootKey, 
//                              LPCTSTR aKeyName, 
//                              LPCTSTR aValueName, 
//                              DWORD aAllowedTypes, 
//                              DWORD * aTypePtr, 
//                              LPTSTR aReturnBuffer, 
//                              DWORD * aBufferSizePtr);
//
// Description: 
//
// Additional Information: 
//
// Parameters:
//
//   HKEY aRootKey :- A handle to an open registry key.
//
//   LPCTSTR aKeyName :- The name of the key relative to the open key.
//
//   LPCTSTR aValueName :- The name of the value to read
//
//   DWORD aAllowedTypes :- See help on ReadRegistryValue.
//
//   DWORD * aTypePtr :- A pointer to the buffer that will receive the type.
//                       If the type is not required then this parameter can be
//                       set to NULL.
//
//   LPBYTE aReturnBuffer :- The buffer into which the data is to be placed.
//                           This parameter can be NULL in which case no data
//                           is retrieved.
//
//   DWORD * aBufferSizePtr :- This should point to a DWORD that contains the
//                             size of the buffer. This parameter cannot be
//                             NULL. When this function returns this value
//                             will contain the size actually required.
//
// Return Value: This function returns a Win32 error code, ERROS_SUCCESS on
//               success.
//
DWORD ReadRegistryValueData (HKEY aRootKey,
                             LPCTSTR aKeyName,
                             LPCTSTR aValueName,
                             DWORD aAllowedTypes,
                             DWORD * aTypePtr,
                             LPTSTR aReturnBuffer,
                             DWORD * aBufferSizePtr) {
  DWORD nType = 0;
  DWORD errCode = ERROR_INVALID_PARAMETER;
  HKEY hOpenKey = NULL;

  if ((errCode = RegOpenKeyEx(aRootKey,
                              aKeyName,
                              0,
                              KEY_READ,
                              &hOpenKey)) == ERROR_SUCCESS) {

    _ASSERT(hOpenKey != NULL);

    //Key exists and is now open

    if ((errCode = RegQueryValueEx(hOpenKey,
                                   aValueName,
                                   NULL,
                                   &nType,
                                   (LPBYTE) aReturnBuffer,
                                   aBufferSizePtr)) == ERROR_SUCCESS) {
      if (aTypePtr != NULL) {
        *aTypePtr = nType;
        }

      if ((nType & aAllowedTypes) == 0) {
        //The value type in the registry does not match the expected
        //type for this function call.
        _ASSERT(FALSE);
        }

      if ((aReturnBuffer != NULL) && (*aBufferSizePtr == 1)) {
        //If the registry entry was in fact empty, the buffer needs to
        //be 1 character, for the NULL termination.
        *aReturnBuffer = TEXT('\0');
        }
      }
    else {
      //Something prevented us from reading the value.
      //The value may not exist, the buffer size might
      //not be large enough. May be using the function to
      //read a DWORD value on a registry value that is a
      //shorter string.

      if (errCode == ERROR_MORE_DATA) {
        //There is most likely a mismatch between the type we expect
        //and the actual type of this registry value.
        _ASSERT(FALSE);
        }
      }

    RegCloseKey(hOpenKey);
    }

  return(errCode);
  }



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\upssers.h ===
/*
 *
 * NOTES:
 *
 * REVISIONS:
 *  ker01DEC92:  Initial break out of sensor classes into separate files 
 *
 */
#ifndef UPSSERS_H
#define UPSSERS_H

#include "sensor.h"

_CLASSDEF(UpsSerialNumberSensor)

class UpsSerialNumberSensor : public Sensor {
   
public:
   UpsSerialNumberSensor(PDevice aParent, PCommController aCommController=NULL);
   virtual INT IsA() const { return UPSSERIALNUMBERSENSOR; };
   
};

 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\w32utils.h ===
/*
*
* NOTES:
*
* REVISIONS:
*  pam15Jul96: Initial creation
*  srt19Dec96: Added GetNtComputerName
*  tjg05Sep97: Added GetVersionInformation function
*  tjg16Dec97: Added GetRegistryValue function
*/

#ifndef __W32UTILS_H
#define __W32UTILS_H

#include "_defs.h"

#define SET_BIT(byte, bitnum)    (byte |= ( 1L << bitnum ))
#define CLEAR_BIT(byte, bitnum)  (byte &= ~( 1L << bitnum ))


INT UtilSelectProcessor(void *hCurrentThread);

enum tWindowsVersion{eUnknown, eWin31, eWinNT, eWin95};
tWindowsVersion GetWindowsVersion();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\utils.h ===
/*
 * REVISIONS: 
 */

#ifndef _INC__UTILS_H
#define _INC__UTILS_H


#include "cdefine.h"
#include "apc.h"

extern "C" {
#include <sys/types.h>
}

#define LESS_THAN -1
#define GREATER_THAN 1
#define EQUAL 0

char* getPwrchuteDirectory();

//
// By defining initial values to max values in the opposite
// direction we are guarenteed the first value will reset
// the max/min value
//

#if (C_OS & (C_OS2 | C_NT | C_NLM | C_UNIX))
#ifndef MINFLOAT
#define MINFLOAT  ((float)3.4e-34)
#endif
#ifndef MAXFLOAT
#define MAXFLOAT  ((float)3.4e+34)
#endif
#endif

#define INITIAL_MAX_VALUE  MINFLOAT
#define INITIAL_MIN_VALUE  MAXFLOAT

VOID UtilStoreString(PCHAR& destination, const PCHAR source);
INT UtilHexStringToInt(PCHAR aString);
INT UtilHexCharToInt(CHAR ch);
INT UtilTime12to24(PCHAR a12Value, PCHAR a24Value);
INT UtilDayToDayOfWeek(PCHAR aDay);
PCHAR UtilDayOfWeekToDay(INT aDayOfWeek);   
 
INT Remove(PCHAR filename);
PCHAR GetServerByAddress(PCHAR aServer);
PCHAR GetIPByName(PCHAR aServer);
INT IsIPAddress(CHAR *str);
INT UtilCheckIniFilePath(PCHAR aPath, INT aCode, PCHAR aRoot);
// @@@ start
PCHAR GetNewUPSName(PCHAR currentName);
INT APCLoadLibrary(PCHAR libraryName);
INT APCLoadString(UINT rid,LPTSTR buffer, INT buffersize);
CHAR * const GetResourceString(INT rid);
BOOL APCFreeLibrary(void);
INT SetTimeZone(void);
// @@@ end

INT ApcStrIntCmpI(PCHAR aStr1, PCHAR aStr2);
BOOLEAN IsEmpty(PCHAR aString);

#if(C_OS & (C_WIN311 | C_WINDOWS | C_NT | C_SUNOS4 | C_IRIX))
// MAA, added because MSC def's max and min
#ifndef max
float max(float a, float b);
#endif
#ifndef min
float min(float a, float b);
#endif
#endif

#if (C_OS & C_UNIX)             
PCHAR itoa(INT, PCHAR, INT);
PCHAR strupr(PCHAR);
PCHAR ltoa(LONG,PCHAR,INT);
PCHAR clip_string(INT,PCHAR,INT);
ULONG MilliToMicro(ULONG);
VOID  Wait(ULONG);
INT   strcmpi (PCHAR cbuffer,PCHAR target);
INT   strnicmp (PCHAR cbuffer,PCHAR target,INT len);
VOID  FormatTimeStruct(ULONG milli_sec_timeout, struct timeval *tstruct);
INT   GetUnixHostName(PCHAR buffer,INT bufferSize);


PCHAR clip_string(INT,PCHAR,INT);
VOID  System(char *exec_string ...);


// The following in English means :-
// if not AIX version 4
// and not SOLARIS 2.x
// and not HP-UX version 10
// then define the abs macro.
//         poc25Jun96
//
#if (!((C_OS & C_AIX) && (C_AIX_VERSION & C_AIX4)) && !(C_OS & C_SOLARIS2) && !((C_OS & C_HPUX) && (C_HP_VERSION & C_HPUX10)))
#define	abs(x)			((x) >= 0 ? (x) : -(x))
#endif

#if !((C_OS & C_AIX) && (C_AIX_VERSION & C_AIX4))
#ifndef max
#define	max(a, b) 		((a) < (b) ? (b) : (a))
#define	min(a, b) 		((a) > (b) ? (b) : (a))
#endif
#endif
#endif

int IsIPString(char *test_string);

#if (C_OS & C_SUNOS4) 
#define        FD_ZERO(p)      memset((char *)(p), 0, sizeof (*(p)))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\utils.cxx ===
/* 
*
* REFERENCES:
*
* NOTES:
*
* REVISIONS:
*
*  v-stebe  29Jul2000   Fixed PREfix errors (bugs #46359-#46361, #112601)
*/


// Needed for open system call 
#include "cdefine.h"
#include "utils.h"
#include "cfgmgr.h"


//#include "registry.h"
#include "w32utils.h"

#include <stdio.h>
#include <stdlib.h>
#include <time.h>


INT UtilHexCharToInt(char ch)
{
    INT int_value = 0;
    
    if(isxdigit(ch))  {
        if(isdigit(ch))  {
            int_value = ch - '0';
        }
        else  {
            int_value = 10 + toupper(ch) - 'A';
        }
    }
    return int_value;
}




INT UtilHexStringToInt(PCHAR aString) {
    /* The thinking man's approach to Hex string conversion... */
    return((INT)strtoul(aString,(PCHAR*)NULL,16));
}


VOID UtilStoreString(PCHAR& destination, const PCHAR source)
{
    if (!source) {
        
        if (destination) free (destination);
        
        destination = (PCHAR)NULL;
    }
    else if (!destination)  {
        destination = _strdup(source);
    }
    else  {
        
        if(strlen(destination) < strlen(source))  {
            free(destination);
            destination = _strdup(source);
        }
        else  {
            strcpy(destination, source);
        }
    }
}


INT UtilTime12to24(PCHAR a12Value, PCHAR a24Value)
{
    INT err = ErrNO_ERROR;
    
    PCHAR temp_string=_strdup(a12Value);
    
    PCHAR tok_string=strtok(temp_string, ":");
    if(tok_string)  {
        CHAR hour[32], minute[32];
        strcpy(hour, tok_string);
        
        tok_string=strtok(NULL, " ");
        if (tok_string) {
          strcpy(minute, tok_string);
        }
        else {
          strcpy(minute, "00");
        }
        
        CHAR hour_str[32];
        if(tok_string) {
            tok_string=strtok(NULL," ");
            if(tok_string) {
                INT hour_val = atoi(hour);
                if((*tok_string == 'p') || (*tok_string == 'P'))  {
                    if(hour_val != 12)  {
                        hour_val = hour_val + 12;
                    }
                }
                else {
                    if(hour_val == 12)  {
                        hour_val = 0;
                    }
                }
                sprintf(hour_str, "%d", hour_val);
            }
            else {
                strcpy(hour_str, hour);
            }
        }
        sprintf(a24Value, "%s:%s", hour_str, minute);
    }
    else {
        err = ErrBAD_RESPONSE_VALUE;
    }
    
    free(temp_string);
    return err;
}


struct dayConversions {
    PCHAR day;
    INT dayOfWeek;
};

struct dayConversions day_conversions[7] = 
{
    {"Sunday", 0},
    {"Monday", 1},
    {"Tuesday", 2},
    {"Wednesday", 3},
    {"Thursday", 4},
    {"Friday", 5},
    {"Saturday", 6}
};


INT UtilDayToDayOfWeek(PCHAR aDay)
{
    INT day_num = 0;
    for(INT i=0; i<7; i++)  {
        if(_strcmpi(day_conversions[i].day, aDay) == 0) {
            day_num = i;
            break;
        }
    }
    return day_num;
}


PCHAR UtilDayOfWeekToDay(INT aDayOfWeek)
{
    return day_conversions[aDayOfWeek].day;;
}





/********************************************************************
Function: ApcStrIntCmpI
Parameters: 
1. String 
2. String to compare against
Purpose:
This function converts two strings into their UpperCase 
equivalent and then compares them.  The special feature of this
function is that it actually compares the numbers within the 
strings.  For example, using this function a1400 would be 
greater than a600.  This function was implemented, because 
strcmpi did not take care of this case.  Additionally, NULLs are 
checked, so this function can be called on NULL pointers, and it 
will not crash.
Return Values: 
GREATER_THAN (1) -- string 1 is greater than string 2
EQUAL (0) -- string 1 is equal to string 2
LESS_THAN (-1) -- string 1 is less than string 2
********************************************************************/
INT ApcStrIntCmpI(PCHAR aStr1, PCHAR aStr2){
    
    const cMaxNumString = 10;
    INT ret_value = EQUAL;
    
    // if both strings are empty
    if(IsEmpty(aStr1) && IsEmpty(aStr2)){
        ret_value = EQUAL;
    }
    // else if string1 is present and string2 is empty then
    // string1 > string2
    else if(!IsEmpty(aStr1) && IsEmpty(aStr2)){
        ret_value = GREATER_THAN;
    }
    // else if string1 is empty and string2 is present then
    // string1 < string2
    else if(IsEmpty(aStr1) && !IsEmpty(aStr2)){
        ret_value = LESS_THAN;   
    }
    else{
        INT str1_index = 0;
        INT str2_index = 0;
        
        // continue_loop will be used to control the following while loop
        BOOLEAN continue_loop = TRUE;
        
        while(continue_loop){
            // Initialize characters for comparison. Note that a toupper 
            // function is called because we want to make sure that we are 
            // comparing only UPPERCASE characters.
            CHAR char1 = (CHAR) toupper(aStr1[str1_index]);
            CHAR char2 = (CHAR) toupper(aStr2[str2_index]);
            
            // if both characters are NULL then the strings are equal
            if(char1 == NULL && char2 == NULL){
                ret_value = EQUAL;
                continue_loop = FALSE;
            }
            // else if char2 is NULL, then char1 > char2
            else if(char1 != NULL && char2 == NULL){
                ret_value = GREATER_THAN;
                continue_loop = FALSE;
            }
            // else if char1 is NULL, then char1 < char2
            else if(char1 == NULL && char2 != NULL){
                ret_value = LESS_THAN;
                continue_loop = FALSE;
            }
            // else we must have two non-NULL characters
            else{
                // if both characters are digits or numbers then,
                // build up a number string
                if(isdigit(char1) && isdigit(char2)){
                    
                    CHAR num1_str[cMaxNumString];
                    CHAR num2_str[cMaxNumString];
                    memset(num1_str,NULL,cMaxNumString);
                    memset(num2_str,NULL,cMaxNumString);
                    INT num1_index = 0;
                    INT num2_index = 0;
                    
                    // while char1 is a number, build number string
                    while(isdigit(char1)){
                        num1_str[num1_index] = char1;
                        num1_index++;
                        str1_index++;
                        char1 = (CHAR) toupper(aStr1[str1_index]);
                    }
                    
                    // while char2 is a number, build number string
                    while(isdigit(char2)){
                        num2_str[num2_index] = char2;
                        num2_index++;
                        str2_index++;
                        char2 = (CHAR) toupper(aStr2[str2_index]);
                    }
                    
                    // Convert number strings to actual numbers to compare 
                    INT number1 = atoi(num1_str);
                    INT number2 = atoi(num2_str);
                    
                    if(number1 < number2){
                        ret_value = LESS_THAN;
                        continue_loop = FALSE;
                    }
                    else if(number1 > number2){
                        ret_value = GREATER_THAN;
                        continue_loop = FALSE;
                    }
                }
                else if(char1 < char2){
                    ret_value = LESS_THAN;
                    continue_loop = FALSE;
                }
                else if(char1 > char2){
                    ret_value = GREATER_THAN;
                    continue_loop = FALSE;
                }
                else{
                    // increment indicies
                    str1_index++;
                    str2_index++;
                }
            }
        }
    }
    return ret_value;
}



/********************************************************************
Function: IsEmpty()
Parameters: 
1. String
Purpose:
This function is used to determine if a string is empty or not.
It assumes that an empty string can be either NULL or if the
[0] element of the string is NULL.  
Return Values: 
TRUE (1) - if the string is empty
FALSE (0) - if the string is not empty
********************************************************************/
BOOLEAN IsEmpty(PCHAR aString){
    
    BOOLEAN ret_value = FALSE;
    
    if(aString == NULL || aString[0] == NULL){
        ret_value = TRUE;
    }
    
    return ret_value;
}

// @@@ start
/* -------------------------------------------------------------------------

  NAME:  GetNewUPSName

  DESCRIPTION:  This function will accept the name of the UPS which is 
                retrieved from the UPS itself, and will load the corresponding
                name from pwrchute.ini, if the language of the OS
                exists in the list under the country_list in pwrchute.ini.
 
  INPUTS :  1 - Name of the UPS

  OUTPUTS : 1 - Returns a pointer to the UPS name loaded from the ini
                file.
----------------------------------------------------------------------------
*/
PCHAR GetNewUPSName(PCHAR currentName)
{
    static CHAR new_name[128];

    if (currentName!=NULL) {
      currentName = _strupr(currentName);
      strcpy(new_name,currentName);
    }

    return new_name;
}









/* -------------------------------------------------------------------------

  NAME:  SetTimeZone

  DESCRIPTION:  This sets the following global timezone variables, _timezone, 
                _daylight and _tzname[0], _tzname[1].  This retrieves timezone
                information from the system and sets the above variables based
                on this information.  These variables are used in calls to 
                localtime, if they are not set correctly localtime may return the
                incorrect time when daylight savings should be used.
                This code is taken from _tzset();
 
  INPUTS :  None

  OUTPUTS :  0 - Successful
            -1 - GetTimeZoneInformation() call failed

----------------------------------------------------------------------------
*/
INT SetTimeZone() {

    TIME_ZONE_INFORMATION lpInfo;
    DWORD tZoneId = 0;
    INT returnValue = 0; 
	

    tZoneId = GetTimeZoneInformation( &lpInfo );
    if (tZoneId == -1) {
        returnValue = -1;
    }
    
    // set the global _timezone variable
	_timezone = lpInfo.Bias * 60L;

    if ( lpInfo.StandardDate.wMonth != 0 ) {
          _timezone += (lpInfo.StandardBias * 60L);
	}
    if ( (lpInfo.DaylightDate.wMonth != 0) &&(lpInfo.DaylightBias != 0) ) {
        _daylight = 1;
        _dstbias = (lpInfo.DaylightBias - lpInfo.StandardBias) * 60L;
    }
    else {
        _daylight = 0;
    }
    /*
    * Try to grab the name strings for both the time zone and the
    * daylight zone.
    */
    wcstombs( _tzname[0], lpInfo.StandardName, 64 );
    wcstombs( _tzname[1], lpInfo.DaylightName, 64 );
    (_tzname[0])[63] = (_tzname[1])[63] = '\0';

    return returnValue;

}        
    // @@@ end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\_defs.h ===
/*
 * REFERENCES:
 *
 * NOTES:
 *
 * REVISIONS:
 * ajr08Mar93: modified to handle unix....
 * rct05Nov93: made _Cdecl definition conditional
 * dpf24May94: added C_WINDOWS
 */

#if !defined( __DEFS_H )
#define __DEFS_H

#ifndef _Cdecl
#  if __STDC__
#     define _Cdecl
#  else
#     ifdef __OS2__
#        define _Cdecl  _stdcall
#     else
#        define _Cdecl  cdecl
#     endif
#  endif
#endif

#ifndef __PAS__
#  define _CType _Cdecl
#else
#  define _CType pascal
#endif

#if (C_OS & (C_OS2 | C_NLM | C_UNIX | C_NT ))
#  define _FAR
#  define _FARFUNC
#  define _CLASSTYPE                       
#elif (C_OS & (C_WIN311 | C_WINDOWS))
#  define _FAR far
#  define _FARFUNC EXPORT
#  define _CLASSTYPE 
#else
#  if defined(__STDC__)
#    define _FAR
#    define _FARFUNC
#    define _CLASSTYPE
#  else
#    if defined(_BUILDRTLDLL)
#      define _FARFUNC _export
#    elif defined(_RTLDLL)
#      define _FARFUNC far
#    else
#      define _FARFUNC
#    endif
#    if defined(__DLL__)
#      if defined(_RTLDLL) || defined(_CLASSDLL)
#        define _CLASSTYPE _export
#      else
#        define _CLASSTYPE far
#      endif
#      define _FAR far
#    elif defined(_RTLDLL) || defined(_CLASSDLL)
#      define _CLASSTYPE huge
#      define _FAR far
#    else
#      define _FAR
#      if   defined(__TINY__) || defined(__SMALL__) || defined(__MEDIUM__)
#        define _CLASSTYPE  near
#      elif defined(__COMPACT__) || defined(__LARGE__)
#        define _CLASSTYPE  far
#      else
#        define _CLASSTYPE  huge
#      endif
#    endif
#  endif    /* __STDC__ */
#endif      /* __OS2__  */

#if defined(_BUILDRTLDLL)
#  define _FARCALL _export
#else
#  define _FARCALL far
#endif

#if defined( __cplusplus )
#  define _PTRDEF(name) typedef name _FAR * P##name;
#  define _REFDEF(name) typedef name _FAR & R##name;
#  define _REFPTRDEF(name) typedef name _FAR * _FAR & RP##name;
#  define _PTRCONSTDEF(name) typedef const name _FAR * PC##name;
#  define _REFCONSTDEF(name) typedef const name _FAR & RC##name;
#  define _CLASSDEF(name) class _CLASSTYPE name; \
        _PTRDEF(name) \
    _REFDEF(name) \
    _REFPTRDEF(name) \
    _PTRCONSTDEF(name) \
    _REFCONSTDEF(name)
#endif

#endif  /* __DEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\cmdexe.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file implements the CommandExecutor.  The CommandExecutor
 *   is responsible for executing command just prior to shutdown.
 *
 *
 * Revision History:
 *   sberard    01Apr1999  initial revision.
 *   mholly     16Apr1999  run old command file if task is invalid
 *   v-stebe    23May2000  add check to the return value of CoInitialize() (bug #112597)
 *
 */ 
#define INITGUID
#include <mstask.h>

#include "cmdexe.h"
#include "upsreg.h"


static BOOL runOldCommandFile();


#ifdef __cplusplus
extern "C" {
#endif


/**
* ExecuteShutdownTask
*
* Description:
*   This function initiates the execution of the shutdown task.  The
*   shutdown task is used to execute commands at shutdown.  The task
*   to execute is specified in the following registry key:
*     HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\UPS\Config\TaskName
*
* Parameters:
*   none
*
* Returns:
*   TRUE  - if the command was executed
*   FALSE - if there was an error executing the command
*/

BOOL ExecuteShutdownTask() {
    BOOL ret_val = FALSE;
    TCHAR task_name[MAX_PATH];
    DWORD task_name_len = sizeof(task_name);
    HRESULT hr;
    ITaskScheduler *task_sched; 
    ITask *shutdown_task;
    
    InitUPSConfigBlock();
    
    // Get the name of the Task to run from the registry
    if (GetUPSConfigTaskName((LPTSTR) &task_name) == ERROR_SUCCESS) {
        
        // Initialize COM
        if (CoInitialize(NULL) == S_OK) {
        
			// Get a handle to the ITaskScheduler COM Object
			hr = CoCreateInstance(&CLSID_CSchedulingAgent, 
				NULL, 
				CLSCTX_INPROC_SERVER,
				&IID_ISchedulingAgent, 
				(LPVOID *)&task_sched);

			if (hr == S_OK) {
            
				if (task_sched->lpVtbl->Activate(task_sched, task_name, &IID_ITask, 
					(IUnknown**)&shutdown_task) == S_OK) {
                
					shutdown_task->lpVtbl->Run(shutdown_task);
                
					// Release the instance of the task
					shutdown_task->lpVtbl->Release(shutdown_task);
                
					ret_val = TRUE;
				}
				else {
					ret_val = runOldCommandFile();
				}
			}        
			// Uninitialize COM
			CoUninitialize();
		}
		else {
			// There was an error initializing COM (probably out of mem.)
			ret_val = FALSE;
		}
    }
    else {
        ret_val = runOldCommandFile();
    }
    return ret_val;
}

// UPS Service Registry values
#define REGISTRY_UPS_DIRECTORY          L"System\\CurrentControlSet\\Services\\UPS"
#define REGISTRY_COMMAND_FILE           L"CommandFile"

DWORD UpsRegistryGetString(LPTSTR SubKey, LPTSTR Buffer, DWORD BufferSize)
{
    DWORD status;
    DWORD type;
	HKEY RegistryKey;
    
    status = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGISTRY_UPS_DIRECTORY,
        0,
        KEY_READ,
        &RegistryKey);
    
    if (ERROR_SUCCESS == status) {
        status = RegQueryValueEx(
            RegistryKey,
            SubKey,
            NULL,
            &type,             
            (LPBYTE)Buffer,
            &BufferSize);

        RegCloseKey(RegistryKey);
    }
    return status;
}


BOOL runOldCommandFile()
{
    PROCESS_INFORMATION ProcessInformation;
    STARTUPINFO         StartupInfo;
    BOOL                success;
    DWORD               status;
    TCHAR               command_file[_MAX_PATH];

    status = UpsRegistryGetString(REGISTRY_COMMAND_FILE, 
        command_file, sizeof(command_file));

    if (ERROR_SUCCESS != status) {
        //
        // there isn't a command file configured
        // so just exit now reporting that we did
        // not run anything
        //
        return FALSE;
    }

    GetStartupInfo(&StartupInfo);
    StartupInfo.lpTitle = NULL;

    success = CreateProcess(
            NULL,               //  image name is imbedded in the command line
            command_file,       //  command line
            NULL,               //  pSecAttrProcess
            NULL,               //  pSecAttrThread
            FALSE,              //  this process will not inherit our handles
            0,                  //  dwCreationFlags
            NULL,               //  pEnvironment
            NULL,               //  pCurrentDirectory
            &StartupInfo,
            &ProcessInformation
            );
    return success;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\cmdexe.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file defines the interface to the CommandExecutor. The
 *   CommandExecutor is reponsible for executing command just
 *   prior to shutdown.
 *
 *
 * Revision History:
 *   sberard  01Apr1999  initial revision.
 *
 */ 

#include <windows.h>

#ifndef _CMDEXE_H
#define _CMDEXE_H


#ifdef __cplusplus
extern "C" {
#endif

  /**
   * ExecuteShutdownTask
   *
   * Description:
   *   This function initiates the execution of the shutdown task.  The
   *   shutdown task is used to execute commands at shutdown.  The task
   *   to execute is specified in the following registry key:
   *				TBD_TBD_TBD
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   TRUE  - if the command was executed
   *   FALSE - if there was an error executing the command
   */
  BOOL ExecuteShutdownTask();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\driver.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *  Implements the UPS to the service - it does this by
 *  either loading a UPS driver or by using the default
 *  Generic UPS interface (simple signalling)
 *
 * Revision History:
 *   mholly  19Apr1999  initial revision.
 *   dsmith  29Apr1999  defaulted comm status to OK
 *   mholly  12May1999  DLL's UPSInit no longer takes the comm port param
 *   sberard 17May1999	added a delay to the UPSTurnOffFunction
 *
*/ 

#include <windows.h>
#include <tchar.h>

#include "driver.h"
#include "upsreg.h"
#include "gnrcups.h"


//
// typedefs of function pointers to aid in
// accessing functions from driver DLLs
//
typedef DWORD (*LPFUNCGETUPSSTATE)(void);
typedef void (*LPFUNCWAITFORSTATECHANGE)(DWORD, DWORD);
typedef void (*LPFUNCCANCELWAIT)(void);
typedef DWORD (*LPFUNCINIT)(void);
typedef void (*LPFUNCSTOP)(void);
typedef void (*LPFUNCTURNUPSOFF)(DWORD);


//
// UPSDRIVERINTERFACE
//
//  this struct is used to gather all the driver
//  interface data together in a single place, this
//  struct is used to dispatch function calls to
//  either a loaded driver dll, or to the Generic
//  UPS interface functions
//  
struct UPSDRIVERINTERFACE
{
    LPFUNCINIT Init;
    LPFUNCSTOP Stop;
    LPFUNCGETUPSSTATE GetUPSState;
    LPFUNCWAITFORSTATECHANGE WaitForStateChange;
    LPFUNCCANCELWAIT CancelWait;
    LPFUNCTURNUPSOFF TurnUPSOff;

    HINSTANCE hDll;
};


//
// private functions used to implement the interface
//
static DWORD initializeGenericInterface(struct UPSDRIVERINTERFACE*);
static DWORD initializeDriverInterface(struct UPSDRIVERINTERFACE*,HINSTANCE);
static DWORD loadUPSMiniDriver(struct UPSDRIVERINTERFACE *);
static void unloadUPSMiniDriver(struct UPSDRIVERINTERFACE *);
static void clearStatusRegistryEntries(void);


//
// _UpsInterface
//
//  This is a file-scope variable that is used by all
//  the functions to get access to the actual driver
//
static struct UPSDRIVERINTERFACE _UpsInterface;


/**
* UPSInit
*
* Description:
*   
*   The UPSInit function must be called before any
*   other function in this file
*
* Parameters:
*   None
*
* Returns:
*   UPS_INITOK: Initalization was successful
*   UPS_INITNOSUCHDRIVER:   The configured driver DLL can't be opened    
*   UPS_INITBADINTERFACE:   The configured driver DLL doesn't support 
*                           the UPS driver interface
*   UPS_INITREGISTRYERROR:  The 'Options' registry value is corrupt
*   UPS_INITCOMMOPENERROR:  The comm port could not be opened
*   UPS_INITCOMMSETUPERROR: The comm port could not be configured
*   UPS_INITUNKNOWNERROR:   Undefined error has occurred
*   
*/
DWORD UPSInit(void)
{
    DWORD init_err = UPS_INITOK;

    //
    // clear out any old status data
    //
    clearStatusRegistryEntries();

   
    if (UPS_INITOK == init_err) {
        //
        // either load a configured driver DLL or
        // use the Generic UPS interface if no driver
        // is specified
        //
        init_err = loadUPSMiniDriver(&_UpsInterface);
    }

    if ((UPS_INITOK == init_err) && (_UpsInterface.Init)) {
        //
        // tell the UPS interface to initialize itself
        //
        init_err = _UpsInterface.Init();
    }
    return init_err;
}


/**
* UPSStop
*
* Description:
*   After a call to UPSStop, only the UPSInit
*   function is valid.  This call will unload the
*   UPS driver interface and stop monitoring of the
*   UPS system
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSStop(void)
{
    if (_UpsInterface.Stop) {
        _UpsInterface.Stop();
    }
    unloadUPSMiniDriver(&_UpsInterface);
}


/**
* UPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*   
*/
void UPSWaitForStateChange(DWORD aCurrentState, DWORD anInterval)
{
    if (_UpsInterface.WaitForStateChange) {
        _UpsInterface.WaitForStateChange(aCurrentState, anInterval);
    }
}


/**
* UPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD UPSGetState(void)
{
    DWORD err = ERROR_INVALID_ACCESS;

    if (_UpsInterface.GetUPSState) {
        err = _UpsInterface.GetUPSState();
    }
    return err;
}


/**
* UPSCancelWait
*
* Description:
*   interrupts pending calls to UPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSCancelWait(void)
{
    if (_UpsInterface.CancelWait) {
        _UpsInterface.CancelWait();
    }
}


/**
* UPSTurnOff
*
* Description:
*   Attempts to turn off the outlets on the UPS
*   after the specified delay.  This call must
*   return immediately.  Any work, such as a timer,
*   must be performed on a another thread.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void UPSTurnOff(DWORD aTurnOffDelay) 
{
    if (_UpsInterface.TurnUPSOff) {
        _UpsInterface.TurnUPSOff(aTurnOffDelay);
    }
}


/**
* initializeGenericInterface
*
* Description:
*   Fills in the UPSDRIVERINTERFACE struct with the functions
*   of the Generic UPS interface
*
* Parameters:
*   anInterface: the UPSDRIVERINTERFACE structure to
*               fill in - the struct must have been
*               allocated prior to calling this function
*
* Returns:
*   ERROR_SUCCESS
*   
*/
DWORD initializeGenericInterface(struct UPSDRIVERINTERFACE* anInterface)
{
    anInterface->hDll = NULL;
    anInterface->Init = GenericUPSInit;
    anInterface->Stop = GenericUPSStop;
    anInterface->GetUPSState = GenericUPSGetState;
    anInterface->WaitForStateChange = GenericUPSWaitForStateChange;
    anInterface->CancelWait = GenericUPSCancelWait;
    anInterface->TurnUPSOff = GenericUPSTurnOff;
    return ERROR_SUCCESS;
}


/**
* initializeDriverInterface
*
* Description:
*   Fills in the UPSDRIVERINTERFACE struct with the functions
*   of the loaded UPS driver DLL
*
* Parameters:
*   anInterface: the UPSDRIVERINTERFACE structure to
*               fill in - the struct must have been
*               allocated prior to calling this function
*   hDll: a handle to a UPS driver DLL
*
* Returns:
*   ERROR_SUCCESS: DLL handle was valid, and the DLL supports the
*                   UPS driver interface
*
*   !ERROR_SUCCESS: either the DLL handle is invalid - or the DLL
*                   does not fully support the UPS driver interface
*   
*/
DWORD initializeDriverInterface(struct UPSDRIVERINTERFACE * anInterface, 
                              HINSTANCE hDll)
{
    DWORD err = ERROR_SUCCESS;
    
    anInterface->hDll = hDll;

    anInterface->Init = 
        (LPFUNCINIT)GetProcAddress(hDll, "UPSInit");

	if (!anInterface->Init) {
		err = GetLastError();
        goto init_driver_end;
	}    
    anInterface->Stop = 
        (LPFUNCSTOP)GetProcAddress(hDll, "UPSStop");

    if (!anInterface->Stop) {
		err = GetLastError();
        goto init_driver_end;
	}
    anInterface->GetUPSState = 
        (LPFUNCGETUPSSTATE)GetProcAddress(hDll, "UPSGetState");
    
	if (!anInterface->GetUPSState) {
		err = GetLastError();
        goto init_driver_end;
	}
    anInterface->WaitForStateChange = 
        (LPFUNCWAITFORSTATECHANGE)GetProcAddress(hDll, 
        "UPSWaitForStateChange");
    
	if (!anInterface->WaitForStateChange) {
		err = GetLastError();
        goto init_driver_end;
	}
    anInterface->CancelWait = 
        (LPFUNCCANCELWAIT)GetProcAddress(hDll, "UPSCancelWait");
    
	if (!anInterface->CancelWait) {
		err = GetLastError();
        goto init_driver_end;
	}
    anInterface->TurnUPSOff = 
        (LPFUNCTURNUPSOFF)GetProcAddress(hDll, "UPSTurnOff");
    
	if (!anInterface->TurnUPSOff) {
		err = GetLastError();
        goto init_driver_end;
	}

init_driver_end:
    return err;
}


/**
* loadUPSMiniDriver
*
* Description:
*   Fills in the UPSDRIVERINTERFACE struct with the functions
*   of a UPS interface, either a configured driver DLL or the
*   Generic UPS interface.  If the configured DLL can't be 
*   opened or does not support the interface then an error is
*   returned and the UPSDRIVERINTERFACE will not be initialized
*
* Parameters:
*   anInterface: the UPSDRIVERINTERFACE structure to
*               fill in - the struct must have been
*               allocated prior to calling this function
*
* Returns:
*   UPS_INITOK: driver interface is intialized
*
*   UPS_INITNOSUCHDRIVER: the configured driver DLL can't be opened
*   UPS_INITBADINTERFACE: the configured driver DLL does not
*                         fully support the UPS driver interface
*   
*/
DWORD loadUPSMiniDriver(struct UPSDRIVERINTERFACE * aDriverInterface)
{
    DWORD load_err = UPS_INITOK;
    DWORD err = ERROR_SUCCESS;
    TCHAR driver_name[MAX_PATH];
    HINSTANCE hDll = NULL;
    
    err = GetUPSConfigServiceDLL(driver_name);
    
    //
    // check to see if there is a key, and that its
    // value is valid (a valid key has a value that
    // is greater than zero characters long)
    //
    if (ERROR_SUCCESS == err && _tcslen(driver_name)) {
        hDll = LoadLibrary(driver_name);
    }
    else {
        //
        // NO ERROR - simply means we use the
        //  internal generic UPS support
        //
        err = initializeGenericInterface(aDriverInterface);
        goto load_end;
    }
    
    if (!hDll) {
        //
        // the configured driver could not be opened
        //
        err = GetLastError();
        load_err = UPS_INITNOSUCHDRIVER;
        goto load_end;
    }
    
    err = initializeDriverInterface(aDriverInterface, hDll);
    
    if (ERROR_SUCCESS != err) {
        load_err = UPS_INITBADINTERFACE;
        goto load_end;
    }
    
load_end:
    return load_err;
}


/**
* unloadUPSMiniDriver
*
* Description:
*   unloads a driver DLL if one was opened, also clears
*   out the function dispatch pointers
*
* Parameters:
*   anInterface: the UPSDRIVERINTERFACE structure to
*               check for DLL info, and to clear
*
* Returns:
*   None
*   
*/
void unloadUPSMiniDriver(struct UPSDRIVERINTERFACE * aDriverInterface)
{
    if (aDriverInterface) {

        if (aDriverInterface->hDll) {
            FreeLibrary(aDriverInterface->hDll);
            aDriverInterface->hDll = NULL;
        }
        aDriverInterface->CancelWait = NULL;
        aDriverInterface->GetUPSState = NULL;
        aDriverInterface->Init = NULL;
        aDriverInterface->Stop = NULL;
        aDriverInterface->TurnUPSOff = NULL;
        aDriverInterface->WaitForStateChange = NULL;
    }
}


/**
* clearStatusRegistryEntries
*
* Description:
*   zeros out the registry status entries
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void clearStatusRegistryEntries(void)
{
    InitUPSStatusBlock();
    SetUPSStatusSerialNum(_TEXT(""));
    SetUPSStatusFirmRev(_TEXT(""));
    SetUPSStatusUtilityStatus(UPS_UTILITYPOWER_UNKNOWN);
    SetUPSStatusRuntime(0);
    SetUPSStatusBatteryStatus(UPS_BATTERYSTATUS_UNKNOWN);
	SetUPSStatusCommStatus(UPS_COMMSTATUS_OK);
    SaveUPSStatusBlock(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\apcsmart\w32utils.cxx ===
/*
*    This is a repository for the utility functions used by 32-bit
*    windows applications.
*
* REFERENCES:
*
* NOTES:
*
* REVISIONS:
*  pam15Jul96: Initial creation
*  srt25Oct96: Use GetComputerName if gethostname fails.
*  srt19Dec96: Added GetNtComputerName
*  tjg05Sep97: Added GetVersionInformation function
*  tjg16Dec97: Added GetRegistryValue function
*  tjg31Jan98: Added call to RegCloseKey in GetRegistryValue
*  tjg26Mar98: Return correct error from GetRegistryValue
*  mwh15Apr98: Update GetAvailableProtocols to look in _theConfigManager
*              for support of a protocol.  This allows a UPS service to
*              turn off TCP & SPX support if desired
*/

#include "cdefine.h"

#include <stdlib.h>
#include <stdio.h>

#include "w32utils.h"
#include "err.h"
#include "cfgmgr.h"

#define WF_WINNT            0x80000000

const char *NOT_FOUND_STR = "Not found";

/********************************************************************
UtilSelectProcessor
This routine determines what CPUs are available for the machine
PowerChute is running on.  If there are more than 1 processor,
we select the first processor as the target for PowerChute to
run on, and then set the process and all subsequent threads
to run on the same processor.
This is the fix to a problem we were having with PowerChute run-
ning on machines with more than 1 processor.
********************************************************************/

INT UtilSelectProcessor(HANDLE hCurrentThread)
{
    DWORD_PTR processMask, systemMask;
    HANDLE hCurrentProcess;
    INT err = ErrNO_ERROR;

    /*
    Get the handle ID of the PowerChute process
    */
    hCurrentProcess = GetCurrentProcess();

    /*
    Get the masked value of the processors available for our
    process to run on.
    */
    GetProcessAffinityMask(hCurrentProcess,
        &processMask,
        &systemMask);

    if (processMask > 0) {
        DWORD_PTR affinityMask = 0;
        DWORD_PTR processorMask = 0;
        INT processorCheck = 0, position = 1;
        DWORD_PTR processorBit;

        /*
        Check the mask of the available processors to find the
        first available processor to run on.  Stop checking
        once we find it.
        */
        processorMask = position;
        processorBit = processMask & processorMask;
        while ((processorBit != processorMask)
            && (position <= 32)) {
            processorMask = 1L << position;
            processorBit = processMask & processorMask;
        }

        /*
        Set the affinity mask to be the first available CPU.
        */
        if (position <= 32)
            SET_BIT(affinityMask, (position-1));
        else
            err = ErrNO_PROCESSORS;

            /*
            Set the thread to work on the first CPU available.
        */
        if (SetThreadAffinityMask(hCurrentThread, affinityMask) == 0)
            err = ErrNO_PROCESSORS;
    }
    else
        err = ErrNO_PROCESSORS;

    return err;
}






/********************************************************************
GetWindowsVersion
This routine checks to see what platform we are running on.
There is another (cleaner) way to do this (as seen in one of the
MSDN newsletters), but it is supported only on 95 and on NT 4.0
and later versions.  We will wait to implement that way.
********************************************************************/
tWindowsVersion GetWindowsVersion()
{

    DWORD win_ver = GetVersion();

    /*
    Determine if we are running in NT
    */
    if (win_ver < WF_WINNT)
        return eWinNT;

        /*
        Determine if we are running in Win 3.1 or Win95
    */
    else if (LOBYTE(LOWORD(win_ver)) < 4)
        return eWin31;
    else
        return eWin95;

    return eUnknown;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\driver.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *  Implements the UPS to the service - it does this by
 *  either loading a UPS driver or by using the default
 *  Generic UPS interface (simple signalling)
 *
 * Revision History:
 *   mholly  19Apr1999  initial revision.
 *
*/ 


#ifndef _INC_UPS_DRIVER_H_
#define _INC_UPS_DRIVER_H_


//
// values that represent the state of the
// UPS system - these values are used in the
// UPSGetState and UPSWaitForStateChange functions
//
#define UPS_ONLINE 1
#define UPS_ONBATTERY 2
#define UPS_LOWBATTERY 4
#define UPS_NOCOMM 8
#define UPS_CRITICAL 16


//
// possible error codes returned from UPSInit
//
#define UPS_INITUNKNOWNERROR    0
#define UPS_INITOK              1
#define UPS_INITNOSUCHDRIVER    2
#define UPS_INITBADINTERFACE    3
#define UPS_INITREGISTRYERROR   4
#define UPS_INITCOMMOPENERROR   5
#define UPS_INITCOMMSETUPERROR  6


/**
* UPSInit
*
* Description:
*   
*   The UPSInit function must be called before any
*   other function in this file
*
* Parameters:
*   None
*
* Returns:
*   UPS_INITOK: Initalization was successful
*   UPS_INITNOSUCHDRIVER:   The configured driver DLL can't be opened    
*   UPS_INITBADINTERFACE:   The configured driver DLL doesn't support 
*                           the UPS driver interface
*   UPS_INITREGISTRYERROR:  The 'Options' registry value is corrupt
*   UPS_INITCOMMOPENERROR:  The comm port could not be opened
*   UPS_INITCOMMSETUPERROR: The comm port could not be configured
*   UPS_INITUNKNOWNERROR:   Undefined error has occurred
*   
*/
DWORD UPSInit(void);


/**
* UPSStop
*
* Description:
*   After a call to UPSStop, only the UPSInit
*   function is valid.  This call will unload the
*   UPS driver interface and stop monitoring of the
*   UPS system
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSStop(void);


/**
* UPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*   
*/
void UPSWaitForStateChange(DWORD aCurrentState, DWORD anInterval);


/**
* UPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD UPSGetState(void);


/**
* UPSCancelWait
*
* Description:
*   interrupts pending calls to UPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSCancelWait(void);


/**
* UPSTurnOff
*
* Description:
*   Attempts to turn off the outlets on the UPS
*   after the specified delay.  This call must
*   return immediately.  Any work, such as a timer,
*   must be performed on a another thread.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void UPSTurnOff(DWORD aTurnOffDelay);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\eventlog.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file implements EventLogger.  The  EventLogger is reponsible 
 *   for logging information to the NT machine's System Event Log.
 *
 *
 * Revision History:
 *   sberard  29Mar1999  initial revision.
 *
 */ 

#include "eventlog.h"

#ifdef __cplusplus
extern "C" {
#endif

  static HANDLE _theUpsEventLogger = NULL;


  /**
   * LogEvent
   *
   * Description:
   *   This function is responsible for logging information to the NT machine's
   *   System Event log.  The Event to log is specified by the parameter 
   *   anEventId, which is defined in the file lmerrlog.h.  The anInfoStr
   *   parameter is used to specify additional information to be merged with 
   *   the Event message.
   *
   * Parameters:
   *   anEventId - the id of the Event to log 
   *   anInfoStr - additional information to merge with the message
   *               or NULL if there is no additional information.
   *   anErrVal - the error code as reported by GetLastError().
   *
   * Returns:
   *   TRUE  - if the Event was logged successfully
   *   FALSE - if there was an error logging the Event
   *   
   */
  BOOL LogEvent(DWORD anEventId, LPTSTR anInfoStr, DWORD anErrVal) {
    BOOL    ret_val = FALSE;
    WORD    event_type;        //  type of event
    LPTSTR  info_strings[1];   //  array of strings to merge with the message
    WORD    num_strings;       //  count of insertion strings
    LPTSTR *ptr_strings;       //  pointer to array of insertion strings
    DWORD   data_size;         //  count of data (in bytes)
    LPVOID  ptr_data;          //  pointer to data

    if (_theUpsEventLogger == NULL) {
      _theUpsEventLogger =  RegisterEventSource(NULL, SZSERVICENAME);
    }


    if (anEventId > ERRLOG_BASE) {
      event_type = EVENTLOG_WARNING_TYPE;
    }
    else {
      event_type = EVENTLOG_ERROR_TYPE;
    }

    // If the error value is anything other than ERROR_SUCCESS, add it
    // to the Event
    if (anErrVal == ERROR_SUCCESS) {
        ptr_data = NULL;
        data_size = 0;
    } else {
        ptr_data = &anErrVal;
        data_size = sizeof(anErrVal);
    }

    // Append any additional strings to the Event message.
    if (anInfoStr == NULL) {
        ptr_strings = NULL;
        num_strings = 0;
    } else {
        info_strings[0] = anInfoStr;
        ptr_strings = info_strings;
        num_strings = 1;
    }

     // Log the Event to the System Event log
    if (ReportEvent(
          _theUpsEventLogger,           //  handle
          event_type,                   //  event type
          0,                            //  event category,
          anEventId,                    //  message id
          NULL,                         //  user id   
          num_strings,                  //  number of strings
          data_size,                    //  number of data bytes
          ptr_strings,                  //  array of strings
          ptr_data                      //  data buffer
          )) {
      ret_val = TRUE;
    }
    else {
      // an error occured, return FALSE
      ret_val = FALSE;
    }

    return ret_val;
  }


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\events.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   Internal Service Events for the State Machine
 *
 * Revision History:
 *   dsmith  31Mar1999  Created
 *   sberard 14May1999	Added hibernation events
 */

#ifndef _INC_EVENTS_H_
#define _INC_EVENTS_H_


////////////////////////////////////////////////////
// Internal Service Events for the State Machine
////////////////////////////////////////////////////

#define NO_EVENT										-1
#define INITIALIZATION_COMPLETE 		0
#define LOST_COMM 									1
#define POWER_FAILED								2
#define POWER_RESTORED							3
#define LOW_BATTERY 								4
#define ON_BATTERY_TIMER_EXPIRED		5
#define SHUTDOWN_ACTIONS_COMPLETED	6
#define SHUTDOWN_COMPLETE 					7
#define STOPPED 										8
#define RETURN_FROM_HIBERNATION 		9
#define HIBERNATION_ERROR 					10

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\eventlog.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file defines the interface to the EventLogger.  The 
 *   EventLogger is reponsible for logging information to the 
 *   NT machine's System Event Log.
 *
 *
 * Revision History:
 *   sberard  29Mar1999  initial revision.
 *
 */ 

#include <windows.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmerrlog.h>

#include "service.h"

#ifndef _EVENTLOG_H
#define _EVENTLOG_H


#ifdef __cplusplus
extern "C" {
#endif

  /**
   * LogEvent
   *
   * Description:
   *   This function is responsible for logging information to the NT machine's
   *   System Event log.  The Event to log is specified by the parameter 
   *   anEventId, which is defined in the file lmerrlog.h.  The anInfoStr
   *   parameter is used to specify additional information to be merged with 
   *   the Event message.
   *
   * Parameters:
   *   anEventId - the id of the Event to log 
   *   anInfoStr - additional information to merge with the message
   *               or NULL if there is no additional information.
   *   anErrVal - the error code as reported by GetLastError().
   *
   * Returns:
   *   TRUE  - if the Event was logged successfully
   *   FALSE - if there was an error logging the Event
   *   
   */
  BOOL LogEvent(DWORD anEventId, LPTSTR anInfoStr, DWORD anErrVal);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\gnrcups.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   Provides the interface to the generic UPS
 *
 * Revision History:
 *   mholly  19Apr1999  initial revision.
 *   mholly  12May1999  UPSInit no longer takes the comm port param
 *
 */ 


#ifndef _INC_GENERIC_UPS_H_
#define _INC_GENERIC_UPS_H_


/**
* GenericUPSInit
*
* Description:
*   Retrieves the UPS signalling information from the
*   NT Registry and attempts to open the comm port and
*   configure it as defined by the signalling data.
*   Starts the monitoring of the UPS on a separate thread
*   The GenericUPSInit function must be called before any
*   other function in this file
*
* Parameters:
*   None
*
* Returns:
*   UPS_INITOK: Initalization was successful
*   UPS_INITREGISTRYERROR:  The 'Options' registry value is corrupt
*   UPS_INITCOMMOPENERROR:  The comm port could not be opened
*   UPS_INITCOMMSETUPERROR: The comm port could not be configured
*   UPS_INITUNKNOWNERROR:   Undefined error has occurred
*   
*/
DWORD GenericUPSInit(void);


/**
* GenericUPSStop
*
* Description:
*   calls GenericUPSCancelWait to release pending threads
*   Stops the thread that is monitoring the UPS
*   Closes the comm port
*   Resets all data to default values
*   After a call to GenericUPSStop, only the GenericUPSInit
*   function is valid
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void  GenericUPSStop(void);


/**
* GenericUPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*   
*/
void  GenericUPSWaitForStateChange(DWORD, DWORD);


/**
* GenericUPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD GenericUPSGetState(void);


/**
* GenericUPSCancelWait
*
* Description:
*   interrupts pending calls to GenericUPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void  GenericUPSCancelWait(void);


/**
* GenericUPSTurnOff
*
* Description:
*   Attempts to turn off the outlets on the UPS
*   after the specified delay.  This call must
*   return immediately.  Any work, such as a timer,
*   must be performed on a another thread.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void  GenericUPSTurnOff(DWORD aTurnOffDelay);


//
// values returned from GenericUPSGetState
//
#define UPS_ONLINE 1
#define UPS_ONBATTERY 2
#define UPS_LOWBATTERY 4
#define UPS_NOCOMM 8


//
// possible error codes for GenericUPSInit
//
#define UPS_INITUNKNOWNERROR    0
#define UPS_INITOK              1
#define UPS_INITNOSUCHDRIVER    2
#define UPS_INITBADINTERFACE    3
#define UPS_INITREGISTRYERROR   4
#define UPS_INITCOMMOPENERROR   5
#define UPS_INITCOMMSETUPERROR  6


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\main.c ===
#include <windows.h>
#include "polmgr.h"
#include <process.h> 
#include <stdio.h>   
#include "eventlog.h"
#include "notifier.h"
void testmethod();


void main(){
   DWORD err;


	err = PolicyManagerInit();
//	_beginthread( testmethod, 0, NULL);

	PolicyManagerRun();



      
}

void testmethod(){
int i=0;
	Sleep(3000);
	PolicyManagerStop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\hibernate.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file defines the interface for the Hibernation funcationality.  
 *   It is responsible for performing a hibernation of the operating system.
 *
 *
 * Revision History:
 *   sberard  14May1999  initial revision.
 *
 */ 

#include <windows.h>

#include "upsreg.h"

#ifndef _HIBERNATE_H
#define _HIBERNATE_H


#ifdef __cplusplus
extern "C" {
#endif

  /**
   * HibernateSystem
   *
   * Description:
   *   This function initiates hibernation of the operating system. This is
	 *   performed through a call to the Win32 function SetSystemPowerStae(..).
   *   When called hibernation is initated immediately and, if successful, the
   *   function will return TRUE when the system returns from hibernation.
	 *   Otherwise, FALSE is retuned to indicate the the system did not hibernate.
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   TRUE  - if hibernation was initiated successfully and subsequently restored
   *   FALSE - if errors occur while initiating hibernation
   */
  BOOL HibernateSystem();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\gnrcups.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   Implements the generic UPS
 *
 * Revision History:
 *   mholly  19Apr1999  initial revision.
 *   mholly  21Apr1999  hold shutoff pin for 5 sec instead of 3
 *   mholly  12May1999  UPSInit no longer takes the comm port param
 *
 */ 


#include <tchar.h>
#include <windows.h>

#include "gnrcups.h"
#include "upsreg.h"

//
// provide meaningful names to the comm port pins
//
#define LINE_FAIL       MS_CTS_ON   
#define LOW_BATT        MS_RLSD_ON
#define LINE_FAIL_MASK  EV_CTS
#define LOW_BATT_MASK   EV_RLSD

// Amount of time to wait in order for the port to settle down
#define DEBOUNCE_DELAY_TIME 250

//
// private functions used in the implementation of the
// public Generic UPS funtions
//
static DWORD openCommPort(LPCTSTR aCommPort);
static DWORD setupCommPort(DWORD aSignalsMask);
static DWORD getSignalsMask(void);
static void updateUpsState(DWORD aModemStatus);
static BOOL upsLineAsserted(DWORD ModemStatus, DWORD Line);
static DWORD startUpsMonitoring(void);
static DWORD WINAPI UpsMonitoringThread(LPVOID unused);


//
// UPSDRIVERCONTEXT
//
//  provides a framework to encapsulate data that is
//  shared among the functions in this file
//
struct UPSDRIVERCONTEXT
{
    HANDLE theCommPort;

    DWORD theState;
    HANDLE theStateChangedEvent;
	DWORD theSignalsMask;

    HANDLE theMonitoringThreadHandle;
    HANDLE theStopMonitoringEvent;
};

//
// _theUps
//
//  provides a single instance of a UPSDRIVERCONTEXT
//  structure that all functions in this file will use
//
static struct UPSDRIVERCONTEXT _theUps;


/**
* GenericUPSInit
*
* Description:
*   Retrieves the UPS signalling information from the
*   NT Registry and attempts to open the comm port and
*   configure it as defined by the signalling data.
*   Also creates a inter-thread signal, theStateChangedEvent,
*   and starts the monitoring of the UPS on a separate thread
*   via a call to startUpsMonitoring.
*   The GenericUPSInit function must be called before any
*   other function in this file
*
* Parameters:
*   None
*
* Returns:
*   UPS_INITOK: Initalization was successful
*   UPS_INITREGISTRYERROR:  The 'Options' registry value is corrupt
*   UPS_INITCOMMOPENERROR:  The comm port could not be opened
*   UPS_INITCOMMSETUPERROR: The comm port could not be configured
*   UPS_INITUNKNOWNERROR:   Undefined error has occurred
*   
*/
DWORD GenericUPSInit(void)
{
    DWORD init_err = UPS_INITOK;
    TCHAR comm_port[MAX_PATH];

	_theUps.theStateChangedEvent = NULL;
    _theUps.theState = UPS_ONLINE;
    _theUps.theCommPort = NULL;
    _theUps.theMonitoringThreadHandle = NULL;
    _theUps.theStopMonitoringEvent = NULL;

    if (ERROR_SUCCESS != getSignalsMask()) {
        init_err = UPS_INITREGISTRYERROR;
        goto init_end;
    }

    //
    // Initialize registry functions
    //
    InitUPSConfigBlock();

    //
    // get the comm port to use
    //
    if (ERROR_SUCCESS != GetUPSConfigPort(comm_port)) {
        init_err = UPS_INITREGISTRYERROR;
        goto init_end;
    }

    if (ERROR_SUCCESS != openCommPort(comm_port)) {
        init_err = UPS_INITCOMMOPENERROR;
        goto init_end;
    }

    _theUps.theStateChangedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!_theUps.theStateChangedEvent) {
        init_err = UPS_INITUNKNOWNERROR;
        goto init_end;
	}

    if (ERROR_SUCCESS != setupCommPort(_theUps.theSignalsMask)) {
        init_err = UPS_INITCOMMSETUPERROR;
        goto init_end;
    }

    if (ERROR_SUCCESS != startUpsMonitoring()) {
        init_err = UPS_INITUNKNOWNERROR;
        goto init_end;
    }

init_end:
    if (UPS_INITOK != init_err) {
        GenericUPSStop();
    }
    return init_err;
}


/**
* GenericUPSStop
*
* Description:
*   calls GenericUPSCancelWait to release pending threads
*   Stops the thread that is monitoring the UPS
*   Closes the comm port
*   Resets all data to default values
*   After a call to GenericUPSStop, only the GenericUPSInit
*   function is valid
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void GenericUPSStop(void)
{
    GenericUPSCancelWait();

    if (_theUps.theStopMonitoringEvent) {
        SetEvent(_theUps.theStopMonitoringEvent);
    }

    if (_theUps.theMonitoringThreadHandle) {
        WaitForSingleObject(_theUps.theMonitoringThreadHandle, INFINITE);
        CloseHandle(_theUps.theMonitoringThreadHandle);
        _theUps.theMonitoringThreadHandle = NULL;
    }

    if (_theUps.theStopMonitoringEvent) {
        CloseHandle(_theUps.theStopMonitoringEvent);
        _theUps.theStopMonitoringEvent = NULL;
    }

    if (_theUps.theCommPort) {
        CloseHandle(_theUps.theCommPort);
        _theUps.theCommPort = NULL;
    }

    if (_theUps.theStateChangedEvent) {
        CloseHandle(_theUps.theStateChangedEvent);
        _theUps.theStateChangedEvent = NULL;
    }
    _theUps.theState = UPS_ONLINE;
    _theUps.theSignalsMask = 0;
}


/**
* GenericUPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*   
*/
void GenericUPSWaitForStateChange(DWORD aLastState, DWORD anInterval)
{
    if (aLastState == _theUps.theState) {
        //
        // wait for a state change from the UPS
        //
		if (_theUps.theStateChangedEvent) {
			WaitForSingleObject(_theUps.theStateChangedEvent, anInterval);
		}
    }
}


/**
* GenericUPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD GenericUPSGetState(void)
{
    return _theUps.theState;
}


/**
* GenericUPSCancelWait
*
* Description:
*   interrupts pending calls to GenericUPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void GenericUPSCancelWait(void)
{
    if (_theUps.theStateChangedEvent) {
        SetEvent(_theUps.theStateChangedEvent);
    }
}


/**
* GenericUPSTurnOff
*
* Description:
*   Attempts to turnoff the UPS after the specified delay.
*   Simple signaling UPS do not support this feature, so
*   this function does nothing.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void GenericUPSTurnOff(DWORD aTurnOffDelay)
{
	// UPS turn off is not supported in simple mode, do nothing
}


/**
* getSignalsMask
*
* Description:
*   Queries the registry for the 'Options' value
*   The 'Options' value defines a bitmask that is
*   used to configure the comm port settings
*
* Parameters:
*   None
*
* Returns:
*   ERROR_SUCCESS:  signals mask retrieved OK
*   any other return code indicates failure to
*   retrieve the value from the registry
*   
*/
DWORD getSignalsMask(void)
{
    DWORD status = ERROR_SUCCESS;
    DWORD value = 0;
    
    status = GetUPSConfigOptions(&value);

    if (ERROR_SUCCESS == status) {
		_theUps.theSignalsMask = value;
	}
	else {
		_theUps.theSignalsMask = 0;
	}
	return status;
}


/**
* openCommPort
*
* Description:
*   Attempts to open the comm port
*
* Parameters:
*   aCommPort:  indicates which comm port
*               on the system to open
*
* Returns:
*   ERROR_SUCCESS:  comm port opened OK
*   any other return code indicates failure to
*   open the comm port - the exact error code
*   is set by the CreateFile function
*   
*/
DWORD openCommPort(LPCTSTR aCommPort)
{
    DWORD err = ERROR_SUCCESS;

    _theUps.theCommPort = CreateFile(
            aCommPort,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OVERLAPPED,
            NULL
            );

    if (_theUps.theCommPort == INVALID_HANDLE_VALUE) {
        err = GetLastError();
    }
    return err;
}


/**
* setupCommPort
*
* Description:
*   Attempts to setup the comm port - this method
*   initializes the shutoff pin to an unsignalled
*   state, and tells the system what other pins
*   it should monitor for changes
*
* Parameters:
*   aSignalsMask:   defines a bitmask that will
*                   be used to configure the
*                   comm port
*
* Returns:
*   ERROR_SUCCESS:  comm port setup OK
*   any other return code indicates failure to
*   setup the comm port - the exact error code
*   is set by the EscapeCommFunction function
*   
*/
DWORD setupCommPort(DWORD aSignalsMask)
{
    DWORD err = ERROR_SUCCESS;
    DWORD ModemStatus = 0;
    DWORD UpsActiveSignals = 0;
    DWORD UpsCommMask = 0;

    //
    // first set the 'shutoff' pin to the
    // unsignaled state, don't want to 
    // shutoff the UPS now...
    //
    if (aSignalsMask & UPS_POSSIGSHUTOFF) {
        ModemStatus = CLRDTR;
    } 
    else {
        ModemStatus = SETDTR;
    }
        
    if (!EscapeCommFunction(_theUps.theCommPort, ModemStatus)) {
        err = GetLastError();
    }

    if (!EscapeCommFunction(_theUps.theCommPort, SETRTS)) {
        err = GetLastError();
    }

    if (!EscapeCommFunction(_theUps.theCommPort, SETXOFF)) {
        err = GetLastError();
    }

    //
    // determine what pins should be monitored for activity
    //
    UpsActiveSignals =
            (aSignalsMask & ( UPS_POWERFAILSIGNAL | UPS_LOWBATTERYSIGNAL));

    switch (UpsActiveSignals) {
    case UPS_POWERFAILSIGNAL:
        UpsCommMask = LINE_FAIL_MASK;
        break;

    case UPS_LOWBATTERYSIGNAL:
        UpsCommMask = LOW_BATT_MASK;
        break;

    case (UPS_LOWBATTERYSIGNAL | UPS_POWERFAILSIGNAL):
        UpsCommMask = (LINE_FAIL_MASK | LOW_BATT_MASK);
        break;
    }

    //
    // tell the system what pins we are interested in
    // monitoring activity
    //
	if (!SetCommMask(_theUps.theCommPort, UpsCommMask)) {
		err = GetLastError();
	}
    //
    // simply wait for 3 seconds for the pins to 'settle',
    // failure to do so results in misleading status to 
    // be returned from GetCommModemStatus
    //
    WaitForSingleObject(_theUps.theStateChangedEvent, 3000);
    GetCommModemStatus( _theUps.theCommPort, &ModemStatus);
    updateUpsState(ModemStatus);

    return err;
}


/**
* startUpsMonitoring
*
* Description:
*   Creates a separate thread to perform the monitoring
*   of the comm port to which the UPS is connected
*   Also creates an event that other threads can signal
*   to indicate that the monitoring thread should exit
*
* Parameters:
*   None
*
* Returns:
*   ERROR_SUCCESS:  thread creation OK
*   any other return code indicates failure to
*   start the thread, either the thread was not
*   created or the stop event was not created
*   
*/
DWORD startUpsMonitoring()
{
	DWORD err = ERROR_SUCCESS;
    DWORD thread_id = 0;

    _theUps.theStopMonitoringEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	if (!_theUps.theStopMonitoringEvent) {
		err = GetLastError();
	}
	else {
		_theUps.theMonitoringThreadHandle =
			CreateThread(NULL, 0, UpsMonitoringThread, NULL, 0, &thread_id);
		
		if (!_theUps.theMonitoringThreadHandle) {
			err = GetLastError();
		}
	}
    return err;
}


/**
* updateUpsState
*
* Description:
*   Determines the state of the UPS based upon
*   the state of the line fail and low battery
*   pins of the UPS
*   If the state of the UPS changes, then this
*   method will signal theStateChangedEvent, this
*   in-turn will release any threads waiting in
*   the GenericUPSWaitForStateChange function
*
* Parameters:
*   aModemStatus: a bitmask that represents the
*               state of the comm port pins, this
*               value should be retrieved by a call
*               to GetCommModemStatus
*
* Returns:
*   None
*   
*/
void updateUpsState(DWORD aModemStatus)
{
    DWORD old_state = _theUps.theState;

    if (upsLineAsserted(aModemStatus, LINE_FAIL)) {

        if (upsLineAsserted(aModemStatus, LOW_BATT)) {
            _theUps.theState = UPS_LOWBATTERY;
        }
        else {
            _theUps.theState = UPS_ONBATTERY;
        }
    }
    else {
        _theUps.theState = UPS_ONLINE;
    }

    if (old_state != _theUps.theState) {
        SetEvent(_theUps.theStateChangedEvent);
    }
}


/**
* upsLineAsserted
*
* Description:
*   Determines if the signal, either LINE_FAIL or LOW_BATT,
*   is asserted or not.  The line is asserted based on the
*   voltage levels set in _theUps.theSignalsMask.  
*   The aModemStatus bitmask signals a positive voltage 
*   by a value of 1.
*   Below is a chart showing the logic used in determining
*   if a line is asserted or not
*   
*   --------------------------------------------------------------
*                  | UPS positive signals  | UPS negative signals
*   --------------------------------------------------------------
*   line positive  |        asserted       |      not asserted
*   ---------------|-----------------------|----------------------
*   line negative  |      not asserted     |        asserted
*   ---------------|-----------------------|----------------------
*
* Parameters:
*   aModemStatus: a bitmask that represents the
*               state of the comm port pins - the value
*               should be retrieved by a call to
*               GetCommModemStatus
*   Line: either LINE_FAIL or LOW_BATT
*
* Returns:
*   TRUE if line is asserted, FALSE otherwise
*   
*/
BOOL upsLineAsserted(DWORD aModemStatus, DWORD aLine)
{
    DWORD asserted;
    DWORD status;
    DWORD assertion;
    
    //
    // only look at the line that was selected
    // this filters out the other fields in the
    // aModemStatus bitmask
    //
    status = aLine & aModemStatus;
    
    //
    // determine if the line is asserted based
    // on positive or negative voltages
    //
    assertion = (aLine == LINE_FAIL) ?
        (_theUps.theSignalsMask & UPS_POSSIGONPOWERFAIL) :
    (_theUps.theSignalsMask & UPS_POSSIGONLOWBATTERY);
    
    if (status) {           
        //
        // the line has positive voltage
        //
        if (assertion) {
            //
            // the UPS uses positive voltage to
            // assert the line
            //
            asserted = TRUE;
        }
        else {
            //
            // the UPS uses negative voltage to
            // assert the line
            //
            asserted = FALSE;
        }
    }
    else {
        //
        // the line has negative voltage
        //
        if (assertion) {
            //
            // the UPS uses positive voltage to
            // assert the line
            //
            asserted = FALSE;
        }
        else {
            //
            // the UPS uses negative voltage to
            // assert the line
            //
            asserted = TRUE;
        }
    }
    return asserted;
}


/**
* UpsMonitoringThread
*
* Description:
*   Method used by the thread to monitor the UPS port
*   for changes.  The thread will exit when the event
*   _theUps.theStopMonitoringEvent is signalled
*
* Parameters:
*   unused: not used
*
* Returns:
*   ERROR_SUCCESS
*   
*/
DWORD WINAPI UpsMonitoringThread(LPVOID unused)
{
    DWORD ModemStatus = 0;
    HANDLE events[2];
    OVERLAPPED UpsPinOverlap;

    //
    // create an event for the OVERLAPPED struct, this event
    // will signalled when one of the pins that we are
    // monitoring, defined by SetCommMask in setupCommPort,
    // indicates a change in its signal state
    //
    UpsPinOverlap.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);        

    //
    // since the thread reacts to two events, a signal from the
    // comm port, and a Stop event, we initialize an array of events
    // to pass into WaitForMultipleObjects
    //
    events[0] = _theUps.theStopMonitoringEvent;
    events[1] = UpsPinOverlap.hEvent;
    
    while (TRUE) {
        //
        // tell the system to wait for comm events again
        //
        WaitCommEvent(_theUps.theCommPort, &ModemStatus, &UpsPinOverlap);
        //
        // block waiting for either a comm port event, or a stop
        // request from another thread
        //
        WaitForMultipleObjects(2, events, FALSE, INFINITE);

        //
        // Test to see if the stop event is signalled, if it
        // is then break out of the while loop.
        //
        // The wait is to allow for the port to settle before reading
        // the value.
        // 
        if (WAIT_OBJECT_0 == 
            WaitForSingleObject(_theUps.theStopMonitoringEvent, DEBOUNCE_DELAY_TIME)) {
            break;
        }
        //
        // ask the system about the status of the comm port
        // and pass the value to updateUpsState so it can
        // determine the new state of the UPS
        // Then simply continue monitoring the port.
        //
        GetCommModemStatus(_theUps.theCommPort, &ModemStatus);
        updateUpsState(ModemStatus);
    }
	CloseHandle(UpsPinOverlap.hEvent);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\hibernate.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file implements the Hibernation funcationality.  It is responsible
 *   for performing a hibernation of the operating system.
 *
 *
 * Revision History:
 *   sberard  14May1999  initial revision.
 *   sberard  20May1999  modified to use the Power Management Profile Interface API
 *
 */ 
#include "hibernate.h"

// These prototypes are needed because we do not have access to powrprof.h
BOOLEAN WINAPI IsPwrHibernateAllowed(VOID);
BOOLEAN WINAPI SetSuspendState(IN BOOLEAN bHibernate, IN BOOLEAN bForce, IN BOOLEAN bWakeupEventsDisabled);

#ifdef __cplusplus
extern "C" {
#endif

  /**
   * HibernateSystem
   *
   * Description:
   *   This function initiates hibernation of the operating system. This is
	 *   performed through a call to the Win32 function SetSystemPowerStae(..).
   *   When called hibernation is initated immediately and, if successful, the
   *   function will return TRUE when the system returns from hibernation.
	 *   Otherwise, FALSE is retuned to indicate the the system did not hibernate.
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   TRUE  - if hibernation was initiated successfully and subsequently restored
   *   FALSE - if errors occur while initiating hibernation
   */
  BOOL HibernateSystem() {
    BOOL ret_val = FALSE;
	  TOKEN_PRIVILEGES tkp;
	  HANDLE           process_token;
  
	  // get the current process token so that we can
	  //  modify our current process privs.
	  //
	  if (OpenProcessToken(GetCurrentProcess(),
		  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &process_token)) {

      // Find the local unique id for SeShutdownPrivilege
	    if (LookupPrivilegeValue(NULL, TEXT("SeShutdownPrivilege"),
		    &tkp.Privileges[0].Luid))  {        	

        // we only want to enable one priv
	      tkp.PrivilegeCount = 1;
	      tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	      
	      // now, add it all back to our current process.
	      if (AdjustTokenPrivileges(process_token,   // do it to us
		                               FALSE,           // don't turn all privs off
		                               &tkp,            // what we want to do
		                               0,               // don't want any prev info
		                               (PTOKEN_PRIVILEGES)NULL,
		                               0)) {		
          
        
          // Check to see if hibernation is enabled
          if (IsPwrHibernateAllowed() == TRUE) {
            // Attempt to hibernate the system
            if (SetSuspendState(TRUE, TRUE, FALSE) == TRUE) {
              // Hibernation was successful, system has been restored
              ret_val = TRUE;
            }
            else {
              // There was an error attempting to hibernate the system
              ret_val = FALSE;
            }
          }
          else {
            // Hibernation is not selected as the CriticalPowerAction, return an error
            ret_val = FALSE;
          }
        }
      }
      CloseHandle (process_token);
    }

    return ret_val;
  }

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\polmgr.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
* 
* Description:
*   This is the implementation of the policy manager for the native UPS service of Windows 2000.
*
* Revision History:
*   dsmith  31Mar1999  Created
*
*/
#include <windows.h>
#include <lmerr.h>

#include "polmgr.h"
#include "statmach.h"
#include "driver.h"
#include "states.h"
#include "events.h"
#include "upsreg.h"
#include "eventlog.h"




// Internal Variables
BOOL theIsInitialized = FALSE;
BOOL theShutdownPending = FALSE;


/**
* PolicyManagerInit
*
* Description:
*   Initializes the UPS service state machine.
*   exiting.
*
* Parameters:
*   None
*
* Returns:
*   An error code defined in lmerr.h
*/
DWORD PolicyManagerInit(){
	DWORD err;
	Initializing_Enter(NO_EVENT);
	err = Initializing_DoWork();
	Initializing_Exit(NO_EVENT);
	if (err == NERR_Success){
		theIsInitialized = TRUE;
	}
	// Log the failure event
	else {
       LogEvent(err, NULL, ERROR_SUCCESS);
	}
	return err;
}


/**
* PolicyManagerRun
*
* Description:
*   Starts the UPS service state machine and does not return until the service is
*   exiting.
*
* Parameters:
*   None
*
* Returns:
*   None
*/
void PolicyManagerRun(){
	if (theIsInitialized){
		RunStateMachine();
	}
}

/**
* PolicyManagerStop
*
* Description:
*   Stops the UPS service state machine if the service is not in the middle of a 
*   shutdown sequence.
*
* Parameters:
*   None
*
* Returns:
*   None
*/
void PolicyManagerStop(){
	StopStateMachine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\notifier.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file defines the interface to the Notifier.  The 
 *   Notifier is reponsible for broadcasting power-related and
 *   shutdown messages to the local machine.
 *
 *
 * Revision History:
 *   sberard  30Mar1999  initial revision.
 *
 */ 

#include <windows.h>
#include <lmcons.h>
#include <lmalert.h>
#include <lmmsg.h>

#ifndef _NOTIFIER_H
#define _NOTIFIER_H


#ifdef __cplusplus
extern "C" {
#endif
  
  
  /**
   * SendNotification
   *
   * Description:
   *   This function sends a broadcast message to the local machine.  The 
   *   message is specified by aMsgId.  The parameter anInterval specifies
   *   the amount of time to wait between consecutive messages.  If this
   *   value is zero the message is only sent once, otherwise the message
   *   will repeat until SendNotification(..) or CancelNotification() is
   *   called.  aDelay specifies that the message should be send aDelay 
   *   seconds in the future - note that this method will not block for aDelay
   *   seconds, it returns immediately and sends the message on a separate
   *   thread.  Any current previously executing periodic notifications 
   *   are canceled as a result of this call.
   *
   *   This method also keeps track of whether the power out message had
   *   been sent to users.  This is done in order to squelch a power return
   *   message if a power out message had not already been sent.
   *
   * Parameters:
   *   aMsgId - the message to send
   *   anInterval - the amount of time, in seconds, between messages
   *   aDelay - the amount of time, in seconds to wait to send message
   *
   * Returns:
   *   nothing
   */
  void SendNotification(DWORD aMsgId, DWORD anInterval, DWORD aDelay);
  
  /**
   * CancelNotification
   *
   * Description:
   *   This function cancels the periodic messaging initiated through a call
   *   to the SendNotification(..) function.
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   nothing
   */
  void CancelNotification();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\notifier.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file implements the Notifier.  The Notifier is reponsible 
 *   for broadcasting power-related and shutdown messages to the 
 *   local machine.
 *
 *
 * Revision History:
 *  sberard  30Mar1999  initial revision.
 *  mholly   27Apr1999  create and recycle a single thread for repeat 
 *                      notifications - use two separate events to signal
 *                      either pause or resume of the thread state  
 *  mholly   27Apr1999  make sure to clear the pause event when resuming
 *                      and to clear the resume event when pausing
 *  mholly   28May1999  send all messages in _theNotifierThread, also
 *                      have this thread do any delaying for the callee,
 *                      and keep track of whether a power out message
 *                      was sent, so we know when to send a power restored
 */ 

#include "notifier.h"
#include "service.h"
#include "upsmsg.h"

//
// Function prototypes
//
static void sendSingleNotification(DWORD aMsgId);
static void sendRepeatingNotification(void);
static void setupNotifierThread(void);

//
// Globals
//
static HANDLE _theNotifierThread = NULL;
static HANDLE _theNotificationPause = NULL;
static HANDLE _theNotificationResume = NULL;
static DWORD  _theMessageId;
static DWORD  _theNotificationInterval;
static DWORD  _theMessageDelay;
static DWORD  _theLastMessageSent = 0;

//
// Constats
//
static const int kMilliSeconds = 1000;    // Used to convert seconds to milliseconds



/**
* SendNotification
*
* Description:
*   This function sends a broadcast message to the local machine.  The 
*   message is specified by aMsgId.  The parameter anInterval specifies
*   the amount of time to wait between consecutive messages.  If this
*   value is zero the message is only sent once, otherwise the message
*   will repeat until SendNotification(..) or CancelNotification() is
*   called.  aDelay specifies that the message should be send aDelay 
*   seconds in the future - note that this method will not block for aDelay
*   seconds, it returns immediately and sends the message on a separate
*   thread.  Any current previously executing periodic notifications 
*   are canceled as a result of this call.
*
*   This method also keeps track of whether the power out message had
*   been sent to users.  This is done in order to squelch a power return
*   message if a power out message had not already been sent.
*
* Parameters:
*   aMsgId - the message to send
*   anInterval - the amount of time, in seconds, between messages
*   aDelay - the amount of time, in seconds to wait to send message
*
* Returns:
*   nothing
*/
void SendNotification(DWORD aMsgId, DWORD anInterval, DWORD aDelay) 
{
    //
    // Cancel any current periodic notifications
    //
    CancelNotification();

    //
    // only sent the power back message if
    // the power out message had already
    // been broadcast to the users
    //
    if ((APE2_UPS_POWER_BACK == aMsgId) &&
        (APE2_UPS_POWER_OUT != _theLastMessageSent)) {
        //
        // the last message sent was not power out
        // so simply return
        //
        return;
    }
    
    //
    // Set the message parameters for _theNotifierThread
    //
    _theMessageId = aMsgId;
    _theNotificationInterval = anInterval;
    _theMessageDelay = aDelay;
    
    //
    // setup the thread events and thread
    //
    setupNotifierThread();

    //
    // tell _theNotificationThread to run by
    // signalling the resume event - must make
    // sure to clear the pause event before
    // signalling the resume
    //
    ResetEvent(_theNotificationPause);
    SetEvent(_theNotificationResume);
}


/**
* CancelNotification
*
* Description:
*   This function cancels the periodic messaging initiated through a call
*   to the SendNotification(..) function.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
void CancelNotification() 
{
    //
    // tell _theNotificationThread to pause
    // by signalling the pause event - must make
    // sure to clear the resume event before
    // signalling the pause event
    //
    ResetEvent(_theNotificationResume);
    SetEvent(_theNotificationPause);
}


/**
* setupNotifierThread
*
* Description:
*   Creates the thread on which the notifications will 
*   actually be sent.  It also creates the events that
*   are used to signal the start and end of notifications
*
* Parameters:
*   none
*
* Returns:
*   nothing

*/
void setupNotifierThread(void)
{
    if (!_theNotificationPause) {
        //
        // Create the pause event
        //
        _theNotificationPause = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    if (!_theNotificationResume) {
        //
        // create the resume event
        //
        _theNotificationResume = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    if (!_theNotifierThread) {
        //
        // create the notification thread
        //
        _theNotifierThread = CreateThread(NULL,   // no security attributes
            0,      // default stack
            (LPTHREAD_START_ROUTINE)
            sendRepeatingNotification,
            NULL,
            0,
            NULL);
    }
}


/**
* sendSingleNotification
*
* Description:
*   This function sends a single broadcast message to the local machine.
*   The message is specified by aMsgId.  
*
* Parameters:
*   aMsgId - the message to send
*
* Returns:
*   nothing
*/
static void sendSingleNotification(DWORD aMsgId) 
{
    DWORD status;
    TCHAR computer_name[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD computer_name_len = MAX_COMPUTERNAME_LENGTH + 1;
    LPTSTR msg_buf, additional_args[1];
    DWORD buf_len;
    
    // Get the computer name and pass it as additional 
    // information for the message
    GetComputerName(computer_name, &computer_name_len);
    additional_args[0] = computer_name;
    
    buf_len = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_ARGUMENT_ARRAY  |
        FORMAT_MESSAGE_FROM_SYSTEM ,
        NULL,                                   // NULL means get message from system
        aMsgId,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),  
        (LPTSTR) &msg_buf,
        0,                                      // buffer size
        (va_list *)additional_args);               // additional arguements
    
    if (buf_len > 0) {
        _theLastMessageSent = aMsgId;
        // Display the message
        status = NetMessageBufferSend(NULL, 
            computer_name,
            computer_name,
            (LPBYTE) msg_buf,
            buf_len * 2);  // multiply by 2 because the string is Unicodeh

        // Free the memory allocated by FormatMessage
        LocalFree(msg_buf);
    }
}


/**
* sendRepeatingNotification
*
* Description:
*   This function sends notifications repeatedly to the local machine.
*   This function calls sendSingleNotification(..) to perform the actual
*   notification.  The message will be sent after _theMessageDelay seconds
*   has elapsed after _theNotificationResume event is signaled.  If 
*   _theMessageDelay is zero, a message is sent immediately.  Messages are 
*   repeated, if _theNotificationInterval is not zero, until the Event 
*   _theNotificationPause is signaled. The message Id and the notification 
*   interval are  specified by the global variables _theMessageId and 
*   _theNotificationInterval.
*
*   To restart notifications using this thread signal _theNotificationResume
*   event.  This thread will remain idle until this event is signalled
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void sendRepeatingNotification(void) 
{
    //
    // wait for _theNotificationResume to become signaled
    // this becomes signaled when a notification should be sent
    //
    while (WAIT_OBJECT_0 == 
        WaitForSingleObject(_theNotificationResume, INFINITE)) {
        
        //
        // Send the initial message after the message delay
        // seconds has elapsed - if _theNotificationPause becomes
        // signaled before the delay seconds has elapsed then
        // this notification has been cancelled
        //
        if (WAIT_TIMEOUT == WaitForSingleObject(_theNotificationPause, 
            _theMessageDelay * kMilliSeconds)) {

            //
            // send the message that was requested
            //
            sendSingleNotification(_theMessageId);

            //
            // now send repeating notifications
            // if necessary - if _theNotificationInterval
            // is set to zero, then only send the single
            // message above
            //
            if (0 != _theNotificationInterval) {
                //
                // wait for either _theNotificationPause to become
                // signalled or until it is time to notify again
                //
                DWORD interval = _theNotificationInterval * kMilliSeconds;

                while (WAIT_TIMEOUT == 
                    WaitForSingleObject(_theNotificationPause, interval)) {
                    sendSingleNotification(_theMessageId);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\running_statmach.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
* 
* Description:
*   Interface to the RUNNING state 
*
* Revision History:
*   dsmith  31Mar1999  Created
*
*/

#ifndef _INC_RUNNING_STATEMACHINE_H_
#define _INC_RUNNING_STATEMACHINE_H_

#include <windows.h>

// Definitions for the RUNNING state

// The RUNNING state has three methods associated with it:  Enter, DoWork 
// and Exit.  DoWork is where all of the major state work is performed.  
// Enter and Exit is where one time processing tasks associated with the 
// state is performed.

void Running_Enter(DWORD anEvent);
DWORD Running_DoWork();
void Running_Exit(DWORD anEvent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gnrcups.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\polmgr.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   Interface between the Windows 2000 service mechanism and the UPS monitoring and
 * control code.
 *
 * Revision History:
 *   dsmith  31Mar1999  Created
 *
 */
#ifndef _INC_POLICYMGR_H_
#define _INC_POLICYMGR_H_



// Initializes the UPS service state machine and returns one of the following
// error codes:
//        NERR_Success
//        NERR_UPSDriverNotStarted
//		  NERR_UPSInvalidConfig
//        NERR_UPSInvalidConfig
//        NERR_UPSInvalidCommPort
//        NERR_UPSInvalidCommPort
//        NERR_UPSInvalidConfig
DWORD PolicyManagerInit();

// Starts the UPS service state machine and does not return until the service is
// stopped.
void PolicyManagerRun();  	

// Signals the policy manager that the OS has completed a shutdown
void OperatingSystemHasShutdown();

// Stops the UPS service state machine if the service is not in the middle of a 
// shutdown sequence.
void PolicyManagerStop(); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\regdefs.h ===
//Generated code, do not edit...


#ifndef _REGDEFS_H_
#define _REGDEFS_H_


#ifdef __cplusplus
extern "C"{
#endif


  ServiceProviderStructure _theStaticProvidersTable[] = {
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Back-UPS"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Back-UPS Pro"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Basic Port on Communications Accessory"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Basic signaling to any APC UPS"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Matrix-UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("PowerStack"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Smart-UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Smart signaling to any APC UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Symmetra Power Array"), TEXT("0x7F;apcups.dll")},
    {NULL, NULL, NULL}
  };


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\running_statmach.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
* 
* Description:
*   Implementation of the RUNNING state machine.
*
* Revision History:
*   dsmith  31Mar1999  Created
*
*/
#include <windows.h>

#include "states.h"
#include "events.h"
#include "run_states.h"
#include "statmach.h"
#include "running_statmach.h"


//////////////////////////////////////////
// Internal prototype definitions
//////////////////////////////////////////
BOOL isRunningEvent(DWORD aState, DWORD anEvent);
DWORD do_running_work(DWORD aCurrentState);
DWORD change_running_state(DWORD aCurrentState, DWORD anEvent);
void exit_running_state(DWORD aCurrentState, DWORD anEvent);
void enter_running_state(DWORD aCurrentState, DWORD anEvent);


//////////////////////////////////////////
// Running State internal variables
//////////////////////////////////////////
BOOL theLogPowerRestoredEvent	= FALSE;



/**
* Running_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the RUNNING state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void Running_Enter(DWORD anEvent){

	// Initialize internal variables and enter the RUNNING default sub-state
    OnLine_Enter(anEvent, FALSE);
}

/**
* Running_DoWork
*
* Description:
*   Change run states based upon events from the UPS.  When an event occurs 
*  that cannot be handled in the run state, then this method exits.  
*
* Parameters:
*   None
*
* Returns:
*   The event that caused the transition from the RUNNING state.
*/
DWORD Running_DoWork(){
	DWORD event = NO_EVENT;
	DWORD new_state = ON_LINE;  
	DWORD current_state = new_state;
	
	// Perform work in sub-states until an event occurs that cannot be
	// handled in the RUNNING state
    while (isRunningEvent(current_state, event) && IsStateMachineActive()){
		new_state = change_running_state(current_state, event);
		current_state = new_state;
		event = do_running_work(current_state);
	}
	return event;
}

/**
* Running_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the RUNNING state.
*
* Parameters:
*   anEvent The event that caused the transition from the RUNNING state.
*
* Returns:
*   None
*/
void Running_Exit(DWORD anEvent){
	// No work to perform
}


/**
* do_running_work
*
* Description:
*   Transfers control to one of the RUNNING sub-states.
*
* Parameters:
*   aCurrentState The sub-state to perform the work in.
*
* Returns:
*   The event that caused the transition from one of the sub-states
*/
DWORD do_running_work(DWORD aCurrentState){
	DWORD event = NO_EVENT;
	switch (aCurrentState){
	case ON_LINE:
		event = OnLine_DoWork();
		break;
	case ON_BATTERY:
		event = OnBattery_DoWork();
		break;
	case NO_COMM:
		event = NoComm_DoWork();
		break;
	default:
		break;
	}
	return event;
}

/**
* isRunningEvent
*
* Description:
*   Determines if the current event pertains to the RUNNING state.
*
* Parameters:
*   aState  The current RUNNING state
*   anEvent The current event occuring within the RUNNING state.
*
* Returns:
*   TRUE if the current event is applicable to the RUNNING state.
*   FALSE for all other events.
*/
BOOL isRunningEvent(DWORD aState, DWORD anEvent){
	
	BOOL running_event = FALSE;
	
	// If the state machine has been commanded to exit, then return FALSE
	// Otherwise, determine if the event is applicable to the Running state
	
	if (IsStateMachineActive()){
		switch (anEvent){
		case LOST_COMM:
			// If the UPS is on battery, then lost comm will translate into
			// a non-RUNNING state event (since the service must now shutdown)
			if (aState != ON_BATTERY){
				running_event = TRUE;
			}
			break;
		case NO_EVENT:
		case POWER_FAILED:
		case POWER_RESTORED:
			running_event = TRUE;
			break;
		default:
			break;
		}
	}
	return running_event;
}

/**
* change_running_state
*
* Description:
*   Changes the running state based upon the current state and an event.
*
* Parameters:
*   anEvent The current event occuring within the RUNNING state.
*   aCurrentState  The current RUNNING sub-state.
*
* Returns:
*   The new RUNNING state.
*/
DWORD change_running_state(DWORD aCurrentState, DWORD anEvent){
	DWORD new_state;
    
	// Determine new RUNNING sub-state
	switch (anEvent){
	case LOST_COMM:
		new_state = NO_COMM;
		break;
	case POWER_FAILED:
		new_state = ON_BATTERY;
		break;
	case POWER_RESTORED:
		new_state = ON_LINE;
		break;
	case NO_EVENT:
	default:
		new_state = aCurrentState;
		break;
	}
	
	// Close down the old sub-state and enter the new one.
	if (new_state != aCurrentState){
		exit_running_state(aCurrentState, anEvent);
		enter_running_state(new_state, anEvent);
	}
	
	return new_state;
}

/**
* exit_running_state
*
* Description:
*   Exits the currently executing sub-state.
*
* Parameters:
*   anEvent The event that is causing the transition from a sub-state.
*   aCurrentState  The current RUNNING sub-state.
*
* Returns:
*   None
*/
void exit_running_state(DWORD aCurrentState, DWORD anEvent){
	switch (aCurrentState){
	case ON_LINE:
		OnLine_Exit(anEvent);
		break;
	case ON_BATTERY:
		OnBattery_Exit(anEvent);
		theLogPowerRestoredEvent = TRUE;
		break;
	case NO_COMM:
		NoComm_Exit(anEvent);
		break;
	default:
		break;
	}	
}

/**
* enter_running_state
*
* Description:
*   Initializes the new RUNNING sub-state.
*
* Parameters:
*   anEvent The event that is causing the transition to a sub-state.
*   aCurrentState  A RUNNING sub-state to enter.
*
* Returns:
*   None
*/
void enter_running_state(DWORD aCurrentState, DWORD anEvent){
	switch (aCurrentState){
	case ON_LINE:
		OnLine_Enter(anEvent, theLogPowerRestoredEvent);
		theLogPowerRestoredEvent = FALSE;
		break;
	case ON_BATTERY:
		OnBattery_Enter(anEvent);
		break;
	case NO_COMM:
		NoComm_Enter(anEvent);
		break;
	default:
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\run_states.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
* 
* Description:
*   Interface to the RUNNING states (ON_LINE, ON_BATTERY and NO_COMM)
*
* Revision History:
*   dsmith  31Mar1999  Created
*
*/
#ifndef _INC_RUNSTATES_H_
#define _INC_RUNSTATES_H_

#include <windows.h>

// Definitions for the RUNNING sub-states

// Each state has three methods associated with it:  Enter, DoWork and Exit
// DoWork is where all of the major state work is performed.  Enter and Exit 
// is where one time processing tasks associated with the state is 
// done.

void OnLine_Enter(DWORD anEvent, int aLogPowerRestoredEvent);
DWORD OnLine_DoWork(void);
void OnLine_Exit(DWORD anEvent);

void OnBattery_Enter(DWORD anEvent);
DWORD OnBattery_DoWork(void);
void OnBattery_Exit(DWORD anEvent);

void NoComm_Enter(DWORD anEvent);
DWORD NoComm_DoWork(void);
void NoComm_Exit(DWORD anEvent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\run_states.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
* 
* Description:
*   Implementation for all RUNNING substates (ON_LINE, ON_BATTERY and NO_COMM)
*
* Revision History:
*   dsmith  31Mar1999  Created
*   mholly  28Apr1999  call InitUPSStatusBlock & SaveUPSStatusBlock when
*                       updating the registry in NoComm_Enter/Exit
*/

#include <windows.h>


#include "states.h"
#include "events.h"
#include "run_states.h"
#include "statmach.h"
#include "driver.h"
#include "eventlog.h"
#include "notifier.h"
#include "upsmsg.h"
#include "upsreg.h"

// Internal Prototypes
DWORD convert_ups_state_to_run_state(DWORD aUPSstate);
DWORD get_new_state();
DWORD get_transition_event();


// Internal constants
#define WAIT_FOREVER_C							INFINITE
#define MILLISECONDS_CONVERSION_C				1000
#define DEFAULT_NOTIFICATION_INTERVAL_C			0  // disable periodic notification
#define DEFAULT_ON_BATTERY_MESSAGE_DELAY_C		5  // in seconds
#define MINUTES_TO_MILLISECONDS_CONVERSION_C	60*MILLISECONDS_CONVERSION_C  


/**
* OnLine_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the ON_LINE state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void OnLine_Enter(DWORD anEvent, int aLogPowerRestoredEvent){
	DWORD notification_interval = DEFAULT_NOTIFICATION_INTERVAL_C;  
    
    //
    // update the registry with status
    //
    InitUPSStatusBlock();
    SetUPSStatusUtilityStatus(UPS_UTILITYPOWER_ON);
    SaveUPSStatusBlock(FALSE);
	
	if (aLogPowerRestoredEvent == TRUE){
	  // Log the power restored event only if appropriate
	  LogEvent(NELOG_UPS_PowerBack, NULL, ERROR_SUCCESS);
	}
	
	/* 
     * Send the power restored message if notification is enabled.
     *
     * patrickf: Supress notification message for now
     * SendNotification(APE2_UPS_POWER_BACK, notification_interval, 0);  
     */
     CancelNotification();
}

/**
* OnLine_DoWork
*
* Description:
*   Wait until the UPS changes state or the state machine exits,
*   then leave this state.
*
* Parameters:
*   None
*
* Returns:
*   The event that caused the transition from the ON_LINE state.
*/
DWORD OnLine_DoWork(){
    DWORD new_state;
    
    new_state = get_new_state();
    while (new_state == ON_LINE && IsStateMachineActive() == TRUE){
        
        // Wait until the UPS state changes.  If the state becomes something
		// other than ONLINE, then exit the ONLINE state.  
        UPSWaitForStateChange(UPS_ONLINE, WAIT_FOREVER_C);
        new_state = get_new_state();
    }
    
    return get_transition_event();
}

/**
* OnLine_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the ON_LINE state.
*
* Parameters:
*   anEvent The event that caused the transition from the ON_LINE state.
*
* Returns:
*   None
*/
void OnLine_Exit(DWORD anEvent){  
	// No work to perform.
}

/**
* OnBattery_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the ON_BATTERY state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void OnBattery_Enter(DWORD anEvent)
{
    BOOL        send_power_failed_message = TRUE;
    DWORD       on_battery_message_delay = DEFAULT_ON_BATTERY_MESSAGE_DELAY_C;
    DWORD       notification_interval = DEFAULT_NOTIFICATION_INTERVAL_C;
	LONG        reg_err;
	
	
  //
  // update the registry with the power failed status
  //
  InitUPSStatusBlock();
  SetUPSStatusUtilityStatus(UPS_UTILITYPOWER_OFF);
  SaveUPSStatusBlock(FALSE);
	
    //Log the power failed event 
	LogEvent(NELOG_UPS_PowerOut, NULL, ERROR_SUCCESS);
	
  // Determine if a power failed notification should take place
	InitUPSConfigBlock();
	reg_err = GetUPSConfigNotifyEnable(&send_power_failed_message);

  if (reg_err != ERROR_SUCCESS){
		send_power_failed_message = TRUE;
	}
	
	if (send_power_failed_message){
		
		// Send the power failed notification after notification delay has expired
		reg_err = GetUPSConfigFirstMessageDelay(&on_battery_message_delay);
		if (reg_err != ERROR_SUCCESS){
			on_battery_message_delay = DEFAULT_ON_BATTERY_MESSAGE_DELAY_C;
		}

        reg_err = GetUPSConfigMessageInterval(&notification_interval);
        if (reg_err != ERROR_SUCCESS) {
            notification_interval = DEFAULT_NOTIFICATION_INTERVAL_C;
        }
		
		// Send the power failed message 
		SendNotification(APE2_UPS_POWER_OUT, notification_interval, on_battery_message_delay);  
	}    
}

/**
* OnBattery_DoWork
*
* Description:
*   Log on battery event and either wait for a low battery condition or until
*  the on battery timer expires.  A transition to power restored will also cause
*  an exit of this state.
*
* Parameters:
*   None
*
* Returns:
*   The event that caused the transition from the ON_BATTERY state.
*/
DWORD OnBattery_DoWork(){
	DWORD wait_before_shutdown = WAIT_FOREVER_C;
	DWORD battery_timer_enabled = FALSE;
	LONG reg_err;
	DWORD transition_event;
	DWORD time_to_wait_while_on_battery;
	
	
	// If the on battery timer is enabled, get the on battery delay.  This is the amount
	// time to remain on battery before tranisitioning to the shutdown state.
	InitUPSConfigBlock();
	
	reg_err = GetUPSConfigShutdownOnBatteryEnable(&battery_timer_enabled);
	if (reg_err == ERROR_SUCCESS && battery_timer_enabled == TRUE){
		reg_err = GetUPSConfigShutdownOnBatteryWait(&time_to_wait_while_on_battery);
		
		if (reg_err == ERROR_SUCCESS){
			wait_before_shutdown = time_to_wait_while_on_battery * MINUTES_TO_MILLISECONDS_CONVERSION_C;
		}
	}
	
	// Wait until the UPS changes state from ON_BATTERY or the 
	// ON_BATTERY timer expires
	if(get_new_state() == ON_BATTERY && IsStateMachineActive() == TRUE){
		UPSWaitForStateChange(UPS_ONBATTERY, wait_before_shutdown );
		if (get_new_state() == ON_BATTERY){
			
			// Set the event that caused the state change.
			transition_event = ON_BATTERY_TIMER_EXPIRED;
		}
		else{
			// Set the event that caused the state change.
			transition_event = get_transition_event();
		}
	}
	else{
		// Set the event that caused the state change.
		transition_event = get_transition_event();
	}
	return transition_event;
}

/**
* OnBattery_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the ON_BATTERY state.
*
* Parameters:
*   anEvent The event that caused the transition from the ON_BATTERY state.
*
* Returns:
*   None
*/
void OnBattery_Exit(DWORD anEvent){
  // Stop sending power failure notifications
  CancelNotification();
}

/**
* NoComm_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the NO_COMM state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void NoComm_Enter(DWORD anEvent){
    InitUPSStatusBlock();
	SetUPSStatusCommStatus(UPS_COMMSTATUS_LOST);
    SaveUPSStatusBlock(FALSE);
}

/**
* NoComm_DoWork
*
* Description:
*   Wait until the UPS changes state or the state machine exits.  
*
* Parameters:
*   None
*
* Returns:
*   The event that caused the transition from the NO_COMM state.
*/
DWORD NoComm_DoWork(){
	
	// Wait until the UPS state changes, then exit the NO COMM state
	while (get_new_state() == NO_COMM && IsStateMachineActive() == TRUE){
		UPSWaitForStateChange(UPS_NOCOMM, WAIT_FOREVER_C);
	}
	return get_transition_event();	
}

/**
* NoComm_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the NO_COMM state.
*
* Parameters:
*   anEvent The event that caused the transition from the NO_COMM state.
*
* Returns:
*   None
*/
void NoComm_Exit(DWORD anEvent){
    // If we leave this state, then some signal has been received from the UPS.
	// Set the com status to good
    InitUPSStatusBlock();
	SetUPSStatusCommStatus(UPS_COMMSTATUS_OK);
    SaveUPSStatusBlock(FALSE);
}



/**
* get_new_state
*
* Description:
*   Retrieves the UPS status and converts the it into a state.
*
* Parameters:
*   None
*
* Returns:
*   The new run state.
*/
DWORD get_new_state(){
	DWORD ups_state;
	
	ups_state = UPSGetState();
	
	return convert_ups_state_to_run_state(ups_state);
}


/**
* convert_ups_state_to_run_state
*
* Description:
*   Converts a UPS state into a run state.
*
* Parameters:
*   aUPSstate The condition of the UPS.
*
* Returns:
*   The new run state.
*/
DWORD convert_ups_state_to_run_state(DWORD aUPSstate){
	DWORD new_event;
	
	switch (aUPSstate){
	case UPS_ONLINE:
		new_event = ON_LINE;
		break;
	case UPS_ONBATTERY:
		new_event = ON_BATTERY;
		break;
	case UPS_LOWBATTERY:
		new_event = LOW_BATTERY;
		break;
	case UPS_NOCOMM:
		new_event = NO_COMM;
		break;
	default:
		new_event = EXIT_NOW; //error
	}
	return new_event;
}

/**
* get_transition_event
*
* Description:
*   Returns the event that caused a state transition.
*
* Parameters:
*   None
*
* Returns:
*   The event that caused a state transition.
*/
DWORD get_transition_event(){
	DWORD ups_state;
	DWORD new_event;
	
	ups_state = UPSGetState();
	
	switch (ups_state){
	case UPS_ONLINE:
		new_event = POWER_RESTORED;
		break;
	case UPS_ONBATTERY:
		new_event = POWER_FAILED;
		break;
	case UPS_LOWBATTERY:
		new_event = LOW_BATTERY;
		break;
	case UPS_NOCOMM:
		new_event = LOST_COMM;
		break;
	default:
		new_event = NO_EVENT;
	}
	
	return new_event;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\shutdown.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file implements the Shutdowner.  The Shutdowner is reponsible
 *   for performing a graceful shutdown of the operating system.
 *
 *
 * Revision History:
 *   sberard  01Apr1999  initial revision.
 *
 */ 
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "shutdown.h"
#include "powrprof.h"

#ifdef __cplusplus
extern "C" {
#endif

  /**
   * ShutdownSystem
   *
   * Description:
   *   This function initiates a graceful shutdown of the operating system.
   *   This is performed through a call to the Win32 function ExitWindowsEx(..).
   *   When called the shutdown is initated immediately and, is successful, the
   *   function returns TRUE.  Otherwise, FALSE is retuned.
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   TRUE  - if the shutdown was initiated successfully
   *   FALSE - if errors occur while initiating shutdown
   */
BOOL ShutdownSystem() 
{
    BOOL                        ret_val = FALSE;
	TOKEN_PRIVILEGES            tkp;
	HANDLE                      process_token;
    SYSTEM_POWER_CAPABILITIES   SysPwrCapabilities;

  
    // get the current process token so that we can
    //  modify our current process privs.
    if (OpenProcessToken(GetCurrentProcess(),
	      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &process_token)) {

    // Find the local unique id for SeShutdownPrivilege
    if (LookupPrivilegeValue(NULL, TEXT("SeShutdownPrivilege"), &tkp.Privileges[0].Luid)) {

        // we only want to enable one priv
        tkp.PrivilegeCount = 1;
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	      
        // now, add it all back to our current process.
        if (AdjustTokenPrivileges(process_token,                // do it to us
                                    FALSE,                      // don't turn all privs off
                                    &tkp,                       // what we want to do
                                    0,                          // don't want any prev info
                                    (PTOKEN_PRIVILEGES)NULL,
                                    0)) {		

            // Initiate the shutdown
            if (GetPwrCapabilities(&SysPwrCapabilities) && SysPwrCapabilities.SystemS5) {
                ret_val = ExitWindowsEx(EWX_SHUTDOWN | EWX_FORCE | EWX_POWEROFF, (DWORD) -1);
            } else {
                ret_val = ExitWindowsEx(EWX_SHUTDOWN | EWX_FORCE, (DWORD) -1);
            }
        }
    }
	  }

    return ret_val;
  }

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\service.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file implements the main portion of the native NT UPS
 *   service for Windows 2000.  It implements all of the functions
 *   required by all Windows NT services.
 *
 *
 * Revision History:
 *   sberard  25Mar1999  initial revision.
 *
 */ 

#include <windows.h>
#include <winsvc.h>
#include <lmsname.h>

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif

// name of the executable
#define SZAPPNAME            "ups.exe"
// internal name of the service
#define SZSERVICENAME        SERVICE_UPS
// displayed name of the service
#define SZSERVICEDISPLAYNAME "Uninterruptable Power Supply"
// no dependencies
#define SZDEPENDENCIES       ""

// amount of time (in milliseconds) for the SCM to wait for start, stop, ...
#define UPS_SERVICE_WAIT_TIME  15000    // 15 seconds

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\service.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved 
 * 
 * Description:
 *   The file implements the main portion of the native NT UPS
 *   service for Windows 2000.  It implements all of the functions
 *   required by all Windows NT services.
 *
 * Revision History:
 *   sberard  25Mar1999  initial revision.
 *
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

#include "service.h"
#include "polmgr.h"
#include "shutdown.h"
#include "notifier.h"
#include "eventlog.h"
#include "cmdexe.h"
#include "upsmsg.h"

#ifdef __cplusplus
extern "C" {
#endif


// global variables
SERVICE_STATUS          _theServiceStatus;       
SERVICE_STATUS_HANDLE   _theServiceStatusHandle;

// Internal function prototypes
VOID ServiceMain(DWORD anArgCount, LPTSTR *anArgList);
static VOID WINAPI ServiceControl(DWORD aControlCode);
static BOOL ConsoleHandler (DWORD aControlType);
static BOOL ServiceInit();
static BOOL SetServiceState(DWORD aNewState);

/**
 * main
 * 
 * Description:
 *   This is the entrypoint for the service.  StartServiceCtrlDispatcher
 *   is called to register the main service thread.  If this call returns
 *   the service has been stopped.
 *
 * Parameters:
 *   argc - number of command line arguments
 *   argv - array of command line arguments
 *
 * Returns:
 *   void
 */
void __cdecl main(int argc, char **argv) {
  // Initialize the service table
  SERVICE_TABLE_ENTRY dispatch_table[] = {
    { SZSERVICENAME, ServiceMain},
    { NULL, NULL}
  };

  if (!StartServiceCtrlDispatcher(dispatch_table)) {
    LogEvent(NERR_UPSInvalidConfig, NULL, GetLastError());
  }

  ExitProcess(0);
}



/** 
 * ServiceMain
 *
 * Description:
 *   Implements the core functionality of the service.
 *
 * Returns:
 *   VOID
 */
VOID ServiceMain(DWORD anArgCount, LPTSTR *anArgList) {
  // Initialize service parameters
  if (ServiceInit()) {

    // Update the service state
    SetServiceState(SERVICE_RUNNING);
  
  	PolicyManagerRun();
  }
  
  // Tell the SCM that the service is stopped
  if (_theServiceStatusHandle) {
    // TBD
  }

  // Do any termination stuff

  // Tell the SCM that we are stopped
  SetServiceState(SERVICE_STOPPED);

}



/**
 * ServiceControl
 *
 * Description:
 *   This function is called by the SCM whenever ControlService() is called.
 *   It is responsible for communicating service control requests to the service.
 *
 * Parameters:
 *   aControlCode - type of control requested
 *
 * Returns:
 *   VOID
 */
static VOID WINAPI ServiceControl(DWORD aControlCode) {
 
  // Handle the requested control code.
  //
  switch (aControlCode) {
    // Requests the service to stop.  
    case SERVICE_CONTROL_STOP:
    // Requests the service to perform cleanup tasks, due to shutdown
    case SERVICE_CONTROL_SHUTDOWN:
      // Tell the SCM that we are stopping
      SetServiceState(SERVICE_STOP_PENDING);

      // Call stop on the policy manager
      PolicyManagerStop();
      break;

    // Requests the service to pause.
    case SERVICE_CONTROL_PAUSE:
      break;

    // Requests the paused service to resume.
    case SERVICE_CONTROL_CONTINUE:
      break;

    // Requests the service to update immediately 
    // its current status information to the service control manager.
    case SERVICE_CONTROL_INTERROGATE:
      break;

    // Invalid control code
    default:
      // Ignore the request
      break;
  }
}


/**
 * ServiceInit
 *
 * Description:
 *   This function is responsible the service with the SCM.
 *
 * Parameters:
 *   none
 *
 * Returns:
 *   TRUE  - if there are no errors in initialization
 *   FALSE - if errors occur during initialization
 */
static BOOL ServiceInit() {
  BOOL ret_val = TRUE;
  DWORD result;

  // Register a service control handler with the SCM
  _theServiceStatusHandle = RegisterServiceCtrlHandler( SZSERVICENAME, ServiceControl);

  if (_theServiceStatusHandle) {
    _theServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    _theServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    _theServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
// sberard - Removed.  Pause/Continue is not supported
//                                         SERVICE_ACCEPT_PAUSE_CONTINUE |
                                           SERVICE_ACCEPT_SHUTDOWN;
    _theServiceStatus.dwCheckPoint = 1;  // This service only has 1 initialization step
    _theServiceStatus.dwWaitHint = UPS_SERVICE_WAIT_TIME;
    _theServiceStatus.dwWin32ExitCode = NO_ERROR;
    _theServiceStatus.dwServiceSpecificExitCode = 0;  // ignored

    // Update SCM with the service's current status
    if (!SetServiceStatus(_theServiceStatusHandle, &_theServiceStatus)) {
      // TBD, report error?
      ret_val = FALSE;
    }

    // Initialize the UPS policy manager
    result = PolicyManagerInit();

   	if (result != ERROR_SUCCESS) {
      // An error occured, set the service error code and update the SCM
      _theServiceStatus.dwWin32ExitCode = result;
      SetServiceStatus(_theServiceStatusHandle, &_theServiceStatus);
      ret_val = FALSE;
    }

  }
  else {
    ret_val = FALSE;
  }

  return ret_val;
}


/**
 * SetServiceState
 *
 * Description:
 *   This function is responsible the updating the SCM with the current service state.
 *
 * Parameters:
 *   aNewState - the state to update the SCM with
 *
 * Returns:
 *   TRUE  - if the update was successfull
 *   FALSE - if the service set was not able to be updated
 */
static BOOL SetServiceState(DWORD aNewState) {
  BOOL ret_val = TRUE;

  if (_theServiceStatusHandle) {
    _theServiceStatus.dwCurrentState = aNewState;

    // Update SCM with the service's current status
    if (!SetServiceStatus(_theServiceStatusHandle, &_theServiceStatus)) {
      // TBD, report error?
      ret_val = FALSE;
    }
  }
  else {
    ret_val = FALSE;
  }
  
  return ret_val;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\test_main.c ===
#include <windows.h>
#include "polmgr.h"
#include <process.h> 
#include <stdio.h>   
#include "eventlog.h"
#include "notifier.h"
void testmethod();


void main(){
   DWORD err;


	err = PolicyManagerInit();
//	_beginthread( testmethod, 0, NULL);

	PolicyManagerRun();



      
}

void testmethod(){
int i=0;
	Sleep(3000);
	PolicyManagerStop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\shutdown.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file defines the interface to the Shutdowner.  The 
 *   Shutdowner is reponsible for performing a graceful
 *   shutdown of the operating system.
 *
 *
 * Revision History:
 *   sberard  01Apr1999  initial revision.
 *
 */ 

#include <windows.h>

#ifndef _SHUTDOWN_H
#define _SHUTDOWN_H


#ifdef __cplusplus
extern "C" {
#endif

  /**
   * ShutdownSystem
   *
   * Description:
   *   This function initiates a graceful shutdown of the operating system.
   *   This is performed through a call to the Win32 function ExitWindowsEx(..).
   *   When called the shutdown is initated immediately and, is successful, the
   *   function returns TRUE.  Otherwise, FALSE is retuned.
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   TRUE  - if the shutdown was initiated successfully
   *   FALSE - if errors occur while initiating shutdown
   */
  BOOL ShutdownSystem();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\states.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
* 
* Description:
*   Implementation of the super states of the UPS native service: 
*  Initializing,Waiting_To_Shutdown, Shutting_Down and Stopping
*
* Revision History:
*   dsmith  1April1999  Created
*
*/
#include <windows.h>

#include "events.h"
#include "driver.h"
#include "eventlog.h"
#include "notifier.h"
#include "shutdown.h"
#include "hibernate.h"
#include "upsmsg.h"       // Included since direct access to message #defines is not possible
#include "cmdexe.h"
#include "upsreg.h"


// Internal constants
#define DELAY_UNTIL_SHUTDOWN_C							30000 // 30 seconds
#define DEFAULT_NOTIFICATION_INTERVAL_C			0			// disable periodic notification
#define MILLISECONDS_CONVERSION_C						1000
#define DEFAULT_TURN_OFF_DELAY_C						120   // seconds


/**
* Initializing_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the INITIALIZING state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void Initializing_Enter(DWORD anEvent){
  DWORD first_msg_delay, msg_interval, shutdown_wait;

	// Default all registry values and set up any new keys required by the
	// service and applet
	InitializeRegistry();

  // Check the ranges of the Config registry keys
  InitUPSConfigBlock();

  // Check FirstMessageDelay
  if (GetUPSConfigFirstMessageDelay(&first_msg_delay) == ERROR_SUCCESS)  {
    if (first_msg_delay > WAITSECONDSLASTVAL) {
      // Value out of range, set to default
      SetUPSConfigFirstMessageDelay(WAITSECONDSDEFAULT);
    }
  }

  // Check MessageInterval
  if (GetUPSConfigMessageInterval(&msg_interval) == ERROR_SUCCESS)  {
    if ((msg_interval < REPEATSECONDSFIRSTVAL) || (msg_interval > REPEATSECONDSLASTVAL)) {
      // Value out of range, set to default
      SetUPSConfigMessageInterval(REPEATSECONDSDEFAULT);
    }
  }

  // Check Config\ShutdownOnBatteryWait
  if (GetUPSConfigShutdownOnBatteryWait(&shutdown_wait) == ERROR_SUCCESS)  {
    if ((shutdown_wait < SHUTDOWNTIMERMINUTESFIRSTVAL) || (shutdown_wait > SHUTDOWNTIMERMINUTESLASTVAL)) {
      // Value out of range, set to default
      SetUPSConfigFirstMessageDelay(SHUTDOWNTIMERMINUTESDEFAULT);
    }
  }

  // Write any changes and free the Config block
  SaveUPSConfigBlock(FALSE);   // Don't force an update of all values
  FreeUPSConfigBlock();
}

/**
* Initializing_DoWork
*
* Description:
*   Initialize the UPS driver  
*
* Parameters:
*   None
*
* Returns:
*   An error status from the UPS.
*/
DWORD Initializing_DoWork(){
    DWORD err;
    DWORD options = 0;

    InitUPSConfigBlock();

    // Check the Options reg key to see if the UPS is installed
    if ((GetUPSConfigOptions(&options) == ERROR_SUCCESS) &&
      (options & UPS_INSTALLED)) {
      // UPS is installed, continue initialization
    
      // Create UPS driver
      err = UPSInit();

      // Convert UPS error to system error
      switch(err){
      case UPS_INITUNKNOWNERROR:
          err = NERR_UPSInvalidConfig;
          break;
      case UPS_INITOK:
          err = NERR_Success;
          break;
      case UPS_INITNOSUCHDRIVER:
          err = NERR_UPSDriverNotStarted;
          break;
      case UPS_INITBADINTERFACE:
          err = NERR_UPSInvalidConfig;
          break;
      case UPS_INITREGISTRYERROR:
          err = NERR_UPSInvalidConfig;
          break;
      case UPS_INITCOMMOPENERROR:
          err = NERR_UPSInvalidCommPort;
          break;
      case UPS_INITCOMMSETUPERROR:
          err = NERR_UPSInvalidCommPort;
          break;
      default:
          err = NERR_UPSInvalidConfig;
      }
    }
    else {
      // UPS is not installed, return configuration error
      err = NERR_UPSInvalidConfig;
    }

    FreeUPSConfigBlock();

    return err; 
}


/**
* Initializing_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the INITIALIZING state.
*
* Parameters:
*   anEvent The event that caused the transition from the INITIALIZING state.
*
* Returns:
*   None
*/
void Initializing_Exit(DWORD anEvent){
// No work to perform 
}


/**
* WaitingToShutdown_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the WAITING_TO_SHUTDOWN state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void WaitingToShutdown_Enter(DWORD anEvent){
	// Stop periodic notifications
	CancelNotification();
}


/**
* WaitingToShutdown_DoWork
*
* Description:
*   Perform shutdown actions then transition out of this state.  
*
* Parameters:
*   None
*
* Returns:
*   The event that caused the transition from the WAITING_TO_SHUTDOWN state.
*/
DWORD WaitingToShutdown_DoWork(){
	LONG err;
	DWORD run_command_file;
	DWORD notification_interval = 0;  // Notify only once
	DWORD send_final_notification;
	HANDLE sleep_timer;
	
	// Send the shutdown notification.  If a configuration error occurs, 
	// send the final notification by default.
	err = GetUPSConfigNotifyEnable(&send_final_notification);
	if (err != ERROR_SUCCESS || send_final_notification == TRUE){
		SendNotification(APE2_UPS_POWER_SHUTDOWN, notification_interval, 0); 
	}
	
	// Determine which actions to perform
	// If command file action is enabled, execute command file and
	// then wait
	
	InitUPSConfigBlock();
	err = GetUPSConfigRunTaskEnable(&run_command_file);
	if (err != ERROR_SUCCESS){
		run_command_file = FALSE;
	}
	if (run_command_file == TRUE){
		
		// Execute the command file and wait for a while.   If the
		// command file fails to execute, log an error to the system
		// event log.
		if (ExecuteShutdownTask() == FALSE){
			
			// Log failed command file event
			LogEvent(NELOG_UPS_CmdFileExec, NULL, GetLastError());
		}
	}
	
	// Always wait here before exiting this state 
	
	// Use the WaitForSingleObject since Sleep is not guaranteed to always work
	sleep_timer = CreateEvent(NULL, FALSE, FALSE, NULL);
	
	if (sleep_timer){
		// Since nothing can signal this event, the following API will wait
		// until the time elapses
		WaitForSingleObject(sleep_timer, DELAY_UNTIL_SHUTDOWN_C);
		CloseHandle(sleep_timer);
	}
	// If the sleep_timer could not be created, try the sleep call anyway
	else {
		Sleep(DELAY_UNTIL_SHUTDOWN_C);
	}
	return SHUTDOWN_ACTIONS_COMPLETED;
}


/**
* WaitingToShutdown_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the WAITING_TO_SHUTDOWN state.
*
* Parameters:
*   anEvent The event that caused the transition from the WAITING_TO_SHUTDOWN state.
*
* Returns:
*   None
*/
void WaitingToShutdown_Exit(DWORD anEvent){   
// No work to perform 
}

/**
* ShuttingDown_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the SHUTTING_DOWN state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void ShuttingDown_Enter(DWORD anEvent){
	// Log the final shut down message
	LogEvent(NELOG_UPS_Shutdown, NULL, ERROR_SUCCESS);

}


/**
* ShuttingDown_DoWork
*
* Description:
*   Shuts down the OS. This state will waits until the shutdown has completed,
*  then exits.
*
* Parameters:
*   None
*
* Returns:
*   The event that caused the transition from the SHUTTING_DOWN state.
*/
DWORD ShuttingDown_DoWork(){
  DWORD ups_turn_off_enable;
  DWORD ups_turn_off_wait;

  // Initialize registry functions
	InitUPSConfigBlock();

  // Lookup the turn off enable in the registry
  if ((GetUPSConfigTurnOffEnable(&ups_turn_off_enable) == ERROR_SUCCESS)
    && (ups_turn_off_enable == TRUE)) {
    // UPS Turn off enabled, lookup the turn off wait in the registry
    if (GetUPSConfigTurnOffWait(&ups_turn_off_wait) != ERROR_SUCCESS) {
      // Error obtaining the value, use the default instead
      ups_turn_off_wait = DEFAULT_TURN_OFF_DELAY_C;
    }
    
    // Tell the UPS driver to turn off the power after the shutdown delay
    UPSTurnOff(ups_turn_off_wait);
  }

	// Tell the OS to Shutdown
	ShutdownSystem(); 

  // Free the UPS registry config block
  FreeUPSConfigBlock();

	return SHUTDOWN_COMPLETE; 
}

/**
* ShuttingDown_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the SHUTTING_DOWN state.
*
* Parameters:
*   anEvent The event that caused the transition from the SHUTTING_DOWN state.
*
* Returns:
*   None
*/
void ShuttingDown_Exit(DWORD anEvent){
// No work to perform 
}



/**
* Hibernate_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the HIBERNATE state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void Hibernate_Enter(DWORD anEvent){
	// Stop periodic notifications
	CancelNotification();
}


/**
* Hibernate_DoWork
*
* Description:
*   Perform hibernation actions then transition out of this state.  
*
* Parameters:
*   None
*
* Returns:
*   The event that caused the transition from the HIBERNATE state.
*/
DWORD Hibernate_DoWork(){
  DWORD event = HIBERNATION_ERROR;
	LONG  err;
  DWORD ups_turn_off_enable;
  DWORD ups_turn_off_wait;
	DWORD notification_interval = 0;  // Notify only once
	DWORD send_hibernate_notification;

  // Initialize registry functions
	InitUPSConfigBlock();

	// Send the hibernation notification.  If a configuration error occurs, 
	// send the notification by default.
	err = GetUPSConfigNotifyEnable(&send_hibernate_notification);
	if (err != ERROR_SUCCESS || send_hibernate_notification == TRUE){
		// TODO:  Send Hibernation nofication
    //SendNotification(HIBERNATE, notification_interval); 
	}

  // Lookup the turn off enable in the registry
  if ((GetUPSConfigTurnOffEnable(&ups_turn_off_enable) == ERROR_SUCCESS)
    && (ups_turn_off_enable == TRUE)) {
    // UPS Turn off enabled, lookup the turn off wait in the registry
    if (GetUPSConfigTurnOffWait(&ups_turn_off_wait) != ERROR_SUCCESS) {
      // Error obtaining the value, use the default instead
      ups_turn_off_wait = DEFAULT_TURN_OFF_DELAY_C;
    }
    
    // Tell the UPS driver to turn off the power after the shutdown delay
    UPSTurnOff(ups_turn_off_wait);
  }

  // Stop the UPS driver.  This needs to be done to ensure that we can start
	// correctly when we return from hibernation.
	UPSStop();

  // Now Hibernate
  if (HibernateSystem() == TRUE) {
    // The system was hibernated and subsequently restored
    event = RETURN_FROM_HIBERNATION;
  }
  else {
    // There was an error attempting to hibernate the system
    event = HIBERNATION_ERROR;
  }

  // Free the UPS registry config block
  FreeUPSConfigBlock();

	return event;
}


/**
* Hibernate_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the HIBERNATE state.
*
* Parameters:
*   anEvent The event that caused the transition from the HIBERNATE state.
*
* Returns:
*   None
*/
void Hibernate_Exit(DWORD anEvent){   
// No work to perform 
}


/**
* Stopping_Enter
*
* Description:
*   Performs the actions necessary when transitioning into the STOPPING state.
*
* Parameters:
*   anEvent The event that caused the transition into this state.
*
* Returns:
*   None
*/
void Stopping_Enter(DWORD anEvent){
// No work to perform 
}


/**
* ShuttingDown_DoWork
*
* Description:
*   Perform any final cleanup activities.  
*
* Parameters:
*   None
*
* Returns:
*   The event that caused the transition from the STOPPING state.
*/
DWORD Stopping_DoWork(){
	
	// Orderly stop the UPS driver (if there is time)
	UPSStop();

	// Cleanup 
	FreeUPSConfigBlock();
	FreeUPSStatusBlock();

	return STOPPED;
}

/**
* Stopping_Exit
*
* Description:
*   Performs the actions necessary when transitioning from the STOPPING state.
*
* Parameters:
*   anEvent The event that caused the transition from the STOPPING state.
*
* Returns:
*   None
*/
void Stopping_Exit(DWORD anEvent){
// No work to perform 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\states.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   Interface to all high level states.
 *
 * Revision History:
 *   dsmith  31Mar1999  Created
 *
 */
#ifndef _INC_STATES_H_
#define _INC_STATES_H_

#include <windows.h>

////////////////////
// States
////////////////////

#define INITIALIZING					0
#define RUNNING 							1
#define NO_COMM 							2
#define ON_LINE 							3
#define ON_BATTERY						4
#define WAITING_TO_SHUTDOWN		5
#define SHUTTING_DOWN 				6
#define HIBERNATE							7
#define STOPPING							8
#define EXIT_NOW							9



////////////////////
// State Methods
////////////////////

// Each state has three methods associated with it:  Enter, DoWork and Exit
// DoWork is where all of the major state work is performed.  Enter and Exit 
// is where one time processing tasks associated with the state is 
// done.

void Initializing_Enter(DWORD anEvent);
DWORD Initializing_DoWork();
void Initializing_Exit(DWORD anEvent);

void WaitingToShutdown_Enter(DWORD anEvent);
DWORD WaitingToShutdown_DoWork();
void WaitingToShutdown_Exit(DWORD anEvent);

void ShuttingDown_Enter(DWORD anEvent);
DWORD ShuttingDown_DoWork();
void ShuttingDown_Exit(DWORD anEvent);

void Hibernate_Enter(DWORD anEvent);
DWORD Hibernate_DoWork();
void Hibernate_Exit(DWORD anEvent);

void Stopping_Enter(DWORD anEvent);
DWORD Stopping_DoWork();
void Stopping_Exit(DWORD anEvent);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\statmach.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   Interface for the UPS service state machine.
 *
 * Revision History:
 *   dsmith  31Mar1999  Created
 *
 */
#ifndef _INC_STATEMACHINE_H_
#define _INC_STATEMACHINE_H_

#include <windows.h>


// Starts the state machine.  This method will not return until the state machine
// exits.
void RunStateMachine();

// Acessor method for the various states to determine if an exit all states override has 
// been issued.
BOOL IsStateMachineActive();

// Interrupts the state machine and forces an exit.  This method will be ignored
// if the service is in one of the shutting down states.
void StopStateMachine();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\statmach.c ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   Implements the native UPS sevice state machine.   The various states executed
 *  within the state machine are housed in separate files.
 *
 * Revision History:
 *   dsmith  31Mar1999  Created
 *
 */
#include <windows.h>

#include "states.h"
#include "events.h"
#include "driver.h"
#include "running_statmach.h"
#include "upsreg.h"

// Internal function Prototypes
static void enter_state(DWORD aNewState, DWORD anEvent);
static DWORD do_work(DWORD aCurrentState);
static void exit_state(DWORD anOldState, DWORD anEvent);
static DWORD change_state(DWORD aCurrentState, DWORD anEvent);
static DWORD get_new_state(DWORD aCurrentState, DWORD anEvent);


// State Machine Variables
BOOL theIsStateMachineActive = TRUE;


/**
 * RunStateMachine
 *
 * Description:
 * Starts the state machine.  This method will not return until the state machine
 * exits.
 *
 * Parameters:
 *   None
 *
 * Returns:
 *   None
 */
void RunStateMachine(){
	
	// Set the primary state to RUNNING
	DWORD new_state = RUNNING;
	DWORD current_state = new_state;
	DWORD event = NO_EVENT;
	
	enter_state(new_state, event);
	
	// Continue processing state changes until the state becomes the EXIT_NOW state
	while (new_state != EXIT_NOW){
		current_state = new_state;
		
		event = do_work(current_state);
		new_state = change_state(new_state, event);	
	}
}

/**
 * StopStateMachine
 *
 * Description:
 *   Stops the UPS service state machine if the service is not in the 
 * middle of a shutdown sequence.
 *
 * Parameters:
 *   None
 *
 * Returns:
 *   None
 */
void StopStateMachine(){

	theIsStateMachineActive = FALSE;

	// Wake up the main service thread
	UPSCancelWait();
}

/**
 * IsStateMachineActive
 *
 * Description:
 *   Returns the running status of the state machine.  If the state machine 
 * has been commanded to exit, then the status will be FALSE, otherwise, 
 * this method will return true.
 *
 * Parameters:
 *   None
 *
 * Returns:
 *   TRUE if the state machine is active
 *   FALSE if the state machine is not active
 */
BOOL IsStateMachineActive(){
	return theIsStateMachineActive;
}

/**
 * change_state
 *
 * Description:
 *   Determines what the new state should be based upon the input parameters.  
 * The current state is exited and the new state is initialized.
 *
 * Parameters:
 *   anEvent The event that is causing the state transition.
 *   aCurrentState The state before the transition.
 *
 * Returns:
 *   The new state.
 */
DWORD change_state(DWORD aCurrentState, DWORD anEvent){
	DWORD new_state;

	new_state = get_new_state(aCurrentState, anEvent);
	if (new_state != aCurrentState){
		exit_state(aCurrentState, anEvent);
		enter_state(new_state, anEvent);
	}
return new_state;
}

/**
 * get_new_state
 *
 * Description:
 *   Determines what the new state should be based upon the input parameters
 *   and registry entries.  
 *
 * Parameters:
 *   anEvent The event that is causing the state transition.
 *   aCurrentState The state before the transition.
 *
 * Returns:
 *   The new state.
 */
static DWORD get_new_state(DWORD aCurrentState, DWORD anEvent){
	DWORD new_state;

	switch (anEvent){
	case INITIALIZATION_COMPLETE:
		new_state = RUNNING;
		break;

	case LOST_COMM:
	case LOW_BATTERY:
	case ON_BATTERY_TIMER_EXPIRED:
		{
			DWORD shutdown_behavior = UPS_SHUTDOWN_SHUTDOWN;
			
			// Check the registry to determine if we shutdown or hibernate
			InitUPSConfigBlock();
			
			if ((GetUPSConfigCriticalPowerAction(&shutdown_behavior) == ERROR_SUCCESS) 
				&& (shutdown_behavior == UPS_SHUTDOWN_HIBERNATE)) {
				// Hibernate was selected as the CriticalPowerAction
				new_state = HIBERNATE;
				
			}
			else {
				// Shutdown was selected as the CriticalPowerAction
				new_state = WAITING_TO_SHUTDOWN;
			}
			
			// Free the UPS registry config block
			FreeUPSConfigBlock();
		}
		break;

	case SHUTDOWN_ACTIONS_COMPLETED:
		new_state = SHUTTING_DOWN;
		break;
	case SHUTDOWN_COMPLETE:
		new_state = STOPPING;
		break;
	case STOPPED:
		new_state = EXIT_NOW;
		break;
	case RETURN_FROM_HIBERNATION:
		new_state = INITIALIZING;
		break;
	case HIBERNATION_ERROR:
		new_state = SHUTTING_DOWN;		
    break;
	default:
		new_state = aCurrentState;
	}

	// If the state machine has been commanded to exit, then return the 
	// stopping state
	if (IsStateMachineActive() == FALSE){
		
		// Ignore this condition if the transition is into the shutting down state
		// Shutdowns in progress cannot be interrupted.
		if (new_state != SHUTTING_DOWN && new_state != EXIT_NOW){
			new_state = STOPPING;
		}
	}
	return new_state; 
}

/**
* enter_state
*
* Description:
*   Initializes the new state.
*
* Parameters:
*   anEvent The event that is causing the transition to a new state.
*   aNewState  The state to enter.
*
* Returns:
*   None
*/
static void enter_state(DWORD aNewState, DWORD anEvent){
	switch (aNewState){
	case INITIALIZING:
		Initializing_Enter(anEvent);
		break;
	case RUNNING:
		Running_Enter(anEvent); 
		break;
	case WAITING_TO_SHUTDOWN:
		WaitingToShutdown_Enter(anEvent);
		break;
	case SHUTTING_DOWN:
		ShuttingDown_Enter(anEvent);
		break;
	case HIBERNATE:
		Hibernate_Enter(anEvent);
		break;
	case STOPPING:
		Stopping_Enter(anEvent);
		break;
	default:
		break;
	}
}

/**
* do_work
*
* Description:
*   Transfers control to a state.
*
* Parameters:
*   aCurrentState The state to perform the work in.
*
* Returns:
*   The event that caused the transition from one of the states
*/
static DWORD do_work(DWORD aCurrentState){
	DWORD event = NO_EVENT;
	switch (aCurrentState){
	case INITIALIZING:
		event = Initializing_DoWork();
		break;
	case RUNNING:
		event = Running_DoWork();  
		break;
	case WAITING_TO_SHUTDOWN:
		event = WaitingToShutdown_DoWork();
		break;
	case SHUTTING_DOWN:
		event = ShuttingDown_DoWork();
		break;
	case HIBERNATE:
		event = Hibernate_DoWork();
		break;
	case STOPPING:
		event = Stopping_DoWork();
		break;
	default:
		break;
	}
	
	return event;
}

/**
* exit_state
*
* Description:
*   Exits the currently executing state.
*
* Parameters:
*   anEvent The event that is causing the transition from the state.
*   anOldState  The current state.
*
* Returns:
*   None
*/
static void exit_state(DWORD anOldState, DWORD anEvent){
	switch (anOldState){
	case INITIALIZING:
		Initializing_Exit(anEvent);
		break;
	case RUNNING:
		Running_Exit(anEvent);  
		break;
	case WAITING_TO_SHUTDOWN:
		WaitingToShutdown_Exit(anEvent);
		break;
	case SHUTTING_DOWN:
		ShuttingDown_Exit(anEvent);
		break;
 case HIBERNATE:
		Hibernate_Exit(anEvent);
		break;
	case STOPPING:
		Stopping_Exit(anEvent);
		break;
	default:
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\upsmsg.h ===
/* Copyright 1999 American Power Conversion, All Rights Reserved
 * 
 * Description:
 *   The file defines the message id's used to send notifications.
 *   These values correspond to the values contained in the netmsg.dll.
 *
 *
 * Revision History:
 *   sberard  31Mar1999  initial revision.
 *
 */ 

#ifndef _UPSMSG_H
#define _UPSMSG_H


#ifdef __cplusplus
extern "C" {
#endif

// These are defined in alertmsg.h
#define ALERT_PowerOut					        3020
#define ALERT_PowerBack					        3021
#define ALERT_PowerShutdown				      3022
#define ALERT_CmdFileConfig				      3023


// These are defined in apperr2.h
#define APE2_UPS_POWER_OUT				      5150
#define APE2_UPS_POWER_BACK				      5151
#define APE2_UPS_POWER_SHUTDOWN			    5152  
#define APE2_UPS_POWER_SHUTDOWN_FINAL   5153


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\upsreg.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSREG.H
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
********************************************************************************/

// This file contains declarations that support accessing
// registry data passed between the UPS service and the
// UPS UI.


#ifndef _UPSREG_H_
#define _UPSREG_H_

#ifdef __cplusplus
extern "C" {
#endif

LONG getStringValue(struct _reg_entry *aRegEntry, LPTSTR aBuffer); 
LONG getDwordValue(struct _reg_entry *aRegEntry, LPDWORD aValue); 

/* 
 * Public Config function declarations
 */
LONG GetUPSConfigVendor( LPTSTR aBuffer);
LONG GetUPSConfigModel( LPTSTR aBuffer);
LONG GetUPSConfigPort( LPTSTR aBuffer);
LONG GetUPSConfigOptions( LPDWORD aValue);
LONG GetUPSConfigShutdownWait( LPDWORD aValue);			
LONG GetUPSConfigFirstMessageDelay( LPDWORD aValue);			
LONG GetUPSConfigMessageInterval( LPDWORD aValue);	
LONG GetUPSConfigServiceDLL( LPTSTR aBuffer);
LONG GetUPSConfigNotifyEnable( LPDWORD aValue);
LONG GetUPSConfigShutdownOnBatteryEnable( LPDWORD aValue);
LONG GetUPSConfigShutdownOnBatteryWait( LPDWORD aValue);
LONG GetUPSConfigRunTaskEnable( LPDWORD aValue);
LONG GetUPSConfigTaskName( LPTSTR aBuffer);
LONG GetUPSConfigTurnOffEnable( LPDWORD aValue);
LONG GetUPSConfigAPCLinkURL( LPTSTR aBuffer);
LONG GetUPSConfigUpgrade( LPDWORD aValue);
LONG GetUPSConfigCustomOptions( LPDWORD aValue);
LONG GetUPSConfigCriticalPowerAction( LPDWORD aValue);
LONG GetUPSConfigTurnOffWait( LPDWORD aValue);
LONG GetUPSConfigImagePath( LPTSTR aBuffer);
LONG GetUPSConfigObjectName( LPTSTR aBuffer);
LONG GetUPSConfigShowUPSTab( LPDWORD aValue);
LONG GetUPSConfigErrorControl( LPDWORD aValue);
LONG GetUPSConfigStart( LPDWORD aValue);
LONG GetUPSConfigType( LPDWORD aValue);

LONG SetUPSConfigVendor( LPCTSTR aBuffer);
LONG SetUPSConfigModel( LPCTSTR aBuffer);
LONG SetUPSConfigPort( LPCTSTR aBuffer);
LONG SetUPSConfigOptions( DWORD aValue);
LONG SetUPSConfigShutdownWait( DWORD aValue);			
LONG SetUPSConfigFirstMessageDelay( DWORD aValue);			
LONG SetUPSConfigMessageInterval( DWORD aValue);		
LONG SetUPSConfigServiceDLL( LPCTSTR aBuffer);
LONG SetUPSConfigNotifyEnable( DWORD aValue);
LONG SetUPSConfigShutdownOnBatteryEnable( DWORD aValue); 
LONG SetUPSConfigShutdownOnBatteryWait( DWORD aValue);
LONG SetUPSConfigRunTaskEnable( DWORD aValue);
LONG SetUPSConfigTaskName( LPCTSTR aBuffer);
LONG SetUPSConfigTurnOffEnable( DWORD aValue);
LONG SetUPSConfigAPCLinkURL( LPCTSTR aBuffer);
LONG SetUPSConfigUpgrade( DWORD aValue);
LONG SetUPSConfigCustomOptions( DWORD aValue);
LONG SetUPSConfigCriticalPowerAction( DWORD aValue);
LONG SetUPSConfigTurnOffWait( DWORD aValue);
LONG SetUPSConfigImagePath( LPCTSTR aBuffer);
LONG SetUPSConfigObjectName( LPCTSTR aBuffer);
LONG SetUPSConfigShowUPSTab( DWORD aValue);
LONG SetUPSConfigErrorControl( DWORD aValue);
LONG SetUPSConfigStart( DWORD aValue);
LONG SetUPSConfigType( DWORD aValue);

/*
 * Public Status function declarations
 */
LONG GetUPSStatusSerialNum( LPTSTR aBuffer);
LONG GetUPSStatusFirmRev( LPTSTR aBuffer);
LONG GetUPSStatusUtilityStatus( LPDWORD aValue);
LONG GetUPSStatusRuntime( LPDWORD aValue);
LONG GetUPSStatusBatteryStatus( LPDWORD aValue);
LONG GetUPSStatusCommStatus( LPDWORD aValue);
LONG GetUPSStatusBatteryCapacity( LPDWORD aValue);

LONG SetUPSStatusSerialNum( LPCTSTR aBuffer);
LONG SetUPSStatusFirmRev( LPCTSTR aBuffer);
LONG SetUPSStatusUtilityStatus( DWORD aValue);
LONG SetUPSStatusRuntime( DWORD aValue);
LONG SetUPSStatusBatteryStatus( DWORD aValue);
LONG SetUPSStatusCommStatus( DWORD aValue);
LONG SetUPSStatusBatteryCapacity( DWORD aValue);

/*
 * Public Reg Entry function declarations
 */
void InitUPSConfigBlock();
void InitUPSStatusBlock();
void RestoreUPSConfigBlock();
void RestoreUPSStatusBlock();
void SaveUPSConfigBlock(BOOL forceAll);
void SaveUPSStatusBlock(BOOL forceAll);
void FreeUPSConfigBlock();
void FreeUPSStatusBlock();

/*
 * Reg entry path string declarations
 */
#define UPS_DEFAULT_ROOT _T("SYSTEM\\CurrentControlSet\\Services\\UPS")
#define UPS_STATUS_ROOT  _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\Status")
#define UPS_CONFIG_ROOT  _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")
#define UPS_SERVICE_ROOT _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders")
#define UPS_PORT_ROOT    _T("HARDWARE\\DEVICEMAP\\SERIALCOMM")

#define UPS_UTILITYPOWER_UNKNOWN 0
#define UPS_UTILITYPOWER_ON      1
#define UPS_UTILITYPOWER_OFF     2

#define UPS_BATTERYSTATUS_UNKNOWN 0
#define UPS_BATTERYSTATUS_GOOD    1
#define UPS_BATTERYSTATUS_REPLACE 2

#define UPS_COMMSTATUS_UNKNOWN 0
#define UPS_COMMSTATUS_OK      1
#define UPS_COMMSTATUS_LOST    2

// Defines the values for the 'Options' bitmask registry key
#define UPS_INSTALLED               0x00000001
#define UPS_POWERFAILSIGNAL         0x00000002
#define UPS_LOWBATTERYSIGNAL        0x00000004
#define UPS_SHUTOFFSIGNAL           0x00000008
#define UPS_POSSIGONPOWERFAIL       0x00000010
#define UPS_POSSIGONLOWBATTERY      0x00000020
#define UPS_POSSIGSHUTOFF           0x00000040
#define UPS_RUNCMDFILE              0x00000080

#define UPS_DEFAULT_SIGMASK			0x0000007f
#define DEFAULT_CONFIG_IMAGEPATH    TEXT("%SystemRoot%\\System32\\ups.exe")

// Min / Max / Default values for  FirstMessageDelay (seconds)
#define WAITSECONDSFIRSTVAL				0
#define WAITSECONDSLASTVAL				120
#define WAITSECONDSDEFAULT				5

// Min / Max / Default values for  MessageInterval (seconds)
#define REPEATSECONDSFIRSTVAL			5
#define REPEATSECONDSLASTVAL			300
#define REPEATSECONDSDEFAULT			120

// Min / Max / Default values for  ShutdownOnBatteryWait (minutes)
#define SHUTDOWNTIMERMINUTESFIRSTVAL	2
#define SHUTDOWNTIMERMINUTESLASTVAL		720
#define SHUTDOWNTIMERMINUTESDEFAULT     2

// Shutdown behavior values
#define UPS_SHUTDOWN_SHUTDOWN   0
#define UPS_SHUTDOWN_HIBERNATE  1

/** ServiceProvider structure.  The structure defines the entries in the
*  ServiceProviders registry key.
*/
typedef struct {
LPTSTR  theVendorKey;		  // Vendor registry subkey
LPTSTR  theModelName;     // UPS model name
LPTSTR  theValue;         // UPS value data
} ServiceProviderStructure;


/**
* InitializeRegistry
*
* Description:
*   This function initiates the registry for the UPS service and the 
*   configuration application.  When called, this function examines 
*   the registry to determine if it needs to be initalized.  If the key
*   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\UPS\Config\ServiceProviderDLL
*   is present, the registry is assumed to be initialized and no initialization
*   is done.  If the key is not present the following Keys are updated:
*        Status
*        Config
*        ServiceProviders
*
*   The values for the ServiceProviders key is supplied in the regdefs.h
*   header file.
*
* Parameters:
*   none
*
* Returns:
*   TRUE if able to open registry keys with write access.
*/
BOOL InitializeRegistry();


///////////////
// upsdefines.h
#ifndef _ASSERT
#define _ASSERT(x) 
#endif

#define DIMENSION_OF(array) (sizeof(array)/sizeof(array[0]))

//This value is used in most of the text buffers in various places throughout
//the application.
#define MAX_MESSAGE_LENGTH      1024

//The following three strings are the registry value names where all
//the UPS data is stored. These values are used in the RegField array
//in datacces.c
#define UPS_KEY_NAME    TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS")
#define STATUS_KEY_NAME TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Status")
#define CONFIG_KEY_NAME TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")

//The following values are used in the DialogAssociations arrays in updatdlg.c
//and upsinfo.c
#define RESOURCE_FIXED     0
#define RESOURCE_INCREMENT 1
#define REG_ANY_DWORD_TYPE (REG_DWORD | REG_DWORD_BIG_ENDIAN | REG_DWORD_LITTLE_ENDIAN)

//This is a helper macro to help form a DialogAssociations array members.
#define MAKE_ARRAY(stub, insertID, indexID, stringType, indexMax, regAccessType, shallowAccessPtr, regEntryPtr)\
  { eREG_##stub, IDC_##stub##_LHS, IDC_##stub, insertID, indexID, stringType, indexMax, regAccessType, shallowAccessPtr, regEntryPtr }

//The following are all the registry values supported by the application.
//The amount and values to these enums correspond to the size of the array
//g_upsRegFields
typedef enum _tUPSDataItemID { eREG_VENDOR_NAME = 0,
                               eREG_MODEL_TYPE,
                               eREG_SERIAL_NUMBER,
                               eREG_FIRMWARE_REVISION,
                               eREG_POWER_SOURCE,
                               eREG_RUNTIME_REMAINING,
							   eREG_BATTERY_CAPACITY,
                               eREG_BATTERY_STATUS,
                               eREG_UPS_OPTIONS,
                               eREG_SERVICE_PROVIDER_DLL,
                               eREG_SHUTDOWN_ON_BATTERY_ENABLE,
                               eREG_SHUTDOWN_ON_BATTERY_WAIT,
                               eREG_TURN_UPS_OFF_ENABLE,
                               eREG_APC_LINKURL,
                               eREG_UPGRADE_ENABLE,
                               eREG_COMM_STATUS,
                               eREG_PORT } tUPSDataItemID;

//This enum is used in DialogAssociations below. This defines the
//type of registry query to perform when reading registry values.
//There are only two options, to perform a deep get, that is, go
//right to the registry every time, re-reading it from the registry, or to
//use the regfunc buffer value (shallow get).
typedef enum _tRegAccessType { eDeepGet = 0,
                               eShallowGet } tRegAccessType;

//This struct links the registry field and the dialog controls.
typedef struct _DialogAssociations {
  const tUPSDataItemID theFieldTypeID;              //the eREG_... id. This is used to read the
                                                    //registry data.
  DWORD                theStaticFieldID;            //A control id (usually for a static control). This
                                                    //is the left-hand side control. For example, in the
                                                    //on-screen text "Model Type: Back-UPS Pro" there are
                                                    //actually two controls the left-hand side (LHS) is
                                                    //"Model Type:" and the right-hand side is "Back-UPS Pro".
                                                    //These controls are separated as the LHS's behavior is
                                                    //different to the RHS when no data is present.
  DWORD                theDisplayControlID;         //A control id (usually an edit field or a static)
  DWORD                theResourceInsertID;         //The id of the string resource to insert the value into
                                                    //If the registry value is a DWORD then
                                                    //the insertion point should be %n!lu!, if
                                                    //it's a string then the insertion point can be just %n
  DWORD                theResourceIndexID;          //This is only relevant if theResourceStringType is
                                                    //of type RESOURCE_INCREMENT. This identifies the id
                                                    //of the string when the value read for this item is 0,
                                                    //it is assumed that the other string values are stored
                                                    //consequtively in the string table following this value.
                                                    //For an example see below.
  DWORD                theResourceStringType;       //This can be RESOURCE_FIXED or RESOURCE_INCREMENT.
                                                    //RESOURCE_FIXED means that the value needs no special
                                                    //handling. Simple insert the value into the string
                                                    //identified by theResourceInsertID. If it's equal to
                                                    //RESOURCE_INCREMENT then the string inserted is determined
                                                    //by reading the value from the registry (say it's equal
                                                    //to 1). The theResourceIndexID indentifies the id of the
                                                    //string resource corresponding to a value. A value of 1
                                                    //gives up the string with id theResourceIndexID + 1. This
                                                    //string is loaded and inserted into the string identified
                                                    //by theResourceInsertID.
  DWORD                theResourceIndexMax;         //This is only relevant if theResourceStringType is
                                                    //of type RESOURCE_INCREMENT. This identifies the maximum
                                                    //index value that is support for this increment type. This
                                                    //is to protect from unsupported registry value causing the
                                                    //"theResourceIndexID + value" addition going beyond the
                                                    //range of supported string resource values.
  tRegAccessType       theRegAccessType;            //This define whether the access to the registry value
                                                    //should use a "shallow" or "deep" get. See help on
                                                    //tUPSDataItemID above.
  void *               theShallowAccessFunctionPtr; //This point to the regfuncs function to use when performing
                                                    //a shallow get. This parameter is only required if
                                                    //theRegAccessType is set to eShallowGet, otherwise it can
                                                    //be 0.
  struct _reg_entry *  theRegEntryPtr;              //This is the _reg_entry * parameter passed to the regfuncs
                                                    //function (theShallowAccessFunctionPtr member) when
                                                    //performing a shallow get. This parameter is only required if
                                                    //theRegAccessType is set to eShallowGet, otherwise it can
                                                    //be 0.
  } DialogAssociations;

/*

  The following example helps to explain more the members of the DialogAssociations struct.

  Say we have an instance of this struct as follows:

  DialogAssociations da = { eREG_POWER_SOURCE,
                            IDC_POWER_SOURCE_LHS,
                            IDC_POWER_SOURCE,
                            IDS_STRING,
                            IDS_UTILITYPOWER_UNKNOWN,
                            RESOURCE_INCREMENT,
                            2,
                            eDeepGet,
                            0,
                            0 };

  This describes a registry field called eREG_POWER_SOURCE. If we look at
  tUPSDataItemID above we see that eREG_POWER_SOURCE has a value of 4. If
  we then look at g_upsRegFields in datacces.c we that the RegField at index
  4 has the following data:

  { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("UtilityPowerStatus"), REG_DWORD },

  The DoUpdateInfo function, for example, takes this information when updating
  the onscreen data in the main UPS page. The function gets the RegField
  information, as above. It then looks to see if it needs to do a deep get (read
  directly from the registry), or a shallow get (take data from the current
  values stored in the regfuncs buffers. If the registry item theValueType is
  one of the string type then the string value is copied into the resource
  string identified by theResourceInsertID. In this case theValueType is
  REG_DWORD. In this case the DWORD is read from the registry directly. Its
  value (say it had a value of 1) is then added to IDS_UTILITYPOWER_UNKNOWN
  giving a value which corresponds to IDS_UTILITYPOWER_ON. The string
  IDS_UTILITYPOWER_ON is then loaded and used as a parameter value when
  loaded the parameterized string resource identified by the
  theResourceInsertID string id. This string (which should include the inserted
  text) is then displayed in the control identified by theDisplayControlID.
*/


//this struct describes a registy field item 
typedef struct _RegField {
  HKEY    theRootKey;   //Handle to an existing registry key.
  LPCTSTR theKeyName;   //The name of the subkey relative to the above handle.
  LPCTSTR theValueName; //The name of the registry value.
  DWORD   theValueType; //The type of the value.
  } RegField;

///////////////////////////////////////////////////////////////////////////////

RegField * GetRegField      (DWORD index);

// upsdata.h
//Note that the order and numbering of the enums in tUPSDataItemID is linked to
//the contents of the array of RegFields defined in datacces.h. 
//Do not change these value without due care and attention. It's OK to change
//it as long as the array of RegFields is updated to match.

DWORD ReadRegistryValueData (HKEY aRootKey,
                             LPCTSTR aKeyName,
                             LPCTSTR aValueName,
                             DWORD aAllowedTypes,
                             DWORD * aTypePtr,
                             LPTSTR aReturnBuffer,
                             DWORD * aBufferSizePtr);

BOOL GetUPSDataItemDWORD  (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr);
BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID, LPTSTR aBufferPtr, DWORD * pSizeOfBufferPtr);



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\wksbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wksbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the Workstaion
    service.

Author:

    Rita Wong (ritaw)  14-May-1991

Environment:

    User Mode -Win32

Revision History:

--*/

#include "wsclient.h"


handle_t
WKSSVC_IMPERSONATE_HANDLE_bind(
    WKSSVC_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the Workstation service client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = NetpBindRpc (
                    ServerName,
                    WORKSTATION_INTERFACE_NAME,
                    TEXT("Security=Impersonation Dynamic False"),
                    &BindHandle
                    );

    if (RpcStatus != RPC_S_OK) {
        NetpKdPrint((
            "WKSSVC_IMPERSONATE_HANDLE_bind failed: " FORMAT_NTSTATUS "\n",
            RpcStatus
            ));
    }

    return BindHandle;
}



handle_t
WKSSVC_IDENTIFY_HANDLE_bind(
    WKSSVC_IDENTIFY_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the Workstation service client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = NetpBindRpc (
                    ServerName,
                    WORKSTATION_INTERFACE_NAME,
                    TEXT("Security=Identification Dynamic False"),
                    &BindHandle
                    );

    if (RpcStatus != RPC_S_OK) {
        NetpKdPrint((
            "WKSSVC_IDENTIFY_HANDLE_bind failed: " FORMAT_NTSTATUS "\n",
            RpcStatus
            ));
    }

    return BindHandle;
}



void
WKSSVC_IMPERSONATE_HANDLE_unbind(
    WKSSVC_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the Workstation service client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    IF_DEBUG(RPCBIND) {
        NetpKdPrint(("WKSSVC_IMPERSONATE_HANDLE_unbind: handle="
                     FORMAT_HEX_DWORD "\n", BindHandle));
    }

    NetpUnbindRpc(BindHandle);
}



void
WKSSVC_IDENTIFY_HANDLE_unbind(
    WKSSVC_IDENTIFY_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the server service client stubs when it is
    necessary to unbind from a server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    IF_DEBUG(RPCBIND) {
        NetpKdPrint(("WKSSVC_IDENTIFY_HANDLE_unbind: handle="
                     FORMAT_HEX_DWORD "\n", BindHandle));
    }

    NetpUnbindRpc(BindHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\upssvc\upsexe\upsreg.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSREG.C
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*	 Revision History:
*   v-stebe  23May2000  added check for NULL in ReadRegistryValue() (bug 112595)
*   v-stebe  23May2000  added code to avoid rewriting the registry value if the
*                       value is unchanged in setDwordValue() (bug #92799)
*   v-stebe  11Sep2000  Fixed PREfix error (bug #170456)
*******************************************************************************/

/*
 * system includes
 */
#include <windows.h>
#include <tchar.h>

/*
 * local includes
 */
//#include "upsdefines.h"
#include "upsreg.h"
#include "regdefs.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Reg entry info structure declaration
 */
struct _reg_entry
{
  HKEY    hKey;			/* the key */
  LPTSTR  lpSubKey;		/* address of SubKey name */
  LPTSTR  lpValueName;  /* address of name of value to query */
  DWORD   ulType;       /* buffer for value type */
  LPBYTE  lpData;       /* address of data buffer */
  DWORD   cbData;       /* data buffer size */
  BOOL    changed;		/* ID of dialog that changed this entry */
};

/*
 * local function pre-declarations
 */
void freeBlock(struct _reg_entry *aBlock[]);
void readBlock(struct _reg_entry *aBlock[], BOOL changed); 
void writeBlock(struct _reg_entry *aBlock[], BOOL forceAll);
LONG setDwordValue(struct _reg_entry *aRegEntry, DWORD aValue);
LONG setStringValue(struct _reg_entry *aRegEntry, LPCTSTR aBuffer);

static BOOL isRegistryInitialized();
static void CheckForUpgrade();
static void InitializeServiceKeys();
static void InitializeServiceProviders();
static void InitializeConfigValues();
static void InitializeStatusValues();


/* 
 * Reg entry value name declarations
 */
#define UPS_VENDOR				_T("Vendor")
#define UPS_MODEL				_T("Model")
#define UPS_SERIALNUMBER		_T("SerialNumber")
#define UPS_FIRMWAREREV			_T("FirmwareRev")
#define UPS_UTILITYSTATUS		_T("UtilityPowerStatus")
#define UPS_RUNTIME				_T("TotalUPSRuntime")
#define UPS_BATTERYSTATUS		_T("BatteryStatus")
#define UPS_PORT				_T("Port")
#define UPS_OPTIONS				_T("Options")
#define UPS_SHUTDOWNWAIT		_T("ShutdownWait")
#define UPS_FIRSTMESSAGEDELAY	_T("FirstMessageDelay")
#define UPS_MESSAGEINTERVAL		_T("MessageInterval")
#define UPS_SERVICEDLL			_T("ServiceProviderDLL")
#define UPS_NOTIFYENABLE		_T("NotifyEnable")
#define UPS_SHUTBATTENABLE		_T("ShutdownOnBatteryEnable")
#define UPS_SHUTBATTWAIT		_T("ShutdownOnBatteryWait")
#define UPS_RUNTASKENABLE		_T("RunTaskEnable")
#define UPS_TASKNAME			_T("TaskName")
#define UPS_TURNUPSOFFENABLE	_T("TurnUPSOffEnable")
#define UPS_APCLINKURL			_T("APCLinkURL")
#define UPS_CUSTOMOPTIONS       _T("CustomOptions")
#define UPS_UPGRADE				_T("Upgrade")
#define UPS_COMMSTATUS			_T("CommStatus")
#define UPS_CRITICALPOWERACTION  _T("CriticalPowerAction")
#define UPS_TURNUPSOFFWAIT           _T("TurnUPSOffWait")
#define UPS_SHOWTAB              _T("ShowUPSTab")
#define UPS_BATTERYCAPACITY       _T("BatteryCapacity")
#define UPS_IMAGEPATH			    _T("ImagePath")
#define UPS_ERRORCONTROL      _T("ErrorControl")
#define UPS_OBJECTNAME        _T("ObjectName")
#define UPS_START             _T("Start")
#define UPS_TYPE              _T("Type")

// This specifies the key to examine to determine if the registry
// has been updated for the UPS Service.
#define UPS_SERVICE_INITIALIZED_KEY   TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")

// Specifies the name of the BatteryLife key used in the NT 4.0 UPS Service
#define UPS_BATTLIFE_KEY              TEXT("BatteryLife")

// This specifies the default name for the shutdown Task
#define DEFAULT_SHUTDOWN_TASK_NAME    TEXT("") 

// Default values for the Config settings
#define DEFAULT_CONFIG_VENDOR_OLD               TEXT("\\(NONE)")
#define DEFAULT_CONFIG_VENDOR                   TEXT("")
#define DEFAULT_CONFIG_MODEL                    TEXT("")
#define DEFAULT_CONFIG_PORT                     TEXT("COM1")
#define DEFAULT_CONFIG_OPTIONS                  0x7e
#define DEFAULT_CONFIG_FIRSTMSG_DELAY           5  
#define DEFAULT_CONFIG_MESSAGE_INTERVAL         120
#define DEFAULT_CONFIG_PROVIDER_DLL             TEXT("")
#define DEFAULT_CONFIG_NOTIFY_ENABLE            1
#define DEFAULT_CONFIG_SHUTDOWN_ONBATT_ENABLE   FALSE
#define DEFAULT_CONFIG_SHUTDOWN_ONBATT_WAIT     2
#define DEFAULT_CONFIG_RUNTASK_ENABLE           FALSE
#define DEFAULT_CONFIG_TASK_NAME                DEFAULT_SHUTDOWN_TASK_NAME
#define DEFAULT_CONFIG_TURNOFF_UPS_ENABLE       TRUE
#define DEFAULT_CONFIG_CUSTOM_OPTIONS           UPS_DEFAULT_SIGMASK
#define DEFAULT_CONFIG_CRITICALPOWERACTION      UPS_SHUTDOWN_SHUTDOWN
#define DEFAULT_CONFIG_TURNOFF_UPS_WAIT         180
#define DEFAULT_CONFIG_ERRORCONTROL             1
#define DEFAULT_CONFIG_OBJECTNAME               TEXT("LocalSystem")
#define DEFAULT_CONFIG_START                    SERVICE_DEMAND_START
#define DEFAULT_CONFIG_TYPE                     16
#define DEFAULT_CONFIG_SHOWUPSTAB               FALSE

// Default values for the Status settings
#define DEFAULT_STATUS_SERIALNO                 TEXT("")
#define DEFAULT_STATUS_FIRMWARE_REV             TEXT("")
#define DEFAULT_STATUS_UTILITY_STAT             0
#define DEFAULT_STATUS_TOTAL_RUNTIME            0
#define DEFAULT_STATUS_BATTERY_STAT             0
#define DEFAULT_STATUS_BATTERY_CAPACITY         0

// Default values for upgraded services
#define UPGRADE_CONFIG_VENDOR_OLD               TEXT("\\Generic")
#define UPGRADE_CONFIG_VENDOR                   TEXT("")
#define UPGRADE_CONFIG_MODEL                    TEXT("")

/* 
 * Allocate the individual Configuration Reg entry records 
 */
struct _reg_entry UPSConfigVendor			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_VENDOR,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigModel			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_MODEL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigPort				= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_PORT,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigOptions			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_OPTIONS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigServiceDLL		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SERVICEDLL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigNotifyEnable		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_NOTIFYENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigFirstMessageDelay= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_FIRSTMESSAGEDELAY,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigMessageInterval	= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_MESSAGEINTERVAL,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShutBattEnable   = {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SHUTBATTENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShutBattWait     = {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SHUTBATTWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigRunTaskEnable	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_RUNTASKENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigTaskName			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TASKNAME,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigTurnOffEnable	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TURNUPSOFFENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigCustomOptions	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_CUSTOMOPTIONS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigAPCLinkURL		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_APCLINKURL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigShutdownWait		= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_SHUTDOWNWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigUpgrade			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_UPGRADE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigCriticalPowerAction	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_CRITICALPOWERACTION,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigTurnOffWait	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TURNUPSOFFWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigImagePath			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_IMAGEPATH,REG_EXPAND_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigObjectName			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_OBJECTNAME,REG_EXPAND_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigErrorControl			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_ERRORCONTROL,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigStart			    = {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_START,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigType     			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_TYPE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShowUPSTab			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_SHOWTAB,REG_DWORD,NULL,0,FALSE};

/* 
 * Allocate the individual Status Reg entry records 
 */
struct _reg_entry UPSStatusSerialNum	= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_SERIALNUMBER,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSStatusFirmRev		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_FIRMWAREREV,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSStatusUtilityStatus= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_UTILITYSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusRuntime		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_RUNTIME,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusBatteryStatus= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_BATTERYSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusCommStatus	= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_COMMSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusBatteryCapacity		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_BATTERYCAPACITY,REG_DWORD,NULL,0,FALSE};

/* 
 * Allocate an array of pointers to the Configuration Reg entry records
 */
struct _reg_entry *ConfigBlock[] =  {&UPSConfigVendor,
									&UPSConfigModel,
									&UPSConfigPort,
									&UPSConfigOptions,
									&UPSConfigServiceDLL,
									&UPSConfigNotifyEnable,
									&UPSConfigFirstMessageDelay,
									&UPSConfigMessageInterval,
									&UPSConfigShutBattEnable,
									&UPSConfigShutBattWait,
									&UPSConfigRunTaskEnable,
									&UPSConfigTaskName,
									&UPSConfigTurnOffEnable,
									&UPSConfigCustomOptions,
									&UPSConfigAPCLinkURL,
									&UPSConfigShutdownWait,
									&UPSConfigUpgrade,
									&UPSConfigCriticalPowerAction,
									&UPSConfigTurnOffWait,
                  &UPSConfigImagePath,
                  &UPSConfigObjectName,
                  &UPSConfigErrorControl,
                  &UPSConfigStart,
                  &UPSConfigType,   		
									&UPSConfigShowUPSTab,
									NULL};

/* 
 * Allocate an array of pointers to the Status Reg entry records
 */
struct _reg_entry *StatusBlock[] = {&UPSStatusSerialNum,
									&UPSStatusFirmRev,
									&UPSStatusUtilityStatus,
									&UPSStatusRuntime,
									&UPSStatusBatteryStatus,
									&UPSStatusCommStatus,
									&UPSStatusBatteryCapacity,
									NULL};


/******************************************************************
 * Public functions
 */

LONG GetUPSConfigVendor( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigVendor, aBuffer);
}

LONG GetUPSConfigModel( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigModel, aBuffer);
}

LONG GetUPSConfigPort( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigPort, aBuffer);
}

LONG GetUPSConfigOptions( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigOptions, aValue);
}

LONG GetUPSConfigServiceDLL( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigServiceDLL, aBuffer);
}

LONG GetUPSConfigNotifyEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigNotifyEnable, aValue);
}

LONG GetUPSConfigFirstMessageDelay( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigFirstMessageDelay, aValue);
}

LONG GetUPSConfigMessageInterval( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigMessageInterval, aValue);
}

LONG GetUPSConfigShutdownOnBatteryEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutBattEnable, aValue);
}

LONG GetUPSConfigShutdownOnBatteryWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutBattWait, aValue);
}

LONG GetUPSConfigRunTaskEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigRunTaskEnable, aValue);
}

LONG GetUPSConfigTaskName( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigTaskName, aBuffer);
}

LONG GetUPSConfigTurnOffEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigTurnOffEnable, aValue);
}

LONG GetUPSConfigCustomOptions( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigCustomOptions, aValue);
}

LONG GetUPSConfigAPCLinkURL( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigAPCLinkURL, aBuffer);
}

LONG GetUPSConfigShutdownWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutdownWait, aValue);
}

LONG GetUPSConfigUpgrade( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigUpgrade, aValue);
}

LONG GetUPSConfigCriticalPowerAction( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigCriticalPowerAction, aValue);
}

LONG GetUPSConfigTurnOffWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigTurnOffWait, aValue);
}

LONG GetUPSConfigShowUPSTab( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShowUPSTab, aValue);
}

LONG GetUPSConfigImagePath( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigImagePath, aBuffer);
}

LONG GetUPSConfigObjectName( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigObjectName, aBuffer);
}

LONG GetUPSConfigErrorControl( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigErrorControl, aValue);
}

LONG GetUPSConfigStart( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigStart, aValue);
}

LONG GetUPSConfigType( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigType, aValue);
}

///////////////////////////////////////////

LONG SetUPSConfigVendor( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigVendor, aBuffer);
}

LONG SetUPSConfigModel( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigModel, aBuffer);
}

LONG SetUPSConfigPort( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigPort, aBuffer);
}

LONG SetUPSConfigOptions( DWORD aValue)
{
	return setDwordValue( &UPSConfigOptions, aValue);
}

LONG SetUPSConfigServiceDLL( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigServiceDLL, aBuffer);
}

LONG SetUPSConfigNotifyEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigNotifyEnable, aValue);
}

LONG SetUPSConfigFirstMessageDelay( DWORD aValue)
{
	return setDwordValue( &UPSConfigFirstMessageDelay, aValue);
}

LONG SetUPSConfigMessageInterval( DWORD aValue)
{
	return setDwordValue( &UPSConfigMessageInterval, aValue);
}

LONG SetUPSConfigShutdownOnBatteryEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigShutBattEnable, aValue);
}

LONG SetUPSConfigShutdownOnBatteryWait( DWORD aValue) 
{
	return setDwordValue( &UPSConfigShutBattWait, aValue); 
}

LONG SetUPSConfigRunTaskEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigRunTaskEnable, aValue);
}

LONG SetUPSConfigTaskName( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigTaskName, aBuffer);
}

LONG SetUPSConfigTurnOffEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigTurnOffEnable, aValue);
}

LONG SetUPSConfigCustomOptions( DWORD aValue)
{
	return setDwordValue( &UPSConfigCustomOptions, aValue);
}

LONG SetUPSConfigAPCLinkURL( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigAPCLinkURL, aBuffer);
}

LONG SetUPSConfigShutdownWait( DWORD aValue)
{
	return setDwordValue( &UPSConfigShutdownWait, aValue);
}

LONG SetUPSConfigUpgrade( DWORD aValue)
{
	return setDwordValue( &UPSConfigUpgrade, aValue);
}

LONG SetUPSConfigCriticalPowerAction( DWORD aValue)
{
	return setDwordValue( &UPSConfigCriticalPowerAction, aValue);
}

LONG SetUPSConfigTurnOffWait( DWORD aValue)
{
	return setDwordValue( &UPSConfigTurnOffWait, aValue);
}

LONG SetUPSConfigShowUPSTab( DWORD aValue)
{
	return setDwordValue( &UPSConfigShowUPSTab, aValue);
}

LONG SetUPSConfigImagePath( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigImagePath, aBuffer);
}

LONG SetUPSConfigObjectName( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigObjectName, aBuffer);
}

LONG SetUPSConfigErrorControl( DWORD aValue)
{
	return setDwordValue( &UPSConfigErrorControl, aValue);
}

LONG SetUPSConfigStart( DWORD aValue)
{
	return setDwordValue( &UPSConfigStart, aValue);
}

LONG SetUPSConfigType( DWORD aValue)
{
	return setDwordValue( &UPSConfigType, aValue);
}


////////////////////////////////////////////////

LONG GetUPSStatusSerialNum( LPTSTR aBuffer)
{
	return getStringValue( &UPSStatusSerialNum, aBuffer);
}

LONG GetUPSStatusFirmRev( LPTSTR aBuffer)
{
	return getStringValue( &UPSStatusFirmRev, aBuffer);
}

LONG GetUPSStatusUtilityStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusUtilityStatus, aValue);
}

LONG GetUPSStatusRuntime( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusRuntime, aValue);
}

LONG GetUPSStatusBatteryStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusBatteryStatus, aValue);
}

LONG GetUPSStatusCommStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusCommStatus, aValue);
}

LONG GetUPSBatteryCapacity( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusBatteryCapacity, aValue);
}

/////////////////////////////////////////

LONG SetUPSStatusSerialNum( LPCTSTR aBuffer)
{
	return setStringValue( &UPSStatusSerialNum, aBuffer);
}

LONG SetUPSStatusFirmRev( LPCTSTR aBuffer)
{
	return setStringValue( &UPSStatusFirmRev, aBuffer);
}

LONG SetUPSStatusUtilityStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusUtilityStatus,aValue);
}

LONG SetUPSStatusRuntime( DWORD aValue)
{
	return setDwordValue( &UPSStatusRuntime,aValue);
}

LONG SetUPSStatusBatteryStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusBatteryStatus,aValue);
}

LONG SetUPSStatusCommStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusCommStatus,aValue);
}

LONG SetUPSStatusBatteryCapacity( DWORD aValue)
{
	return setDwordValue( &UPSStatusBatteryCapacity,aValue);
}

//////////////////////////////////////////////////////////////

void FreeUPSConfigBlock()
{
	freeBlock(ConfigBlock);
}

void FreeUPSStatusBlock()
{
	freeBlock(StatusBlock);
}

void InitUPSConfigBlock()
{
	readBlock(ConfigBlock,FALSE);
}

void InitUPSStatusBlock()
{
	readBlock(StatusBlock,FALSE);
}

void RestoreUPSConfigBlock()
{
	readBlock(ConfigBlock, TRUE);
}

void RestoreUPSStatusBlock()
{
	readBlock(StatusBlock, TRUE);
}

void SaveUPSConfigBlock(BOOL forceAll)
{
	writeBlock(ConfigBlock, forceAll);
}

void SaveUPSStatusBlock(BOOL forceAll)
{
	writeBlock(StatusBlock, forceAll);
}

/******************************************************************
 * Local functions
 */

/*
 * freeBlock()
 *
 * Description: Frees storage allocated when a block of registry 
 *				entries is read
 *
 * Parameters: aBlock - pointer to an array of _reg_entry structures
 *
 * Returns:
 */
void freeBlock(struct _reg_entry *aBlock[]) 
{
	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		if (NULL != anEntry->lpData)
		{
			LocalFree(anEntry->lpData);
		}
		anEntry->lpData = NULL;
		anEntry->cbData = 0;
		anEntry->changed = FALSE; 

		aBlock++;
	}
}

/*
 * readBlock()
 *
 * Description: Loads all of the items in a array of registry entries
 *
 * Parameters:  aBlock - pointer to an array of _reg_entry structures
 *				changed - boolean which, when true, causes only the
 *				structures that are marked as changed to be loaded.
 *
 * Returns:
 */
void readBlock(struct _reg_entry *aBlock[], BOOL changed) 
{
	LONG res;
	HKEY hkResult;

	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		/* 
		 * if changed is FALSE, we read all entries
		 * otherwise, only re-read the changed entries
		 */
		if ((FALSE == changed) || (TRUE == anEntry->changed))
		{
			/* 
			 * delete current value, in case this is a reload 
			 */
			if (NULL != anEntry->lpData)
			{
				LocalFree(anEntry->lpData);
			}
			anEntry->lpData = NULL;
			anEntry->cbData = 0;
			anEntry->changed = FALSE;

			/* 
			 * open key 
			 */
			res = RegOpenKeyEx( anEntry->hKey,
								anEntry->lpSubKey,
								0,
								KEY_QUERY_VALUE,
								&hkResult);

			if (ERROR_SUCCESS == res) 
			{
				DWORD ulTmpType;

				/* 
				 * query for the data size 
				 */
				res = RegQueryValueEx( hkResult,
										anEntry->lpValueName,
										NULL,
										&ulTmpType,
										NULL,
										&anEntry->cbData);

				/* 
				 * if the data has 0 size, we don't read it 
				 */
				if ((ERROR_SUCCESS == res) && 
					(anEntry->cbData > 0) && 
					(anEntry->ulType == ulTmpType) &&
					(NULL != (anEntry->lpData = (LPBYTE)LocalAlloc(LMEM_FIXED, anEntry->cbData))))
//					(NULL != (anEntry->lpData = (LPBYTE)malloc(anEntry->cbData))))
				{
					/* 
					 * query for data 
					 */
					res = RegQueryValueEx( hkResult,
											anEntry->lpValueName,
											NULL,
											&ulTmpType,
											anEntry->lpData,
											&anEntry->cbData);
					
					/* 
					 * something went wrong; reset 
					 */
					if (ERROR_SUCCESS != res)
					{
						LocalFree(anEntry->lpData);
						anEntry->lpData = NULL;
						anEntry->cbData = 0;
					}
				}
				else
				{
					anEntry->cbData = 0;
				}

				RegCloseKey(hkResult);
			}
		}

		aBlock++;
	}
}

/*
 * writeBlock()
 *
 * Description: Stores all of the items in a array of registry entries
 *
 * Parameters:  aBlock - pointer to an array of _reg_entry structures
 *				forceAll - boolean which, when true, causes all of the
 *				structures to be written to the registry, otherwise only
 *				those entries that are marked as changed are stored.
 *
 * Returns:
 */
void writeBlock(struct _reg_entry *aBlock[], BOOL forceAll) 
{
	LONG res;
	HKEY hkResult;

	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		/*
		 * if forcall is true, write out everything
		 * otherwise only write out the changed entries
		 */
		if ((NULL != anEntry->lpData) &&
			((TRUE == forceAll) || (TRUE == anEntry->changed)))
		{
			/* 
			 * open key 
			 */
			res = RegOpenKeyEx( anEntry->hKey,
								anEntry->lpSubKey,
								0,
								KEY_SET_VALUE,
								&hkResult);

			if (ERROR_SUCCESS == res) 
			{
				/* 
				 * set data 
				 */
				res = RegSetValueEx( hkResult,
										anEntry->lpValueName,
										0,
										anEntry->ulType,
										anEntry->lpData,
										anEntry->cbData);
				
				RegCloseKey(hkResult);
			}

			anEntry->changed = FALSE;  
		}

		aBlock++;
	}
}

/*
 * setDwordValue()
 *
 * Description: Sets the value of a REG_DWORD entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aValue - the value to store in the entry
 *
 * Returns: ERROR_SUCCESS, E_OUTOFMEMORY, ERROR_INVALID_PARAMETER
 */
LONG setDwordValue(struct _reg_entry *aRegEntry, DWORD aValue)
{
	LONG res = ERROR_SUCCESS;
	DWORD value_changed = TRUE;

	if (NULL != aRegEntry)
	{
		/*
		 * Check to see if a value already exists
		 */
		if (NULL != aRegEntry->lpData)
		{
			/*
			 * If the value is the different, delete it.  
			 */
			if (memcmp(aRegEntry->lpData, &aValue, sizeof(aValue)) != 0) {
				LocalFree (aRegEntry->lpData);
				aRegEntry->lpData = NULL;
				aRegEntry->cbData = 0;
			}
			else {
				/*
				 * The value is the same, don't change it.  That would cause an
				 * unnecessary write to the registry (see bug #92799)
				 */
				value_changed = FALSE;
			}
		}

		/*
		 * set value
		 */
		if (value_changed) {
			aRegEntry->cbData = sizeof(DWORD);
			if (NULL != (aRegEntry->lpData = LocalAlloc(LMEM_FIXED, aRegEntry->cbData)))
			{
				*((DWORD*)aRegEntry->lpData) = aValue;
				aRegEntry->changed = TRUE;
			}
			else 
			{ 
				res = E_OUTOFMEMORY;
				aRegEntry->cbData = 0;
			}
		}
	}
	else 
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}


/*
 * setStringValue()
 *
 * Description: Sets the value of a REG_SZ entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aBuffer - pointer to the string to store in the entry
 *
 * Returns: ERROR_SUCCESS, E_OUTOFMEMORY, ERROR_INVALID_PARAMETER
 */
LONG setStringValue(struct _reg_entry *aRegEntry, LPCTSTR aBuffer)
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aBuffer))
	{
		/*
		 * if value already exists, delete it
		 */
		if (NULL != aRegEntry->lpData)
		{
			LocalFree(aRegEntry->lpData);
			aRegEntry->lpData = NULL;
			aRegEntry->cbData = 0;
		}

		/*
		 * set value
		 */
		aRegEntry->cbData = (_tcslen(aBuffer)+1)*sizeof(TCHAR);
		if (NULL != (aRegEntry->lpData = LocalAlloc(LMEM_FIXED, aRegEntry->cbData)))
		{
			_tcscpy((LPTSTR)aRegEntry->lpData,aBuffer);
			aRegEntry->changed = TRUE;
		}
		else 
		{ 
			res = E_OUTOFMEMORY;
			aRegEntry->cbData = 0;
		}
	}
	else 
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}


/*
 * getStringValue()
 *
 * Description: Gets the value of a REG_SZ entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aBuffer - pointer to the string to receive the string
 *
 * Returns: ERROR_SUCCESS, REGDB_E_INVALIDVALUE, ERROR_INVALID_PARAMETER
 */
LONG getStringValue(struct _reg_entry *aRegEntry, LPTSTR aBuffer) 
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aBuffer))
	{
		if (NULL != aRegEntry->lpData)
		{
			_tcscpy(aBuffer, (LPCTSTR)aRegEntry->lpData);
		}
		else 
		{
			res = REGDB_E_INVALIDVALUE;
		}
	}
	else
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}

/*
 * getDwordValue()
 *
 * Description: Gets the value of a REG_DWORD entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aValue - pointer to the variable to receive the value
 *
 * Returns: ERROR_SUCCESS, REGDB_E_INVALIDVALUE, ERROR_INVALID_PARAMETER
 */
LONG getDwordValue(struct _reg_entry *aRegEntry, LPDWORD aValue) 
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aValue))
	{
		if (NULL != aRegEntry->lpData)
		{
			*aValue = *((DWORD*)aRegEntry->lpData);
		}
		else
		{
			res = REGDB_E_INVALIDVALUE;
		}
	}
	else
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}


/**
* InitializeRegistry
*
* Description:
*   This function initiates the registry for the UPS service and the 
*   configuration application.  When called, this function calls the
*   function isRegistryInitialized(..) to determine if the registry
*   has been initialied.  If it has not, the following Keys are updated:
*        Status
*        Config
*        ServiceProviders
*
*   The values for the ServiceProviders key is supplied in the regdefs.h
*   header file.
*
* Parameters:
*   none
*
* Returns:
*   TRUE if able to open registry keys with write access.
*/
BOOL InitializeRegistry() {
    BOOL ret_val = FALSE;
    HKEY key;

    TCHAR szKeyName[MAX_PATH] = _T("");

  // Initialize UPS Service registry keys 
  InitializeServiceKeys();

  // Check to see if the registry is already initialized
  if (isRegistryInitialized() == FALSE) {
    CheckForUpgrade();
    InitializeServiceProviders();
    InitializeConfigValues();
    InitializeStatusValues();
  }

    /*
     * Remove "(None)" and "Generic" Service Provider keys if they exist
     * This fixes a localization bug introduced in RC2
     */
  _tcscpy(szKeyName, UPS_SERVICE_ROOT);
  _tcscat(szKeyName, DEFAULT_CONFIG_VENDOR_OLD);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName);
  _tcscpy(szKeyName, UPS_SERVICE_ROOT);
  _tcscat(szKeyName, UPGRADE_CONFIG_VENDOR_OLD);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName);

  // ...and check if we have write access
  if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                   UPS_DEFAULT_ROOT,
                   0,
                   KEY_WRITE,
                   &key) == ERROR_SUCCESS )
  {
    RegCloseKey(key);
    ret_val = TRUE;
  }

  return ret_val;
}


/**
* isRegistryInitialized
*
* Description:
*   This function determines if the registry has been initialized for
*   the UPS service.  This is done by examine the registry key specified
*   by the identifier UPS_SERVICE_INITIALIED_KEY.  If the key is present,
*   the registry is assumed to be initialized and TRUE is returned.  
*   Otherwise, FALSE is returned.
*
* Parameters:
*   none
*
* Returns:
*   TRUE  - if the registry has been initialized for the UPS service
*   FALSE - otherwise
*/
static BOOL isRegistryInitialized() {
BOOL ret_val = FALSE;
HKEY key;

if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, UPS_SERVICE_INITIALIZED_KEY,
  0, KEY_QUERY_VALUE, &key) == ERROR_SUCCESS) {
  ret_val = TRUE;

  RegCloseKey(key);
}
return ret_val;
}

/**
* CheckForUpgrade
*
* Description:
*   This function determines if this installation is an upgrade from
*   the WINNT 4.x UPS service.  This is done by checking to see if the 
*   Config registry key is present.  If it is not present and the Options 
*   key is set to UPS_INSTALLED, then the Upgrade registry key is set to 
*   TRUE.  Otherwise, it is set to FALSE.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void CheckForUpgrade() {
DWORD result;
HKEY key;
DWORD options = 0;

// Create the Config key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_CONFIG_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Check to see if the Config key was present
    if (result != REG_OPENED_EXISTING_KEY) {
      // Config key was not found
      InitUPSConfigBlock();

      // Check the port value
      if (ERROR_SUCCESS != GetUPSConfigOptions(&options)) {
        // Options key is not found
        SetUPSConfigUpgrade(FALSE);
      }
      else if (options & UPS_INSTALLED) {
        // The Options key is present and UPS_INSTALLED is set
        // This is an upgrade
        SetUPSConfigUpgrade(TRUE);
      }
      else {
        // The Config key is present and UPS_INSTALLED is not set
        SetUPSConfigUpgrade(FALSE);
      }
    }
    else {
      // Config key does not exist
      SetUPSConfigUpgrade(FALSE);
    }

    // Write the Config values, force a save of all values
    SaveUPSConfigBlock(TRUE);

    // Free the Config block
    FreeUPSConfigBlock();
}
}

/**
* InitializeServiceKeys
*
* Description:
*   This function initializes the UPS service registry keys to
*   default values, if the values are not present.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeServiceKeys() {
  TCHAR tmpString[MAX_PATH];
  DWORD tmpDword;

  // Initialize the registry functions
  InitUPSConfigBlock();
  
  // Check the service keys and initialize any missing keys
  if (GetUPSConfigImagePath(tmpString) != ERROR_SUCCESS) {
    SetUPSConfigImagePath(DEFAULT_CONFIG_IMAGEPATH);
  }

  if (GetUPSConfigObjectName(tmpString) != ERROR_SUCCESS) {
    SetUPSConfigObjectName(DEFAULT_CONFIG_OBJECTNAME);
  }

  if (GetUPSConfigErrorControl(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigErrorControl(DEFAULT_CONFIG_ERRORCONTROL);
  }

  if (GetUPSConfigStart(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigStart(DEFAULT_CONFIG_START);
  }

  if (GetUPSConfigType(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigType(DEFAULT_CONFIG_TYPE);
  }

  // Write the Config values, force a save of all values
  SaveUPSConfigBlock(TRUE);
  
  // Free the Status block
  FreeUPSConfigBlock();
}

/**
* InitializeServiceProviders
*
* Description:
*   This function initializes the ServiceProviders registry keys with the
*   data provided in the global structure _theStaticProvidersTable.  This
*   structure is defined in the file regdefs.h and is automatically 
*   generated.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeServiceProviders() {
DWORD result;
HKEY key;

int index = 0;

// Loop through the list of Service Providers
while (_theStaticProvidersTable[index].theModelName != NULL) {
  // Open the vendor registry key
  if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, _theStaticProvidersTable[index].theVendorKey, 
    0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // Set the model value
    RegSetValueEx(key, _theStaticProvidersTable[index].theModelName, 0, REG_SZ, 
      (LPSTR) _theStaticProvidersTable[index].theValue, 
      wcslen(_theStaticProvidersTable[index].theValue)*sizeof(TCHAR));

    RegCloseKey(key);
  }

  // Increment counter
  index++;
}
}

/**
* InitializeConfigValues
*
* Description:
*   This function initializes the Config registry keys with
*   default values.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeConfigValues() {
DWORD result;
HKEY  key;
DWORD options_val, batt_life, type; 
DWORD batt_life_size = sizeof(DWORD);

// Create the Config key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_CONFIG_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Initialize the registry functions
    InitUPSConfigBlock();

    // Set default values
    SetUPSConfigServiceDLL(DEFAULT_CONFIG_PROVIDER_DLL);
    SetUPSConfigNotifyEnable(DEFAULT_CONFIG_NOTIFY_ENABLE);
    SetUPSConfigShutdownOnBatteryEnable(DEFAULT_CONFIG_SHUTDOWN_ONBATT_ENABLE);
    SetUPSConfigShutdownOnBatteryWait(DEFAULT_CONFIG_SHUTDOWN_ONBATT_WAIT);
    SetUPSConfigRunTaskEnable(DEFAULT_CONFIG_RUNTASK_ENABLE);
    SetUPSConfigTaskName(DEFAULT_CONFIG_TASK_NAME);
    SetUPSConfigTurnOffEnable(DEFAULT_CONFIG_TURNOFF_UPS_ENABLE);
    SetUPSConfigCustomOptions(DEFAULT_CONFIG_CUSTOM_OPTIONS);
    SetUPSConfigCriticalPowerAction(DEFAULT_CONFIG_CRITICALPOWERACTION);
    SetUPSConfigTurnOffWait(DEFAULT_CONFIG_TURNOFF_UPS_WAIT);

    // If this is not an upgrade, set the appropriate values
    if ((GetUPSConfigUpgrade(&result) != ERROR_SUCCESS) || (result == FALSE)) {
      SetUPSConfigVendor(DEFAULT_CONFIG_VENDOR);
      SetUPSConfigModel(DEFAULT_CONFIG_MODEL);
      SetUPSConfigPort(DEFAULT_CONFIG_PORT);
      SetUPSConfigOptions(DEFAULT_CONFIG_OPTIONS);
      SetUPSConfigFirstMessageDelay(DEFAULT_CONFIG_FIRSTMSG_DELAY);
      SetUPSConfigMessageInterval(DEFAULT_CONFIG_MESSAGE_INTERVAL);
    }
    else {
      // This is an upgrade
      SetUPSConfigVendor(UPGRADE_CONFIG_VENDOR);
      SetUPSConfigModel(UPGRADE_CONFIG_MODEL);

      // Migrate the run command file option bit to the RunTaskEnable key
      if ((GetUPSConfigOptions(&options_val) == ERROR_SUCCESS) && 
        (options_val & UPS_RUNCMDFILE)) {
        // Run command file is enabled, set RunTaskEnable to TRUE
        SetUPSConfigRunTaskEnable(TRUE);
      }
      else {
        // Run command file is not enabled
        SetUPSConfigRunTaskEnable(FALSE);
      }

      // Migrate the BatteryLife value to the ShutdownOnBatteryWait value
      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, UPS_DEFAULT_ROOT, 0, KEY_ALL_ACCESS, &key) == ERROR_SUCCESS) {

        result = RegQueryValueEx(key, UPS_BATTLIFE_KEY, NULL, &type, (LPBYTE) &batt_life,  &batt_life_size);

        if ((result == ERROR_SUCCESS) && (type == REG_DWORD)) {

          // Migrate the value and enable shutdown on battery
          SetUPSConfigShutdownOnBatteryWait(batt_life);
		  SetUPSConfigShutdownOnBatteryEnable(TRUE);

          // Delete the value
          RegDeleteValue(key, UPS_BATTLIFE_KEY);
        }

        // Close the key
        RegCloseKey(key);
      }
    }

    // Write the Config values, force a save of all values
    SaveUPSConfigBlock(TRUE);

    // Free the Config block
    FreeUPSConfigBlock();
  }
}

/**
* InitializeStatusValues
*
* Description:
*   This function initializes the Status registry keys with 
*   default values.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeStatusValues() {
DWORD result;
HKEY key;

// Create the Status key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_STATUS_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Initialize the registry functions
    InitUPSStatusBlock();

    // Put in default values
    SetUPSStatusSerialNum(DEFAULT_STATUS_SERIALNO);
    SetUPSStatusFirmRev(DEFAULT_STATUS_FIRMWARE_REV);
    SetUPSStatusUtilityStatus(DEFAULT_STATUS_UTILITY_STAT);
    SetUPSStatusRuntime(DEFAULT_STATUS_TOTAL_RUNTIME);
    SetUPSStatusBatteryStatus(DEFAULT_STATUS_BATTERY_STAT);
	SetUPSStatusBatteryCapacity(DEFAULT_STATUS_BATTERY_CAPACITY);

    // Write the Config values, force a save of all values
    SaveUPSStatusBlock(TRUE);

    // Free the Status block
    FreeUPSStatusBlock();
  }
}



///////////////////////////////////////////////////////////////////////////////
// upsdata.c
///////////////////////////////////////////////////////////////////////////////

//Note that the order of the following RegField is linked to the enum
//tUPSDataItemID.
//Do not change these value without due care and attention. It's OK to change
//them as long as the enum is updated to match.

//To access the RegField associated with Firmware, for example, use
//g_upsRegFields[(DWORD) eREG_FIRMWARE_REVISION]

static RegField g_upsRegFields[] = {
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Vendor"),                  REG_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Model"),                   REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("SerialNumber"),            REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("FirmwareRev"),             REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("UtilityPowerStatus"),      REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("TotalUPSRuntime"),         REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("BatteryCapacity"),         REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("BatteryStatus"),           REG_DWORD },
    { HKEY_LOCAL_MACHINE, UPS_KEY_NAME,    TEXT("Options"),                 REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ServiceProviderDLL"),      REG_EXPAND_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ShutdownOnBatteryEnable"), REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ShutdownOnBatteryWait"),   REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("TurnUPSOffEnable"),        REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("APCLinkURL"),              REG_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Upgrade"),                 REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("CommStatus"),              REG_DWORD },
    { HKEY_LOCAL_MACHINE, UPS_KEY_NAME,    TEXT("Port"),                    REG_SZ } };

// functions
///////////////////////////////////////////////////////////////////////////////

DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID,
                         DWORD aAllowedTypes,
                         DWORD * aTypePtr,
                         LPBYTE aReturnBuffer,
                         DWORD * aBufferSizePtr);

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// RegField * GetRegField (DWORD aIndex);
//
// Description: This function returns a pointer to a RegField from the
//              static array of RegFields named g_upsRegFields. The parameter
//              aIndex is an index into this array.
//
// Additional Information: 
//
// Parameters:
//
//   DWORD aIndex :- A index into array of known RegFields g_upsRegFields
//
// Return Value: If aIndex is within range this function returns a point to
//               the corresponding RegField, otherwise it ASSERTs and returns
//               NULL.
//
RegField * GetRegField (DWORD aIndex) {
  static const DWORD numRegFields = DIMENSION_OF(g_upsRegFields);
  RegField * pRequiredReg = NULL;

  if (aIndex < numRegFields) {
    pRequiredReg = &g_upsRegFields[aIndex];
    }
  else {
    _ASSERT(FALSE);
    }

  return(pRequiredReg);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL GetUPSDataItemDWORD (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr);
//
// Description: This function reads the DWORD value from the registry that
//              corresponds to the registry field identified by aDataItemID.
//              The registry value must be one of the DWORD types (REG_DWORD,
//              REG_DWORD_LITTLE_ENDIAN, REG_DWORD_BIG_ENDIAN)
//
//              For example, if aDataItemID is eREG_UPS_OPTIONS (=7), the
//              RegField at index 7 in g_upsRegFields identifies the required
//              registry information. The RegField identifies that the registry
//              key is HKLM\SYSTEM\CurrentControlSet\Services\UPS and the
//              value name is Options and it's of type DWORD. Using this
//              information this function gets the information from the
//              registry and puts the result in aReturnValuePtr.
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried. The value ranges
//                                       from eREG_VENDOR_NAME (which equals 0)
//                                       to eREG_PORT, the values incrementing
//                                       by 1 for each enum in the range. The
//                                       range of values in tUPSDataItemID
//                                       corresponds directly to the number of
//                                       elements in the array g_upsRegFields
//                                       because this enum is used to index the
//                                       elements in g_upsRegFields.
//
//   DWORD * aReturnValuePtr :- The DWORD value is returned through this
//                              pointer.
//
// Return Value: 
//
BOOL GetUPSDataItemDWORD (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr) {
  BOOL bGotValue = FALSE;
  DWORD nDWORDSize = sizeof(DWORD);

  if (ReadRegistryValue(aDataItemID, REG_DWORD, NULL, (LPBYTE) aReturnValuePtr, &nDWORDSize) == ERROR_SUCCESS) {
    bGotValue = TRUE;
    }

  return(bGotValue);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID, 
//                            LPTSTR aBufferPtr, 
//                            DWORD * pSizeOfBufferPtr);
//
// Description: This function reads the string value from the registry that
//              corresponds to the registry field identified by aDataItemID.
//              The registry value must be one of the string types (REG_SZ or
//              REG_EXPAND_SZ)
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried. The value must be
//                                       one of the string types (REG_SZ or
//                                       REG_EXPAND_SZ).
//
//   LPTSTR aBufferPtr :- The buffer into which the data is to be placed. This
//                        parameter can be NULL in which case no data is
//                        retrieved.
//
//   DWORD * pSizeOfBufferPtr :- This should point to a DWORD that contains the
//                               size of the buffer. This parameter cannot be
//                               NULL. When this function returns this value
//                               will contain the size actually required. This
//                               is useful if the user want to determine how
//                               big a buffer is required by calling this
//                               function with aBufferPtr set to NULL and
//                               pSizeOfBufferPtr pointing to a DWORD that
//                               is set to 0. When the function returns the
//                               DWORD pointed to by pSizeOfBufferPtr should
//                               contain the size of string required. This can
//                               then be used to dynamically allocate memory
//                               and call this function again with the buffer
//                               included this time.
//
// Return Value: The function returns TRUE if successful, FALSE otherwise.
//
BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID,
                           LPTSTR aBufferPtr,
                           DWORD * pSizeOfBufferPtr) {
  BOOL bGotValue = FALSE;
  DWORD nType = 0;

  if (ReadRegistryValue(aDataItemID,
                        REG_SZ | REG_EXPAND_SZ,
                        &nType,
                        (LPBYTE) aBufferPtr,
                        pSizeOfBufferPtr) == ERROR_SUCCESS) {
    //RegQueryValueEx stores the size of the data, in bytes, in the variable
    //pointed to by lpcbData. If the data has the REG_SZ, REG_MULTI_SZ or
    //REG_EXPAND_SZ type, then lpcbData will also include the size of the
    //terminating null character.
    //For Unicode the terminating NULL character is two-bytes.
    if ((pSizeOfBufferPtr != NULL) && (*pSizeOfBufferPtr > sizeof(TCHAR))) {
      if (nType == REG_EXPAND_SZ) {
        TCHAR expandBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
        DWORD expandBufferSize = DIMENSION_OF(expandBuffer);

        //ExpandEnvironmentStrings return number of bytes(ANSI) or
        //number of character(UNICODE) including the NULL character
        if (ExpandEnvironmentStrings(aBufferPtr, expandBuffer, expandBufferSize) > 0) {
          _tcscpy(aBufferPtr, expandBuffer);
          }
        }

      bGotValue = TRUE;
      }
    }

  return(bGotValue);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID, 
//                          DWORD aAllowedTypes, 
//                          DWORD * aTypePtr, 
//                          LPBYTE aReturnBuffer, 
//                          DWORD * aBufferSizePtr);
//
// Description: This function reads the registry value identified by
//              aDataItemID. This function can read any type of registry value
//              but the value must match that identified in the RegField
//              description for this field.
//              
//              For example, if aDataItemID is eREG_UPS_OPTIONS (=7), the
//              RegField at index 7 in g_upsRegFields identifies the required
//              registry information. The RegField identifies that the registry
//              key is HKLM\SYSTEM\CurrentControlSet\Services\UPS and the
//              value name is Options and it's of type DWORD. This function
//              will succeed only if it's called with an aAllowedTypes value
//              equal to REG_DWORD.
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried.
//
//   DWORD aAllowedTypes :- This identifies the allowed type of the registry
//                          data. The registry value types are not bit value
//                          that can be |'d (the types are sequentially
//                          numbered 0, 1, 2, 3, 4, not 0, 1, 2, 4, 8).
//                          However, the parameter is still called
//                          aAllowedTypes because we actually call the function
//                          with a value of REG_SZ | REG_EXPAND_SZ (1 | 2) to
//                          allow the same function to work if the value is
//                          either of these. Except for this case assume that
//                          the aAllowedTypes is actually aAllowedType.
//
//   DWORD * aTypePtr :- A pointer to the buffer that will receive the type.
//                       If the type is not required then this parameter can be
//                       set to NULL.
//
//   LPBYTE aReturnBuffer :- The buffer into which the data is to be placed.
//                           This parameter can be NULL in which case no data
//                           is retrieved.
//
//   DWORD * aBufferSizePtr :- This should point to a DWORD that contains the
//                             size of the buffer. This parameter cannot be
//                             NULL. When this function returns this value
//                             will contain the size actually required.
//
// Return Value: This function returns a Win32 error code, ERROS_SUCCESS on
//               success.
//
DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID,
                         DWORD aAllowedTypes,
                         DWORD * aTypePtr,
                         LPBYTE aReturnBuffer,
                         DWORD * aBufferSizePtr) {
  DWORD ret_val = ERROR_NO_MATCH;
  RegField * pRegField = GetRegField((DWORD) aDataItemID);

  if (pRegField != NULL ) {
		_ASSERT((pRegField->theValueType & aAllowedTypes) == pRegField->theValueType);

		ret_val = ReadRegistryValueData(pRegField->theRootKey,
																 pRegField->theKeyName,
																 pRegField->theValueName,
																 aAllowedTypes,
																 aTypePtr,
																 (LPTSTR) aReturnBuffer,
																 aBufferSizePtr);
  }

  return ret_val;
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD ReadRegistryValueData (HKEY aRootKey, 
//                              LPCTSTR aKeyName, 
//                              LPCTSTR aValueName, 
//                              DWORD aAllowedTypes, 
//                              DWORD * aTypePtr, 
//                              LPTSTR aReturnBuffer, 
//                              DWORD * aBufferSizePtr);
//
// Description: 
//
// Additional Information: 
//
// Parameters:
//
//   HKEY aRootKey :- A handle to an open registry key.
//
//   LPCTSTR aKeyName :- The name of the key relative to the open key.
//
//   LPCTSTR aValueName :- The name of the value to read
//
//   DWORD aAllowedTypes :- See help on ReadRegistryValue.
//
//   DWORD * aTypePtr :- A pointer to the buffer that will receive the type.
//                       If the type is not required then this parameter can be
//                       set to NULL.
//
//   LPBYTE aReturnBuffer :- The buffer into which the data is to be placed.
//                           This parameter can be NULL in which case no data
//                           is retrieved.
//
//   DWORD * aBufferSizePtr :- This should point to a DWORD that contains the
//                             size of the buffer. This parameter cannot be
//                             NULL. When this function returns this value
//                             will contain the size actually required.
//
// Return Value: This function returns a Win32 error code, ERROS_SUCCESS on
//               success.
//
DWORD ReadRegistryValueData (HKEY aRootKey,
                             LPCTSTR aKeyName,
                             LPCTSTR aValueName,
                             DWORD aAllowedTypes,
                             DWORD * aTypePtr,
                             LPTSTR aReturnBuffer,
                             DWORD * aBufferSizePtr) {
  DWORD nType = 0;
  DWORD errCode = ERROR_INVALID_PARAMETER;
  HKEY hOpenKey = NULL;

  if ((errCode = RegOpenKeyEx(aRootKey,
                              aKeyName,
                              0,
                              KEY_READ,
                              &hOpenKey)) == ERROR_SUCCESS) {

    _ASSERT(hOpenKey != NULL);

    //Key exists and is now open

    if ((errCode = RegQueryValueEx(hOpenKey,
                                   aValueName,
                                   NULL,
                                   &nType,
                                   (LPBYTE) aReturnBuffer,
                                   aBufferSizePtr)) == ERROR_SUCCESS) {
      if (aTypePtr != NULL) {
        *aTypePtr = nType;
        }

      if ((nType & aAllowedTypes) == 0) {
        //The value type in the registry does not match the expected
        //type for this function call.
        _ASSERT(FALSE);
        }

      if ((aReturnBuffer != NULL) && (*aBufferSizePtr == 1)) {
        //If the registry entry was in fact empty, the buffer needs to
        //be 1 character, for the NULL termination.
        *aReturnBuffer = TEXT('\0');
        }
      }
    else {
      //Something prevented us from reading the value.
      //The value may not exist, the buffer size might
      //not be large enough. May be using the function to
      //read a DWORD value on a registry value that is a
      //shorter string.

      if (errCode == ERROR_MORE_DATA) {
        //There is most likely a mismatch between the type we expect
        //and the actual type of this registry value.
        _ASSERT(FALSE);
        }
      }

    RegCloseKey(hOpenKey);
    }

  return(errCode);
  }



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\csc.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csc.c

Abstract:

    These are the wkssvc API RPC client stubs for CSC

--*/

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <time.h>
#include    <rpcutil.h>
#include    <lmcons.h>
#include    <lmerr.h>
#include    <lmapibuf.h>
#include    <lmwksta.h>
#include    "cscp.h"

static FARPROC pCSCIsServerOffline = NULL;

/*
 * Paranoia
 */
#define WCSLEN( x ) ( (x) ? wcslen(x) : 0)
#define WCSCPY( d, s ) (((s) && (d)) ? wcscpy( d, s ) : 0)

//
// Load the cscdll.dll library, and pull out the functions that we need.
//
static
GetCSCEntryPoints()
{
    HANDLE hMod;

    if( pCSCIsServerOffline == NULL ) {

        hMod = LoadLibrary(L"cscdll.dll");
        if( hMod != NULL ) {
            pCSCIsServerOffline = GetProcAddress(hMod, "CSCIsServerOfflineW" );
        }

    }
    return pCSCIsServerOffline != NULL;
}

//
// Return TRUE if we think this server is in the offline state
//
static
BOOLEAN
CSCIsServerOffline(
    IN LPWSTR servername
)
{
    BOOL isOffline;

    if( GetCSCEntryPoints() &&
        pCSCIsServerOffline( servername, &isOffline ) &&
        isOffline == TRUE ) {

        return TRUE;
    }

    return FALSE;
}

//
// Emulate NetWkstaGetInfo() for an offline server.  We don't capture enough information
//  from the target server to really emulate this API, so we use our own data instead.
//
NET_API_STATUS NET_API_FUNCTION
CSCNetWkstaGetInfo (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    NET_API_STATUS status;
    PWKSTA_INFO_100 wsi;
    ULONG len, baselen;
    PVOID ni;

    if( CSCIsServerOffline( servername ) == FALSE ) {
        return ERROR_UNEXP_NET_ERR;
    }

    //
    // Call the local API, since we don't have cached info for the remote one
    //
    status = NetWkstaGetInfo( NULL, level, bufptr );

    //
    // If we got an error or the computername is not in the returned info, then
    // just get out now.
    //
    if( status != NO_ERROR ||
        (level != 100 && level != 101 && level != 102 ) ) {

        return status;
    }

    //
    // We need to patch the computer name to be the name the caller asked
    //  for, not the local name
    //
    wsi = (PWKSTA_INFO_100)(*bufptr);

    //
    // The returned computer name does not have the leading slashes, so trim them off
    //
    while( *servername == L'\\' ) {
        servername++;
    }

    if( *servername == L'\0' ) {
        MIDL_user_free( *bufptr );
        *bufptr = NULL;
        return ERROR_UNEXP_NET_ERR;
    }

    //
    // Maybe we can do the substitution in place
    //
    if( WCSLEN( servername ) <= WCSLEN( wsi->wki100_computername ) ) {
        //
        // Great -- we can do it in place!
        //
        WCSCPY( wsi->wki100_computername, servername );
        return NO_ERROR;
    }

    //
    // Drat -- we need to reallocate and do it the hard way
    //
    len = WCSLEN( wsi->wki100_langroup )*sizeof(WCHAR) + sizeof( WCHAR );
    len += WCSLEN( servername ) * sizeof( WCHAR ) + sizeof( WCHAR );

    switch( level ) {
    case 100:
        baselen = sizeof( WKSTA_INFO_100 );
        break;
    case 101:
        baselen = sizeof( WKSTA_INFO_101 );
        len += WCSLEN( ((PWKSTA_INFO_101)(*bufptr))->wki101_lanroot )* sizeof( WCHAR ) + sizeof( WCHAR );
        break;
    case 102:
        baselen = sizeof( WKSTA_INFO_102 );
        len += WCSLEN( ((PWKSTA_INFO_101)(*bufptr))->wki101_lanroot )* sizeof( WCHAR ) + sizeof( WCHAR );
        break;
    }

    if ((ni = MIDL_user_allocate(baselen + len )) == NULL) {
        MIDL_user_free( *bufptr );
        *bufptr = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy( ni, *bufptr, baselen );
    wsi = (PWKSTA_INFO_100)ni;

    wsi->wki100_computername = (LPWSTR)((PBYTE)ni + baselen);
    WCSCPY( wsi->wki100_computername, servername );

    wsi->wki100_langroup = (LPWSTR)((LPBYTE)wsi->wki100_computername +
                           (WCSLEN( wsi->wki100_computername )+1) * sizeof(WCHAR));

    WCSCPY( wsi->wki100_langroup, ((PWKSTA_INFO_100)(*bufptr))->wki100_langroup );

    if( level == 101 || level == 102 ) {
        PWKSTA_INFO_101 wsi101 = (PWKSTA_INFO_101)ni;

        wsi101->wki101_lanroot = (LPWSTR)(((LPBYTE)wsi->wki100_langroup) +
                                (WCSLEN(wsi->wki100_langroup)+1)*sizeof(WCHAR));

        WCSCPY( wsi101->wki101_lanroot, ((PWKSTA_INFO_101)(*bufptr))->wki101_lanroot );
    }

    MIDL_user_free( *bufptr );
    *bufptr = ni;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\wkssvc_c_stub.c ===
#include "wkssvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\cscp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cscp.h 

Abstract:

    Contains definitions used for accessing the CSC share database

--*/

//
// These functions are callouts from srvstub.c to the CSC subsystem.  They help with
//  offline access to servers and shares
//

NET_API_STATUS NET_API_FUNCTION
CSCNetWkstaGetInfo (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\wstest.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wstest.c

Abstract:

    Test program for the NetWksta and NetUse APIs.  Run this test after
    starting the Workstation service.

Author:

    Rita Wong (ritaw) 12-Mar-1991

Revision History:

--*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <winerror.h>
#include <windef.h>              // Win32 type definitions
#include <winbase.h>             // Win32 base API prototypes

#include <lm.h>                  // LAN Man definitions
#include <netdebug.h>            // NetpDbgDisplayWksta()
#include <netlib.h>

#include <tstring.h>

#ifdef UNICODE
#define FORMAT_STR "ws "
#else
#define FORMAT_STR "s "
#endif


#define CHANGE_HEURISTICS                                                       \
    for (i = 0, ptr = &(redir->wki502_use_opportunistic_locking); i < 14;       \
         i++, ptr++) {                                                          \
        if (*ptr) {                                                             \
            *ptr = FALSE;                                                       \
        }                                                                       \
        else {                                                                  \
            *ptr = TRUE;                                                        \
        }                                                                       \
    }

CHAR WorkBuffer[(DEVLEN + RMLEN + PWLEN + UNLEN + DNLEN + 5) * sizeof(TCHAR)
                + sizeof(PUSE_INFO_2)];


LPWSTR TargetMachine = NULL;

VOID
WsTestWkstaInfo(
    VOID
    );

VOID
WsTestWkstaTransportEnum(
    VOID
    );

VOID
WsTestUse(
    VOID
    );

VOID
TestUseAdd(
    IN  LPBYTE Buffer,
    IN  DWORD ExpectedStatus
    );

VOID
TestUseDel(
    IN  LPTSTR UseName,
    IN  DWORD ForceLevel,
    IN  DWORD ExpectedStatus
    );

VOID
TestUseEnum(
    DWORD PreferedMaximumLength,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

VOID
TestUseGetInfo(
    LPTSTR UseName,
    DWORD ExpectedStatus
    );

VOID
PrintUseInfo1(
    PUSE_INFO_1 UseInfo
    );

VOID
PrintUseInfo2(
    PUSE_INFO_2 UseInfo
    );



VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    if (argc > 1) {

       if (argc == 3) {
           TargetMachine = NetpAllocWStrFromStr(argv[2]);

           if (TargetMachine != NULL) {

               printf("New Target is %ws\n", TargetMachine);
           }
       }

       WsTestWkstaInfo();

       WsTestWkstaTransportEnum();

       if (TargetMachine != NULL) {
           NetApiBufferFree(TargetMachine);
       }
    }

    WsTestUse();
}


VOID
WsTestWkstaInfo(
    VOID
    )
{
    NET_API_STATUS status;

    PWKSTA_INFO_502 redir;

    PWKSTA_INFO_102 systeminfo102;
    PWKSTA_INFO_100 systeminfo100;
    PWKSTA_INFO_101 systeminfo101;

    PWKSTA_USER_INFO_0 UserInfo0;
    PWKSTA_USER_INFO_1 UserInfo;

    DWORD ErrorParameter;
    DWORD i = 0;
    BOOL *ptr = NULL;

    DWORD ResumeHandle = 0;
    DWORD EntriesRead;
    DWORD TotalEntries;



    printf("In wstest.exe\n\n");

    status = NetWkstaGetInfo(
                 TargetMachine,
                 502,
                 (LPBYTE *) &redir
                 );

    printf("NetWkstaGetInfo Test:status=%lu\n", status);

    if (status != NERR_Success) {
       goto TrySomethingElse;
    }

    redir->wki502_char_wait++;
    redir->wki502_maximum_collection_count++;
    redir->wki502_collection_time++;

    redir->wki502_keep_conn++;
    redir->wki502_siz_char_buf++;

    redir->wki502_max_cmds++;         // Not settable: should be ignored

    redir->wki502_sess_timeout++;
    redir->wki502_lock_quota++;
    redir->wki502_lock_increment++;
    redir->wki502_lock_maximum++;
    redir->wki502_pipe_increment++;
    redir->wki502_pipe_maximum++;

    redir->wki502_cache_file_timeout++;

    CHANGE_HEURISTICS;

    status = NetWkstaSetInfo(
                 TargetMachine,
                 502,
                 (LPBYTE) redir,
                 &ErrorParameter
                 );

    printf("NetWkstaSetInfo Test:status=%lu\n", status);

    //
    // Free the get info buffer.  We are getting another buffer from the
    // next get.
    //
    NetApiBufferFree(redir);

    if (status != NERR_Success) {
        if (status == ERROR_INVALID_PARAMETER) {
            printf(
            "NetWkstaSetInfo parameter %lu causes ERROR_INVALID_PARAMETER\n",
            ErrorParameter
            );
        }
        goto TrySomethingElse;
    }

    status = NetWkstaGetInfo(
                 TargetMachine,
                 502,
                 (LPBYTE *) &redir
                 );

    printf("NetWkstaGetInfo again: status=%lu\n", status);

    if (status != NERR_Success) {
        goto TrySomethingElse;
    }

    printf("\nAfter NetWkstaSetInfo, all values should be 1 extra"
           " maxcmds\n");

    redir->wki502_char_wait--;
    redir->wki502_collection_time--;
    redir->wki502_maximum_collection_count--;

    redir->wki502_keep_conn--;
    redir->wki502_siz_char_buf--;

    //redir->wki502_max_cmds--;         // Not settable

    redir->wki502_sess_timeout--;
    redir->wki502_lock_quota--;
    redir->wki502_lock_increment--;
    redir->wki502_lock_maximum--;
    redir->wki502_pipe_increment--;
    redir->wki502_pipe_maximum--;

    redir->wki502_cache_file_timeout--;

    CHANGE_HEURISTICS;

    status = NetWkstaSetInfo(
                 TargetMachine,
                 502,
                 (LPBYTE) redir,
                 NULL
                 );

    NetApiBufferFree(redir);

    printf("NetWkstaGetInfo to reset to original values: status=%lu\n", status);


TrySomethingElse:
    //
    // Get system info 102
    //
    status = NetWkstaGetInfo(
                 TargetMachine,
                 102,
                 (LPBYTE *) &systeminfo102
                 );

    if (status == NERR_Success) {
        NetApiBufferFree(systeminfo102);
    }
    else {
        printf("NetWkstaGetInfo level 102: FAILED %lu\n", status);
    }

    //
    // Get system info 100
    //
    status = NetWkstaGetInfo(
                 TargetMachine,
                 100,
                 (LPBYTE *) &systeminfo100
                 );

    if (status == NERR_Success) {
        NetApiBufferFree(systeminfo100);
    }
    else {
        printf("NetWkstaGetInfo level 100: FAILED %lu\n", status);
    }

    //
    // Get system info 101
    //
    status = NetWkstaGetInfo(
                 TargetMachine,
                 101,
                 (LPBYTE *) &systeminfo101
                 );

    if (status == NERR_Success) {
        NetApiBufferFree(systeminfo101);
    }
    else {
        printf("NetWkstaGetInfo level 101: FAILED %lu\n", status);
    }


    //
    // Get user info level 1
    //
    status = NetWkstaUserGetInfo(
                 NULL,
                 1,
                 (LPBYTE *) &UserInfo
                 );

    if (status == NERR_Success) {
        printf("NetWkstaUserGetInfo level 1:\n"
               "username=" FORMAT_LPTSTR "\nlogon domain=" FORMAT_LPTSTR "\nother domains=" FORMAT_LPTSTR "\nlogon server=" FORMAT_LPTSTR "\n",
               UserInfo->wkui1_username,
               UserInfo->wkui1_logon_domain,
               UserInfo->wkui1_oth_domains,
               UserInfo->wkui1_logon_server
               );

        NetApiBufferFree(UserInfo);
    }
    else {
        printf("NetWkstaUserGetInfo level 1: FAILED %lu", status);
    }

    //
    // Get user info level 0
    //
    status = NetWkstaUserGetInfo(
                 NULL,
                 0,
                 (LPBYTE *) &UserInfo0
                 );

    if (status == NERR_Success) {
        printf("NetWkstaUserGetInfo level 0:\nusername=" FORMAT_LPTSTR "\n",
               UserInfo0->wkui0_username
               );

        NetApiBufferFree(UserInfo0);
    }
    else {
        printf("NetWkstaUserGetInfo level 0: FAILED %lu", status);
    }

    status = NetWkstaUserEnum (
                 TargetMachine,
                 1,
                 (LPBYTE *) &UserInfo,
                 MAXULONG,
                 &EntriesRead,
                 &TotalEntries,
                 &ResumeHandle
                 );


    if (status == NERR_Success) {

        PWKSTA_USER_INFO_1 TmpPtr = UserInfo;


        printf("NetWkstaUserEnum level 1: EntriesRead=%lu, TotalEntries=%lu\n",
               EntriesRead, TotalEntries);

        for (i = 0; i < EntriesRead; i++, UserInfo++) {

            printf("  username=" FORMAT_LPTSTR "\nlogon domain=" FORMAT_LPTSTR "\nother domains=" FORMAT_LPTSTR "\nlogon server=" FORMAT_LPTSTR "\n",
                   UserInfo->wkui1_username,
                   UserInfo->wkui1_logon_domain,
                   UserInfo->wkui1_oth_domains,
                   UserInfo->wkui1_logon_server
                   );
        }

        NetApiBufferFree(TmpPtr);
    }
    else {
        printf("NetWkstaUserEnum level 1: FAILED %lu", status);
    }

}


VOID
WsTestWkstaTransportEnum(
    VOID
    )
{
    NET_API_STATUS status;
    LPBYTE Buffer;
    DWORD EntriesRead,
          TotalEntries,
          ResumeHandle = 0;


    status = NetWkstaTransportEnum(
                 NULL,
                 0,
                 &Buffer,
                 MAXULONG,
                 &EntriesRead,
                 &TotalEntries,
                 &ResumeHandle
                 );

    printf("NetWkstaTransportEnum Test:status=%lu\n", status);

    if (status == NERR_Success) {

        printf("   EntriesRead=%lu, TotalEntries=%lu\n", EntriesRead,
               TotalEntries);

        NetApiBufferFree(Buffer);
    }
}


VOID
WsTestUse(
    VOID
    )
{
    PUSE_INFO_2 UseInfo = (PUSE_INFO_2) WorkBuffer;
    DWORD ResumeHandle = 0;

    DWORD i;

    LPTSTR PasswordSavePtr;
    LPTSTR UserNameSavePtr;
    LPTSTR DomainNameSavePtr;


    //
    // Initialize string pointers.  Local device points to the bottom
    // of Info 2 structure; Shared resource points to the middle of
    // buffer (away from everything so there's no chance of overwriting
    // or being overwritten.
    //
    UseInfo->ui2_local = (LPTSTR) &WorkBuffer[sizeof(USE_INFO_2)];

    UseInfo->ui2_remote = (LPTSTR) ((DWORD) UseInfo->ui2_local) +
                                    (DEVLEN + 1) * sizeof(TCHAR);

    UseInfo->ui2_password = NULL;
    PasswordSavePtr = (LPTSTR) ((DWORD) UseInfo->ui2_remote) +
                                      (RMLEN + 1) * sizeof(TCHAR);

    UseInfo->ui2_username = NULL;
    UserNameSavePtr = (LPTSTR) ((DWORD) PasswordSavePtr) +
                                      (PWLEN + 1) * sizeof(TCHAR);

    UseInfo->ui2_domainname = NULL;
    DomainNameSavePtr = (LPTSTR) ((DWORD) UserNameSavePtr) +
                                      (DNLEN + 1) * sizeof(TCHAR);

    UseInfo->ui2_asg_type = USE_DISKDEV;


    //
    // Test with explicit username and password
    //
    UseInfo->ui2_username = UserNameSavePtr;
    UseInfo->ui2_password = PasswordSavePtr;
    UseInfo->ui2_domainname = DomainNameSavePtr;

    STRCPY(UseInfo->ui2_username, TEXT("NTBUILD"));
    STRCPY(UseInfo->ui2_password, TEXT("NTBUILD"));
    STRCPY(UseInfo->ui2_domainname, TEXT("NtWins"));
    STRCPY(UseInfo->ui2_local, TEXT("k:"));
    STRCPY(UseInfo->ui2_remote, TEXT("\\\\kernel\\razzle2"));
    TestUseAdd(WorkBuffer, NERR_Success);
    TestUseGetInfo(TEXT("K:"), NERR_Success);


    UseInfo->ui2_password = NULL;
    UseInfo->ui2_domainname = NULL;

    //
    // Connect to \\kernel\razzle2 again with only the username
    //
    STRCPY(UseInfo->ui2_local, TEXT("j:"));
    TestUseAdd(WorkBuffer, NERR_Success);

    //
    // Add 5 \\ritaw2\public
    //
    UseInfo->ui2_username = NULL;

    STRCPY(UseInfo->ui2_local, TEXT(""));
    STRCPY(UseInfo->ui2_remote, TEXT("\\\\ritaw2\\public"));
    for (i = 0; i < 5; i++) {
        TestUseAdd(WorkBuffer, NERR_Success);
    }

    TestUseDel(
        TEXT("j:"),
        USE_LOTS_OF_FORCE,
        NERR_Success
        );

    TestUseDel(
        TEXT("k:"),
        USE_LOTS_OF_FORCE,
        NERR_Success
        );

    //
    // Add p: \\ritaw2\public
    //
    STRCPY(UseInfo->ui2_local, TEXT("p:"));
    TestUseAdd(WorkBuffer, NERR_Success);

    //
    // Add U: \\ritaw2\public
    //
    STRCPY(UseInfo->ui2_local, TEXT("U:"));
    TestUseAdd(WorkBuffer, NERR_Success);

    //
    // Add s: \\ritaw2\testdir
    //
    STRCPY(UseInfo->ui2_local, TEXT("s:"));
    STRCPY(UseInfo->ui2_remote, TEXT("\\\\ritaw2\\testdir"));
    TestUseAdd(WorkBuffer, NERR_Success);
    TestUseAdd(WorkBuffer, ERROR_ALREADY_ASSIGNED);
    TestUseGetInfo(TEXT("\\\\ritaw2\\testdir"), NERR_UseNotFound);

    //
    // Add 3 \\ritaw2\testdir
    //
    STRCPY(UseInfo->ui2_local, TEXT(""));
    for (i = 0; i < 3; i++) {
        TestUseAdd(WorkBuffer, NERR_Success);
    }

    //
    // Create implicit connections
    //
    system("ls \\\\ritaw2\\pub2");
    system("ls \\\\ritaw2\\tmp");

    //
    // Delete implicit connection \\ritaw2\tmp USE_NOFORCE.
    //
    TestUseDel(
        TEXT("\\\\ritaw2\\tmp"),
        USE_NOFORCE,
        NERR_Success
        );

    //
    // Enumerate all connections
    //
    TestUseEnum(MAXULONG, NULL);

    TestUseEnum(150, &ResumeHandle);

    TestUseEnum(100, &ResumeHandle);

    for (i = 0; i < 3; i++) {
        TestUseEnum(50, &ResumeHandle);
    }

    TestUseEnum(150, NULL);


    //
    // Get info
    //
    TestUseGetInfo(TEXT("\\\\ritaw2\\public"), NERR_Success);

    TestUseGetInfo(TEXT("p:"), NERR_Success);

    TestUseGetInfo(TEXT("\\\\ritaw2\\Z"), NERR_UseNotFound);

    TestUseGetInfo(TEXT("\\\\ritaw2\\Testdir"), NERR_Success);

    TestUseGetInfo(TEXT("S:"), NERR_Success);


    //
    // Delete \\ritaw2\public USE_NOFORCE.  Decrements usecount from 5 to 4.
    //
    TestUseDel(
        TEXT("\\\\ritaw2\\public"),
        USE_NOFORCE,
        NERR_Success
        );

    //
    // Delete \\ritaw2\public USE_FORCE.  This should delete all 4 usecounts.
    //
    TestUseDel(
        TEXT("\\\\ritaw2\\public"),
        USE_FORCE,
        NERR_Success
        );

    TestUseDel(
        TEXT("\\\\ritaw2\\public"),
        USE_FORCE,
        NERR_UseNotFound
        );

    //
    // Delete s: USE_FORCE
    //
    TestUseDel(
        TEXT("s:"),
        USE_LOTS_OF_FORCE,
        NERR_Success
        );

    //
    // Add s: \\ritaw2\z
    //
    STRCPY(UseInfo->ui2_local, TEXT("s:"));
    STRCPY(UseInfo->ui2_remote, TEXT("\\\\ritaw2\\z"));
    TestUseAdd(WorkBuffer, NERR_Success);

    //
    // Delete p: USE_NOFORCE.  Second time should get NERR_UseNotFound.
    //
    TestUseDel(
        TEXT("p:"),
        USE_LOTS_OF_FORCE,
        NERR_Success
        );

    TestUseDel(
        TEXT("p:"),
        USE_LOTS_OF_FORCE,
        NERR_UseNotFound
        );

    //
    // Delete \\ritaw2\testdir USE_NOFORCE.  4th time should be
    // NERR_UseNotFound.
    //
    for (i = 0; i < 3; i++) {
        TestUseDel(
           TEXT("\\\\ritaw2\\testdir"),
           USE_NOFORCE,
           NERR_Success
           );
    }

    TestUseDel(
       TEXT("\\\\ritaw2\\testdir"),
       USE_NOFORCE,
       NERR_UseNotFound
       );


    //
    // Add prn: \\ritaw2\prn
    //

    UseInfo->ui2_asg_type = USE_SPOOLDEV;

    STRCPY(UseInfo->ui2_local, TEXT("prn"));
    STRCPY(UseInfo->ui2_remote, TEXT("\\\\prt21088\\laserii"));
    TestUseAdd(WorkBuffer, NERR_Success);

    //
    // Add lpt1: \\ritaw2\laser, should get ERROR_ALREADY_ASSIGNED because prn:
    // is converted to lpt1.
    //
    STRCPY(UseInfo->ui2_local, TEXT("lpt1:"));
    STRCPY(UseInfo->ui2_remote, TEXT("\\\\prt21088\\laserii"));
    TestUseAdd(WorkBuffer, ERROR_ALREADY_ASSIGNED);

    //
    // Delete LPT1 USE_LOTS_OF_FORCE, should succeed
    //
    TestUseDel(
        TEXT("prn:"),
        USE_LOTS_OF_FORCE,
        NERR_Success
        );

    //
    // Bad device type
    //
    STRCPY(UseInfo->ui2_local, TEXT(""));
    STRCPY(UseInfo->ui2_remote, TEXT("\\\\ritaw2\\public"));
    UseInfo->ui2_asg_type = 12345678;
    TestUseAdd(WorkBuffer, NERR_BadAsgType);

    TestUseDel(
        TEXT("S:"),
        USE_LOTS_OF_FORCE,
        NERR_Success
        );


    TestUseDel(
        TEXT("U:"),
        USE_LOTS_OF_FORCE,
        NERR_Success
        );
}

VOID
TestUseAdd(
    IN  LPBYTE Buffer,
    IN  DWORD ExpectedStatus
    )
{
    NET_API_STATUS status;
    DWORD ErrorParameter;

    status = NetUseAdd(
                NULL,
                2,
                Buffer,
                &ErrorParameter
                );


    printf("NetUseAdd %-5" FORMAT_STR "%-25" FORMAT_STR, ((PUSE_INFO_2) Buffer)->ui2_local,
                               ((PUSE_INFO_2) Buffer)->ui2_remote);

    if (status != ExpectedStatus) {
        printf("FAILED: Got %lu, expected %lu\n", status, ExpectedStatus);
    }
    else {
        printf("OK: Got expected status %lu\n", status);
    }

    if (status == ERROR_INVALID_PARAMETER) {
        printf("NetUseAdd parameter %lu is cause of ERROR_INVALID_PARAMETER\n",
               ErrorParameter);
    }
}


VOID
TestUseDel(
    IN  LPTSTR UseName,
    IN  DWORD ForceLevel,
    IN  DWORD ExpectedStatus
    )
{
    NET_API_STATUS status;

    PWCHAR Force[3] = {
        L"NOFORCE",
        L"FORCE",
        L"LOTS_OF_FORCE"
        };


    printf("NetUseDel %-17" FORMAT_STR "%-13" FORMAT_STR, UseName, Force[ForceLevel]);

    status = NetUseDel(
                 NULL,
                 UseName,
                 ForceLevel
                 );

    if (status != ExpectedStatus) {
        printf("FAILED: Got %lu, expected %lu\n", status, ExpectedStatus);
    }
    else {
        printf("OK: Got expected status %lu\n", status);
    }
}


VOID
TestUseGetInfo(
    LPTSTR UseName,
    DWORD ExpectedStatus
    )
{

    NET_API_STATUS status;
    PUSE_INFO_2 UseInfo;

    printf("NetUseGetInfo %-27" FORMAT_STR, UseName);

    status = NetUseGetInfo(
                 NULL,
                 UseName,
                 2,
                 (LPBYTE *) &UseInfo
                 );

    if (status != ExpectedStatus) {
        printf("FAILED: Got %lu, expected %lu\n", status, ExpectedStatus);
    }
    else {
        printf("OK: Got expected status %lu\n", status);
    }

    if (status == NERR_Success) {
        PrintUseInfo2(UseInfo);
        NetApiBufferFree(UseInfo);
    }
}


VOID
TestUseEnum(
    IN DWORD PreferedMaximumLength,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )
{
    DWORD i;
    NET_API_STATUS status;
    DWORD EntriesRead,
         TotalEntries;

    PUSE_INFO_1 UseInfo, saveptr;

    if (ARGUMENT_PRESENT(ResumeHandle)) {
       printf("\nInput ResumeHandle=x%08lx\n", *ResumeHandle);
    }
    status = NetUseEnum(
                 NULL,
                 1,
                 (LPBYTE *) &UseInfo,
                 PreferedMaximumLength,
                 &EntriesRead,
                 &TotalEntries,
                 ResumeHandle
                 );

    saveptr = UseInfo;

    if (status != NERR_Success && status != ERROR_MORE_DATA) {
        printf("NetUseEnum FAILED %lu\n", status);
    }
    else {
        printf("Return code from NetUseEnum %lu\n", status);

        printf("EntriesRead=%lu, TotalEntries=%lu\n",
               EntriesRead, TotalEntries);

        if (ARGUMENT_PRESENT(ResumeHandle)) {
           printf("Output ResumeHandle=x%08lx\n", *ResumeHandle);
        }

        for (i = 0; i < EntriesRead; i++, UseInfo++) {
            PrintUseInfo1(UseInfo);
        }

        //
        // Free buffer allocated for us.
        //
        NetApiBufferFree(saveptr);
    }

}

VOID
PrintUseInfo1(
    PUSE_INFO_1 UseInfo
    )
{

    switch(UseInfo->ui1_status) {

        case USE_OK:
            printf("OK           ");
            break;

        case USE_PAUSED:
            printf("Paused       ");
            break;

        case USE_SESSLOST:
            printf("Disconnected ");
            break;

        case USE_NETERR:
            printf("Net error    ");
            break;

        case USE_CONN:
            printf("Connecting   ");
            break;

        case USE_RECONN:
            printf("Reconnecting ");
            break;

        default:
            printf("Unknown      ");
    }

    printf(" %-7" FORMAT_STR "%-25" FORMAT_STR, UseInfo->ui1_local,
           UseInfo->ui1_remote);
    printf("usecount=%lu, refcount=%lu\n",
           UseInfo->ui1_usecount, UseInfo->ui1_refcount);

}

VOID
PrintUseInfo2(
    PUSE_INFO_2 UseInfo
    )
{

    switch(UseInfo->ui2_status) {

        case USE_OK:
            printf("OK           ");
            break;

        case USE_PAUSED:
            printf("Paused       ");
            break;

        case USE_SESSLOST:
            printf("Disconnected ");
            break;

        case USE_NETERR:
            printf("Net error    ");
            break;

        case USE_CONN:
            printf("Connecting   ");
            break;

        case USE_RECONN:
            printf("Reconnecting ");
            break;

        default:
            printf("Unknown      ");
    }

    printf(" %-7" FORMAT_STR "%-" FORMAT_STR, UseInfo->ui2_local,
           UseInfo->ui2_remote);

    printf("\n   %-25" FORMAT_STR "%-" FORMAT_STR, UseInfo->ui2_username,
           UseInfo->ui2_domainname);

    printf("\n   usecount=%02lu, refcount=%02lu\n",
           UseInfo->ui2_usecount, UseInfo->ui2_refcount);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\wstsend.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wstsend.c

Abstract:

    Test program for the NetMessageBufferSend APIs.  Run this test after
    starting the Workstation service.

        wstsend <recipient> <message>

Author:

    Rita Wong (ritaw) 12-Aug-1991

Revision History:

--*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <winerror.h>
#include <windef.h>              // Win32 type definitions
#include <winbase.h>             // Win32 base API prototypes

#include <lm.h>                  // LAN Man definitions

#include <tstring.h>


VOID
main(
    int argc,
    char *argv[]
    )
{
    DWORD i;
    NET_API_STATUS status;
#ifdef UNICODE
    LPWSTR ToName;
    LPWSTR Message;
#else
    LPSTR ToName;
    LPSTR Message;
#endif

    if (argc != 3) {
        printf("Usage: wstsend <recipient> <message>.\n");
        return;
    }

#ifdef UNICODE
    ToName = NetpAllocWStrFromStr(_strupr(argv[1]));

    if (ToName == NULL) {
        printf("Could not convert the receipient name.\n");
        return;
    }

    Message = NetpAllocWStrFromStr(argv[2]);

    if (ToName == NULL) {
        printf("Could not convert the message.\n");
        NetApiBufferFree(ToName);
        return;
    }
#else
    ToName = _strupr(argv[1]);
    Message = argv[2];
#endif


    if ((status = NetMessageBufferSend(
                     NULL,
                     ToName,             // To
                     NULL,
                     Message,            // Message to send
                     STRLEN(Message) * sizeof(TCHAR)
                     )) != NERR_Success) {

        printf("Failed in sending message to %s %lu\n", argv[1], status);
        printf("Message is %s\n", argv[2]);
    }
    else {
        printf("Message sent successfully\n");
    }

#ifdef UNICODE
    NetApiBufferFree(ToName);
    NetApiBufferFree(Message);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\wstsenum.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wstsend.c

Abstract:

    Test program for the NetServerEnum API.  Run this test after
    starting the Workstation service.

        wstenum [domain]

Author:

    Rita Wong (ritaw) 24-Oct-1991

Revision History:

--*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <winerror.h>
#include <windef.h>              // Win32 type definitions
#include <winbase.h>             // Win32 base API prototypes

#include <lm.h>                  // LAN Man definitions
#include <lmserver.h>

#include <tstring.h>
#include <netdebug.h>            // NetpDbgDisplay routines.
#include <dlserver.h>

#define FIXED_WIDTH_STRING "%-30ws: "
#define INDENT "  "

VOID
DisplayServerInfo(
    IN DWORD Level,
    IN LPVOID Info
    );

VOID
DisplayDword(
    IN LPTSTR Tag,
    IN DWORD Value
    );

VOID
DisplayBool(
    IN LPTSTR Tag,
    IN BOOL Value
    );

VOID
TestServerEnum(
    IN LPTSTR DomainName OPTIONAL,
    IN DWORD PreferedMaximumLength,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );



VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    LPTSTR DomainName = NULL;

    if (argc > 2) {
        printf("Usage: wstenum [domain].\n");
        return;
    }

    if (argc == 2) {
#ifdef UNICODE
        DomainName = NetpAllocWStrFromStr(argv[1]);
#else
        DomainName = argv[1];
#endif
    }

    //
    // Enumerate all servers
    //
    TestServerEnum(DomainName, MAXULONG, NULL);

#ifdef UNICODE
    NetApiBufferFree(DomainName);
#endif
}





VOID
TestServerEnum(
    IN LPTSTR DomainName OPTIONAL,
    IN DWORD PreferedMaximumLength,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )
{
    DWORD i;
    NET_API_STATUS status;
    DWORD EntriesRead,
         TotalEntries;

    PSERVER_INFO_101 ServerInfo, saveptr;


    if (ARGUMENT_PRESENT(ResumeHandle)) {
       printf("\nInput ResumeHandle=x%08lx\n", *ResumeHandle);
    }

    status = NetServerEnum(
                 NULL,
                 101,
                 (LPBYTE *) &ServerInfo,
                 PreferedMaximumLength,
                 &EntriesRead,
                 &TotalEntries,
                 SV_TYPE_ALL,
                 DomainName,
                 ResumeHandle
                 );

    saveptr = ServerInfo;

    if (status != NERR_Success && status != ERROR_MORE_DATA) {
        printf("NetServerEnum FAILED %lu\n", status);
    }
    else {
        printf("Return code from NetServerEnum %lu\n", status);

        printf("EntriesRead=%lu, TotalEntries=%lu\n",
               EntriesRead, TotalEntries);

        if (ARGUMENT_PRESENT(ResumeHandle)) {
           printf("Output ResumeHandle=x%08lx\n", *ResumeHandle);
        }

        for (i = 0; i < EntriesRead; i++, ServerInfo++) {
            DisplayServerInfo(101, ServerInfo);
        }

        //
        // Free buffer allocated for us.
        //
        NetApiBufferFree(saveptr);
    }
}
VOID
DisplayTag(
    IN LPTSTR Tag
    )
{
    printf(INDENT FIXED_WIDTH_STRING, Tag);

} // NetpDbgDisplayTag
VOID
DisplayString(
    IN LPTSTR Tag,
    IN LPTSTR Value
    )
{
    DisplayTag( Tag );
    if (Value != NULL) {
        printf(FORMAT_LPTSTR "\n", Value);
    } else {
        printf("(none)\n");
    }

} // NetpDbgDisplayString

VOID
DisplayDwordHex(
    IN LPTSTR Tag,
    IN DWORD Value
    )
{
    DisplayTag( Tag );
    printf(FORMAT_HEX_DWORD, Value);
    printf("\n");

} // NetpDbgDisplayDwordHex

DBGSTATIC VOID
DisplayServerType(
    IN DWORD Type
    )
{
    // Longest name is "DOMAIN_BAKCTRL" (14 chars)
    TCHAR str[(14+2)*11];  // 14 chars per name, 2 spaces, for 11 names.
    str[0] = '\0';

#define DO(name)                     \
    if (Type & SV_TYPE_ ## name) {   \
        (void) STRCAT(str, # name);  \
        (void) STRCAT(str, L"  ");    \
        Type &= ~(SV_TYPE_ ## name); \
    }

    NetpAssert(Type != 0);
    DO(WORKSTATION);
    DO(SERVER);
    DO(SQLSERVER);
    DO(DOMAIN_CTRL);
    DO(DOMAIN_BAKCTRL);
    DO(TIME_SOURCE);
    DO(AFP);
    DO(NOVELL);
    DO(DOMAIN_MEMBER);
    DO(PRINTQ_SERVER);
    DO(DIALIN_SERVER);

    DisplayString(L"server type", str);
    if (Type != 0) {
        DisplayDwordHex( L"UNEXPECTED TYPE BIT(S)", Type );
    }

} // DisplayServerType
VOID
DisplayLanManVersion(
    IN DWORD MajorVersion,
    IN DWORD MinorVersion
    )
{
    DisplayTag( L"LanMan version" );
    printf(FORMAT_DWORD "." FORMAT_DWORD "\n",
            (DWORD) (MajorVersion & (MAJOR_VERSION_MASK)),
            (DWORD) (MinorVersion) );

} // DisplayLanManVersion

DBGSTATIC VOID
DisplayDisconnectTime(
    IN LONG DiscTime
    )
{
    DisplayTag(L"Idle session time (min)" );
    if (DiscTime == SV_NODISC) {
        printf("infinite\n" );
    } else {
        printf(FORMAT_LONG "\n", DiscTime );
    }
} // NetpDbgDisplayDisconnectTime

DBGSTATIC VOID
DisplayLicenses(
    IN DWORD MajorVersion,
    IN DWORD Licenses
    )
{
    UNREFERENCED_PARAMETER( MajorVersion );

    DisplayDword(L"Licenses (NOT users)", Licenses );
} // NetpDbgDisplayLicenses

VOID
DisplayPlatformId(
    IN DWORD Value
    )
{
    LPTSTR String;

    switch (Value) {
    case PLATFORM_ID_DOS : String =L"DOS";     break;
    case PLATFORM_ID_OS2 : String =L"OS2";     break;
    case PLATFORM_ID_NT  : String =L"NT";      break;
    default              : String =L"unknown"; break;
    }

    DisplayString(L"Platform ID", String );
}
VOID
DisplayBool(
    IN LPTSTR Tag,
    IN BOOL Value
    )
{
    DisplayTag( Tag );
    printf(Value ? "Yes" : "No");
    printf("\n");

}

VOID
DisplayDword(
    IN LPTSTR Tag,
    IN DWORD Value
    )
{
    DisplayTag( Tag );
    printf(FORMAT_DWORD, Value);
    printf("\n");

} // DbgDisplayDword
VOID
DisplayServerInfo(
    IN DWORD Level,
    IN LPVOID Info
    )
{
    printf("server info (level " FORMAT_DWORD ") at "
                FORMAT_LPVOID ":\n", Level, (LPVOID) Info);
    NetpAssert(Info != NULL);

    switch (Level) {
    case 0 :
        {
            LPSERVER_INFO_0 psv0 = Info;
            DisplayString(L"name", psv0->sv0_name);
        }
        break;

    case 1 :
        {
            LPSERVER_INFO_1 psv1 = Info;
            DisplayString(L"name", psv1->sv1_name);
            DisplayLanManVersion(
                        psv1->sv1_version_major,
                        psv1->sv1_version_minor);
            DisplayServerType( psv1->sv1_type );
            DisplayString(L"comment", psv1->sv1_comment);
        }
        break;

    case 2 :
        {
            LPSERVER_INFO_2 psv2 = Info;
            DisplayString(L"name", psv2->sv2_name);
            DisplayLanManVersion(
                        psv2->sv2_version_major,
                        psv2->sv2_version_minor);
            DisplayServerType( psv2->sv2_type );
            DisplayString(L"comment", psv2->sv2_comment);
            DisplayDword(L"ulist_mtime", psv2->sv2_ulist_mtime);
            DisplayDword(L"glist_mtime", psv2->sv2_glist_mtime);
            DisplayDword(L"alist_mtime", psv2->sv2_alist_mtime);
            DisplayDword(L"users", psv2->sv2_users);
            DisplayDisconnectTime( psv2->sv2_disc);
            DisplayString(L"alerts", psv2->sv2_alerts);
            DisplayDword(L"security", psv2->sv2_security);
            DisplayDword(L"auditing", psv2->sv2_auditing);
            DisplayDword(L"numadmin", psv2->sv2_numadmin);
            DisplayDword(L"lanmask", psv2->sv2_lanmask);
            DisplayDword(L"hidden", psv2->sv2_hidden);
            DisplayDword(L"announce", psv2->sv2_announce);
            DisplayDword(L"anndelta", psv2->sv2_anndelta);
            DisplayString(L"guestacct", psv2->sv2_guestacct);
            DisplayLicenses(
                    psv2->sv2_version_major,
                    psv2->sv2_licenses );
            DisplayString(L"userpath", psv2->sv2_userpath);
            DisplayDword(L"chdevs", psv2->sv2_chdevs);
            DisplayDword(L"chdevq", psv2->sv2_chdevq);
            DisplayDword(L"chdevjobs", psv2->sv2_chdevjobs);
            DisplayDword(L"connections", psv2->sv2_connections);
            DisplayDword(L"shares", psv2->sv2_shares);
            DisplayDword(L"openfiles", psv2->sv2_openfiles);
            DisplayDword(L"sessopens", psv2->sv2_sessopens);
            DisplayDword(L"sessvcs", psv2->sv2_sessvcs);
            DisplayDword(L"sessreqs", psv2->sv2_sessreqs);
            DisplayDword(L"opensearch", psv2->sv2_opensearch);
            DisplayDword(L"activelocks", psv2->sv2_activelocks);
            DisplayDword(L"numreqbuf", psv2->sv2_numreqbuf);
            DisplayDword(L"sizreqbuf", psv2->sv2_sizreqbuf);
            DisplayDword(L"numbigbuf", psv2->sv2_numbigbuf);
            DisplayDword(L"numfiletasks", psv2->sv2_numfiletasks);
            DisplayDword(L"alertsched", psv2->sv2_alertsched);
            DisplayDword(L"erroralert", psv2->sv2_erroralert);
            DisplayDword(L"logonalert", psv2->sv2_logonalert);
            DisplayDword(L"accessalert", psv2->sv2_accessalert);
            DisplayDword(L"diskalert", psv2->sv2_diskalert);
            DisplayDword(L"netioalert", psv2->sv2_netioalert);
            DisplayDword(L"maxauditsz", psv2->sv2_maxauditsz);
            DisplayString(L"srvheuristics", psv2->sv2_srvheuristics);
        }
        break;

    case 3 :
        {
            LPSERVER_INFO_3 psv3 = Info;
            DisplayString(L"name", psv3->sv3_name);
            DisplayLanManVersion(
                        psv3->sv3_version_major,
                        psv3->sv3_version_minor);
            DisplayServerType( psv3->sv3_type );
            DisplayString(L"comment", psv3->sv3_comment);
            DisplayDword(L"ulist_mtime", psv3->sv3_ulist_mtime);
            DisplayDword(L"glist_mtime", psv3->sv3_glist_mtime);
            DisplayDword(L"alist_mtime", psv3->sv3_alist_mtime);
            DisplayDword(L"users", psv3->sv3_users);
            DisplayDisconnectTime( psv3->sv3_disc );
            DisplayString(L"alerts", psv3->sv3_alerts);
            DisplayDword(L"security", psv3->sv3_security);
            DisplayDword(L"auditing", psv3->sv3_auditing);
            DisplayDword(L"numadmin", psv3->sv3_numadmin);
            DisplayDword(L"lanmask", psv3->sv3_lanmask);
            DisplayDword(L"hidden", psv3->sv3_hidden);
            DisplayDword(L"announce", psv3->sv3_announce);
            DisplayDword(L"anndelta", psv3->sv3_anndelta);
            DisplayString(L"guestacct", psv3->sv3_guestacct);
            DisplayLicenses(
                    psv3->sv3_version_major,
                    psv3->sv3_licenses );
            DisplayString(L"userpath", psv3->sv3_userpath);
            DisplayDword(L"chdevs", psv3->sv3_chdevs);
            DisplayDword(L"chdevq", psv3->sv3_chdevq);
            DisplayDword(L"chdevjobs", psv3->sv3_chdevjobs);
            DisplayDword(L"connections", psv3->sv3_connections);
            DisplayDword(L"shares", psv3->sv3_shares);
            DisplayDword(L"openfiles", psv3->sv3_openfiles);
            DisplayDword(L"sessopens", psv3->sv3_sessopens);
            DisplayDword(L"sessvcs", psv3->sv3_sessvcs);
            DisplayDword(L"sessreqs", psv3->sv3_sessreqs);
            DisplayDword(L"opensearch", psv3->sv3_opensearch);
            DisplayDword(L"activelocks", psv3->sv3_activelocks);
            DisplayDword(L"numreqbuf", psv3->sv3_numreqbuf);
            DisplayDword(L"sizreqbuf", psv3->sv3_sizreqbuf);
            DisplayDword(L"numbigbuf", psv3->sv3_numbigbuf);
            DisplayDword(L"numfiletasks", psv3->sv3_numfiletasks);
            DisplayDword(L"alertsched", psv3->sv3_alertsched);
            DisplayDword(L"erroralert", psv3->sv3_erroralert);
            DisplayDword(L"logonalert", psv3->sv3_logonalert);
            DisplayDword(L"accessalert", psv3->sv3_accessalert);
            DisplayDword(L"diskalert", psv3->sv3_diskalert);
            DisplayDword(L"netioalert", psv3->sv3_netioalert);
            DisplayDword(L"maxauditsz", psv3->sv3_maxauditsz);
            DisplayString(L"srvheuristics", psv3->sv3_srvheuristics);
            DisplayDword(L"auditedevents", psv3->sv3_auditedevents);
            DisplayDword(L"autoprofile", psv3->sv3_autoprofile);
            DisplayString(L"autopath", psv3->sv3_autopath);
        }
        break;

    case 100 :
        {
            LPSERVER_INFO_100 psv100 = Info;
            DisplayPlatformId( psv100->sv100_platform_id );
            DisplayString(L"Server Name", psv100->sv100_name);
        }
        break;

    case 101 :
        {
            LPSERVER_INFO_101 psv101 = Info;
            DisplayPlatformId( psv101->sv101_platform_id );
            DisplayString(L"Server Name", psv101->sv101_name);
            DisplayLanManVersion(
                        psv101->sv101_version_major,
                        psv101->sv101_version_minor);
            DisplayServerType( psv101->sv101_type );
            DisplayString(L"Server Comment", psv101->sv101_comment);
        }
        break;

    case 102 :
        {
            LPSERVER_INFO_102 psv102 = Info;
            DisplayPlatformId( psv102->sv102_platform_id );
            DisplayString(L"Server Name", psv102->sv102_name);
            DisplayLanManVersion(
                        psv102->sv102_version_major,
                        psv102->sv102_version_minor );
            DisplayServerType( psv102->sv102_type );
            DisplayString(L"Server Comment", psv102->sv102_comment );
            DisplayDword(L"users", psv102->sv102_users );
            DisplayBool(L"Server hidden", psv102->sv102_hidden );
            DisplayDword(L"announce", psv102->sv102_announce );
            DisplayDword(L"announce delta", psv102->sv102_anndelta );
            DisplayLicenses(
                    psv102->sv102_version_major,
                    psv102->sv102_licenses );
            DisplayString(L"user path", psv102->sv102_userpath );
        }
        break;

    case 402 :
        {
            LPSERVER_INFO_402 psv402 = Info;
            DisplayDword(L"ulist mtime", psv402->sv402_ulist_mtime);
            DisplayDword(L"glist mtime", psv402->sv402_glist_mtime);
            DisplayDword(L"alist mtime", psv402->sv402_alist_mtime);
            DisplayString(L"alerts", psv402->sv402_alerts);
            DisplayDword(L"security", psv402->sv402_security);
            DisplayDword(L"numadmin", psv402->sv402_numadmin);
            DisplayDwordHex(L"lanmask", psv402->sv402_lanmask);
            DisplayString(L"guestacct", psv402->sv402_guestacct);
            DisplayDword(L"chdevs", psv402->sv402_chdevs);
            DisplayDword(L"chdevq", psv402->sv402_chdevq);
            DisplayDword(L"chdevjobs", psv402->sv402_chdevjobs);
            DisplayDword(L"connections", psv402->sv402_connections);
            DisplayDword(L"shares", psv402->sv402_shares);
            DisplayDword(L"openfiles", psv402->sv402_openfiles);
            DisplayDword(L"sessopens", psv402->sv402_sessopens);
            DisplayDword(L"sessvcs", psv402->sv402_sessvcs);
            DisplayDword(L"sessreqs", psv402->sv402_sessreqs);
            DisplayDword(L"opensearch", psv402->sv402_opensearch);
            DisplayDword(L"activelocks", psv402->sv402_activelocks);
            DisplayDword(L"numreqbuf", psv402->sv402_numreqbuf);
            DisplayDword(L"sizreqbuf", psv402->sv402_sizreqbuf);
            DisplayDword(L"numbigbuf", psv402->sv402_numbigbuf);
            DisplayDword(L"numfiletasks", psv402->sv402_numfiletasks);
            DisplayDword(L"alertsched", psv402->sv402_alertsched);
            DisplayDword(L"erroralert", psv402->sv402_erroralert);
            DisplayDword(L"logonalert", psv402->sv402_logonalert);
            DisplayDword(L"diskalert", psv402->sv402_diskalert);
            DisplayDword(L"accessalert", psv402->sv402_accessalert);
            DisplayDword(L"diskalert", psv402->sv402_diskalert);
            DisplayDword(L"netioalert", psv402->sv402_netioalert);
            DisplayDword(L"maxauditsz", psv402->sv402_maxauditsz);
            DisplayString(L"srvheuristics", psv402->sv402_srvheuristics);
        }
        break;

    case 403 :
        {
            LPSERVER_INFO_403 psv403 = Info;
            DisplayDword(L"ulist mtime", psv403->sv403_ulist_mtime);
            DisplayDword(L"glist mtime", psv403->sv403_glist_mtime);
            DisplayDword(L"alist mtime", psv403->sv403_alist_mtime);
            DisplayString(L"alerts", psv403->sv403_alerts);
            DisplayDword(L"security", psv403->sv403_security);
            DisplayDword(L"numadmin", psv403->sv403_numadmin);
            DisplayDwordHex(L"lanmask", psv403->sv403_lanmask);
            DisplayString(L"guestacct", psv403->sv403_guestacct);
            DisplayDword(L"chdevs", psv403->sv403_chdevs);
            DisplayDword(L"chdevq", psv403->sv403_chdevq);
            DisplayDword(L"chdevjobs", psv403->sv403_chdevjobs);
            DisplayDword(L"connections", psv403->sv403_connections);
            DisplayDword(L"shares", psv403->sv403_shares);
            DisplayDword(L"openfiles", psv403->sv403_openfiles);
            DisplayDword(L"sessopens", psv403->sv403_sessopens);
            DisplayDword(L"sessvcs", psv403->sv403_sessvcs);
            DisplayDword(L"sessreqs", psv403->sv403_sessreqs);
            DisplayDword(L"opensearch", psv403->sv403_opensearch);
            DisplayDword(L"activelocks", psv403->sv403_activelocks);
            DisplayDword(L"numreqbuf", psv403->sv403_numreqbuf);
            DisplayDword(L"sizreqbuf", psv403->sv403_sizreqbuf);
            DisplayDword(L"numbigbuf", psv403->sv403_numbigbuf);
            DisplayDword(L"numfiletasks", psv403->sv403_numfiletasks);
            DisplayDword(L"alertsched", psv403->sv403_alertsched);
            DisplayDword(L"erroralert", psv403->sv403_erroralert);
            DisplayDword(L"logonalert", psv403->sv403_logonalert);
            DisplayDword(L"diskalert", psv403->sv403_diskalert);
            DisplayDword(L"accessalert", psv403->sv403_accessalert);
            DisplayDword(L"diskalert", psv403->sv403_diskalert);
            DisplayDword(L"netioalert", psv403->sv403_netioalert);
            DisplayDword(L"maxauditsz", psv403->sv403_maxauditsz);
            DisplayString(L"srvheuristics", psv403->sv403_srvheuristics);
            DisplayDword(L"auditedevents", psv403->sv403_auditedevents);
            DisplayDword(L"autoprofile", psv403->sv403_autoprofile);
            DisplayString(L"autopath", psv403->sv403_autopath);
        }
        break;

    // RpcXlate doesn't need support for info levels 502, 503, 599.
    // Feel free to add them here if you need them.

    default :
        NetpAssert(FALSE);
    }

} // DisplayServerInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\wstinv.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wstinv.c

Abstract:

    This module tests invalid parameters to NetUse APIs.

Author:

    Rita Wong (ritaw) 12-Mar-1991

Revision History:

--*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <winerror.h>
#include <windef.h>              // Win32 type definitions
#include <winbase.h>             // Win32 base API prototypes

#include <lm.h>                  // LAN Man definitions
#include <netdebug.h>            // NetpDbgDisplayWksta()

#include <tstring.h>


VOID
WsTestUse(
    VOID
    );

VOID
TestUseAdd(
    IN  LPBYTE Buffer,
    IN  DWORD ExpectedStatus
    );

VOID
TestUseDel(
    IN  LPTSTR UseName,
    IN  DWORD ForceLevel,
    IN  DWORD ExpectedStatus
    );

VOID
TestUseEnum(
    DWORD PreferedMaximumLength,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

VOID
TestUseGetInfo(
    LPTSTR UseName,
    DWORD ExpectedStatus
    );

VOID
PrintUseInfo(
    PUSE_INFO_1 UseInfo
    );


VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    WsTestUse();
}


VOID
WsTestUse(
    VOID
    )
{
    CHAR Buffer[1024];
    PUSE_INFO_2 UseInfo = (PUSE_INFO_2) Buffer;
    DWORD ResumeHandle = 0;

    DWORD i;


    //
    // Initialize string pointers.  Local device points to the bottom
    // of Info 2 structure; Shared resource points to the middle of
    // buffer (away from everything so there's no chance of overwriting
    // or being overwritten.
    //
    UseInfo->ui2_local = (LPTSTR) ((DWORD) UseInfo + sizeof(USE_INFO_2));

    UseInfo->ui2_remote = (LPTSTR) &Buffer[601];

    UseInfo->ui2_password = NULL;
    UseInfo->ui2_username = NULL;
    UseInfo->ui2_domainname = NULL;

    UseInfo->ui2_asg_type = USE_DISKDEV;


    //
    // Add \\ritaw2\public
    //
    UseInfo->ui2_local = NULL;
    STRCPY(UseInfo->ui2_remote, L"\\\\ritaw2\\public");
    TestUseAdd(Buffer, NERR_Success);


    UseInfo->ui2_local = (LPTSTR) ((DWORD) UseInfo + sizeof(USE_INFO_2));

    //
    // Add &: \\ritaw2\public
    //
    STRCPY(UseInfo->ui2_local, L"&:");
    TestUseAdd(Buffer, ERROR_INVALID_PARAMETER);

    //
    // Add 5: \\ritaw2\public
    //
    STRCPY(UseInfo->ui2_local, L"5:");
    TestUseAdd(Buffer, ERROR_INVALID_PARAMETER);

    //
    // Add x: \\ritaw2\public\tmp
    //
    STRCPY(UseInfo->ui2_local, L"x:");
    STRCPY(UseInfo->ui2_remote, L"\\\\ritaw2\\public\\tmp");
    TestUseAdd(Buffer, ERROR_INVALID_PARAMETER);

    //
    // Add x: \\\
    //
    STRCPY(UseInfo->ui2_local, L"x:");
    STRCPY(UseInfo->ui2_remote, L"\\\\\\");
    TestUseAdd(Buffer, ERROR_INVALID_PARAMETER);

    //
    // Add *: \\ritaw2\testdir
    //
    STRCPY(UseInfo->ui2_local, L"*:");
    STRCPY(UseInfo->ui2_remote, L"\\\\ritaw2\\testdir");
    TestUseAdd(Buffer, ERROR_INVALID_PARAMETER);

    //
    // Get info
    //
    TestUseGetInfo(L"$:", NERR_UseNotFound);

    TestUseGetInfo(L"", NERR_UseNotFound);

    TestUseGetInfo(NULL, ERROR_INVALID_ADDRESS);

    TestUseGetInfo(L"\\\\ritaw2\\public\\tmp", NERR_UseNotFound);

    TestUseGetInfo(L"\\\\\\", NERR_UseNotFound);


    //
    // Delete %: USE_NOFORCE.
    //
    TestUseDel(
        L"%:",
        USE_NOFORCE,
        NERR_UseNotFound
        );


    //
    // Delete \\ritaw2\public with invalid force level.
    //
    TestUseDel(
        L"\\\\ritaw2\\public",
        999,
        ERROR_INVALID_PARAMETER
        );

    //
    // Delete \\ritaw2\public USE_FORCE.
    //
    TestUseDel(
        L"\\\\ritaw2\\public",
        USE_FORCE,
        NERR_Success
        );


    //
    // Add prn: \\sparkle\laserjet
    //
    UseInfo->ui2_asg_type = USE_SPOOLDEV;

    STRCPY(UseInfo->ui2_local, L"prn");
    STRCPY(UseInfo->ui2_remote, L"\\\\sparkle\\laserjet");
    TestUseAdd(Buffer, NERR_Success);

    //
    // Add aux: \\sparkle\laserjet
    //
    UseInfo->ui2_asg_type = USE_CHARDEV;

    STRCPY(UseInfo->ui2_local, L"aux");
    TestUseAdd(Buffer, ERROR_BAD_DEV_TYPE);

    //
    // Add lpt1: \\ritaw2\laser, should get ERROR_ALREADY_ASSIGNED because prn:
    // is converted to lpt1.
    //
    UseInfo->ui2_asg_type = USE_SPOOLDEV;

    STRCPY(UseInfo->ui2_local, L"lpt1:");
    STRCPY(UseInfo->ui2_remote, L"\\\\ritaw2\\printer");
    TestUseAdd(Buffer, ERROR_ALREADY_ASSIGNED);

    //
    // Delete LPT1 USE_LOTS_OF_FORCE, should succeed
    //
    TestUseDel(
        L"prn:",
        USE_LOTS_OF_FORCE,
        NERR_Success
        );

    //
    // Bad device type
    //
    STRCPY(UseInfo->ui2_local, L"");
    STRCPY(UseInfo->ui2_remote, L"\\\\ritaw2\\public");
    UseInfo->ui2_asg_type = 12345678;
    TestUseAdd(Buffer, NERR_BadAsgType);

}

VOID
TestUseAdd(
    IN  LPBYTE Buffer,
    IN  DWORD ExpectedStatus
    )
{
    NET_API_STATUS status;
    DWORD ErrorParameter;

    status = NetUseAdd(
                NULL,
                2,
                Buffer,
                &ErrorParameter
                );

    printf("NetUseAdd %-5ws %-25ws ", ((PUSE_INFO_2) Buffer)->ui2_local,
                               ((PUSE_INFO_2) Buffer)->ui2_remote);

    if (status != ExpectedStatus) {
        printf("FAILED: Got %lu, expected %lu\n", status, ExpectedStatus);
    }
    else {
        printf("OK: Got expected status %lu\n", status);
    }

    if (status == ERROR_INVALID_PARAMETER) {
        printf("NetUseAdd parameter %lu is cause of ERROR_INVALID_PARAMETER\n",
               ErrorParameter);
    }
}


VOID
TestUseDel(
    IN  LPTSTR UseName,
    IN  DWORD ForceLevel,
    IN  DWORD ExpectedStatus
    )
{
    NET_API_STATUS status;
    DWORD Level;

    PWCHAR Force[4] = {
        L"NOFORCE",
        L"FORCE",
        L"LOTS_OF_FORCE",
        L"INVALID FORCE"
        };


    if (ForceLevel > 2) {
        Level = 3;
    }
    else {
        Level = ForceLevel;
    }

    printf("NetUseDel %-17ws %-13ws ", UseName, Force[Level]);

    status = NetUseDel(
                 NULL,
                 UseName,
                 ForceLevel
                 );

    if (status != ExpectedStatus) {
        printf("FAILED: Got %lu, expected %lu\n", status, ExpectedStatus);
    }
    else {
        printf("OK: Got expected status %lu\n", status);
    }
}


VOID
TestUseGetInfo(
    LPTSTR UseName,
    DWORD ExpectedStatus
    )
{

    NET_API_STATUS status;
    PUSE_INFO_1 UseInfo;

    printf("NetUseGetInfo %-27ws ", UseName);

    status = NetUseGetInfo(
                 NULL,
                 UseName,
                 2,
                 (LPBYTE *) &UseInfo
                 );

    if (status != ExpectedStatus) {
        printf("FAILED: Got %lu, expected %lu\n", status, ExpectedStatus);
    }
    else {
        printf("OK: Got expected status %lu\n", status);
    }

    if (status == NERR_Success) {
        PrintUseInfo(UseInfo);
        NetApiBufferFree(UseInfo);
    }
}


VOID
TestUseEnum(
    IN DWORD PreferedMaximumLength,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )
{
    DWORD i;
    NET_API_STATUS status;
    DWORD EntriesRead,
         TotalEntries;

    PUSE_INFO_1 UseInfo, saveptr;

    if (ARGUMENT_PRESENT(ResumeHandle)) {
       printf("\nInput ResumeHandle=x%08lx\n", *ResumeHandle);
    }
    status = NetUseEnum(
                 NULL,
                 1,
                 (LPBYTE *) &UseInfo,
                 PreferedMaximumLength,
                 &EntriesRead,
                 &TotalEntries,
                 ResumeHandle
                 );

    saveptr = UseInfo;

    if (status != NERR_Success && status != ERROR_MORE_DATA) {
        printf("NetUseEnum FAILED %lu\n", status);
    }
    else {
        printf("Return code from NetUseEnum %lu\n", status);

        printf("EntriesRead=%lu, TotalEntries=%lu\n",
               EntriesRead, TotalEntries);

        if (ARGUMENT_PRESENT(ResumeHandle)) {
           printf("Output ResumeHandle=x%08lx\n", *ResumeHandle);
        }

        for (i = 0; i < EntriesRead; i++, UseInfo++) {
            PrintUseInfo(UseInfo);
        }

        //
        // Free buffer allocated for us.
        //
        NetApiBufferFree(saveptr);
    }

}


VOID
PrintUseInfo(
    PUSE_INFO_1 UseInfo
    )
{

    switch(UseInfo->ui1_status) {

        case USE_OK:
            printf("OK           ");
            break;

        case USE_PAUSED:
            printf("Paused       ");
            break;

        case USE_SESSLOST:
            printf("Disconnected ");
            break;

        case USE_NETERR:
            printf("Net error    ");
            break;

        case USE_CONN:
            printf("Connecting   ");
            break;

        case USE_RECONN:
            printf("Reconnecting ");
            break;

        default:
            printf("Unknown      ");
    }

    printf(" %-7ws %-25ws", UseInfo->ui1_local,
           UseInfo->ui1_remote);
    printf("usecount=%lu, refcount=%lu\n",
           UseInfo->ui1_usecount, UseInfo->ui1_refcount);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\wsclient.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsclient.h

Abstract:

    Private header file for the client end of the Workstation service
    modules.

Author:

    Rita Wong (ritaw) 10-May-1991

Revision History:

--*/

#include <nt.h>                  // DbgPrint prototype
#include <ntrtl.h>                  // DbgPrint
#include <nturtl.h>                 // Needed by winbase.h

#include <windef.h>                 // DWORD
#include <winbase.h>                // LocalFree

#include <rpc.h>                    // DataTypes and runtime APIs
#include <rpcutil.h>                // GENERIC_ENUM_STRUCT

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <lmremutl.h>               // SUPPORTS_RPC

#include <netlibnt.h>               // NetpNtStatusToApiStatus
#include <netdebug.h>               // NetpDbgPrint

#include <wkssvc.h>                 // generated by the MIDL complier
#include <wsnames.h>                // Service and interface names

//
// Debug trace level bits for turning on/off trace statements in the client
// end of the Workstation service
//

//
// Client stub trace output
//
#define WKSTA_DEBUG_CLIENTSTUBS    0x00000001

//
// Client RPC binding trace output
//
#define WKSTA_DEBUG_RPCBIND        0x00000002

//
// All debug flags on
//
#define WKSTA_DEBUG_ALL            0xFFFFFFFF


#if DBG

#define STATIC

extern DWORD WorkstationClientTrace;

#define DEBUG if (TRUE)

#define IF_DEBUG(Function) if (WorkstationClientTrace & WKSTA_DEBUG_ ## Function)

#else

#define STATIC static

#define DEBUG if (FALSE)

#define IF_DEBUG(Function) if (FALSE)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\client\wksstub.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    wksstub.c

Abstract:

    Client stubs of the Workstation service APIs.

Author:

    Rita Wong (ritaw) 10-May-1991

Environment:

    User Mode - Win32

Revision History:

    18-Jun-1991 JohnRo
        Remote NetUse APIs to downlevel servers.
    24-Jul-1991 JohnRo
        Use NET_REMOTE_TRY_RPC etc macros for NetUse APIs.
        Moved NetpIsServiceStarted() into NetLib.
    25-Jul-1991 JohnRo
        Quiet DLL stub debug output.
    19-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.  Use NetRpc.h for NetWksta APIs.
    07-Nov-1991 JohnRo
        RAID 4186: assert in RxNetShareAdd and other DLL stub problems.
    19-Nov-1991 JohnRo
        Make sure status is correct for APIs not supported on downlevel.
        Implement remote NetWkstaUserEnum().
    21-Jan-1991 rfirth
        Added NetWkstaStatisticsGet wrapper
    19-Apr-1993 JohnRo
        Fix NET_API_FUNCTION references.
--*/

#include "wsclient.h"
#undef IF_DEBUG                 // avoid wsclient.h vs. debuglib.h conflicts.
#include <debuglib.h>           // IF_DEBUG() (needed by netrpc.h).
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmsvc.h>
#include <rxuse.h>              // RxNetUse APIs.
#include <rxwksta.h>            // RxNetWksta and RxNetWkstaUser APIs.
#include <rap.h>                // Needed by rxserver.h
#include <rxserver.h>           // RxNetServerEnum API.
#include <netlib.h>             // NetpServiceIsStarted() (needed by netrpc.h).
#include <netrpc.h>             // NET_REMOTE macros.
#include <lmstats.h>
#include <netstats.h>           // NetWkstaStatisticsGet prototype
#include <rxstats.h>
#include <netsetup.h>
#include <crypt.h>
#include <rc4.h>
#include <md5.h>
#include <rpcasync.h>

#if(_WIN32_WINNT >= 0x0500)
#include "cscp.h"
#endif

STATIC
DWORD
WsMapRpcError(
    IN DWORD RpcError
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

#if DBG

DWORD WorkstationClientTrace = 0;

#endif  // DBG


NET_API_STATUS NET_API_FUNCTION
NetWkstaGetInfo(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    NET_API_STATUS status;

    if (bufptr == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *bufptr = NULL;           // Must be NULL so RPC knows to fill it in.

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrWkstaGetInfo(
                     servername,
                     level,
                     (LPWKSTA_INFO) bufptr
                     );

    NET_REMOTE_RPC_FAILED("NetWkstaGetInfo",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )

        //
        // Call downlevel version of the API.
        //
        status = RxNetWkstaGetInfo(
                     servername,
                     level,
                     bufptr
                     );

    NET_REMOTE_END

#if(_WIN32_WINNT >= 0x0500)
    if( *bufptr == NULL && servername != NULL &&
        CSCNetWkstaGetInfo( servername, level, bufptr ) == NO_ERROR ) {

        status = NO_ERROR;
    }
#endif

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetWkstaSetInfo(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaSetInfo.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the level of information.

    buf - Supplies a buffer which contains the information structure of fields
        to set.  The level denotes the structure in this buffer.

    parm_err - Returns the identifier to the invalid parameter in buf if this
        function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrWkstaSetInfo(
                     servername,
                     level,
                     (LPWKSTA_INFO) &buf,
                     parm_err
                     );

    NET_REMOTE_RPC_FAILED("NetWkstaSetInfo",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )

        //
        // Call downlevel version of the API.
        //
        status = RxNetWkstaSetInfo(
                servername,
                level,
                buf,
                parm_err
                );

    NET_REMOTE_END

    return status;
}



NET_API_STATUS NET_API_FUNCTION
NetWkstaUserEnum(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaUserEnum.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to the buffer which contains a sequence of
        information structure of the specified information level.  This
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.

    prefmaxlen - Supplies the number of bytes of information to return in the
        buffer.  If this value is MAXULONG, all available information will
        be returned.

    entriesread - Returns the number of entries read into the buffer.  This
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    totalentries - Returns the total number of entries available.  This value
        is only valid if the return code is NERR_Success or ERROR_MORE_DATA.

    resume_handle - Supplies a handle to resume the enumeration from where it
        left off the last time through.  Returns the resume handle if return
        code is ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    GENERIC_INFO_CONTAINER GenericInfoContainer;
    GENERIC_ENUM_STRUCT InfoStruct;

    if (bufptr == NULL || entriesread == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    try {
        *entriesread = 0;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return ERROR_INVALID_PARAMETER;
    }

    GenericInfoContainer.Buffer = NULL;
    GenericInfoContainer.EntriesRead = 0;

    InfoStruct.Container = &GenericInfoContainer;
    InfoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrWkstaUserEnum(
                     servername,
                     (LPWKSTA_USER_ENUM_STRUCT) &InfoStruct,
                     prefmaxlen,
                     totalentries,
                     resume_handle
                     );

        if (status == NERR_Success || status == ERROR_MORE_DATA) {
            *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
            *entriesread = GenericInfoContainer.EntriesRead;
        }

    NET_REMOTE_RPC_FAILED("NetWkstaUserEnum",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )

        //
        // Call downlevel version.
        //
        status = RxNetWkstaUserEnum(
                servername,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle);

    NET_REMOTE_END

    return status;
}



NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfo(
    IN  LPTSTR  reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaUserGetInfo.

Arguments:

    reserved - Must be NULL.

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to a buffer which contains the requested
        user information.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;


    if (reserved != NULL || bufptr == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *bufptr = NULL;           // Must be NULL so RPC knows to fill it in.

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local only) version of API.
        //
        status = NetrWkstaUserGetInfo(
                     NULL,
                     level,
                     (LPWKSTA_USER_INFO) bufptr
                     );

    NET_REMOTE_RPC_FAILED("NetWkstaUserGetInfo",
            NULL,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )

        //
        // No downlevel version to call
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetWkstaUserSetInfo(
    IN  LPTSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaUserSetInfo.

Arguments:

    reserved - Must be NULL.

    level - Supplies the level of information.

    buf - Supplies a buffer which contains the information structure of fields
        to set.  The level denotes the structure in this buffer.

    parm_err - Returns the identifier to the invalid parameter in buf if this
        function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;


    if (reserved != NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local only) version of API.
        //
        status = NetrWkstaUserSetInfo(
                     NULL,
                     level,
                     (LPWKSTA_USER_INFO) &buf,
                     parm_err
                     );

    NET_REMOTE_RPC_FAILED("NetWkstaUserSetInfo",
            NULL,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )

        //
        // No downlevel version to call
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportEnum(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaTransportEnum.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to the buffer which contains a sequence of
        information structure of the specified information level.  This
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.

    prefmaxlen - Supplies the number of bytes of information to return in the
        buffer.  If this value is MAXULONG, all available information will
        be returned.

    entriesread - Returns the number of entries read into the buffer.  This
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    totalentries - Returns the total number of entries available.  This value
        is only valid if the return code is NERR_Success or ERROR_MORE_DATA.

    resume_handle - Supplies a handle to resume the enumeration from where it
        left off the last time through.  Returns the resume handle if return
        code is ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    GENERIC_INFO_CONTAINER GenericInfoContainer;
    GENERIC_ENUM_STRUCT InfoStruct;

    if (bufptr == NULL || entriesread == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    try {
        *entriesread = 0;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return ERROR_INVALID_PARAMETER;
    }

    GenericInfoContainer.Buffer = NULL;
    GenericInfoContainer.EntriesRead = 0;

    InfoStruct.Container = &GenericInfoContainer;
    InfoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrWkstaTransportEnum(
                     servername,
                     (LPWKSTA_TRANSPORT_ENUM_STRUCT) &InfoStruct,
                     prefmaxlen,
                     totalentries,
                     resume_handle
                     );

        if (status == NERR_Success || status == ERROR_MORE_DATA) {
            *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
            *entriesread = GenericInfoContainer.EntriesRead;
        }

    NET_REMOTE_RPC_FAILED("NetWkstaTransportEnum",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )

        //
        // No downlevel version to call
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}



NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportAdd(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaTransportAdd.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the level of information.

    buf - Supplies a buffer which contains the information of transport to add.

    parm_err - Returns the identifier to the invalid parameter in buf if this
        function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrWkstaTransportAdd(
                     servername,
                     level,
                     (LPWKSTA_TRANSPORT_INFO_0) buf,
                     parm_err
                     );

    NET_REMOTE_RPC_FAILED("NetWkstaTransportAdd",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )


        //
        // No downlevel version to call
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}



NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportDel(
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  transportname,
    IN  DWORD   ucond
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaTransportDel.

Arguments:

    servername - Supplies the name of server to execute this function

    transportname - Supplies the name of the transport to delete.

    ucond - Supplies a value which specifies the force level of disconnection
        for existing use on the transport.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrWkstaTransportDel(
                     servername,
                     transportname,
                     ucond
                     );

    NET_REMOTE_RPC_FAILED("NetWkstaTransportDel",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )

        //
        // No downlevel version to try
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}



NET_API_STATUS NET_API_FUNCTION
NetUseAdd(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetUseAdd.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    buf - Supplies a buffer which contains the information of use to add.

    parm_err - Returns the identifier to the invalid parameter in buf if this
        function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    LPWSTR lpwTempPassword = NULL;
    UNICODE_STRING EncodedPassword;
#define NETR_USE_ADD_PASSWORD_SEED 0x56    // Pick a non-zero seed.

    DWORD OptionsSupported;

    status = NetRemoteComputerSupports(
                servername,
                SUPPORTS_RPC | SUPPORTS_LOCAL,     // options wanted
                &OptionsSupported
                );

    if (status != NERR_Success) {
        //
        // This is where machine not found gets handled.
        //
        return status;
    }

    if (OptionsSupported & SUPPORTS_LOCAL) {

        //
        // Local case
        //

        RtlInitUnicodeString( &EncodedPassword, NULL );

        RpcTryExcept {

            //
            // Obfuscate the password so it won't end up in the pagefile
            //
            if ( level >= 1 ) {

                if ( ((PUSE_INFO_1)buf)->ui1_password != NULL ) {
                    UCHAR Seed = NETR_USE_ADD_PASSWORD_SEED;

                    // create a local copy of the password
                    lpwTempPassword = ((PUSE_INFO_1)buf)->ui1_password;
                    ((PUSE_INFO_1)buf)->ui1_password = (LPWSTR)LocalAlloc(LMEM_FIXED,(wcslen(lpwTempPassword)+1) * sizeof(WCHAR));
                    if (((PUSE_INFO_1)buf)->ui1_password == NULL) {
                        ((PUSE_INFO_1)buf)->ui1_password = lpwTempPassword;
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                    wcscpy(((PUSE_INFO_1)buf)->ui1_password,lpwTempPassword);

                    RtlInitUnicodeString( &EncodedPassword,
                                          ((PUSE_INFO_1)buf)->ui1_password );

                    RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );
                }
            }

            status = NetrUseAdd(
                         NULL,
                         level,
                         (LPUSE_INFO) &buf,
                         parm_err
                         );
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            status = WsMapRpcError(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Put the password back the way we found it.
        //
        if(lpwTempPassword != NULL) {
            LocalFree(((PUSE_INFO_1)buf)->ui1_password);
            ((PUSE_INFO_1)buf)->ui1_password = lpwTempPassword;
        }
    }
    else {

        //
        // Remote servername specified.  Only allow remoting to downlevel.
        //

        if (OptionsSupported & SUPPORTS_RPC) {
            status = ERROR_NOT_SUPPORTED;
        }
        else {

            //
            // Call downlevel version of the API.
            //
            status = RxNetUseAdd(
                         servername,
                         level,
                         buf,
                         parm_err
                         );

        }
    }

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetUseDel(
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  usename,
    IN  DWORD   ucond
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetUseDel.

Arguments:

    servername - Supplies the name of server to execute this function

    transportname - Supplies the name of the transport to delete.

    ucond - Supplies a value which specifies the force level of disconnection
        for the use.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    DWORD OptionsSupported;


    status = NetRemoteComputerSupports(
                servername,
                SUPPORTS_RPC | SUPPORTS_LOCAL,     // options wanted
                &OptionsSupported
                );

    if (status != NERR_Success) {
        //
        // This is where machine not found gets handled.
        //
        return status;
    }

    if (OptionsSupported & SUPPORTS_LOCAL) {

        //
        // Local case
        //

        RpcTryExcept {

            status = NetrUseDel(
                         NULL,
                         usename,
                         ucond
                         );

        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            status = WsMapRpcError(RpcExceptionCode());
        }
        RpcEndExcept

    }
    else {

        //
        // Remote servername specified.  Only allow remoting to downlevel.
        //

        if (OptionsSupported & SUPPORTS_RPC) {
            status = ERROR_NOT_SUPPORTED;
        }
        else {

            //
            // Call downlevel version of the API.
            //
            status = RxNetUseDel(
                         servername,
                         usename,
                         ucond
                         );
        }
    }

    return status;
}



NET_API_STATUS NET_API_FUNCTION
NetUseGetInfo(
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  usename,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetUseGetInfo.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to a buffer which contains the requested
        use information.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    DWORD OptionsSupported;

    if (bufptr == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *bufptr = NULL;           // Must be NULL so RPC knows to fill it in.

    status = NetRemoteComputerSupports(
                servername,
                SUPPORTS_RPC | SUPPORTS_LOCAL,     // options wanted
                &OptionsSupported
                );

    if (status != NERR_Success) {
        //
        // This is where machine not found gets handled.
        //
        return status;
    }

    if (OptionsSupported & SUPPORTS_LOCAL) {

        //
        // Local case
        //

        RpcTryExcept {

            status = NetrUseGetInfo(
                         NULL,
                         usename,
                         level,
                         (LPUSE_INFO) bufptr
                         );

        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            status = WsMapRpcError(RpcExceptionCode());
        }
        RpcEndExcept

    }
    else {

        //
        // Remote servername specified.  Only allow remoting to downlevel.
        //

        if (OptionsSupported & SUPPORTS_RPC) {
            status = ERROR_NOT_SUPPORTED;
        }
        else {

            //
            // Call downlevel version of the API.
            //
            status = RxNetUseGetInfo(
                         servername,
                         usename,
                         level,
                         bufptr
                         );

        }
    }

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetUseEnum(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetUseEnum.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to the buffer which contains a sequence of
        information structure of the specified information level.  This
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.

    prefmaxlen - Supplies the number of bytes of information to return in the
        buffer.  If this value is MAXULONG, all available information will
        be returned.

    entriesread - Returns the number of entries read into the buffer.  This
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    totalentries - Returns the total number of entries available.  This value
        is only valid if the return code is NERR_Success or ERROR_MORE_DATA.

    resume_handle - Supplies a handle to resume the enumeration from where it
        left off the last time through.  Returns the resume handle if return
        code is ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    GENERIC_INFO_CONTAINER GenericInfoContainer;
    GENERIC_ENUM_STRUCT InfoStruct;

    DWORD OptionsSupported;

    if (bufptr == NULL || entriesread == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    try {
        *entriesread = 0;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return ERROR_INVALID_PARAMETER;
    }

    GenericInfoContainer.Buffer = NULL;
    GenericInfoContainer.EntriesRead = 0;

    InfoStruct.Container = &GenericInfoContainer;
    InfoStruct.Level = level;

    status = NetRemoteComputerSupports(
                servername,
                SUPPORTS_RPC | SUPPORTS_LOCAL,     // options wanted
                &OptionsSupported
                );

    if (status != NERR_Success) {
        //
        // This is where machine not found gets handled.
        //
        return status;
    }

    if (OptionsSupported & SUPPORTS_LOCAL) {

        //
        // Local case
        //

        RpcTryExcept {

            status = NetrUseEnum(
                         NULL,
                         (LPUSE_ENUM_STRUCT) &InfoStruct,
                         prefmaxlen,
                         totalentries,
                         resume_handle
                         );

            if (status == NERR_Success || status == ERROR_MORE_DATA) {
                *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
                *entriesread = GenericInfoContainer.EntriesRead;
            }

        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            status = WsMapRpcError(RpcExceptionCode());
        }
        RpcEndExcept

    }
    else {

        //
        // Remote servername specified.  Only allow remoting to downlevel.
        //

        if (OptionsSupported & SUPPORTS_RPC) {
            status = ERROR_NOT_SUPPORTED;
        }
        else {

            //
            // Call downlevel version of the API.
            //
            status = RxNetUseEnum(
                         servername,
                         level,
                         bufptr,
                         prefmaxlen,
                         entriesread,
                         totalentries,
                         resume_handle
                         );

        }
    }

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetMessageBufferSend (
    IN  LPCWSTR servername OPTIONAL,
    IN  LPCWSTR msgname,
    IN  LPCWSTR fromname,
    IN  LPBYTE  buf,
    IN  DWORD   buflen
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetMessageBufferSend.

Arguments:

    servername - Supplies the name of server to execute this function


Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
#define MAX_MESSAGE_SIZE 1792

    NET_API_STATUS status;

    //
    // Truncate messages greater than (2K - 1/8th) = 1792 due to the 2K LPC
    // port data size max. The messenger server receiving this message uses
    // the MessageBox() api with the MB_SERVICE_NOTIFICATION flag to display
    // this message. The MB_SERVICE_NOTIFICATION flag instructs MessageBox()
    // to piggyback the hard error mechanism to get the UI on the console;
    // otherwise the UI would never be seen. This is where the LPC port data
    // size limitation comes into play.
    //
    // Why subtract an 1/8th from 2K? The messenger server prepends a string
    // to the message (e.g., "Message from Joe to Linda on 3/7/96 12:04PM").
    // In English, this string is 67 characters max (max user/computer name
    // is 15 chars).
    //     67 * 1.5 (other languages) * 2 (sizeof(WCHAR)) = 201 bytes.
    // An 1/8th of 2K is 256.
    //
    if (buflen > MAX_MESSAGE_SIZE) {
       buf[MAX_MESSAGE_SIZE - 2] = '\0';
       buf[MAX_MESSAGE_SIZE - 1] = '\0';
       buflen = MAX_MESSAGE_SIZE;
    }

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrMessageBufferSend(
                     (LPWSTR)servername,
                     (LPWSTR)msgname,
                     (LPWSTR)fromname,
                     buf,
                     buflen
                     );

    NET_REMOTE_RPC_FAILED("NetMessageBufferSend",
            (LPWSTR)servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION )

        //
        // Call downlevel version of the API.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}



NET_API_STATUS NET_API_FUNCTION
I_NetLogonDomainNameAdd(
    IN  LPTSTR logondomain
    )

/*++

Routine Description:

    This is the DLL entrypoint for the internal API I_NetLogonDomainNameAdd.

Arguments:

    logondomain - Supplies the name of the logon domain to add to the Browser.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;


    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local only) version of API.
        //
        status = I_NetrLogonDomainNameAdd(
                     logondomain
                     );

    NET_REMOTE_RPC_FAILED(
        "I_NetLogonDomainNameAdd",
        NULL,
        status,
        NET_REMOTE_FLAG_NORMAL,
        SERVICE_WORKSTATION
        )

        //
        // No downlevel version to try
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}



NET_API_STATUS NET_API_FUNCTION
I_NetLogonDomainNameDel(
    IN  LPTSTR logondomain
    )

/*++

Routine Description:

    This is the DLL entrypoint for the internal API I_NetLogonDomainNameDel.

Arguments:

    logondomain - Supplies the name of the logon domain to delete from the
        Browser.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;


    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local only) version of API.
        //
        status = I_NetrLogonDomainNameDel(
                     logondomain
                     );

    NET_REMOTE_RPC_FAILED(
        "I_NetLogonDomainNameDel",
        NULL,
        status,
        NET_REMOTE_FLAG_NORMAL,
        SERVICE_WORKSTATION
        )

        //
        // No downlevel version to try
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;

}



NET_API_STATUS
NetWkstaStatisticsGet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  DWORD   Options,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Wrapper for workstation statistics retrieval routine - either calls the
    client-side RPC function or calls RxNetStatisticsGet to retrieve the
    statistics from a down-level workstation service

Arguments:

    ServerName  - where to remote this function
    Level       - of information required (MBZ)
    Options     - flags. Currently MBZ
    Buffer      - pointer to pointer to returned buffer

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                    Level not 0
                  ERROR_INVALID_PARAMETER
                    Unsupported options requested
                  ERROR_NOT_SUPPORTED
                    Service is not SERVER or WORKSTATION
                  ERROR_ACCESS_DENIED
                    Caller doesn't have necessary access rights for request

--*/

{
    NET_API_STATUS  status;

    if (Buffer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // set the caller's buffer pointer to known value. This will kill the
    // calling app if it gave us a bad pointer and didn't use try...except
    //

    *Buffer = NULL;

    //
    // validate parms
    //

    if (Level) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // we don't even allow clearing of stats any more
    //

    if (Options) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // NTRAID-70679-2/6/2000 davey remove redundant service name parameter
    //

    NET_REMOTE_TRY_RPC
        status = NetrWorkstationStatisticsGet(ServerName,
                                                SERVICE_WORKSTATION,
                                                Level,
                                                Options,
                                                (LPSTAT_WORKSTATION_0*)Buffer
                                                );

    NET_REMOTE_RPC_FAILED("NetrWorkstationStatisticsGet",
                            ServerName,
                            status,
                            NET_REMOTE_FLAG_NORMAL,
                            SERVICE_WORKSTATION
                            )

        status = RxNetStatisticsGet(ServerName,
                                SERVICE_LM20_WORKSTATION,
                                Level,
                                Options,
                                Buffer
                                );

    NET_REMOTE_END

    return status;
}


STATIC
DWORD
WsMapRpcError(
    IN DWORD RpcError
    )
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful net
    error for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

Return Value:

    Returns the mapped error.

--*/
{

    switch (RpcError) {

        case RPC_S_SERVER_UNAVAILABLE:
            return NERR_WkstaNotStarted;

        case RPC_X_NULL_REF_POINTER:
            return ERROR_INVALID_PARAMETER;

        case EXCEPTION_ACCESS_VIOLATION:
            return ERROR_INVALID_ADDRESS;

        default:
            return RpcError;
    }

}


NET_API_STATUS
NetpEncodeJoinPassword(
    IN LPWSTR lpPassword,
    OUT LPWSTR *EncodedPassword
    )
{
    NET_API_STATUS status = NERR_Success;
    UNICODE_STRING EncodedPasswordU;
    PWSTR PasswordPart;
    ULONG PwdLen;
    UCHAR Seed;

    *EncodedPassword = NULL;

    if ( lpPassword  ) {

        PwdLen = wcslen( ( LPWSTR )lpPassword ) * sizeof( WCHAR );

        PwdLen += sizeof( WCHAR ) + sizeof( WCHAR );

        status = NetApiBufferAllocate( PwdLen,
                                       ( PVOID * )EncodedPassword );

        if ( status == NERR_Success ) {

            //
            // We'll put the encode byte as the first character in the string
            //
            PasswordPart = ( *EncodedPassword ) + 1;
            wcscpy( PasswordPart, ( LPWSTR )lpPassword );
            RtlInitUnicodeString( &EncodedPasswordU, PasswordPart );

            Seed = 0;
            RtlRunEncodeUnicodeString( &Seed, &EncodedPasswordU );

            *( PWCHAR )( *EncodedPassword ) = ( WCHAR )Seed;

        }

    }

    return( status );
}

NTSTATUS
JoinpRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
)
/*++

Routine Description:

    This routine fills a buffer with random data.

Parameters:

    BufferSize - Length of the input buffer, in bytes.

    Buffer - Input buffer to be filled with random data.

Return Values:

    Errors from NtQuerySystemTime()


--*/
{
    ULONG Index;
    LARGE_INTEGER Time;
    ULONG Seed;
    NTSTATUS NtStatus;


    NtStatus = NtQuerySystemTime(&Time);
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    Seed = Time.LowPart ^ Time.HighPart;

    for (Index = 0 ; Index < BufferSize ; Index++ )
    {
        *Buffer++ = (UCHAR) (RtlRandom(&Seed) % 256);
    }
    return(STATUS_SUCCESS);

}


NET_API_STATUS
NetpEncryptJoinPasswordStart(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR lpPassword OPTIONAL,
    OUT RPC_BINDING_HANDLE *RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PJOINPR_ENCRYPTED_USER_PASSWORD *EncryptedUserPassword,
    OUT LPWSTR *EncodedPassword
    )

/*++

Routine Description:

    This routine takes a cleartext unicode NT password from the user,
    and encrypts it with the session key.

Parameters:

    ServerName - UNC server name of the server to remote the API to

    lpPassword - the cleartext unicode NT password.

    RpcBindingHandle - RPC handle used for acquiring a session key.

    RedirHandle - Returns a handle to the redir.  Since RpcBindingHandles don't represent
        and open connection to the server, we have to ensure the connection stays open
        until the server side has a chance to get this same UserSessionKey.  The only
        way to do that is to keep the connect open.

        Returns NULL if no handle is needed.

    EncryptedUserPassword - receives the encrypted cleartext password.
        If lpPassword is NULL, a NULL is returned.

    EncodedPassword - receives an encode form of lpPassowrd.
        This form can be passed around locally with impunity.

Return Values:

    If this routine returns NO_ERROR, the returned data must be freed using
        NetpEncryptJoinPasswordEnd.


--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS NtStatus;
    USER_SESSION_KEY UserSessionKey;
    RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    PJOINPR_USER_PASSWORD UserPassword = NULL;
    ULONG PasswordSize;

    //
    // Initialization
    //

    *RpcBindingHandle = NULL;
    *EncryptedUserPassword = NULL;
    *RedirHandle = NULL;
    *EncodedPassword = NULL;

    //
    // Get an RPC handle to the server.
    //

    NetStatus = NetpBindRpc (
                    (LPWSTR) ServerName,
                    WORKSTATION_INTERFACE_NAME,
                    TEXT("Security=Impersonation Dynamic False"),
                    RpcBindingHandle );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // If no password was specified,
    //  just return.
    //

    if ( lpPassword == NULL ) {
        NetStatus = NO_ERROR;
        goto Cleanup;
    }


    //
    // Sanity check the password length
    //

    try {
        PasswordSize = wcslen( lpPassword ) * sizeof(WCHAR);
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( PasswordSize > JOIN_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        NetStatus = ERROR_PASSWORD_RESTRICTION;
        goto Cleanup;
    }

    //
    // Encode the password
    //

    NetStatus = NetpEncodeJoinPassword( (LPWSTR) lpPassword, EncodedPassword );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Allocate a buffer to encrypt and fill it in.
    //

    UserPassword = LocalAlloc( 0, sizeof(*UserPassword) );

    if ( UserPassword == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Copy the password into the tail end of the buffer.
    //

    RtlCopyMemory(
        ((PCHAR) UserPassword->Buffer) +
            (JOIN_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
            PasswordSize,
        lpPassword,
        PasswordSize );

    UserPassword->Length = PasswordSize;

    //
    // Fill the front of the buffer with random data
    //

    NtStatus = JoinpRandomFill(
                (JOIN_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                    PasswordSize,
                (PUCHAR) UserPassword->Buffer );

    if ( !NT_SUCCESS(NtStatus) ) {
        NetStatus = NetpNtStatusToApiStatus( NtStatus );
        goto Cleanup;
    }

    NtStatus = JoinpRandomFill(
                JOIN_OBFUSCATOR_LENGTH,
                (PUCHAR) UserPassword->Obfuscator );

    if ( !NT_SUCCESS(NtStatus) ) {
        NetStatus = NetpNtStatusToApiStatus( NtStatus );
        goto Cleanup;
    }

    //
    // Get the session key.
    //

    NtStatus = RtlGetUserSessionKeyClientBinding(
                   *RpcBindingHandle,
                   RedirHandle,
                   &UserSessionKey );

    if ( !NT_SUCCESS(NtStatus) ) {
        NetStatus = NetpNtStatusToApiStatus( NtStatus );
        goto Cleanup;
    }

    //
    // The UserSessionKey is the same for the life of the session.  RC4'ing multiple
    //  strings with a single key is weak (if you crack one you've cracked them all).
    //  So compute a key that's unique for this particular encryption.
    //
    //

    MD5Init(&Md5Context);

    MD5Update( &Md5Context, (LPBYTE)&UserSessionKey, sizeof(UserSessionKey) );
    MD5Update( &Md5Context, UserPassword->Obfuscator, sizeof(UserPassword->Obfuscator) );

    MD5Final( &Md5Context );

    rc4_key( &Rc4Key, MD5DIGESTLEN, Md5Context.digest );


    //
    // Encrypt it.
    //  Don't encrypt the obfuscator.  The server needs that to compute the key.
    //

    rc4( &Rc4Key, sizeof(UserPassword->Buffer)+sizeof(UserPassword->Length), (LPBYTE) UserPassword->Buffer );

    NetStatus = NO_ERROR;

Cleanup:
    if ( NetStatus == NO_ERROR ) {
        *EncryptedUserPassword = (PJOINPR_ENCRYPTED_USER_PASSWORD) UserPassword;
    } else {
        if ( UserPassword != NULL ) {
            LocalFree( UserPassword );
        }
        if ( *RpcBindingHandle != NULL ) {
            NetpUnbindRpc( *RpcBindingHandle );
            *RpcBindingHandle = NULL;
        }
        if ( *RedirHandle != NULL ) {
            NtClose( *RedirHandle );
            *RedirHandle = NULL;
        }
        if ( *EncodedPassword != NULL ) {
            NetApiBufferFree( *EncodedPassword );
            *EncodedPassword = NULL;
        }
    }

    return NetStatus;
}


VOID
NetpEncryptJoinPasswordEnd(
    IN RPC_BINDING_HANDLE RpcBindingHandle,
    IN HANDLE RedirHandle OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword OPTIONAL,
    IN LPWSTR EncodedPassword OPTIONAL
    )

/*++

Routine Description:

    This routine takes the variables returned by NetpEncryptJoinPasswordStart and
    frees them.

Parameters:

    RpcBindingHandle - RPC handle used for acquiring a session key.

    RedirHandle - Handle to the redirector

    EncryptedUserPassword - the encrypted cleartext password.

    EncodedPassword - the encoded form of lpPassowrd.

Return Values:


--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS NtStatus;
    USER_SESSION_KEY UserSessionKey;
    RC4_KEYSTRUCT Rc4Key;
    PJOINPR_USER_PASSWORD UserPassword = NULL;
    ULONG PasswordSize;


    //
    // Free the RPC binding handle.
    //

    if ( RpcBindingHandle != NULL ) {
        (VOID) NetpUnbindRpc ( RpcBindingHandle );
    }

    //
    // Close the redir handle.
    //

    if ( RedirHandle != NULL ) {
        NtClose( RedirHandle );
    }

    //
    // Free the encrypted password.
    //

    if ( EncryptedUserPassword != NULL ) {
        LocalFree( EncryptedUserPassword );
    }

    //
    // Free the encoded password
    //

    if ( EncodedPassword != NULL ) {
        NetApiBufferFree( EncodedPassword );
    }

}




NET_API_STATUS
NET_API_FUNCTION
NetJoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDomain,
    IN  LPCWSTR lpMachineAccountOU OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    )
/*++

Routine Description:

    Joins the machine to the domain.

Arguments:

    lpServer -- Name of server on which to execute this function

    lpDomain -- Domain to join

    lpMachineAccountOU -- Optional name of the OU under which to create the machine account

    lpAccount -- Account to use for join

    lpPassword -- Password matching the account

    fOptions -- Options to use when joining the domain

Returns:

    NERR_Success -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this interface

--*/
{
    NET_API_STATUS NetStatus, OldStatus;
    PWSTR ComputerName = NULL;
    BOOLEAN CallLocal = FALSE;
    RPC_BINDING_HANDLE RpcBindingHandle;
    HANDLE RedirHandle;
    PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    LPWSTR EncodedPassword;

    //
    // Encrypt the password.
    //

    NetStatus = NetpEncryptJoinPasswordStart( lpServer,
                                           lpPassword,
                                           &RpcBindingHandle,
                                           &RedirHandle,
                                           &EncryptedUserPassword,
                                           &EncodedPassword );

    if ( NetStatus == NERR_Success ) {

        NET_REMOTE_TRY_RPC

            //
            // Try RPC version of API.
            //
            NetStatus = NetrJoinDomain2( RpcBindingHandle,
                                     ( LPWSTR )lpServer,
                                     ( LPWSTR )lpDomain,
                                     ( LPWSTR )lpMachineAccountOU,
                                     ( LPWSTR )lpAccount,
                                     EncryptedUserPassword,
                                     fJoinOptions );

        NET_REMOTE_RPC_FAILED(
            "NetJoinDomain",
            NULL,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION
            )

            //
            // No downlevel version to try
            //
            NetStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END


        if ( NetStatus == NERR_WkstaNotStarted || NetStatus == ERROR_ACCESS_DENIED ) {

            OldStatus = NetStatus;

            if ( lpServer ) {

                NetStatus = NetpGetComputerName( &ComputerName );

                if ( NetStatus == NERR_Success ) {

                    if ( !_wcsicmp( lpServer, ComputerName ) ) {

                        CallLocal = TRUE;
                    }

                    NetApiBufferFree( ComputerName );
                }

            } else {

                CallLocal = TRUE;
            }

            //
            // Only call locally if we are joining a workgroup
            //
            if ( CallLocal && !FLAG_ON( fJoinOptions, NETSETUP_JOIN_DOMAIN ) ) {

                NetStatus = NetpDoDomainJoin( ( LPWSTR )lpServer,
                                           ( LPWSTR )lpDomain,
                                           NULL,
                                           ( LPWSTR )lpAccount,
                                           ( LPWSTR )EncodedPassword,
                                           fJoinOptions );

            } else {

                NetStatus = OldStatus;
            }
        }

        NetpEncryptJoinPasswordEnd( RpcBindingHandle,
                                    RedirHandle,
                                    EncryptedUserPassword,
                                    EncodedPassword );

    }

    return NetStatus;

}



NET_API_STATUS
NET_API_FUNCTION
NetUnjoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fUnjoinOptions
    )
/*++

Routine Description:

    Unjoins from the joined domain

Arguments:

    lpServer -- Name of server on which to execute this function

    lpAccount -- Account to use for unjoining

    lpPassword -- Password matching the account

    fOptions -- Options to use when unjoining the domain

Returns:

    NERR_Success -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this interface

--*/
{
    NET_API_STATUS NetStatus;
    RPC_BINDING_HANDLE RpcBindingHandle;
    HANDLE RedirHandle;
    PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    LPWSTR EncodedPassword;

    //
    // Encrypt the password.
    //

    NetStatus = NetpEncryptJoinPasswordStart( lpServer,
                                           lpPassword,
                                           &RpcBindingHandle,
                                           &RedirHandle,
                                           &EncryptedUserPassword,
                                           &EncodedPassword );

    if ( NetStatus == NERR_Success ) {

        NET_REMOTE_TRY_RPC

            //
            // Try RPC version of API.
            //
            NetStatus = NetrUnjoinDomain2(
                                       RpcBindingHandle,
                                       ( LPWSTR )lpServer,
                                       ( LPWSTR )lpAccount,
                                       EncryptedUserPassword,
                                       fUnjoinOptions );

        NET_REMOTE_RPC_FAILED(
            "NetUnjoinDomain",
            NULL,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION
            )

            //
            // No downlevel version to try
            //
            NetStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END

        NetpEncryptJoinPasswordEnd( RpcBindingHandle,
                                    RedirHandle,
                                    EncryptedUserPassword,
                                    EncodedPassword );

    }

    return NetStatus;

}


NET_API_STATUS
NET_API_FUNCTION
NetRenameMachineInDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpNewMachineName OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fRenameOptions
    )
/*++

Routine Description:

    Renames a machine currently joined to a domain.

Arguments:

    lpServer -- Name of server on which to execute this function

    lpNewMachineName -- New name for this machine.  If the name is specified, it is used
      for the new machine name.  If it is not specified, it is assumed that SetComputerName
      has already been invoked, and that name will be used.

    lpAccount -- Account to use for the rename

    lpPassword -- Password matching the account

    fOptions -- Options to use for the rename

Returns:

    NERR_Success -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this interface

--*/
{
    NET_API_STATUS NetStatus;
    RPC_BINDING_HANDLE RpcBindingHandle;
    HANDLE RedirHandle;
    PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    LPWSTR EncodedPassword;

    //
    // Encrypt the password.
    //

    NetStatus = NetpEncryptJoinPasswordStart( lpServer,
                                           lpPassword,
                                           &RpcBindingHandle,
                                           &RedirHandle,
                                           &EncryptedUserPassword,
                                           &EncodedPassword );

    if ( NetStatus == NERR_Success ) {

        NET_REMOTE_TRY_RPC

            //
            // Try RPC (local only) version of API.
            //
            NetStatus = NetrRenameMachineInDomain2(
                                                RpcBindingHandle,
                                                ( LPWSTR )lpServer,
                                                ( LPWSTR )lpNewMachineName,
                                                ( LPWSTR )lpAccount,
                                                EncryptedUserPassword,
                                                fRenameOptions );
        NET_REMOTE_RPC_FAILED(
            "NetRenameMachineInDomain",
            NULL,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION
            )

            //
            // No downlevel version to try
            //
            NetStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END

        NetpEncryptJoinPasswordEnd( RpcBindingHandle,
                                    RedirHandle,
                                    EncryptedUserPassword,
                                    EncodedPassword );
    }

    return NetStatus;

}


NET_API_STATUS
NET_API_FUNCTION
NetValidateName(
    IN  LPCWSTR             lpServer OPTIONAL,
    IN  LPCWSTR             lpName,
    IN  LPCWSTR             lpAccount OPTIONAL,
    IN  LPCWSTR             lpPassword OPTIONAL,
    IN  NETSETUP_NAME_TYPE  NameType
    )
/*++

Routine Description:

    Ensures that the given name is valid for a name of that type

Arguments:

    lpServer -- Name of server on which to execute this function

    lpName -- Name to validate

    lpAccount -- Account to use for validation

    lpPassword -- Password matching the account

    NameType -- Type of the name to validate

Returns:

    NERR_Success -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this interface


--*/
{
    NET_API_STATUS NetStatus, OldStatus;
    PWSTR ComputerName = NULL;
    BOOLEAN CallLocal = FALSE;
    RPC_BINDING_HANDLE RpcBindingHandle;
    HANDLE RedirHandle;
    PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    LPWSTR EncodedPassword;

    //
    // Encrypt the password.
    //

    NetStatus = NetpEncryptJoinPasswordStart( lpServer,
                                           lpPassword,
                                           &RpcBindingHandle,
                                           &RedirHandle,
                                           &EncryptedUserPassword,
                                           &EncodedPassword );

    if ( NetStatus == NERR_Success ) {

        NET_REMOTE_TRY_RPC


            //
            // Try RPC (local only) version of API.
            //
            NetStatus = NetrValidateName2( RpcBindingHandle,
                                       ( LPWSTR )lpServer,
                                       ( LPWSTR )lpName,
                                       ( LPWSTR )lpAccount,
                                       EncryptedUserPassword,
                                       NameType );

        NET_REMOTE_RPC_FAILED(
            "NetValidateName",
            NULL,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION
            )

            //
            // No downlevel version to try
            //
            NetStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END

        if ( NetStatus == NERR_WkstaNotStarted ) {

            OldStatus = NetStatus;

            if ( lpServer ) {

                NetStatus = NetpGetComputerName( &ComputerName );

                if ( NetStatus == NERR_Success ) {

                    if ( !_wcsicmp( lpServer, ComputerName ) ) {

                        CallLocal = TRUE;
                    }

                    NetApiBufferFree( ComputerName );
                }

            } else {

                CallLocal = TRUE;
            }

            if ( CallLocal ) {

                NetStatus = NetpValidateName( ( LPWSTR )lpServer,
                                           ( LPWSTR )lpName,
                                           ( LPWSTR )lpAccount,
                                           EncodedPassword,
                                           NameType );

            } else {

                NetStatus = OldStatus;
            }
        }

        NetpEncryptJoinPasswordEnd( RpcBindingHandle,
                                    RedirHandle,
                                    EncryptedUserPassword,
                                    EncodedPassword );
    }

    return NetStatus;

}



NET_API_STATUS
NET_API_FUNCTION
NetGetJoinInformation(
    IN      LPCWSTR                lpServer OPTIONAL,
    OUT     LPWSTR                *lpNameBuffer,
    OUT     PNETSETUP_JOIN_STATUS  BufferType
    )
/*++

Routine Description:

    Gets information on the state of the workstation.  The information
    obtainable is whether the machine is joined to a workgroup or a domain,
    and optionally, the name of that workgroup/domain.

Arguments:

    lpServer -- Name of server on which to execute this function

    lpNameBuffer -- Where the domain/workgroup name is returned.

    BufferType -- Whether the machine is joined to a workgroup or a domain

Returns:

    NERR_Success -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this interface

    ERROR_INVALID_PARAMETER -- An invalid buffer pointer was given

--*/
{
    NET_API_STATUS status, OldStatus;
    LPWSTR Name = NULL, ComputerName = NULL;
    BOOLEAN CallLocal = FALSE;

    if ( lpNameBuffer == NULL ) {

        return( ERROR_INVALID_PARAMETER );
    }


    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local only) version of API.
        //
        status = NetrGetJoinInformation( ( LPWSTR )lpServer,
                                         &Name,
                                         BufferType );

    NET_REMOTE_RPC_FAILED(
        "NetGetJoinInformation",
        NULL,
        status,
        NET_REMOTE_FLAG_NORMAL,
        SERVICE_WORKSTATION
        )

        //
        // No downlevel version to try
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    if ( status != NERR_Success  ) {

        OldStatus = status;

        if ( lpServer ) {

            if ( status == NERR_Success ) {

                if ( !_wcsicmp( lpServer, ComputerName ) ) {

                    CallLocal = TRUE;
                }

                NetApiBufferFree( ComputerName );
            }

        } else {

            CallLocal = TRUE;
        }

        if ( CallLocal ) {


            status = NetpGetJoinInformation( ( LPWSTR )lpServer,
                                             &Name,
                                             BufferType );
        } else {

            status = OldStatus;
        }
    }

    if ( status == NERR_Success ) {

        *lpNameBuffer = Name;
    }

    return status;

}


NET_API_STATUS
NET_API_FUNCTION
NetGetJoinableOUs(
    IN  LPCWSTR     lpServer OPTIONAL,
    IN  LPCWSTR     lpDomain,
    IN  LPCWSTR     lpAccount OPTIONAL,
    IN  LPCWSTR     lpPassword OPTIONAL,
    OUT DWORD      *OUCount,
    OUT LPWSTR    **OUs
    )
/*++

Routine Description:

    This API is used to determine the list of OUs in which a machine account
    can be created.  This function is only valid against an NT5 or greater Dc.

Arguments:

    lpServer -- Name of server on which to execute this function

    lpDomain -- Domain to join

    lpAccount -- Account to use for join

    lpPassword -- Password matching the account

    OUCount --  Where the number of joinable OU strings is returned

    OUs --  Where the list of OU under which machine accounts can be created is returned


Returns:

    NERR_Success -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this interface

    ERROR_INVALID_PARAMETER -- An invalid buffer pointer was given

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    ULONG Count = 0;
    LPWSTR *OUList = NULL;
    RPC_BINDING_HANDLE RpcBindingHandle;
    HANDLE RedirHandle;
    PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    LPWSTR EncodedPassword;


    if ( OUCount == NULL || OUs == NULL ) {

        return( ERROR_INVALID_PARAMETER );
    }


    //
    // Encrypt the password.
    //

    NetStatus = NetpEncryptJoinPasswordStart( lpServer,
                                           lpPassword,
                                           &RpcBindingHandle,
                                           &RedirHandle,
                                           &EncryptedUserPassword,
                                           &EncodedPassword );


    if ( NetStatus == NERR_Success ) {

        NET_REMOTE_TRY_RPC

            //
            // Try RPC (local only) version of API.
            //
            NetStatus = NetrGetJoinableOUs2(
                                         RpcBindingHandle,
                                         ( LPWSTR )lpServer,
                                         ( LPWSTR )lpDomain,
                                         ( LPWSTR )lpAccount,
                                         EncryptedUserPassword,
                                         &Count,
                                         &OUList );

        NET_REMOTE_RPC_FAILED(
            "NetrGetJoinableOUs",
            NULL,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION
            )

            //
            // No downlevel version to try
            //
            NetStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END

        NetpEncryptJoinPasswordEnd( RpcBindingHandle,
                                    RedirHandle,
                                    EncryptedUserPassword,
                                    EncodedPassword );
    }

    if ( NetStatus == NERR_Success ) {

        *OUCount = Count;
        *OUs = OUList;
    }

    return NetStatus;
}


NET_API_STATUS
NET_API_FUNCTION
NetAddAlternateComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR AlternateName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    )
/*++

Routine Description:

    Adds an alternate name for the specified server.

Arguments:

    Server -- Name of server on which to execute this function.

    AlternateName -- The name to add.

    DomainAccount -- Domain account to use for accessing the
        machine account object for the specified server in the AD.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    DomainAccountPassword -- Password matching the domain account.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

Note:

    The process that calls this routine must have administrator
    privileges on the server computer.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    NET_API_STATUS NetStatus;
    RPC_BINDING_HANDLE RpcBindingHandle;
    HANDLE RedirHandle;
    PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    LPWSTR EncodedPassword;

    //
    // Encrypt the password.
    //

    NetStatus = NetpEncryptJoinPasswordStart( Server,
                                              DomainAccountPassword,
                                              &RpcBindingHandle,
                                              &RedirHandle,
                                              &EncryptedUserPassword,
                                              &EncodedPassword );

    if ( NetStatus == NERR_Success ) {

        NET_REMOTE_TRY_RPC

            //
            // Try RPC version of API.
            //
            NetStatus = NetrAddAlternateComputerName(
                                                RpcBindingHandle,
                                                (LPWSTR) Server,
                                                (LPWSTR) AlternateName,
                                                (LPWSTR) DomainAccount,
                                                EncryptedUserPassword,
                                                Reserved );
        NET_REMOTE_RPC_FAILED(
            "NetRenameMachineInDomain",
            NULL,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION
            )

            //
            // No downlevel version to try
            //
            NetStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END

        NetpEncryptJoinPasswordEnd( RpcBindingHandle,
                                    RedirHandle,
                                    EncryptedUserPassword,
                                    EncodedPassword );
    }

    return NetStatus;
}


NET_API_STATUS
NET_API_FUNCTION
NetRemoveAlternateComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR AlternateName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    )
/*++

Routine Description:

    Deletes an alternate name for the specified server.

Arguments:

    Server -- Name of server on which to execute this function.

    AlternateName -- The name to delete.

    DomainAccount -- Domain account to use for accessing the
        machine account object for the specified server in the AD.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    DomainAccountPassword -- Password matching the domain account.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

Note:

    The process that calls this routine must have administrator
    privileges on the server computer.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    NET_API_STATUS NetStatus;
    RPC_BINDING_HANDLE RpcBindingHandle;
    HANDLE RedirHandle;
    PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    LPWSTR EncodedPassword;

    //
    // Encrypt the password.
    //

    NetStatus = NetpEncryptJoinPasswordStart( Server,
                                              DomainAccountPassword,
                                              &RpcBindingHandle,
                                              &RedirHandle,
                                              &EncryptedUserPassword,
                                              &EncodedPassword );

    if ( NetStatus == NERR_Success ) {

        NET_REMOTE_TRY_RPC

            //
            // Try RPC version of API.
            //
            NetStatus = NetrRemoveAlternateComputerName(
                                                RpcBindingHandle,
                                                (LPWSTR) Server,
                                                (LPWSTR) AlternateName,
                                                (LPWSTR) DomainAccount,
                                                EncryptedUserPassword,
                                                Reserved );
        NET_REMOTE_RPC_FAILED(
            "NetRenameMachineInDomain",
            NULL,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION
            )

            //
            // No downlevel version to try
            //
            NetStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END

        NetpEncryptJoinPasswordEnd( RpcBindingHandle,
                                    RedirHandle,
                                    EncryptedUserPassword,
                                    EncodedPassword );
    }

    return NetStatus;
}


NET_API_STATUS
NET_API_FUNCTION
NetSetPrimaryComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR PrimaryName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    )
/*++

Routine Description:

    Sets the primary computer name for the specified server.

Arguments:

    Server -- Name of server on which to execute this function.

    PrimaryName -- The primary computer name to set.

    DomainAccount -- Domain account to use for accessing the
        machine account object for the specified server in the AD.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    DomainAccountPassword -- Password matching the domain account.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

Note:

    The process that calls this routine must have administrator
    privileges on the server computer.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    NET_API_STATUS NetStatus;
    RPC_BINDING_HANDLE RpcBindingHandle;
    HANDLE RedirHandle;
    PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    LPWSTR EncodedPassword;

    //
    // Encrypt the password.
    //

    NetStatus = NetpEncryptJoinPasswordStart( Server,
                                              DomainAccountPassword,
                                              &RpcBindingHandle,
                                              &RedirHandle,
                                              &EncryptedUserPassword,
                                              &EncodedPassword );

    if ( NetStatus == NERR_Success ) {

        NET_REMOTE_TRY_RPC

            //
            // Try RPC version of API.
            //
            NetStatus = NetrSetPrimaryComputerName(
                                                RpcBindingHandle,
                                                (LPWSTR) Server,
                                                (LPWSTR) PrimaryName,
                                                (LPWSTR) DomainAccount,
                                                EncryptedUserPassword,
                                                Reserved );
        NET_REMOTE_RPC_FAILED(
            "NetRenameMachineInDomain",
            NULL,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_WORKSTATION
            )

            //
            // No downlevel version to try
            //
            NetStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END

        NetpEncryptJoinPasswordEnd( RpcBindingHandle,
                                    RedirHandle,
                                    EncryptedUserPassword,
                                    EncodedPassword );
    }

    return NetStatus;
}


NET_API_STATUS
NET_API_FUNCTION
NetEnumerateComputerNames(
    IN  LPCWSTR Server OPTIONAL,
    IN  NET_COMPUTER_NAME_TYPE NameType,
    IN  ULONG Reserved,
    OUT PDWORD EntryCount,
    OUT LPWSTR **ComputerNames
    )
/*++

Routine Description:

    Enumerates computer names for the specified server.

Arguments:

    Server -- Name of server on which to execute this function.

    NameType -- The type of the name queried.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

    EntryCount -- Returns the number of names returned

    ComputerNames -- An array of pointers to names.  Must be freed by
        calling NetApiBufferFree.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    PNET_COMPUTER_NAME_ARRAY ComputerNameArray = NULL;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC version of API.
        //
        NetStatus = NetrEnumerateComputerNames(
                              (LPWSTR) Server,
                              NameType,
                              Reserved,
                              &ComputerNameArray );

    NET_REMOTE_RPC_FAILED(
        "NetRenameMachineInDomain",
        NULL,
        NetStatus,
        NET_REMOTE_FLAG_NORMAL,
        SERVICE_WORKSTATION
        )

        //
        // No downlevel version to try
        //
        NetStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    //
    // Convert the computer names to what the caller expects
    //

    if ( NetStatus == NO_ERROR && ComputerNameArray != NULL ) {

        //
        // If there are no names returned,
        //  set the entry count to zero
        //
        if ( ComputerNameArray->EntryCount == 0 ) {
            *ComputerNames = NULL;
            *EntryCount = 0;

        //
        // Otherwise, allocate a buffer to return to the caller
        //
        } else {
            ULONG Size;
            ULONG i;
            LPBYTE Where;

            Size = sizeof(LPWSTR) * ComputerNameArray->EntryCount;
            for ( i = 0; i < ComputerNameArray->EntryCount; i++ ) {
                Size += ComputerNameArray->ComputerNames[i].Length + sizeof(WCHAR);
            }

            NetStatus = NetApiBufferAllocate( Size, (PVOID) ComputerNames );

            if ( NetStatus == NO_ERROR ) {

                //
                // Set the size of the array
                //
                *EntryCount = ComputerNameArray->EntryCount;

                //
                // Loop copying names to the caller.
                //
                Where = ((LPBYTE)(*ComputerNames)) + sizeof(LPWSTR) * ComputerNameArray->EntryCount;
                for ( i = 0; i < ComputerNameArray->EntryCount; i++ ) {

                    //
                    // Copy the site name into the return buffer.
                    //
                    (*ComputerNames)[i] = (LPWSTR) Where;
                    RtlCopyMemory( Where,
                                   ComputerNameArray->ComputerNames[i].Buffer,
                                   ComputerNameArray->ComputerNames[i].Length );
                    Where += ComputerNameArray->ComputerNames[i].Length;
                    *((LPWSTR)Where) = L'\0';
                    Where += sizeof(WCHAR);
                }
            }
        }

        NetApiBufferFree( ComputerNameArray );
    }

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\msgsvcsend_c_stub.c ===
#include "msgsvcsend_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\idl\wsnames.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsnames.h

Abstract:

    Private header file which defines the Workstation names.

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:

--*/

#define WORKSTATION_INTERFACE_NAME    TEXT("wkssvc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <nt.h>
#include <windef.h>
#include <lmcons.h>

#define JOIN_OBFUSCATOR_LENGTH 8
#define JOIN_MAX_PASSWORD_LENGTH PWLEN

#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPWSTR [string] wchar_t*
#define LPSTR [string] LPSTR
#define BOOL DWORD
#endif

#include <lmwksta.h>
#include <lmuse.h>
#include <lmstats.h>
#include <lmjoin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\message.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module contains the worker routines for the NetMessageBufferSend
    API implemented in the Workstation service.

Author:

    Rita Wong (ritaw) 29-July-1991

Revision History:
    Terence Kwan (terryk)   20-Oct-1993
        Initialize the system inside NetrMessageBufferSend for the first send

--*/

#include "wsutil.h"
#include "wsconfig.h"                    // WsInfo.WsComputerName
#include "wsmsg.h"                       // Send worker routines
#include "wssec.h"                       // Security object
#include <lmwksta.h>                     // NetWkstaUserGetInfo

#include "msgsvcsend.h"                  // NetrSendMessage interface for internet direct send

STATIC
NET_API_STATUS
WsGetSenderName(
    OUT LPTSTR Sender
    );

STATIC
DWORD
WsSendInternetMessage(
    IN  LPTSTR MessageName,
    IN  LPTSTR To,
    IN  LPTSTR Sender,
    IN  LPBYTE Message,
    IN  DWORD MessageSize
    );

STATIC
NET_API_STATUS
WsSendDirectedMessage(
    IN  LPTSTR To,
    IN  LPTSTR Sender,
    IN  LPBYTE Message,
    IN  DWORD MessageSize
    );


NET_API_STATUS
NetrMessageBufferSend (
    IN LPTSTR ServerName,
    IN LPTSTR MessageName,
    IN LPTSTR FromName OPTIONAL,
    IN LPBYTE Message,
    IN DWORD  MessageSize
    )
/*++

Routine Description:

    This function is the NetMessageBufferSend entry point in the
    Workstation service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    MessageName - Supplies the message alias to send the message to.

    FromName - Supplies the message alias of sender.  If NULL, the sender
        alias will default to the currently logged on user.

    Message - Supplies a pointer to the message to send.

    MessageSize - Supplies the size of the message in number of bytes.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    int            i;

    TCHAR Sender[UNLEN + 1];
    TCHAR To[UNLEN + 1];

    LPTSTR Asterix = NULL;

    NTSTATUS ntstatus;
    UNICODE_STRING UnicodeMessage;
    OEM_STRING OemMessage;

    static BOOL fInitialize = FALSE;

    // Initialize the system if this this the first time.

    if ( !fInitialize )
    {
        if (( ntstatus = WsInitializeMessageSend( TRUE /* first time */)) != NERR_Success )
        {
            return(ntstatus);
        }

        fInitialize = TRUE;
    }

    UNREFERENCED_PARAMETER(ServerName);

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(("[Wksta] NetMessageBufferSend MessageSize=%lu\n",
                     MessageSize));
    }

    //
    // Any local user, and domain admins and operators are allowed to
    // send messages.  Remote users besides domain admins, and operators
    // are denied access.
    //
    if (NetpAccessCheckAndAudit(
            WORKSTATION_DISPLAY_NAME,        // Subsystem name
            (LPTSTR) MESSAGE_SEND_OBJECT,    // Object type name
            MessageSendSd,                   // Security descriptor
            WKSTA_MESSAGE_SEND,              // Desired access
            &WsMessageSendMapping            // Generic mapping
            ) != NERR_Success) {

        return ERROR_ACCESS_DENIED;
    }

    if (! ARGUMENT_PRESENT(FromName)) {

        //
        // Get the caller's username
        //
        if ((status = WsGetSenderName(Sender)) != NERR_Success) {
            return status;
        }
    }
    else {
        //
        // Insure we don't overwrite our buffer.
        //
        if (STRLEN(FromName) > UNLEN) {
            STRNCPY(Sender, FromName, UNLEN);
            FromName[UNLEN] = TCHAR_EOS;
        }
        else {
            STRCPY(Sender, FromName);
        }
    }

    //
    // Convert the Unicode message to OEM character set (very similar
    // to ANSI)
    //
    UnicodeMessage.Buffer = (PWCHAR) Message;
    UnicodeMessage.Length = (USHORT) MessageSize;
    UnicodeMessage.MaximumLength = (USHORT) MessageSize;

    ntstatus = RtlUnicodeStringToOemString(
                   &OemMessage,
                   &UnicodeMessage,
                   TRUE
                   );

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Wksta] NetrMessageBufferSend: RtlUnicodeStringToOemString failed "
                     FORMAT_NTSTATUS "\n", ntstatus));
        return NetpNtStatusToApiStatus(ntstatus);
    }


    //
    // If message name is longer than the maximum name length,
    // truncate the name.  Since DNLEN is way less than UNLEN,
    // this will hold <DomainName*> if need be.
    //
    if (STRLEN(MessageName) > UNLEN)
    {
        STRNCPY(To, MessageName, UNLEN);
        To[UNLEN] = TCHAR_EOS;
    }
    else
    {
        STRCPY(To, MessageName);
    }

    //
    // Remove any trailing blanks from the "To" Name.
    //
    for (i = STRLEN(To) - 1; i >= 0; i--)
    {
        if (To[i] != TEXT(' '))
        {
            To[i + 1] = TEXT('\0');
            break;
        }
    }


    //
    // Don't allow broadcasts anymore.
    //
    if (STRNCMP(To, TEXT("*"), 2) == 0)
    {
        status = ERROR_INVALID_PARAMETER;

        goto CleanExit;
    }


    //
    // Send message to a domain.  Recipient name should be in the form of
    // "DomainName*".
    //
    Asterix = STRRCHR(To, TCHAR_STAR);

    if ((Asterix) && (*(Asterix + 1) == TCHAR_EOS)) {

        *Asterix = TCHAR_EOS;                     // Overwrite trailing '*'

        //
        // If message size is too long to fit into a mailslot message,
        // truncate it.
        //
        if (OemMessage.Length > MAX_GROUP_MESSAGE_SIZE) {

            if ((status = WsSendToGroup(
                              To,
                              Sender,
                              OemMessage.Buffer,
                              MAX_GROUP_MESSAGE_SIZE
                              )) == NERR_Success)  {

                status = NERR_TruncatedBroadcast;
                goto CleanExit;
            }

        } else {
            status = WsSendToGroup(
                         To,
                         Sender,
                         OemMessage.Buffer,
                         (WORD) OemMessage.Length
                         );

            goto CleanExit;
        }
    }

    //
    // Send a directed message
    //
    if (Asterix) {
        RtlFreeOemString(&OemMessage);
        return NERR_NameNotFound;
    }

    status = WsSendDirectedMessage(
                 To,
                 Sender,
                 OemMessage.Buffer,
                 OemMessage.Length
                 );

    //
    // If error suggests adapters have changed, reinitialize and try again
    //

    if (status == NERR_NameNotFound) {
        NET_API_STATUS status1;

        (void) WsInitializeMessageSend( FALSE /* second time */ );

        status1 = WsSendDirectedMessage(
            To,
            Sender,
            OemMessage.Buffer,
            OemMessage.Length
            );
        // If this time we are successful, update final status
        if (status1 == NERR_Success) {
            status = NERR_Success;
        }
    }

    //
    // If error suggests that Netbios could not resolve the name, or is
    // not running, try sending an Internet message.
    //

    if (status == NERR_NameNotFound) {
        ntstatus = WsSendInternetMessage(
            MessageName,
            To,
            Sender,
            OemMessage.Buffer,
            OemMessage.Length );

        if (ntstatus == ERROR_SUCCESS) {
            status = NERR_Success;
        }
    }

CleanExit:

    RtlFreeOemString(&OemMessage);
    return status;
}


STATIC
NET_API_STATUS
WsGetSenderName(
    OUT LPTSTR Sender
    )
/*++

Routine Description:

    This function retrives the username of person who called
    NetMessageBufferSend API.  If the caller is not logged on, he/she has
    no name; in this case, we return the computer name as the sender name.

Arguments:

    Sender - Returns the username of the caller of the NetMessageBufferSend
        API.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    //
    // No username, sender is computer name
    //
    STRCPY(Sender, WsInfo.WsComputerName);


    (VOID) I_NetNameCanonicalize(
                 NULL,
                 Sender,
                 Sender,
                 (UNLEN + 1) * sizeof(TCHAR),
                 NAMETYPE_MESSAGEDEST,
                 0
                 );

    return NERR_Success;
}


STATIC
DWORD
WsSendInternetMessage(
    IN  LPTSTR MessageName,
    IN  LPTSTR To,
    IN  LPTSTR Sender,
    IN  LPBYTE Message,
    IN  DWORD MessageSize
    )

/*++

Routine Description:

This routine sends the message to the computer specified by the MessageName.  Note that the
MessageName must be resolvable using "gethostbyname", that is usernames or other general
net names are not supported for this type of send.

Arguments:

    MessageName - The target name
    To - Target name truncated to 16 characters
    Sender - Sending computer name
    Message - 
    MessageSize - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    LPSTR  ansiTo           = NULL;
    LPSTR  ansiSender       = NULL;
    LPSTR  newMessage       = NULL;
    LPTSTR pszStringBinding = NULL;

    RPC_BINDING_HANDLE hRpcBinding = NULL;

    IF_DEBUG( MESSAGE )
        NetpKdPrint(("[Wksta] WsSendInternet: enter, To %ws Sender %ws\n", To, Sender));

    // Convert arguments to ansi

    ansiTo = NetpAllocStrFromWStr( To );
    if (ansiTo == NULL) {
        IF_DEBUG( MESSAGE )
            NetpKdPrint(("[Wksta] WsSendInternet: alloc to failed\n"));
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto release;
    }

    ansiSender = NetpAllocStrFromWStr( Sender );
    if (ansiSender == NULL) {
        IF_DEBUG( MESSAGE )
            NetpKdPrint(("[Wksta] WsSendInternet: alloc sender failed\n"));
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto release;
    }

    newMessage = LocalAlloc( LMEM_FIXED, MessageSize + 1 );
    if (newMessage == NULL) {
        IF_DEBUG( MESSAGE )
            NetpKdPrint(("[Wksta] WsSendInternet: alloc message failed\n"));
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto release;
    }
    memcpy( newMessage, Message, MessageSize );
    newMessage[MessageSize] = '\0';

    // Treat the To argument as a computer name and try to bind
    // Specify NULL endpoing, meaning bind to dynamic endpoint at call-time.

    status = RpcStringBindingCompose( NULL,                         // UUID
                                      TEXT("ncadg_ip_udp"),         // pszProtocolSequence,
                                      MessageName,                  // pszNetworkAddress,
                                      NULL,                         // pszEndpoint,
                                      NULL,                         // Options
                                      &pszStringBinding);
    if (status != ERROR_SUCCESS) {
        IF_DEBUG( MESSAGE )
            NetpKdPrint(("[Wksta] WsSendInternet: RpcStringBindingCompose failure: "
                     FORMAT_NTSTATUS "\n", status));
        goto release;
    }

    status = RpcBindingFromStringBinding(pszStringBinding, &hRpcBinding);

    if (status != ERROR_SUCCESS) {
        IF_DEBUG( MESSAGE )
            NetpKdPrint(("[Wksta] WsSendInternet: RpcBindingFromStringBinding failure: "
                     FORMAT_NTSTATUS "\n", status));
        goto release;
    }

    status = NetrSendMessage( hRpcBinding, ansiSender, ansiTo, newMessage );

    if (status != ERROR_SUCCESS) {
        IF_DEBUG( MESSAGE ) {
            NetpKdPrint(("[Wksta] WsSendInternet: NetrSendMessage failure: "
                         FORMAT_NTSTATUS "\n", status));
        }
    }

release:
    if (ansiTo != NULL)
        NetApiBufferFree( ansiTo );
    if (ansiSender != NULL)
        NetApiBufferFree( ansiSender );
    if (newMessage != NULL)
        LocalFree( newMessage );

    if (pszStringBinding != NULL) {
        RpcStringFree( &pszStringBinding );  // remote calls done; unbind
    }

    if (hRpcBinding != NULL) {
        RpcBindingFree( &hRpcBinding );  // remote calls done; unbind
    }

    IF_DEBUG( MESSAGE ) {
        NetpKdPrint(("[Wksta] WsSendInternet: exit, ntstatus= %d\n", status));
    }
    return status;
} /* WsSendInternetMessage */


STATIC
NET_API_STATUS
WsSendDirectedMessage(
    IN  LPTSTR To,
    IN  LPTSTR Sender,
    IN  LPBYTE Message,
    IN  DWORD MessageSize
    )
/*++

Routine Description:

    This function sends the specified message as a directed message
    to the specified recipient.  A call to the recipient is sent
    out on each LAN adapter.  If there is no response we try the
    next LAN adapter until we hear from the targeted recipient.

Arguments:

    To - Supplies the message alias of the recipient.

    Sender - Supplies the message alias of sender.

    Message - Supplies a pointer to the message to send.

    MessageSize - Supplies the size of the message in number of bytes.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_NameNotFound;
    UCHAR i;

    BOOL NameFound = FALSE;

    UCHAR SessionNumber;
    short MessageId;



    //
    // Try each network until someone answers the call.  Only the first name
    // found will receive the message.  The same name on any other network
    // will never see the message.  This is to remain consistent with all
    // other session based algorithms in LAN Man.
    //
    for (i = 0; i < WsNetworkInfo.LanAdapterNumbers.length; i++) {

        //
        // Attempt to establish a session
        //
        if ((status = NetpNetBiosCall(
                          WsNetworkInfo.LanAdapterNumbers.lana[i],
                          To,
                          Sender,
                          &SessionNumber
                          )) == NERR_Success) {

            NameFound = TRUE;

            IF_DEBUG(MESSAGE) {
                NetpKdPrint(("[Wksta] Successfully called %ws\n", To));
            }

            if (MessageSize <= MAX_SINGLE_MESSAGE_SIZE) {

                //
                // Send single block message if possible
                //
                status = WsSendSingleBlockMessage(
                             WsNetworkInfo.LanAdapterNumbers.lana[i],
                             SessionNumber,
                             To,
                             Sender,
                             Message,
                             (WORD) MessageSize
                             );

            }
            else {

                //
                // Message too long, got to send multi-block message
                //

                //
                // Send the begin message
                //
                if ((status = WsSendMultiBlockBegin(
                                  WsNetworkInfo.LanAdapterNumbers.lana[i],
                                  SessionNumber,
                                  To,
                                  Sender,
                                  &MessageId
                                  )) == NERR_Success) {


                    //
                    // Send the body of the message in as many blocks as necessary
                    //
                    for (; MessageSize > MAX_SINGLE_MESSAGE_SIZE;
                         Message += MAX_SINGLE_MESSAGE_SIZE,
                         MessageSize -= MAX_SINGLE_MESSAGE_SIZE) {

                         if ((status = WsSendMultiBlockText(
                                           WsNetworkInfo.LanAdapterNumbers.lana[i],
                                           SessionNumber,
                                           Message,
                                           MAX_SINGLE_MESSAGE_SIZE,
                                           MessageId
                                           )) != NERR_Success) {
                             break;
                         }
                    }

                    if (status == NERR_Success && MessageSize > 0) {
                        //
                        // Send the remaining message body
                        //
                        status = WsSendMultiBlockText(
                                            WsNetworkInfo.LanAdapterNumbers.lana[i],
                                            SessionNumber,
                                            Message,
                                            (WORD) MessageSize,
                                            MessageId
                                            );
                    }

                    //
                    // Send the end message
                    //
                    if (status == NERR_Success) {
                       status = WsSendMultiBlockEnd(
                                    WsNetworkInfo.LanAdapterNumbers.lana[i],
                                    SessionNumber,
                                    MessageId
                                    );
                    }

                }
            }

            (VOID) NetpNetBiosHangup(
                       WsNetworkInfo.LanAdapterNumbers.lana[i],
                       SessionNumber
                       );

        }   // Call successful

        if (NameFound) {
            break;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\dfsgluon.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       DfsGluon.h
//
//  Contents:   Declarations for dfs use of gluons
//
//  Classes:
//
//  Functions:
//
//  History:    March 24, 1994		Milans Created
//
//-----------------------------------------------------------------------------


#ifndef _DFS_GLUON_
#define _DFS_GLUON_

#include <gluon.h>


//
// Marshalling info for TAddress
//

extern MARSHAL_INFO MiTAddress;

#define INIT_TADDRESS_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_TAddress[] = {			\
    	_MCode_conformant(TA_ADDRESS, Address, AddressLength),		\
    	_MCode_ush(TA_ADDRESS, AddressLength),				\
	_MCode_ush(TA_ADDRESS, AddressType),				\
	_MCode_cauch(TA_ADDRESS, Address, AddressLength) 		\
    };									\
    MARSHAL_INFO MiTAddress = _mkMarshalInfo(TA_ADDRESS, _MCode_TAddress);

//
// Marshalling info for DS_TRANSPORT
//

extern MARSHAL_INFO MiDSTransport;

#define INIT_DS_TRANSPORT_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSTransport[] = {			\
        _MCode_conformant(DS_TRANSPORT, taddr.Address, taddr.AddressLength), \
    	_MCode_ush(DS_TRANSPORT, usFileProtocol),			\
	_MCode_ush(DS_TRANSPORT, iPrincipal),				\
	_MCode_ush(DS_TRANSPORT, grfModifiers),				\
	_MCode_struct(DS_TRANSPORT, taddr, &MiTAddress)		\
    };									\
    MARSHAL_INFO MiDSTransport = _mkMarshalInfo(DS_TRANSPORT, _MCode_DSTransport);


//
// The following is needed to define an array of pointers to DS_TRANSPORT
//

typedef struct _DS_TRANSPORT_P {
    PDS_TRANSPORT pDSTransport;
} DS_TRANSPORT_P;

#define INIT_DS_TRANSPORT_P_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSTransportP[] = {			\
    	_MCode_pstruct(DS_TRANSPORT_P, pDSTransport, &MiDSTransport)	\
    };									\
    MARSHAL_INFO MiDSTransportP = _mkMarshalInfo(DS_TRANSPORT_P, _MCode_DSTransportP);

extern MARSHAL_INFO MiDSTransportP;

//
// Marshalling info for DS_MACHINE
//

extern MARSHAL_INFO MiDSMachine;

#define INIT_DS_MACHINE_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_DSMachine[] = {			\
        _MCode_conformant(DS_MACHINE, rpTrans, cTransports),		\
    	_MCode_guid(DS_MACHINE, guidSite),				\
	_MCode_guid(DS_MACHINE, guidMachine),				\
	_MCode_ul(DS_MACHINE, grfFlags),				\
	_MCode_pwstr(DS_MACHINE, pwszShareName),			\
	_MCode_ul(DS_MACHINE, cPrincipals),				\
	_MCode_pcapwstr(DS_MACHINE, prgpwszPrincipals, cPrincipals),	\
	_MCode_ul(DS_MACHINE, cTransports),				\
	_MCode_castruct(DS_MACHINE, rpTrans, cTransports, &MiDSTransportP) \
    };									\
    MARSHAL_INFO MiDSMachine = _mkMarshalInfo(DS_MACHINE, _MCode_DSMachine);

//
// The following is needed to define an array of pointers to DS_MACHINE
//

typedef struct _DS_MACHINE_P {
    PDS_MACHINE pDSMachine;
} DS_MACHINE_P;

#define INIT_DS_MACHINE_P_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSMachineP[] = {			\
    	_MCode_pstruct(DS_MACHINE_P, pDSMachine, &MiDSMachine)		\
    };									\
    MARSHAL_INFO MiDSMachineP = _mkMarshalInfo(DS_MACHINE_P, _MCode_DSMachineP);

extern MARSHAL_INFO MiDSMachineP;
//
// Marshalling info for DS_GLUON
//

extern MARSHAL_INFO MiDSGluon;

#define INIT_DS_GLUON_MARSHAL_INFO() 					\
    static MARSHAL_TYPE_INFO _MCode_DSGluon[] = {			\
    	_MCode_conformant(DS_GLUON, rpMachines, cMachines),		\
    	_MCode_guid(DS_GLUON, guidThis),				\
	_MCode_pwstr(DS_GLUON, pwszName),				\
	_MCode_ul(DS_GLUON, grfFlags),					\
	_MCode_ul(DS_GLUON, cMachines),					\
	_MCode_castruct(DS_GLUON, rpMachines, cMachines, &MiDSMachineP)	\
    };									\
    MARSHAL_INFO MiDSGluon = _mkMarshalInfo(DS_GLUON, _MCode_DSGluon);

typedef struct _DS_GLUON_P {
    PDS_GLUON pDSGluon;
} DS_GLUON_P;

extern MARSHAL_INFO MiDSGluonP;

#define INIT_DS_GLUON_P_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_DSGluonP[] = {			\
    	_MCode_pstruct(DS_GLUON_P, pDSGluon, &MiDSGluon)		\
    };									\
    MARSHAL_INFO MiDSGluonP = _mkMarshalInfo(DS_GLUON_P, _MCode_DSGluonP);

#endif // _DFS_GLUON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\join.c ===
/*++

Copyright (c) 1998-1998  Microsoft Corporation

Module Name:

    join.c

Abstract:

    This module contains the worker routines for the NetJoin APIs
    implemented in the Workstation service.

Author:

    Mac McLain      (macm)       06-Jan-1998

Revision History:

--*/
#include "wsutil.h"
#include "wsconfig.h"
#include <lmerrlog.h>
#include <lmaccess.h>

#define __LMJOIN_H__
#include <netsetup.h>
#include <icanon.h>
#include <crypt.h>
#include <rc4.h>
#include <md5.h>
#if(_WIN32_WINNT >= 0x0500)
    #include <dnsapi.h>
    #include <ntdsapi.h>
    #include <dsgetdc.h>
    #include <dsgetdcp.h>
    #include <winldap.h>
    #include <ntldap.h>
#endif

#if(_WIN32_WINNT < 0x0500)
    #include <winreg.h>
#endif

#define COMPUTERNAME_ROOT \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName"
#define NEW_COMPUTERNAME_VALUE_NAME L"ComputerName"




NET_API_STATUS
JoinpDecryptPasswordWithKey(
    IN handle_t RpcBindingHandle,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    IN BOOL EncodePassword,
    OUT LPWSTR *EncodedPassword
    )
/*++

Routine Description:

    Decrypts a password encrypted with the user session key.

Arguments:

    RpcBindingHandle - Rpc Binding handle describing the session key to use.

    EncryptedPassword - Encrypted password to decrypt.

    EncodePassword - If TRUE, the returned password will be encoded
        and the first WCHAR of the password buffer will be the seed

    EncodedPassword - Returns the (optionally Encoded) password.
        Buffer should be freed using NetpMemoryFree.

Return Value:

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    USER_SESSION_KEY UserSessionKey;
    RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;

    UNICODE_STRING EncodedPasswordU;
    LPWSTR PasswordPart;
    UCHAR Seed = 0;

    PJOINPR_USER_PASSWORD Password = (PJOINPR_USER_PASSWORD) EncryptedPassword;

    //
    // Handle the trivial case
    //

    *EncodedPassword = NULL;
    if ( EncryptedPassword == NULL ) {
        return NO_ERROR;
    }

    //
    // Get the session key
    //


    Status = RtlGetUserSessionKeyServer(
                    (RPC_BINDING_HANDLE)RpcBindingHandle,
                    &UserSessionKey );

    if (!NT_SUCCESS(Status)) {
        return NetpNtStatusToApiStatus( Status );
    }

    //
    // The UserSessionKey is the same for the life of the session.  RC4'ing multiple
    //  strings with a single key is weak (if you crack one you've cracked them all).
    //  So compute a key that's unique for this particular encryption.
    //
    //

    MD5Init(&Md5Context);

    MD5Update( &Md5Context, (LPBYTE)&UserSessionKey, sizeof(UserSessionKey) );
    MD5Update( &Md5Context, Password->Obfuscator, sizeof(Password->Obfuscator) );

    MD5Final( &Md5Context );

    rc4_key( &Rc4Key, MD5DIGESTLEN, Md5Context.digest );


    //
    // Decrypt the Buffer
    //

    rc4( &Rc4Key, sizeof(Password->Buffer)+sizeof(Password->Length), (LPBYTE) Password->Buffer );

    //
    // Check that the length is valid.  If it isn't bail here.
    //

    if (Password->Length > JOIN_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return ERROR_INVALID_PASSWORD;
    }

    //
    // Return the password to the caller.
    //

    *EncodedPassword = NetpMemoryAllocate(  Password->Length + sizeof(WCHAR) + sizeof(WCHAR) );

    if ( *EncodedPassword == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the password into the buffer
    //
    // If we are to encode the password, reserve
    //  the first character for the seed
    //

    if ( EncodePassword ) {
        PasswordPart = ( *EncodedPassword ) + 1;
    } else {
        PasswordPart = ( *EncodedPassword );
    }

    RtlCopyMemory( PasswordPart,
                   ((PCHAR) Password->Buffer) +
                   (JOIN_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                   Password->Length,
                   Password->Length );

    PasswordPart[Password->Length/sizeof(WCHAR)] = L'\0';

    RtlZeroMemory( ((PCHAR) Password->Buffer) +
                   (JOIN_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                   Password->Length,
                   Password->Length );


    //
    // Run Encode it so we can pass it around the process with impunity
    //

    if ( EncodePassword ) {
        RtlInitUnicodeString( &EncodedPasswordU, PasswordPart );

        RtlRunEncodeUnicodeString( &Seed, &EncodedPasswordU );

        *( PWCHAR )( *EncodedPassword ) = ( WCHAR )Seed;
    }

    return NO_ERROR;
}

NET_API_STATUS
NET_API_FUNCTION
NetrJoinDomain2(
    IN handle_t RpcBindingHandle,
    IN  LPWSTR  lpServer OPTIONAL,
    IN  LPWSTR  lpDomain,
    IN  LPWSTR  lpMachineAccountOU,
    IN  LPWSTR  lpAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    IN  DWORD   fOptions
    )
/*++

Routine Description:

    Joins the machine to the domain.

Arguments:

    lpServer -- Name of the machine being run on
    lpDomain -- Domain to join
    lpMachineAccountOU -- Optional name of the OU under which to create the machine account
    lpAccount -- Account to use for join
    EncryptedPassword - Encrypted password for lpAccount.
    fOptions -- Options to use when joining the domain

Returns:

    NERR_Success -- Success

    ERROR_INVALID_PARAMETER --  A bad parameter was given

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    LPTSTR ComputerName = NULL;
    LPWSTR EncodedPassword = NULL;

    //
    // Check the parameters we can
    //
    if (lpDomain == NULL ) {

        NetStatus = ERROR_INVALID_PARAMETER;

    }

    //
    // Decrypt the password.
    //

    if ( NetStatus == NERR_Success ) {
        NetStatus = JoinpDecryptPasswordWithKey(
                                RpcBindingHandle,
                                EncryptedPassword,
                                TRUE,  // encode the password
                                &EncodedPassword );
    }

    //
    // Get the current machine name, so we are sure we always have it in flat format
    //
    if ( NetStatus == NERR_Success ) {

        NetStatus = NetpGetComputerName( &ComputerName );

        if ( NetStatus == NERR_Success ) {

            lpServer = ComputerName;
        }

    }

    //
    // Do the impersonation
    //
    if ( NetStatus == NERR_Success ) {

        NetStatus = WsImpersonateClient();
    }

    //
    // Then, see about the join...
    //
    if ( NetStatus == NERR_Success ) {

        NetStatus = NetpDoDomainJoin( lpServer, lpDomain, lpMachineAccountOU, lpAccount,
                                      EncodedPassword, fOptions );

        //
        // Revert back to ourselves
        //
        WsRevertToSelf();
    }

    //
    // Write event log stating that we successfully joined the domain/workgroup
    //
    if ( NetStatus == NERR_Success ) {
        LPWSTR StringArray[2];

        if ( fOptions & NETSETUP_JOIN_DOMAIN ) {
            StringArray[0] = L"domain";
        } else {
            StringArray[0] = L"workgroup";
        }
        StringArray[1] = lpDomain;

        WsLogEvent( NELOG_Joined_Domain,
                    EVENTLOG_INFORMATION_TYPE,
                    2,
                    StringArray,
                    NERR_Success );
    }

    //
    // Free the memory for the machine name if we need to
    //
    if ( ComputerName != NULL ) {

        NetApiBufferFree( ComputerName );
    }

    if ( EncodedPassword != NULL ) {
        NetpMemoryFree( EncodedPassword );
    }

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetrUnjoinDomain2(
    IN handle_t RpcBindingHandle,
    IN  LPWSTR  lpServer OPTIONAL,
    IN  LPWSTR  lpAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    )
/*++

Routine Description:

    Unjoins from the joined domain

Arguments:

    lpServer -- Name of the machine being run on
    lpAccount -- Account to use for unjoining
    lpPassword -- Password matching the account.  The password is encoded.  The first WCHAR is
                  the seed
    fOptions -- Options to use when unjoining the domain

Returns:

    NERR_Success -- Name is valid
    NERR_SetupNotJoined -- This machine was not joined to a domain
    NERR_SetupDomainController -- This machine is a domain controller and
                                  cannot be unjoined
    NERR_InternalError -- Can't determine product type

--*/
{
    NET_API_STATUS              NetStatus = NERR_Success;
    PPOLICY_PRIMARY_DOMAIN_INFO pPolicyPDI;
    PPOLICY_DNS_DOMAIN_INFO     pPolicyDNS;
    NT_PRODUCT_TYPE             ProductType;
    LPWSTR EncodedPassword = NULL;

    //
    // Decrypt the password.
    //

    NetStatus = JoinpDecryptPasswordWithKey(
                                RpcBindingHandle,
                                EncryptedPassword,
                                TRUE,  // encode the password
                                &EncodedPassword );

    if ( NetStatus != NO_ERROR ) {
        return NetStatus;
    }

    //
    // Do the impersonation
    //
    NetStatus = WsImpersonateClient();

    //
    // First, get the primary domain info... We'll need it later
    //
    if ( NetStatus == NERR_Success ) {

        NetStatus = NetpGetLsaPrimaryDomain( NULL,
                                             NULL,
                                             &pPolicyPDI,
                                             &pPolicyDNS,
                                             NULL );

        if ( NetStatus == NERR_Success ) {

            if ( !IS_CLIENT_JOINED(pPolicyPDI) ) {

                NetStatus = NERR_SetupNotJoined;

            } else {

                //
                // See if it's a DC...
                //
                if ( RtlGetNtProductType( &ProductType ) == FALSE ) {

                    NetStatus = NERR_InternalError;

                } else {

                    if ( ProductType == NtProductLanManNt ) {

                        NetStatus = NERR_SetupDomainController;
                    }

                }
            }

            //
            // Ok, now if all that worked, we'll go ahead and do the removal
            //
            if ( NetStatus == NERR_Success ) {

                NetStatus = NetpUnJoinDomain( pPolicyPDI, lpAccount, EncodedPassword,
                                              fJoinOptions );


            }

            LsaFreeMemory( pPolicyPDI );
            LsaFreeMemory( pPolicyDNS );
        }

        //
        // Revert back to ourselves
        //
        WsRevertToSelf();
    }

    if ( EncodedPassword != NULL ) {
        NetpMemoryFree( EncodedPassword );
    }

    return(NetStatus);
}

NET_API_STATUS
NET_API_FUNCTION
NetrValidateName2(
    IN handle_t RpcBindingHandle,
    IN  LPWSTR              lpMachine,
    IN  LPWSTR              lpName,
    IN  LPWSTR              lpAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    IN  NETSETUP_NAME_TYPE  NameType
    )
/*++

Routine Description:

    Ensures that the given name is valid for a name of that type

Arguments:

    lpMachine -- Name of the machine being run on
    lpName -- Name to validate
    lpAccount -- Account to use for name validation
    lpPassword -- Password matching the account.  The password is encoded.  The first WCHAR is
                  the seed
    NameType -- Type of the name to validate

Returns:

    NERR_Success -- Name is valid
    ERROR_INVALID_PARAMETER -- A bad parameter was given
    NERR_InvalidComputer -- The name format given is bad
    ERROR_DUP_NAME -- The name is invalid for this type

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    UNICODE_STRING EncodedPasswordU;
    UCHAR Seed;
    LPWSTR EncodedPassword = NULL;

    //
    // Decrypt the password.
    //

    NetStatus = JoinpDecryptPasswordWithKey(
                                RpcBindingHandle,
                                EncryptedPassword,
                                TRUE,  // encode the password
                                &EncodedPassword );

    if ( NetStatus != NO_ERROR ) {
        return NetStatus;
    }

    if ( EncodedPassword ) {

        Seed = *( PUCHAR )EncodedPassword;
        RtlInitUnicodeString( &EncodedPasswordU, EncodedPassword + 1 );

    } else {

        RtlZeroMemory( &EncodedPasswordU, sizeof( UNICODE_STRING ) );
    }

    //
    // Do the impersonation
    //
    NetStatus = WsImpersonateClient();

    if ( NetStatus == NERR_Success ) {


        RtlRunDecodeUnicodeString( Seed, &EncodedPasswordU );
        NetStatus = NetpValidateName( lpMachine,
                                      lpName,
                                      lpAccount,
                                      EncodedPasswordU.Buffer,
                                      NameType );
        RtlRunEncodeUnicodeString( &Seed, &EncodedPasswordU );

        //
        // Revert back to ourselves
        //
        WsRevertToSelf();
    }

    if ( EncodedPassword != NULL ) {
        NetpMemoryFree( EncodedPassword );
    }

    return( NetStatus );
}



NET_API_STATUS
NET_API_FUNCTION
NetrGetJoinInformation(
    IN   LPWSTR                 lpServer OPTIONAL,
    OUT  LPWSTR                *lpNameBuffer,
    OUT  PNETSETUP_JOIN_STATUS  BufferType
    )
/*++

Routine Description:

    Gets information on the state of the workstation.  The information
    obtainable is whether the machine is joined to a workgroup or a domain,
    and optionally, the name of that workgroup/domain.

Arguments:

    lpNameBuffer -- Where the domain/workgroup name is returned.
    lpNameBufferSize -- Size of the passed in buffer, in WCHARs.  If 0, the
                        workgroup/domain name is not returned.
    BufferType -- Whether the machine is joined to a workgroup or a domain

Returns:

    NERR_Success -- Name is valid
    ERROR_INVALID_PARAMETER -- A bad parameter was given
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;

    //
    // Check the parameters
    //
    if ( lpNameBuffer == NULL ) {

        return( ERROR_INVALID_PARAMETER );

    }

    //
    // Do the impersonation
    //
    NetStatus = WsImpersonateClient();

    if ( NetStatus == NERR_Success ) {

        NetStatus = NetpGetJoinInformation( lpServer,
                                            lpNameBuffer,
                                            BufferType );

        //
        // Revert back to ourselves
        //
        WsRevertToSelf();
    }

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetrRenameMachineInDomain2(
    IN handle_t RpcBindingHandle,
    IN  LPWSTR  lpServer OPTIONAL,
    IN  LPWSTR  lpNewMachineName OPTIONAL,
    IN  LPWSTR  lpAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    IN  DWORD   fRenameOptions
    )
/*++

Routine Description:

    Renames a machine currently joined to a domain.

Arguments:

    lpServer -- Name of the machine being run on

    lpNewMachineName -- New name for this machine.  If the name is specified, it is used
      for the new machine name.  If it is not specified, it is assumed that SetComputerName
      has already been invoked, and that name will be used.

    lpAccount -- Account to use for the rename

    lpPassword -- Password matching the account.  The password has been encoded.  The first
                  WCHAR of the string is the seed.

    fOptions -- Options to use for the rename

Returns:

    NERR_Success -- Success

    ERROR_INVALID_PARAMETER --  A bad parameter was given

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    PPOLICY_PRIMARY_DOMAIN_INFO pPolicyPDI;
    PPOLICY_DNS_DOMAIN_INFO     pPolicyDNS;
    LPTSTR ComputerName = NULL;
    LPTSTR NewComputerName = NULL;
    LPTSTR DomainName = NULL;
    HKEY ComputerNameRootKey;
    ULONG Length;
    LPWSTR EncodedPassword = NULL;

    //
    // Get the current machine name
    //
    NetStatus = NetpGetComputerName( &ComputerName );

    if ( NetStatus == NERR_Success ) {

        lpServer = ComputerName;
    }

    //
    // Decrypt the password.
    //

    if ( NetStatus == NERR_Success ) {
        NetStatus = JoinpDecryptPasswordWithKey(
                                RpcBindingHandle,
                                EncryptedPassword,
                                TRUE,  // encode the password
                                &EncodedPassword );
    }


    //
    // Get the new machine name if it isn't specified
    //
    if ( NetStatus == NERR_Success && lpNewMachineName == NULL ) {

        NetStatus = NetpGetNewMachineName( &NewComputerName );
        lpNewMachineName = NewComputerName;
    }

    //
    // Get the current domain information
    //
    if ( NetStatus == NERR_Success ) {

        NetStatus = NetpGetLsaPrimaryDomain( NULL,
                                             NULL,
                                             &pPolicyPDI,
                                             &pPolicyDNS,
                                             NULL );

        if ( NetStatus == NERR_Success ) {

            NetStatus = NetApiBufferAllocate( pPolicyPDI->Name.Length + sizeof( WCHAR ),
                                              ( LPVOID * )&DomainName );

            if ( NetStatus == NERR_Success ) {

                RtlCopyMemory( DomainName, pPolicyPDI->Name.Buffer, pPolicyPDI->Name.Length );
                DomainName[ pPolicyPDI->Name.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
            }

            LsaFreeMemory( pPolicyPDI );
            LsaFreeMemory( pPolicyDNS );
        }
    }

    //
    // Do the impersonation
    //

    if ( NetStatus == NERR_Success ) {

        NetStatus = WsImpersonateClient();

        if ( NetStatus == NERR_Success ) {

            //
            // A machine rename
            //
            NetStatus = NetpMachineValidToJoin( lpNewMachineName, TRUE );

            if ( NetStatus == NERR_SetupAlreadyJoined ||
                 NetStatus == NERR_SetupDomainController ) {  // Allow DC rename

                NetStatus = NetpChangeMachineName( lpServer,
                                                   lpNewMachineName,
                                                   DomainName,
                                                   lpAccount,
                                                   EncodedPassword,
                                                   fRenameOptions );

                if ( NetStatus == NERR_Success && lpNewMachineName ) {

                    if ( SetComputerNameEx( ComputerNamePhysicalDnsHostname,
                                            lpNewMachineName ) == FALSE ) {

                        NetStatus = GetLastError();
                    }
                }

            } else if ( NetStatus == NERR_Success ) {

                NetStatus = NERR_SetupNotJoined;
            }
            //
            // Revert back to ourselves
            //
            WsRevertToSelf();
        }
    }


    //
    // Free the memory for the machine name(s) if we need to
    //
    if ( ComputerName != NULL ) {

        NetApiBufferFree( ComputerName );
    }

    if ( NewComputerName != NULL ) {

        NetApiBufferFree( NewComputerName );
    }

    if ( DomainName != NULL ) {

        NetApiBufferFree( DomainName );
    }

    if ( EncodedPassword != NULL ) {
        NetpMemoryFree( EncodedPassword );
    }

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetrGetJoinableOUs2(
    IN handle_t RpcBindingHandle,
    IN LPWSTR   lpServer OPTIONAL,
    IN LPWSTR   lpDomain,
    IN LPWSTR   lpAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    OUT DWORD   *OUCount,
    OUT LPWSTR **OUs
    )
/*++

Routine Description:

    Renames a machine currently joined to a domain.

Arguments:

    lpServer -- Name of the machine being run on
    lpDomain -- Domain to join
    lpAccount -- Account to use for join
    lpPassword -- Password matching the account.  The password has been encoded and the first
                  WCHAR of the name is the seed
    MachineAccountOUs -- Where the information is returned.

Returns:

    NERR_Success -- Success

    ERROR_INVALID_PARAMETER --  A bad parameter was given

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    LPWSTR EncodedPassword = NULL;

    NetStatus = WsImpersonateClient();

    //
    // Decrypt the password.
    //

    if ( NetStatus == NERR_Success ) {
        NetStatus = JoinpDecryptPasswordWithKey(
                                RpcBindingHandle,
                                EncryptedPassword,
                                TRUE,  // encode the password
                                &EncodedPassword );
    }

    if ( NetStatus == NERR_Success ) {

        //
        // Read the current information
        //
        NetStatus = NetpGetListOfJoinableOUs( lpDomain,
                                              lpAccount,
                                              EncodedPassword,
                                              OUCount,
                                              OUs );
    }

    //
    // Revert back to ourselves
    //
    WsRevertToSelf();

    if ( EncodedPassword != NULL ) {
        NetpMemoryFree( EncodedPassword );
    }

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetrJoinDomain(
    IN  LPWSTR  lpServer OPTIONAL,
    IN  LPWSTR  lpDomain,
    IN  LPWSTR  lpMachineAccountOU,
    IN  LPWSTR  lpAccount OPTIONAL,
    IN  LPWSTR  lpPassword OPTIONAL,
    IN  DWORD   fOptions
    )
/*++

Routine Description:

    Joins the machine to the domain.

Arguments:

    lpServer -- Name of the machine being run on
    lpDomain -- Domain to join
    lpMachineAccountOU -- Optional name of the OU under which to create the machine account
    lpAccount -- Account to use for join
    lpPassword -- Password matching the account.  The password is encoded.  The first WCHAR
                  is the seed.
    fOptions -- Options to use when joining the domain

Returns:

    NERR_Success -- Success

    ERROR_INVALID_PARAMETER --  A bad parameter was given

--*/
{

    //
    // This version that takes a clear text password isn't supported.
    //

    return ERROR_NOT_SUPPORTED;
}



NET_API_STATUS
NET_API_FUNCTION
NetrUnjoinDomain(
    IN  LPWSTR  lpServer OPTIONAL,
    IN  LPWSTR  lpAccount OPTIONAL,
    IN  LPWSTR  lpPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    )
/*++

Routine Description:

    Unjoins from the joined domain

Arguments:

    lpServer -- Name of the machine being run on
    lpAccount -- Account to use for unjoining
    lpPassword -- Password matching the account.  The password is encoded.  The first WCHAR is
                  the seed
    fOptions -- Options to use when unjoining the domain

Returns:

    NERR_Success -- Name is valid
    NERR_SetupNotJoined -- This machine was not joined to a domain
    NERR_SetupDomainController -- This machine is a domain controller and
                                  cannot be unjoined
    NERR_InternalError -- Can't determine product type

--*/
{

    //
    // This version that takes a clear text password isn't supported.
    //

    return ERROR_NOT_SUPPORTED;
}





NET_API_STATUS
NET_API_FUNCTION
NetrValidateName(
    IN  LPWSTR              lpMachine,
    IN  LPWSTR              lpName,
    IN  LPWSTR              lpAccount OPTIONAL,
    IN  LPWSTR              lpPassword OPTIONAL,
    IN  NETSETUP_NAME_TYPE  NameType
    )
/*++

Routine Description:

    Ensures that the given name is valid for a name of that type

Arguments:

    lpMachine -- Name of the machine being run on
    lpName -- Name to validate
    lpAccount -- Account to use for name validation
    lpPassword -- Password matching the account.  The password is encoded.  The first WCHAR is
                  the seed
    NameType -- Type of the name to validate

Returns:

    NERR_Success -- Name is valid
    ERROR_INVALID_PARAMETER -- A bad parameter was given
    NERR_InvalidComputer -- The name format given is bad
    ERROR_DUP_NAME -- The name is invalid for this type

--*/
{

    //
    // This version that takes a clear text password isn't supported.
    //

    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS
NET_API_FUNCTION
NetrRenameMachineInDomain(
    IN  LPWSTR  lpServer OPTIONAL,
    IN  LPWSTR  lpNewMachineName OPTIONAL,
    IN  LPWSTR  lpAccount OPTIONAL,
    IN  LPWSTR  lpPassword OPTIONAL,
    IN  DWORD   fRenameOptions
    )
/*++

Routine Description:

    Renames a machine currently joined to a domain.

Arguments:

    lpServer -- Name of the machine being run on

    lpNewMachineName -- New name for this machine.  If the name is specified, it is used
      for the new machine name.  If it is not specified, it is assumed that SetComputerName
      has already been invoked, and that name will be used.

    lpAccount -- Account to use for the rename

    lpPassword -- Password matching the account.  The password has been encoded.  The first
                  WCHAR of the string is the seed.

    fOptions -- Options to use for the rename

Returns:

    NERR_Success -- Success

    ERROR_INVALID_PARAMETER --  A bad parameter was given

--*/
{

    //
    // This version that takes a clear text password isn't supported.
    //

    return ERROR_NOT_SUPPORTED;
}

NET_API_STATUS
NET_API_FUNCTION
NetrGetJoinableOUs(
    IN  LPWSTR   lpServer OPTIONAL,
    IN  LPWSTR   lpDomain,
    IN  LPWSTR   lpAccount OPTIONAL,
    IN  LPWSTR   lpPassword OPTIONAL,
    OUT DWORD   *OUCount,
    OUT LPWSTR **OUs
    )
/*++

Routine Description:

    Renames a machine currently joined to a domain.

Arguments:

    lpServer -- Name of the machine being run on
    lpDomain -- Domain to join
    lpAccount -- Account to use for join
    lpPassword -- Password matching the account.  The password has been encoded and the first
                  WCHAR of the name is the seed
    MachineAccountOUs -- Where the information is returned.

Returns:

    NERR_Success -- Success

    ERROR_INVALID_PARAMETER --  A bad parameter was given

--*/
{

    //
    // This version that takes a clear text password isn't supported.
    //

    return ERROR_NOT_SUPPORTED;
}


//
// Computer rename preparation APIs
//

NET_API_STATUS
NetpSetPrimarySamAccountName(
    IN LPWSTR DomainController,
    IN LPWSTR CurrentSamAccountName,
    IN LPWSTR NewSamAccountName,
    IN LPWSTR DomainAccountName,
    IN LPWSTR DomainAccountPassword
    )
/*++

Routine Description:

    Sets primary SAM account name and teh display name on the
    computer object in the DS.

Arguments:

    DomainController -- DC name where to modify the computer object.

    CurrentSamAccountName -- The current value of SAM account name.

    NewSamAccountName -- The new value of SAM account name to be set.

    DomainAccount -- Domain account to use for accessing the machine
        account object in the DS. May be NULL in which case the
        credentials of the user executing this routine are used.

    DomainAccountPassword -- Password matching the domain account.
        May be NULL in which case the credentials of the user executing
        this routine are used.

Note:

    This routine uses NetUserSetInfo, downlevel SAM based API.
    NetUserSetInfo has an advantage such that it updates the DN of the
    computer object to correspond to the new SAM account name.  Also,
    for a DC's computer object, it follows the serverReferenceBL attribute
    link and updates the DN of the server object in the Config container.
    The server object in the Config container, in its turn, has a reference
    to the computer object (serverReference attrib) -- that reference also
    gets updated as the result of NetUserSetInfo call. Updating the two
    objects through ldap (instead of NetuserSetInfo) currently can't be done
    as one transaction, so we use NetUserSetInfo to do all this for us. We
    may reconsider the use of ldap once transactional ldap (i.e. several
    ldap operations performed as one transaction) becomes available.

Returns:

    NO_ERROR -- Success

    Otherwise, error returned by NetUserSetInfo.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    NET_API_STATUS TmpNetStatus = NO_ERROR;
    USER_INFO_0 NetUI0;
    PUSER_INFO_10 usri10 = NULL;
    BOOLEAN Connected = FALSE;

    //
    // Connect to the DC
    //

    NetStatus = NetpManageIPCConnect( DomainController,
                                      DomainAccountName,
                                      DomainAccountPassword,
                                      NETSETUPP_CONNECT_IPC );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpSetPrimarySamAccountName: NetpManageIPCConnect failed to connect to %ws: 0x%lx\n",
                  DomainController,
                  NetStatus ));
        goto Cleanup;
    }

    Connected = TRUE;

    //
    // Set the SAM account name
    //

    NetUI0.usri0_name = NewSamAccountName;
    NetStatus = NetUserSetInfo( DomainController,
                                CurrentSamAccountName,
                                0,
                                (PBYTE)&NetUI0,
                                NULL );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpSetPrimarySamAccountName: NetUserSetInfo failed on %ws: 0x%lx\n",
                  DomainController,
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Update the display name as well.
    //  Ignore error as this is not critical.
    //
    // First get the current display name
    //

    TmpNetStatus = NetUserGetInfo( DomainController,
                                   NewSamAccountName,
                                   10,
                                   (PBYTE *)&usri10 );

    if ( TmpNetStatus != NERR_Success ) {
        NetpLog(( "NetpSetPrimarySamAccountName: failed to get display name on %ws (ignored) 0x%lx\n",
                  DomainController,
                  TmpNetStatus ));

    //
    // If the display name exists and is
    //  different from the new one, update it
    //

    } else if ( usri10->usri10_full_name != NULL &&
                _wcsicmp(usri10->usri10_full_name, NewSamAccountName) != 0 ) {

        USER_INFO_1011 usri1011;

        usri1011.usri1011_full_name = NewSamAccountName;  // new name
        TmpNetStatus = NetUserSetInfo( DomainController,
                                       NewSamAccountName,
                                       1011,
                                       (PBYTE)&usri1011,
                                       NULL );

        if ( TmpNetStatus != NERR_Success ) {
            NetpLog(( "NetpSetPrimarySamAccountName: failed to update display name on %ws (ignored) 0x%lx\n",
                      DomainController,
                      TmpNetStatus ));
        }
    }

Cleanup:

    if ( usri10 != NULL ) {
        NetApiBufferFree( usri10 );
    }

    if ( Connected ) {
        TmpNetStatus = NetpManageIPCConnect( DomainController,
                                             DomainAccountName,
                                             DomainAccountPassword,
                                             NETSETUPP_DISCONNECT_IPC );
        if ( TmpNetStatus != NO_ERROR ) {
            NetpLog(( "NetpSetPrimarySamAccountName: NetpManageIPCConnect failed to disconnect from %ws: 0x%lx\n",
                      DomainController,
                      TmpNetStatus ));
        }
    }

    return NetStatus;
}

#define NET_ADD_ALTERNATE_COMPUTER_NAME    1
#define NET_DEL_ALTERNATE_COMPUTER_NAME    2
#define NET_SET_PRIMARY_COMPUTER_NAME      3

NET_API_STATUS
NET_API_FUNCTION
NetpManageAltComputerName(
    IN handle_t RpcBindingHandle,
    IN LPWSTR  AlternateName,
    IN ULONG Action,
    IN LPWSTR  DomainAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    IN ULONG Reserved
    )
/*++

Routine Description:

    Manages the alternate names for the specified server.

Arguments:

    AlternateName -- The name to add.

    Action -- Specifies action to take on the name:

        NET_ADD_ALTERNATE_COMPUTER_NAME - Add the alternate name.
        NET_DEL_ALTERNATE_COMPUTER_NAME - Delete the alternate name.
        NET_SET_PRIMARY_COMPUTER_NAME - Set the alternate name as
            the primary computer name.

    DomainAccount -- Domain account to use for accessing the
        machine account object for the specified server in the AD.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    DomainAccountPassword -- Password matching the domain account.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

Note:

    The process that calls this routine must have administrator
    privileges on the local computer to perform the local computer
    name modifications. The access check is performed by the local
    information APIs.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LdapStatus = LDAP_SUCCESS;
    NT_PRODUCT_TYPE NtProductType;
    LSA_HANDLE LocalPolicyHandle = NULL;
    PPOLICY_DNS_DOMAIN_INFO LocalPolicyDns = NULL;


    ULONG PrimaryNameSize = DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR);
    WCHAR NewNetbiosMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR ComputerName = NULL;
    LPWSTR MachineAccountName = NULL;
    LPWSTR NewMachineAccountName = NULL;
    LPWSTR AccountUserName = NULL;
    LPWSTR AccountDomainName = NULL;
    LPWSTR DomainAccountPassword = NULL;
    LPWSTR MachineAccountNameToCrack = NULL; // not allocated
    LPWSTR NameToCrack = NULL;
    LPWSTR PrimaryName = NULL;
    BOOLEAN ClientImpersonated = FALSE;
    BOOLEAN NameModifiedLocally = FALSE;
    BOOLEAN PrimarySamAccountNameSet = FALSE;
    BOOLEAN ToldNetlogonToAvoidDnsHostNameUpdate = FALSE;
    BOOLEAN StopedNetlogon = FALSE;

    SERVICE_STATUS NetlogonServiceStatus;
    LPQUERY_SERVICE_CONFIG NetlogonServiceConfig = NULL;


    RPC_AUTH_IDENTITY_HANDLE AuthId = 0;
    HANDLE hDs = NULL;
    PLDAP LdapHandle = NULL;
    LONG LdapOption;
    OBJECT_ATTRIBUTES OA;
    PDS_NAME_RESULTW CrackedName = NULL;

    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL;
    PWSTR AlternateNameValues[2];
    PWSTR DnsHostNameValues[2];
    PWSTR PrimaryNameValues[2];
    LDAPModW DnsHostNameMod;
    LDAPModW PrimaryNameMod;
    LDAPModW AlternateDnsHostNameMod;
    LDAPModW *ModList[4] = {NULL};
    ULONG ModCount = 0;

    SEC_WINNT_AUTH_IDENTITY AuthIdent = {0};

    //
    // Ldap modify server control
    //
    // An LDAP modify request will normally fail if it attempts
    //  to add an attribute that already exists, or if it attempts
    //  to delete an attribute that does not exist. With this control,
    //  as long as the attribute to be added has the same value as
    //  the existing attribute, then the modify will succeed. With
    //  this control, deletion of an attribute that doesn't exist
    //  will also succeed.
    //

    LDAPControlW    ModifyControl =
                    {
                        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                        {
                            0, NULL
                        },
                        FALSE
                    };

    PLDAPControlW   ModifyControlArray[2] =
                    {
                        &ModifyControl,
                        NULL
                    };

    //
    // Initialize the log file
    //

    NetSetuppOpenLog();
    NetpLog(( "NetpManageAltComputerName called:\n" ));
    NetpLog(( " AlternateName = %ws\n", AlternateName ));
    NetpLog(( " DomainAccount = %ws\n", DomainAccount ));
    NetpLog(( " Action = 0x%lx\n", Action ));
    NetpLog(( " Flags = 0x%lx\n", Reserved ));

    //
    // This API is supported on DCs and servers only
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        NtProductType = NtProductWinNt;
    }

    if ( NtProductType != NtProductServer &&
         NtProductType != NtProductLanManNt ) {

        NetpLog(( "NetpManageAltComputerName: Not supported on wksta: %lu\n",
                  NtProductType ));
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Validate the Flags
    //
    // If some flags are passed which we don't understand
    //  and we are not told to ignore them, error out.
    //

    if ( Reserved != 0 &&
         (Reserved & NET_IGNORE_UNSUPPORTED_FLAGS) == 0 ) {
        NetpLog(( "NetpManageAltComputerName: Invalid Flags passed\n" ));
        NetStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // Validate the alternate name passed
    //

    NetStatus = DnsValidateName_W( AlternateName, DnsNameHostnameFull );

    if ( NetStatus != NO_ERROR && NetStatus != DNS_ERROR_NON_RFC_NAME ) {
        NetpLog(( "NetpManageAltComputerName: DnsValidateName failed: 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Decrypt the domain account password
    //

    NetStatus = JoinpDecryptPasswordWithKey(
                            RpcBindingHandle,
                            EncryptedPassword,
                            FALSE,  // don't encode the password
                            &DomainAccountPassword );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: JoinpDecryptPasswordWithKey failed: 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    //
    // If there is no domain account passed,
    //  ignore the domain account password (if any)
    //

    if ( DomainAccount == NULL &&
         DomainAccountPassword != NULL ) {

        NetpMemoryFree( DomainAccountPassword );
        DomainAccountPassword = NULL;
    }

    //
    // Separate the domain account into
    //  the user and domain parts for later use
    //

    if ( DomainAccount != NULL ) {
        NetStatus = NetpSeparateUserAndDomain( DomainAccount,
                                               &AccountUserName,
                                               &AccountDomainName );
    }

    if ( NetStatus != NERR_Success ) {
        NetpLog(( "NetpGetComputerObjectDn: Cannot NetpSeparateUserAndDomain 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Get the current Netbios machine name
    //

    NetStatus = NetpGetComputerName( &ComputerName );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: NetpGetComputerName failed: 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Get SAM machine account name from the Netbios machine name
    //

    NetStatus = NetpGetMachineAccountName( ComputerName, &MachineAccountName );
    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: NetpGetMachineAccountName failed: 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Get the current primary DNS host name
    //

    PrimaryName = LocalAlloc( LMEM_ZEROINIT, PrimaryNameSize );

    if ( PrimaryName == NULL ) {
        NetpLog(( "NetpManageAltComputerName: LocalAlloc for PrimaryName failed\n" ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    NetStatus = EnumerateLocalComputerNamesW(
                      PrimaryComputerName,  // type of name
                      0,                    // reserved
                      PrimaryName,
                      &PrimaryNameSize );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: EnumerateLocalComputerNamesW failed with Size 0x%lx: 0x%lx\n",
                  PrimaryNameSize,
                  NetStatus ));
        goto Cleanup;
    }

    //
    // If we are to rename the machine,
    //  get the new machine account name from
    //  the DNS name passed
    //

    if ( Action == NET_SET_PRIMARY_COMPUTER_NAME ) {
        ULONG Size = MAX_COMPUTERNAME_LENGTH + 1;

        if ( !DnsHostnameToComputerNameW(AlternateName,
                                         NewNetbiosMachineName,
                                         &Size) ) {
            NetStatus = GetLastError();
            NetpLog(( "NetpManageAltComputerName: DnsHostnameToComputerNameW failed: 0x%lx\n",
                      NetStatus ));
            goto Cleanup;
        }

        //
        // Get the new SAM machine account name from the new Netbios machine name
        //
        NetStatus = NetpGetMachineAccountName( NewNetbiosMachineName, &NewMachineAccountName );
        if ( NetStatus != NO_ERROR ) {
            NetpLog(( "NetpManageAltComputerName: NetpGetMachineAccountName (2) failed: 0x%lx\n",
                      NetStatus ));
            goto Cleanup;
        }
    }

    //
    // Open the local LSA policy
    //

    InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL );

    Status = LsaOpenPolicy( NULL,
                            &OA,
                            MAXIMUM_ALLOWED,
                            &LocalPolicyHandle );

    if ( !NT_SUCCESS(Status) ) {
        NetpLog(( "NetpManageAltComputerName: LsaOpenPolicy failed: 0x%lx\n",
                  Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Get the current domain information from LSA
    //

    Status = LsaQueryInformationPolicy( LocalPolicyHandle,
                                        PolicyDnsDomainInformation,
                                        (PVOID *) &LocalPolicyDns );

    if ( !NT_SUCCESS(Status) ) {
        NetpLog(( "NetpManageAltComputerName: LsaQueryInformationPolicy failed: 0x%lx\n",
                  Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Do the local opperation for the specified alternate name
    //
    // Impersonate the caller. The local API will perform the
    //  access check on the caller on our behalf.
    //

    NetStatus = WsImpersonateClient();

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: WsImpersonateClient failed: 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    ClientImpersonated = TRUE;

    //
    // Do local operations
    //

    if ( Action == NET_ADD_ALTERNATE_COMPUTER_NAME ) {

        NetStatus = AddLocalAlternateComputerName( AlternateName,
                                                   0 );  // reserved

        if ( NetStatus != NO_ERROR ) {
            NetpLog(( "NetpManageAltComputerName: AddLocalAlternateComputerName failed 0x%lx\n",
                      NetStatus ));
            goto Cleanup;
        }

    } else if ( Action == NET_DEL_ALTERNATE_COMPUTER_NAME ) {

        NetStatus = RemoveLocalAlternateComputerName( AlternateName,
                                                      0 );  // reserved

        if ( NetStatus != NO_ERROR ) {
            NetpLog(( "NetpManageAltComputerName: RemoveLocalAlternateComputerName failed 0x%lx\n",
                      NetStatus ));
            goto Cleanup;
        }

    } else if ( Action == NET_SET_PRIMARY_COMPUTER_NAME ) {

        NetStatus = SetLocalPrimaryComputerName( AlternateName,
                                                 0 );  // reserved

        if ( NetStatus != NO_ERROR ) {
            NetpLog(( "NetpManageAltComputerName: SetLocalPrimaryComputerName failed 0x%lx\n",
                      NetStatus ));
            goto Cleanup;
        }
    }

    NameModifiedLocally = TRUE;

    //
    // We are done with local operations; we are going
    //  to do remote operations on the DC next.
    //
    //  If the user credentials are supplied, revert
    //  the impersonation -- we will access the remote
    //  server with explicit credentials supplied.
    //  Otherwise, access the DC while running in the
    //  user context.
    //

    if ( DomainAccount != NULL ) {
        WsRevertToSelf();
        ClientImpersonated = FALSE;
    }

    //
    // If this machine is not joined to an AD domain,
    //  there is nothing to do on the DC.
    //

    if ( LocalPolicyDns->Sid == NULL ||
         LocalPolicyDns->DnsDomainName.Length == 0 ) {

        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // Discover a DC for the domain of this machine
    //  to modify the computer object in the DS.
    //

    NetStatus = DsGetDcNameWithAccountW(
                  NULL,
                  MachineAccountName,
                  UF_WORKSTATION_TRUST_ACCOUNT | UF_SERVER_TRUST_ACCOUNT,
                  NULL,
                  NULL,
                  NULL,
                  DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                  &DcInfo );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: DsGetDcNameWithAccountW failed 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    //
    // If this machine is a DC, verify that we got it.
    //  We do this because we want to avoid inconsistent
    //  state where the local name stored in registry
    //  is different from name stored locally in the DS.
    //

    if ( NtProductType == NtProductLanManNt &&
         !DnsNameCompare_W(PrimaryName, DcInfo->DomainControllerName+2) ) {

        NetpLog(( "NetpManageAltComputerName: Got different DC '%ws' than local DC '%ws'\n",
                  DcInfo->DomainControllerName+2,
                  PrimaryName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // We've got a DC. Bind to the DS to get the DN
    //  for our machine account and do a LDAP connect
    //  to modify our machine account given the DN
    //

    NetStatus = DsMakePasswordCredentials( AccountUserName,
                                           AccountDomainName,
                                           DomainAccountPassword,
                                           &AuthId );
    if ( NetStatus != NERR_Success ) {
        NetpLog(( "NetpManageAltComputerName: DsMakePasswordCredentials failed 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Bind to the DS on the DC.
    //

    NetStatus = DsBindWithCredW( DcInfo->DomainControllerName,
                                 NULL,
                                 AuthId,
                                 &hDs );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: DsBindWithCredW failed to '%ws': 0x%lx\n",
                  DcInfo->DomainControllerName,
                  NetStatus ));
        goto Cleanup ;
    }

    //
    // Open an LDAP connection to the DC and set useful options
    //

    LdapHandle = ldap_initW( DcInfo->DomainControllerName+2,
                             LDAP_PORT );

    if ( LdapHandle == NULL ) {
        LdapStatus = LdapGetLastError();
        NetpLog(( "NetpManageAltComputerName: ldap_init to %ws failed: %lu\n",
                  DcInfo->DomainControllerName+2,
                  LdapStatus ));
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;
    }

    //
    // Tell LDAP to avoid chasing referals
    //

    LdapOption = PtrToLong( LDAP_OPT_OFF );
    LdapStatus = ldap_set_optionW( LdapHandle,
                                   LDAP_OPT_REFERRALS,
                                   &LdapOption );

    if ( LdapStatus != LDAP_SUCCESS ) {
        NetpLog(( "NetpManageAltComputerName: ldap_set_option LDAP_OPT_REFERRALS failed on %ws: %ld: %s\n",
                  DcInfo->DomainControllerName+2,
                  LdapStatus,
                  ldap_err2stringA(LdapStatus) ));
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;
    }

    //
    // Tell LDAP we are passing an explicit DC name
    //  to avoid the DC discovery
    //

    LdapOption = PtrToLong( LDAP_OPT_ON );
    LdapStatus = ldap_set_optionW( LdapHandle,
                                   LDAP_OPT_AREC_EXCLUSIVE,
                                   &LdapOption );

    if ( LdapStatus != LDAP_SUCCESS ) {
        NetpLog(( "NetpManageAltComputerName: ldap_set_option LDAP_OPT_AREC_EXCLUSIVE failed on %ws: %ld: %s\n",
                  DcInfo->DomainControllerName+2,
                  LdapStatus,
                  ldap_err2stringA(LdapStatus) ));
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;
    }

    //
    // Bind to the LDAP server
    //

    if ( AccountUserName != NULL ) {
        AuthIdent.User = AccountUserName;
        AuthIdent.UserLength = wcslen( AccountUserName );
    }

    if ( AccountDomainName != NULL ) {
        AuthIdent.Domain = AccountDomainName;
        AuthIdent.DomainLength = wcslen( AccountDomainName );
    }

    if ( DomainAccountPassword != NULL ) {
        AuthIdent.Password = DomainAccountPassword;
        AuthIdent.PasswordLength = wcslen( DomainAccountPassword );
    }

    AuthIdent.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    LdapStatus = ldap_bind_sW( LdapHandle,
                               NULL,
                               (PWSTR) &AuthIdent,
                               LDAP_AUTH_NEGOTIATE );

    if ( LdapStatus != LDAP_SUCCESS ) {
        NetpLog(( "NetpManageAltComputerName: ldap_bind failed on %ws: %ld: %s\n",
                  DcInfo->DomainControllerName+2,
                  LdapStatus,
                  ldap_err2stringA(LdapStatus) ));
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;
    }

    //
    // Ok, now that we have all prerequsites satisfied,
    //  do the operations that may require rollback if
    //  they fail.
    //
    // Set the primary SAM account name by doing NetSetUser.
    //  Note that this will also rename the DN of the computer
    //  object (and its display name) and the DN of the server
    //  object linked to from the computer object if this is a DC.
    //

    if ( Action == NET_SET_PRIMARY_COMPUTER_NAME ) {
        NetStatus = NetpSetPrimarySamAccountName(
                             DcInfo->DomainControllerName,
                             MachineAccountName,
                             NewMachineAccountName,
                             DomainAccount,
                             DomainAccountPassword );

        if ( NetStatus != NO_ERROR ) {
            NetpLog(( "NetpManageAltComputerName: NetpSetPrimarySamAccountName failed on %ws: 0x%lx\n",
                      DcInfo->DomainControllerName,
                      NetStatus ));
            goto Cleanup;
        }
        PrimarySamAccountNameSet = TRUE;

        //
        // We need to crack the new machine account
        //  name which we just set
        //
        MachineAccountNameToCrack = NewMachineAccountName;

    //
    // If we are not changing the primary name,
    //  the name to crack is the current machine name.
    //

    } else {
        MachineAccountNameToCrack = MachineAccountName;
    }

    //
    // Now get the DN for our machine account object
    //  in the DS. Do this after setting the SAM account
    //  name as it changes the DN.
    //
    // Form the NT4 account name 'domain\account' to crack
    //  it into the DN.
    //

    NameToCrack = LocalAlloc( LMEM_ZEROINIT,
                              LocalPolicyDns->Name.Length +   // Netbios domain name
                               (1 +                           // backslash
                                wcslen(MachineAccountNameToCrack) +  // SAM account name
                                1) * sizeof(WCHAR) );         // NULL terminator

    if ( NameToCrack == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( NameToCrack,
                   LocalPolicyDns->Name.Buffer,
                   LocalPolicyDns->Name.Length );

    wcscat( NameToCrack, L"\\" );
    wcscat( NameToCrack, MachineAccountNameToCrack );

    //
    // Crack the account name into a DN
    //

    NetStatus = DsCrackNamesW( hDs,
                               0,
                               DS_NT4_ACCOUNT_NAME,
                               DS_FQDN_1779_NAME,
                               1,
                               &NameToCrack,
                               &CrackedName );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: DsCrackNames failed on '%ws' for %ws: 0x%lx\n",
                  DcInfo->DomainControllerName,
                  NameToCrack,
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Check for consistency
    //

    if ( CrackedName->rItems[0].status != DS_NAME_NO_ERROR ) {
        NetpLog(( "NetpManageAltComputerName: CrackNames failed for %ws: substatus 0x%lx\n",
                  NameToCrack,
                  CrackedName->rItems[0].status ));
        NetStatus = NetpCrackNamesStatus2Win32Error( CrackedName->rItems[0].status );
        goto Cleanup;
    }

    if ( CrackedName->cItems > 1 ) {
        NetStatus = ERROR_DS_NAME_ERROR_NOT_UNIQUE;
        NetpLog(( "NetpManageAltComputerName: Cracked Name %ws is not unique on %ws: %lu\n",
                  NameToCrack,
                  DcInfo->DomainControllerName,
                  CrackedName->cItems ));
        goto Cleanup;
    }

    //
    // Ok, we have our machine account DN. Proceed with modifying
    //  our machine account object in the DS.
    //
    // If we are seting new DnsHostName, we have to stop netlogon
    //  and tell it not to update this attribute before the
    //  reboot.
    //

    if ( Action == NET_SET_PRIMARY_COMPUTER_NAME ) {

        //
        // First get the current status of netlogon so that
        //  we can roll back properly on failure
        //
        NetStatus = NetpQueryService( SERVICE_NETLOGON,
                                      &NetlogonServiceStatus,
                                      &NetlogonServiceConfig );

        if ( NetStatus != NO_ERROR ) {
            NetpLog(( "NetpManageAltComputerName: NetpQueryService failed 0x%lx\n",
                      NetStatus ));
            goto Cleanup;
        }

        //
        // Stop netlogon if it's running
        //
        if ( NetlogonServiceStatus.dwCurrentState != SERVICE_STOPPED ) {
            NetStatus = NetpControlServices( NETSETUP_SVC_STOPPED,
                                             NETSETUPP_SVC_NETLOGON );
            if ( NetStatus != NO_ERROR ) {
                NetpLog(( "NetpManageAltComputerName: NetpControlServices failed 0x%lx\n",
                          NetStatus ));
                goto Cleanup;
            }
            StopedNetlogon = TRUE;
        }

        //
        // Tell netlogon not to update DnsHostName until reboot
        //  in case the user decides to start netlogon before reboot
        //  for some reason
        //
        NetpAvoidNetlogonSpnSet( TRUE );
        ToldNetlogonToAvoidDnsHostNameUpdate = TRUE;
    }


    //
    // Prepare attributes that need to be set in the DS
    //
    // If we are seting a primary name, we need to set
    //  DnsHostName attribute. Also, we need to add the
    //  current primary computer name to the additional
    //  DNS host name list.
    //

    if ( Action == NET_SET_PRIMARY_COMPUTER_NAME ) {
        DnsHostNameValues[0] = AlternateName;
        DnsHostNameValues[1] = NULL;

        DnsHostNameMod.mod_type   = L"DnsHostName";
        DnsHostNameMod.mod_values = DnsHostNameValues;
        DnsHostNameMod.mod_op = LDAP_MOD_REPLACE;

        ModList[ModCount++] = &DnsHostNameMod;

        //
        // Add the current primary to additional list
        //
        PrimaryNameValues[0] = PrimaryName;
        PrimaryNameValues[1] = NULL;

        PrimaryNameMod.mod_type   = L"msDS-AdditionalDnsHostName";
        PrimaryNameMod.mod_values = PrimaryNameValues;
        PrimaryNameMod.mod_op = LDAP_MOD_ADD;

        ModList[ModCount++] = &PrimaryNameMod;
    }

    //
    // Prepare the additional DNS host name modification.
    //
    //  Note that we don't need to manipulate the additional
    //  SAM account name as it will be added/deleted by the DS
    //  itself as the result of the AdditionalDnsHostName update.
    //

    AlternateNameValues[0] = AlternateName;
    AlternateNameValues[1] = NULL;

    AlternateDnsHostNameMod.mod_type   = L"msDS-AdditionalDnsHostName";
    AlternateDnsHostNameMod.mod_values = AlternateNameValues;

    //
    // If we are additing an alternate name, the operation
    //  is add.  Otherwise, we are deleting the alternate
    //  name or setting the alternate name as primary: in
    //  both cases the alternate name should be deleted
    //  from the additional name attribute list.
    //

    if ( Action == NET_ADD_ALTERNATE_COMPUTER_NAME ) {
        AlternateDnsHostNameMod.mod_op = LDAP_MOD_ADD;
    } else {
        AlternateDnsHostNameMod.mod_op = LDAP_MOD_DELETE;
    }

    ModList[ModCount++] = &AlternateDnsHostNameMod;

    //
    // Write the modifications
    //

    LdapStatus = ldap_modify_ext_sW( LdapHandle,
                                     CrackedName->rItems[0].pName,  // DN of account
                                     ModList,
                                     ModifyControlArray,  // server controls
                                     NULL );              // no client controls

    if ( LdapStatus != LDAP_SUCCESS ) {
        NetpLog(( "NetpManageAltComputerName: ldap_modify_ext_s failed on %ws: %ld: %s\n",
                 DcInfo->DomainControllerName+2,
                 LdapStatus,
                 ldap_err2stringA(LdapStatus) ));
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;
    }

Cleanup:

    //
    // Revert impersonation
    //

    if ( ClientImpersonated ) {
        WsRevertToSelf();
    }

    //
    // On error, revert the changes. Do this after reverting
    //  impersonation to have as much (LocalSystem) access
    //  as one possibly can.
    //
    //  Note that we don't need to revert ldap modifications
    //  because they were made as the last step.
    //

    if ( NetStatus != NO_ERROR && NameModifiedLocally ) {
        NET_API_STATUS TmpNetStatus = NO_ERROR;

        //
        // If we added an alternate name, remove it
        //
        if ( Action == NET_ADD_ALTERNATE_COMPUTER_NAME ) {

            TmpNetStatus = RemoveLocalAlternateComputerName( AlternateName,
                                                             0 );  // reserved
            if ( TmpNetStatus != NO_ERROR ) {
                NetpLog(( "NetpManageAltComputerName: (rollback) RemoveLocalAlternateComputerName failed 0x%lx\n",
                          TmpNetStatus ));
            }

        //
        // If we removed an alternate name, add it
        //
        } else if ( Action == NET_DEL_ALTERNATE_COMPUTER_NAME ) {

            TmpNetStatus = AddLocalAlternateComputerName( AlternateName,
                                                          0 );  // reserved
            if ( TmpNetStatus != NO_ERROR ) {
                NetpLog(( "NetpManageAltComputerName: (rollback) AddLocalAlternateComputerName failed 0x%lx\n",
                          TmpNetStatus ));
            }

        //
        // If we set a new primary name, reset it to the previous value
        //
        } else if ( Action == NET_SET_PRIMARY_COMPUTER_NAME ) {

            TmpNetStatus = SetLocalPrimaryComputerName( PrimaryName,
                                                        0 );  // reserved

            if ( TmpNetStatus != NO_ERROR ) {
                NetpLog(( "NetpManageAltComputerName: (rollback) SetLocalPrimaryComputerName failed 0x%lx\n",
                          TmpNetStatus ));
            }
        }
    }

    if ( NetStatus != NO_ERROR && PrimarySamAccountNameSet ) {
        NET_API_STATUS TmpNetStatus = NO_ERROR;

        TmpNetStatus = NetpSetPrimarySamAccountName(
                             DcInfo->DomainControllerName,
                             NewMachineAccountName,  // the changed name
                             MachineAccountName,     // old name to restore
                             DomainAccount,
                             DomainAccountPassword );

        if ( TmpNetStatus != NO_ERROR) {
            NetpLog(( "NetpManageAltComputerName: NetpSetPrimarySamAccountName (rollback) failed on %ws: 0x%lx\n",
                      DcInfo->DomainControllerName,
                      TmpNetStatus ));
        }
    }

    //
    // On error, take back what we told netlogon
    //  w.r.t. the DnsHostName update
    //

    if ( NetStatus != NO_ERROR && ToldNetlogonToAvoidDnsHostNameUpdate ) {
        NetpAvoidNetlogonSpnSet( FALSE );
    }

    //
    // On error, restart netlogon if we stoped it
    //

    if ( NetStatus != NO_ERROR && StopedNetlogon ) {
        NET_API_STATUS TmpNetStatus = NO_ERROR;
        TmpNetStatus = NetpControlServices( NETSETUP_SVC_STARTED,
                                            NETSETUPP_SVC_NETLOGON );

        if ( TmpNetStatus != NO_ERROR ) {
            NetpLog(( "NetpManageAltComputerName: (rollback) Failed starting netlogon: 0x%lx\n",
                      TmpNetStatus ));
        }
    }

    //
    // Close the log file
    //

    NetSetuppCloseLog();

    //
    // Finally free the memory
    //

    if ( DomainAccountPassword != NULL ) {
        NetpMemoryFree( DomainAccountPassword );
    }

    if ( AccountUserName != NULL ) {
        NetApiBufferFree( AccountUserName );
    }

    if ( AccountDomainName != NULL ) {
        NetApiBufferFree( AccountDomainName );
    }

    if ( ComputerName != NULL ) {
        NetApiBufferFree( ComputerName );
    }

    if ( MachineAccountName != NULL ) {
        NetApiBufferFree( MachineAccountName );
    }

    if ( NewMachineAccountName != NULL ) {
        NetApiBufferFree( NewMachineAccountName );
    }

    if ( PrimaryName != NULL ) {
        LocalFree( PrimaryName );
    }

    if ( NameToCrack != NULL ) {
        LocalFree( NameToCrack );
    }

    if ( NetlogonServiceConfig != NULL ) {
        LocalFree( NetlogonServiceConfig );
    }

    if ( LocalPolicyDns != NULL ) {
        LsaFreeMemory( LocalPolicyDns );
    }

    if ( LocalPolicyHandle != NULL ) {
        LsaClose( LocalPolicyHandle );
    }

    if ( DcInfo != NULL ) {
        NetApiBufferFree( DcInfo );
    }

    if ( AuthId ) {
        DsFreePasswordCredentials( AuthId );
    }

    if ( CrackedName ) {
        DsFreeNameResultW( CrackedName );
    }

    if ( hDs ) {
        DsUnBind( &hDs );
    }

    if ( LdapHandle != NULL ) {
        ldap_unbind_s( LdapHandle );
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetrAddAlternateComputerName(
    IN handle_t RpcBindingHandle,
    IN LPWSTR  ServerName OPTIONAL,
    IN LPWSTR  AlternateName,
    IN LPWSTR  DomainAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    IN ULONG Reserved
    )
/*++

Routine Description:

    Adds an alternate name for the specified server.

Arguments:

    ServerName -- Name of server on which to execute this function.

    AlternateName -- The name to add.

    DomainAccount -- Domain account to use for accessing the
        machine account object for the specified server in the AD.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    DomainAccountPassword -- Password matching the domain account.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

Note:

    The process that calls this routine must have administrator
    privileges on the server computer.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    //
    // Call the common routine
    //

    return NetpManageAltComputerName(
                 RpcBindingHandle,
                 AlternateName,
                 NET_ADD_ALTERNATE_COMPUTER_NAME,
                 DomainAccount,
                 EncryptedPassword,
                 Reserved );
}

NET_API_STATUS
NET_API_FUNCTION
NetrRemoveAlternateComputerName(
    IN handle_t RpcBindingHandle,
    IN LPWSTR  ServerName OPTIONAL,
    IN LPWSTR  AlternateName,
    IN LPWSTR  DomainAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    IN ULONG Reserved
    )
/*++

Routine Description:

    Deletes an alternate name for the specified server.

Arguments:

    ServerName -- Name of server on which to execute this function.

    AlternateName -- The name to delete.

    DomainAccount -- Domain account to use for accessing the
        machine account object for the specified server in the AD.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    DomainAccountPassword -- Password matching the domain account.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

Note:

    The process that calls this routine must have administrator
    privileges on the server computer.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    //
    // Call the common routine
    //

    return NetpManageAltComputerName(
                 RpcBindingHandle,
                 AlternateName,
                 NET_DEL_ALTERNATE_COMPUTER_NAME,
                 DomainAccount,
                 EncryptedPassword,
                 Reserved );
}

NET_API_STATUS
NET_API_FUNCTION
NetrSetPrimaryComputerName(
    IN handle_t RpcBindingHandle,
    IN LPWSTR  ServerName OPTIONAL,
    IN LPWSTR  PrimaryName,
    IN LPWSTR  DomainAccount OPTIONAL,
    IN PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword OPTIONAL,
    IN ULONG Reserved
    )
/*++

Routine Description:

    Sets the primary computer name for the specified server.

Arguments:

    ServerName -- Name of server on which to execute this function.

    PrimaryName -- The primary computer name to set.

    DomainAccount -- Domain account to use for accessing the
        machine account object for the specified server in the AD.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    DomainAccountPassword -- Password matching the domain account.
        Not used if the server is not joined to a domain. May be
        NULL in which case the credentials of the user executing
        this routine are used.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

Note:

    The process that calls this routine must have administrator
    privileges on the server computer.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    //
    // Call the common routine
    //

    return NetpManageAltComputerName(
                 RpcBindingHandle,
                 PrimaryName,
                 NET_SET_PRIMARY_COMPUTER_NAME,
                 DomainAccount,
                 EncryptedPassword,
                 Reserved );
}

NET_API_STATUS
NET_API_FUNCTION
NetrEnumerateComputerNames(
    IN  LPWSTR ServerName OPTIONAL,
    IN  NET_COMPUTER_NAME_TYPE NameType,
    IN  ULONG Reserved,
    OUT PNET_COMPUTER_NAME_ARRAY *ComputerNames
    )
/*++

Routine Description:

    Enumerates computer names for the specified server.

Arguments:

    ServerName -- Name of server on which to execute this function.

    NameType -- The type of the name queried.

    Reserved -- Reserved for future use.  If some flags are specified
        that are not supported, they will be ignored if
        NET_IGNORE_UNSUPPORTED_FLAGS is set, otherwise this routine
        will fail with ERROR_INVALID_FLAGS.

    ComputerNames - Returns the computer names structure.

Returns:

    NO_ERROR -- Success

    ERROR_NOT_SUPPORTED -- The specified server does not support this
        functionality.

    ERROR_INVALID_FLAGS - The Flags parameter is incorrect.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    NT_PRODUCT_TYPE NtProductType;
    BOOL ClientImpersonated = FALSE;
    ULONG Size = 0;
    ULONG Index = 0;
    ULONG EntryCount = 0;

    LPWSTR LocalNames = NULL;
    PNET_COMPUTER_NAME_ARRAY LocalArray = NULL;
    LPTSTR_ARRAY TStrArray;

    //
    // Initialize the log file
    //

    NetSetuppOpenLog();
    NetpLog(( "NetrEnumerateComputerNames called: NameType = 0x%lx, Flags = 0x%lx\n",
              NameType, Reserved ));

    //
    // This API is supported on DCs and servers only
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        NtProductType = NtProductWinNt;
    }

    if ( NtProductType != NtProductServer &&
         NtProductType != NtProductLanManNt ) {

        NetpLog(( "NetrEnumerateComputerNames: Not supported on wksta: %lu\n",
                  NtProductType ));
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Validate the Flags
    //
    // If some flags are passed which we don't understand
    //  and we are not told to ignore them, error out.
    //

    if ( Reserved != 0 &&
         (Reserved & NET_IGNORE_UNSUPPORTED_FLAGS) == 0 ) {
        NetpLog(( "NetrEnumerateComputerNames: Invalid Flags passed\n" ));
        NetStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // Validate the name type
    //

    if ( NameType >= NetComputerNameTypeMax ) {
        NetpLog(( "NetrEnumerateComputerNames: Invalid name type passed %lu\n",
                  NameType ));
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Impersonate the caller. The local API will perform the
    //  access check on the caller on our behalf.
    //

    NetStatus = WsImpersonateClient();

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetrEnumerateComputerNames: WsImpersonateClient failed: 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    ClientImpersonated = TRUE;

    //
    // Get the size of the local data
    //

    NetStatus = EnumerateLocalComputerNamesW(
                                NameType,
                                0,         // reserved
                                LocalNames,
                                &Size );   // in characters, Null included

    //
    // Allocate memory for local names
    //

    if ( NetStatus != NO_ERROR ) {
        if ( NetStatus ==  ERROR_MORE_DATA ) {
            NetStatus = NetApiBufferAllocate( Size * sizeof(WCHAR), &LocalNames );
            if (  NetStatus != NO_ERROR ) {
                goto Cleanup;
            }
        } else {
            NetpLog(( "NetrEnumerateComputerNames: EnumerateLocalComputerNamesW failed 0x%lx\n",
                      NetStatus ));
            goto Cleanup;
        }
    }

    //
    // Get the names
    //

    NetStatus = EnumerateLocalComputerNamesW(
                                NameType,
                                0,          // reserved
                                LocalNames,
                                &Size );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetrEnumerateComputerNames: EnumerateLocalComputerNamesW (2) failed 0x%lx\n",
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Determine the length of the returned information
    //

    Size = sizeof( NET_COMPUTER_NAME_ARRAY );

    TStrArray = LocalNames;
    while ( !NetpIsTStrArrayEmpty(TStrArray) ) {

        Size += sizeof(UNICODE_STRING) + (wcslen(TStrArray) + 1) * sizeof(WCHAR);
        EntryCount++;
        TStrArray = NetpNextTStrArrayEntry( TStrArray );
    }

    //
    // Allocate the return buffer.
    //

    NetStatus = NetApiBufferAllocate( Size, &LocalArray );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    LocalArray->EntryCount = EntryCount;

    //
    // If there are names to return, copy them
    //  to the return buffer
    //

    if ( EntryCount == 0 ) {
        LocalArray->ComputerNames = NULL;
    } else {
        PUNICODE_STRING Strings;
        LPBYTE Where;

        Strings = (PUNICODE_STRING) (LocalArray + 1);
        LocalArray->ComputerNames = Strings;
        Where = (LPBYTE) &Strings[EntryCount];

        //
        // Loop copying the names into the return buffer.
        //

        Index = 0;
        TStrArray = LocalNames;
        while ( !NetpIsTStrArrayEmpty(TStrArray) ) {

            Strings[Index].Buffer = (LPWSTR) Where;
            Strings[Index].Length = wcslen(TStrArray) * sizeof(WCHAR);
            Strings[Index].MaximumLength = Strings[Index].Length + sizeof(WCHAR);

            RtlCopyMemory( Where, TStrArray, Strings[Index].MaximumLength );

            Where += Strings[Index].MaximumLength;
            Index++;
            TStrArray = NetpNextTStrArrayEntry( TStrArray );
        }
    }

    NetStatus = NO_ERROR;

Cleanup:

    //
    // Revert impersonation
    //

    if ( ClientImpersonated ) {
        WsRevertToSelf();
    }

    //
    // Return names on success or clean up on error
    //

    if ( NetStatus == NO_ERROR ) {

        *ComputerNames = LocalArray;

        //
        // Be verbose
        //
        if ( LocalArray->EntryCount > 0 ) {
            NetpLog(( "NetrEnumerateComputerNames: Returning names:" ));
            for ( Index = 0; Index < LocalArray->EntryCount; Index++ ) {
                NetpLog(( " %wZ", &(LocalArray->ComputerNames[Index]) ));
            }
            NetpLog(( "\n" ));
        } else {
            NetpLog(( "NetrEnumerateComputerNames: No names returned\n" ));
        }

    } else {
        if ( LocalArray != NULL ) {
            NetApiBufferFree( LocalArray );
        }
        NetpLog(( "NetrEnumerateComputerNames: Failed 0x%lx\n", NetStatus ));
    }

    if ( LocalNames != NULL ) {
        NetApiBufferFree( LocalNames );
    }

    //
    // Close the log file
    //

    NetSetuppCloseLog();

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\dominfo.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dominfo.h
//
//  Contents:   Code to figure out domain dfs addresses
//
//  Classes:    None
//
//  Functions:  DfsGetDomainReferral
//
//  History:    Feb 7, 1996     Milans created
//
//-----------------------------------------------------------------------------

#ifndef _DOMINFO_
#define _DOMINFO_

VOID
DfsInitDomainList();

NTSTATUS
DfsGetDomainReferral(
    LPWSTR wszDomainName,
    LPWSTR wszShareName);

NTSTATUS
DfsGetDCName(
    ULONG Flags,
    BOOLEAN *DcNameFailed);

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  ULONG OutputBufferLength);

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle,
    IN      PUNICODE_STRING DfsName OPTIONAL);

HANDLE
CreateMupEvent(
    VOID);

#endif // _DOMINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\dominfo.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dominfo.h
//
//  Contents:   Code to figure out domain dfs addresses
//
//  Classes:    None
//
//  Functions:
//
//  History:    Feb 7, 1996     Milans created
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <windows.h>

#include <dsgetdc.h>
#include <dsrole.h>
#include <wsutil.h>

#include "dominfo.h"

#define MUP_EVENT_NAME  TEXT("wkssvc:  MUP finished initializing event")

HANDLE
CreateMupEvent(void);

NTSTATUS
DfsGetDomainNameInfo(void);

HANDLE hMupEvent = NULL;
BOOLEAN MupEventSignaled = FALSE;
BOOLEAN GotDomainNameInfo = FALSE;
ULONG DfsDebug = 0;

//
// Commonly used strings and characters
//

#define UNICODE_PATH_SEP_STR    L"\\"
#define UNICODE_PATH_SEP        L'\\'
#define DNS_PATH_SEP            L'.'


//+----------------------------------------------------------------------------
//
//  Function:   DfsGetDCName
//
//  Synopsis:   Gets the name of a DC we can use for expanded name referrals
//              It will stick this into the driver.
//
//  Arguments:  [Flags] -- TBD
//
//  Returns:    [STATUS_SUCCESS] -- Successfully created domain pkt entry.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition.
//
//              [STATUS_OBJECT_NAME_NOT_FOUND] -- wszDomain is not a trusted
//                      domain.
//
//              [STATUS_UNEXPECTED_NETWORK_ERROR] -- Unable to get DC for
//                      domain.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetDCName(
    IN ULONG Flags,
    BOOLEAN *DcNameFailed)
{
    NTSTATUS            Status;
    HANDLE              hDfs;
    ULONG               cbSize;
    WCHAR               *DCName;
    ULONG               dwErr;
    ULONG               Len;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo;

    *DcNameFailed = TRUE;
#if DBG
    if (DfsDebug)
        DbgPrint("DfsGetDCName(%d)\n", Flags);
#endif

    if( WsInAWorkgroup() == TRUE ) {
        //
        // We are in a workgroup.  We will never find a DC!
        //
#if DBG
        if (DfsDebug)
            DbgPrint("DfsGetDCName exit STATUS_NO_SUCH_DOMAIN\n");
#endif
        return STATUS_NO_SUCH_DOMAIN;
    }

    if (hMupEvent == NULL) {

        hMupEvent = CreateMupEvent();

    }

    dwErr = DsGetDcName(
                NULL,   // Computername
                NULL,   // DomainName
                NULL,   // DomainGuid
                NULL,   // SiteGuid
                Flags | DS_DIRECTORY_SERVICE_REQUIRED,
                &pDomainControllerInfo);

    //
    //  If DsGetDcName succeeded, try to get the NetBios & Dns domain names.
    //

    if (dwErr != NO_ERROR) {

        if (MupEventSignaled == FALSE) {

#if DBG
            if (DfsDebug)
                DbgPrint("Signaling mup event\n");
#endif
            SetEvent(hMupEvent);
            MupEventSignaled = TRUE;

        }

        switch (dwErr) {
        case ERROR_NOT_ENOUGH_MEMORY:
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        case ERROR_NETWORK_UNREACHABLE:
            Status = STATUS_NETWORK_UNREACHABLE;
            break;
        default:
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
            break;
        }
#if DBG
        if (DfsDebug)
            DbgPrint("DfsGetDCName(1) exit 0x%x\n", Status);
#endif
        return (Status);
    } else {
        if (pDomainControllerInfo == NULL) {
            DbgBreakPoint();
        }
    }

    *DcNameFailed = FALSE;

    DfsGetDomainNameInfo();

    //
    // Remove leading '\'s
    //
    DCName = pDomainControllerInfo->DomainControllerName;
    while (*DCName == UNICODE_PATH_SEP && *DCName != UNICODE_NULL)
        DCName++;

    //
    // Remove trailing '.', if present
    //

    Len = wcslen(DCName);

    if (Len >= 1 && DCName[Len-1] == DNS_PATH_SEP) {

        DCName[Len-1] = UNICODE_NULL;

    }

    if (wcslen(DCName) <= 0) {
        NetApiBufferFree(pDomainControllerInfo);
#if DBG
        if (DfsDebug)
            DbgPrint("DfsGetDCName exit STATUS_UNEXPECTED_NETWORK_ERROR\n");
#endif
        return (STATUS_UNEXPECTED_NETWORK_ERROR);
    }

    Status = DfsOpen( &hDfs, NULL );

    if (!NT_SUCCESS(Status)) {
        NetApiBufferFree(pDomainControllerInfo);
#if DBG
        if (DfsDebug)
            DbgPrint("DfsGetDCName(2) exit 0x%x\n", Status);
#endif
        return (Status);
    }

    //
    // Take the name and fscontrol it down to the driver
    //

    cbSize = wcslen(DCName) * sizeof(WCHAR) + sizeof(WCHAR);

    Status = DfsFsctl(
                hDfs,
                FSCTL_DFS_PKT_SET_DC_NAME,
                DCName,
                cbSize,
                NULL,
                0L);

    NetApiBufferFree(pDomainControllerInfo);

    //
    // Inform anyone waiting that the mup is ready.
    //

    if (MupEventSignaled == FALSE) {

#if DBG
        if (DfsDebug)
            DbgPrint("Signaling mup event\n");
#endif
        SetEvent(hMupEvent);
        MupEventSignaled = TRUE;

    }
       
    NtClose( hDfs );

#if DBG
    if (DfsDebug)
        DbgPrint("DfsGetDCName(3) exit 0x%x\n", Status);
#endif

    return (Status);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetDomainNameInfo
//
//  Synopsis:   Gets the Netbios & Dns name of the domain, then sends them
//              down to the drvier;
//
//  Returns:    [STATUS_SUCCESS] -- Successfully created domain pkt entry.
//              [other]             -- return from DfsOpen or
//                                      DsRoleGetPrimaryDomainInformation
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetDomainNameInfo(void)
{
    NTSTATUS Status;
    ULONG dwErr;
    HANDLE hDfs;
    ULONG cbSize;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo;

    Status = DfsOpen( &hDfs, NULL );

    if (!NT_SUCCESS(Status)) {
        return (Status);
    }

    //
    // Get our machine name and type/role.
    //

    dwErr = DsRoleGetPrimaryDomainInformation(
                NULL,
                DsRolePrimaryDomainInfoBasic,
                (PBYTE *)&pPrimaryDomainInfo);

    if (dwErr == ERROR_SUCCESS) {

        if (pPrimaryDomainInfo->DomainNameFlat != NULL) {

            cbSize = wcslen(pPrimaryDomainInfo->DomainNameFlat) * sizeof(WCHAR) + sizeof(WCHAR);
        
            Status = DfsFsctl(
                        hDfs,
                        FSCTL_DFS_PKT_SET_DOMAINNAMEFLAT,
                        pPrimaryDomainInfo->DomainNameFlat,
                        cbSize,
                        NULL,
                        0L);

        }

        if (pPrimaryDomainInfo->DomainNameDns != NULL) {

            cbSize = wcslen(pPrimaryDomainInfo->DomainNameDns) * sizeof(WCHAR) + sizeof(WCHAR);
            
            Status = DfsFsctl(
                        hDfs,
                    FSCTL_DFS_PKT_SET_DOMAINNAMEDNS,
                        pPrimaryDomainInfo->DomainNameDns,
                        cbSize,
                        NULL,
                        0L);

        }

        DsRoleFreeMemory(pPrimaryDomainInfo);

        GotDomainNameInfo = TRUE;

    }

    NtClose( hDfs );
    return (Status);

}

UNICODE_STRING LocalDfsName = {
    sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
    sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
    DFS_DRIVER_NAME
};

//+-------------------------------------------------------------------------
//
//  Function:   DfsOpen, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle,
    IN      PUNICODE_STRING DfsName OPTIONAL
)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    PUNICODE_STRING name;

    if (ARGUMENT_PRESENT(DfsName)) {
        name = DfsName;
    } else {
        name = &LocalDfsName;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctl, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  ULONG OutputBufferLength
)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    status = NtFsControlFile(
        DfsHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength
    );

    if(NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}

//+-------------------------------------------------------------------------
//
//  CreateMUPEvent()
//
//  Purpose:    Creates an event so other processes can check if the
//              MUP is ready yet
//
//  Parameters: none
//
//  Note:       This handle should never be closed or other processes
//              will fail on the call to OpenEvent().
//
//  Return:     Event handle if successful
//              NULL if an error occurs
//
//+-------------------------------------------------------------------------

HANDLE
CreateMupEvent(void)
{
    HANDLE hEvent;

    // Use default security descriptor.

    hEvent = CreateEvent (NULL, TRUE, FALSE, MUP_EVENT_NAME);

    return hEvent;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\usegenum.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    usegenum.c

Abstract:

    This module contains the worker routines for the NetUseGetInfo and
    NetUseEnum APIs implemented in the Workstation service.

Author:

    Rita Wong (ritaw) 13-Mar-1991

Revision History:

--*/

#include "wsutil.h"
#include "wsdevice.h"
#include "wsuse.h"

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
WsGetUseInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    IN  HANDLE TreeConnection,
    IN  PUSE_ENTRY UseEntry,
    OUT LPBYTE *OutputBuffer
    );

STATIC
NET_API_STATUS
WsEnumUseInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    IN  PUSE_ENTRY UseList,
    IN  LPBYTE ImplicitList,
    IN  DWORD TotalImplicit,
    OUT LPBYTE *OutputBuffer,
    IN  DWORD PreferedMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    );

STATIC
NET_API_STATUS
WsEnumCombinedUseInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    IN  LPBYTE ImplicitList,
    IN  DWORD TotalImplicit,
    IN  PUSE_ENTRY UseList,
    OUT LPBYTE OutputBuffer,
    IN  DWORD OutputBufferLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    );

STATIC
NET_API_STATUS
WsGetRedirUseInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    IN  HANDLE TreeConnection,
    OUT LPBYTE *OutputBuffer
    );

STATIC
NET_API_STATUS
WsGetCombinedUseInfo(
    IN  DWORD Level,
    IN  DWORD UseFixedLength,
    IN  PUSE_ENTRY UseEntry,
    IN  PLMR_CONNECTION_INFO_2 UncEntry,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  OUT LPDWORD EntriesRead OPTIONAL
    );

STATIC
BOOL
WsFillUseBuffer(
    IN  DWORD Level,
    IN  PUSE_ENTRY UseEntry,
    IN  PLMR_CONNECTION_INFO_2 UncEntry,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  DWORD UseFixedLength
    );

//-------------------------------------------------------------------//
//                                                                   //
// Macros                                                            //
//                                                                   //
//-------------------------------------------------------------------//

#define SET_USE_INFO_POINTER(InfoStruct, ResultBuffer) \
    InfoStruct->UseInfo2 = (PUSE_INFO_2) ResultBuffer;

#define SET_USE_ENUM_POINTER(InfoStruct, ResultBuffer, NumRead)      \
    {InfoStruct->UseInfo.Level2->Buffer = (PUSE_INFO_2) ResultBuffer;\
     InfoStruct->UseInfo.Level2->EntriesRead = NumRead;}



NET_API_STATUS NET_API_FUNCTION
NetrUseGetInfo(
    IN  LPTSTR ServerName OPTIONAL,
    IN  LPTSTR UseName,
    IN  DWORD Level,
    OUT LPUSE_INFO InfoStruct
    )
/*++

Routine Description:

    This function is the NetUseGetInfo entry point in the Workstation service.

    This function assumes that UseName has been error checked and
    canonicalized.

Arguments:

    UseName - Supplies the local device name or shared resource name of
        the tree connection.

    Level - Supplies the level of information to be returned regarding the
        specified tree connection.

    BufferPointer - Returns a pointer to the buffer allocated by the
        Workstation service which contains the requested information.
        This pointer is set to NULL if return code is not NERR_Success
        or ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NET_API_STATUS status;

    LUID LogonId;                      // Logon Id of user
    DWORD Index;                       // Index to user entry in Use Table

    PUSE_ENTRY MatchedPointer;         // Points to found use entry
    HANDLE TreeConnection;             // Handle to connection

    TCHAR *FormattedUseName;
                                       // For canonicalizing a local device
                                       // name
    DWORD PathType = 0;

    LPBYTE Buffer = NULL;

    PUSE_ENTRY UseList;

    SET_USE_INFO_POINTER(InfoStruct, NULL);

    UNREFERENCED_PARAMETER(ServerName);

    if (Level > 3) {
        return ERROR_INVALID_LEVEL;
    }

    FormattedUseName = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,(MAX_PATH+1)*sizeof(TCHAR));

    if (FormattedUseName == NULL) {
        return GetLastError();
    }

    //
    // Check to see if UseName is valid, and canonicalize it.
    //
    if (I_NetPathCanonicalize(
            NULL,
            UseName,
            FormattedUseName,
            (MAX_PATH+1)*sizeof(TCHAR),
            NULL,
            &PathType,
            0
            ) != NERR_Success) {
        LocalFree(FormattedUseName);
        return NERR_UseNotFound;
    }

    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] NetUseGetInfo %ws %lu\n", FormattedUseName, Level));
    }

    //
    // Impersonate caller and get the logon id
    //
    if ((status = WsImpersonateAndGetLogonId(&LogonId)) != NERR_Success) {
        LocalFree(FormattedUseName);
        return status;
    }

    //
    // Lock Use Table for read access
    //
    if (! RtlAcquireResourceShared(&Use.TableResource, TRUE)) {
        LocalFree(FormattedUseName);
        return NERR_InternalError;
    }

    //
    // See if the use entry is an explicit connection.
    //
    status = WsGetUserEntry(
                 &Use,
                 &LogonId,
                 &Index,
                 FALSE
                 );

    UseList = (status == NERR_Success) ? (PUSE_ENTRY) Use.Table[Index].List :
                                         NULL;

    if ((status = WsFindUse(
                     &LogonId,
                     UseList,
                     FormattedUseName,
                     &TreeConnection,
                     &MatchedPointer,
                     NULL
                     )) != NERR_Success) {
        RtlReleaseResource(&Use.TableResource);
        LocalFree(FormattedUseName);
        return status;
    }

    LocalFree(FormattedUseName);

    if (MatchedPointer == NULL) {

        //
        // UseName specified has an implicit connection.  Don't need to hold
        // on to Use Table anymore.
        //
        RtlReleaseResource(&Use.TableResource);
    }

    status = WsGetUseInfo(
                 &LogonId,
                 Level,
                 TreeConnection,
                 MatchedPointer,
                 &Buffer
                 );

    if (MatchedPointer == NULL) {
        //
        // Close temporary handle to implicit connection.
        //
        NtClose(TreeConnection);
    }
    else {
        RtlReleaseResource(&Use.TableResource);
    }

    SET_USE_INFO_POINTER(InfoStruct, Buffer);

    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] NetrUseGetInfo: about to return status=%lu\n",
                     status));
    }

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetrUseEnum(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  OUT LPUSE_ENUM_STRUCT InfoStruct,
    IN  DWORD PreferedMaximumLength,
    OUT LPDWORD TotalEntries,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    )
/*++

Routine Description:

    This function is the NetUseEnum entry point in the Workstation service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    InfoStruct - This structure supplies the level of information requested,
        returns a pointer to the buffer allocated by the Workstation service
        which contains a sequence of information structure of the specified
        information level, and returns the number of entries read.  The buffer
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.  The EntriesRead
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    PreferedMaximumLength - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, all available
        information will be returned.

    TotalEntries - Returns the total number of entries available.  This value
        is only valid if the return code is NERR_Success or ERROR_MORE_DATA.

    ResumeHandle - Supplies a handle to resume the enumeration from where it
        left off the last time through.  Returns the resume handle if return
        code is ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    LUID LogonId;                      // Logon Id of user
    DWORD Index;                       // Index to user entry in Use Table
    PUSE_ENTRY UseList;                // Pointer to user's use list

    DWORD EnumConnectionHint = 0;      // Hint size from redirector
    LMR_REQUEST_PACKET Rrp;            // Redirector request packet

    DWORD TotalImplicit;               // Length of ImplicitList
    LPBYTE ImplicitList;               // List of information on implicit
                                       //     connections
    LPBYTE Buffer = NULL;
    DWORD EntriesRead = 0;
    DWORD Level = InfoStruct->Level;

    if (Level > 2) {
        return ERROR_INVALID_LEVEL;
    }

    if (InfoStruct->UseInfo.Level2 == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    try {
	SET_USE_ENUM_POINTER(InfoStruct, NULL, 0);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
	return ERROR_INVALID_PARAMETER;
    }

    UNREFERENCED_PARAMETER(ServerName);

    //
    // Impersonate caller and get the logon id
    //
    if ((status = WsImpersonateAndGetLogonId(&LogonId)) != NERR_Success) {
        return status;
    }

    //
    // Ask the redirector to enumerate the information of implicit connections
    // established by the caller.
    //
    Rrp.Type = GetConnectionInfo;
    Rrp.Version = REQUEST_PACKET_VERSION;
    RtlCopyLuid(&Rrp.LogonId, &LogonId);
    Rrp.Level = Level;
    Rrp.Parameters.Get.ResumeHandle = 0;

    if ((status = WsDeviceControlGetInfo(
                      Redirector,
                      WsRedirDeviceHandle,
                      FSCTL_LMR_ENUMERATE_CONNECTIONS,
                      &Rrp,
                      sizeof(LMR_REQUEST_PACKET),
                      (LPBYTE *) &ImplicitList,
                      MAXULONG,
                      EnumConnectionHint,
                      NULL
                      )) != NERR_Success) {
        return status;
    }

    //
    // If successful in getting all the implicit connection info from the
    // redirector, expect the total entries available to be equal to entries
    // read.
    //
    TotalImplicit = Rrp.Parameters.Get.TotalEntries;
    NetpAssert(TotalImplicit == Rrp.Parameters.Get.EntriesRead);

    //
    // Serialize access to Use Table.
    //
    if (! RtlAcquireResourceShared(&Use.TableResource, TRUE)) {
        status = NERR_InternalError;
        goto CleanUp;
    }

    //
    // See if the user has explicit connection entries in the Use Table.
    //
    status = WsGetUserEntry(
                 &Use,
                 &LogonId,
                 &Index,
                 FALSE
                 );

    UseList = (status == NERR_Success) ? (PUSE_ENTRY) Use.Table[Index].List :
                                         NULL;

    //
    // User has no connections if both implicit and explicit lists are empty.
    //
    if (TotalImplicit == 0 && UseList == NULL) {
        *TotalEntries = 0;
        status = NERR_Success;
        goto CleanUp;
    }

    status = WsEnumUseInfo(
                 &LogonId,
                 Level,
                 UseList,
                 ImplicitList,
                 TotalImplicit,
                 &Buffer,
                 PreferedMaximumLength,
                 &EntriesRead,
                 TotalEntries,
                 ResumeHandle
                 );

CleanUp:
    MIDL_user_free(ImplicitList);

    RtlReleaseResource(&Use.TableResource);

    SET_USE_ENUM_POINTER(InfoStruct, Buffer, EntriesRead);

    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] NetrUseEnum: about to return status=%lu\n",
                     status));
    }

    return status;
}


STATIC
NET_API_STATUS
WsGetUseInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    IN  HANDLE TreeConnection,
    IN  PUSE_ENTRY UseEntry,
    OUT LPBYTE *OutputBuffer
    )
/*++

Routine Description:

    This function allocates the output buffer of exactly the required size
    and fill it with the use information that is requested by the caller of
    NetUseGetInfo.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    Level - Supplies the level of information to be returned.

    TreeConnection - Supplies the handle to the tree connection which user is
        requesting information about.

    UseEntry - Supplies a pointer to the use entry if the tree connection is
        an explicit connection.

    OutputBuffer - Returns a pointer to the buffer allocated by this
        routine which contains the use information requested.  This pointer
        is set to NULL if return code is not NERR_Success.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    DWORD OutputBufferLength;

    LPBYTE FixedPortion;
    LPTSTR EndOfVariableData;

    PLMR_CONNECTION_INFO_2 ConnectionInfo;


    //
    // Get information of the requested connection from redirector
    //   Only send Level 0,1,2 to redir.  Send 2 in place of 3.
    //
    if ((status = WsGetRedirUseInfo(
                      LogonId,
                      (Level > 2 ? 2 : Level),
                      TreeConnection,
                      (LPBYTE *) &ConnectionInfo
                      )) != NERR_Success) {
        return status;
    }

    OutputBufferLength =
        USE_TOTAL_LENGTH(
            Level,
            ((UseEntry != NULL) ?
                (UseEntry->LocalLength + UseEntry->Remote->UncNameLength +
                    2) * sizeof(TCHAR) :
                ConnectionInfo->UNCName.Length + (2 * sizeof(TCHAR))),
            ConnectionInfo->UserName.Length + sizeof(TCHAR)
            );

    if( Level >= 2 && ConnectionInfo->DomainName.Length != 0 ) {
        OutputBufferLength += ConnectionInfo->DomainName.Length + sizeof(TCHAR);
    }

    //
    // Allocate output buffer to be filled in and returned to user
    //
    if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

    FixedPortion = *OutputBuffer;
    EndOfVariableData = (LPTSTR) ((DWORD_PTR) FixedPortion + OutputBufferLength);

    if (UseEntry != NULL) {
        //
        // Use the UNC name of WorkStation Services instead of RDR which doesn't include the
        // deep net use path
        //

        ConnectionInfo->UNCName.Length =
        ConnectionInfo->UNCName.MaximumLength = (USHORT)UseEntry->Remote->UncNameLength * sizeof(TCHAR);
        ConnectionInfo->UNCName.Buffer = (PWSTR)UseEntry->Remote->UncName;
    }

    //
    // Combine the redirector information (if any) with the use entry
    // information into one output buffer.
    //
    status = WsGetCombinedUseInfo(
                 Level,
                 USE_FIXED_LENGTH(Level),
                 UseEntry,
                 ConnectionInfo,
                 &FixedPortion,
                 &EndOfVariableData,
                 NULL
                 );

    //
    // We should have allocated enough memory for all the data
    //
    NetpAssert(status == NERR_Success);

    //
    // If not successful in getting any data, free the output buffer and set
    // it to NULL.
    //
    if (status != NERR_Success) {
        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;
    }

    MIDL_user_free(ConnectionInfo);

    return status;
}


STATIC
NET_API_STATUS
WsEnumUseInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    IN  PUSE_ENTRY UseList,
    IN  LPBYTE ImplicitList,
    IN  DWORD TotalImplicit,
    OUT LPBYTE *OutputBuffer,
    IN  DWORD PreferedMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    )
/*++

Routine Description:

    This function allocates the output buffer of exactly the required size
    and fill it with the use information that is requested by the caller of
    NetUseEnum.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    Level - Supplies the level of information to be returned.

    UseList - Supplies a pointer to the use list.

    ImplicitList - Supplies an array of information from the redirector
        about each implicit connection.

    TotalImplicit - Supplies the number of entries in ImplicitList.

    OutputBuffer - Returns a pointer to the buffer allocated by this
        routine which contains the use information requested.  This pointer
        is set to NULL if return code is not NERR_Success.

    PreferedMaximumLength - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, we will try
        to return all available information if there is enough memory
        resource.

    EntriesRead - Returns the number of entries read into the buffer.  This
        value is returned only if the return code is NERR_Success or
        ERROR_MORE_DATA.

    TotalEntries - Returns the remaining total number of entries that would
        be read into output buffer if it has enough memory to hold all entries.
        This value is returned only if the return code is NERR_Success or
        ERROR_MORE_DATA.

    ResumeHandle - Supplies the resume key to begin enumeration, and returns
        the key to the next entry to resume the enumeration if the current
        call returns ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD i;
    DWORD OutputBufferLength = 0;
    PUSE_ENTRY UseEntry = UseList;
    DWORD TotalExplicit = 0;

    //
    // Get the use information from the redirector for each explicit connection
    //
    while (UseEntry != NULL) {

        PLMR_CONNECTION_INFO_2 ci2;

        //
        // Get tree connection information from the redirector.
        //

        ci2 = NULL;

        if ((status = WsGetRedirUseInfo(
                          LogonId,
                          Level,
                          UseEntry->TreeConnection,
                          (LPBYTE *) &ci2
                          )) != NERR_Success) {

            if( ci2 != NULL )
                MIDL_user_free( ci2 );

            return status;
        }


        if( ci2 == NULL ) {
            return NERR_InternalError;
        }

        //
        // Use the UNC name of WorkStation Services instead of RDR which doesn't include the
        // deep net use path
        //

        ci2->UNCName.Length =
        ci2->UNCName.MaximumLength = (USHORT)UseEntry->Remote->UncNameLength * sizeof(TCHAR);
        ci2->UNCName.Buffer = (PWSTR)UseEntry->Remote->UncName;

        //
        // While we are here, add up the amount of memory needed to hold the
        // explicit connection entries including information from the redir
        // like username.
        //
        if (PreferedMaximumLength == MAXULONG) {
            OutputBufferLength +=
                USE_TOTAL_LENGTH(
                    Level,
                    (UseEntry->LocalLength +
                     ci2->UNCName.Length   +
                     2) * sizeof(TCHAR),
                    (ci2->UserName.Length +
                     sizeof(TCHAR))
                    );

            if( Level >= 2 && ci2->DomainName.Length != 0 ) {
                OutputBufferLength += ci2->DomainName.Length + sizeof(TCHAR);
            }
        }

        MIDL_user_free( ci2 );

        //
        // Sum up the number of explicit connections.
        //
        TotalExplicit++;

        UseEntry = UseEntry->Next;
    }

    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] NetrUseEnum: length of explicit info %lu\n",
                     OutputBufferLength));
    }

    //
    // If the user requests to enumerate all use entries with
    // PreferedMaximumLength == MAXULONG, add up the total number of bytes
    // we need to allocate for the output buffer.  We know the amount we
    // need for explicit connections from above; now add the lengths of
    // implicit connection information.
    //

    if (PreferedMaximumLength == MAXULONG) {

        //
        // Pointer to the next entry in the ImplicitList is computed based
        // on the level of information requested from the redirector.
        //
        LPBYTE ImplicitEntry;
        DWORD ImplicitEntryLength = REDIR_ENUM_INFO_FIXED_LENGTH(Level);


        //
        // Add up the buffer size needed to hold the implicit connection
        // information
        //
        for (ImplicitEntry = ImplicitList, i = 0; i < TotalImplicit;
             ImplicitEntry += ImplicitEntryLength, i++) {

            OutputBufferLength +=
                USE_TOTAL_LENGTH(
                    Level,
                    ((PLMR_CONNECTION_INFO_2) ImplicitEntry)->UNCName.Length
                        + (2 * sizeof(TCHAR)),
                    ((PLMR_CONNECTION_INFO_2) ImplicitEntry)->UserName.Length
                        + sizeof(TCHAR)
                    );

            if( Level >= 2 ) {
                OutputBufferLength += (DNS_MAX_NAME_LENGTH + 1)*sizeof(TCHAR);
            }
        }

        IF_DEBUG(USE) {
            NetpKdPrint((
                "[Wksta] NetrUseEnum: length of implicit & explicit info %lu\n",
                OutputBufferLength));
        }

    }
    else {

        //
        // We will return as much as possible that fits into this specified
        // buffer size.
        //
        OutputBufferLength = ROUND_UP_COUNT(PreferedMaximumLength, ALIGN_WCHAR);

        if (OutputBufferLength < USE_FIXED_LENGTH(Level)) {

            *OutputBuffer = NULL;
            *EntriesRead = 0;
            *TotalEntries = TotalExplicit + TotalImplicit;

            return ERROR_MORE_DATA;
        }
    }


    //
    // Allocate the output buffer
    //
    if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);


    //
    // Get the information
    //
    status = WsEnumCombinedUseInfo(
                 LogonId,
                 Level,
                 ImplicitList,
                 TotalImplicit,
                 UseList,
                 *OutputBuffer,
                 OutputBufferLength,
                 EntriesRead,
                 TotalEntries,
                 ResumeHandle
                 );

    //
    // WsEnumCombinedUseInfo returns in *TotalEntries the number of
    // remaining unread entries.  Therefore, the real total is the
    // sum of this returned value and the number of entries read.
    //
    (*TotalEntries) += (*EntriesRead);

    //
    // If the caller asked for all available data with
    // PreferedMaximumLength == MAXULONG and our buffer overflowed, free the
    // output buffer and set its pointer to NULL.
    //
    if (PreferedMaximumLength == MAXULONG && status == ERROR_MORE_DATA) {

        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (status == ERROR_MORE_DATA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {

        if (*EntriesRead == 0) {
            MIDL_user_free(*OutputBuffer);
            *OutputBuffer = NULL;
        }
    }

    return status;
}


STATIC
NET_API_STATUS
WsEnumCombinedUseInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    IN  LPBYTE ImplicitList,
    IN  DWORD TotalImplicit,
    IN  PUSE_ENTRY UseList,
    OUT LPBYTE OutputBuffer,
    IN  DWORD OutputBufferLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesUnread,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    )
/*++

Routine Description:

    This function lists all existing connections by going through the
    the explicit connections in the Use Table, and the implicit connections
    from the redirector.

Arguments:

    Level - Supplies the level of information to be returned.

    ImplicitList - Supplies an array implicit connections from the redirector.

    TotalImplicit - Supplies the number of entries in ImplicitList.

    UseList - Supplies a pointer to the use list.

    OutputBuffer - Supplies the output buffer which receives the requested
        information.

    OutputBufferLength - Supplies the length of the output buffer.

    EntriesRead - Returns the number of entries written into the output
        buffer.

    EntriesUnread - Returns the remaining total number of unread entries.
        This value is returned only if the return code is NERR_Success or
        ERROR_MORE_DATA.

    ResumeHandle - Supplies the resume key to begin enumeration, and returns
        the key to the next entry to resume the enumeration if the current
        call returns ERROR_MORE_DATA.

Return Value:

    NERR_Success - All entries fit into the output buffer.

    ERROR_MORE_DATA - 0 or more entries were written into the output buffer
        but not all entries fit.

--*/
{
    DWORD i;
    NET_API_STATUS status;
    DWORD UseFixedLength = USE_FIXED_LENGTH(Level);

    LPBYTE FixedPortion = OutputBuffer;
    LPTSTR EndOfVariableData = (LPTSTR) ((DWORD_PTR) FixedPortion +
                                                 OutputBufferLength);
    //
    // Pointer to the next entry in the ImplicitList is computed based on the
    // level of information requested from the redirector.
    //
    LPBYTE ImplicitEntry;
    DWORD ImplicitEntryLength = REDIR_ENUM_INFO_FIXED_LENGTH(Level);

    DWORD StartEnumeration = 0;
    BOOL OnlyRedirectorList = FALSE;


    if (ARGUMENT_PRESENT(ResumeHandle)) {
        StartEnumeration = *ResumeHandle & ~(REDIR_LIST);
        OnlyRedirectorList = *ResumeHandle & REDIR_LIST;
    }

    IF_DEBUG(USE) {
        NetpKdPrint(("\nStartEnumeration=%lu\n, OnlyRedir=%u\n",
                     StartEnumeration, OnlyRedirectorList));
    }

    *EntriesRead = 0;

    //
    // Enumerate explicit connections.  This is done only if resume handle
    // says to start enumeration from the explicit list.
    //
    if (! OnlyRedirectorList) {

        for( ; UseList != NULL; UseList = UseList->Next ) {

            PLMR_CONNECTION_INFO_2 ci2;

            if( StartEnumeration > UseList->ResumeKey ) {
                continue;
            }

            //
            // Get tree connection information from the redirector.
            //

            ci2 = NULL;

            status = WsGetRedirUseInfo( LogonId, Level, UseList->TreeConnection, (LPBYTE *) &ci2 );

            if( status != NERR_Success || ci2 == NULL ) {
                if( ci2 != NULL )
                    MIDL_user_free( ci2 );
                continue;
            }

            //
            // Use the UNC name of WorkStation Services instead of RDR which doesn't include the
            // deep net use path
            //

            ci2->UNCName.Length =
            ci2->UNCName.MaximumLength = (USHORT)UseList->Remote->UncNameLength * sizeof(TCHAR);
            ci2->UNCName.Buffer = (PWSTR)UseList->Remote->UncName;

            status = WsGetCombinedUseInfo(
                    Level,
                    UseFixedLength,
                    UseList,
                    ci2,
                    &FixedPortion,
                    &EndOfVariableData,
                    EntriesRead );

            MIDL_user_free( ci2 );

            if( status == ERROR_MORE_DATA ) {

                    if (ARGUMENT_PRESENT(ResumeHandle)) {
                        *ResumeHandle = UseList->ResumeKey;
                    }

                    *EntriesUnread = TotalImplicit;

                    while (UseList != NULL) {
                        (*EntriesUnread)++;
                        UseList = UseList->Next;
                    }

                    return status;
            }
        }

        //
        // Finished the explicit list.  Start from the beginning of implicit
        // list.
        //
        StartEnumeration = 0;
    }

    //
    // Enumerate implicit connections
    //
    for (ImplicitEntry = ImplicitList, i = 0; i < TotalImplicit;
         ImplicitEntry += ImplicitEntryLength, i++) {

        IF_DEBUG(USE) {
            NetpKdPrint(("RedirList->ResumeKey=%lu\n",
                         ((PLMR_CONNECTION_INFO_2) ImplicitEntry)->ResumeKey));
        }

        if (StartEnumeration <=
            ((PLMR_CONNECTION_INFO_2) ImplicitEntry)->ResumeKey) {

            if (WsGetCombinedUseInfo(
                    Level,
                    UseFixedLength,
                    NULL,
                    (PLMR_CONNECTION_INFO_2) ImplicitEntry,
                    &FixedPortion,
                    &EndOfVariableData,
                    EntriesRead
                    ) == ERROR_MORE_DATA) {

                if (ARGUMENT_PRESENT(ResumeHandle)) {
                    *ResumeHandle = ((PLMR_CONNECTION_INFO_2)
                                        ImplicitEntry)->ResumeKey;
                    *ResumeHandle |= REDIR_LIST;
                }

                *EntriesUnread = TotalImplicit - i;

                return ERROR_MORE_DATA;
            }
        }
    }

    //
    // Successful enumeration.  Reset the resume handle to start from the
    // beginning.
    //
    if (ARGUMENT_PRESENT(ResumeHandle)) {
        *ResumeHandle = 0;
    }

    //
    // There are no more remaining entries.
    //
    *EntriesUnread = 0;

    return NERR_Success;
}


STATIC
NET_API_STATUS
WsGetRedirUseInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    IN  HANDLE TreeConnection,
    OUT LPBYTE *OutputBuffer
    )
/*++

Routine Description:

    This function gets the connection information from the redirector given
    the handle to the connection.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    Level - Supplies the level of information to be returned.

    TreeConnection - Supplies the handle to the tree connection which user is
        requesting information about.

    OutputBuffer - Returns a pointer to the buffer allocated by this
        routine which contains the connection information requested.  This
        pointer is set to NULL if return code is not NERR_Success.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    LMR_REQUEST_PACKET Rrp;

    //
    // Get information of the requested connection from redirector
    //
    Rrp.Type = GetConnectionInfo;
    Rrp.Version = REQUEST_PACKET_VERSION;
    RtlCopyLuid(&Rrp.LogonId, LogonId);
    Rrp.Level = Level;
    Rrp.Parameters.Get.ResumeHandle = 0;
    Rrp.Parameters.Get.TotalBytesNeeded = 0;

    return WsDeviceControlGetInfo(
               Redirector,
               TreeConnection,
               FSCTL_LMR_GET_CONNECTION_INFO,
               &Rrp,
               sizeof(LMR_REQUEST_PACKET),
               OutputBuffer,
               MAXULONG,
               HINT_REDIR_INFO(Level),
               NULL
               );
}



STATIC
NET_API_STATUS
WsGetCombinedUseInfo(
    IN  DWORD Level,
    IN  DWORD UseFixedLength,
    IN  PUSE_ENTRY UseEntry,
    IN  PLMR_CONNECTION_INFO_2 UncEntry,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  OUT LPDWORD EntriesRead OPTIONAL
    )
/*++

Routine Description:

    This function puts together the use information from redirector and from
    the Use Table (if any) into the output buffer.  It increments the
    EntriesRead variable when a use entry is written into the output buffer.

Arguments:

    Level - Supplies the level of information to be returned.

    UseFixedLength - Supplies the length of the fixed portion of the use
        information returned.

    UseEntry - Supplies the pointer to the use entry in the Use Table if it
        is an explicit connection.

    UncEntry - Supplies a pointer to the use information retrieved from the
        redirector.

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a use entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the use
        information is written into the output buffer starting from the end.
        This pointer is updated after any variable length information is
        written to the output buffer.

    EntriesRead - Supplies a running total of the number of entries read
        into the buffer.  This value is incremented every time a use entry is
        successfully written into the output buffer.

Return Value:

    NERR_Success - The current entry fits into the output buffer.

    ERROR_MORE_DATA - The current entry does not fit into the output buffer.

--*/
{
    if (((DWORD_PTR) *FixedPortion + UseFixedLength) >=
         (DWORD_PTR) *EndOfVariableData) {

        //
        // Fixed length portion does not fit.
        //
        return ERROR_MORE_DATA;
    }

    if (! WsFillUseBuffer(
              Level,
              UseEntry,
              UncEntry,
              FixedPortion,
              EndOfVariableData,
              UseFixedLength
              )) {

        //
        // Variable length portion does not fit.
        //
        return ERROR_MORE_DATA;
    }

    if (ARGUMENT_PRESENT(EntriesRead)) {
        (*EntriesRead)++;
    }

    return NERR_Success;
}


STATIC
BOOL
WsFillUseBuffer(
    IN  DWORD Level,
    IN  PUSE_ENTRY UseEntry,
    IN  PLMR_CONNECTION_INFO_2 UncEntry,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  DWORD UseFixedLength
    )
/*++

Routine Description:

    This function fills an entry in the output buffer with the supplied use
    information, and updates the FixedPortion and EndOfVariableData pointers.

    NOTE: This function assumes that the fixed size portion will fit into
          the output buffer.

          It also assumes that info structure level 2 is a superset of
          info structure level 1, which in turn is a superset of info
          structure level 0, and that the offset to each common field is
          exactly the same.  This allows us to take advantage of a switch
          statement without a break between the levels.

Arguments:

    Level - Supplies the level of information to be returned.

    UseEntry - Supplies the pointer to the use entry in the Use Table if it is
        an explicit connection.

    UncEntry - Supplies a pointer to the use information retrieved from the
        redirector.

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated after a use entry is written to the
        output buffer.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the use
        information is written into the output buffer starting from the end.
        This pointer is updated after any variable length information is
        written to the output buffer.

    UseFixedLength - Supplies the number of bytes needed to hold the fixed
        size portion.

Return Value:

    Returns TRUE if entire entry fits into output buffer, FALSE otherwise.

--*/
{
    PUSE_INFO_2 UseInfo = (PUSE_INFO_2) *FixedPortion;


    *FixedPortion += UseFixedLength;

    switch (Level) {
        case 3:
            if(UseEntry != NULL && (UseEntry->Flags & USE_DEFAULT_CREDENTIALS)) {
                ((PUSE_INFO_3)*FixedPortion)->ui3_flags |= USE_DEFAULT_CREDENTIALS;
            }

        case 2:
            if (! NetpCopyStringToBuffer(
                      UncEntry->UserName.Buffer,
                      UncEntry->UserName.Length / sizeof(TCHAR),
                      *FixedPortion,
                      EndOfVariableData,
                      &UseInfo->ui2_username
                      )) {
                return FALSE;
            }

            if( UncEntry->DomainName.Length != 0 ) {
                if(! NetpCopyStringToBuffer(
                          UncEntry->DomainName.Buffer,
                          UncEntry->DomainName.Length / sizeof(TCHAR),
                          *FixedPortion,
                          EndOfVariableData,
                          &UseInfo->ui2_domainname
                          )) {
                    return FALSE;
                }
            }

        case 1:

            UseInfo->ui2_password = NULL;

            UseInfo->ui2_status = UncEntry->ConnectionStatus;

            if ((UseEntry != NULL) && (UseEntry->Local != NULL)
                && (UseEntry->LocalLength > 2)) {

                //
                // Reassign the status of the connection if it is paused
                //
                if (WsRedirectionPaused(UseEntry->Local)) {
                    UseInfo->ui2_status = USE_PAUSED;
                }
            }

            switch (UncEntry->SharedResourceType) {

                case FILE_DEVICE_DISK:
                    UseInfo->ui2_asg_type = USE_DISKDEV;
                    break;

                case FILE_DEVICE_PRINTER:
                    UseInfo->ui2_asg_type = USE_SPOOLDEV;
                    break;

                case FILE_DEVICE_SERIAL_PORT:
                    UseInfo->ui2_asg_type = USE_CHARDEV;
                    break;

                case FILE_DEVICE_NAMED_PIPE:
                    UseInfo->ui2_asg_type = USE_IPC;
                    break;

                default:
                    NetpKdPrint((
                        "WsFillUseBuffer: Unknown shared resource type %d.\n",
                        UncEntry->SharedResourceType
                        ));

                case FILE_DEVICE_UNKNOWN:
                    UseInfo->ui2_asg_type = USE_WILDCARD;
                    break;
            }

            UseInfo->ui2_refcount = UncEntry->NumberFilesOpen;

            UseInfo->ui2_usecount = (UseEntry == NULL) ? 0 :
                                    UseEntry->Remote->TotalUseCount;

        case 0:

            if (UseEntry != NULL) {
                //
                // Explicit connection
                //
                if (! NetpCopyStringToBuffer(
                          UseEntry->Local,
                          UseEntry->LocalLength,
                          *FixedPortion,
                          EndOfVariableData,
                          &UseInfo->ui2_local
                          )) {
                    return FALSE;
                }

            }
            else {
                //
                // Implicit connection
                //
                if (! NetpCopyStringToBuffer(
                          NULL,
                          0,
                          *FixedPortion,
                          EndOfVariableData,
                          &UseInfo->ui2_local
                          )) {
                    return FALSE;
                }
            }

            if (! NetpCopyStringToBuffer(
                      UncEntry->UNCName.Buffer,
                      UncEntry->UNCName.Length / sizeof(TCHAR),
                      *FixedPortion,
                      EndOfVariableData,
                      &UseInfo->ui2_remote
                      )) {
                return FALSE;
            }

            break;

        default:
            //
            // This should never happen.
            //
            NetpKdPrint(("WsFillUseBuffer: Invalid level %u.\n", Level));
            NetpAssert(FALSE);
    }

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\msgutil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgutil.c

Abstract:

    This module contains the common utility routines for needed to
    implement the NetMessageBufferSend API.

Author:

    Rita Wong (ritaw) 26-July-1991

Revision History:
    Terence Kwan (terryk)   20-Oct-1993
        Shut down the system iff we initiailize the system successfully.

--*/

#include "ws.h"
#include "wsconfig.h"                    // WsInfo.WsComputerName
#include "wsmsg.h"
#include "wsmain.h"
#include <stdarg.h>

//
// Global variables
//

//
// Information structure which contains the number of networks, the adapter
// numbers of the networks, an array of computer name numbers, and an array
// of broadcast name numbers.
//
WSNETWORKS WsNetworkInfo;
// Flag for initialization
BOOL    fInitialize = FALSE;


NET_API_STATUS
WsInitializeMessageSend(
    BOOLEAN FirstTime
    )
/*++

Routine Description:

    This function initializes the Workstation service to send messages using
    NetBIOS by adding the computername to every network adapter (both logical
    and physical network).

Arguments:

    FirstTime - Flag to indicate first time initialization.  This routine may be called
                later to reinitialize netbios configuration.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    UCHAR Index;

    CHAR NetBiosName[NCBNAMSZ];



    //
    // Get the adapter numbers of networks
    //
    status = NetpNetBiosGetAdapterNumbers(
                 &(WsNetworkInfo.LanAdapterNumbers),
                 sizeof(LANA_ENUM)
                 );

    if (status != NERR_Success) {
        //
        // Fatal error: Log error with NELOG_NetBios
        //
        IF_DEBUG(MESSAGE) {
            NetpKdPrint((
                "[Wksta] Error enumerating LAN adapters.  "
                "Ignore if no UB card.\n"
                ));
        }
        return status;
    }

    //
    // Make the computer name a message type NetBIOS name
    //
    if ((status = NetpStringToNetBiosName(
                      NetBiosName,
                      WsInfo.WsComputerName,
                      NAMETYPE_MESSAGEDEST,
                      WKSTA_TO_MESSAGE_ALIAS_TYPE
                      )) != NERR_Success) {
        return status;
    }

    //
    // Add the computer name (message alias) to every network managed by
    // the redirector, excluding the loopback network.
    //
    if (FirstTime) {
        WsLmsvcsGlobalData->NetBiosOpen();
    }

    for (Index = 0; Index < WsNetworkInfo.LanAdapterNumbers.length; Index++) {

        //
        // Reset the adapter first
        //
        if (WsLmsvcsGlobalData->NetBiosReset(WsNetworkInfo.LanAdapterNumbers.lana[Index])
                != NERR_Success) {
            IF_DEBUG(MESSAGE) {
                NetpKdPrint((
                    "[Wksta] Error reseting LAN adapter number %u.\n"
                    "        Ignore if no UB card.\n",
                    WsNetworkInfo.LanAdapterNumbers.lana[Index]
                    ));
            }
            continue;
        }

        IF_DEBUG(MESSAGE) {
            NetpKdPrint(("[Wksta] About to add name on adapter number %u\n",
                         WsNetworkInfo.LanAdapterNumbers.lana[Index]));
        }

        status = NetpNetBiosAddName(
                     NetBiosName,
                     WsNetworkInfo.LanAdapterNumbers.lana[Index],
                     &WsNetworkInfo.ComputerNameNumbers[Index]
                     );

        if (status != NERR_Success && status != NERR_AlreadyExists) {
            //
            // Fatal error: Log error with NELOG_NetBios
            //
            IF_DEBUG(MESSAGE) {
                NetpKdPrint((
                    "[Wksta] Error adding computername to LAN "
                    "Adapter number %u.\n        Ignore if no UB card.\n",
                    WsNetworkInfo.LanAdapterNumbers.lana[Index]
                    ));
            }
            return status;
        }
    }

    // Initialize okay
    fInitialize = TRUE;
    return NERR_Success;
}


VOID
WsShutdownMessageSend(
    VOID
    )
/*++

Routine Description:

    This function shuts down the Workstation service message send
    functionality by asking NetBIOS to delete the computername that
    was added to every network adapter.

Arguments:

    None

Return Value:

    None.

--*/
{
    // We shut down the component if and only if we successfully initialize
    // the system
    if ( fInitialize )
    {
        NET_API_STATUS status;
        UCHAR Index;

        CHAR NetBiosName[NCBNAMSZ];


        //
        // Make the computer name a message type NetBIOS name
        //
        if ((status = NetpStringToNetBiosName(
                          NetBiosName,
                          WsInfo.WsComputerName,
                          NAMETYPE_MESSAGEDEST,
                          WKSTA_TO_MESSAGE_ALIAS_TYPE
                          )) != NERR_Success) {
            return;
        }

        //
        // Delete the computer name (message alias) from every network.
        //
        for (Index = 0; Index < WsNetworkInfo.LanAdapterNumbers.length; Index++) {

            (void) NetpNetBiosDelName(
                       NetBiosName,
                       WsNetworkInfo.LanAdapterNumbers.lana[Index]
                       );
        }
        WsLmsvcsGlobalData->NetBiosClose();
    }
}


WORD
WsMakeSmb(
    OUT PUCHAR SmbBuffer,
    IN  UCHAR SmbFunctionCode,
    IN  WORD NumberOfParameters,
    IN  PCHAR FieldsDopeVector,
    ...
    )
/*++

Routine Description:

    This function builds a Server Message Block.  It takes a variable
    number of arguments, but the first 4 are required to be present.
    If NumberOfParameters is some non-zero value, n, then immediately
    following the 4 required arguments there will be n WORD
    parameters.

Arguments:

    SmbBuffer - Returns the Server Message Block in the supplied buffer.

    SmbFunctionCode - Supplies the function code for the command.

    NumberOfParameters - Supplies the number of WORD parameters passed
        to this routine immediately following the first 4 required parameters.

    FieldsDopeVector - Supplies an ASCIIZ string where each character of the
        string describes the remaining parameters:

        's' - the next argument is a pointer to a null-terminated string
              which is to be copied into the SMB prefixed by a byte
              containing '\004'.

        'b' - the next argument is a WORD specifying a length,
              and it is followed by a pointer to a buffer whose contents
              are to be placed in the SMB prefixed by a byte containing
              '\001' and a WORD containing the length.

        't' - the next argument is a WORD specifying a length,
              and it is followed by a pointer to a text buffer whose
              contents are to be placed in the SMB prefixed by a byte
              containing '\001' and a WORD containg the length.
              This is the same as 'b' except that <CRLF>,<LFCR>,<CR>,<LF>
              are all converted to a single '\024' character.

Return Value:

    Returns the length in bytes of the SMB created in SmbBuffer.

Assumptions:

    The supplied SmbBuffer is large enough for the SMB created.

--*/
{
    va_list ArgList;                        // Argument List
    PSMB_HEADER Smb;                        // SMB header pointer
    PUCHAR SmbBufferPointer;

    PUCHAR LengthPointer;                   // length pointer
    PCHAR TextPointer;                      // Text pointer
    WORD TextBufferSize;                    // Size of SMB data to send

    WORD i;                                 // Text loop index
    WORD Length;                            // Length after text conversion or
                                            //    length of the buffer portion



    va_start(ArgList, FieldsDopeVector);    // Init ArgList

    RtlZeroMemory((PVOID) SmbBuffer, WS_SMB_BUFFER_SIZE);

    Smb = (PSMB_HEADER) SmbBuffer;

    Smb->Protocol[0] = 0xff;                // Message type
    Smb->Protocol[1] = 'S';                 // Server
    Smb->Protocol[2] = 'M';                 // Message
    Smb->Protocol[3] = 'B';                 // Block

    Smb->Command = SmbFunctionCode;         // Set function code

    //
    // Skip over SMB header
    //
    SmbBufferPointer = &SmbBuffer[sizeof(SMB_HEADER)];

    //
    // Set parameter count
    //
    *SmbBufferPointer++ = (UCHAR) NumberOfParameters;

    while (NumberOfParameters--) {

        short Parameters = va_arg(ArgList, short);

        //
        // Put parameters in the SMB
        //

        //
        // Assign message group id
        //
        *(SmbBufferPointer)++ = ((PUCHAR) &Parameters)[0];
        *(SmbBufferPointer)++ = ((PUCHAR) &Parameters)[1];
    }

    //
    // Save the pointer
    //
    Smb = (PSMB_HEADER) SmbBufferPointer;

    //
    // Skip data length field.  After the rest of buffer is filled
    // in, we will come back to set the length of the data.
    //
    SmbBufferPointer += sizeof(WORD);

    while (*FieldsDopeVector != '\0') {

        switch (*FieldsDopeVector++) {

            case 's':
                //
                // Null-terminated string
                //

                //
                // Set buffer type code
                //
                *SmbBufferPointer++ = '\004';

                //
                // Copy string into SMB buffer
                //
                strcpy(SmbBufferPointer, va_arg(ArgList, LPSTR));

                //
                // Increment pointer past string and null terminator
                //
                SmbBufferPointer += strlen(SmbBufferPointer) + 1;

                break;

            case 'b':
                //
                // Length-prefixed buffer
                //

                //
                // Set buffer type code
                //
                *SmbBufferPointer++ = '\001';

                //
                // Get buffer size
                //
                TextBufferSize = va_arg(ArgList, WORD);

                //
                // Set the buffer length
                //
                *(SmbBufferPointer)++ = ((PUCHAR) &TextBufferSize)[0];
                *(SmbBufferPointer)++ = ((PUCHAR) &TextBufferSize)[1];

                //
                // Move data into SMB buffer
                //
                memcpy(SmbBufferPointer, va_arg(ArgList, PUCHAR), TextBufferSize);

                //
                // Increment buffer pointer
                //
                SmbBufferPointer += TextBufferSize;

                break;

            case 't':

              //
              // Length-prefixed text buffer
              //
              *SmbBufferPointer++ = '\001';

              //
              // Get non converted text length
              //
              TextBufferSize = va_arg(ArgList, WORD);

              IF_DEBUG(MESSAGE) {
                  NetpKdPrint(("[Wksta] WsMakeSmb TexBufferSize=%u\n",
                               TextBufferSize));
              }


              TextPointer = va_arg(ArgList, PCHAR);

              //
              // Where to put modified text length
              //
              LengthPointer = SmbBufferPointer;
              SmbBufferPointer += sizeof(WORD);

              //
              // Now copy the text into the buffer converting all occurences
              // of <CRLF>, <LFCR>, <CR>, <LF> to '\024'
              //
              for (i = 0, Length = 0; i < TextBufferSize; i++) {

                  if (*TextPointer == '\n') {

                      //
                      // Convert to IBM end of line
                      //
                      *SmbBufferPointer++ = '\024';
                      TextPointer++;
                      Length++;

                      //
                      // Ignore LF following CR
                      //
                      if (*TextPointer == '\r') {
                          TextPointer++;
                          i++;
                      }

                  }
                  else if (*TextPointer == '\r') {

                      //
                      // Convert to IBM end of line
                      //
                      *SmbBufferPointer++ = '\024';
                      TextPointer++;
                      Length++;

                      //
                      // Ignore CR following LF
                      //
                      if (*(TextPointer) == '\n') {
                          TextPointer++;
                          i++;
                      }

                  }
                  else {

                      *SmbBufferPointer++ = *TextPointer++;
                      Length++;
                  }

              }

              //
              // Set the buffer length
              //
              *(LengthPointer)++ = ((PUCHAR) &Length)[0];
              *(LengthPointer)++ = ((PUCHAR) &Length)[1];

              break;
          }
    }

    va_end(ArgList);

    //
    // Set length of buffer portion
    //
    Length = (WORD) ((DWORD) (SmbBufferPointer - (PUCHAR) Smb) - sizeof(WORD));
    *((PUCHAR) Smb)++ = ((PUCHAR) &Length)[0];
    *((PUCHAR) Smb)++ = ((PUCHAR) &Length)[1];

    //
    // Return length of SMB
    //
    return (WORD) (SmbBufferPointer - SmbBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\wkssvc_s_stub.c ===
#include "wkssvc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\useaddel.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    useaddel.c

Abstract:

    This module contains the worker routines for the NetUseAdd and
    NetUseDel APIs implemented in the Workstation service.

Author:

    Rita Wong (ritaw) 4-Mar-1991

Revision History:

--*/

#include "wsutil.h"
#include "wsdevice.h"
#include "wsuse.h"

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
WsAddUse(
    IN  PLUID LogonId,
    IN  HANDLE TreeConnection,
    IN  LPTSTR Local OPTIONAL,
    IN  DWORD LocalLength,
    IN  LPTSTR UncName,
    IN  DWORD UncNameLength,
    IN  PUNICODE_STRING TreeConnectStr,
    IN  DWORD Flags
    );

STATIC
NET_API_STATUS
WsDeleteUse(
    IN  PLUID LogonId,
    IN  DWORD ForceLevel,
    IN  PUSE_ENTRY MatchedPointer,
    IN  DWORD Index
    );


STATIC
NET_API_STATUS
WsCreateNewEntry(
    OUT PUSE_ENTRY *NewUse,
    IN  HANDLE TreeConnection,
    IN  LPTSTR Local OPTIONAL,
    IN  DWORD LocalLength,
    IN  LPTSTR UncName OPTIONAL,
    IN  DWORD UncNameLength,
    IN  PUNICODE_STRING TreeConnectStr,
    IN  DWORD Flags
    );

STATIC
NET_API_STATUS
WsCheckLocalAndDeviceType(
    IN  LPTSTR Local,
    IN  DWORD DeviceType,
    OUT LPDWORD ErrorParameter OPTIONAL
    );

STATIC
NET_API_STATUS
WsCheckEstablishedDeviceType(
    IN  HANDLE TreeConnection,
    IN  DWORD RequestedDeviceType
    );

STATIC
NET_API_STATUS
WsAllocateUseWorkBuffer(
    IN  PUSE_INFO_2 UseInfo,
    IN  DWORD Level,
    OUT LPTSTR *UncName,
    OUT LPTSTR *Local,
    OUT LPTSTR *UserName,
    OUT LPTSTR *DomainName
    );

#if DBG

STATIC
VOID
DumpUseList(
    DWORD Index
    );

#endif

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Monotonically incrementing integer.  A unique value is assigned to
// each new use entry created so that we can provide an enumeration
// resume handle.
//
STATIC DWORD GlobalResumeKey = 0;

//-------------------------------------------------------------------//
//                                                                   //
// Macros                                                            //
//                                                                   //
//-------------------------------------------------------------------//

#define GET_USE_INFO_POINTER(UseInfo, InfoStruct) \
    UseInfo = InfoStruct->UseInfo3;



NET_API_STATUS NET_API_FUNCTION
NetrUseAdd(
    IN  LPTSTR ServerName OPTIONAL,
    IN  DWORD Level,
    IN  LPUSE_INFO InfoStruct,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function is the NetUseAdd entry point in the Workstation service.

Arguments:

    Level - Supplies the level of information specified in Buffer.

    Buffer - Supplies the parameters to create the new tree connection with.

    ErrorParameter - Returns the identifier to the invalid parameter in Buffer
        if this function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    LUID LogonId;
    NET_API_STATUS status;

    LPTSTR UncName = NULL;
    DWORD UncNameLength = 0;
    PTSTR Local = NULL;
    DWORD LocalLength = 0;
    DWORD Flags;

    LPTSTR UserName = NULL;
    LPTSTR DomainName = NULL;
    LPTSTR Password = NULL;
    UNICODE_STRING EncodedPassword;
    ULONG CreateFlags;

    HANDLE TreeConnection;
    UNICODE_STRING TreeConnectStr;

    PUSE_INFO_3 pUseInfo;
    PUSE_INFO_2 UseInfo;

    DWORD SessionId;
    LPWSTR Session = NULL;

    UNREFERENCED_PARAMETER(ServerName);

    if (Level == 0) {
        return ERROR_INVALID_LEVEL;
    }

#define NETR_USE_ADD_PASSWORD_SEED 0x56     // Pick a non-zero seed
    RtlInitUnicodeString( &EncodedPassword, NULL );

    GET_USE_INFO_POINTER(pUseInfo, InfoStruct);

    if (pUseInfo == NULL) {
        RETURN_INVALID_PARAMETER(ErrorParameter, PARM_ERROR_UNKNOWN);
    }

    //
    // Cast a pointer to USE_INFO_2 to make things easy ...
    //

    UseInfo = &pUseInfo->ui3_ui2;

    if(Level == 3)
    {
        CreateFlags = pUseInfo->ui3_flags;
    }
    else
    {
        CreateFlags = 0;
    }

    //
    // UNC name can never be NULL or empty string.
    //
    if ((UseInfo->ui2_remote == NULL) ||
        (UseInfo->ui2_remote[0] == TCHAR_EOS)) {
        RETURN_INVALID_PARAMETER(ErrorParameter, USE_REMOTE_PARMNUM);
    }

    //
    // Allocate one large buffer for storing the UNC name, local device name,
    // username, and domain name.
    //
    if ((status = WsAllocateUseWorkBuffer(
                      UseInfo,
                      Level,
                      &UncName,           // Free using this pointer
                      &Local,
                      &UserName,
                      &DomainName
                      )) != NERR_Success) {
        return status;
    }

    //
    // If local device is a NULL string, it will be treated as a pointer to
    // NULL.
    //
    if ((UseInfo->ui2_local != NULL) &&
        (UseInfo->ui2_local[0] != TCHAR_EOS)) {

        //
        // Local device name is not NULL, canonicalize it
        //
        if (WsUseCheckLocal(
                UseInfo->ui2_local,
                Local,
                &LocalLength
                ) != NERR_Success) {
            (void) LocalFree(UncName);
            RETURN_INVALID_PARAMETER(ErrorParameter, USE_LOCAL_PARMNUM);
        }
    }

    //
    // Check the format of the shared resource name.
    //
    if (WsUseCheckRemote(
            UseInfo->ui2_remote,
            UncName,
            &UncNameLength
            ) != NERR_Success) {
        (void) LocalFree(UncName);
        RETURN_INVALID_PARAMETER(ErrorParameter, USE_REMOTE_PARMNUM);
    }

    if ((Level >= 2) &&
        (UseInfo->ui2_password != NULL) &&
        (UseInfo->ui2_password[0] == TCHAR_EOS) &&
        (UseInfo->ui2_username != NULL) &&
        (UseInfo->ui2_username[0] == TCHAR_EOS) &&
        (UseInfo->ui2_domainname != NULL) &&
        (UseInfo->ui2_domainname[0] == TCHAR_EOS)) {

        //
        //  The user explicitly specified an empty password, username, and
        //  domain.  This means they want a null session.
        //

        *UserName = TCHAR_EOS;
        *DomainName = TCHAR_EOS;
        Password = TEXT("");

    } else {

        //
        // Canonicalize user and domain names.
        //

        if (UserName != NULL) {

            //
            // Canonicalize username
            //
            if ((status = I_NetNameCanonicalize(
                              NULL,
                              UseInfo->ui2_username,
                              UserName,
                              (UNLEN + 1) * sizeof(TCHAR),
                              NAMETYPE_USER,
                              0
                              )) != NERR_Success) {
                (void) LocalFree(UncName);
                RETURN_INVALID_PARAMETER(ErrorParameter, USE_USERNAME_PARMNUM);
            }
        }

        if ( (DomainName != NULL)
             && (UseInfo->ui2_domainname[0] != TCHAR_EOS) ) {

            // Must now allow null string for domain name to support UPNs
            // which contain the domain name in the username.
            //
            // Canonicalize domain name
            // Canonicalize as a computername since a computername can be
            // a valid domain (on the workstation to which you are connecting.
            // This allows computernames with spaces to work.
            //
            if ((status = I_NetNameCanonicalize(
                              NULL,
                              UseInfo->ui2_domainname,
                              DomainName,
                              (DNS_MAX_NAME_LENGTH + 1) * sizeof(TCHAR),
                              NAMETYPE_COMPUTER,
                              0
                              )) != NERR_Success) {
                (void) LocalFree(UncName);
                RETURN_INVALID_PARAMETER(ErrorParameter, USE_DOMAINNAME_PARMNUM);
            }
        }

        //
        // Make sure password length is not too long
        //
        if (UseInfo->ui2_password != NULL) {

            Password = UseInfo->ui2_password;

            if (STRLEN(Password) > PWLEN) {
                (void) LocalFree(UncName);
                RETURN_INVALID_PARAMETER(ErrorParameter, USE_PASSWORD_PARMNUM);
            }

            //
            // Decode the password (the client obfuscated it.)
            //

            RtlInitUnicodeString( &EncodedPassword, Password );

            RtlRunDecodeUnicodeString( NETR_USE_ADD_PASSWORD_SEED,
                                       &EncodedPassword );

        }
        else {
            Flags |= USE_DEFAULT_CREDENTIALS;
        }

    }
    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] NetrUseAdd %ws %ws\n", Local, UncName));
    }

    //
    // Check to see if the format of the local device name is correct based
    // on the shared resource type to be accessed.  This function also checks
    // to see if the device is shared.
    //
    if ((status = WsCheckLocalAndDeviceType(
                      Local,
                      UseInfo->ui2_asg_type,
                      ErrorParameter
                      )) != NERR_Success) {
        IF_DEBUG(USE) {
            NetpKdPrint(("[Wksta] WsCheckLocalAndDeviceType return %lu\n", status));
        }
        goto FreeWorkBuffer;
    }

    //
    // Impersonate caller and get the logon id
    //
    if ((status = WsImpersonateAndGetSessionId(&SessionId)) != NERR_Success) {
        goto FreeWorkBuffer;
    }

    //
    // Replace \\ with \Device\LanmanRedirector in UncName, and create
    // the NT-style tree connection names (without password or user name)
    //
    if ((status = WsCreateTreeConnectName(
                      UncName,
                      UncNameLength,
                      Local,
                      SessionId,
                      &TreeConnectStr
                      )) != NERR_Success) {
        IF_DEBUG(USE) {
            NetpKdPrint(("[Wksta] NetrUseAdd Bad tree connect name: %lu\n",
                         status));
        }
        goto FreeWorkBuffer;
    }

    //
    // Impersonate caller and get the logon id
    //
    if ((status = WsImpersonateAndGetLogonId(&LogonId)) != NERR_Success) {
        goto FreeAllocatedBuffers;
    }

    //
    // Don't redirect comm or spooled devices if redirection is paused.
    //
    if( Local != NULL && WsRedirectionPaused(Local) ) {
        IF_DEBUG(USE) {
            NetpKdPrint(("[Wksta] NetrUseAdd Redirector paused\n"));
        }
        status = ERROR_REDIR_PAUSED;
        goto FreeAllocatedBuffers;
    }

    if (Local != NULL) {

        PUSE_ENTRY UseList;
        DWORD Index;

        //
        // Lock Use Table so nobody will do anything destructive to it while
        //  we're in the middle of all this.  If multiple threads are trying
        //  to redirect the same drive, only one will succeed creating the
        //  symbolic link, and the others will fail.
        //

        if (! RtlAcquireResourceShared(&Use.TableResource, TRUE)) {
            status = NERR_InternalError;
            goto FreeAllocatedBuffers;
        }

        //
        // Look for the matching LogonId in the Use Table, if none matched
        // create a new entry.
        //
        if (WsGetUserEntry(
                &Use,
                &LogonId,
                &Index,
                FALSE
                ) != NERR_Success) {
            UseList = NULL;
        }
        else {
            UseList = Use.Table[Index].List;
        }

        //
        // Create symbolic link for local device name.  If there are multiple
        //  threads trying to do this, only one will succeed.
        //
        if ((status = WsCreateSymbolicLink(
                          Local,
                          UseInfo->ui2_asg_type,
                          TreeConnectStr.Buffer,
                          UseList,
                          &Session
                          )) != NERR_Success) {

            if ((ARGUMENT_PRESENT(ErrorParameter)) &&
                (status == ERROR_INVALID_PARAMETER)) {
                *ErrorParameter = USE_LOCAL_PARMNUM;
            }
        }

        RtlReleaseResource(&Use.TableResource);

        if( status )
            goto FreeAllocatedBuffers;
    }

    //
    // Create the tree connection if none already exists; otherwise, open it.
    //
    status = WsOpenCreateConnection(
                 &TreeConnectStr,
                 UserName,
                 DomainName,
                 Password,
                 CreateFlags,
                 FILE_OPEN_IF,
                 UseInfo->ui2_asg_type,
                 &TreeConnection,
                 NULL
                 );

    if (status != NERR_Success) {
        if (status == NERR_UseNotFound) {
            status = ERROR_DEV_NOT_EXIST;
        }
        WsDeleteSymbolicLink( Local, TreeConnectStr.Buffer, Session );
        goto FreeAllocatedBuffers;
    }

    //
    // Make sure user was correct about the shared resource type
    //
    if ((status = WsCheckEstablishedDeviceType(
                      TreeConnection,
                      UseInfo->ui2_asg_type
                      )) != NERR_Success) {
        WsDeleteConnection(&LogonId, TreeConnection, USE_LOTS_OF_FORCE);
        WsDeleteSymbolicLink( Local, TreeConnectStr.Buffer, Session );
        goto FreeAllocatedBuffers;
    }

    //
    // Add use to the Use Table.
    //
    status = WsAddUse(
                 &LogonId,
                 TreeConnection,
                 Local,
                 LocalLength,
                 UncName,
                 UncNameLength,
                 &TreeConnectStr,
                 Flags
                 );

    if( status ) {
        WsDeleteConnection(&LogonId, TreeConnection, USE_LOTS_OF_FORCE);
        WsDeleteSymbolicLink( Local, TreeConnectStr.Buffer, Session );
    }

FreeAllocatedBuffers:
    //
    // Free tree connection name buffer and work buffer
    //
    (void) LocalFree(TreeConnectStr.Buffer);

FreeWorkBuffer:
    (void) LocalFree(UncName);
    (void) LocalFree(Session);
    //
    // Put the password back the way we found it.
    //

    if ( EncodedPassword.Length != 0 ) {
        UCHAR Seed = NETR_USE_ADD_PASSWORD_SEED;
        RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );
    }

    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] NetrUseAdd: about to return status=%lu\n",
                     status));
    }

    
    

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetrUseDel (
    IN  LPTSTR ServerName OPTIONAL,
    IN  LPTSTR UseName,
    IN  DWORD ForceLevel
    )
/*++

Routine Description:

    This function is the NetUseDel entry point in the Workstation service.

Arguments:

    UseName - Supplies the local device name or shared resource name of
        the tree connection to be deleted.

    ForceLevel - Supplies the level of force to delete the tree connection.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    LUID LogonId;                      // Logon Id of user
    DWORD Index;                       // Index to user entry in Use Table

    PUSE_ENTRY MatchedPointer;         // Points to found use entry
    PUSE_ENTRY BackPointer;            // Points to node previous to
                                       //     found use entry
    HANDLE TreeConnection;             // Handle to connection

    TCHAR *FormattedUseName;
                                       // For canonicalizing a local device
                                       // name
    DWORD PathType = 0;

    PUSE_ENTRY UseList;


    UNREFERENCED_PARAMETER(ServerName);

    //
    // Check that ForceLevel parameter is valid
    //
    switch (ForceLevel) {

        case USE_NOFORCE:
        case USE_LOTS_OF_FORCE:
        case USE_FORCE:
            break;

        default:
            return ERROR_INVALID_PARAMETER;
    }

    FormattedUseName = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,(MAX_PATH+1)*sizeof(TCHAR));

    if (FormattedUseName == NULL) {
        return GetLastError();
    }
    
    //
    // Check to see if UseName is valid, and canonicalize it.
    //
    if (I_NetPathCanonicalize(
            NULL,
            UseName,
            FormattedUseName,
            (MAX_PATH+1)*sizeof(TCHAR),
            NULL,
            &PathType,
            0
            ) != NERR_Success) {
        LocalFree(FormattedUseName);
        return NERR_UseNotFound;
    }

    IF_DEBUG(USE) {
        NetpKdPrint(("\n[Wksta] NetrUseDel %ws %u, formatted use name %ws\n",
             UseName, ForceLevel, FormattedUseName));
    }

    //
    // Impersonate caller and get the logon id
    //
    if ((status = WsImpersonateAndGetLogonId(&LogonId)) != NERR_Success) {
        LocalFree(FormattedUseName);
        return status;
    }

    //
    // Lock Use Table while looking for entry to delete.
    //
    if (! RtlAcquireResourceExclusive(&Use.TableResource, TRUE)) {
        LocalFree(FormattedUseName);
        return NERR_InternalError;
    }

    //
    // See if the use entry is an explicit connection.
    //
    status = WsGetUserEntry(
                 &Use,
                 &LogonId,
                 &Index,
                 FALSE
                 );

    UseList = (status == NERR_Success) ? (PUSE_ENTRY) Use.Table[Index].List :
                                         NULL;

    if ((status = WsFindUse(
                     &LogonId,
                     UseList,
                     FormattedUseName,
                     &TreeConnection,
                     &MatchedPointer,
                     &BackPointer
                     )) != NERR_Success) {
        RtlReleaseResource(&Use.TableResource);
        LocalFree(FormattedUseName);
        return status;
    }

    LocalFree(FormattedUseName);

    if (MatchedPointer == NULL) {

        //
        // UseName specified has an implicit connection.  Don't need to hold
        // on to Use Table anymore.
        //
        RtlReleaseResource(&Use.TableResource);

        status = WsDeleteConnection(&LogonId, TreeConnection, ForceLevel);

        //
        //  Close the connection handle if the API failed.
        //

        if (status != NERR_Success) {

            NtClose(TreeConnection);

        }

        return status;

    }
    else if ((MatchedPointer->Local != NULL) &&
             (MatchedPointer->LocalLength > 2)) {

        //
        // Don't allow delete on comm or spooled devices if redirection is
        // paused for the current user.
        //
        if (WsRedirectionPaused(MatchedPointer->Local)) {
            RtlReleaseResource(&Use.TableResource);
            return ERROR_REDIR_PAUSED;
        }
    }

    //
    // Delete tree connection and remove use entry from Use Table.  This function
    //  releases the TableResource
    //
    status = WsDeleteUse(
                 &LogonId,
                 ForceLevel,
                 MatchedPointer,
                 Index
                 );

    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] NetrUseDel: about to return status=%lu\n", status));
    }

    return status;
}



STATIC
NET_API_STATUS
WsAddUse(
    IN  PLUID LogonId,
    IN  HANDLE TreeConnection,
    IN  LPTSTR Local OPTIONAL,
    IN  DWORD LocalLength,
    IN  LPTSTR UncName,
    IN  DWORD UncNameLength,
    IN  PUNICODE_STRING TreeConnectStr,
    IN  DWORD Flags
    )
/*++

Routine Description:

    This function adds a use (tree connection) entry into the Use Table for
    the user specified by the Logon Id.  There is a linked list of uses for
    each user.  Each new use entry is inserted into the end of the linked
    list so that enumeration of the list is resumable.

    NOTE: This function locks the Use Table.
          It also closes the tree connection in case of a error, or if a tree
          connection to the same shared resource already exists.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    TreeConnection - Supplies the handle to the tree connection created.

    Local - Supplies the string of the local device name.

    LocalLength - Supplies the length of the local device name.

    UncName - Supplies the name of the shared resource (UNC name).

    UncNameLength - Supplies the length of the shared resource.

    TreeConnectStr - Supplies the string of UNC name in NT-style format
        (\Device\LanmanRedirector\X:\Orville\Razzle).

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD Index;                      // Index to user entry in Use Table

    PUSE_ENTRY MatchedPointer = NULL; // Points to matching shared resource
    PUSE_ENTRY InsertPointer = NULL;  // Point of insertion into use list
    PUSE_ENTRY NewUse;                // Pointer to the new use entry

    if (! RtlAcquireResourceExclusive(&Use.TableResource, TRUE)) {
        (void) NtClose(TreeConnection);
        return NERR_InternalError;
    }

    //
    // Look for the matching LogonId in the Use Table, if none matched
    // create a new entry.
    //
    if ((status = WsGetUserEntry(
                      &Use,
                      LogonId,
                      &Index,
                      TRUE
                      )) != NERR_Success) {
        RtlReleaseResource(&Use.TableResource);
        (void) NtClose(TreeConnection);
        return status;
    }

    if (Use.Table[Index].List != NULL) {

        //
        // Traverse use list to look for location to insert new use entry.
        //
        WsFindInsertLocation(
            (PUSE_ENTRY) Use.Table[Index].List,
            UncName,
            &MatchedPointer,
            &InsertPointer
            );
    }

    if (MatchedPointer == NULL) {

        //
        // No matching UNC name found.  Create a new entry with a
        // corresponding remote entry.
        //
        if ((status = WsCreateNewEntry(
                          &NewUse,
                          TreeConnection,
                          Local,
                          LocalLength,
                          UncName,
                          UncNameLength,
                          TreeConnectStr,
                          Flags
                          )) != NERR_Success) {
            RtlReleaseResource(&Use.TableResource);
            (void) NtClose(TreeConnection);
            return status;
        }
    }
    else {

        //
        // Matching UNC name found.
        //

        //
        // It may be unnecessary to create a new use entry if the use
        // we are adding has a NULL local device and a NULL local device
        // entry already exists.
        //
        if (Local == NULL) {

           if (MatchedPointer->Local == NULL) {

               //
               // Yes, there is a NULL local device entry already.
               // Increment the use count and we are done.
               //
               MatchedPointer->UseCount++;
               MatchedPointer->Remote->TotalUseCount++;

#if DBG
               DumpUseList(Index);
#endif

               RtlReleaseResource(&Use.TableResource);

               //
               // Close newly opened handle to the same tree connection because
               // one already exists.
               //
               (void) NtClose(TreeConnection);

               return NERR_Success;
           }
        }

        //
        // If we get here means we need to create a new use entry but not
        // a corresponding remote entry because a use with the same UNC
        // name already exists.
        //
        if ((status = WsCreateNewEntry(
                          &NewUse,
                          TreeConnection,
                          Local,
                          LocalLength,
                          NULL,
                          0,
                          TreeConnectStr,
                          Flags
                          )) != NERR_Success) {
            RtlReleaseResource(&Use.TableResource);
            (void) NtClose(TreeConnection);
            return status;
        }

        NewUse->Remote = MatchedPointer->Remote;
        NewUse->Remote->TotalUseCount++;
    }

    //
    // Insert the new use entry into use list
    //
    if (InsertPointer == NULL) {
        //
        // Inserting into the head of list
        //
        Use.Table[Index].List = (PVOID) NewUse;
    }
    else {
        InsertPointer->Next = NewUse;
    }

#if DBG
    DumpUseList(Index);
#endif

    RtlReleaseResource(&Use.TableResource);
    return NERR_Success;
}



STATIC
NET_API_STATUS
WsDeleteUse(
    IN  PLUID LogonId,
    IN  DWORD ForceLevel,
    IN  PUSE_ENTRY MatchedPointer,
    IN  DWORD Index
    )
/*++

Routine Description:

    This function removes the use entry pointed by MatchedPointer and
    free it memory if it is a UNC connection deleted with force, or
    it is a UNC connection deleted with no force and the use count is
    decremented to 0, or it is a connection mapped to a local device.

    WARNING: This function assumes that the Use.TableResource is claimed.
             And it releases it on exit.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    ForceLevel - Supplies the level of force to delete.

    MatchedPointer - Supplies the pointer to the use entry to be deleted.

Return Value:

    None.

--*/
{
    PUSE_ENTRY BackPointer;
    NET_API_STATUS status;

    //
    // No need to remove entry if UNC connection is deleted with USE_NOFORCE
    // level, and use count is not 0 after the deletion.
    //
    if ((MatchedPointer->Local == NULL) &&
        (ForceLevel == USE_NOFORCE) &&
        ((MatchedPointer->UseCount - 1) > 0)) {

            MatchedPointer->UseCount--;
            MatchedPointer->Remote->TotalUseCount--;
            NetpAssert(MatchedPointer->Remote->TotalUseCount);

            RtlReleaseResource(&Use.TableResource);
            return NERR_Success;
    }

    //
    // Delete the tree connection and close the handle.
    //
    if ((status = WsDeleteConnection( 
                      LogonId, 
                      MatchedPointer->TreeConnection, 
                      ForceLevel )) != NERR_Success) {
        RtlReleaseResource(&Use.TableResource);
        return status;
    }

    //
    // Successfully deleted connection, and refound our entry.
    //

    BackPointer = (PUSE_ENTRY)Use.Table[Index].List;

    if (BackPointer != MatchedPointer) {
        while (BackPointer->Next != NULL) {
            if (BackPointer->Next == MatchedPointer) {
                break;
            } else {
                BackPointer = BackPointer->Next;
            }
        }

        ASSERT(BackPointer->Next == MatchedPointer);

        BackPointer->Next = MatchedPointer->Next;
    } else {
        //
        // Use entry is the first one on the use list
        //
        Use.Table[Index].List = (PVOID) MatchedPointer->Next;
    }

    MatchedPointer->Remote->TotalUseCount -= MatchedPointer->UseCount;

    if (MatchedPointer->Remote->TotalUseCount == 0) {
        (void) LocalFree((HLOCAL) MatchedPointer->Remote);
    }

    RtlReleaseResource(&Use.TableResource);

    //
    // Delete symbolic link, if any.
    // Must perform the deletion outside of exclusively holding the
    // Use.TableResource.
    // Otherwise, when the shell tries to update the current status of
    // a drive letter change, the explorer.exe thread will block while
    // trying to acquire the Use.TableResource
    //
    WsDeleteSymbolicLink(
        MatchedPointer->Local,
        MatchedPointer->TreeConnectStr,
        NULL
        );

    (void) LocalFree((HLOCAL) MatchedPointer);

    return status;
}


STATIC
NET_API_STATUS
WsCreateNewEntry(
    OUT PUSE_ENTRY *NewUse,
    IN  HANDLE TreeConnection,
    IN  LPTSTR Local OPTIONAL,
    IN  DWORD LocalLength,
    IN  LPTSTR UncName OPTIONAL,
    IN  DWORD UncNameLength,
    IN  PUNICODE_STRING TreeConnectStr,
    IN  DWORD Flags
    )
/*++

Routine Description:

    This function creates and initializes a new use entry.  If the UncName
    is specified, a new remote entry is created and initialized with
    UncName.

Arguments:

    NewUse - Returns a pointer to the newly allocated and initialized use
        entry.

    TreeConnection - Supplies the handle to the tree connection to set in
        the new use entry.

    Local - Supplies the local device name string to be copied into the new
        use entry.

    LocalLength - Supplies the length of the local device name string.

    UncName - Supplies the UNC name string to be copied into the new use entry.

    UncNameLength - Supplies the length of the UNC name string.

    TreeConnectStr - Supplies the string of UNC name in NT-style format
        (\Device\LanmanRedirector\X:\Orville\Razzle).

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    PUNC_NAME NewRemoteEntry;      // Common extension to use entries which
                                   //    share the same UNC connection.


    //
    // Allocate memory for new use.  String length does not include zero
    // terminator so add that.
    //
    if ((*NewUse = (PUSE_ENTRY) LocalAlloc(
                                    LMEM_ZEROINIT,
                                    ROUND_UP_COUNT(
                                        sizeof(USE_ENTRY) + (LocalLength + 1)
                                            * sizeof(TCHAR),
                                        ALIGN_WCHAR
                                        ) +
                                        (ARGUMENT_PRESENT(Local) ?
                                             TreeConnectStr->MaximumLength :
                                             0
                                        )
                                    )) == NULL) {
        return GetLastError();
    }

    //
    // Put use information into the new use node
    //
    (*NewUse)->Next = NULL;
    (*NewUse)->LocalLength = LocalLength;
    (*NewUse)->UseCount = 1;
    (*NewUse)->TreeConnection = TreeConnection;
    (*NewUse)->ResumeKey = GlobalResumeKey++;
    (*NewUse)->Flags = Flags;

    //
    // GlobalResumeKey wraps back to 0 if it is 0x80000000 because we use the
    // high bit to indicate whether the resume handle for NetUseEnum comes
    // from the workstation service or from the redirector.
    //
    GlobalResumeKey &= ~(REDIR_LIST);

    //
    // Copy local device name into use entry after the LocalLength field,
    // if it is specified.
    //
    if (ARGUMENT_PRESENT(Local)) {
        (*NewUse)->Local = (LPTSTR) ((DWORD_PTR) *NewUse + sizeof(USE_ENTRY));
        STRCPY((*NewUse)->Local, Local);

        (*NewUse)->TreeConnectStr = (LPWSTR) ROUND_UP_COUNT(
                                                 ((DWORD_PTR) *NewUse +
                                                     sizeof(USE_ENTRY) +
                                                     (LocalLength + 1) *
                                                        sizeof(TCHAR)),
                                                  ALIGN_WCHAR
                                                  );

        wcscpy((*NewUse)->TreeConnectStr, TreeConnectStr->Buffer);
    }
    else {
        (*NewUse)->Local = NULL;
        (*NewUse)->TreeConnectStr = NULL;
    }

    //
    // If shared resource name is specified, create a new remote entry to hold
    // the UNC name, the tree connection handle, and total number of uses on
    // this shared resource.
    //
    if (ARGUMENT_PRESENT(UncName)) {

        if ((NewRemoteEntry = (PUNC_NAME) LocalAlloc(
                                              LMEM_ZEROINIT,
                                              (UINT) (sizeof(UNC_NAME) +
                                                      UncNameLength * sizeof(TCHAR))
                                              )) == NULL) {
           (void) LocalFree((HLOCAL) *NewUse);
           return GetLastError();
        }

        STRCPY((LPWSTR) NewRemoteEntry->UncName, UncName);
        NewRemoteEntry->UncNameLength = UncNameLength;
        NewRemoteEntry->TotalUseCount = 1;
//        NewRemoteEntry->RedirUseInfo = NULL;

        (*NewUse)->Remote = NewRemoteEntry;
    }

    return NERR_Success;
}



STATIC
NET_API_STATUS
WsCheckLocalAndDeviceType(
    IN  OUT LPTSTR Local,
    IN  DWORD DeviceType,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function checks the format of the specified local device name
    based on the device type of shared resource to be accessed, and at
    the same time verifies that the device type is valid.

Arguments:

    Local - Supplies the local device name.  Returns its canonicalized
        form.

    DeviceType - Supplies the shared resource device type.

    ErrorParameter - Returns the identifier to the invalid parameter in Buffer
        if this function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{

    //
    // Validate local device name based on the shared resource type.
    //

    //
    // Check for wild card device type outside of the switch statement
    // below because compiler complains about constant too big.
    //
    if (DeviceType == USE_WILDCARD || DeviceType == USE_IPC) {

        //
        // Local device name must be NULL for wild card or IPC connection.
        //
        if (Local == NULL) {
            return NERR_Success;
        }
        else {
            RETURN_INVALID_PARAMETER(ErrorParameter, USE_LOCAL_PARMNUM);
        }
    }

    switch (DeviceType) {

        case USE_DISKDEV:

            if (Local == NULL) {
                return NERR_Success;
            }

            //
            // Local device name must have "<drive>:" format for disk
            // device.
            //
            if (STRLEN(Local) != 2 || Local[1] != TCHAR_COLON) {
                RETURN_INVALID_PARAMETER(ErrorParameter, USE_LOCAL_PARMNUM);
            }

            break;

        case USE_SPOOLDEV:

            if (Local == NULL) {
                return NERR_Success;
            }

            //
            //  Local device name must have "LPTn:" or "PRN:" format
            //  for a print device.
            //
            if ((STRNICMP(Local, TEXT("PRN"), 3) != 0) &&
                (STRNICMP(Local, TEXT("LPT"), 3) != 0)) {
                RETURN_INVALID_PARAMETER(ErrorParameter, USE_LOCAL_PARMNUM);
            }
            break;

        case USE_CHARDEV:

            if (Local == NULL) {
                return NERR_Success;
            }

            //
            //  Local device name must have "COMn:" or "AUX:" format
            //  for a comm device.
            //
            if ((STRNICMP(Local, TEXT("AUX"), 3) != 0) &&
                (STRNICMP(Local, TEXT("COM"), 3) != 0)) {
                RETURN_INVALID_PARAMETER(ErrorParameter, USE_LOCAL_PARMNUM);
            }
            break;


        default:
            IF_DEBUG(USE) {
               NetpKdPrint((
                   "[Wksta] NetrUseAdd: Unknown shared resource type %lu\n",
                   DeviceType));
            }

            return NERR_BadAsgType;
    }

    return NERR_Success;
}


STATIC
NET_API_STATUS
WsCheckEstablishedDeviceType(
    IN  HANDLE TreeConnection,
    IN  DWORD RequestedDeviceType
    )
/*++

Routine Description:

    This function verifies that the device type of the shared resource we
    have connected to is the same as the requested device type.

Arguments:

    TreeConnection - Supplies handle to established tree connection.

    RequestedDeviceType - Supplies the shared resource device type specified
        by the user to create the tree connection.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    FILE_FS_DEVICE_INFORMATION FileInformation;
    IO_STATUS_BLOCK IoStatusBlock;


    ntstatus = NtQueryVolumeInformationFile(
                   TreeConnection,
                   &IoStatusBlock,
                   (PVOID) &FileInformation,
                   sizeof(FILE_FS_DEVICE_INFORMATION),
                   FileFsDeviceInformation
                   );

    if (! NT_SUCCESS(ntstatus) || ! NT_SUCCESS(IoStatusBlock.Status)) {
        return NERR_InternalError;
    }

    //
    // Check for wild card device type outside of the switch statement
    // below because compiler complains about constant too big.
    //
    if (RequestedDeviceType == USE_WILDCARD) {
        return NERR_Success;
    }

    switch (RequestedDeviceType) {
        case USE_DISKDEV:
            if (FileInformation.DeviceType != FILE_DEVICE_DISK) {
                return ERROR_BAD_DEV_TYPE;
            }
            break;

        case USE_SPOOLDEV:
            if (FileInformation.DeviceType != FILE_DEVICE_PRINTER) {
                return ERROR_BAD_DEV_TYPE;
            }
            break;

        case USE_CHARDEV:
            if (FileInformation.DeviceType != FILE_DEVICE_SERIAL_PORT) {
                return ERROR_BAD_DEV_TYPE;
            }
            break;

        case USE_IPC:
            if (FileInformation.DeviceType != FILE_DEVICE_NAMED_PIPE) {
                return ERROR_BAD_DEV_TYPE;
            }
            break;

        default:
            //
            // This should have been error checked earlier.
            //
            NetpKdPrint((
                "WsCheckEstablishedDeviceType: Unknown device type.\n"
                ));
            NetpAssert(FALSE);
            return ERROR_BAD_DEV_TYPE;
    }

    return NERR_Success;
}


STATIC
NET_API_STATUS
WsAllocateUseWorkBuffer(
    IN  PUSE_INFO_2 UseInfo,
    IN  DWORD Level,
    OUT LPTSTR *UncName,
    OUT LPTSTR *Local,
    OUT LPTSTR *UserName,
    OUT LPTSTR *DomainName
    )
/*++

Routine Description:

    This function allocates the work buffer for NetrUseAdd.  The buffer
    is the maximum need for canonicalizing and storing the strings
    described below.  If any of the strings is NULL, no memory is allocated
    for it.

        UncName - UNC name of remote resource.  Cannot be NULL.

        Local - local device name specified in the NetUseAdd.  May be NULL.

        UserName - username to establish connection with.  May be NULL.

        DomainName - domain name.  Must be specified if UserName is,
            otherwise if UserName is NULL this string is ignored.


Arguments:

    UseInfo - Supplies the input structure for NetUseAdd.

    Level - Supplies the use info level.

    Output pointers are set to point into allocated work buffer if its
    corresponding input string is not NULL or empty.

Return Value:

    Error from LocalAlloc.

--*/
{
    DWORD WorkBufferSize = (MAX_PATH + 1) * sizeof(TCHAR);
    LPBYTE WorkBuffer;


    if ((UseInfo->ui2_local != NULL) &&
        (UseInfo->ui2_local[0] != TCHAR_EOS)) {
        WorkBufferSize += (DEVLEN + 1) * sizeof(TCHAR);
    }

    if (Level >= 2) {
        if (UseInfo->ui2_username != NULL) {
            WorkBufferSize += (UNLEN + 1) * sizeof(TCHAR);
        }

        if (UseInfo->ui2_domainname != NULL) {
            WorkBufferSize += (DNS_MAX_NAME_LENGTH + 1) * sizeof(TCHAR);
        }
    }


    if ((WorkBuffer = (LPBYTE) LocalAlloc(
                                   LMEM_ZEROINIT,
                                   (UINT) WorkBufferSize
                                   )) == NULL) {
        return GetLastError();
    }

    *UncName = (LPTSTR) WorkBuffer;

    IF_DEBUG(USE) {
        NetpKdPrint(("                               Remote x%08lx\n", *UncName));
    }

    WorkBuffer += (MAX_PATH + 1) * sizeof(TCHAR);

    if ((UseInfo->ui2_local != NULL) &&
        (UseInfo->ui2_local[0] != TCHAR_EOS)) {
        *Local = (LPTSTR) WorkBuffer;
        WorkBuffer += (DEVLEN + 1) * sizeof(TCHAR);
    }
    else {
        *Local = NULL;
    }

    IF_DEBUG(USE) {
        NetpKdPrint(("                               Local x%08lx\n", *Local));
    }


    if (Level >= 2) {

        if (UseInfo->ui2_username != NULL) {
            *UserName = (LPTSTR) WorkBuffer;
            WorkBuffer += (UNLEN + 1) * sizeof(TCHAR);
        }
        else {
            *UserName = NULL;
        }

        if (UseInfo->ui2_domainname != NULL) {
            *DomainName = (LPTSTR) WorkBuffer;
        }
        else {
            *DomainName = NULL;
        }
    }

    IF_DEBUG(USE) {
        NetpKdPrint(("                               UserName x%08lx, DomainName x%08lx\n",
                     *UserName, *DomainName));
    }

    return NERR_Success;
}


#if DBG

STATIC
VOID
DumpUseList(
    DWORD Index
    )
/*++

Routine Description:

    This function dumps the user's use list for debugging purposes.

Arguments:

    Index - Supplies the index to the user entry in the Use Table.

Return Value:

    None.

--*/
{
    PUSE_ENTRY UseList = (PUSE_ENTRY) Use.Table[Index].List;

    IF_DEBUG(USE) {
        NetpKdPrint(("\nDump Use List @%08lx\n", UseList));

        while (UseList != NULL) {
            NetpKdPrint(("%ws   %ws\n", UseList->Local,
                         UseList->Remote->UncName));

            NetpKdPrint(("usecount=%lu, totalusecount=%lu\n",
                         UseList->UseCount, UseList->Remote->TotalUseCount));
            NetpKdPrint(("Connection handle %08lx, resume key=%lu\n",
                         UseList->TreeConnection, UseList->ResumeKey));

            UseList = UseList->Next;
        }
    }
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\ws.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ws.h

Abstract:

    Private header file for the NT Workstation service included by every
    module of the Workstation service.

Author:

    Rita Wong (ritaw) 15-Feb-1991

Revision History:

--*/

#ifndef _WS_INCLUDED_
#define _WS_INCLUDED_


#include <nt.h>                   // NT definitions
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>

#include <windef.h>               // Win32 type definitions
#include <winbase.h>              // Win32 base API prototypes
#include <winsvc.h>               // Win32 service control APIs

#include <lmcons.h>               // LAN Manager common definitions
#include <lmerr.h>                // LAN Manager network error definitions
#include <lmsname.h>              // LAN Manager service names
#include <lmapibuf.h>             // NetApiBufferFree

#include <netlib.h>               // LAN Man utility routines
#include <netlibnt.h>             // NetpNtStatusToApiStatus
#include <netdebug.h>             // NetpDbgPrint
#include <tstring.h>              // Transitional string functions
#include <icanon.h>               // I_Net canonicalize functions
#include <align.h>                // ROUND_UP_COUNT macro

#include <rpc.h>                  // DataTypes and runtime APIs
#include <rpcutil.h>              // Prototypes for MIDL user functions
#include <wkssvc.h>               // Generated by the MIDL complier


//
// Debug trace level bits for turning on/off trace statements in the
// Workstation service
//

//
// NetWksta[Get|Set]Info APIs
//
#define WKSTA_DEBUG_INFO         0x00000001

//
// NetWkstaUser APIs
//
#define WKSTA_DEBUG_USER         0x00000002

//
// NetUse APIs
//
#define WKSTA_DEBUG_USE          0x00000004

//
// NetAlert APIs
//
#define WKSTA_DEBUG_ALERT        0x00000008

//
// NetServerEnum
//
#define WKSTA_DEBUG_SERVER_ENUM  0x00000010

//
// Utility trace statements
//
#define WKSTA_DEBUG_UTIL         0x00000020

//
// Configuration trace statements
//
#define WKSTA_DEBUG_CONFIG       0x00000040

//
// Main service functionality
//
#define WKSTA_DEBUG_MAIN         0x00000080

//
// NetMessageBufferSend
//
#define WKSTA_DEBUG_MESSAGE      0x00000100

//
// Logon support trace statements
//
#define WKSTA_DEBUG_LOGON        0x00000200

//
// Logon support trace statements
//
#define WKSTA_DEBUG_START        0x00000400

//
// All debug flags on
//
#define WKSTA_DEBUG_ALL          0xFFFFFFFF


#if DBG

#define STATIC

extern DWORD WorkstationTrace;

#define DEBUG if (TRUE)

#define IF_DEBUG(Function) if (WorkstationTrace & WKSTA_DEBUG_ ## Function)

#else

#define STATIC static

#define DEBUG if (FALSE)

#define IF_DEBUG(Function) if (FALSE)

#endif // DBG

extern NET_API_STATUS
WsUpdateStatus(
    VOID
    );

#endif // ifdef _WS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\user.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    user.c

Abstract:

    This module contains the worker routines for the NetWkstaUser
    APIs implemented in the Workstation service.

Author:

    Rita Wong (ritaw) 20-Feb-1991

Revision History:

--*/

#include "wsutil.h"
#include "wsdevice.h"
#include "wssec.h"
#include "wsconfig.h"
#include "wslsa.h"
#include "wswksta.h"

#include <strarray.h>
#include <config.h>     // NT config file helpers in netlib
#include <configp.h>    // USE_WIN32_CONFIG (if defined), etc.
#include <confname.h>   // Section and keyword equates.

#include "wsregcfg.h"   // Registry helpers

#define WS_OTH_DOMAIN_DELIMITER_STR   L" "
#define WS_OTH_DOMAIN_DELIMITER_CHAR  L' '

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
WsGetUserInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    OUT PMSV1_0_GETUSERINFO_RESPONSE *UserInfoResponse,
    OUT PDGRECEIVE_NAMES *DgrNames,
    OUT LPDWORD DgrNamesCount,
    IN  OUT LPDWORD TotalBytesNeeded OPTIONAL
    );

STATIC
NET_API_STATUS
WsGetActiveDgrNames(
    IN  PLUID LogonId,
    OUT PDGRECEIVE_NAMES *DgrNames,
    OUT LPDWORD DgrNamesCount,
    IN  OUT LPDWORD TotalBytesNeeded OPTIONAL
    );

STATIC
NET_API_STATUS
WsSetOtherDomains(
    IN  DWORD   Level,
    IN  LPBYTE  Buffer
    );

STATIC
NET_API_STATUS
WsEnumUserInfo(
    IN  DWORD Level,
    IN  DWORD PreferedMaximumLength,
    IN  PMSV1_0_ENUMUSERS_RESPONSE EnumUsersResponse,
    OUT LPBYTE *OutputBuffer,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    );

STATIC
NET_API_STATUS
WsPackageUserInfo(
    IN  DWORD Level,
    IN  DWORD UserInfoFixedLength,
    IN  PMSV1_0_GETUSERINFO_RESPONSE UserInfoResponse,
    IN  PDGRECEIVE_NAMES DgrNames,
    IN  DWORD DgrNamesCount,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  OUT LPDWORD EntriesRead OPTIONAL
    );

STATIC
BOOL
WsFillUserInfoBuffer(
    IN  DWORD Level,
    IN  PMSV1_0_GETUSERINFO_RESPONSE UserInfo,
    IN  PDGRECEIVE_NAMES DgrNames,
    IN  DWORD DgrNamesCount,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  DWORD UserInfoFixedLength
    );

STATIC
VOID
WsWriteOtherDomains(
    IN  PDGRECEIVE_NAMES DgrNames,
    IN  DWORD DgrNamesCount,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  DWORD UserInfoFixedLength,
    OUT LPWSTR *OtherDomainsPointer
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//



NET_API_STATUS NET_API_FUNCTION
NetrWkstaUserGetInfo(
    IN  LPTSTR Reserved,
    IN  DWORD Level,
    OUT LPWKSTA_USER_INFO UserInfo
    )
/*++

Routine Description:

    This function is the NetWkstaUserGetInfo entry point in the Workstation
    service.  It calls the LSA subsystem and the MSV1_0 authentication
    package to get per user information.

Arguments:

    Reserved - Must be 0.

    Level - Supplies the requested level of information.

    UserInfo - Returns, in this structure, a pointer to a buffer which
         contains the requested user information.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    LUID LogonId;

    PMSV1_0_GETUSERINFO_RESPONSE UserInfoResponse = NULL;
    LPBYTE FixedPortion;
    LPTSTR EndOfVariableData;

    DWORD UserInfoFixedLength = USER_FIXED_LENGTH(Level);
    LPBYTE OutputBuffer;

    DWORD TotalBytesNeeded = 0;

    PDGRECEIVE_NAMES DgrNames = NULL;
    DWORD DgrNamesCount;


    if (Reserved != NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Levels 0, 1, and 1101 are valid
    //
    if (Level > 1 && Level != 1101) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // Impersonate caller and get the logon id
    //
    if ((status = WsImpersonateAndGetLogonId(&LogonId)) != NERR_Success) {
        return status;
    }

    if ((status = WsGetUserInfo(
                      &LogonId,
                      Level,
                      &UserInfoResponse,
                      &DgrNames,
                      &DgrNamesCount,
                      &TotalBytesNeeded
                      )) != NERR_Success) {
        return status;
    }

    if ((OutputBuffer = MIDL_user_allocate(TotalBytesNeeded)) == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FreeBuffers;
    }
    RtlZeroMemory((PVOID) OutputBuffer, TotalBytesNeeded);

    SET_USER_INFO_POINTER(UserInfo, OutputBuffer);


    //
    // Write the user information into output buffer.
    //
    FixedPortion = OutputBuffer;
    EndOfVariableData = (LPTSTR) ((DWORD_PTR) FixedPortion + TotalBytesNeeded);

    status = WsPackageUserInfo(
                 Level,
                 UserInfoFixedLength,
                 UserInfoResponse,
                 DgrNames,
                 DgrNamesCount,
                 &FixedPortion,
                 &EndOfVariableData,
                 NULL
                 );

    NetpAssert(status == NERR_Success);

FreeBuffers:
    if (UserInfoResponse != NULL) {
        (void) LsaFreeReturnBuffer((PVOID) UserInfoResponse);
    }

    if (DgrNames != NULL) {
        MIDL_user_free((PVOID) DgrNames);
    }

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetrWkstaUserSetInfo(
    IN  LPTSTR Reserved,
    IN  DWORD Level,
    IN  LPWKSTA_USER_INFO UserInfo,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function is the NetWkstaUserSetInfo entry point in the Workstation
    service.  It sets the other domains for the current user.

Arguments:

    Reserved - Must be NULL.

    Level - Supplies the level of information.

    UserInfo - Supplies a pointer to union structure of pointers to
        buffer of fields to set.  The level denotes the fields supplied in
        this buffer.

    ErrorParameter - Returns the identifier to the invalid parameter if
        this function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;


    if (Reserved != NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Only admins can set redirector configurable fields.  Validate access.
    //
    if (NetpAccessCheckAndAudit(
            WORKSTATION_DISPLAY_NAME,        // Subsystem name
            (LPTSTR) CONFIG_INFO_OBJECT,     // Object type name
            ConfigurationInfoSd,             // Security descriptor
            WKSTA_CONFIG_INFO_SET,           // Desired access
            &WsConfigInfoMapping             // Generic mapping
            ) != NERR_Success) {

        return ERROR_ACCESS_DENIED;
    }

    //
    // Check for NULL input buffer
    //
    if (UserInfo->UserInfo1 == NULL) {
        RETURN_INVALID_PARAMETER(ErrorParameter, PARM_ERROR_UNKNOWN);
    }

    //
    // Serialize write access
    //
    if (! RtlAcquireResourceExclusive(&WsInfo.ConfigResource, TRUE)) {
        return NERR_InternalError;
    }

    switch (Level) {

        //
        // Other domains is the only settable field in the entire
        // system-wide info structure
        //
        case 1:
        case 1101:

            if ((status = WsSetOtherDomains(
                                  Level,
                                  (LPBYTE) UserInfo->UserInfo1
                                  )) == ERROR_INVALID_PARAMETER) {
                if (ARGUMENT_PRESENT(ErrorParameter)) {
                    *ErrorParameter = WKSTA_OTH_DOMAINS_PARMNUM;
                }
            }
            break;

        default:
                status = ERROR_INVALID_LEVEL;
    }

    RtlReleaseResource(&WsInfo.ConfigResource);
    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetrWkstaUserEnum(
    IN  LPTSTR ServerName OPTIONAL,
    IN  OUT LPWKSTA_USER_ENUM_STRUCT UserInfo,
    IN  DWORD PreferedMaximumLength,
    OUT LPDWORD TotalEntries,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    )
/*++

Routine Description:

    This function is the NetWkstaUserEnum entry point in the Workstation
    service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    UserInfo - This structure supplies the level of information requested,
        returns a pointer to the buffer allocated by the Workstation service
        which contains a sequence of information structure of the specified
        information level, and returns the number of entries read.  The buffer
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.  The EntriesRead
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    PreferedMaximumLength - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, all available
        information will be returned.

    TotalEntries - Returns the total number of entries available.  This value
        is only valid if the return code is NERR_Success or ERROR_MORE_DATA.

    ResumeHandle - Supplies a handle to resume the enumeration from where it
        left off the last time through.  Returns the resume handle if return
        code is ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    PMSV1_0_ENUMUSERS_RESPONSE EnumUsersResponse = NULL;
    
    UNREFERENCED_PARAMETER(ServerName);

    //
    // Only levels 0 and 1
    //
    if (UserInfo->Level > 1) {
        return ERROR_INVALID_LEVEL;
    }

    if( UserInfo->WkstaUserInfo.Level1 == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (WsLsaRestrictAnonymous > 0) {
        //
        // Perform access validation on the caller.
        //
        if (NetpAccessCheckAndAudit(
                WORKSTATION_DISPLAY_NAME,        // Subsystem name
                (LPTSTR) CONFIG_INFO_OBJECT,     // Object type name
                ConfigurationInfoSd,             // Security descriptor
                WKSTA_CONFIG_ADMIN_INFO_GET,     // Desired access
                &WsConfigInfoMapping             // Generic mapping
                ) != NERR_Success) {

            return ERROR_ACCESS_DENIED;
        }
    }

    //
    // Ask authentication package to enumerate users who are physically
    // logged to the local machine.
    //
    if ((status = WsLsaEnumUsers(
                      (LPBYTE *) &EnumUsersResponse
                      )) != NERR_Success) {
        return status;
    }

    if (EnumUsersResponse == NULL) {
        return ERROR_GEN_FAILURE;
    }

    //
    // If no users are logged on, set appropriate fields and return success.
    //
    if (EnumUsersResponse->NumberOfLoggedOnUsers == 0) {
        UserInfo->WkstaUserInfo.Level1->Buffer = NULL;
        UserInfo->WkstaUserInfo.Level1->EntriesRead = 0;
        *TotalEntries = 0;
        status = NERR_Success;
    } else {
        status = WsEnumUserInfo(
                     UserInfo->Level,
                     PreferedMaximumLength,
                     EnumUsersResponse,
                     (LPBYTE *) &(UserInfo->WkstaUserInfo.Level1->Buffer),
                     (LPDWORD) &(UserInfo->WkstaUserInfo.Level1->EntriesRead),
                     TotalEntries,
                     ResumeHandle
                     );
    }

    (void) LsaFreeReturnBuffer((PVOID) EnumUsersResponse);

    return status;
}



STATIC
NET_API_STATUS
WsEnumUserInfo(
    IN  DWORD Level,
    IN  DWORD PreferedMaximumLength,
    IN  PMSV1_0_ENUMUSERS_RESPONSE EnumUsersResponse,
    OUT LPBYTE *OutputBuffer,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    )
/*++

Routine Description:

    This function takes the logon IDs returned by MS V1.0 Authentication
    Package to call it again to get information about each user.

Arguments:

    Level - Supplies the level of information to be returned.

    PreferedMaximumLength - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, all available
        information will be returned.

    EnumUsersResponse - Supplies the structure returned from calling the MS
        V1.0 Authentication Package to enumerate logged on users.

    OutputBuffer - Returns a pointer to the enumerated user information.

    TotalEntries - Returns the total number of entries available.  This value
        is only valid if the return code is NERR_Success or ERROR_MORE_DATA.

    EntriesRead - Supplies a running total of the number of entries read
        into the output buffer.  This value is incremented every time a
        user entry is successfully written into the output buffer.

    ResumeHandle - Returns the handle to continue with the enumeration if
        this function returns ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;

    //
    // Array of per user info entries, each entry contains a pointer
    // LSA info, and a pointer to active datagram receiver names.
    //
    PWSPER_USER_INFO UserInfoArray;

    DWORD UserInfoFixedLength = USER_FIXED_LENGTH(Level);
    DWORD i;
    DWORD OutputBufferLength = 0;
    DWORD UserEntriesRead = 0;
    DWORD OtherDomainsSize = 0;

    LPDWORD PointerToOutputBufferLength = &OutputBufferLength;

    LPBYTE FixedPortion;
    LPTSTR EndOfVariableData;

    DWORD StartEnumeration = 0;


    if (PreferedMaximumLength != MAXULONG) {

        //
        // We will return as much as possible that fits into this specified
        // buffer size.
        //
        OutputBufferLength =
            ROUND_UP_COUNT(PreferedMaximumLength, ALIGN_WCHAR);

        if (OutputBufferLength < UserInfoFixedLength) {
            *OutputBuffer = NULL;
            *EntriesRead = 0;
            *TotalEntries = EnumUsersResponse->NumberOfLoggedOnUsers;

            return ERROR_MORE_DATA;
        }

        //
        // This indicates that we should not bother calculating the
        // total output buffer size needed.
        //
        PointerToOutputBufferLength = NULL;
    }

    //
    // Allocate a temporary array to save pointers to user information
    // we retrieve from the LSA and datagram receiver.  This is because we
    // need to go through the list of users twice: the first time to add
    // up the number of bytes to allocate for the output buffer; the second
    // time to write the user information into the output buffer.
    //
    if ((UserInfoArray = (PWSPER_USER_INFO) LocalAlloc(
                                                LMEM_ZEROINIT,
                                                EnumUsersResponse->NumberOfLoggedOnUsers *
                                                    sizeof(WSPER_USER_INFO)
                                                )) == NULL) {
        return GetLastError();
    }

    //
    // Get the info for each user and calculate the amount of memory to
    // allocate for the output buffer if PointerToOutputBufferLength is
    // not set to NULL.  If it was set to NULL, we will allocate the
    // output buffer size as specified by the caller.
    //
    for (i = 0; i < EnumUsersResponse->NumberOfLoggedOnUsers; i++) {

        if ((status = WsGetUserInfo(
                          &(EnumUsersResponse->LogonIds[i]),
                          Level,
                          (PMSV1_0_GETUSERINFO_RESPONSE *) &(UserInfoArray[i].LsaUserInfo),
                          (PDGRECEIVE_NAMES *) &UserInfoArray[i].DgrNames,
                          (LPDWORD) &UserInfoArray[i].DgrNamesCount,
                          PointerToOutputBufferLength
                          )) != NERR_Success) {
            goto FreeBuffers;
        }

    }

    IF_DEBUG(INFO) {
        NetpKdPrint(("[Wksta] NetrWkstaUserEnum: OutputBufferLength=%lu\n",
                     OutputBufferLength));
    }

    //
    // Allocate the output buffer
    //
    if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FreeBuffers;
    }

    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

    FixedPortion = *OutputBuffer;
    EndOfVariableData = (LPTSTR) ((DWORD_PTR) FixedPortion + OutputBufferLength);

    //
    // Get the enumeration starting point.
    //
    if (ARGUMENT_PRESENT(ResumeHandle)) {
        StartEnumeration = *ResumeHandle;
    }

    //
    // Enumerate the user information
    //
    for (i = 0; i < EnumUsersResponse->NumberOfLoggedOnUsers &&
                status == NERR_Success; i++) {

        IF_DEBUG(INFO) {
            NetpKdPrint(("LsaList->ResumeKey=%lu\n",
                         EnumUsersResponse->EnumHandles[i]));
        }

        if (StartEnumeration <= EnumUsersResponse->EnumHandles[i]) {

            status = WsPackageUserInfo(
                        Level,
                        UserInfoFixedLength,
                        UserInfoArray[i].LsaUserInfo,
                        UserInfoArray[i].DgrNames,
                        UserInfoArray[i].DgrNamesCount,
                        &FixedPortion,
                        &EndOfVariableData,
                        &UserEntriesRead
                        );

            if (status == ERROR_MORE_DATA) {
                *TotalEntries = (EnumUsersResponse->NumberOfLoggedOnUsers
                                 - i) + UserEntriesRead;
            }
        }
    }

    //
    // Return entries read and total entries.  We can only get NERR_Success
    // or ERROR_MORE_DATA from WsPackageUserInfo.
    //
    *EntriesRead = UserEntriesRead;

    if (status == NERR_Success) {
       *TotalEntries = UserEntriesRead;
    }

    if (status == ERROR_MORE_DATA && ARGUMENT_PRESENT(ResumeHandle)) {
        *ResumeHandle = EnumUsersResponse->EnumHandles[i - 1];
    }

    if (*EntriesRead == 0) {
        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;
    }

FreeBuffers:
    for (i = 0; i < EnumUsersResponse->NumberOfLoggedOnUsers; i++) {

        if (UserInfoArray[i].DgrNames != NULL) {
            MIDL_user_free((PVOID) UserInfoArray[i].DgrNames);
        }

        if (UserInfoArray[i].LsaUserInfo != NULL) {
            (void) LsaFreeReturnBuffer((PVOID) UserInfoArray[i].LsaUserInfo);
        }
    }

    (void) LocalFree((HLOCAL) UserInfoArray);

    return status;
}


STATIC
NET_API_STATUS
WsGetUserInfo(
    IN  PLUID LogonId,
    IN  DWORD Level,
    OUT PMSV1_0_GETUSERINFO_RESPONSE *UserInfoResponse,
    OUT PDGRECEIVE_NAMES *DgrNames,
    OUT LPDWORD DgrNamesCount,
    IN  OUT LPDWORD TotalBytesNeeded OPTIONAL
    )
/*++

Routine Description:

    This function gets the other domains for the current user from
    the datagram receiver.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    Level - Supplies the level of information to be returned.

    UserInfoResponse - Returns a pointer to the user information from the
        authentication package.

    DgrNames - Returns a pointer an array of active datagram receiver
        names.

    DgrNamesCount - Returns the number of entries in DgrNames.

    TotalBytesNeeded - Returns the number of bytes required to in the
        output buffer for writing the other domains to.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    ULONG UserInfoResponseLength;

    DWORD OtherDomainsSize = 0;


    //
    // Ask the datagram receiver for the other domains
    //
    if (Level == 1 || Level == 1101) {
        if ((status = WsGetActiveDgrNames(
                          LogonId,
                          DgrNames,
                          DgrNamesCount,
                          TotalBytesNeeded
                          )) != NERR_Success) {
            return status;
        }
    }

    //
    // Don't get user info from authentication package if level
    // is 1101 since only other domains are returned in this level.
    //
    if (Level != 1101) {

        //
        // Ask authentication package for user information.
        //
        if ((status = WsLsaGetUserInfo(
                          LogonId,
                          (LPBYTE *) UserInfoResponse,
                          &UserInfoResponseLength
                          )) != NERR_Success) {

            MIDL_user_free((PVOID) *DgrNames);
            *DgrNames = NULL;
            *DgrNamesCount = 0;
            return status;
        }

        //
        // Calculate the amount of memory needed to hold the user information
        // and allocate the return buffer of that size.
        //
        if (ARGUMENT_PRESENT(TotalBytesNeeded)) {
            (*TotalBytesNeeded) +=
                FIXED_PLUS_LSA_SIZE(
                    Level,
                    (*UserInfoResponse)->UserName.Length +
                        sizeof(TCHAR),
                    (*UserInfoResponse)->LogonDomainName.Length +
                        sizeof(TCHAR),
                    (*UserInfoResponse)->LogonServer.Length +
                        sizeof(TCHAR)
                    );
        }
    }
    else {
        *TotalBytesNeeded += USER_FIXED_LENGTH(Level);
    }

    return NERR_Success;
}


STATIC
NET_API_STATUS
WsGetActiveDgrNames(
    IN  PLUID LogonId,
    OUT PDGRECEIVE_NAMES *DgrNames,
    OUT LPDWORD DgrNamesCount,
    IN  OUT LPDWORD TotalBytesNeeded OPTIONAL
    )
/*++

Routine Description:

    This function gets the other domains for the current user from
    the datagram receiver.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    DgrNames - Returns a pointer an array of active datagram receiver
        names.

    DgrNamesCount - Returns the number of entries in DgrNames.

    TotalBytesNeeded - Returns the number of bytes required to in the
        output buffer for writing the other domains to.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    LMDR_REQUEST_PACKET Drp;        // Datagram receiver request packet
    DWORD EnumDgNamesHintSize = 0;
    DWORD i;

    Drp.Version = LMDR_REQUEST_PACKET_VERSION;
    Drp.Type = EnumerateNames;
    RtlCopyLuid(&Drp.LogonId, LogonId);
    Drp.Parameters.EnumerateNames.ResumeHandle = 0;
    Drp.Parameters.EnumerateNames.TotalBytesNeeded = 0;
    
    //
    // Get the other domains from the datagram receiver.
    //
    if ((status = WsDeviceControlGetInfo(
                      DatagramReceiver,
                      WsDgReceiverDeviceHandle,
                      IOCTL_LMDR_ENUMERATE_NAMES,
                      (PVOID) &Drp,
                      sizeof(LMDR_REQUEST_PACKET),
                      (LPBYTE *) DgrNames,
                      MAXULONG,
                      EnumDgNamesHintSize,
                      NULL
                      )) != NERR_Success) {
        return status;
    }

    //
    // Include room for NULL character, in case there are no
    // other domains
    //
    if (ARGUMENT_PRESENT(TotalBytesNeeded)) {
        (*TotalBytesNeeded) += sizeof(TCHAR);
    }


    *DgrNamesCount = Drp.Parameters.EnumerateNames.EntriesRead;

    if (*DgrNamesCount == 0 && *DgrNames != NULL) {
        MIDL_user_free((PVOID) *DgrNames);
        *DgrNames = NULL;
    }

    //
    // Calculate the amount of memory to allocate for the output buffer
    //
    if (ARGUMENT_PRESENT(TotalBytesNeeded)) {
        for (i = 0; i < *DgrNamesCount; i++) {

            //
            // Add up the lengths of all the other domain names
            //
            if ((*DgrNames)[i].Type == OtherDomain) {
                (*TotalBytesNeeded) += (*DgrNames)[i].DGReceiverName.Length +
                                           sizeof(TCHAR);
            }
        }
    }

    return NERR_Success;
}


STATIC
NET_API_STATUS
WsSetOtherDomains(
    IN  DWORD   Level,
    IN  LPBYTE  Buffer
    )
/*++

Routine Description:

    This function sets the other domains for the current user in
    the datagram receiver.

Arguments:

    Level - Supplies the level of information.

    Buffer - Supplies a buffer which contains the information structure
        if Parameter is WkstaSetAllParm.  Otherwise Buffer contains the
        individual field to set.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;

    PCHAR DrpBuffer[sizeof(LMDR_REQUEST_PACKET) +
                    DNLEN * sizeof(TCHAR)];
    PLMDR_REQUEST_PACKET Drp = (PLMDR_REQUEST_PACKET) DrpBuffer;
    DWORD DrpSize = sizeof(LMDR_REQUEST_PACKET) +
                      DNLEN * sizeof(TCHAR);

    PDGRECEIVE_NAMES DgrNames;
    DWORD DgrNamesCount;
    DWORD EnumDgNamesHintSize = 0;

    DWORD NumberOfOtherDomains = 0;
    DWORD i, j, k;
    DWORD IndexToList = 0;

    PWSNAME_RECORD OtherDomainsInfo = NULL;
    LPTSTR OtherDomainsPointer;
    LPTSTR OtherDomains;

    LPTSTR CanonBuffer;
    DWORD CanonBufferSize;


    if (Level == 1101) {
        OtherDomains = ((PWKSTA_USER_INFO_1101) Buffer)->wkui1101_oth_domains;
    }
    else {
        OtherDomains = ((PWKSTA_USER_INFO_1) Buffer)->wkui1_oth_domains;
    }

    //
    // NULL pointer means leave the other domains unmodified
    //
    if (OtherDomains == NULL) {
        return NERR_Success;
    }

    IF_DEBUG(INFO) {
        NetpKdPrint(("WsSetOtherDomains: Input other domain is %ws\n", OtherDomains));
    }

    //
    // Before canonicalizing the input buffer, we have to find out how
    // many other domain entries are there so that we can supply a
    // buffer of the right size to the canonicalize routine.
    //
    OtherDomainsPointer = OtherDomains;
    while (*OtherDomainsPointer != TCHAR_EOS) {
        if (*(OtherDomainsPointer + 1) == WS_OTH_DOMAIN_DELIMITER_CHAR ||
            *(OtherDomainsPointer + 1) == TCHAR_EOS) {
            NumberOfOtherDomains++;
        }

        OtherDomainsPointer++;
    }

    //
    // Allocate the buffer to put the canonicalized other domain names
    //
    CanonBufferSize = NumberOfOtherDomains * (DNLEN + 1) * sizeof(TCHAR) +
                      sizeof(TCHAR);    // One more char for the NULL terminator

    if ((CanonBuffer = (LPTSTR) LocalAlloc(
                                    LMEM_ZEROINIT,
                                    (UINT) CanonBufferSize
                                    )) == NULL) {
        return GetLastError();
    }

    //
    // Canonicalize the input other domains separated by NULLs and put
    // into CanonBuffer, each other domain name separated by NULL, and
    // the buffer itself terminated by another NULL.
    //
    status = I_NetListCanonicalize(
                 NULL,
                 OtherDomains,
                 WS_OTH_DOMAIN_DELIMITER_STR,
                 CanonBuffer,
                 CanonBufferSize,
                 &NumberOfOtherDomains,
                 NULL,
                 0,
                 OUTLIST_TYPE_NULL_NULL |
                     NAMETYPE_DOMAIN    |
                     INLC_FLAGS_CANONICALIZE
                 );

    if (status != NERR_Success) {
        NetpKdPrint(("[Wksta] Error in canonicalizing other domains %lu",
                     status));
        status = ERROR_INVALID_PARAMETER;
        goto FreeCanonBuffer;
    }

    //
    // Initialize datagram receiver packet to add or delete
    // other domains.
    //
    Drp->Version = LMDR_REQUEST_PACKET_VERSION;
    Drp->Type = EnumerateNames;
    Drp->Parameters.AddDelName.Type = OtherDomain;

    if ((status = WsImpersonateAndGetLogonId(
                      &Drp->LogonId
                      )) != NERR_Success) {
        goto FreeCanonBuffer;
    }

    //
    // Get all datagram receiver names from the datagram receiver.
    //
    if ((status = WsDeviceControlGetInfo(
                      DatagramReceiver,
                      WsDgReceiverDeviceHandle,
                      IOCTL_LMDR_ENUMERATE_NAMES,
                      (PVOID) Drp,
                      DrpSize,
                      (LPBYTE *) &DgrNames,
                      MAXULONG,
                      EnumDgNamesHintSize,
                      NULL
                      )) != NERR_Success) {
        goto FreeCanonBuffer;
    }

    DgrNamesCount = Drp->Parameters.EnumerateNames.EntriesRead;

    //
    // The other domains the user wants to set has to be merged with the
    // one that is maintained by the datagram receiver.  We will attempt
    // to add all the other domains first.  If it already exists, we ignore
    // the error.  If it was added successfully, we mark it as such so that
    // if we run into an error other than the already exist error, we can
    // back out the ones we've already added.
    //
    // This requires that we allocate a structure to keep track of the ones
    // we've added.
    //
    if (NumberOfOtherDomains != 0) {
        if ((OtherDomainsInfo = (PWSNAME_RECORD) LocalAlloc(
                                                     LMEM_ZEROINIT,
                                                     (UINT) (NumberOfOtherDomains *
                                                                 sizeof(WSNAME_RECORD))
                                                     )) == NULL) {
            status = GetLastError();
            goto FreeDgrNames;
        }


        //
        // Add all other domains specified.  If any already exist, we ignore
        // the error from the datagram receiver.
        //
        OtherDomains = CanonBuffer;
        while ((OtherDomainsPointer = I_NetListTraverse(
                                          NULL,
                                          &OtherDomains,
                                          0
                                          )) != NULL) {

            OtherDomainsInfo[IndexToList].Name = OtherDomainsPointer;
            OtherDomainsInfo[IndexToList].Size =
                STRLEN(OtherDomainsPointer) * sizeof(TCHAR);

            for (j = 0; j < DgrNamesCount; j++) {

                if (DgrNames[j].Type == OtherDomain) {

                    if (WsCompareStringU(
                            DgrNames[j].DGReceiverName.Buffer,
                            DgrNames[j].DGReceiverName.Length / sizeof(TCHAR),
                            OtherDomainsPointer,
                            OtherDomainsInfo[IndexToList].Size / sizeof(TCHAR)
                            ) == 0) {

                        break;
                    }
                }
            }

            //
            // User-specified domain does not already exist, so add it.
            //
            if (j == DgrNamesCount) {

                Drp->Parameters.AddDelName.Type = OtherDomain;
                status = WsAddDomainName(
                             Drp,
                             DrpSize,
                             OtherDomainsPointer,
                             OtherDomainsInfo[IndexToList].Size
                             );

                if (status == NERR_Success) {

                    OtherDomainsInfo[IndexToList].IsAdded = TRUE;

                    IF_DEBUG(INFO) {
                        NetpKdPrint((
                            "[Wksta] Successfully added other domain %ws\n",
                            OtherDomainsPointer
                            ));
                    }

                }
                else {

                    //
                    // We're ran into trouble and have to delete those
                    // we've just added.
                    //
                    IF_DEBUG(INFO) {
                        NetpKdPrint((
                            "[Wksta] Trouble with adding other domain %ws %lu\n",
                            OtherDomainsPointer, status
                            ));
                    }

                    for (i = 0; i < IndexToList; i++) {
                        if (OtherDomainsInfo[i].IsAdded) {

                            IF_DEBUG(INFO) {
                                NetpKdPrint(("[Wksta] About to remove %ws\n",
                                             OtherDomainsInfo[i].Name));
                            }

                            Drp->Parameters.AddDelName.Type = OtherDomain;
                            (void) WsDeleteDomainName(
                                       Drp,
                                       DrpSize,
                                       OtherDomainsInfo[i].Name,
                                       OtherDomainsInfo[i].Size
                                       );
                        }
                    }
                    goto FreeDomainInfo;

                } // back out added domains

            } // attempted to add a non-existing domain name

            IndexToList++;

        } // while there is a user-specified domain name

    } // if NumberOfOtherDomains != 0

    //
    // Now we need to delete an active domain name from the Datagram
    // Receiver if it is not in the input other domain list.
    //
    for (i = 0; i < DgrNamesCount; i++) {

        if (DgrNames[i].Type == OtherDomain) {

            for (j = 0; j < NumberOfOtherDomains; j++) {

                if (WsCompareStringU(
                        DgrNames[i].DGReceiverName.Buffer,
                        DgrNames[i].DGReceiverName.Length / sizeof(TCHAR),
                        OtherDomainsInfo[j].Name,
                        OtherDomainsInfo[j].Size / sizeof(TCHAR)
                        ) == 0) {

                    break;
                }
            }

            //
            // Did not find the active other domain name in the
            // input list.  We have to delete it.
            //
            if (j == NumberOfOtherDomains) {

                Drp->Parameters.AddDelName.Type = OtherDomain;
                status = WsDeleteDomainName(
                             Drp,
                             DrpSize,
                             DgrNames[i].DGReceiverName.Buffer,
                             DgrNames[i].DGReceiverName.Length
                             );

                //
                // Save the delete status of the other domain name away
                // because we might run into a problem and have to back
                // out the deletion later.  What a mess!
                //
                if (status == NERR_Success) {

                    IF_DEBUG(INFO) {
                        NetpKdPrint((
                            "[Wksta] Successfully deleted other domain\n"));
                            //"[Wksta] Successfully deleted other domain %wZ\n",
                            //DgrNames[i].DGReceiverName);
                    }

                    DgrNames[i].Type = DGR_NAME_DELETED;
                }
                else {

                    //
                    // Could not delete the name.  Back all successful
                    // changes so far--this includes adding the names
                    // that were deleted, and removing the names that
                    // were added.
                    //
                    IF_DEBUG(INFO) {
                        NetpKdPrint((
                            "[Wksta] Trouble with deleting other domain %lu\n",
                            status));
                            //"[Wksta] Trouble with deleting other domain %wZ %lu\n",
                            //DgrNames[i].DGReceiverName, status);
                    }

                    //
                    // Add back all deleted names
                    //
                    for (k = 0; k < i; k++) {
                        if (DgrNames[k].Type == DGR_NAME_DELETED) {

                            IF_DEBUG(INFO) {
                                NetpKdPrint(("[Wksta] About to add back %wZ\n",
                                             DgrNames[k].DGReceiverName));
                            }

                            Drp->Parameters.AddDelName.Type = OtherDomain;
                            (void) WsAddDomainName(
                                       Drp,
                                       DrpSize,
                                       DgrNames[k].DGReceiverName.Buffer,
                                       DgrNames[k].DGReceiverName.Length
                                       );

                        }

                    } // back out deletions

                    //
                    // Remove all added names
                    //
                    for (k = 0; k < NumberOfOtherDomains; k++) {
                        if (OtherDomainsInfo[k].IsAdded) {

                            IF_DEBUG(INFO) {
                                NetpKdPrint(("[Wksta] About to remove %ws\n",
                                             OtherDomainsInfo[k].Name));
                            }

                            Drp->Parameters.AddDelName.Type = OtherDomain;
                            (void) WsDeleteDomainName(
                                       Drp,
                                       DrpSize,
                                       OtherDomainsInfo[k].Name,
                                       OtherDomainsInfo[k].Size
                                       );
                        }

                    } // back out additions

                    goto FreeDomainInfo;

                } // back out all changes so far

            } // delete the active other domain
        }
    }


    //
    // Make other domains persistent by writing to the registry
    //
    if (status == NERR_Success) {

        LPNET_CONFIG_HANDLE SectionHandle = NULL;


        if (NetpOpenConfigData(
                &SectionHandle,
                NULL,            // no server name
                SECT_NT_WKSTA,
                FALSE            // not read-only
                ) != NERR_Success) {

            //
            //  Ignore the error if the config section couldn't be found.
            //
            goto FreeDomainInfo;
        }

        //
        // Set value for OtherDomains keyword in the wksta section.
        // This is a "NULL-NULL" array (which corresponds to REG_MULTI_SZ).
        // Ignore error if not set properly in the registry.
        //
        (void) WsSetConfigTStrArray(
                   SectionHandle,
                   WKSTA_KEYWORD_OTHERDOMAINS,
                   CanonBuffer
                   );

        (void) NetpCloseConfigData(SectionHandle);
    }


FreeDomainInfo:
    if (OtherDomainsInfo != NULL) {
        (void) LocalFree((HLOCAL) OtherDomainsInfo);
    }

FreeDgrNames:
    MIDL_user_free((PVOID) DgrNames);

FreeCanonBuffer:
    (void) LocalFree((HLOCAL) CanonBuffer);

    IF_DEBUG(INFO) {
        NetpKdPrint(("WsSetOtherDomains: about to return %lu\n", status));
    }

    return status;
}



STATIC
NET_API_STATUS
WsPackageUserInfo(
    IN  DWORD Level,
    IN  DWORD UserInfoFixedLength,
    IN  PMSV1_0_GETUSERINFO_RESPONSE UserInfoResponse,
    IN  PDGRECEIVE_NAMES DgrNames,
    IN  DWORD DgrNamesCount,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  OUT LPDWORD EntriesRead OPTIONAL
    )
/*++

Routine Description:

    This function writes the user information from LSA and datagram
    receiver into the output buffer.  It increments the EntriesRead
    variable when a user entry is written into the output buffer.

Arguments:

    Level - Supplies the level of information to be returned.

    UserInfoFixedLength - Supplies the length of the fixed portion of the
        information structure.

    UserInfoResponse - Supplies a pointer to the user information from the
        authentication package.

    DgrNames - Supplies an array of active datagram receiver names.

    DgrNamesCount - Supplies the number of entries in DgrNames.

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a user entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the
        user information is written into the output buffer starting from
        the end.

        This pointer is updated after any variable length information is
        written to the output buffer.

    EntriesRead - Supplies a running total of the number of entries read
        into the output buffer.  This value is incremented every time a
        user entry is successfully written into the output buffer.

Return Value:

    NERR_Success - The current entry fits into the output buffer.

    ERROR_MORE_DATA - The current entry does not fit into the output buffer.

--*/
{
    if (((DWORD_PTR) *FixedPortion + UserInfoFixedLength) >=
         (DWORD_PTR) *EndOfVariableData) {

        //
        // Fixed length portion does not fit.
        //
        return ERROR_MORE_DATA;
    }

    if (! WsFillUserInfoBuffer(
              Level,
              UserInfoResponse,
              DgrNames,
              DgrNamesCount,
              FixedPortion,
              EndOfVariableData,
              UserInfoFixedLength
              )) {
        //
        // Variable length portion does not fit.
        //
        return ERROR_MORE_DATA;
    }

    if (ARGUMENT_PRESENT(EntriesRead)) {
        (*EntriesRead)++;
    }

    return NERR_Success;
}




STATIC
BOOL
WsFillUserInfoBuffer(
    IN  DWORD Level,
    IN  PMSV1_0_GETUSERINFO_RESPONSE UserInfo,
    IN  PDGRECEIVE_NAMES DgrNames,
    IN  DWORD DgrNamesCount,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  DWORD UserInfoFixedLength
    )
/*++

Routine Description:

    This function fills an entry in the output buffer with the supplied user
    information.

    NOTE: This function assumes that the fixed size portion will fit into
          the output buffer.

          It also assumes that info structure level 1 is a superset of info
          structure level 0, and that the offset to each common field is
          exactly the same.  This allows us to take advantage of a switch
          statement without a break between the levels.

Arguments:

    Level - Supplies the level of information to be returned.

    UserInfo - Supplies a pointer to the user information from the
        authentication package.

    DgrNames - Supplies an array of active datagram receiver names.

    DgrNamesCount - Supplies the number of entries in DgrNames.

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated after a user entry is written to the
        output buffer.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the use
        information is written into the output buffer starting from the end.
        This pointer is updated after any variable length information is
        written to the output buffer.

    UserInfoFixedLength - Supplies the number of bytes needed to hold the
        fixed size portion.

Return Value:

    Returns TRUE if entire entry fits into output buffer, FALSE otherwise.

--*/
{
    PWKSTA_USER_INFO_1 WkstaUserInfo = (PWKSTA_USER_INFO_1) *FixedPortion;
    PWKSTA_USER_INFO_1101 UserInfo1101 = (PWKSTA_USER_INFO_1101) *FixedPortion;


    *FixedPortion += UserInfoFixedLength;

    switch (Level) {

        case 1:

            //
            // Logon server from authentication package
            //

            if (! WsCopyStringToBuffer(
                      &UserInfo->LogonServer,
                      *FixedPortion,
                      EndOfVariableData,
                      (LPWSTR *) &WkstaUserInfo->wkui1_logon_server
                      )) {
                return FALSE;
            }


            //
            // Logon Domain from authentication package
            //
            if (! WsCopyStringToBuffer(
                      &UserInfo->LogonDomainName,
                      *FixedPortion,
                      EndOfVariableData,
                      (LPWSTR *) &WkstaUserInfo->wkui1_logon_domain
                      )) {
                return FALSE;
            }


            WsWriteOtherDomains(
                DgrNames,
                DgrNamesCount,
                FixedPortion,
                EndOfVariableData,
                UserInfoFixedLength,
                (LPWSTR *) &WkstaUserInfo->wkui1_oth_domains
                );

            //
            // Fall through because level 1 is a superset of level 0
            //

        case 0:

            //
            // User name from authentication package
            //

            if (! WsCopyStringToBuffer(
                      &UserInfo->UserName,
                      *FixedPortion,
                      EndOfVariableData,
                      (LPWSTR *) &WkstaUserInfo->wkui1_username
                      )) {
                return FALSE;
            }

            break;

        case 1101:

            WsWriteOtherDomains(
                DgrNames,
                DgrNamesCount,
                FixedPortion,
                EndOfVariableData,
                UserInfoFixedLength,
                (LPWSTR *) &UserInfo1101->wkui1101_oth_domains
                );

            break;

        default:
            //
            // This should never happen.
            //
            NetpKdPrint(("WsFillUserInfoBuffer: Invalid level %u.\n", Level));
            NetpAssert(FALSE);
    }

    return TRUE;
}


STATIC
VOID
WsWriteOtherDomains(
    IN  PDGRECEIVE_NAMES DgrNames,
    IN  DWORD DgrNamesCount,
    IN  OUT LPBYTE *FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    IN  DWORD UserInfoFixedLength,
    OUT LPWSTR *OtherDomainsPointer
    )
/*++

Routine Description:

    This function writes to the output buffer the other domains field.

Arguments:

    DgrNames - Supplies an array of active datagram receiver names.

    DgrNamesCount - Supplies the number of entries in DgrNames.

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated after a user entry is written to the
        output buffer.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the use
        information is written into the output buffer starting from the end.
        This pointer is updated after any variable length information is
        written to the output buffer.

    UserInfoFixedLength - Supplies the number of bytes needed to hold the
        fixed size portion.

Return Value:

    Returns TRUE if entire entry fits into output buffer, FALSE otherwise.

--*/
{
    DWORD i;
    DWORD OtherDomainsCount = 0;


    //
    // Other domain names form a NULL terminated string each
    // separated by a space.
    //
    for (i = 0; i < DgrNamesCount; i++) {

        if (DgrNames[i].Type == OtherDomain) {

            WsCopyStringToBuffer(
                &DgrNames[i].DGReceiverName,
                *FixedPortion,
                EndOfVariableData,
                OtherDomainsPointer
                );

            OtherDomainsCount++;

            if (OtherDomainsCount > 1) {
                (*OtherDomainsPointer)[
                    STRLEN(*OtherDomainsPointer)
                    ] = WS_OTH_DOMAIN_DELIMITER_CHAR;
            }

            IF_DEBUG(INFO) {
                NetpKdPrint(("[Wksta] Other domains is %ws\n",
                    *OtherDomainsPointer));
            }
        }
    }

    if (OtherDomainsCount == 0) {
        NetpCopyStringToBuffer(
            NULL,
            0,
            *FixedPortion,
            EndOfVariableData,
            OtherDomainsPointer
            );
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\useutil.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    useutil.c

Abstract:

    This module contains the common utility routines for needed to
    implement the NetUse APIs.

Author:

    Rita Wong (ritaw) 10-Mar-1991

Revision History:

--*/

#include "wsutil.h"
#include "wsdevice.h"
#include "wsuse.h"
#include "wsmain.h"
#include <names.h>
#include <winbasep.h>

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
WsGrowUseTable(
    VOID
    );

STATIC
VOID
WsFindLocal(
    IN  PUSE_ENTRY UseList,
    IN  LPTSTR Local,
    OUT PUSE_ENTRY *MatchedPointer,
    OUT PUSE_ENTRY *BackPointer
    );

LPTSTR
WsReturnSessionPath(
    IN  LPTSTR LocalDeviceName
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Redirector name in NT string format
//
UNICODE_STRING RedirectorDeviceName;

//
// Use Table
//
USERS_OBJECT Use;



NET_API_STATUS
WsInitUseStructures(
    VOID
    )
/*++

Routine Description:

    This function creates the Use Table, and initialize the NT-style string
    of the redirector device name.

Arguments:

    None

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    //
    // Initialize NT-style redirector device name string.
    //
    RtlInitUnicodeString(&RedirectorDeviceName, DD_NFS_DEVICE_NAME_U);


    //
    // Allocate and initialize the Use Table which is an array of logged
    // on user entries, with a linked list of use entries for each user.
    //
    return WsInitializeUsersObject(&Use);
}


VOID
WsDestroyUseStructures(
    VOID
    )
/*++

Routine Description:

    This function destroys the Use Table.

Arguments:

    None

Return Value:

    None.

--*/
{
    DWORD i;
    PUSE_ENTRY UseEntry;
    PUSE_ENTRY PreviousEntry;

    //
    // Lock Use Table
    //
    if (! RtlAcquireResourceExclusive(&Use.TableResource, TRUE)) {
        return;
    }

    //
    // Close handles for every use entry that still exist and free the memory
    // allocated for the use entry.
    //
    for (i = 0; i < Use.TableSize; i++) {

        UseEntry = Use.Table[i].List;

        while (UseEntry != NULL) {

            (void) WsDeleteConnection(
                       &Use.Table[i].LogonId,
                       UseEntry->TreeConnection,
                       USE_NOFORCE
                       );

            WsDeleteSymbolicLink(
                UseEntry->Local,
                UseEntry->TreeConnectStr,
                NULL
                );

            UseEntry->Remote->TotalUseCount -= UseEntry->UseCount;

            if (UseEntry->Remote->TotalUseCount == 0) {
                (void) LocalFree((HLOCAL) UseEntry->Remote);
            }

            PreviousEntry = UseEntry;
            UseEntry = UseEntry->Next;

            (void) LocalFree((HLOCAL) PreviousEntry);
        }
    }

    RtlReleaseResource(&Use.TableResource);

    //
    // Free the array of logged on user entries, and delete the resource
    // created to serialize access to the array.
    //
    WsDestroyUsersObject(&Use);
}


NET_API_STATUS
WsFindUse(
    IN  PLUID LogonId,
    IN  PUSE_ENTRY UseList,
    IN  LPTSTR UseName,
    OUT PHANDLE TreeConnection,
    OUT PUSE_ENTRY *MatchedPointer,
    OUT PUSE_ENTRY *BackPointer OPTIONAL
    )
/*++

Routine Description:

    This function searches the Use Table for the specified tree connection.
    If the connection is found, NERR_Success is returned.

    If the UseName is found in the Use Table (explicit connection), a
    pointer to the matching use entry is returned.  Otherwise, MatchedPointer
    is set to NULL.

    WARNING: This function assumes that the Use.TableResource is claimed.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    UseList - Supplies the use list of the user.

    UseName - Supplies the name of the tree connection, this is either a
        local device name or a UNC name.

    TreeConnection - Returns a handle to the found tree connection.

    MatchedPointer - Returns the pointer to the matching use entry.  This
        pointer is set to NULL if the specified use is an implicit
        connection.

    BackPointer - Returns the pointer to the entry previous to the matching
        use entry if MatchedPointer is not NULL.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    PUSE_ENTRY Back;

    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] WsFindUse: Usename is %ws\n", UseName));
    }

    //
    // Look for use entry depending on whether the local device name or
    // UNC name is specified.
    //
    if (UseName[1] != TCHAR_BACKSLASH) {

        //
        // Local device name is specified.
        //
        WsFindLocal(
            UseList,
            UseName,
            MatchedPointer,
            &Back
            );

        if (*MatchedPointer == NULL) {
            return NERR_UseNotFound;
        }
        else {
            *TreeConnection = (*MatchedPointer)->TreeConnection;
            if (ARGUMENT_PRESENT(BackPointer)) {
                *BackPointer = Back;
            }
            return NERR_Success;
        }

    }
    else {

        //
        // UNC name is specified, need to find matching shared resource
        // in use list.
        //
        WsFindUncName(
            UseList,
            UseName,
            MatchedPointer,
            &Back
            );

        if (*MatchedPointer == NULL) {

            NET_API_STATUS status;

            DWORD EnumConnectionHint = 0;      // Hint size from redirector
            LMR_REQUEST_PACKET Rrp;            // Redirector request packet

            PLMR_CONNECTION_INFO_0 UncList;    // List of information on UNC
                                               //     connections
            PLMR_CONNECTION_INFO_0 SavePtr;

            DWORD i;
            BOOL FoundImplicitEntry = FALSE;
            DWORD UseNameLength = STRLEN(UseName);

            UNICODE_STRING TreeConnectStr;


            IF_DEBUG(USE) {
                NetpKdPrint(("[Wksta] WsFindUse: No explicit entry\n"));
            }

            //
            // Did not find an explicit connection, see if there is an
            // implicit connection by enumerating all implicit connections
            //
            Rrp.Type = GetConnectionInfo;
            Rrp.Version = REQUEST_PACKET_VERSION;
            RtlCopyLuid(&Rrp.LogonId, LogonId);
            Rrp.Level = 0;
            Rrp.Parameters.Get.ResumeHandle = 0;

            if ((status = WsDeviceControlGetInfo(
                              Redirector,
                              WsRedirDeviceHandle,
                              FSCTL_LMR_ENUMERATE_CONNECTIONS,
                              (PVOID) &Rrp,
                              sizeof(LMR_REQUEST_PACKET),
                              (LPBYTE *) &UncList,
                              MAXULONG,
                              EnumConnectionHint,
                              NULL
                              )) != NERR_Success) {
                return status;
            }

            SavePtr = UncList;

            for (i = 0; i < Rrp.Parameters.Get.EntriesRead &&
                        FoundImplicitEntry == FALSE; i++, UncList++) {
                if (WsCompareStringU(
                        UncList->UNCName.Buffer,
                        UncList->UNCName.Length / sizeof(WCHAR),
                        UseName,
                        UseNameLength
                        ) == 0) {
                    FoundImplicitEntry = TRUE;
                }
            }

            MIDL_user_free((PVOID) SavePtr);

            //
            // Fail if no such connection.
            //
            if (! FoundImplicitEntry) {
                IF_DEBUG(USE) {
                    NetpKdPrint(("[Wksta] WsFindUse: No implicit entry\n"));
                }
                return NERR_UseNotFound;
            }

            //
            // Otherwise open the connection and return the handle
            //

            //
            // Replace \\ with \Device\LanmanRedirector\ in UseName
            //
            if ((status = WsCreateTreeConnectName(
                              UseName,
                              STRLEN(UseName),
                              NULL,
                              0,
                              &TreeConnectStr
                              )) != NERR_Success) {
                return status;
            }

            //
            // Redirector will pick up the logon username and password
            // from the LSA if the authentication package is loaded.
            //
            status = WsOpenCreateConnection(
                         &TreeConnectStr,
                         NULL,
                         NULL,
                         NULL,
                         0,              // no special flags
                         FILE_OPEN,
                         USE_WILDCARD,
                         TreeConnection,
                         NULL
                         );

            (void) LocalFree(TreeConnectStr.Buffer);

            return status;
        }
        else {

            IF_DEBUG(USE) {
                NetpKdPrint(("[Wksta] WsFindUse: Found an explicit entry\n"));
            }

            //
            // Found an explicit UNC connection (NULL local device name).
            //
            NetpAssert((*MatchedPointer)->Local == NULL);

            *TreeConnection = (*MatchedPointer)->TreeConnection;

            if (ARGUMENT_PRESENT(BackPointer)) {
                *BackPointer = Back;
            }

            return NERR_Success;
        }
    }
}



VOID
WsFindInsertLocation(
    IN  PUSE_ENTRY UseList,
    IN  LPTSTR UncName,
    OUT PUSE_ENTRY *MatchedPointer,
    OUT PUSE_ENTRY *InsertPointer
    )
/*++

Routine Description:

    This function searches the use list for the location to insert a new use
    entry.  The use entry is inserted to the end of the use list so the
    pointer to the last node in the use list is returned via InsertPointer.
    We also have to save a pointer to the node with the same UNC name so that
    the new use entry can be set to point to the same remote node (where the
    UNC name is stored).  This pointer is returned as MatchedPointer.

    WARNING: This function assumes that the Use.TableResource has been claimed.

Arguments:

    UseList - Supplies the pointer to the use list.

    UncName - Supplies the pointer to the shared resource (UNC name).

    MatchedPointer - Returns a pointer to the node that holds the matching
        UncName.  If no matching UncName is found, this pointer is set to
        NULL.  If there are more than one node that has the same UNC name,
        this pointer will point to the node with the NULL local device name,
        if any; otherwise, if all nodes with matching UNC names have non-null
        local device names, the pointer to the last matching node will be
        returned.

    InsertPointer - Returns a pointer to the last use entry, after which the
        new entry is to be inserted.

Return Value:

    None.

--*/
{
    BOOL IsMatchWithNullDevice = FALSE;


    *MatchedPointer = NULL;

    while (UseList != NULL) {

        //
        // Do the string comparison only if we haven't found a matching UNC
        // name with a NULL local device name.
        //
        if (! IsMatchWithNullDevice &&
            (STRICMP((LPWSTR) UseList->Remote->UncName, UncName) == 0)) {

            //
            // Found matching entry
            //
            *MatchedPointer = UseList;

            IsMatchWithNullDevice = (UseList->Local == NULL);
        }

        *InsertPointer = UseList;
        UseList = UseList->Next;
    }
}



VOID
WsFindUncName(
    IN  PUSE_ENTRY UseList,
    IN  LPTSTR UncName,
    OUT PUSE_ENTRY *MatchedPointer,
    OUT PUSE_ENTRY *BackPointer
    )
/*++

Routine Description:

    This function searches the use list for the use entry with the specified
    UNC name with a NULL local device name.

    WARNING: This function assumes that the Use.TableResource has been claimed.

Arguments:

    UseList - Supplies the pointer to the use list.

    UncName - Supplies the pointer to the shared resource (UNC name).

    MatchedPointer - Returns a pointer to the node that holds the matching
        UncName.  If no matching UncName is found, this pointer is set to
        NULL.

    BackPointer - Returns a pointer to the entry previous to the found entry.
        If UncName is not found, this pointer is set to NULL.

Return Value:

    None.

--*/
{
    *BackPointer = UseList;

    while (UseList != NULL) {

        if ((UseList->Local == NULL) &&
            (STRICMP((LPWSTR) UseList->Remote->UncName, UncName) == 0)) {

            //
            // Found matching entry
            //
            *MatchedPointer = UseList;
            return;
        }
        else {
            *BackPointer = UseList;
            UseList = UseList->Next;
        }
    }

    //
    // Did not find matching UNC name with a NULL local device name in the
    // entire list.
    //
    *MatchedPointer = NULL;
    *BackPointer = NULL;
}


STATIC
VOID
WsFindLocal(
    IN  PUSE_ENTRY UseList,
    IN  LPTSTR Local,
    OUT PUSE_ENTRY *MatchedPointer,
    OUT PUSE_ENTRY *BackPointer
    )
/*++

Routine Description:

    This function searches the use list for the specified local device name.

    WARNING: This function assumes that the Use.TableResource has been claimed.

Arguments:

    UseList - Supplies the pointer to the use list.

    Local - Supplies the local device name.

    MatchedPointer - Returns a pointer to the use entry that holds the matching
        local device name.  If no matching local device name is found, this
        pointer is set to NULL.

    BackPointer - Returns a pointer to the entry previous to the found entry.
        If the local device name is not found, this pointer is set to NULL.

Return Value:

    None.

--*/
{
    *BackPointer = UseList;

    while (UseList != NULL) {

        if ((UseList->Local != NULL) &&
            (STRICMP(UseList->Local, Local) == 0)) {

            //
            // Found matching entry
            //
            *MatchedPointer = UseList;
            return;
        }
        else {
            *BackPointer = UseList;
            UseList = UseList->Next;
        }
    }

    //
    // Did not find matching local device name in the entire list.
    //
    *MatchedPointer = NULL;
    *BackPointer = NULL;
}


NET_API_STATUS
WsCreateTreeConnectName(
    IN  LPTSTR UncName,
    IN  DWORD UncNameLength,
    IN  LPTSTR LocalName OPTIONAL,
    IN  DWORD  SessionId,
    OUT PUNICODE_STRING TreeConnectStr
    )
/*++

Routine Description:

    This function replaces \\ with \Device\LanmanRedirector\DEVICE: in the
    UncName to form the NT-style tree connection name.  A buffer is allocated
    by this function and returned as the output string.

Arguments:

    UncName - Supplies the UNC name of the shared resource.

    UncNameLength - Supplies the length of the UNC name.

    LocalName - Supplies the local device name for the redirection.

    SessionId - Id that uniquely identifies a Hydra session. This value is always
                0 for non-hydra NT and console hydra session

    TreeConnectStr - Returns a string with a newly allocated buffer that
        contains the NT-style tree connection name.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    BOOLEAN IsDeviceName = FALSE;
    WCHAR IdBuffer[16]; // Value from RtlIntegerToUnicodeString
    UNICODE_STRING IdString;

    LUID LogonId;
    WCHAR LUIDBuffer[32]; // Value from _snwprintf
    UNICODE_STRING LUIDString;
    NET_API_STATUS status;


    IdString.Length = 0;
    IdString.MaximumLength = sizeof(IdBuffer);
    IdString.Buffer = IdBuffer;
    RtlIntegerToUnicodeString( SessionId, 10, &IdString );

    if (WsLUIDDeviceMapsEnabled == TRUE) {
        //
        // Get LogonID of the user
        //
        if ((status = WsImpersonateAndGetLogonId(&LogonId)) != NERR_Success) {
            return status;
        }

        _snwprintf( LUIDBuffer,
                    sizeof(LUIDBuffer)/sizeof(WCHAR),
                    L"%08x%08x",
                    LogonId.HighPart,
                    LogonId.LowPart );

        RtlInitUnicodeString( &LUIDString, LUIDBuffer );

    }

    if (ARGUMENT_PRESENT(LocalName)) {
        IsDeviceName = ((STRNICMP(LocalName, TEXT("LPT"), 3) == 0) ||
                    (STRNICMP(LocalName, TEXT("COM"), 3) == 0));
    }


    //
    // Initialize tree connect string maximum length to hold
    //            \Device\LanmanRedirector\DEVICE:\SERVER\SHARE
    //
    // The new redirector requires an additional character for name
    // canonicalization.

    if (!LoadedMRxSmbInsteadOfRdr) {
       // The old redirector
       TreeConnectStr->MaximumLength = (USHORT)(RedirectorDeviceName.Length +
           (USHORT) (UncNameLength * sizeof(WCHAR)) +
           (ARGUMENT_PRESENT(LocalName) ? (STRLEN(LocalName)*sizeof(WCHAR)) : 0) +
           sizeof(WCHAR) +                         // For "\"
           (IsDeviceName ? sizeof(WCHAR) : 0));
    } else {
       // The new redirector
       TreeConnectStr->MaximumLength = (USHORT)(RedirectorDeviceName.Length +
           (USHORT) (UncNameLength * sizeof(WCHAR)) +
           (ARGUMENT_PRESENT(LocalName) ? ((STRLEN(LocalName)+1)*sizeof(WCHAR)) //+1 for ';'
                                        : 0) +
           sizeof(WCHAR) +                         // For "\"
           ((WsLUIDDeviceMapsEnabled == TRUE) ?
               (LUIDString.Length * sizeof(WCHAR)) :
               (IdString.Length * sizeof(WCHAR))) +
           (IsDeviceName ? sizeof(WCHAR) : 0));
    }

    if ((TreeConnectStr->Buffer = (PWSTR) LocalAlloc(
                                              LMEM_ZEROINIT,
                                              (UINT) TreeConnectStr->MaximumLength
                                              )) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy \Device\LanmanRedirector
    //
    RtlCopyUnicodeString(TreeConnectStr, &RedirectorDeviceName);

    //
    // Concatenate \DEVICE:
    //
    if (ARGUMENT_PRESENT(LocalName)) {
        wcscat(TreeConnectStr->Buffer, L"\\");

        TreeConnectStr->Length += sizeof(WCHAR);

        // Concatenate the ; required by the new redirector for canonicalization
        if (LoadedMRxSmbInsteadOfRdr) {

            wcscat(TreeConnectStr->Buffer, L";");

            TreeConnectStr->Length += sizeof(WCHAR);

        }

        wcscat(TreeConnectStr->Buffer, LocalName);

        TreeConnectStr->Length += (USHORT)(STRLEN(LocalName)*sizeof(WCHAR));

        if (IsDeviceName) {
            wcscat(TreeConnectStr->Buffer, L":");

            TreeConnectStr->Length += sizeof(WCHAR);

        }

        if (LoadedMRxSmbInsteadOfRdr) {

            if (WsLUIDDeviceMapsEnabled == TRUE) {
                // Add the Logon Id
                RtlAppendUnicodeStringToString( TreeConnectStr, &LUIDString );
            }
            else {
                // Add the session id
                RtlAppendUnicodeStringToString( TreeConnectStr, &IdString );
            }
        }
    }

    //
    // Concatenate \SERVER\SHARE
    //
    wcscat(TreeConnectStr->Buffer, &UncName[1]);

    TreeConnectStr->Length += (USHORT)((UncNameLength - 1) * sizeof(WCHAR));

    return NERR_Success;
}


NET_API_STATUS
WsOpenCreateConnection(
    IN  PUNICODE_STRING TreeConnectionName,
    IN  LPTSTR UserName OPTIONAL,
    IN  LPTSTR DomainName OPTIONAL,
    IN  LPTSTR Password OPTIONAL,
    IN  ULONG CreateFlags,
    IN  ULONG CreateDisposition,
    IN  ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

    This function asks the redirector to either open an existing tree
    connection (CreateDisposition == FILE_OPEN), or create a new tree
    connection if one does not exist (CreateDisposition == FILE_OPEN_IF).

    The password and user name passed to the redirector via the EA buffer
    in the NtCreateFile call.  The EA buffer is NULL if neither password
    or user name is specified.

    The redirector expects the EA descriptor string to be in Unicode
    but the password and username strings to be in ANSI.

Arguments:

    TreeConnectionName - Supplies the name of the tree connection in NT-style
        file name format: \Device\LanmanRedirector\SERVER\SHARE

    UserName - Supplies the user name to create the tree connection with.

    DomainName - Supplies the name of the domain to get user credentials from.

    Password - Supplies the password to create the tree connection with.

    CreateDisposition - Supplies the create disposition value to either
        open or create the tree connection.

    ConnectionType - Supplies the type of the connection (USE_xxx)

    TreeConnectionHandle - Returns the handle to the tree connection
        created/opened by the redirector.

    Information - Returns the information field of the I/O status block.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;

    OBJECT_ATTRIBUTES UncNameAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION Ea;
    ULONG EaBufferSize = 0;

    UCHAR EaNamePasswordSize = (UCHAR) (ROUND_UP_COUNT(
                                            strlen(EA_NAME_PASSWORD) + sizeof(CHAR),
                                            ALIGN_WCHAR
                                            ) - sizeof(CHAR));
    UCHAR EaNameUserNameSize = (UCHAR) (ROUND_UP_COUNT(
                                            strlen(EA_NAME_USERNAME) + sizeof(CHAR),
                                            ALIGN_WCHAR
                                            ) - sizeof(CHAR));

    UCHAR EaNameDomainNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_DOMAIN) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNameTypeSize = (UCHAR) (ROUND_UP_COUNT(
                                        strlen(EA_NAME_TYPE) + sizeof(CHAR),
                                        ALIGN_DWORD
                                        ) - sizeof(CHAR));

    UCHAR EaNameConnectSize = (UCHAR) (ROUND_UP_COUNT(
                                        strlen(EA_NAME_CONNECT) + sizeof(CHAR),
                                        ALIGN_DWORD
                                        ) - sizeof(CHAR));

    UCHAR EaNameCSCAgentSize = (UCHAR) (ROUND_UP_COUNT(
                                        strlen(EA_NAME_CSCAGENT) + sizeof(CHAR),
                                        ALIGN_DWORD
                                        ) - sizeof(CHAR));


    USHORT PasswordSize = 0;
    USHORT UserNameSize = 0;
    USHORT DomainNameSize = 0;
    USHORT TypeSize = sizeof(ULONG);



    InitializeObjectAttributes(
        &UncNameAttributes,
        TreeConnectionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Calculate the number of bytes needed for the EA buffer to put the
    // password or user name.
    //
    if (ARGUMENT_PRESENT(Password)) {

        PasswordSize = (USHORT) (wcslen(Password) * sizeof(WCHAR));

        EaBufferSize = ROUND_UP_COUNT(
                           FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                           EaNamePasswordSize + sizeof(CHAR) +
                           PasswordSize,
                           ALIGN_DWORD
                           );
    }

    if (ARGUMENT_PRESENT(UserName)) {

        UserNameSize = (USHORT) (wcslen(UserName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameUserNameSize + sizeof(CHAR) +
                            UserNameSize,
                            ALIGN_DWORD
                            );
    }

    if (ARGUMENT_PRESENT(DomainName)) {

        DomainNameSize = (USHORT) (wcslen(DomainName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameDomainNameSize + sizeof(CHAR) +
                            DomainNameSize,
                            ALIGN_DWORD
                            );
    }

    if(CreateFlags & CREATE_NO_CONNECT)
    {
        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameConnectSize + sizeof(CHAR),
                            ALIGN_DWORD
                            );
    }

    if(CreateFlags & CREATE_BYPASS_CSC)
    {
        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameCSCAgentSize + sizeof(CHAR),
                            ALIGN_DWORD
                            );
    }


    EaBufferSize += FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                    EaNameTypeSize + sizeof(CHAR) +
                    TypeSize;


    //
    // Allocate the EA buffer
    //
    if ((EaBuffer = (PFILE_FULL_EA_INFORMATION) LocalAlloc(
                                                    LMEM_ZEROINIT,
                                                    (UINT) EaBufferSize
                                                    )) == NULL) {
        status = GetLastError();
        goto FreeMemory;
    }

    Ea = EaBuffer;

    if(CreateFlags & CREATE_NO_CONNECT)
    {
        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_CONNECT);
        Ea->EaNameLength = EaNameConnectSize;

        Ea->EaValueLength = 0;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameConnectSize + sizeof(CHAR) +
                                  0,
                                  ALIGN_DWORD
                                  );

        IF_DEBUG(USE) {
            NetpKdPrint(("[Wksta] OpenCreate: After round, NextEntryOffset=%lu\n",
                         Ea->NextEntryOffset));
        }

        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    if( CreateFlags & CREATE_BYPASS_CSC ) {
        strcpy((LPSTR)Ea->EaName, EA_NAME_CSCAGENT);
        Ea->EaNameLength = EaNameCSCAgentSize;
        Ea->EaValueLength = 0;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameCSCAgentSize + sizeof(CHAR) +
                                  0,
                                  ALIGN_DWORD
                                  );

        IF_DEBUG(USE) {
            NetpKdPrint(("[Wksta] OpenCreate: After round, NextEntryOffset=%lu\n",
                         Ea->NextEntryOffset));
        }

        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    if (ARGUMENT_PRESENT(Password)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_PASSWORD);
        Ea->EaNameLength = EaNamePasswordSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy(
            (LPWSTR) &(Ea->EaName[EaNamePasswordSize + sizeof(CHAR)]),
            Password
            );

        Ea->EaValueLength = PasswordSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNamePasswordSize + sizeof(CHAR) +
                                  PasswordSize,
                                  ALIGN_DWORD
                                  );

        IF_DEBUG(USE) {
            NetpKdPrint(("[Wksta] OpenCreate: After round, NextEntryOffset=%lu\n",
                         Ea->NextEntryOffset));
        }

        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    if (ARGUMENT_PRESENT(UserName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_USERNAME);
        Ea->EaNameLength = EaNameUserNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy(
            (LPWSTR) &(Ea->EaName[EaNameUserNameSize + sizeof(CHAR)]),
            UserName
            );

        Ea->EaValueLength = UserNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameUserNameSize + sizeof(CHAR) +
                                  UserNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    if (ARGUMENT_PRESENT(DomainName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_DOMAIN);
        Ea->EaNameLength = EaNameDomainNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy(
            (LPWSTR) &(Ea->EaName[EaNameDomainNameSize + sizeof(CHAR)]),
            DomainName
            );

        Ea->EaValueLength = DomainNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameDomainNameSize + sizeof(CHAR) +
                                  DomainNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    //
    // Copy the EA for the connection type name into EA buffer.  EA name length
    // does not include the zero terminator.
    //
    strcpy((LPSTR) Ea->EaName, EA_NAME_TYPE);
    Ea->EaNameLength = EaNameTypeSize;

    *((PULONG) &(Ea->EaName[EaNameTypeSize + sizeof(CHAR)])) = ConnectionType;

    Ea->EaValueLength = TypeSize;

    Ea->NextEntryOffset = 0;
    Ea->Flags = 0;

    if ((status = WsImpersonateClient()) != NERR_Success) {
        goto FreeMemory;
    }

    //
    // Create or open a tree connection
    //
    ntstatus = NtCreateFile(
                   TreeConnectionHandle,
                   SYNCHRONIZE,
                   &UncNameAttributes,
                   &IoStatusBlock,
                   NULL,
                   FILE_ATTRIBUTE_NORMAL,
                   FILE_SHARE_READ | FILE_SHARE_WRITE |
                       FILE_SHARE_DELETE,
                   CreateDisposition,
                   FILE_CREATE_TREE_CONNECTION
                       | FILE_SYNCHRONOUS_IO_NONALERT,
                   (PVOID) EaBuffer,
                   EaBufferSize
                   );

    WsRevertToSelf();

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = IoStatusBlock.Information;
    }

    IF_DEBUG(USE) {
        NetpKdPrint(("[Wksta] NtCreateFile returns %lx\n", ntstatus));
    }

    status = WsMapStatus(ntstatus);

FreeMemory:
    if (EaBuffer != NULL) {
        // Prevent password from making it to pagefile.
        RtlZeroMemory( EaBuffer, EaBufferSize );
        (void) LocalFree((HLOCAL) EaBuffer);
    }

    return status;
}


NET_API_STATUS
WsDeleteConnection(
    IN  PLUID LogonId,
    IN  HANDLE TreeConnection,
    IN  DWORD ForceLevel
    )
/*++

Routine Description:

    This function asks the redirector to delete the tree connection
    associated with the tree connection handle, and closes the handle.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    TreeConnection - Supplies the handle to the tree connection created.

    ForceLevel - Supplies the level of force to delete the tree connection.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    LMR_REQUEST_PACKET Rrp;            // Redirector request packet


    //
    // Map force level to values the redirector understand
    //
    switch (ForceLevel) {

        case USE_NOFORCE:
        case USE_LOTS_OF_FORCE:
            Rrp.Level = ForceLevel;
            break;

        case USE_FORCE:
            Rrp.Level = USE_NOFORCE;
            break;

        default:
            NetpKdPrint(("[Wksta] Invalid force level %lu should never happen!\n",
                         ForceLevel));
            NetpAssert(FALSE);
    }

    //
    // Tell the redirector to delete the tree connection
    //
    Rrp.Version = REQUEST_PACKET_VERSION;
    RtlCopyLuid(&Rrp.LogonId, LogonId);

    status = WsRedirFsControl(
                 TreeConnection,
                 FSCTL_LMR_DELETE_CONNECTION,
                 &Rrp,
                 sizeof(LMR_REQUEST_PACKET),
                 NULL,
                 0,
                 NULL
                 );

    //
    // Close the connection handle
    //

    if(status == NERR_Success)
    {
        (void) NtClose(TreeConnection);
    }

    return status;
}


BOOL
WsRedirectionPaused(
    IN LPTSTR LocalDeviceName
    )
/*++

Routine Description:

    This function checks to see if the redirection for the print and comm
    devices are paused for the system.  Since we are only checking a global
    flag, there's no reason to protect it with a RESOURCE.

Arguments:

    LocalDeviceName - Supplies the name of the local device.

Return Value:

    Returns TRUE redirection is paused; FALSE otherwise

--*/
{

    if ((STRNICMP(LocalDeviceName, TEXT("LPT"), 3) == 0) ||
        (STRNICMP(LocalDeviceName, TEXT("COM"), 3) == 0)) {

        //
        // Redirection of print and comm devices are paused if
        // workstation service is paused.
        //
        return (WsGlobalData.Status.dwCurrentState == SERVICE_PAUSED);

    } else {

        //
        // Redirection of disk devices cannot be paused.
        //
        return FALSE;
    }
}


VOID
WsPauseOrContinueRedirection(
    IN  REDIR_OPERATION OperationType
    )
/*++

Routine Description:

    This function pauses or unpauses (based on OperationType) the redirection
    of print or comm devices.

Arguments:

    OperationType - Supplies a value that causes redirection to be paused or
        continued.

Return Value:

    None.

--*/
{
    DWORD Index;                       // Index to user entry in Use Table
    PUSE_ENTRY UseEntry;


    //
    // Lock Use Table
    //
    if (! RtlAcquireResourceExclusive(&Use.TableResource, TRUE)) {
        return;
    }

    //
    // If we want to pause and we are already paused, or if we want to
    // continue and we have not paused, just return.
    //
    if ((OperationType == PauseRedirection &&
         WsGlobalData.Status.dwCurrentState == SERVICE_PAUSED) ||
        (OperationType == ContinueRedirection &&
         WsGlobalData.Status.dwCurrentState == SERVICE_RUNNING)) {

        RtlReleaseResource(&Use.TableResource);
        return;
    }

    //
    // Pause or continue for all users
    //
    for (Index = 0; Index < Use.TableSize; Index++) {
        UseEntry = Use.Table[Index].List;

        while (UseEntry != NULL) {

            if ((UseEntry->Local != NULL) &&
                ((STRNICMP(TEXT("LPT"), UseEntry->Local, 3) == 0) ||
                 (STRNICMP(TEXT("COM"), UseEntry->Local, 3) == 0))) {

                if (OperationType == PauseRedirection) {

                    //
                    // Pause the redirection
                    //

                    //
                    // Delete the symbolic link
                    //
                    WsDeleteSymbolicLink(
                        UseEntry->Local,
                        UseEntry->TreeConnectStr,
                        NULL
                        );

                }
                else {
                    LPWSTR Session = NULL;

                    //
                    // Continue the redirection
                    //

                    if (WsCreateSymbolicLink(
                            UseEntry->Local,
                            USE_SPOOLDEV,      // USE_CHARDEV is just as good
                            UseEntry->TreeConnectStr,
                            NULL,
                            &Session
                            ) != NERR_Success) {

                        PUSE_ENTRY RestoredEntry = Use.Table[Index].List;


                        //
                        // Could not continue completely.  Delete all
                        // symbolic links restored so far
                        //
                        while (RestoredEntry != UseEntry) {

                            if ((UseEntry->Local != NULL) &&
                                ((STRNICMP(TEXT("LPT"), UseEntry->Local, 3) == 0) ||
                                 (STRNICMP(TEXT("COM"), UseEntry->Local, 3) == 0))) {

                                WsDeleteSymbolicLink(
                                    RestoredEntry->Local,
                                    RestoredEntry->TreeConnectStr,
                                    Session
                                    );
                            }

                            RestoredEntry = RestoredEntry->Next;
                        }

                        RtlReleaseResource(&Use.TableResource);
                        LocalFree(Session);
                        return;
                    }

                    LocalFree(Session);
                }

            }

            UseEntry = UseEntry->Next;
        }

    }  // for all users

    if (OperationType == PauseRedirection) {
        WsGlobalData.Status.dwCurrentState = SERVICE_PAUSED;
    }
    else {
        WsGlobalData.Status.dwCurrentState = SERVICE_RUNNING;
    }

    //
    // Use the same resource to protect access to the RedirectionPaused flag
    // in WsGlobalData
    //
    RtlReleaseResource(&Use.TableResource);
}



NET_API_STATUS
WsCreateSymbolicLink(
    IN  LPWSTR Local,
    IN  DWORD DeviceType,
    IN  LPWSTR TreeConnectStr,
    IN  PUSE_ENTRY UseList,
    IN OUT LPWSTR *Session
    )
/*++

Routine Description:

    This function creates a symbolic link object for the specified local
    device name which is linked to the tree connection name that has a
    format of \Device\LanmanRedirector\Device:\Server\Share.

    NOTE: when LUID Device maps are enabled,
    Must perform the creation outside of exclusively holding the
    Use.TableResource.
    Otherwise, when the shell tries to update the current status of
    a drive letter change, the explorer.exe thread will block while
    trying to acquire the Use.TableResource

Arguments:

    Local - Supplies the local device name.

    DeviceType - Supplies the shared resource device type.

    TreeConnectStr - Supplies the tree connection name string which is
        the link target of the symbolick link object.

    UseList - Supplies the pointer to the use list.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;
    WCHAR TempBuf[64];
    DWORD dddFlags;

    //
    // Multiple session support
    //
    *Session = WsReturnSessionPath(Local);

    if( *Session == NULL ) {
        return( GetLastError() );
    }

    if (WsLUIDDeviceMapsEnabled == TRUE) {
        if ((status = WsImpersonateClient()) != NERR_Success) {
            return status;
        }
    }

    //
    // To redirect a comm or print device, we need to see if we have
    // redirected it once before by searching through all existing
    // redirections.
    //
    if ((DeviceType == USE_CHARDEV) || (DeviceType == USE_SPOOLDEV)) {

        PUSE_ENTRY MatchedPointer;
        PUSE_ENTRY BackPointer;


        WsFindLocal(
            UseList,
            Local,
            &MatchedPointer,
            &BackPointer
            );

        if (MatchedPointer != NULL) {
            //
            // Already redirected
            //
            return ERROR_ALREADY_ASSIGNED;
        }
    }
    else {

        if (! QueryDosDeviceW(
                  *Session,
                  TempBuf,
                  64
                  )) {

            if (GetLastError() != ERROR_FILE_NOT_FOUND) {

                //
                // Most likely failure occurred because our output
                // buffer is too small.  It still means someone already
                // has an existing symbolic link for this device.
                //

                return ERROR_ALREADY_ASSIGNED;
            }

            //
            // ERROR_FILE_NOT_FOUND (translated from OBJECT_NAME_NOT_FOUND)
            // means it does not exist and we can redirect this device.
            //
        }
        else {

            //
            // QueryDosDevice successfully an existing symbolic link--
            // somebody is already using this device.
            //
            return ERROR_ALREADY_ASSIGNED;
        }
    }

    //
    // Create a symbolic link object to the device we are redirecting
    //
    dddFlags = DDD_RAW_TARGET_PATH | DDD_NO_BROADCAST_SYSTEM;

    if (!DefineDosDeviceW(
                  dddFlags,
                  *Session,
                  TreeConnectStr
                  )) {

        DWORD dwError = GetLastError();
        if (WsLUIDDeviceMapsEnabled == TRUE) {
            WsRevertToSelf();
        }
        return dwError;
    }
    else {
        if (WsLUIDDeviceMapsEnabled == TRUE) {
            WsRevertToSelf();
        }
        return NERR_Success;
    }
}



VOID
WsDeleteSymbolicLink(
    IN  LPWSTR LocalDeviceName,
    IN  LPWSTR TreeConnectStr,
    IN  LPWSTR SessionDeviceName
    )
/*++

Routine Description:

    This function deletes the symbolic link we had created earlier for
    the device.

    NOTE: when LUID Device maps are enabled,
    Must perform the deletion outside of exclusively holding the
    Use.TableResource.
    Otherwise, when the shell tries to update the current status of
    a drive letter change, the explorer.exe thread will block while
    trying to acquire the Use.TableResource

Arguments:

    LocalDeviceName - Supplies the local device name string of which the
        symbolic link object is created.

    TreeConnectStr - Supplies a pointer to the Unicode string which
        contains the link target string we want to match and delete.

Return Value:

    None.

--*/
{
    BOOLEAN DeleteSession = FALSE;
    DWORD dddFlags;

    if (LocalDeviceName != NULL ||
        SessionDeviceName != NULL) {

        if (SessionDeviceName == NULL) {
            SessionDeviceName = WsReturnSessionPath(LocalDeviceName);
            if( SessionDeviceName == NULL ) return;
            DeleteSession = TRUE;
        }

        dddFlags = DDD_REMOVE_DEFINITION  |
                     DDD_RAW_TARGET_PATH |
                     DDD_EXACT_MATCH_ON_REMOVE |
                     DDD_NO_BROADCAST_SYSTEM;

        if (WsLUIDDeviceMapsEnabled == TRUE) {
            if (WsImpersonateClient() != NERR_Success) {
                return;
            }
        }

        if (! DefineDosDeviceW(
                  dddFlags,
                  SessionDeviceName,
                  TreeConnectStr
                  )) {

#if DBG
            NetpKdPrint(("DefineDosDevice DEL of %ws %ws returned %ld\n",
                        LocalDeviceName, TreeConnectStr, GetLastError()));
#endif

        }

        if (WsLUIDDeviceMapsEnabled == TRUE) {
            WsRevertToSelf();
        }
    }

    if( SessionDeviceName && DeleteSession) {
        LocalFree( SessionDeviceName );
    }
}



NET_API_STATUS
WsUseCheckRemote(
    IN  LPTSTR RemoteResource,
    OUT LPTSTR UncName,
    OUT LPDWORD UncNameLength
    )
/*++

Routine Description:

    This function checks the validity of the remote resource name
    specified to NetUseAdd.

Arguments:

    RemoteResource - Supplies the remote resource name specified by the API
        caller.

    UncName - Returns the canonicalized remote resource name.

    UncNameLength - Returns the length of the canonicalized name.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD PathType = 0;
    LPTSTR Ptr;


    if ((status = I_NetPathType(
                      NULL,
                      RemoteResource,
                      &PathType,
                      0)) == NERR_Success) {

        //
        // Check for UNC type
        //
        if (PathType != ITYPE_UNC) {
            IF_DEBUG(USE) {
                NetpKdPrint(("[Wksta] WsUseCheckRemote not UNC type\n"));
            }
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Canonicalize the name
        //
        status = I_NetPathCanonicalize(
                     NULL,
                     RemoteResource,
                     UncName,
                     (MAX_PATH) * sizeof(TCHAR),
                     NULL,
                     &PathType,
                     0
                     );

        if (status != NERR_Success) {
            IF_DEBUG(USE) {
               NetpKdPrint((
                   "[Wksta] WsUseCheckRemote: I_NetPathCanonicalize return %lu\n",
                    status
                    ));
            }
            return status;
        }

        IF_DEBUG(USE) {
            NetpKdPrint(("[Wksta] WsUseCheckRemote: %ws\n", UncName));
        }
    }
    else {
        NetpKdPrint(("[Wksta] WsUseCheckRemote: I_NetPathType return %lu\n",
            status));
        return status;
    }

    //
    // Detect illegal remote name in the form of \\XXX\YYY\zzz.  We assume
    // that the UNC name begins with exactly two leading backslashes.
    //
    if ((Ptr = STRCHR(UncName + 2, TCHAR_BACKSLASH)) == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!LoadedMRxSmbInsteadOfRdr && STRCHR(Ptr + 1, TCHAR_BACKSLASH) != NULL) {
        //
        // There should not be anymore backslashes
        //
        return ERROR_INVALID_PARAMETER;
    }

    *UncNameLength = STRLEN(UncName);
    return NERR_Success;
}


NET_API_STATUS
WsUseCheckLocal(
    IN  LPTSTR LocalDevice,
    OUT LPTSTR Local,
    OUT LPDWORD LocalLength
    )
/*++

Routine Description:

    This function checks the validity of the local device name
    specified to NetUseAdd.

Arguments:

    LocalDevice - Supplies the local device name specified by the API
        caller.

    Local - Returns the canonicalized local device name.

    LocalLength - Returns the length of the canonicalized name.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD PathType = 0;


    if ((status = I_NetPathType(
                      NULL,
                      LocalDevice,
                      &PathType,
                      0)) == NERR_Success) {

        //
        // Check for DEVICE type
        //
        if ((PathType != (ITYPE_DEVICE | ITYPE_DISK)) &&
            (PathType != (ITYPE_DEVICE | ITYPE_LPT)) &&
            (PathType != (ITYPE_DEVICE | ITYPE_COM))) {
            IF_DEBUG(USE) {
                NetpKdPrint(("[Wksta] WsUseCheckLocal not DISK, LPT, or COM type\n"));
            }
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Canonicalize the name
        //
        status = I_NetPathCanonicalize(
                     NULL,
                     LocalDevice,
                     Local,
                     (DEVLEN + 1) * sizeof(TCHAR),
                     NULL,
                     &PathType,
                     0
                     );

        if (status != NERR_Success) {
            IF_DEBUG(USE) {
               NetpKdPrint((
                   "[Wksta] WsUseCheckLocal: I_NetPathCanonicalize return %lu\n",
                    status
                    ));
            }
            return status;
        }

        IF_DEBUG(USE) {
            NetpKdPrint(("[Wksta] WsUseCheckLocal: %ws\n", Local));
        }

    }
    else {
        NetpKdPrint(("[Wksta] WsUseCheckLocal: I_NetPathType return %lu\n",
            status));
        return status;
    }

    *LocalLength = STRLEN(Local);
    return NERR_Success;
}



LPTSTR
WsReturnSessionPath(
    IN  LPTSTR LocalDeviceName
    )
/*++

Routine Description:

    This function returns the per session path to access the
    specific dos device for multiple session support.


Arguments:

    LocalDeviceName - Supplies the local device name specified by the API
        caller.

Return Value:

    LPTSTR - Pointer to per session path in newly allocated memory
             by LocalAlloc().

--*/
{
    BOOL  rc;
    DWORD SessionId;
    CLIENT_ID ClientId;
    LPTSTR SessionDeviceName;
    NET_API_STATUS status;

    if ((status = WsImpersonateAndGetSessionId(&SessionId)) != NERR_Success) {
         return NULL;
    }

    rc = DosPathToSessionPath(
             SessionId,
             LocalDeviceName,
             &SessionDeviceName
             );

    if( !rc ) {
        return NULL;
    }

    return SessionDeviceName;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\wksta.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    wksta.c

Abstract:

    This module contains the worker routines for the NetWksta APIs
    implemented in the Workstation service.

Author:

    Rita Wong (ritaw) 20-Feb-1991

Revision History:

    14-May-1992 JohnRo
        Implemented "sticky set info" and registry watch.
        Corrected an info level: 1015 should be 1013.
--*/

#include "wsutil.h"
#include "wsdevice.h"
#include "wssec.h"
#include "wslsa.h"
#include "wsconfig.h"
#include "wswksta.h"
#include <config.h>
#include <confname.h>
#include <prefix.h>
#include "wsregcfg.h"   // Registry helpers

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
WsValidateAndSetWksta(
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ErrorParameter OPTIONAL,
    OUT LPDWORD Parmnum
    );

STATIC
NET_API_STATUS
WsGetSystemInfo(
    IN  DWORD   Level,
    OUT LPBYTE  *BufferPointer
    );

STATIC
NET_API_STATUS
WsGetPlatformInfo(
    IN  DWORD   Level,
    OUT LPBYTE  *BufferPointer
    );

STATIC
NET_API_STATUS
WsFillSystemBufferInfo(
    IN  DWORD Level,
    IN  DWORD NumberOfLoggedOnUsers,
    OUT LPBYTE *OutputBuffer
    );

STATIC
VOID
WsUpdateRegistryToMatchWksta(
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ErrorParameter OPTIONAL
    );



NET_API_STATUS NET_API_FUNCTION
NetrWkstaGetInfo(
    IN  LPTSTR ServerName OPTIONAL,
    IN  DWORD Level,
    OUT LPWKSTA_INFO WkstaInfo
    )
/*++

Routine Description:

    This function is the NetWkstaGetInfo entry point in the Workstation
    service.  It checks the security access of the caller before returning
    one the information requested which is either system-wide, or redirector
    specific.

Arguments:

    ServerName - Supplies the name of server to execute this function

    Level - Supplies the requested level of information.

    WkstaInfo - Returns a pointer to a buffer which contains the requested
        workstation information.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;
    LPBYTE Buffer;

    ACCESS_MASK DesiredAccess;


    UNREFERENCED_PARAMETER(ServerName);

    //
    // Determine the desired access based on the specified info level.
    //
    switch (Level) {

        //
        // Guest access
        //
        case 100:
            DesiredAccess = WKSTA_CONFIG_GUEST_INFO_GET;
            break;

        //
        // User access
        //
        case 101:
            DesiredAccess = WKSTA_CONFIG_USER_INFO_GET;
            break;

        //
        // Admin or operator access
        //
        case 102:
        case 502:
            DesiredAccess = WKSTA_CONFIG_ADMIN_INFO_GET;
            break;

        default:
            return ERROR_INVALID_LEVEL;
    }

    //
    // Perform access validation on the caller.
    //
    if (NetpAccessCheckAndAudit(
            WORKSTATION_DISPLAY_NAME,        // Subsystem name
            (LPTSTR) CONFIG_INFO_OBJECT,     // Object type name
            ConfigurationInfoSd,             // Security descriptor
            DesiredAccess,                   // Desired access
            &WsConfigInfoMapping             // Generic mapping
            ) != NERR_Success) {

        return ERROR_ACCESS_DENIED;
    }

    //
    // Only allowed to proceed with get info if no one else is setting
    //
    if (! RtlAcquireResourceShared(&WsInfo.ConfigResource, TRUE)) {
        return NERR_InternalError;
    }

    try {
    switch (Level) {

        //
        // System-wide information
        //
        case 100:
        case 101:
        case 102:
            status = WsGetSystemInfo(Level, &Buffer);
            if (status == NERR_Success) {
                SET_SYSTEM_INFO_POINTER(WkstaInfo, Buffer);
            }
            break;

        //
        // Platform specific information
        //
        case 502:
            status = WsGetPlatformInfo(
                         Level,
                         (LPBYTE *) &(WkstaInfo->WkstaInfo502)
                         );
            break;

        //
        // This should have been caught earlier.
        //
        default:
            NetpAssert(FALSE);
            status = ERROR_INVALID_LEVEL;
    }
    } except(EXCEPTION_EXECUTE_HANDLER) {
          RtlReleaseResource(&WsInfo.ConfigResource);
          return RtlNtStatusToDosError(GetExceptionCode());
    }

    RtlReleaseResource(&WsInfo.ConfigResource);
    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetrWkstaSetInfo(
    IN  LPTSTR ServerName OPTIONAL,
    IN  DWORD Level,
    IN  LPWKSTA_INFO WkstaInfo,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function is the NetWkstaSetInfo entry point in the Workstation
    service.  It checks the security access of the caller to make sure
    that the caller is allowed to set specific workstation information.

Arguments:

    ServerName - Supplies the name of server to execute this function

    Level - Supplies the level of information.

    WkstaInfo - Supplies a pointer to union structure of pointers to
        buffer of fields to set.  The level denotes the fields supplied in
        this buffer.

    ErrorParameter - Returns the identifier to the invalid parameter if
        this function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    WKSTA_INFO_502 OriginalWksta = WSBUF;
    NET_API_STATUS status = NERR_Success;
    DWORD Parmnum;

    UNREFERENCED_PARAMETER(ServerName);

    //
    // Check for NULL input buffer
    //
    if (WkstaInfo->WkstaInfo502 == NULL) {
        RETURN_INVALID_PARAMETER(ErrorParameter, PARM_ERROR_UNKNOWN);
    }

    //
    // Only admins can set redirector configurable fields.  Validate access.
    //
    if (NetpAccessCheckAndAudit(
            WORKSTATION_DISPLAY_NAME,        // Subsystem name
            (LPTSTR) CONFIG_INFO_OBJECT,     // Object type name
            ConfigurationInfoSd,             // Security descriptor
            WKSTA_CONFIG_INFO_SET,           // Desired access
            &WsConfigInfoMapping             // Generic mapping
            ) != NERR_Success) {

        return ERROR_ACCESS_DENIED;
    }

    //
    // Serialize write access
    //
    if (! RtlAcquireResourceExclusive(&WsInfo.ConfigResource, TRUE)) {
        return NERR_InternalError;
    }

    status = WsValidateAndSetWksta(
                 Level,
                 (LPBYTE) WkstaInfo->WkstaInfo502,
                 ErrorParameter,
                 &Parmnum
                 );

    if (status != NERR_Success) {
        goto CleanExit;
    }

    //
    // Set NT redirector specific fields
    //
    status = WsUpdateRedirToMatchWksta(
                 Parmnum,
                 ErrorParameter
                 );

    if (status != NERR_Success) {
        goto CleanExit;
    }

    //
    // Make updates "sticky" (update registry to match wksta).
    //
    WsUpdateRegistryToMatchWksta(
        Level,
        (LPBYTE) WkstaInfo->WkstaInfo502,
        ErrorParameter
        );

CleanExit:
    if (status != NERR_Success) {
        WSBUF = OriginalWksta;
    }
    RtlReleaseResource(&WsInfo.ConfigResource);
    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetrWkstaTransportEnum(
    IN  LPTSTR ServerName OPTIONAL,
    IN  OUT LPWKSTA_TRANSPORT_ENUM_STRUCT TransportInfo,
    IN  DWORD PreferedMaximumLength,
    OUT LPDWORD TotalEntries,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    )
/*++

Routine Description:

    This function is the NetWkstaTransportEnum entry point in the
    Workstation service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    TransportInfo - This structure supplies the level of information requested,
        returns a pointer to the buffer allocated by the Workstation service
        which contains a sequence of information structure of the specified
        information level, and returns the number of entries read.  The buffer
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.  The EntriesRead
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    PreferedMaximumLength - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, all available
        information will be returned.

    TotalEntries - Returns the total number of entries available.  This value
        is only valid if the return code is NERR_Success or ERROR_MORE_DATA.

    ResumeHandle - Supplies a handle to resume the enumeration from where it
        left off the last time through.  Returns the resume handle if return
        code is ERROR_MORE_DATA.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    LMR_REQUEST_PACKET Rrp;             // Redirector request packet
    DWORD EnumTransportHintSize = 0;    // Hint size from redirector

    LPBYTE Buffer;


    UNREFERENCED_PARAMETER(ServerName);

    //
    // Only level 0 is valid
    //
    if (TransportInfo->Level != 0) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // Set up request packet.  Output buffer structure is of enumerate
    // transport type.
    //
    Rrp.Version = REQUEST_PACKET_VERSION;
    Rrp.Type = EnumerateTransports;
    Rrp.Level = TransportInfo->Level;
    Rrp.Parameters.Get.ResumeHandle = (ARGUMENT_PRESENT(ResumeHandle)) ?
                                      *ResumeHandle : 0;

    //
    // Get the requested information from the redirector.
    //
    status = WsDeviceControlGetInfo(
                 Redirector,
                 WsRedirDeviceHandle,
                 FSCTL_LMR_ENUMERATE_TRANSPORTS,
                 &Rrp,
                 sizeof(LMR_REQUEST_PACKET),
                 &Buffer,
                 PreferedMaximumLength,
                 EnumTransportHintSize,
                 NULL
                 );

    //
    // Return output parameters
    //
    if (status == NERR_Success || status == ERROR_MORE_DATA) {
        SET_TRANSPORT_ENUM_POINTER(
            TransportInfo,
            Buffer,
            Rrp.Parameters.Get.EntriesRead
            );

        if (TransportInfo->WkstaTransportInfo.Level0 == NULL) 
        {
            LocalFree(Buffer);
        }

        *TotalEntries = Rrp.Parameters.Get.TotalEntries;

        if (status == ERROR_MORE_DATA && ARGUMENT_PRESENT(ResumeHandle)) {
            *ResumeHandle = Rrp.Parameters.Get.ResumeHandle;
        }

    }

    return status;
}



NET_API_STATUS NET_API_FUNCTION
NetrWkstaTransportAdd (
    IN  LPTSTR ServerName OPTIONAL,
    IN  DWORD Level,
    IN  LPWKSTA_TRANSPORT_INFO_0 TransportInfo,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function is the NetWkstaTransportAdd entry point in the
    Workstation service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    Level - Supplies the requested level of information.

    TransportInfo - Supplies the information structure to add a new transport.

    ErrorParameter - Returns the identifier to the invalid parameter if this
        function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{

    UNREFERENCED_PARAMETER(ServerName);

    //
    // Only admins can add a transport.  Validate access.
    //
    if (NetpAccessCheckAndAudit(
            WORKSTATION_DISPLAY_NAME,        // Subsystem name
            (LPTSTR) CONFIG_INFO_OBJECT,     // Object type name
            ConfigurationInfoSd,             // Security descriptor
            WKSTA_CONFIG_INFO_SET,           // Desired access
            &WsConfigInfoMapping             // Generic mapping
            ) != NERR_Success) {

        return ERROR_ACCESS_DENIED;
    }


    //
    // 0 is the only valid level
    //
    if (Level != 0) {
        return ERROR_INVALID_LEVEL;
    }

    if (TransportInfo->wkti0_transport_name == NULL) {
        RETURN_INVALID_PARAMETER(ErrorParameter, TRANSPORT_NAME_PARMNUM);
    }

    return WsBindTransport(
               TransportInfo->wkti0_transport_name,
               TransportInfo->wkti0_quality_of_service,
               ErrorParameter
               );
}



NET_API_STATUS NET_API_FUNCTION
NetrWkstaTransportDel (
    IN  LPTSTR ServerName OPTIONAL,
    IN  LPTSTR TransportName,
    IN  DWORD ForceLevel
    )
/*++

Routine Description:

    This function is the NetWkstaTransportDel entry point in the
    Workstation service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    TransportName - Supplies the name of the transport to delete.

    ForceLevel - Supplies the level of force to delete the tree connections on
        the transport we are unbinding from.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{

    UNREFERENCED_PARAMETER(ServerName);

    //
    // Only admins can delete a transport.  Validate access.
    //
    if (NetpAccessCheckAndAudit(
            WORKSTATION_DISPLAY_NAME,        // Subsystem name
            (LPTSTR) CONFIG_INFO_OBJECT,     // Object type name
            ConfigurationInfoSd,             // Security descriptor
            WKSTA_CONFIG_INFO_SET,           // Desired access
            &WsConfigInfoMapping             // Generic mapping
            ) != NERR_Success) {

        return ERROR_ACCESS_DENIED;
    }

    if (TransportName == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check that ForceLevel parameter is valid, which the redirector and
    // browser use to delete the connections on the transport we are
    // unbinding from.
    //
    switch (ForceLevel) {

        case USE_FORCE:
            ForceLevel = USE_NOFORCE;
            break;

        case USE_NOFORCE:
        case USE_LOTS_OF_FORCE:
            break;

        default:
            return ERROR_INVALID_PARAMETER;
    }

    return WsUnbindTransport(TransportName, ForceLevel);
}



STATIC
NET_API_STATUS
WsGetSystemInfo(
    IN  DWORD Level,
    OUT LPBYTE *BufferPointer
    )

/*++

Routine Description:

    This function calls the Redirector FSD, the LSA subsystem and the
    MSV1_0 authentication package, and the Datagram Receiver DD to get
    the system wide information returned by NetWkstaGetInfo API.

Arguments:

    Level - Supplies the requested level of information.

    BufferPointer - Returns a pointer to a buffer which contains the
        requested workstation information.


Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD NumberOfLoggedOnUsers = 1;

    //
    // Get number of logged on users from the MSV1_0 authentication package
    // if Level == 102.
    //
    if (Level == 102) {

        PMSV1_0_ENUMUSERS_RESPONSE EnumUsersResponse = NULL;

        //
        // Ask authentication package to enumerate users who are physically
        // logged to the local machine.
        //
        if ((status = WsLsaEnumUsers(
                          (LPBYTE *) &EnumUsersResponse
                          )) != NERR_Success) {
            return status;
        }

        if (EnumUsersResponse == NULL) {
            return ERROR_GEN_FAILURE;
        }

        NumberOfLoggedOnUsers = EnumUsersResponse->NumberOfLoggedOnUsers;

        (VOID) LsaFreeReturnBuffer(EnumUsersResponse);
    }

    //
    // Put all the data collected into output buffer allocated by this routine.
    //
    return WsFillSystemBufferInfo(
               Level,
               NumberOfLoggedOnUsers,
               BufferPointer
               );
}



STATIC
NET_API_STATUS
WsGetPlatformInfo(
    IN  DWORD Level,
    OUT LPBYTE *BufferPointer
    )
/*++

Routine Description:

    This function calls the Redirector FSD to get the Redirector platform
    specific information returned by NetWkstaGetInfo API.

Arguments:

    Level - Supplies the requested level of information.

    BufferPointer - Returns the pointer a buffer which contains the requested
        redirector specific information.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    LMR_REQUEST_PACKET Rrp;          // Redirector request packet
    PWKSTA_INFO_502 Info;

    //
    // There is only one redirector info level: 502.
    //
    NetpAssert(Level == 502);

    //
    // Set up request packet.  Output buffer structure is of configuration
    // information type.
    //
    Rrp.Version = REQUEST_PACKET_VERSION;
    Rrp.Level = Level;
    Rrp.Type = ConfigInformation;

    //
    // Get the requested information from the Redirector.  This routine
    // allocates the returned buffer.
    //
    status = WsDeviceControlGetInfo(
                 Redirector,
                 WsRedirDeviceHandle,
                 FSCTL_LMR_GET_CONFIG_INFO,
                 &Rrp,
                 sizeof(LMR_REQUEST_PACKET),
                 BufferPointer,
                 sizeof(WKSTA_INFO_502),
                 0,
                 NULL
                 );

    if (status == NERR_Success) {
        Info = (PWKSTA_INFO_502) *BufferPointer;

        //
        // Fill datagram receiver fields in level 502 structure from global
        // Workstation buffer (WSBUF).  There are no FSCtl APIs to get or
        // set them in the datagram receiver.
        //
        Info->wki502_num_mailslot_buffers =
            WSBUF.wki502_num_mailslot_buffers;
        Info->wki502_num_srv_announce_buffers =
            WSBUF.wki502_num_srv_announce_buffers;
        Info->wki502_max_illegal_datagram_events =
            WSBUF.wki502_max_illegal_datagram_events;
        Info->wki502_illegal_datagram_event_reset_frequency =
            WSBUF.wki502_illegal_datagram_event_reset_frequency;
        Info->wki502_log_election_packets =
            WSBUF.wki502_log_election_packets;;
    }

    return status;
}


NET_API_STATUS
WsValidateAndSetWksta(
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ErrorParameter OPTIONAL,
    OUT LPDWORD Parmnum
    )
/*++

Routine Description:

    This function sets the user specified config fields into the global
    WsInfo.WsConfigBuf (WSBUF) buffer and validates that the fields
    are valid.

    It returns the associated parmnum value so that the caller can
    specify it to the redirector.

Arguments:

    Level - Supplies the requested level of information.

    Buffer - Supplies a buffer which contains the user specified config
        fields.

    ErrorParameter - Receives the parmnum value of the field that is
        invalid if ERROR_INVALID_PARAMETER is returned.

    Parmnum - Receives the parmnum for the field(s) being set.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{

    DWORD i;

    //
    // Perform range checking
    //

    switch (Level) {

        case 502:     // Set all fields
            WSBUF = *((PWKSTA_INFO_502) Buffer);
            *Parmnum = PARMNUM_ALL;
            break;

        case 1010:    // char_wait
            WSBUF.wki502_char_wait = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_CHARWAIT_PARMNUM;
            break;

        case 1011:    // collection_time
            WSBUF.wki502_collection_time = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_CHARTIME_PARMNUM;
            break;

        case 1012:    // maximum_collection_count
            WSBUF.wki502_maximum_collection_count = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_CHARCOUNT_PARMNUM;
            break;

        case 1013:    // keep_conn
            WSBUF.wki502_keep_conn = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_KEEPCONN_PARMNUM;
            break;

        case 1018:    // sess_timeout
            WSBUF.wki502_sess_timeout = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_SESSTIMEOUT_PARMNUM;
            break;

        case 1023:    // siz_char_buf
            WSBUF.wki502_siz_char_buf = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_SIZCHARBUF_PARMNUM;
            break;

        case 1033:    // max_threads
            WSBUF.wki502_max_threads = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_MAXTHREADS_PARMNUM;
            break;

        case 1041:    // lock_quota
            WSBUF.wki502_lock_quota = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_LOCKQUOTA_PARMNUM;
            break;

        case 1042:    // lock_increment
            WSBUF.wki502_lock_increment = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_LOCKINCREMENT_PARMNUM;
            break;

        case 1043:    // lock_maximum
            WSBUF.wki502_lock_maximum = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_LOCKMAXIMUM_PARMNUM;
            break;

        case 1044:    // pipe_increment
            WSBUF.wki502_pipe_increment = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_PIPEINCREMENT_PARMNUM;
            break;

        case 1045:    // pipe_maximum
            WSBUF.wki502_pipe_maximum = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_PIPEMAXIMUM_PARMNUM;
            break;

        case 1046:    // dormant_file_limit
            WSBUF.wki502_dormant_file_limit = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_DORMANTFILELIMIT_PARMNUM;
            break;

        case 1047:    // cache_file_timeout
            WSBUF.wki502_cache_file_timeout = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_CACHEFILETIMEOUT_PARMNUM;
            break;

        case 1048:    // use_opportunistic_locking
            WSBUF.wki502_use_opportunistic_locking = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USEOPPORTUNISTICLOCKING_PARMNUM;
            break;

        case 1049:    // use_unlock_behind
            WSBUF.wki502_use_unlock_behind = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USEUNLOCKBEHIND_PARMNUM;
            break;

        case 1050:    // use_close_behind
            WSBUF.wki502_use_close_behind = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USECLOSEBEHIND_PARMNUM;
            break;

        case 1051:    // buf_named_pipes
            WSBUF.wki502_buf_named_pipes = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_BUFFERNAMEDPIPES_PARMNUM;
            break;

        case 1052:    // use_lock_read_unlock
            WSBUF.wki502_use_lock_read_unlock = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USELOCKANDREADANDUNLOCK_PARMNUM;
            break;

        case 1053:    // utilize_nt_caching
            WSBUF.wki502_utilize_nt_caching = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_UTILIZENTCACHING_PARMNUM;
            break;

        case 1054:    // use_raw_read
            WSBUF.wki502_use_raw_read = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USERAWREAD_PARMNUM;
            break;

        case 1055:    // use_raw_write
            WSBUF.wki502_use_raw_write = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USERAWWRITE_PARMNUM;
            break;

        case 1056:    // use_write_raw_data
            WSBUF.wki502_use_write_raw_data = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USEWRITERAWWITHDATA_PARMNUM;
            break;

        case 1057:    // use_encryption
            WSBUF.wki502_use_encryption = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USEENCRYPTION_PARMNUM;
            break;

        case 1058:    // buf_files_deny_write
            WSBUF.wki502_buf_files_deny_write = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_BUFFILESWITHDENYWRITE_PARMNUM;
            break;

        case 1059:    // buf_read_only_files
            WSBUF.wki502_buf_read_only_files = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_BUFFERREADONLYFILES_PARMNUM;
            break;

        case 1060:    // force_core_create_mode
            WSBUF.wki502_force_core_create_mode = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_FORCECORECREATEMODE_PARMNUM;
            break;

        case 1061:    // use_512_byte_max_transfer
            WSBUF.wki502_use_512_byte_max_transfer = *((LPBOOL) Buffer);
            *Parmnum = WKSTA_USE512BYTESMAXTRANSFER_PARMNUM;
            break;

        case 1062:    // read_ahead_throughput
            WSBUF.wki502_read_ahead_throughput = *((LPDWORD) Buffer);
            *Parmnum = WKSTA_READAHEADTHRUPUT_PARMNUM;
            break;

        default:
            if (ErrorParameter != NULL) {
                *ErrorParameter = PARM_ERROR_UNKNOWN;
            }
            return ERROR_INVALID_LEVEL;
    }


    for (i = 0; WsInfo.WsConfigFields[i].Keyword != NULL; i++) {

        //
        // Check the range of all fields.  If any fail, we return
        // ERROR_INVALID_PARAMETER.
        //
        if (((WsInfo.WsConfigFields[i].DataType == DWordType) &&
             (*(WsInfo.WsConfigFields[i].FieldPtr) <
                WsInfo.WsConfigFields[i].Minimum ||
              *(WsInfo.WsConfigFields[i].FieldPtr) >
                WsInfo.WsConfigFields[i].Maximum))
            ||
            ((WsInfo.WsConfigFields[i].DataType == BooleanType) &&
             (*(WsInfo.WsConfigFields[i].FieldPtr) != TRUE &&
              *(WsInfo.WsConfigFields[i].FieldPtr) != FALSE))) {

            //
            // We have a problem if this is not a field we want
            // to set, and we still happen to find a bad value.
            //
            NetpAssert((*Parmnum == PARMNUM_ALL) ||
                       (*Parmnum == WsInfo.WsConfigFields[i].Parmnum));

            IF_DEBUG(INFO) {
                NetpKdPrint((
                    PREFIX_WKSTA "Parameter %s has bad value %u, parmnum %u\n",
                    WsInfo.WsConfigFields[i].Keyword,
                    *(WsInfo.WsConfigFields[i].FieldPtr),
                    WsInfo.WsConfigFields[i].Parmnum
                    ));
            }

            RETURN_INVALID_PARAMETER(
                ErrorParameter,
                WsInfo.WsConfigFields[i].Parmnum
                );

        }
    }

    return NERR_Success;

}


NET_API_STATUS
WsUpdateRedirToMatchWksta(
    IN  DWORD Parmnum,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function calls the redirector to set the redirector platform specific
    information with the values found in the global WsInfo.WsConfigBuf (WSBUF)
    buffer.

Arguments:

    Parmnum - Supplies the parameter number of the field if a single field
        is being set.  If all fields are being set, this value is PARMNUM_ALL.


    ErrorParameter - Returns the identifier to the invalid parameter in Buffer
        if this function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS ApiStatus;
    LMR_REQUEST_PACKET Rrp;                   // Redirector request packet


    //
    // Set up request packet.  Input buffer structure is of configuration
    // information type.
    //
    Rrp.Version = REQUEST_PACKET_VERSION;
    Rrp.Level = 502;
    Rrp.Type = ConfigInformation;
    Rrp.Parameters.Set.WkstaParameter = Parmnum;

    //
    // Set the information in the Redirector.
    //
    ApiStatus = WsRedirFsControl(
                    WsRedirDeviceHandle,
                    FSCTL_LMR_SET_CONFIG_INFO,
                    &Rrp,
                    sizeof(LMR_REQUEST_PACKET),
                    (PVOID) &WSBUF,
                    sizeof(WSBUF),
                    NULL
                    );

    if (ApiStatus == ERROR_INVALID_PARAMETER && ARGUMENT_PRESENT(ErrorParameter)) {

        IF_DEBUG(INFO) {
            NetpKdPrint((
                PREFIX_WKSTA "NetrWkstaSetInfo: invalid parameter is %lu\n",
                Rrp.Parameters.Set.WkstaParameter));
        }

        *ErrorParameter = Rrp.Parameters.Set.WkstaParameter;
    }

    return ApiStatus;

}


VOID
WsUpdateRegistryToMatchWksta(
    IN  DWORD Level,
    IN  LPBYTE Buffer,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function calls the registry to update the platform specific
    information in the registry.

    If any write operation to the registry fails, there is nothing we can
    do about it because chances are good that we will not be able to back
    out the changes since that requires more writes to the registry.  When
    this happens, the discrepancy between the registry and the redirector
    will be straightened out when next key change notify occurs.

Arguments:

    Level - Supplies the level of information.

    Buffer - Supplies a buffer which contains the information structure
        to set.

    ErrorParameter - Returns the identifier to the invalid parameter in Buffer
        if this function returns ERROR_INVALID_PARAMETER.

Return Value:

    None.

--*/
{
    NET_API_STATUS ApiStatus;
    LPNET_CONFIG_HANDLE SectionHandle = NULL;
    DWORD i;


    //
    // Open section of config data.
    //
    ApiStatus = NetpOpenConfigData(
                    &SectionHandle,
                    NULL,                      // Local server.
                    SECT_NT_WKSTA,             // Section name.
                    FALSE                      // Don't want read-only access.
                    );

    if (ApiStatus != NERR_Success) {
        return;
    }

    //
    // Macro to update one value in the registry.
    // Assumes that Buffer starts with the new value for this field.
    //

#define WRITE_ONE_PARM_TO_REGISTRY( KeyNamePart, TypeFlag ) \
    { \
        if (TypeFlag == BooleanType) { \
            (void) WsSetConfigBool( \
                       SectionHandle, \
                       WKSTA_KEYWORD_ ## KeyNamePart, \
                       * ((LPBOOL) Buffer) ); \
        } else { \
            NetpAssert( TypeFlag == DWordType ); \
            (void) WsSetConfigDword( \
                       SectionHandle, \
                       WKSTA_KEYWORD_ ## KeyNamePart, \
                       * ((LPDWORD) Buffer) ); \
        } \
    }

    //
    // Update field based on the info level.
    //

    switch (Level) {

    case 502:     // Set all fields

        for (i = 0; WsInfo.WsConfigFields[i].Keyword != NULL; i++) {
            //
            // Write this field to the registry.
            //
            if (WsInfo.WsConfigFields[i].DataType == DWordType) {

                (void) WsSetConfigDword(
                           SectionHandle,
                           WsInfo.WsConfigFields[i].Keyword,
                           * ((LPDWORD) WsInfo.WsConfigFields[i].FieldPtr)
                           );

            } else {

                NetpAssert(WsInfo.WsConfigFields[i].DataType == BooleanType);

                (void) WsSetConfigBool(
                           SectionHandle,
                           WsInfo.WsConfigFields[i].Keyword,
                           * ((LPBOOL) WsInfo.WsConfigFields[i].FieldPtr)
                           );
            }
        }

        break;

    case 1010:    // char_wait
        WRITE_ONE_PARM_TO_REGISTRY( CHARWAIT, DWordType );
        break;

    case 1011:    // collection_time
        WRITE_ONE_PARM_TO_REGISTRY( COLLECTIONTIME, DWordType );
        break;

    case 1012:    // maximum_collection_count
        WRITE_ONE_PARM_TO_REGISTRY( MAXCOLLECTIONCOUNT, DWordType );
        break;

    case 1013:    // keep_conn
        WRITE_ONE_PARM_TO_REGISTRY( KEEPCONN, DWordType );
        break;

    case 1018:    // sess_timeout
        WRITE_ONE_PARM_TO_REGISTRY( SESSTIMEOUT, DWordType );
        break;

    case 1023:    // siz_char_buf
        WRITE_ONE_PARM_TO_REGISTRY( SIZCHARBUF, DWordType );
        break;

    case 1033:    // max_threads
        WRITE_ONE_PARM_TO_REGISTRY( MAXTHREADS, DWordType );
        break;

    case 1041:    // lock_quota
        WRITE_ONE_PARM_TO_REGISTRY( LOCKQUOTA, DWordType );
        break;

    case 1042:    // lock_increment
        WRITE_ONE_PARM_TO_REGISTRY( LOCKINCREMENT, DWordType );
        break;

    case 1043:    // lock_maximum
        WRITE_ONE_PARM_TO_REGISTRY( LOCKMAXIMUM, DWordType );
        break;

    case 1044:    // pipe_increment
        WRITE_ONE_PARM_TO_REGISTRY( PIPEINCREMENT, DWordType );
        break;

    case 1045:    // pipe_maximum
        WRITE_ONE_PARM_TO_REGISTRY( PIPEMAXIMUM, DWordType );
        break;

    case 1046:    // dormant_file_limit
        WRITE_ONE_PARM_TO_REGISTRY( DORMANTFILELIMIT, DWordType );
        break;

    case 1047:    // cache_file_timeout
        WRITE_ONE_PARM_TO_REGISTRY( CACHEFILETIMEOUT, DWordType );
        break;

    case 1048:    // use_opportunistic_locking
        WRITE_ONE_PARM_TO_REGISTRY( USEOPLOCKING, BooleanType );
        break;

    case 1049:    // use_unlock_behind
        WRITE_ONE_PARM_TO_REGISTRY( USEUNLOCKBEHIND, BooleanType );
        break;

    case 1050:    // use_close_behind
        WRITE_ONE_PARM_TO_REGISTRY( USECLOSEBEHIND, BooleanType );
        break;

    case 1051:    // buf_named_pipes
        WRITE_ONE_PARM_TO_REGISTRY( BUFNAMEDPIPES, BooleanType );
        break;

    case 1052:    // use_lock_read_unlock
        WRITE_ONE_PARM_TO_REGISTRY( USELOCKREADUNLOCK, BooleanType );
        break;

    case 1053:    // utilize_nt_caching
        WRITE_ONE_PARM_TO_REGISTRY( UTILIZENTCACHING, BooleanType );
        break;

    case 1054:    // use_raw_read
        WRITE_ONE_PARM_TO_REGISTRY( USERAWREAD, BooleanType );
        break;

    case 1055:    // use_raw_write
        WRITE_ONE_PARM_TO_REGISTRY( USERAWWRITE, BooleanType );
        break;

    case 1056:    // use_write_raw_data
        WRITE_ONE_PARM_TO_REGISTRY( USEWRITERAWDATA, BooleanType );
        break;

    case 1057:    // use_encryption
        WRITE_ONE_PARM_TO_REGISTRY( USEENCRYPTION, BooleanType );
        break;

    case 1058:    // buf_files_deny_write
        WRITE_ONE_PARM_TO_REGISTRY( BUFFILESDENYWRITE, BooleanType );
        break;

    case 1059:    // buf_read_only_files
        WRITE_ONE_PARM_TO_REGISTRY( BUFREADONLYFILES, BooleanType );
        break;

    case 1060:    // force_core_create_mode
        WRITE_ONE_PARM_TO_REGISTRY( FORCECORECREATE, BooleanType );
        break;

    case 1061:    // use_512_byte_max_transfer
        WRITE_ONE_PARM_TO_REGISTRY( USE512BYTEMAXTRANS, BooleanType );
        break;

    case 1062:    // read_ahead_throughput
        WRITE_ONE_PARM_TO_REGISTRY( READAHEADTHRUPUT, DWordType );
        break;


    default:
        //
        // This should never happen
        //
        NetpAssert(FALSE);
    }

    if (SectionHandle != NULL) {
        (VOID) NetpCloseConfigData( SectionHandle );
    }
}


STATIC
NET_API_STATUS
WsFillSystemBufferInfo(
    IN  DWORD Level,
    IN  DWORD NumberOfLoggedOnUsers,
    OUT LPBYTE *OutputBuffer
    )
/*++

Routine Description:

    This function calculates the exact length of the output buffer needed,
    allocates that amount, and fill the output buffer with all the requested
    system-wide workstation information.

    NOTE: This function assumes that info structure level 102 is a superset
          of info structure level 100 and 101, and that the offset to each
          common field is exactly the same.  This allows us to take
          advantage of a switch statement without a break between the levels.

Arguments:

    Level - Supplies the level of information to be returned.

    NumberOfLoggedOnUsers - Supplies the number of users logged on
        interactively.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which is filled with the requested system-wide workstation
        information.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failing to allocate the
        output buffer.

--*/
{
    PWKSTA_INFO_102 WkstaSystemInfo;

    LPBYTE FixedDataEnd;
    LPTSTR EndOfVariableData;

    DWORD SystemInfoFixedLength = SYSTEM_INFO_FIXED_LENGTH(Level);
    DWORD TotalBytesNeeded = SystemInfoFixedLength +
                             (WsInfo.WsComputerNameLength +
                              WsInfo.WsPrimaryDomainNameLength +
                              3) * sizeof(TCHAR);  // include NULL character
                                                   // for LAN root


    if ((*OutputBuffer = MIDL_user_allocate(TotalBytesNeeded)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID) *OutputBuffer, TotalBytesNeeded);

    WkstaSystemInfo = (PWKSTA_INFO_102) *OutputBuffer;

    FixedDataEnd = (LPBYTE) ((DWORD_PTR) *OutputBuffer + SystemInfoFixedLength);
    EndOfVariableData = (LPTSTR) ((DWORD_PTR) *OutputBuffer + TotalBytesNeeded);

    //
    // Put the data into the output buffer.
    //
    switch (Level) {

        case 102:

            WkstaSystemInfo->wki102_logged_on_users = NumberOfLoggedOnUsers;

        case 101:

            //
            // LAN root is set to NULL on NT.
            //
            NetpCopyStringToBuffer(
                NULL,
                0,
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaSystemInfo->wki102_lanroot
                );

        case 100:

            WkstaSystemInfo->wki102_platform_id = WsInfo.RedirectorPlatform;
            WkstaSystemInfo->wki102_ver_major = WsInfo.MajorVersion;
            WkstaSystemInfo->wki102_ver_minor = WsInfo.MinorVersion;

            NetpCopyStringToBuffer(
                WsInfo.WsComputerName,
                WsInfo.WsComputerNameLength,
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaSystemInfo->wki102_computername
                );

            NetpCopyStringToBuffer(
                WsInfo.WsPrimaryDomainName,
                WsInfo.WsPrimaryDomainNameLength,
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaSystemInfo->wki102_langroup
                );

            break;

        default:
            //
            // This should never happen.
            //
            NetpKdPrint(("WsFillSystemBufferInfo: Invalid level %lu\n", Level));
            NetpAssert(FALSE);
    }

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\wsconfig.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    wsconfig.h

Abstract:

    Private header file to be included by Workstation service modules that
    need to load Workstation configuration information.

Author:

    Rita Wong (ritaw) 22-May-1991

Revision History:

--*/


#ifndef _WSCONFIG_INCLUDED_
#define _WSCONFIG_INCLUDED_

#include <config.h>     // LPNET_CONFIG_HANDLE.

typedef enum _DATATYPE {
    BooleanType,
    DWordType
} DATATYPE, *PDATATYPE;

typedef struct _WS_REDIR_FIELDS {
    LPTSTR Keyword;
    LPDWORD FieldPtr;
    DWORD Default;
    DWORD Minimum;
    DWORD Maximum;
    DATATYPE DataType;
    DWORD Parmnum;
} WS_REDIR_FIELDS, *PWS_REDIR_FIELDS;

//
// Configuration information.  Reading and writing to this global
// structure requires that the resource be acquired first.
//
typedef struct _WSCONFIGURATION_INFO {

    RTL_RESOURCE ConfigResource;  // To serialize access to config
                                  //     fields.

    TCHAR WsComputerName[MAX_PATH + 1];
    DWORD WsComputerNameLength;
    TCHAR WsPrimaryDomainName[DNLEN + 1];
    DWORD WsPrimaryDomainNameLength;
    DWORD RedirectorPlatform;
    DWORD MajorVersion;
    DWORD MinorVersion;
    WKSTA_INFO_502 WsConfigBuf;
    PWS_REDIR_FIELDS WsConfigFields;

} WSCONFIGURATION_INFO, *PWSCONFIGURATION_INFO;

extern WSCONFIGURATION_INFO WsInfo;

#define WSBUF      WsInfo.WsConfigBuf

extern BOOLEAN WsBrowserPresent;

NET_API_STATUS
WsGetWorkstationConfiguration(
    VOID
    );

NET_API_STATUS
WsBindToTransports(
    VOID
    );

NET_API_STATUS
WsAddDomains(
    VOID
    );

VOID
WsUpdateWkstaToMatchRegistry(
    IN LPNET_CONFIG_HANDLE WorkstationSection,
    IN BOOL IsWkstaInit
    );

VOID
WsLogEvent(
    DWORD MessageId,
    WORD EventType,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings,
    DWORD ErrorCode
    );

NET_API_STATUS
WsSetWorkStationDomainName(
    VOID
    );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\wsbind.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    wsbind.h

Abstract:

    Private header file to be included by Workstation service modules that
    need to call into the NT Redirector and the NT Datagram Receiver.

Author:

    Vladimir Z. Vulovic     (vladimv)       August - 08 -1991

Revision History:

--*/


#ifndef _WSBIND_INCLUDED_
#define _WSBIND_INCLUDED_

typedef struct _WS_BIND_REDIR {
    HANDLE              EventHandle;    
    BOOL                Bound;
    IO_STATUS_BLOCK     IoStatusBlock;
    LMR_REQUEST_PACKET  Packet;
} WS_BIND_REDIR, *PWS_BIND_REDIR;

typedef struct _WS_BIND_DGREC {
    HANDLE              EventHandle;    
    BOOL                Bound;
    IO_STATUS_BLOCK     IoStatusBlock;
    LMDR_REQUEST_PACKET  Packet;
} WS_BIND_DGREC, *PWS_BIND_DGREC;

typedef struct _WS_BIND {
    LIST_ENTRY          ListEntry;
    PWS_BIND_REDIR      Redir;
    PWS_BIND_DGREC      Dgrec;
    ULONG               TransportNameLength;  // not including terminator
    WCHAR               TransportName[1];     // Name of transport provider
} WS_BIND, *PWS_BIND;


NET_API_STATUS
WsAsyncBindTransport(
    IN  LPTSTR          transportName,
    IN  DWORD           qualityOfService,
    IN  PLIST_ENTRY     pHeader
    );

VOID
WsUnbindTransport2(
    IN  PWS_BIND        pBind
    );

extern HANDLE   WsRedirAsyncDeviceHandle;   // redirector
extern HANDLE   WsDgrecAsyncDeviceHandle;   // datagram receiver or "bowser"

#endif // ifndef _WSBIND_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\wsdfs.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    wsdfs.h

Abstract:

    Private header file to be included by Workstation service modules that
    interact with the Dfs server thread.

Author:

    Milan Shah (milans) 29-Feb-1996

Revision History:

--*/

#ifndef _WSDFS_INCLUDED_
#define _WSDFS_INCLUDED_

#define DFS_MSGTYPE_TERMINATE           0x0001
#define DFS_MSGTYPE_GET_DOMAIN_REFERRAL 0x0002
#define DFS_MSGTYPE_GET_DC_NAME         0x0003

NET_API_STATUS
WsInitializeDfs();

VOID
WsShutdownDfs();

#endif // ifndef _WSUSE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\wkssvc\server\wsdevice.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsdevice.h

Abstract:

    Private header file to be included by Workstation service modules that
    need to call into the NT Redirector and the NT Datagram Receiver.

Author:

    Rita Wong (ritaw) 15-Feb-1991

Revision History:

--*/

#ifndef _WSDEVICE_INCLUDED_
#define _WSDEVICE_INCLUDED_

#include <ntddnfs.h>                  // Redirector include file

#include <ntddbrow.h>                 // Datagram receiver include file

//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

typedef enum _DDTYPE {
    Redirector,
    DatagramReceiver
} DDTYPE, *PDDTYPE;


//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes of support routines found in wsdevice.c       //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
WsDeviceControlGetInfo(
    IN  DDTYPE DeviceDriverType,
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPBYTE *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG_PTR Information OPTIONAL
    );

NET_API_STATUS
WsInitializeRedirector(
    VOID
    );

NET_API_STATUS
WsShutdownRedirector(
    VOID
    );

NET_API_STATUS
WsRedirFsControl (
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PLMR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG_PTR Information OPTIONAL
    );

NET_API_STATUS
WsDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG_PTR Information OPTIONAL
    );

NET_API_STATUS
WsBindTransport(
    IN  LPTSTR TransportName,
    IN  DWORD QualityOfService,
    OUT LPDWORD ErrorParameter OPTIONAL
    );

NET_API_STATUS
WsUnbindTransport(
    IN LPTSTR TransportName,
    IN DWORD ForceLevel
    );

NET_API_STATUS
WsDeleteDomainName(
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  DWORD DrpLength,
    IN  LPTSTR DomainName,
    IN  DWORD DomainNameSize
    );

NET_API_STATUS
WsAddDomainName(
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  DWORD DrpLength,
    IN  LPTSTR DomainName,
    IN  DWORD DomainNameSize
    );

NET_API_STATUS
WsUnloadDriver(
    IN LPTSTR DriverNameString
    );

NET_API_STATUS
WsLoadDriver(
    IN LPWSTR DriverNameString
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

// Global Registry key definitions for the new Redirector

#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

#define SMB_MINIRDR L"MRxSmb"
#define RDBSS       L"Rdbss"

// the key definition is relative to HKEY_LOCAL_MACHINE
#define MR